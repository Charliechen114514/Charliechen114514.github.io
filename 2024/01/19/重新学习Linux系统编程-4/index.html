<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>重新学习Linux系统编程-4 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="重新学习Linux系统 4高级文件IO分散&#x2F;集聚 IO​        它指的是单次的系统调用中对多个缓冲区输入输出的办法，可以把多个缓冲区的数据写入单个数据流中 ​        与线性的相比，分散IO具有这些有时  编码格式更加自然：对于那些数据本身分段的，向量IO提供了更加直观的数据处理 效率更高：向量IO可以看作是按照一定方式集成的多个线性IO 性能更好：处理减少发起的系统调用的次数以外，">
<meta property="og:type" content="article">
<meta property="og:title" content="重新学习Linux系统编程-4">
<meta property="og:url" content="http://charliechen114514.github.io/2024/01/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="重新学习Linux系统 4高级文件IO分散&#x2F;集聚 IO​        它指的是单次的系统调用中对多个缓冲区输入输出的办法，可以把多个缓冲区的数据写入单个数据流中 ​        与线性的相比，分散IO具有这些有时  编码格式更加自然：对于那些数据本身分段的，向量IO提供了更加直观的数据处理 效率更高：向量IO可以看作是按照一定方式集成的多个线性IO 性能更好：处理减少发起的系统调用的次数以外，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2024-01-19T12:04:36.000Z">
<meta property="article:modified_time" content="2024-01-19T12:07:43.465Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2024/01/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '重新学习Linux系统编程-4',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-19 20:07:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">重新学习Linux系统编程-4</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-19T12:04:36.000Z" title="发表于 2024-01-19 20:04:36">2024-01-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-19T12:07:43.465Z" title="更新于 2024-01-19 20:07:43">2024-01-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="重新学习Linux系统编程-4"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="重新学习Linux系统-4"><a href="#重新学习Linux系统-4" class="headerlink" title="重新学习Linux系统 4"></a>重新学习Linux系统 4</h1><h2 id="高级文件IO"><a href="#高级文件IO" class="headerlink" title="高级文件IO"></a>高级文件IO</h2><h3 id="分散-集聚-IO"><a href="#分散-集聚-IO" class="headerlink" title="分散/集聚 IO"></a>分散/集聚 IO</h3><p>​        它指的是单次的系统调用中对多个缓冲区输入输出的办法，可以把多个缓冲区的数据写入单个数据流中</p>
<p>​        与线性的相比，分散IO具有这些有时</p>
<ol>
<li>编码格式更加自然：对于那些数据本身分段的，向量IO提供了更加直观的数据处理</li>
<li>效率更高：向量IO可以看作是按照一定方式集成的多个线性IO</li>
<li>性能更好：处理减少发起的系统调用的次数以外，还可以由于内部的优化二有更好的性能</li>
<li>支持原子操作</li>
</ol>
<h4 id="readv-amp-amp-writev"><a href="#readv-amp-amp-writev" class="headerlink" title="readv &amp;&amp; writev"></a>readv &amp;&amp; writev</h4><p>​        也就是readVector和writeVector的意思，API接口如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/uio.h></span></span>
<span class="token class-name">ssize_t</span> <span class="token function">readv</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token operator">*</span>iov<span class="token punctuation">,</span> <span class="token keyword">int</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ssize_t</span> <span class="token function">writev</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">iovec</span> <span class="token operator">*</span>iov<span class="token punctuation">,</span> <span class="token keyword">int</span> iovcnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        每一个iovec都是这样的一个结构体：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/uio.h></span></span>

<span class="token keyword">struct</span> <span class="token class-name">iovec</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">void</span><span class="token operator">*</span> 	iov_base<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> 	iov_len<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们count这个字段就是说明要处理多少个数据段。</p>
<p>​        这两个函数就是返回的处理的字节数目。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>​        <strong><code>epoll</code></strong>是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Linux">Linux</a>内核的可扩展I/O事件通知机制，让需要大量操作<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/檔案描述子">文件描述符</a>的程序得以发挥更优异的性能（举例来说：旧有的系统函数所花费的时间复杂度为O(n)，<code>epoll</code>的时间复杂度O(log n)）。epoll 实现的功能与 poll 类似，都是监听多个文件描述符上的事件。</p>
<p>​        <code>epoll</code>与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/FreeBSD">FreeBSD</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Kqueue"><code>kqueue</code></a>类似，底层都是由可配置的操作系统内核对象建构而成，并以文件描述符(file descriptor)的形式呈现于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/使用者空間">用户空间</a>。<code>epoll</code> 通过使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/红黑树">红黑树</a>(RB-tree)搜索被监控的文件描述符(file descriptor)。</p>
<p>​        在 epoll 实例上注册事件时，epoll 会将该事件添加到 epoll 实例的红黑树上并注册一个回调函数，当事件发生时会将事件添加到就绪链表中。</p>
<h4 id="创建epoll"><a href="#创建epoll" class="headerlink" title="创建epoll"></a>创建epoll</h4><pre class="line-numbers language-none"><code class="language-none">int epoll_create(int size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在内核中创建<code>epoll</code>实例并返回一个<code>epoll</code>文件描述符。 在最初的实现中，调用者通过 <code>size</code> 参数告知内核需要监听的文件描述符数量。如果监听的文件描述符数量超过 size, 则内核会自动扩容。而现在 size 已经没有这种语义了，但是调用者调用时 size 依然必须大于 0，以保证后向兼容性。</p>
<h4 id="操作epoll"><a href="#操作epoll" class="headerlink" title="操作epoll"></a>操作epoll</h4><pre class="line-numbers language-none"><code class="language-none">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        向 epfd 对应的内核<code>epoll</code> 实例添加、修改或删除对 fd 上事件 event 的监听。op 可以为 <code>EPOLL_CTL_ADD</code>, <code>EPOLL_CTL_MOD</code>, <code>EPOLL_CTL_DEL</code> 分别对应的是添加新的事件，修改文件描述符上监听的事件类型，从实例上删除一个事件。如果 event 的 events 属性设置了 <code>EPOLLET</code> flag，那么监听该事件的方式是边缘触发。</p>
<h4 id="等待epoll事件"><a href="#等待epoll事件" class="headerlink" title="等待epoll事件"></a>等待epoll事件</h4><pre class="line-numbers language-none"><code class="language-none">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当 timeout 为 0 时，epoll_wait 永远会立即返回。而 timeout 为 -1 时，epoll_wait 会一直阻塞直到任一已注册的事件变为就绪。当 timeout 为一正整数时，epoll 会阻塞直到计时 timeout 毫秒终了或已注册的事件变为就绪。因为内核调度延迟，阻塞的时间可能会略微超过 timeout 毫秒。</p>
<h4 id="触发模式"><a href="#触发模式" class="headerlink" title="触发模式"></a>触发模式</h4><p><code>epoll</code>提供<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/中断#边沿触发">边沿触发</a>及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/中断#状态触发">状态触发</a>模式。在边沿触发模式中，<code>epoll_wait</code>仅会在新的事件首次被加入<code>epoll</code>队列时返回；于level-triggered模式下，<code>epoll_wait</code>在事件状态未变更前将不断被触发。状态触发模式是默认的模式。</p>
<p>​        状态触发模式与边沿触发模式有读和写两种情况，我们先来考虑读的情况。假设我们注册了一个读事件到<code>epoll</code>实例上，<code>epoll</code>实例会通过<code>epoll_wait</code>返回值的形式通知我们哪些读事件已经就绪。简单地来说，在状态触发模式下，如果读事件未被处理，该事件对应的内核读缓冲器非空，则每次调用 <code>epoll_wait</code> 时返回的事件列表都会包含该事件。直到该事件对应的内核读缓冲器为空为止。而在边沿触发模式下，读事件就绪后只会通知一次，不会反复通知。</p>
<p>​        然后我们再考虑写的情况。水平触发模式下，只要文件描述符对应的内核写缓冲器未满，就会一直通知可写事件。而在边沿触发模式下，内核写缓冲器由满变为未满后，只会通知一次可写事件。</p>
<p>​        举例来说，倘若有一个已经于<code>epoll</code>注册之<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Anonymous_pipe">流水线</a>接获资料，<code>epoll_wait</code>将返回，并发出资料读取的信号。现假设缓冲器的资料仅有部分被读取并处理，在level-triggered模式下，任何对<code>epoll_wait</code>之调用都将即刻返回，直到缓冲器中的资料全部被读取；然而，在edge-triggered的情境下，<code>epoll_wait</code>仅会于再次接收到新资料(亦即，新资料被写入流水线)时返回。</p>
<h3 id="边沿触发模式-编辑"><a href="#边沿触发模式-编辑" class="headerlink" title="边沿触发模式[编辑]"></a>边沿触发模式[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Epoll&amp;action=edit&amp;section=3">编辑</a>]</h3><p>边沿触发模式使得程序有可能在用户态缓存 IO 状态。nginx 使用的是边沿触发模式。</p>
<p>文件描述符有两种情况是推荐使用边沿触发模式的。</p>
<ol>
<li>read 或者 write 系统调用返回了 EAGAIN。</li>
<li>非阻塞的文件描述符。</li>
</ol>
<p>可能的缺陷：</p>
<ol>
<li>如果 IO 空间很大，你要花很多时间才能把它一次读完，这可能会导致饥饿。举个例子，假设你在监听一个文件描述符列表，而某个文件描述符上有大量的输入（不间断的输入流），那么你在读完它的过程中就没空处理其他就绪的文件描述符。（因为边沿触发模式只会通知一次可读事件，所以你往往会想一次把它读完。）一种解决方案是，程序维护一个就绪队列，当 <code>epoll</code> 实例通知某文件描述符就绪时将它在就绪队列数据结构中标记为就绪，这样程序就会记得哪些文件描述符等待处理。Round-Robin 循环处理就绪队列中就绪的文件描述符即可。</li>
<li>如果你缓存了所有事件，那么一种可能的情况是 A 事件的发生让程序关闭了另一个文件描述符 B。但是内核的 <code>epoll</code> 实例并不知道这件事，需要你从 <code>epoll</code> 删除掉。</li>
</ol>
<h2 id="存储映射"><a href="#存储映射" class="headerlink" title="存储映射"></a>存储映射</h2><p>​        我们想要说的就是mmap函数系列。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;mman.h&gt;

void *mmap(void addr[.length], size_t length, int prot, int flags,int fd, off_t offset);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        mmap的参数说明如下：</p>
<blockquote>
<ol>
<li><p>addr告诉我内核映射文件的最佳地址，一般而言传递的是0</p>
</li>
<li><p>prot描述了我们的访问权限：PROT_NONE就是无法访问（不用）。其余的参数看下面：</p>
<pre class="line-numbers language-none"><code class="language-none">PROT_EXEC
       Pages may be executed.
   
PROT_READ
       Pages may be read.
   
PROT_WRITE
       Pages may be written.
   
PROT_NONE
       Pages may not be accessed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面说说flag参数：</p>
<pre class="line-numbers language-none"><code class="language-none">MAP_SHARED
       Share this mapping.  Updates to the mapping are visible to
       other processes mapping the same region, and (in the case
       of file-backed mappings) are carried through to the
       underlying file.  (To precisely control when updates are
       carried through to the underlying file requires the use of
       msync(2).)
   
MAP_SHARED_VALIDATE (since Linux 4.15)
       This flag provides the same behavior as MAP_SHARED except
       that MAP_SHARED mappings ignore unknown flags in flags.
       By contrast, when creating a mapping using
       MAP_SHARED_VALIDATE, the kernel verifies all passed flags
       are known and fails the mapping with the error EOPNOTSUPP
       for unknown flags.  This mapping type is also required to
       be able to use some mapping flags (e.g., MAP_SYNC).
   
MAP_PRIVATE
       Create a private copy-on-write mapping.  Updates to the
       mapping are not visible to other processes mapping the
       same file, and are not carried through to the underlying
       file.  It is unspecified whether changes made to the file
       after the mmap() call are visible in the mapped region.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</blockquote>
<p>​        这个函数实际上就是把文件的读写映射到了内存里——访问内存读写速度显然比访问文件要快。</p>
<p>​        但是我们不能滥用mmap，正确使用才会让他的效率最大化，这里我们先介绍页的概念：</p>
<p>​        页是MMU的粒度单元，mmap的基本块就是页。所以，我们映射的大小就是页的整数倍。查看当前页的方法是调用sysconf函数而不是直接使用暴露的宏<code>PAGE_SIZE</code></p>
<h4 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h4><pre class="line-numbers language-none"><code class="language-none">int munmap(void addr[.length], size_t length);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        取消我们的映射。</p>
<h4 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote>
<p>我们可以直接减少数据的拷贝操作（比起来向用户缓冲区读写然后拷贝到磁盘）</p>
<ol>
<li>减少潜在的页错误，我们直接操作内存</li>
<li>搜索对象直接用指针偏移而不用lseek</li>
<li>当多个进程把同一个对象映射到内存时，数据会在所有进程间共享，只读和写共享的映射在群体中都是共享的。私有可写的映射对尚未进行写时拷贝的也是共享的 </li>
</ol>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<p>由于映射区域的大小总是页大小的整倍数所以文件大小与叶大小倍数之间存在空间浪费，所以这种使用方式不适合用于小文件</p>
<p>其次存储映射区域必须在进程地址空间内，对于32位的地址空间大量的，大小不同的映射会导致生成大量的碎片，使得难以找到连续的大片空内存</p>
<p>创建和维护映射以及相关的内核数据结构是有一定开销的，不过如上所示，由于这个调用消除了读写时的不必要拷贝，这样的开销几乎可以忽略。对于大文件和频繁访问的文件更是如此 </p>
</blockquote>
<h4 id="mremap"><a href="#mremap" class="headerlink" title="mremap"></a>mremap</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mremap</span><span class="token punctuation">(</span><span class="token keyword">void</span> old_address<span class="token punctuation">[</span><span class="token punctuation">.</span>old_size<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> old_size<span class="token punctuation">,</span><span class="token class-name">size_t</span> new_size<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* void *new_address */</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        也就是动态调整映射区域的大小</p>
<h4 id="posix-fadvise-系统调用"><a href="#posix-fadvise-系统调用" class="headerlink" title="posix_fadvise()系统调用"></a>posix_fadvise()系统调用</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span>
<span class="token keyword">int</span> <span class="token function">posix_fadvise</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> off_t offset<span class="token punctuation">,</span> off_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> advice<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对posix_fadvise()的调用为内核提供了文件描述符fd上的对于[offset, offset+len)这一段的建议。如果len为0，则建议将应用于范围[offset，length of file]。<br>可供选择的advice参数有：</p>
<ul>
<li>POSIX_FADV_NORMAL<br>应用程序没有关于此文件范围的特定通知。它应该被视为正常。<br>内核像往常一样运行，执行适量的readahead操作。</li>
<li>POSIX_FADV_RANDOM<br>应用程序打算访问特定的数据以随机的方式。<br>内核禁用readahead，只读取每个物理读取操作的最小数据量。</li>
<li>POSIX_FADV_SEQUENTIAL<br>应用程序打算顺序地访问指定范围内的数据，从低地址到高地址。<br>内核执行积极的readahead，使readahead读取窗口的大小加倍。</li>
<li>POSIX_FADV_WILLNEED<br>应用程序打算在不久的将来访问指定范围内的数据。<br>内核启动readahead，开始读取给定页面的内存。</li>
<li>POSIX_FADV_NOREUSE<br>应用程序打算在不久的将来访问指定范围内的数据，但只访问 就一次。<br>-POSIX_FADV_DONTNEED<br>应用程序不打算在不久的将来访问指定范围内的页面。<br>当前，该行为与POSIX_FADV_WILLNEED相同；未来的内核可能会执行额外的优化来利用“一次性使用”行为。<br>内核从页面缓存中删除给定范围内的任何缓存数据。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//example</span>
<span class="token keyword">int</span> ret<span class="token punctuation">;</span>
ret <span class="token operator">=</span> <span class="token function">posix_fadvise</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> POSIX_FADV_RANDOM<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"posix_fadvise"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>成功后，返回0。如果失败，则返回−1，并设置errno。</p>
<h4 id="readahead-系统调用"><a href="#readahead-系统调用" class="headerlink" title="readahead()系统调用"></a>readahead()系统调用</h4><p>posix_fadvise()系统调用对于2.6Linux内核来说是新的。readahead()系统调用以前就有了，与POSIX_FADV_WILLNEED提示有相同的行为。<br><strong>与posix_fadvise()不同的是, readahead() 是linux专属接口。</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_GNU_SOURCE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span>
ssize_t <span class="token function">readahead</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> off64_t offset<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对readahead()的调用将从文件描述符fd中的区域[offset，偏offset+count)填充到页面缓存中。<br>成功后，readahead()返回0。如果失败，则返回−1，并设置errno。</p>
<p>​        一些常见的应用程序工作负载可以很容易地受益于对内核的一些善意的建议。这样的建议可以大大减轻I/O的负担。在读取文件块之前，进程可以提供POSIX_FADV_WILLNEED提示，指示内核将文件读入页缓存。I/O将在后台异步发生。 当应用程序最终访问文件时，操作可以没有阻塞的完成。</p>
<p>​        相反，在读取或写入大量数据(例如，将视频连续流写到磁盘时)，进程可以提供POSIX_FADV_DONTNEED提示，指示内核排除页缓存中给定的文件块。一个大的流操作可以持续地填充页面缓存.如果应用程序不再打算访问数据，这意味着页面缓存将充满多余的数据。 以牺牲潜在更有用的数据为代价。因此，流视频应用程序定期请求将流数据从缓存中清除是有意义的。</p>
<p>​        打算读取整个文件的进程可以提供POSIX_FADV_SEQUENTIAL提示，指示内核执行积极的readahead。相反的，一个进程知道自己会随机处理一个文件，寻求来回，可以提供POSIX_FADV_RANDOM提示，指示内核readahead将是毫无价值的开销。</p>
<h3 id="常见的IO调度器"><a href="#常见的IO调度器" class="headerlink" title="常见的IO调度器"></a>常见的IO调度器</h3><p>​        为什么会有IO调度器呢？原因是处理速度和磁盘访问速度的不匹配。它实际上就是将多次访问合并，按照区块号码排列，这样我们的磁头就不会乱序的访问而是顺序的访问得到数据。</p>
<ol>
<li><h4 id="Noop调度器"><a href="#Noop调度器" class="headerlink" title="Noop调度器"></a>Noop调度器</h4><p>：Noop（No Operation）调度器是最简单的IO调度器，它实际上不做任何调度，只是按照请求的顺序将IO请求传递给硬件。这种调度器适用于具有自身硬件级IO调度机制的设备，如SSD。</p>
<p><img src="a89445ad6c225b61a990f684b4b0d92d.png" alt="img"></p>
</li>
<li><h4 id="CFQ调度器"><a href="#CFQ调度器" class="headerlink" title="CFQ调度器"></a>CFQ调度器</h4><p>（Completely Fair Queuing）：CFQ调度器的目标是为所有进程提供公平的IO服务。它将每个进程的IO请求放入单独的队列中，并按时间片分配IO服务。这样可以保证每个进程都能得到一定的IO带宽，提高系统的整体响应</p>
<p><img src="06f7be7f03989f41bea16e203663ddab.png" alt="img"></p>
</li>
</ol>
<ol>
<li><h4 id="Deadline调度器"><a href="#Deadline调度器" class="headerlink" title="Deadline调度器"></a>Deadline调度器</h4><p>：Deadline调度器旨在保证IO请求的延迟。它为每个IO请求设置一个截止时间，优先处理接近截止时间的请求。此外，它还区分同步和异步请求，确保同步请求（通常是交互式操作）能得到及时处理。</p>
<p><img src="efb4fc5eac2937313e0cadca879dd7f0.png" alt="img"></p>
</li>
<li><h4 id="Anticipatory调度器："><a href="#Anticipatory调度器：" class="headerlink" title="Anticipatory调度器："></a><strong>Anticipatory调度器</strong>：</h4><p>Anticipatory调度器是在CFQ调度器基础上的一种优化。它的基本思想是，在处理完一个IO请求后，故意延迟一段时间再处理下一个请求。这个延迟的时间预期用户在读取数据后可能会有新的读取请求，这样可以减少磁头的寻道次数，提高磁盘的效率。然而，这种调度器对于随机写入操作或者SSD等无寻道延迟的设备来说效果不佳。</p>
</li>
<li><h4 id="MQ-Deadline和MQ-None："><a href="#MQ-Deadline和MQ-None：" class="headerlink" title="MQ-Deadline和MQ-None："></a><strong>MQ-Deadline和MQ-None</strong>：</h4><p>这两种调度器是为多队列硬盘驱动器设计的。MQ-Deadline与普通的Deadline调度器类似，但每个硬件队列都有自己的调度策略。MQ-None则类似于Noop调度器，不对IO请求做任何调度，直接将请求发送到硬件队列。</p>
</li>
</ol>
<p>​        选择哪种IO调度器取决于具体的硬件特性和工作负载需求。例如，对于SSD等高速存储设备，通常推荐使用Noop或Deadline调度器，因为这些设备的内部已经具有高效的硬件级调度机制。而对于传统的机械硬盘，CFQ或Deadline调度器可能更适合，因为他们能够更好地管理磁头的寻道和旋转延迟。</p>
<h2 id="程序，进程和线程的基本概念"><a href="#程序，进程和线程的基本概念" class="headerlink" title="程序，进程和线程的基本概念"></a>程序，进程和线程的基本概念</h2><p>​        程序指的是编译过后的，，可以执行的二进制程序，一般而言，他们被保存在磁盘介质上</p>
<p>​        进程则是指代的正在运行程序，他们被加载到进程上被CPU选中执行，线程就是进程内的活动单元。</p>
<h3 id="pid"><a href="#pid" class="headerlink" title="pid"></a>pid</h3><p>​        pid是标识进程的一个标识符，是一个整数：第一个进程也就是线程他自己是0号进程，初始化的init进程是1号进程，其他派生的进程号就有其自己对应的进程号。</p>
<p>​        进程分配上一般是达到上限后才会重用之前的pid号，否则只会递增不会递减。其pid的类型是pid_t。我们这样获取pid号：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;types.h&gt;
#include &lt;unistd.h&gt;

pid_t getpid(); &#x2F;&#x2F; 得到当前进程的pid号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="运行新的进程"><a href="#运行新的进程" class="headerlink" title="运行新的进程"></a>运行新的进程</h3><p>​        我们现在要运行全新的进程，使用的就是exec类的系统调用。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;unistd.h&gt;

      extern char **environ;

      int execl(const char *pathname, const char *arg, ...
                      &#x2F;*, (char *) NULL *&#x2F;);
      int execlp(const char *file, const char *arg, ...
                      &#x2F;*, (char *) NULL *&#x2F;);
      int execle(const char *pathname, const char *arg, ...
                      &#x2F;*, (char *) NULL, char *const envp[] *&#x2F;);
      int execv(const char *pathname, char *const argv[]);
      int execvp(const char *file, char *const argv[]);
      int execvpe(const char *file, char *const argv[], char *const envp[]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们重点看看execl，他会把path指向的映像加载到内存，替换当前的进程，一个合适的例子是：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> ret<span class="token punctuation">;</span>

ret <span class="token operator">=</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token string">"/bin/vi"</span><span class="token punctuation">,</span> <span class="token string">"vi"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"execl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        execl一般会跳转到新的程序不会返回，我们就可以在这句话的后面加上这个调用来查看是否存在出错。他会改变线程的一些属性：</p>
<blockquote>
<ol>
<li>所有挂起的信号都会丢失</li>
<li>捕捉到的所有信号都会还原为默认处理方，式因为信号处理函数已经不再地址空间中</li>
<li>丢失所有内存锁</li>
<li>大多数线程的属性会还原成默认值</li>
<li>重置刷新大多数进程相关的统计信息</li>
<li>清空和进程内存地址空间相关的所有数据，包括所有映射的文件</li>
<li>清空所有只存在于内存空间的数据包括c库的一些功能</li>
</ol>
</blockquote>
<p>​        下面是他可能返回的错误：</p>
<pre class="line-numbers language-none"><code class="language-none">Errors
E2BIG
The total number of bytes in the environment (envp) and argument list (argv) is too large.

EACCES

Search permission is denied on a component of the path prefix of filename or the name of a script interpreter. (See also path_resolution(7).)

EACCES

The file or a script interpreter is not a regular file.

EACCES

Execute permission is denied for the file or a script or ELF interpreter.

EACCES

The file system is mounted noexec.

EFAULT

filename points outside your accessible address space.

EINVAL

An ELF executable had more than one PT_INTERP segment (i.e., tried to name more than one interpreter).

EIO

An I&#x2F;O error occurred.

EISDIR

An ELF interpreter was a directory.

ELIBBAD
An ELF interpreter was not in a recognized format.
ELOOP
Too many symbolic links were encountered in resolving filename or the name of a script or ELF interpreter.

EMFILE

The process has the maximum number of files open.

ENAMETOOLONG
filename is too long.
ENFILE
The system limit on the total number of open files has been reached.

ENOENT

The file filename or a script or ELF interpreter does not exist, or a shared library needed for file or interpreter cannot be found.

ENOEXEC
An executable is not in a recognized format, is for the wrong architecture, or has some other format error that means it cannot be executed.
ENOMEM
Insufficient kernel memory was available.

ENOTDIR
A component of the path prefix of filename or a script or ELF interpreter is not a directory.
EPERM
The file system is mounted nosuid, the user is not the superuser, and the file has the set-user-ID or set-group-ID bit set.

EPERM

The process is being traced, the user is not the superuser and the file has the set-user-ID or set-group-ID bit set.

ETXTBSY
Executable was open for writing by one or more processes.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这个系统调用将会发起一个新的进程，对于父进程，他返回的是子进程的pid，对于子进程来看，则是0（可以认为是从这里开始分叉产生父子进程的说法），所以一个经典的使用案例是：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pid_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Father!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Child process!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现代的fork调用都是采用的写时复制的操作，也就是说在没有发生写操作的时候是共享父进程的页的，直到发生写操作的时候才会触发拷贝操作。</p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span>
<span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这个函数执行退出操作，C库总是会执行以下几个经典的操作：</p>
<blockquote>
<p>任何由<code>atexit()</code>或<code>on_exit</code>注册的函数，和在系统中注册时顺序相反。</p>
<p>清空所有已打开的标准io流</p>
<p>删除由<code>tmpfile()</code>函数创建的所有临时文件</p>
</blockquote>
<h3 id="atexit"><a href="#atexit" class="headerlink" title="atexit"></a>atexit</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">int</span> <span class="token function">atexit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        当触发exit函数的时候会回调function函数</p>
<h3 id="SIGCHILD"><a href="#SIGCHILD" class="headerlink" title="SIGCHILD"></a>SIGCHILD</h3><p>​        子进程终止的时候就会发出这个信号，提示自己已经完成任务。</p>
<h3 id="wait-amp-amp-waitpid"><a href="#wait-amp-amp-waitpid" class="headerlink" title="wait &amp;&amp; waitpid"></a>wait &amp;&amp; waitpid</h3><p>​        wait系统调用指代的是等待阻塞直到子进程运行结束。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;wait.h&gt;

pid_t wait(int *_Nullable wstatus);
pid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        关于wait，返回值和错误值的描述：</p>
<pre class="line-numbers language-none"><code class="language-none">The value of pid can be:

&lt; -1   meaning wait for any child process whose process group ID
       is equal to the absolute value of pid.

-1     meaning wait for any child process.

0      meaning wait for any child process whose process group ID
       is equal to that of the calling process at the time of the
       call to waitpid().

&gt; 0    meaning wait for the child whose process ID is equal to
       the value of pid.

The value of options is an OR of zero or more of the following
constants:

WNOHANG
       return immediately if no child has exited.

WUNTRACED
       also return if a child has stopped (but not traced via
       ptrace(2)).  Status for traced children which have stopped
       is provided even if this option is not specified.

WCONTINUED (since Linux 2.6.10)
       also return if a stopped child has been resumed by
       delivery of SIGCONT.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​            wait系统调用等待的是所有的子进程，waitpid则是等待特定的子进程。在参数内指定我们希望等待的进程，下面是可能的错误值和返回值说明：</p>
<pre class="line-numbers language-none"><code class="language-none">&lt; -1   meaning wait for any child process whose process group ID
       is equal to the absolute value of pid.

-1     meaning wait for any child process.

0      meaning wait for any child process whose process group ID
       is equal to that of the calling process at the time of the
       call to waitpid().

&gt; 0    meaning wait for the child whose process ID is equal to
       the value of pid.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">WIFEXITED(wstatus)
       returns true if the child terminated normally, that is, by
       calling exit(3) or _exit(2), or by returning from main().

WEXITSTATUS(wstatus)
       returns the exit status of the child.  This consists of
       the least significant 8 bits of the status argument that
       the child specified in a call to exit(3) or _exit(2) or as
       the argument for a return statement in main().  This macro
       should be employed only if WIFEXITED returned true.

WIFSIGNALED(wstatus)
       returns true if the child process was terminated by a
       signal.

WTERMSIG(wstatus)
       returns the number of the signal that caused the child
       process to terminate.  This macro should be employed only
       if WIFSIGNALED returned true.

WCOREDUMP(wstatus)
       returns true if the child produced a core dump (see
       core(5)).  This macro should be employed only if
       WIFSIGNALED returned true.

       This macro is not specified in POSIX.1-2001 and is not
       available on some UNIX implementations (e.g., AIX, SunOS).
       Therefore, enclose its use inside #ifdef WCOREDUMP ...
       #endif.

WIFSTOPPED(wstatus)
       returns true if the child process was stopped by delivery
       of a signal; this is possible only if the call was done
       using WUNTRACED or when the child is being traced (see
       ptrace(2)).

WSTOPSIG(wstatus)
       returns the number of the signal which caused the child to
       stop.  This macro should be employed only if WIFSTOPPED
       returned true.

WIFCONTINUED(wstatus)
       (since Linux 2.6.10) returns true if the child process was
       resumed by delivery of SIGCONT.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>​        对于那些开辟了子进程的父进程在对没有任何子进程处理之下的子进程被称为僵尸进程，他们将会被init进程管理，过长的事件则会被kill掉。</p>
<h3 id="进程-进程组-会话"><a href="#进程-进程组-会话" class="headerlink" title="进程 进程组 会话"></a>进程 进程组 会话</h3><p>​        传统上，Unix操作系统下运行的应用程序、 服务器以及其他程序都被称为进程，而Linux也继承了来自unix进程的概念。必须要理解下，程序是指的存储在存储设备上（如磁盘）包含了可执行机器指 令（二进制代码）和数据的静态实体；而进程可以认为是已经被OS从磁盘加载到内存上的、动态的、可运行的指令与数据的集合，是在运行的动态实体。这里指的 指令和数据的集合可以理解为Linux上ELF文件格式中的.text .data数据段。</p>
<h4 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h4><p>　　每个进程除了有一个进程ID之外，还属于一个进程组，那什么是进程组呢？</p>
<p>　　顾名思义，进程组就是一个或多个进程的集合。这些进程并不是孤立的，他们彼此之间或者存在父子、兄弟关系，或者在功能上有相近的联系。<strong>每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构</strong>。</p>
<p>　　那为啥Linux里要有进程组呢？其实，提供进程组就是为了方便对进程进行管理。假设要完成一个任务，需要同时并发100个进程。当用户处于某种原因要终止 这个任务时，要是没有进程组，就需要手动的一个个去杀死这100个进程，并且必须要严格按照进程间父子兄弟关系顺序，否则会扰乱进程树。有了进程组，就可以将这100个进程设置为一个进程组，它们共有1个组号（pgrp），并且有选取一个进程作为组长（通常是“辈分”最高的那个，通常该进程的ID也就作为进程组的ID）。现在就可以通过杀死整个进程组，来关闭这100个进程，并且是严格有序的。组长进程可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。</p>
<p>　　 进程必定属于一个进程组，也只能属于一个进程组。 一个进程组中可以包含多个进程。 进程组的生命周期从被创建开始，到其内所有进程终止或离开该组。</p>
<p>　　内核中，sys_getpgrp()系统调用用来获取当前进程所在进程组号；sys_setpgid(int pid, int pgid)调用用来设置置顶进程pid的进程组号为pgid。</p>
<h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>　　Shell分前后台来控制的不是进程而是作业（Job）或者进程组（Process Group）。一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，Shell可以运行<strong>一个前台作业</strong>和<strong>任意多个后台作业</strong>，这称为作业控制。</p>
<p>　　作业与进程组的区别：如果作业中的某个进程又创建了子进程，则子进程不属于作业。一旦作业运行结束，Shell就把自己提到前台，如果原来的前台进程还存在（如果这个子进程还没终止），它自动变为后台进程组。</p>
<p>四、会话</p>
<p>　　再看下会话。由于Linux是多用户多任务的分时系统，所以必须要支持多个用户同时使用一个操作系统。当一个用户登录一次系统就形成一次会话 。一个会话可包含多个进程组，但只能有一个前台进程组。每个会话都有一个会话首领（leader），即创建会话的进程。 sys_setsid()调用能创建一个会话。必须注意的是，只有当前进程不是进程组的组长时，才能创建一个新的会话。调用setsid 之后，该进程成为新会话的leader。</p>
<p>　　一个会话可以有一个控制终端。这通常是登陆到其上的终端设备（在终端登陆情况下）或伪终端设备（在网络登陆情况下）。建立与控制终端连接的会话首进程被称为控制进程。一个会话中的几个进程组可被分为一个前台进程组以及一个或多个后台进程组。所以一个会话中，应该包括控制进程（会话首进程），一个前台进程组和任意后台进程组。 </p>
<p>　　<strong>一次登录形成一个会话</strong></p>
<p>　　<strong>一个会话可包含多个进程组，但只能有一个前台进程组</strong></p>
<h4 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h4><p>　　会话的领头进程打开一个终端之后, 该终端就成为该会话的控制终端 (SVR4/Linux) </p>
<p>　　与控制终端建立连接的会话领头进程称为控制进程 (session leader) </p>
<p>　　一个会话只能有一个控制终端 </p>
<p>　　产生在控制终端上的输入和信号将发送给会话的前台进程组中的所有进程 </p>
<p>　　终端上的连接断开时 (比如网络断开或 Modem 断开), 挂起信号将发送到控制进程(session leader）</p>
<p>　　进程属于一个进程组，进程组属于一个会话，会话可能有也可能没有控制终端。一般而言，当用户在某个终端上登录时，一个新的会话就开始了。进程组由组中的领头进程标识，领头进程的进程标识符就是进程组的组标识符。类似地，每个会话也对应有一个领头进程。</p>
<p>　　同一会话中的进程通过该会话的领头进程和一个终端相连，该终端作为这个会话的控制终端。一个会话只能有一个控制终端，而一个控制终端只能控制一个会话。用户通过控制终端，可以向该控制终端所控制的会话中的进程发送键盘信号。</p>
<p>　　 同一会话中只能有一个前台进程组，属于前台进程组的进程可从控制终端获得输入，而其他进程均是后台进程，可能分属于不同的后台进程组。</p>
<p> 　当我们打开多个终端窗口时，实际上就创建了多个终端会话。每个会话都会有自己的前台工作和后台工作。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>​        这些步骤坐下来将会构成一个守护进程</p>
<blockquote>
<p>1.调用fork创建新的进程，该进程将会成为守护进程。</p>
<p>在守护进程的父进程中调用<code>exit()</code>这会确保父进程的父进程，也就是守护进程的祖父进程在其子进程结束时会退出保证了，这确保了守护进程的父进程不再继续运行，而且守护进程不是首进程最后一点是成功完成下一步的前提</p>
<p>调用<code>setsid()</code>使得守护进程有一个新的进程组合，新的会话，并作为两者的首要进程。这也保证不存在和守护进程相关联的控制终端通过</p>
<p>调用<code>chdir()</code>将该当前工作目录改为根目录，因为守护进程是调用fork创建来创建的它，继承来的当前工作目录可能在文件系统的任何地方，而守护进程往往会在系统开机状态下一直运行。我们不希望这些随机目录一直处于打开状态，，导致管理员无法卸载守护工作进程的工作目录所在的文件系统。</p>
<p>关闭所有的文件描述符，我们不希望继承任何打开的描述符，不希望这些描述符一直处于打开状态，而自己没有发现。</p>
<p>重定位文件描述符0，1，2，也就是标准输入，标准输出，和标准错误，并把它们重定向到<code>/dev/null</code> </p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2024/01/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/">http://charliechen114514.github.io/2024/01/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/19/EffectiveModernCpp/" title="EffectiveModernCpp"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">EffectiveModernCpp</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/19/Linux%E6%BC%AB%E6%B8%B8%E5%90%88%E9%9B%86/" title="Linux漫游合集"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux漫游合集</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/23/TCP-IP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%EF%BC%8C2%EF%BC%8C3/" title="TCP&#x2F;IP 网络编程笔记——1，2，3"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-23</div><div class="title">TCP&#x2F;IP 网络编程笔记——1，2，3</div></div></a></div><div><a href="/2023/08/17/Unix-network-programming-Guidance/" title="Unix网络编程 - 1"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-17</div><div class="title">Unix网络编程 - 1</div></div></a></div><div><a href="/2023/08/19/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE/" title="Unix网络编程——导论与三种协议"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="title">Unix网络编程——导论与三种协议</div></div></a></div><div><a href="/2023/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BF%AE%E5%85%BB%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/" title="嵌入式C修养——前导"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-20</div><div class="title">嵌入式C修养——前导</div></div></a></div><div><a href="/2024/01/16/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-3/" title="重新学习Linux系统编程-3"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-16</div><div class="title">重新学习Linux系统编程-3</div></div></a></div><div><a href="/2024/01/15/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-2/" title="重新学习Linux系统编程-2"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="title">重新学习Linux系统编程-2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F-4"><span class="toc-number">1.</span> <span class="toc-text">重新学习Linux系统 4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6IO"><span class="toc-number">1.1.</span> <span class="toc-text">高级文件IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%95%A3-%E9%9B%86%E8%81%9A-IO"><span class="toc-number">1.1.1.</span> <span class="toc-text">分散&#x2F;集聚 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#readv-amp-amp-writev"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">readv &amp;&amp; writev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#epoll"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAepoll"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">创建epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9Cepoll"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">操作epoll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85epoll%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">等待epoll事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">触发模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F-%E7%BC%96%E8%BE%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">边沿触发模式[编辑]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.</span> <span class="toc-text">存储映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#munmap"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">munmap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">优缺点分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.0.2.1.</span> <span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mremap"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">mremap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#posix-fadvise-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">posix_fadvise()系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readahead-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">readahead()系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84IO%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">常见的IO调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Noop%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Noop调度器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CFQ%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">CFQ调度器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deadline%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">Deadline调度器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Anticipatory%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%9A"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">Anticipatory调度器：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MQ-Deadline%E5%92%8CMQ-None%EF%BC%9A"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">MQ-Deadline和MQ-None：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">程序，进程和线程的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pid"><span class="toc-number">1.3.1.</span> <span class="toc-text">pid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%96%B0%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">运行新的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">1.3.3.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit"><span class="toc-number">1.3.4.</span> <span class="toc-text">exit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atexit"><span class="toc-number">1.3.5.</span> <span class="toc-text">atexit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIGCHILD"><span class="toc-number">1.3.6.</span> <span class="toc-text">SIGCHILD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-amp-amp-waitpid"><span class="toc-number">1.3.7.</span> <span class="toc-text">wait &amp;&amp; waitpid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.8.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%BB%84-%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.3.9.</span> <span class="toc-text">进程 进程组 会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-number">1.3.9.1.</span> <span class="toc-text">进程组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.3.9.2.</span> <span class="toc-text">作业</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%88%E7%AB%AF"><span class="toc-number">1.3.9.3.</span> <span class="toc-text">控制终端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.10.</span> <span class="toc-text">守护进程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/20/%E5%BA%93%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Logger%E5%BA%93/" title="库设计：一个简单的Logger库"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="库设计：一个简单的Logger库"/></a><div class="content"><a class="title" href="/2024/01/20/%E5%BA%93%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Logger%E5%BA%93/" title="库设计：一个简单的Logger库">库设计：一个简单的Logger库</a><time datetime="2024-01-20T06:40:11.000Z" title="发表于 2024-01-20 14:40:11">2024-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/19/EffectiveModernCpp/" title="EffectiveModernCpp"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EffectiveModernCpp"/></a><div class="content"><a class="title" href="/2024/01/19/EffectiveModernCpp/" title="EffectiveModernCpp">EffectiveModernCpp</a><time datetime="2024-01-19T12:39:07.000Z" title="发表于 2024-01-19 20:39:07">2024-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/" title="重新学习Linux系统编程-4"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重新学习Linux系统编程-4"/></a><div class="content"><a class="title" href="/2024/01/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/" title="重新学习Linux系统编程-4">重新学习Linux系统编程-4</a><time datetime="2024-01-19T12:04:36.000Z" title="发表于 2024-01-19 20:04:36">2024-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/19/Linux%E6%BC%AB%E6%B8%B8%E5%90%88%E9%9B%86/" title="Linux漫游合集"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux漫游合集"/></a><div class="content"><a class="title" href="/2024/01/19/Linux%E6%BC%AB%E6%B8%B8%E5%90%88%E9%9B%86/" title="Linux漫游合集">Linux漫游合集</a><time datetime="2024-01-19T11:55:46.000Z" title="发表于 2024-01-19 19:55:46">2024-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/19/OCR%E5%BC%80%E5%8F%91%E5%BA%93%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/" title="OCR开发库日志记录"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OCR开发库日志记录"/></a><div class="content"><a class="title" href="/2024/01/19/OCR%E5%BC%80%E5%8F%91%E5%BA%93%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/" title="OCR开发库日志记录">OCR开发库日志记录</a><time datetime="2024-01-19T09:10:04.000Z" title="发表于 2024-01-19 17:10:04">2024-01-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>