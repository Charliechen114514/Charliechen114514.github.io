<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>EffectiveModernCpp | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Effective Modern C++理解模板类别推导​        一个良好风格程序，是可以让客户程序员对其原理一无所知但是却用的相当的satisfied的！ ​        符合上述陈述的，就是模板类别推导机制。这里有一小段伪代码可以view一下： template&lt;typename T&gt; void f(ParamType param); &#x2F;&#x2F; Param">
<meta property="og:type" content="article">
<meta property="og:title" content="EffectiveModernCpp">
<meta property="og:url" content="http://charliechen114514.github.io/2024/01/19/EffectiveModernCpp/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="Effective Modern C++理解模板类别推导​        一个良好风格程序，是可以让客户程序员对其原理一无所知但是却用的相当的satisfied的！ ​        符合上述陈述的，就是模板类别推导机制。这里有一小段伪代码可以view一下： template&lt;typename T&gt; void f(ParamType param); &#x2F;&#x2F; Param">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2024-01-19T12:39:07.000Z">
<meta property="article:modified_time" content="2024-01-19T12:43:07.242Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2024/01/19/EffectiveModernCpp/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'EffectiveModernCpp',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-19 20:43:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">EffectiveModernCpp</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-19T12:39:07.000Z" title="发表于 2024-01-19 20:39:07">2024-01-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-19T12:43:07.242Z" title="更新于 2024-01-19 20:43:07">2024-01-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>134分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="EffectiveModernCpp"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Effective-Modern-C"><a href="#Effective-Modern-C" class="headerlink" title="Effective Modern C++"></a><code>Effective Modern C++</code></h1><h2 id="理解模板类别推导"><a href="#理解模板类别推导" class="headerlink" title="理解模板类别推导"></a>理解模板类别推导</h2><p>​        一个良好风格程序，是可以让客户程序员对其原理一无所知但是却用的相当的satisfied的！</p>
<p>​        符合上述陈述的，就是模板类别推导机制。这里有一小段伪代码可以view一下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(ParamType param); &#x2F;&#x2F; ParamType is a compound of T<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        一次调用：</p>
<pre class="line-numbers language-none"><code class="language-none">f(expr);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在编译期间，我们的编译器通过expr推导两个型别：一个是T，另一个是<code>ParamType</code>,这个<code>ParamType</code>，往往会有一些饰词：举个例子：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(const T&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        调用如下：</p>
<pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 0;
f(x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        不会违背我们常识的——我们马上拿到了T是int,而<em><code>ParamType</code></em>是<code>const T&amp;</code></p>
<p>​        结合我们的开发经验，可以知道<em><code>ParamType</code></em>有三种：</p>
<ul>
<li><code>ParamType</code>具有指针或者是引用型别，但不是一个万能引用</li>
<li><code>ParamType</code>是一个万能引用</li>
<li><code>ParamType</code>啥也不是</li>
</ul>
<h3 id="Case-1-ParamType具有指针或者是引用型别，但不是一个万能引用"><a href="#Case-1-ParamType具有指针或者是引用型别，但不是一个万能引用" class="headerlink" title="Case 1:ParamType具有指针或者是引用型别，但不是一个万能引用"></a><code>Case 1</code>:<code>ParamType</code>具有指针或者是引用型别，但不是一个万能引用</h3><p>​        这是最简单的！运作的步骤就是如下：</p>
<ol>
<li>若expr具有引用型别，先忽略引用</li>
<li>而后，对expr的型别和<code>ParamType</code>的型别进行模式匹配后，来决定T的型别</li>
</ol>
<p>举个例子</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(T&amp; param);

int x &#x3D; 27;			&#x2F;&#x2F; x is int
const int cx &#x3D; x;	&#x2F;&#x2F; cx is const int
const int&amp; rx &#x3D; x;	&#x2F;&#x2F; rx is consy int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        于是</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">f(x);			&#x2F;&#x2F; T is int, param is int&amp;
f(cx);			&#x2F;&#x2F; T is const int, param is const int&amp;
f(rx);			&#x2F;&#x2F; T is const int, param is const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        这个时候，请注意——const关键字在类型模板推到中还是被带上了const。这就说明了模板推导是安全的。</p>
<p>​        当然，那如果是</p>
<pre class="line-numbers language-none"><code class="language-none">void f(const T&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        于是，我们没有必要繁琐的多次添加const，也就是说：</p>
<pre class="line-numbers language-none"><code class="language-none">f(x);			&#x2F;&#x2F; T is int, param is int&amp;
f(cx);			&#x2F;&#x2F; T is int, param is const int&amp;
f(rx);			&#x2F;&#x2F; T is int, param is const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        没有必要再让T带上const修饰符了——这里的参数总会具有恒定修饰符。</p>
<p>​        当然，对于指针</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void f(T* param);
int x &#x3D; 27;
const int cx &#x3D; x;
const int* px &#x3D; &amp;x;

f(&amp;x);	&#x2F;&#x2F; T is int, param is int*
f(px);	&#x2F;&#x2F; T is const int param is const int*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="case-2-param是一个万能引用"><a href="#case-2-param是一个万能引用" class="headerlink" title="case 2: param是一个万能引用"></a><code>case 2: param</code>是一个万能引用</h2><p>​        先简单谈谈什么是万能引用</p>
<p>C++11除了带来了右值引用以外，还引入了一种称为“万能引用”的语法；通过“万能引用”，对某型别的引用T&amp;&amp;，既可以表达右值引用，也可以表达左值引用。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>该语法有两种使用场景，最常见的一种是作为函数模板的形参：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;typename T>
void f(T&amp;&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中param就是一个万能引用。<br>第二个场景则是auto声明：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">auto&amp;&amp; var2 = var1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这两种情况都涉及到了型别的推导，也就是说，如果你虽然遇到了T&amp;&amp;的形式，但是不涉及型别推导，那么它只是一个右值引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">void f(Widget&amp;&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同时，想要成为万能引用，变量声明的形式也必须正确无误，必须正好是形如“T&amp;&amp;”才行。比如下面这些情况就不是万能引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;typename T>
void f1(std::vector&lt;T>&amp;&amp; param); // param是一个右值引用

template&lt;typename T>
void f2(const T&amp;&amp; param);      //param也是一个右值引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你向f1和f2传左值，会都是会直接报错的。<br>除此之外，像下面这种情况也不是万能引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;class T, class Allocator=allocator&lt;T>>
class vector&#123;
public:
  void push_back(T&amp;&amp; x);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>push_back的形参x的型别T是受vector影响的，假设给定T为Widget，那么就会被实例化为如下代码：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;class Widget, class Allocator=allocator&lt;T>>
class vector&#123;
public:
  void push_back(Widget&amp;&amp; x);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而作为对比，vector类中的emplace_back函数则是一个实实在在的万能引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;class T, class Allocator=allocator&lt;T>>
class vector&#123;
public:
  template&lt;class...Args>
  void emplace_back(Args&amp;&amp;.. args);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>args的型别Args完全独立于vector的型别形参T，Args必须在每次调用emplace_back时被推导，因此args是万能引用。</p>
<h2 id="为什么是“万能引用”？"><a href="#为什么是“万能引用”？" class="headerlink" title="为什么是“万能引用”？"></a>为什么是“万能引用”？</h2><p>你一定非常好奇，为什么这种形态被称作“万能引用”。原因正像前文所说的，通过“万能引用”，对某型别的引用T&amp;&amp;，既可以表达右值引用，也可以表达左值引用。<br>比如说，传入一个右值引用，一般都要给传入的参数加一个std::move操作确保变量的可移动性：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">class Widget
&#123;
public:
  Widget(Widget&amp;&amp; rhs):name(std::move(rhs.name))&#123;&#125;
private:
  std::string name;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而万能引用则有所不同，它一般是通过std::forward来进行转换：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">class Widget
&#123;
public:
  template&lt;typename T>
  void setName(T&amp;&amp; newName)
  &#123;name = std::forward&lt;T>(newName);&#125;
private:
  std::string name;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这种情况下，若newName是一个左值引用，则forward函数不会对它进行操作，它的返回值仍然是一个左值引用；若newName是一个右值，则会进行std::move的转换。用户使用时无需区分，这也正是它“万能”之处。<br>举个例子：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Widget w;
std::string c = "123";
w.setName(w);            //传入是一个左值，forward返回左值引用
w.setName("123");        //传入是一个右值，forward返回右值引用
w.setName(std::move(w)); //传入是一个右值，forward返回右值引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>​        你一定会很奇怪，为什么万能引用的形式明明是T&amp;&amp;，却既可以代表左值又可以代表右值。这就要涉及到C++的引用折叠语法了。<br>​        首先，C++不支持“引用的引用”这种概念，这样的代码在C++中是非法的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">int x;
auto&amp; &amp; rx = x;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        但是，假设我们向前面的万能引用函数f传入一个左值引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Widget w = w;
f(w);  //T的推导型别为Widget&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        那么实例化的结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">void f(Widget&amp; &amp;&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        之所以这样的代码能通过，是因为在特殊的情况下（比如模板实例化），C++应用了引用折叠的语法。<br>​        有左值和右值两种引用，所以就有四种可能的组合：左值-左值、左值-右值、右值-左值、右值-右值，如果引用的引用出现在允许的语境，改双重引用会被折叠成单个引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">如果任一引用为左值引用，则结果为左值引用。否则（即两个都为右值引用），结果为右值引用。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        因此上述例子中，最终将param推导为左值引用。<br>​        此外，auto的型别推导也会应用引用折叠的场景，例如：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Widget w;
auto &amp;&amp;w1 =w;  //w1是个左值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>话说到这里，我们就可以更深入地理解万能引用，其实它就是满足了下面两个条件的语境中的右值引用：</p>
<ul>
<li>1.型别推导的过程会区别左值和右值。T型别的左值推导结果为T&amp;，而T型别的右值推导结果为T。</li>
<li>2.会发生引用折叠。</li>
</ul>
<p>好了，再给出大纲：</p>
<ul>
<li>如果expr 时一个左值，那么 T 和 paramType都会被推导为左值引用，这个结果仔细思考很有趣：在模板型别推到中，T被认为是引用的唯一情形。其次，尽管在声明的时候使用的是右值引用语法，它的型别推导是左值引用！</li>
<li>expr是右值，那就是常规的，没有什么区别了。</li>
</ul>
<h3 id="case-3-param既不是指针又不是引用"><a href="#case-3-param既不是指针又不是引用" class="headerlink" title="case 3: param既不是指针又不是引用"></a><code>case 3: param</code>既不是指针又不是引用</h3><p>​        那就是剩下值传递了</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(T param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这意味：传入啥都会是副本，于是我们的param就是一个副本。也就是说：</p>
<pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 27;
const int cx &#x3D; x;
const int&amp; rx &#x3D; x;

f(x);  &#x2F;&#x2F; T 和 param 都是int
f(cx); &#x2F;&#x2F; T 和 param 都是int
f(rx); &#x2F;&#x2F; T 和 param 都是int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        不过，有一个很有趣的情况</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(T param);

const char* const ptr &#x3D; &quot;Fun wth pointers&quot;;
f(ptr); &#x2F;&#x2F; const char* const的实参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个时候，传景区的param类型就会被推到为const char*，原因很简单，我们必须拷贝这个字符串，这就意味着不可能对原本的字符串进行更改（仍然保留了这一原则！），仍然遵循着自身的const或者volitaile属性会被忽略的问题。</p>
<h3 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h3><p>​        我们下面考虑的是数组实参的问题</p>
<pre class="line-numbers language-none"><code class="language-none">const char name[] &#x3D; &quot;J,P,Briggs&quot;;
const char* ptrToName &#x3D; name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这里的ptrToName就是通过name来初始化的。后者的类型是const char[13]，前者是const char*。我们说：这里就发生了数组的退化。</p>
<p>​        现在，当我们把之传递给模板又如何呢？</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;
void f(T param);
f(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        我们知道，这样的传递相当的合法：</p>
<pre class="line-numbers language-none"><code class="language-none">void myFunc(int param[]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        同样的，我们可以按照指针的方式加以处理——等价的！</p>
<pre class="line-numbers language-none"><code class="language-none">void myFunc(int* param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        所以，对于值传递——param就会变成<code>const char*</code></p>
<p>​        那么，有没有办法传递一个真正的数组呢？答案是传递引用</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;
void f(T&amp; param);
f(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        T在此时此刻就会变成<code>const char [13]</code>，也就是说，param这个时候是:<code>const char (&amp;) [13]</code></p>
<p>​        嗯，试一下：</p>
<p><img src="image-20230822101943592.png" alt="image-20230822101943592"></p>
<p>​        没有任何意外，答案是5.</p>
<h2 id="理解auto型别推导"><a href="#理解auto型别推导" class="headerlink" title="理解auto型别推导"></a>理解auto型别推导</h2><p>​        有人调侃，未来的C++将会是</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include auto
auto main()&#123;
    auto;
    return auto;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这确实形象的表达了auto的功能——但是没有如此的夸张。他会让你想起来模板类型推导——没有反转，原理完全一致，我甚至不打算在这里重复一遍了。但是，唯独有一个区别…</p>
<p>​        C++11中，引入了一个叫做统一初始化列表的东西，它的语法是这样的</p>
<pre class="line-numbers language-none"><code class="language-none">int x &#x3D; &#123;27&#125;;
int y&#123;27&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        都被允许了！</p>
<pre class="line-numbers language-none"><code class="language-none">auto x1 &#x3D; 27;
auto x2(27); &#x2F;&#x2F; x1 and x2 is 27

auto x3 &#x3D; &#123;27&#125;; &#x2F;&#x2F; initialize_list&lt;int&gt;
auto x4&#123;27&#125;; &#x2F;&#x2F; 存疑，貌似有更改，不再是initialize_list&lt;int&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;

#define SHOWTYPE(X) std::cout &lt;&lt; #X &lt;&lt; &quot; is &quot; &lt;&lt; typeid(X).name() &lt;&lt; std::endl;
void show1()
&#123;
    auto x1 &#x3D; 27;
    SHOWTYPE(x1);
    auto x2(27);

    auto x3 &#x3D; &#123;27&#125;;
    SHOWTYPE(x3);
    auto x4&#123;27&#125;;
    SHOWTYPE(x4);
&#125;

template&lt;typename T&gt;
void f(T param)
&#123;
    std::cout &lt;&lt; &quot; In F&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;T is &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;param is &quot; &lt;&lt; typeid(param).name() &lt;&lt; std::endl;
&#125;

template&lt;typename T&gt;
void g(std::initializer_list&lt;T&gt; listParam)&#123;
    std::cout &lt;&lt; &quot; In G&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;T is &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;param is &quot; &lt;&lt; typeid(listParam).name() &lt;&lt; std::endl;
&#125;


int main()
&#123;
    auto x &#x3D; &#123;1,2,3&#125;;

    &#x2F;&#x2F; f(&#123;1,2,3&#125;); &#x2F;&#x2F; can not pass compiling
    f(x);
    g(&#123;1,2,3&#125;);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        尝试一下使用上面的代码编译一下！最终我们得出结论：auto可以识别initialize_list这个类型（推导时假定），但是模板类型推导不会。</p>
<p>​        C++14中，我们无法使用auto返回initialize_list这个类型：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto ErrorReturn()&#123;
	return &#123;1,2,3&#125;; &#x2F;&#x2F; Failed!
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="理解decltype"><a href="#理解decltype" class="headerlink" title="理解decltype"></a>理解decltype</h2><p>​        这玩意很有趣，它可以返回给定的表达式的类型。我举个例子</p>
<pre class="line-numbers language-none"><code class="language-none">const int i &#x3D; 0;		&#x2F;&#x2F; decltype(i) -&gt; const int
bool f(const Widget&amp; w); &#x2F;&#x2F; decltype(f) -&gt; bool(const Widget&amp;)

struct Point&#123;
	int x, y;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <code>delctype</code>主要是应用于那些返回值型别依赖于形参型别的函数模板。</p>
<p>​        在C++11中，我们需要这样写一个函数模板</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename Container, typename Index&gt;
auto authandAccess(Container&amp; c, Index i)-&gt;decltype(c[i])
&#123;
    authenticateUser();
    return c[i];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这里使用了C++11的返回值型别尾序语法，这样，我们就可以在指定返回值型别的时候使用函数形参。</p>
<p>​        当然，现在不会再那么麻烦了：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename Container, typename Index&gt;
auto authandAccess(Container&amp; c, Index i)
&#123;
    authenticateUser();
    return c[i];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        可是即使这样，还是会留下隐患。</p>
<p>​        举个例子，在STL中的若干容器，当我们试着去运行operator[]的时候，我们希望返回的是T&amp; ， 啥意思？这个意思：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::deque&lt;int&gt; a;
a[1] &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        我们可以通过这种方式赋值。</p>
<p>​        但是，我们上面的写法，是没有办法赋值的。</p>
<pre class="line-numbers language-none"><code class="language-none">std::deque&lt;int&gt; d;
authAndAccess(d, 5) &#x3D; 10; &#x2F;&#x2F; 抛错， 本质上返回了右值int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        所以，这样修改：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename Container, typename Index&gt;
auto authandAccess(Container&amp; c, Index i) -＞delctype(auto)
&#123;
    authenticateUser();
    return c[i];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样，我们的<code>c[i]</code>是啥，他就会返回啥。</p>
<p>​        别跑，还有问题！我们可能会需要起传递一个右值容易——</p>
<pre class="line-numbers language-none"><code class="language-none">std::deque&lt;std::string&gt; makeStringDeque();&#x2F;&#x2F; 工厂函数
auto s &#x3D; authAndAccess(makeStringDeque(), 5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        我们的右值容器，会在传递语句结束之后就会被析构。右值不可以绑定在左值引用上！（马上就会消失）。</p>
<p>​        我们的一个办法，就是写两个函数（一个接受左值，一个接受右值）。还有一个办法就是使用万能引用——让我们的编译器判断处置</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T, typename Index&gt;
decltype(auto) authAndAccess(Container&amp;&amp; c, Index i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        当然，我们后面会提到的——对万能模板使用<code>std::forward</code></p>
<h2 id="decltype-关键字"><a href="#decltype-关键字" class="headerlink" title="decltype 关键字"></a>decltype 关键字</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/152154499">c++ decltype: 类型推导规则及应用 - 知乎 (zhihu.com)</a></p>
<h3 id="获知表达式的类型"><a href="#获知表达式的类型" class="headerlink" title="获知表达式的类型"></a>获知表达式的类型</h3><ul>
<li>auto，用于通过一个表达式在编译时确定待定义的变量类型，auto 所修饰 的变量必须被初始化，编译器需要通过初始化来确定auto 所代表的类型，即必须要定义变 量。</li>
<li>若仅希望得到类型，而不需要（或不能）定义变量的时候应该怎么办呢？ C++11 新增了decltype 关键字，用来在编译时推导出一个表达式的类型。它的语法格式 如下：</li>
</ul>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">decltype(exp)
其中，exp 表示一个表达式（expression）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>从格式上来看，decltype 很像sizeof——用来推导表达式类型大小的操作符。类似于 sizeof，decltype 的推导过程是在编译期完成的，并且不会真正计算表达式的值。 那么怎样使用decltype 来得到表达式的类型呢？让我们来看一组例子：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">int x = 0;
decltype(x) y = 1; // y -> int
decltype(x + y) z = 0; // z -> int
const int&amp; i = x;
decltype(i) j = y; // j -> const int &amp;
const decltype(z) * p = &amp;z; // *p -> const int, p -> const int *
decltype(z) * pi = &amp;z; // *pi -> int , pi -> int *
decltype(pi)* pp = &amp;pi; // *pp -> int * , pp -> int * *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li><strong>y 和z</strong> 的结果表明decltype 可以根据表达式直接推导出它的类型本身。这个功能和上一 节的auto 很像，但又有所不同。auto 只能根据变量的初始化表达式推导出变量应该具有的 类型。若想要通过某个表达式得到类型，但不希望新变量和这个表达式具有同样的值，此时 auto 就显得不适用了。</li>
<li><strong>j</strong> 的结果表明decltype 通过表达式得到的类型，可以保留住表达式的引用及const 限定 符。实际上，对于一般的标记符表达式（id-expression），decltype 将精确地推导出表达式定义 本身的类型，不会像auto 那样在某些情况下舍弃掉引用和cv 限定符。</li>
<li><strong>p、pi</strong> 的结果表明decltype 可以像auto 一样，加上引用和指针，以及cv 限定符。 pp 的推导则表明，当表达式是一个指针的时候，decltype 仍然推导出表达式的实际类 型（指针类型），之后结合pp 定义时的指针标记，得到的pp 是一个二维指针类型。这也是和 auto 推导不同的一点。</li>
<li>对于decltype 和引用（&amp;） 结合的推导结果， 与C++11 中新增的引用折叠规则 （Reference Collapsing）有关，因此，留到后面的2.1 节右值引用（Rvalue Reference）时再详 细讲解。</li>
<li><strong>p、pi、pp</strong> 的推导， 有个很有意思的地方。像MicrosoftVisual Studio 这样的 IDE，可以在运行时观察每个变量的类型。我们可以看到p 的显示是这样的： 这其实是C/C++ 的一个违反常理的地方： 指针（<em>）、引用（&amp;） 属于说明符 （declarators），在定义的时候，是和变量名，而不是类型标识符（type-specif iers）相结 合的。因此，“ const decltype(z)</em>p”推导出来的其实是*p 的类型（const int），然后再进一步运算出p 的类型。</li>
</ol>
<h3 id="decltype-的推导规则"><a href="#decltype-的推导规则" class="headerlink" title="decltype 的推导规则"></a>decltype 的推导规则</h3><p>从上面一节内容来看，decltype 的使用是比较简单的。但在简单的使用方法之后，也隐 藏了不少细节。 我们先来看看decltype(exp) 的推导规则：</p>
<p><strong>推导规则 1</strong>: exp 是标识符、类访问表达式，decltype(exp) 和 exp 的类型一致。*</p>
<p><strong>推导规则 2</strong>: exp 是函数调用，decltype(exp) 和返回值的类型一致。</p>
<p><strong>推导规则 3</strong>: 其他情况，若 exp 是一个左值，则 decltype(exp) 是 exp 类型的左值引 用，否则和exp 类型一致。</p>
<p>只看上面的推导规则，很难理解decltype(exp) 到底是一个什么类型。为了更好地讲解这 些规则的适用场景，下面根据上面的规则分3 种情况依次讨论： <em>标识符表达式和类访问表达式。</em> 函数调用（非标识符表达式，也非类访问表达式）。 * 带括号的表达式和加法运算表达式（其他情况）。</p>
<h3 id="标识符表达式和类访问表达式"><a href="#标识符表达式和类访问表达式" class="headerlink" title="标识符表达式和类访问表达式"></a>标识符表达式和类访问表达式</h3><p>先看第一种情况，代码清单1-3 是一组简单的例子。 代码清单1-3　decltype 作用于标识符和类访问表达式示例</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">class Foo
&#123;
public:
static const int Number = 0;
int x;
&#125;;

int n = 0;
volatile const int &amp; x = n;
decltype(n) a = n; // a -> int
decltype(x) b = n; // b -> const volatile int &amp;
decltype(Foo::Number) c = 0; // c -> const int
Foo foo;
decltype(foo.x) d = 0; // d -> int，类访问表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>变量a、b、c 保留了表达式的所有属性（cv、引用）。 这里的结果是很简单的，按照推导规则1，对于标识符表达式而言，decltype 的推导结果就和这个变量的类型定义一致。</li>
<li>d 是一个类访问表达式，因此也符合推导规则1。</li>
</ol>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>如果表达式是一个函数调用（不符合推导规则1），结果会如 何呢？ 请看代码清单1-4 所示的示例。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">int&amp; func_int_r(void); // 左值（lvalue，可简单理解为可寻址值）
int&amp;&amp; func_int_rr(void); // x 值（xvalue，右值引用本身是一个xvalue）
int func_int(void); // 纯右值（prvalue，将在后面的章节中讲解）
const int&amp; func_cint_r(void); // 左值
const int&amp;&amp; func_cint_rr(void); // x 值
const int func_cint(void); // 纯右值
const Foo func_cfoo(void); // 纯右值
// 下面是测试语句
int x = 0;
decltype(func_int_r()) a1 = x; // a1 -> int &amp;
decltype(func_int_rr()) b1 = 0; // b1 -> int &amp;&amp;
decltype(func_int()) c1 = 0; // c1 -> int
decltype(func_cint_r()) a2 = x; // a2 -> const int &amp;
decltype(func_cint_rr()) b2 = 0; // b2 -> const int &amp;&amp;
decltype(func_cint()) c2 = 0; // c2 -> int
decltype(func_cfoo()) ff = Foo(); // ff -> const Foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>按照推导规则2，decltype 的结果和函数的返回值类型保持一致。</li>
<li>需要注意的是，c2 是int 而不是const int。这是因为函数返回的int 是一个纯右值 （prvalue）。对于纯右值而言，只有类类型可以携带cv 限定符，此外则一般忽略掉cv 限定。 如果在gcc 下编译上面的代码，会得到一个警告信息如下：</li>
</ol>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">warning: type qualif iers ignored on function return type
[-Wignored-qualif iers]
cint func_cint(void);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>因此，decltype 推导出来的c2 是一个int。 3. 作为对比，可以看到decltype 根据func_cfoo() 推导出来的ff 的类型是const Foo。</p>
<h3 id="带括号的表达式和加法运算表达式"><a href="#带括号的表达式和加法运算表达式" class="headerlink" title="带括号的表达式和加法运算表达式"></a>带括号的表达式和加法运算表达式</h3><p>最后，来看看第三种情况：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">struct Foo &#123; int x; &#125;;
const Foo foo = Foo();
decltype(foo.x) a = 0; // a -> int
decltype((foo.x)) b = a; // b -> const int &amp;
int n = 0, m = 0;
decltype(n + m) c = 0; // c -> int
decltype(n += m) d = c; // d -> int &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>a 和b 的结果：仅仅多加了一对括号，它们得到的类型却是不同的。</li>
<li>a 的结果是很直接的，根据推导规则1，a 的类型就是foo.x 的定义类型。</li>
<li>b 的结果并不适用于推导规则1 和2。根据foo.x 是一个左值，可知括号表达式也是一个 左值。因此可以按照推导规则3，知道decltype 的结果将是一个左值引用。 foo 的定义是const Foo，所以foo.x 是一个const int 类型左值，因此decltype 的推导结果 是const int &amp;。 同样，n+m 返回一个右值，按照推导规则3，decltype 的结果为int。 最后，n+=m 返回一个左值，按照推导规则3，decltype 的结果为int &amp;。</li>
</ol>
<h3 id="decltype-的实际应用"><a href="#decltype-的实际应用" class="headerlink" title="decltype 的实际应用"></a>decltype 的实际应用</h3><h3 id="decltype-的应用多出现在泛型编程中"><a href="#decltype-的应用多出现在泛型编程中" class="headerlink" title="decltype 的应用多出现在泛型编程中"></a>decltype 的应用多出现在泛型编程中</h3><pre class="line-numbers language-text" data-language="text"><code class="language-text">#include &lt;vector>
template &lt;class ContainerT>
class Foo
&#123;
typedef typename ContainerT::iterator it_; // 类型定义可能有问题

public:
void func(ContainerT&amp; container)
&#123;
it_ i = container.begin();
&#125;
// ...
&#125;;
int main(void)
&#123;
typedef const std::vector&lt;int> container_t;
container_t arr;
Foo&lt;container_t> foo;
foo.func(arr);
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>单独看类Foo 中的it_ 成员定义，很难看出会有什么错误，但在使用时，若上下文要求 传入一个const 容器类型，编译器马上会弹出一大堆错误信息。</p>
<p>原因就在于，ContainerT::iterator 并不能包括所有的迭代器类型，当ContainerT 是一个 const 类型时，应当使用const_iterator。</p>
<p>要想解决这个问题，在C++98/03 下只能想办法把const 类型的容器用模板特化单独处 理，比如增加一个像下面这样的模板特化：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template &lt;class ContainerT>
class Foo&lt;const ContainerT>
&#123;
typename ContainerT::const_iterator it_;
public:
void func(const ContainerT&amp; container)
&#123;
it_ = container.begin();
&#125;
// ...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这实在不能说是一个好的解决办法。若const 类型的特化只是为了配合迭代器的类型限 制，Foo 的其他代码也不得不重新写一次。</p>
<p>有了decltype 以后，就可以直接这样写：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template &lt;class ContainerT&gt;
class Foo
&#123;
	decltype(ContainerT().begin()) it_;
	public:
	void func(ContainerT&amp; container)
	&#123;
		it_ &#x3D; container.begin();
	&#125;
&#x2F;&#x2F; ...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="decltype-用在通过变量表达式抽取变量类型"><a href="#decltype-用在通过变量表达式抽取变量类型" class="headerlink" title="decltype 用在通过变量表达式抽取变量类型"></a>decltype 用在通过变量表达式抽取变量类型</h3><p>如下面的这种用法：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">vector&lt;int> v;
// ...
decltype(v)::value_type i = 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在冗长的代码中，人们往往只会关心变量本身，而并不关心它的具体类型。</p>
<p>比如在上例中，只要知道v 是一个容器就够了（可以提取value_type），后面的所有算法内容只需要出现 v，而不需要出现像vector 这种精确的类型名称。这对理解一些变量类型复杂但操作统 一的代码片段有很大好处。</p>
<p>实际上，标准库中有些类型都是通过decltype 来定义的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">typedef decltype(nullptr)nullptr_t;// 通过编译器关键字nullptr 定义类型nullptr_t
typedef decltype(sizeof(0)) size_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这种定义方法的好处是，从类型的定义过程上就可以看出来这个类型的含义。</p>
<h3 id="返回类型后置语法——auto-和decltype-的结合使用"><a href="#返回类型后置语法——auto-和decltype-的结合使用" class="headerlink" title="返回类型后置语法——auto 和decltype 的结合使用"></a>返回类型后置语法——auto 和decltype 的结合使用</h3><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。 考虑下面这个场景：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template &lt;typename R, typename T, typename U>
R add(T t, U u)
&#123;
return t+u;
&#125;
int a = 1; float b = 2.0;
auto c = add&lt;decltype(a + b)>(a, b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们并不关心a+b 的类型是什么，因此，只需要通过decltype(a+b) 直接得到返回值 类型即可</p>
<p>。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运 算，只有add 函数才知道返回值应当如何推导。那么，在add 函数的定义上能不能直接通过 decltype 拿到返回值吗？</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template &lt;typename T, typename U>
decltype(t + u) add(T t, U u) // error: t、u 尚未定义
&#123;
return t + u;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，直接像上面这样写是编译不过的。因为t、u 在参数列表中，而C++ 的返回值是 前置语法，在返回值定义的时候参数变量还不存在。 可行的写法如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template &lt;typename T, typename U>
decltype(T() + U()) add(T t, U u)
&#123;
return t + u;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>考虑到T、U 可能是没有无参构造函数的类，正确的写法应该是这样：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template &lt;typename T, typename U>
decltype((*(T*)0) + (*(U*)0)) add(T t, U u)
&#123;
return t + u;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然成功地使用decltype 完成了返回值的推导，但写法过于晦涩，会大大增加decltype 在返回值类型推导上的使用难度并降低代码的可读性。</p>
<p>因此，在C++11 中增加了<strong>返回类型后置</strong>（trailing-return-type，又称跟踪返回类型）语法，将decltype 和auto 结合起来完成返回值类型的推导。</p>
<p>返回类型后置语法是通过auto 和 decltype 结合起来使用的。</p>
<p>上面的add 函数，使用新的语法可以写成：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template &lt;typename T, typename U>
auto add(T t, U u) -> decltype(t + u)
&#123;
return t + u;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了进一步说明这个语法，再看另一个例子：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">int&amp; foo(int&amp; i);
float foo(float&amp; f);
template &lt;typename T>
auto func(T&amp; val) -> decltype(foo(val))
&#123;
return foo(val);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/645328162">C++编程系列笔记（3）——std::forward与完美转发详解 - 知乎 (zhihu.com)</a></p>
<p>std::forward是C++11中引入的一个函数模板，用于实现完美转发（Perfect Forwarding）。它的作用是根据传入的参数，决定将参数以左值引用还是右值引用的方式进行转发。</p>
<p>我们知道，在C++中，存在左值（lvalue）和右值（rvalue）的概念。关于左值和右值的概念，在本系列上一篇文章《C++编程系列笔记（2）——std::move和移动语义详解》中也有较为详细的讲解。简单来说，左值是指可以取地址的、具有持久性的对象，而右值是指不能取地址的、临时生成的对象。传统上，当一个左值传递给一个函数时，参数会以左值引用的方式进行传递；当一个右值传递给一个函数时，参数会以右值引用的方式进行传递。</p>
<p>然而，完美转发是为了解决传递参数时的临时对象（右值）被强制转换为左值的问题。在C++03中，可以使用泛型引用来实现完美转发，但是需要写很多重载函数，非常繁琐。而在C++11中，引入了std::forward，可以更简洁地实现完美转发。</p>
<p>因此，概括来说，std::forward实现完美转发主要用于以下场景：<strong>提高模板函数参数传递过程的转发效率</strong>。</p>
<p>下面我们将逐步引入完美转发的必要性和用法。完美转发主要通过“引用折叠”和“std::forward”函数实现，我们先来了解他们。</p>
<h2 id="引用折叠-1"><a href="#引用折叠-1" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>C++引用折叠是一种特性，允许在模板元编程中使用引用类型的参数来创建新的引用类型。</p>
<p>由于存在<code>T&amp;&amp;</code>这种万能引用类型，当它作为<code>参数</code>时，有可能被一个左值引用或右值引用的参数初始化，这是经过类型推导的T&amp;&amp;类型，推导后得到的参数类型会发生类型变化，这种变化就称为引用折叠。</p>
<p>引用折叠的具体规则如下：</p>
<ul>
<li>若一个右值引用（即带有<code>&amp;&amp;</code>）参数被一个左值或左值引用初始化，那么引用将折叠为左值引用。（即：T&amp;&amp; &amp; –&gt; T&amp;）</li>
<li>若一个右值引用参数被一个右值初始化，那么引用将折叠为右值引用。（即：T&amp;&amp; &amp;&amp; 变成 T&amp;&amp;）。</li>
<li>若一个左值引用参数被一个左值或右值初始化，那么引用不能折叠，仍为左值引用（即：T&amp; &amp; –&gt;T&amp;，T&amp; &amp;&amp; –&gt;T&amp;）。</li>
</ul>
<blockquote>
<p>总结一下： 所有右值引用折叠到右值引用上仍然是一个右值引用。（A&amp;&amp; &amp;&amp; 变成 A&amp;&amp;） 。 所有的其他引用类型之间的折叠都将变成左值引用。 （A&amp; &amp; 变成 A&amp;; A&amp; &amp;&amp; 变成 A&amp;; A&amp;&amp; &amp; 变成 A&amp;）。<br>简单来说：右值经过T&amp;&amp;参数传递，类型保持不变还是右值（引用）；而左值经过T&amp;&amp;变为普通的左值引用。</p>
</blockquote>
<p>为了更好地理解引用折叠，以下为几个示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// arg为int&amp;，引用折叠为左值引用</span>

  <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// arg为int&amp;&amp;，引用折叠为右值引用</span>

  <span class="token keyword">int</span><span class="token operator">&amp;</span> ref <span class="token operator">=</span> a<span class="token punctuation">;</span>
  <span class="token function">func</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// arg为int&amp;，引用不能折叠</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上述示例中，函数模板func接受一个转发引用类型（&amp;&amp;）的参数，并根据传递给func的实参类型决定引用类型：</p>
<ul>
<li>当func(a)时，参数类型折叠后实际为int&amp;，因为a是一个左值，引用类型折叠为左值引用。</li>
<li>当func(10)时，参数类型折叠后实际为int&amp;&amp;，因为10是一个右值，引用类型折叠为右值引用。</li>
<li>当func(ref)时，参数类型折叠后实际为int&amp;，由于左值引用类型不能折叠，参数类型保持为左值引用。</li>
</ul>
<p>引用折叠是C++中模板编程中非常有用的特性，可以根据传递实参的左值还是右值来确定引用类型，进而使得编写通用的模板函数或类更简单。</p>
<h2 id="std-forward函数"><a href="#std-forward函数" class="headerlink" title="std::forward函数"></a>std::forward函数</h2><p>实现完美转发的关键是使用std::forward函数。std::forward是一个条件转发函数模板，根据参数的左值或右值属性进行转发。它的定义参考如下：</p>
<p><img src="v2-7332145088c99ee761117eb0a6876dee_1440w.webp" alt="img"></p>
<p>这个模板函数接受一个参数并返回一个右值引用，同时利用<strong>引用折叠</strong>保留参数的左值或右值属性。调用std::forward时，根据参数的左值或右值属性，编译器会选择适当的模板实例进行转发。如果参数是一个左值引用，std::forward将返回一个左值引用。如果参数是一个右值引用，std::forward将返回一个右值引用。</p>
<p>例如：</p>
<p>1、如果T为std::string&amp;，那么std::forward(t) 返回值为std::string&amp;&amp; &amp;，折叠为std::string&amp;，左值引用特性不变。</p>
<p>2、如果T为std::string&amp;&amp;，那么std::forward(t) 返回值为std::string&amp;&amp; &amp;&amp;，折叠为std::string&amp;&amp;，右值引用特性不变。</p>
<p>掌握了以上知识之后，我们可能还是不清楚std::forward到底有什么用，那么请看下一节。</p>
<h2 id="利用std-forward实现完美转发"><a href="#利用std-forward实现完美转发" class="headerlink" title="利用std::forward实现完美转发"></a>利用std::forward实现完美转发</h2><p>C++完美转发是指一种能够传递函数参数或对象的<strong>同样类型</strong>（例如左值或右值属性）和<strong>cv限定符</strong>（const或volatile）的方式，同时保留原参数的准确数值类别和cv限定符的转发机制。完美转发通过使用引用折叠机制和std::forward函数来实现。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在C++11之前，当我们将一个参数转发给另一个函数时，会丢失参数的左值或右值的信息。例如，如果我们有一个函数f，它接受一个左值引用，然后我们通过f来调用一个函数g并传递一个右值，那么在g函数内部，参数将被视为左值，从而可能引入额外的参数转移开销。</p>
<p>C++11引入了右值引用、移动构造函数、引用折叠、std::forward等概念，使我们能够更准确地传递参数的左值或右值属性。因此，完美转发的目标是在转发参数时保持原始参数的左值或右值属性，从而提高函数参数传递的效率。</p>
<h3 id="完美转发应用实例"><a href="#完美转发应用实例" class="headerlink" title="完美转发应用实例"></a><strong>完美转发应用实例</strong></h3><p>首先定义一个对象CData，具体说明看注释：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>

<span class="token keyword">class</span> <span class="token class-name">CData</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
	<span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> ch<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>    <span class="token comment">// 构造函数，涉及资源的复制</span>
	<span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CData(const char* ch)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">CData</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>  <span class="token comment">// 拷贝构造函数，涉及资源的复制</span>
	<span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CData(const std::string&amp; str)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">CData</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> str<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>    <span class="token comment">// 移动构造函数，不涉及资源的复制！！！</span>
	<span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"CData(std::string&amp;&amp; str)"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token operator">~</span><span class="token function">CData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// 析构函数</span>
	<span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~CData()"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>string data<span class="token punctuation">;</span>   <span class="token comment">// 表示类内部管理的资源</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假如我们封装了一个操作，主要是用来创建对象使用（类似设计模式中的工厂模式），这个操作要求如下：</p>
<p>\1. 可以接受不同类型的参数，然后构造一个对象的指针。</p>
<p>\2. 性能尽可能高。（这里需要高效率，故对于右值的调用应该使用CData(std::string&amp;&amp; str)移动函数操作）</p>
<p><strong>1）不使用std::forward实现</strong></p>
<p>假设我们不使用std::forward，那么要提高函数参数转发效率，我们使用右值引用（万能引用）作为模板函数参数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
CData<span class="token operator">*</span> <span class="token function">Creator</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 利用&amp;&amp;万能引用，引用折叠： T&amp;&amp; &amp;&amp; -> T&amp;&amp;; T&amp;&amp; &amp; -> T&amp;</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">CData</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>string str1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  
    std<span class="token double-colon punctuation">::</span>string str2 <span class="token operator">=</span> <span class="token string">" world"</span><span class="token punctuation">;</span>
    CData<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">Creator</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 参数折叠为左值引用，调用CData构造函数</span>
    CData<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">Creator</span><span class="token punctuation">(</span>str1 <span class="token operator">+</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 参数折叠为右值引用，但在Creator函数中t仍为左值，调用CData构造函数！！！</span>
    <span class="token keyword">delete</span> p2<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> p1<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>g++编译上述程序，可得如下结果，印证了注释中的说明：</p>
<p><img src="v2-c2796683efe71df60fb2eac3c13a511a_1440w.webp" alt="img"></p>
<p>可以看出，在不使用std::forward的情况下，即使传入了右值引用，也无法在Creator函数中触发CData的移动构造函数，从而造成了额外的资源复制损耗。</p>
<p><strong>2）使用std::forward实现</strong></p>
<p>使用std::forward即可完美解决上述问题：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
CData<span class="token operator">*</span> <span class="token function">Creator</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">CData</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>string str1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string str2 <span class="token operator">=</span> <span class="token string">" world"</span><span class="token punctuation">;</span>
    CData<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">Creator</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 参数折叠为左值引用，调用CData构造函数</span>
    CData<span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token function">Creator</span><span class="token punctuation">(</span>str1 <span class="token operator">+</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 参数折叠为右值引用，通过std::forward转发给CData，调用移动构造函数</span>
    <span class="token keyword">delete</span> p2<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> p1<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>g++编译上述程序，可得如下结果，印证了注释中的说明：</p>
<p><img src="v2-5bd40399eab8323f3ed3eeea374e7e90_1440w.webp" alt="img"></p>
<p>可以看出，使用了std::forward之后，可以将传入的函数参数按照其原类型进一步传入参数中，从而使右值引用的参数类型可以触发类的移动构造函数，从而避免不必要的资源复制操作，提高参数转移效率。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>所谓的完美转发，是指std::forward会将输入的参数原封不动地传递到下一个函数中，这个“原封不动”指的是，如果输入的参数是左值，那么传递给下一个函数的参数的也是左值；如果输入的参数是右值，那么传递给下一个函数的参数的也是右值。</p>
<p>完美转发主要使用两步来完成任务： 1. 在模板中使用&amp;&amp;（万能引用）接收参数。 2. 使用std::forward()转发给被调函数.</p>
<p>这个对于上面一个例子带来的好处就是函数转发仍旧为右值引用，可以使用移动构造函数提高参数转移的效率（关于移动构造函数可以参考上一篇文章《C++编程系列笔记（2）——std::move和移动语义详解》中的内容）。</p>
<h2 id="std-forward实现原理（参考自ChatGPT）"><a href="#std-forward实现原理（参考自ChatGPT）" class="headerlink" title="std::forward实现原理（参考自ChatGPT）"></a>std::forward实现原理（参考自ChatGPT）</h2><p>std::forward的定义如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template &lt;typename T>
T&amp;&amp; forward(typename std::remove_reference&lt;T>::type&amp; arg) noexcept
&#123;   // forward an lvalue as either an lvalue or an rvalue
    return (static_cast&lt;_Ty&amp;&amp;>(_Arg));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它接受一个参数arg，并将其转发为右值引用。实际上，它会根据arg的左值或右值属性来决定是将arg转发为左值引用还是右值引用。如果arg是左值，它会将arg转发为左值引用；如果arg是右值，它会将arg转发为右值引用。</p>
<p>std::forward通常与模板函数和转发引用（forwarding reference）一起使用，用于完美转发函数参数。例如：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template &lt;typename T>
void foo(T&amp;&amp; arg)
&#123;
    bar(std::forward&lt;T>(arg));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子中，foo函数接受一个转发引用arg，并将arg转发给另一个函数bar。通过使用std::forward，bar函数会根据传入的arg参数的左值或右值属性，将它作为左值引用或右值引用进行转发。</p>
<p>总之，std::forward是C++11中用于实现完美转发的函数模板，可以根据传入的参数决定将参数以左值引用还是右值引用的方式进行转发，解决了传递参数时临时对象被强制转换为左值的问题。</p>
<h2 id="C-Lambda表达式详解"><a href="#C-Lambda表达式详解" class="headerlink" title="C ++ Lambda表达式详解"></a>C ++ <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Lambda&amp;spm=1001.2101.3001.7020">Lambda</a>表达式详解</h2><h3 id="1-Lambda表达式概述"><a href="#1-Lambda表达式概述" class="headerlink" title="1.Lambda表达式概述"></a>1.Lambda表达式概述</h3><p> Lambda表达式是现代C++在C ++ 11和更高版本中的一个新的语法糖 ，在C++11、C++14、C++17和C++20中Lambda表达的内容还在不断更新。 lambda表达式（也称为lambda函数）是在调用或作为函数参数传递的位置处定义匿名函数对象的便捷方法。通常，lambda用于封装传递给算法或异步方法的几行代码 。本文主要介绍Lambda的工作原理以及使用方法。</p>
<h3 id="2-Lambda表达式定义"><a href="#2-Lambda表达式定义" class="headerlink" title="2.Lambda表达式定义"></a>2.Lambda表达式定义</h3><h4 id="2-1-Lambda表达式示例"><a href="#2-1-Lambda表达式示例" class="headerlink" title="2.1 Lambda表达式示例"></a>2.1 Lambda表达式示例</h4><p> Lambda有很多叫法，有Lambda表达式、Lambda函数、匿名函数，本文中为了方便表述统一用Lambda表达式进行叙述。 ISO C ++标准官网展示了一个简单的lambda 表示式实例:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span>

<span class="token keyword">void</span> <span class="token function">abssort</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span> x<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x <span class="token operator">+</span> n<span class="token punctuation">,</span>
        <span class="token comment">// Lambda expression begins</span>
        <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">float</span> a<span class="token punctuation">,</span> <span class="token keyword">float</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">abs</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token comment">// end of lambda expression</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的实例中std::sort函数第三个参数应该是传递一个排序规则的函数，但是这个实例中直接将排序函数的实现写在应该传递函数的位置，省去了定义排序函数的过程，对于这种不需要复用，且短小的函数，直接传递函数体可以增加代码的可读性。</p>
<h4 id="2-2-Lambda表达式语法定义"><a href="#2-2-Lambda表达式语法定义" class="headerlink" title="2.2 Lambda表达式语法定义"></a>2.2 Lambda表达式语法定义</h4><p><img src="D:\My notebook project\NowReading\Finish reading as well as noting\Effective Modern C++\Effective Mordern C++ 3\f86a9e30f7474aff10be27e4b51c6f64.png" alt="在这里插入图片描述"></p>
<ol>
<li>捕获列表。在C ++规范中也称为<em>Lambda导入器， 捕获列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数，捕获列表能够捕捉上下文中的变量以供Lambda函数使用。</em></li>
<li><em>参数列表</em>。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略。</li>
<li>可变规格<em>。mutable修饰符， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</em></li>
<li><em>异常说明</em>。用于Lamdba表达式内部函数抛出异常。</li>
<li>返回类型。 追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”-&gt;”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li>
<li>lambda函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li>
</ol>
<h4 id="2-3-Lambda表达式参数详解"><a href="#2-3-Lambda表达式参数详解" class="headerlink" title="2.3 Lambda表达式参数详解"></a>2.3 Lambda表达式参数详解</h4><h5 id="2-3-1-Lambda捕获列表"><a href="#2-3-1-Lambda捕获列表" class="headerlink" title="2.3.1 Lambda捕获列表"></a>2.3.1 Lambda捕获列表</h5><p> Lambda表达式与普通函数最大的区别是，除了可以使用参数以外，Lambda函数还可以通过捕获列表访问一些上下文中的数据。具体地，捕捉列表描述了上下文中哪些数据可以被Lambda使用，以及使用方式（以值传递的方式或引用传递的方式）。语法上，在“[]”包括起来的是捕获列表，捕获列表由多个捕获项组成，并以逗号分隔。捕获列表有以下几种形式：</p>
<ul>
<li>[]表示不捕获任何变量</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>[var]表示值传递方式捕获变量var</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>[=]表示值传递方式捕获所有父作用域的变量（包括this）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>
			std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index: "</span><span class="token operator">&lt;&lt;</span> index <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> 
                <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span><span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>[&amp;var]表示引用传递捕捉变量var</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>num<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>
		num <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>
		num <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
		index <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index: "</span><span class="token operator">&lt;&lt;</span> index <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> 
            <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span><span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>[this]表示值传递方式捕捉当前的this指针</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">Lambda</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token keyword">void</span> <span class="token function">lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span> 
            <span class="token keyword">this</span><span class="token operator">-></span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

        <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Lambda demo<span class="token punctuation">;</span>
    demo<span class="token punctuation">.</span><span class="token function">lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>[=, &amp;] 拷贝与引用混合</p>
<ul>
<li><p>[=,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>index<span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>
		num <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
		index <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"index: "</span><span class="token operator">&lt;&lt;</span> index <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> 
            <span class="token operator">&lt;&lt;</span> <span class="token string">"num: "</span><span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>[&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。</p>
</li>
</ul>
<p>不过值得注意的是，捕捉列表不允许变量重复传递。下面一些例子就是典型的重复，会导致编译时期的错误。例如：</p>
<ul>
<li>[=,a]这里已经以值传递方式捕捉了所有变量，但是重复捕捉a了，会报错的;</li>
<li>[&amp;,&amp;this]这里&amp;已经以引用传递方式捕捉了所有变量，再捕捉this也是一种重复。</li>
</ul>
<p>如果lambda主体<code>total</code>通过引用访问外部变量，并<code>factor</code>通过值访问外部变量，则以下捕获子句是等效的：</p>
<pre class="line-numbers language-none"><code class="language-none">[&amp;total, factor]
[factor, &amp;total]
[&amp;, factor]
[factor, &amp;]
[&#x3D;, &amp;total]
[&amp;total, &#x3D;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="2-3-2-Lambda参数列表"><a href="#2-3-2-Lambda参数列表" class="headerlink" title="2.3.2 Lambda参数列表"></a>2.3.2 Lambda参数列表</h5><p> 除了捕获列表之外，lambda还可以接受输入参数。参数列表是可选的，并且在大多数方面类似于函数的参数列表。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> function <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> second<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> first <span class="token operator">+</span> second<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	
<span class="token function">function</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="2-3-3-可变规格mutable"><a href="#2-3-3-可变规格mutable" class="headerlink" title="2.3.3 可变规格mutable"></a>2.3.3 可变规格mutable</h5><p> mutable修饰符， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
   <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">,</span> n<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">&#123;</span> m <span class="token operator">=</span> <span class="token operator">++</span>n <span class="token operator">+</span> a<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   cout <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="2-3-4-异常说明"><a href="#2-3-4-异常说明" class="headerlink" title="2.3.4 异常说明"></a>2.3.4 异常说明</h5><p> 你可以使用 throw() 异常规范来指示 lambda 表达式不会引发任何异常。与普通函数一样，如果 lambda 表达式声明 C4297 异常规范且 lambda 体引发异常，Visual C++ 编译器将生成警告 throw() 。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// C4297 expected </span>
<span class="token punctuation">&#123;</span> 
 	<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">throw</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在MSDN的异常规范 [5] 中，明确指出异常规范是在 C++11 中弃用的 C++ 语言功能。因此这里不建议不建议大家使用。</p>
<h5 id="2-3-5-返回类型"><a href="#2-3-5-返回类型" class="headerlink" title="2.3.5 返回类型"></a>2.3.5 返回类型</h5><p> Lambda表达式的返回类型会自动推导。除非你指定了返回类型，否则不必使用关键字。返回型类似于通常的方法或函数的返回型部分。但是，返回类型必须在参数列表之后，并且必须在返回类型-&gt;之前包含类型关键字。如果lambda主体仅包含一个return语句或该表达式未返回值，则可以省略Lambda表达式的return-type部分。如果lambda主体包含一个return语句，则编译器将从return表达式的类型中推断出return类型。否则，编译器将返回类型推导为void。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> x1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="2-3-6-Lambda函数体"><a href="#2-3-6-Lambda函数体" class="headerlink" title="2.3.6 Lambda函数体"></a>2.3.6 Lambda函数体</h5><pre class="line-numbers language-none"><code class="language-none">- 捕获变量
- 形参变量
- 局部声明的变量
- 类数据成员，当在类内声明**&#96;this&#96;**并被捕获时
- 具有静态存储持续时间的任何变量，例如全局变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> Lambda表达式的lambda主体（标准语法中的<em>复合语句</em>）可以包含普通方法或函数的主体可以包含的任何内容。普通函数和lambda表达式的主体都可以访问以下类型的变量：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;

int main()
&#123;
   int m &#x3D; 0;
   int n &#x3D; 0;
   [&amp;, n] (int a) mutable &#123; m &#x3D; ++n + a; &#125;(4);
   cout &lt;&lt; m &lt;&lt; endl &lt;&lt; n &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-Lambda表达式的优缺点"><a href="#3-Lambda表达式的优缺点" class="headerlink" title="3.Lambda表达式的优缺点"></a>3.Lambda表达式的优缺点</h3><h4 id="3-1-Lambda表达式的优点"><a href="#3-1-Lambda表达式的优点" class="headerlink" title="3.1 Lambda表达式的优点"></a>3.1 Lambda表达式的优点</h4><ul>
<li><p>可以直接在需要调用函数的位置定义短小精悍的函数，而不需要预先定义好函数</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> item<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> item <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>使用Lamdba表达式变得更加紧凑，结构层次更加明显、代码可读性更好</p>
</li>
</ul>
<h4 id="3-2-Lambda表达式的缺点"><a href="#3-2-Lambda表达式的缺点" class="headerlink" title="3.2 Lambda表达式的缺点"></a>3.2 Lambda表达式的缺点</h4><ul>
<li>Lamdba表达式语法比较灵活，增加了阅读代码的难度</li>
<li>对于函数复用无能为力</li>
</ul>
<h3 id="4-Lambda表达式工作原理"><a href="#4-Lambda表达式工作原理" class="headerlink" title="4.Lambda表达式工作原理"></a>4.Lambda表达式工作原理</h3><h4 id="4-1-Lambda表达式工作原理"><a href="#4-1-Lambda表达式工作原理" class="headerlink" title="4.1 Lambda表达式工作原理"></a>4.1 Lambda表达式工作原理</h4><p> 编译器会把一个lambda表达式生成一个匿名类的匿名对象，并在类中重载函数调用运算符,实现了一个operator()方法。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> print <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 编译器会把上面这一句翻译为下面的代码:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">print_class</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
	<span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">//用构造的类创建对象，print此时就是一个函数对象</span>
<span class="token keyword">auto</span> print <span class="token operator">=</span> <span class="token function">print_class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="4-2-C-仿函数"><a href="#4-2-C-仿函数" class="headerlink" title="4.2 C++仿函数"></a>4.2 C++仿函数</h4><p> 仿函数（functor）又称为函数对象（function object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载operator()运算符，仿函数与Lamdba表达式的作用是一致的。举个例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
 
<span class="token keyword">class</span> <span class="token class-name">Functor</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">&#123;</span>
        cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Functor myFunctor<span class="token punctuation">;</span>
    <span class="token function">myFunctor</span><span class="token punctuation">(</span><span class="token string">"Hello world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="5-Lamdba表达式适用场景"><a href="#5-Lamdba表达式适用场景" class="headerlink" title="5.Lamdba表达式适用场景"></a>5.Lamdba表达式适用场景</h3><h4 id="5-1-Lamdba表达式应用于STL算法库"><a href="#5-1-Lamdba表达式应用于STL算法库" class="headerlink" title="5.1 Lamdba表达式应用于STL算法库"></a>5.1 Lamdba表达式应用于STL算法库</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// for_each应用实例</span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token operator">%</span><span class="token number">10</span> <span class="token operator">&lt;</span> y<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">for_each</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> a<span class="token operator">+</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">1234</span>
<span class="token comment">// find_if应用实例</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> coll <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">17</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> pos <span class="token operator">=</span> <span class="token function">find_if</span><span class="token punctuation">(</span>coll<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> coll<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                 
    <span class="token keyword">return</span> i <span class="token operator">></span> x <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">1234567</span>
<span class="token comment">// remove_if应用实例</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec_data <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
vec_data<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span>date<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec_data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    <span class="token keyword">return</span> n <span class="token operator">&lt;</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec_data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span>date<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec_data<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-2-短小不需要复用函数场景"><a href="#5-2-短小不需要复用函数场景" class="headerlink" title="5.2 短小不需要复用函数场景"></a>5.2 短小不需要复用函数场景</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> testdata<span class="token punctuation">;</span>
    testdata<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>testdata<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> data<span class="token punctuation">,</span> data <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 对于比较大小的逻辑，使用lamdba不需要在重新定义一个函数</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>testdata<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> testdata<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> 
        <span class="token keyword">return</span> a <span class="token operator">></span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-3-Lamdba表达式应用于多线程场景"><a href="#5-3-Lamdba表达式应用于多线程场景" class="headerlink" title="5.3 Lamdba表达式应用于多线程场景"></a>5.3 Lamdba表达式应用于多线程场景</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// vector 容器存储线程</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">></span> workers<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        workers<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread function\n"</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main thread\n"</span><span class="token punctuation">;</span>

    <span class="token comment">// 通过 for_each 循环每一个线程</span>
    <span class="token comment">// 第三个参数赋值一个task任务</span>
    <span class="token comment">// 符号'[]'会告诉编译器我们正在用一个匿名函数</span>
    <span class="token comment">// lambda函数将它的参数作为线程的引用t</span>
    <span class="token comment">// 然后一个一个的join</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>workers<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> workers<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread <span class="token operator">&amp;</span>t<span class="token punctuation">;</span><span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

std<span class="token double-colon punctuation">::</span>mutex mutex<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable condition<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> queue_data<span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">threadBody</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">></span> <span class="token function">lock_log</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
	condition<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock_log<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token operator">!</span>queue_data<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"queue data: "</span> <span class="token operator">&lt;&lt;</span> queue_data<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	lock_log<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

queue_data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"this is my data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
condition<span class="token punctuation">.</span><span class="token function">notity_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span><span class="token punctuation">(</span>threadBody<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	threadBody<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-4-Lamdba表达式应用于函数指针与function"><a href="#5-4-Lamdba表达式应用于函数指针与function" class="headerlink" title="5.4 Lamdba表达式应用于函数指针与function"></a>5.4 Lamdba表达式应用于函数指针与function</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> add <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> Add <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"add: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Add: "</span> <span class="token operator">&lt;&lt;</span> <span class="token function">Add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-5-Lamdba表达式作为函数的入参"><a href="#5-5-Lamdba表达式作为函数的入参" class="headerlink" title="5.5 Lamdba表达式作为函数的入参"></a>5.5 Lamdba表达式作为函数的入参</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> FuncCallback <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">DataCallback</span><span class="token punctuation">(</span>FuncCallback callback<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Start FuncCallback!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"End FuncCallback!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">auto</span> callback_handler <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This is callback_handler"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">DataCallback</span><span class="token punctuation">(</span>callback_handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="5-6-Lamdba表达式在QT中的应用"><a href="#5-6-Lamdba表达式在QT中的应用" class="headerlink" title="5.6 Lamdba表达式在QT中的应用"></a>5.6 Lamdba表达式在QT中的应用</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QTimer <span class="token operator">*</span>timer<span class="token operator">=</span><span class="token keyword">new</span> QTimer<span class="token punctuation">;</span>
timer<span class="token operator">-></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">connect</span><span class="token punctuation">(</span>timer<span class="token punctuation">,</span><span class="token operator">&amp;</span>QTimer<span class="token double-colon punctuation">::</span>timeout<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Lambda表达式"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">12345</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
QString str1 <span class="token operator">=</span> <span class="token string">"汉字博大精深"</span><span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>pBtn4<span class="token punctuation">,</span> <span class="token operator">&amp;</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">bool</span> checked<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span>str1<span class="token punctuation">;</span>
	<span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> checked<span class="token punctuation">;</span>
	<span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Hua Windows Lambda Button"</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="当auto推导的型别不符合要求的时候，强转之"><a href="#当auto推导的型别不符合要求的时候，强转之" class="headerlink" title="当auto推导的型别不符合要求的时候，强转之"></a>当auto推导的型别不符合要求的时候，强转之</h2><p>​        我们来看一个特例：</p>
<pre class="line-numbers language-none"><code class="language-none">std::vector&lt;bool&gt; features(const Widget&amp; w);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们构造此函数意在说明关于它的第几个比特表征了他的第几个性质，举个例子</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Widget w;
...;
bool highPriority &#x3D; feature(w)[5];
...;
processWidget(w, highPriority);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这段代码本身没啥，但是注意到：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Widget w;
...;
auto highPriority &#x3D; feature(w)[5];
...;
processWidget(w, highPriority);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        就会出现状况！这是因为<code>std::vector&lt;bool&gt;</code>再当我们使用<code>operator[]</code>访问的时候，会返回一个reference，这个reference的生命周期很短，只要我们越过了这个生命周期就会产生未定义的现象。那么，我们可以如何处理这种在我们可能不熟悉的情况下产生总是正确的结果呢？答案是使用强制类型转换：</p>
<pre class="line-numbers language-none"><code class="language-none">auto highPriority &#x3D; static_cast&lt;bool&gt;(features(w)[5])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这样，我们就可以强制的转换类型达到我们想要的目的了。</p>
<h2 id="区分-和"><a href="#区分-和" class="headerlink" title="区分()和{}"></a>区分<code>()</code>和<code>&#123;&#125;</code></h2><p>​        C++11引入了初始化列表方法：<code>initializer_list</code></p>
<pre class="line-numbers language-none"><code class="language-none">int z &#x3D; &#123;0&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这种大括号的处理方法，可以初始化一些容器：</p>
<pre class="line-numbers language-none"><code class="language-none">std::vector&lt;int&gt; x&#123;1, 3, 5&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在类内，我们可以使用两种初始化方法，一个是上面刚刚提到的initializer_list，另一个就是等号赋值</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class A&#123;
	...;
private:
        int x&#123;0&#125;;
    	int y &#x3D; 0;
    	&#x2F;&#x2F; int z(0) ; &#x2F;&#x2F; will Failed
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是调转回头，对于那些不可以被复制的对象（<code>std::atomic</code>）上，却可以使用大小括号的方式进行初始化：</p>
<pre class="line-numbers language-none"><code class="language-none">std::atomic&lt;int&gt; ai1&#123;0&#125;;
std::atomic&lt;int&gt; ai2(0);
&#x2F;&#x2F; std::atomic&lt;int&gt; ai3 &#x3D; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        大括号初始化有一个好处，那就是精致内建型别之间相互的隐式转化，举个例子</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">double x, y, z;
int sum1&#123;x, y, z&#125;; &#x2F;&#x2F; ERROR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        而其它方式不会报错.</p>
<p>​        对于类：那些没有initializer_list作为单纯参数的构造函数同小括号方式调用的方式没有任何区别，但是，当存在：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class W&#123;
	public:
    	Widget(int, bool);
    	Widget(int, double);
    	Widget(std::initialzer_list&lt;long double&gt; i1);
&#125;;

Widget w1(10, true); &#x2F;&#x2F; 第一个构造函数
Widget w2&#123;10, true&#125;; &#x2F;&#x2F; 第三个构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <strong>注意，<code>&#123;&#125;</code>认为是没有参数，而不是空的<code>&#123;&#125;</code></strong>，这也就意味着，对于那些含有默认构造函数的同时还具有有初始化列表的构造函数类上</p>
<pre class="line-numbers language-none"><code class="language-none">A&#123;&#125; -&gt; A() 而不是 A(&#123;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="优先选用nullptr而不是0-NULL"><a href="#优先选用nullptr而不是0-NULL" class="headerlink" title="优先选用nullptr而不是0, NULL"></a>优先选用nullptr而不是0, NULL</h2><p>​        0 是 int， 而NULL是void*，都不符合现代C++的风格。</p>
<blockquote>
<p>不要在指针类型和整数类型上做重载（Even in C++）</p>
</blockquote>
<p>​        这是一个忠告。现在，我们使用<code>nullptr</code>作为题目的代替品，他总是会保证我们走的函数是指针类型的而不是整数类型的。</p>
<h2 id="优先使用别名而不是typedef"><a href="#优先使用别名而不是typedef" class="headerlink" title="优先使用别名而不是typedef"></a>优先使用别名而不是typedef</h2><p>​        在C++98时期，我们使用typedef来化简对类型的声明：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; UPtrMapSS<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在C++11中，使用这个：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">using UPtrMapSS &#x3D; std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当然，关于为什么使用using最好的理由是它可以使用模板</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
using MyList &#x3D; std::list&lt;T, MyAlloc&lt;T&gt;&gt;;

MyList&lt;W&gt; list_w;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        使用typedef的话，会显得十分的麻烦。</p>
<h2 id="优先使用enum-class而不是enum"><a href="#优先使用enum-class而不是enum" class="headerlink" title="优先使用enum class而不是enum"></a>优先使用enum class而不是enum</h2><p>​        enum class给我们的枚举值加上了作用域，同时，还支持了我们不会对之做出隐式的转化，实在是很方便。</p>
<p>​        我们当然可以控制他做任何的转化，举个例子：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">size_t size &#x3D; static_cast&lt;size_t&gt;(NewMember::MEM_TYPE::someType_MAX)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        程序员自然可以控制类型的转化方式了。</p>
<p>​        当然可以使用继承整形的方式来确定我们的枚举类型的基础整形如何。</p>
<h2 id="优先使用删除函数，而不是把函数塞到private且不下定义"><a href="#优先使用删除函数，而不是把函数塞到private且不下定义" class="headerlink" title="优先使用删除函数，而不是把函数塞到private且不下定义"></a>优先使用删除函数，而不是把函数塞到private且不下定义</h2><p>​        在C++98中，我们常常会为了删除构造函数而把函数藏在private中，当我们试图使用的时候就会抛出未定义的错误。在C++11中，更好的做法是声明为delete：</p>
<pre class="line-numbers language-none"><code class="language-none">basic_ios(const basic_ios&amp;) &#x3D; delete;
basic_ios&amp; operator&#x3D;(const basic_ios&amp;) &#x3D; delete;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        删除函数可以拒绝我们不想要的重载版本，从而避免隐式转换。</p>
<h2 id="为意在改写的函数添加override"><a href="#为意在改写的函数添加override" class="headerlink" title="为意在改写的函数添加override"></a>为意在改写的函数添加override</h2><p>​        在C++中，面对对象是不可避免的话题，也就意味着我们的代码活动伴随着大量的重写。我们可以为我们就是想要改写的函数上标签<code>override</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base
&#123;
    public:
    	virtual void doWork() &#x3D; 0;
&#125;

class DerivedClass : public Base&#123;
    public:
    	virtual void doWork() override;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于此，我们就要求：</p>
<blockquote>
<ol>
<li>基类和派生类的函数的函数形参型别必须完全一致与相同</li>
<li>基类和派生类中的函数常量性必须完全一致</li>
<li>基类和派生类中的函数返回值和异常规格必须完全兼容</li>
</ol>
</blockquote>
<h2 id="优先选用const-iterator而不是iterator"><a href="#优先选用const-iterator而不是iterator" class="headerlink" title="优先选用const_iterator而不是iterator"></a>优先选用<code>const_iterator</code>而不是iterator</h2><p>​        他是那些指向不可以被修改的const的对象的指针的等价物</p>
<blockquote>
<p>任何时候我们没有必要修改设计的内容的时候都应该使用<code>const_iterator</code></p>
</blockquote>
<p>​        现在，主流的容器接口提供<code>cbegin</code>和<code>cend</code>来返回常迭代器</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;vector&gt;
#include &lt;iostream&gt;

void makeInit(std::vector&lt;int&gt;* vec)
&#123;
    for(int i &#x3D; 0; i &lt; 10; i++)
        vec-&gt;push_back(i);
&#125;

void displayVec(std::vector&lt;int&gt;&amp; vec)
&#123;
    for(std::vector&lt;int&gt;::const_iterator it &#x3D; vec.cbegin(); it !&#x3D; vec.cend(); it++)
        std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    std::cout &lt;&lt; &quot;\n&quot;;
&#125;

int main()
&#123;
    std::vector&lt;int&gt; vec;
    makeInit(&amp;vec);
    displayVec(vec);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="只要函数不发射异常，就应该加上noexcept声明"><a href="#只要函数不发射异常，就应该加上noexcept声明" class="headerlink" title="只要函数不发射异常，就应该加上noexcept声明"></a>只要函数不发射异常，就应该加上noexcept声明</h2><p>​        注意，为了保证接口信息全面，应该为那些确实不会发射异常的函数加上noexcept声明。</p>
<h3 id="Microsoft-Team给出的解释"><a href="#Microsoft-Team给出的解释" class="headerlink" title="Microsoft Team给出的解释"></a>Microsoft Team给出的解释</h3><p>​        <em><code>noexcept-expression</code></em> 是一种异常规范：一个函数声明的后缀，代表了一组可能由异常处理程序匹配的类型，用于处理退出函数的任何异常。 当 <em><code>constant_expression</code></em> 生成 <strong><code>true</code></strong> 时，一元条件运算符 <code>noexcept(constant_expression)</code> 及其无条件同义词 <strong><code>noexcept</code></strong> 指定可以退出函数的潜在异常类型集为空。 也就是说，该函数绝不会引发异常，也绝不允许在其范围外传播异常。 当 <em><code>constant_expression</code></em> 生成 <strong><code>false</code></strong> 或缺少异常规范（析构函数或解除分配函数除外），运算符 <code>noexcept(constant_expression)</code> 指示可以退出函数的潜在异常集是所有类型的集合。</p>
<p>​        仅当函数直接或间接调用的所有函数也是 <strong><code>noexcept</code></strong> 或 <strong><code>const</code></strong> 时，才将该函数标记为 <strong><code>noexcept</code></strong>。 编译器不一定会检查可能归因于 <strong><code>noexcept</code></strong> 函数的异常的每个代码路径。 如果异常确实退出标记为 <strong><code>noexcept</code></strong> 的函数的外部范围，则会立即调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/standard-library/exception-functions?view=msvc-170#terminate"><code>std::terminate</code></a>，并且不会保证将调用任何范围内对象的析构函数。 使用 <strong><code>noexcept</code></strong> 而不是动态异常说明符 <code>throw()</code>。 动态异常规范（<code>throw(optional_type_list)</code> 规范）在 C++11 中已弃用，并已在 C++17 中删除，但 <code>throw()</code> 除外，它是 <code>noexcept(true)</code> 的别名。 我们建议你将 <strong><code>noexcept</code></strong> 应用到任何绝不允许异常传播到调用堆栈的函数。 当函数被声明为 <strong><code>noexcept</code></strong> 时，它使编译器可以在多种不同的上下文中生成更高效的代码</p>
<blockquote>
<p>noexcept对于那些移动操作的，swap和内存释放函数和析构函数最有价值。</p>
</blockquote>
<h2 id="保证const成员函数的线程安全性"><a href="#保证const成员函数的线程安全性" class="headerlink" title="保证const成员函数的线程安全性"></a>保证const成员函数的线程安全性</h2><p>​        我们一般认为，多个线程执行读操作是安全的，但是可能存在：在读的内部更改了和const变量自身有关的其他变量导致实际上会存在破坏数据的风险。</p>
<p>​        这样，我们可能就会需要使用互斥量mutex来完成这些事情，或者是使用<code>atomic</code>型别的计数器来完成</p>
<h2 id="理解特种成员函数的生成机制"><a href="#理解特种成员函数的生成机制" class="headerlink" title="理解特种成员函数的生成机制"></a>理解特种成员函数的生成机制</h2><p>​        现在，我们多了两个特别的成员函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Widget(Widget&amp;&amp; rhs);
Widget&amp; opreator&#x3D;(Widget&amp;&amp; rhs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        移动构造。</p>
<p>​        注意到：移动操作彼此之间并不互相对立——只要生成了其中一个就会阻止另一个的生成。</p>
<p>​        C++里有一个大三律的推论：假如类有明显地定义下列其中一个成员函数，那么程序员必须连其他二个成员函数也一同编写至类内，亦即下列三个成员函数缺一不可:</p>
<blockquote>
<p>析构函数（Destructor）<br>复制构造函数（copy constructor）<br>复制赋值运算符（copy assignment operator）</p>
</blockquote>
<p>​        上述三个函数是特别的成员函数，假如程序员没有自行定义或是编写声明它们，那么编译器会自动地创建它们，并且会编译至应用程序内。相反地，假如程序员有定义上述三者其中一个函数，那么由编译器自动产生出来的上述三个函数是不会搭配到这个类内。三法则（Rule of three）这个专有名词是由 Marshall Cline 于 1991 年创立的。</p>
<p>​        这个法则的修正版本是，假如析构函数有用到 RAII（资源的取得就是初始化，Resource Acquisition Is Initialization），可以使得析构函数的定义更加明确（也就是所谓的二大定律，The Law of The Big Two[3]）。<br>​        因为隐性产生（英语：implicitly-generated；由编译器自动产生）的构造函数与赋值运算符可以很容易地复制类内所有的数据成员[4]，当数据成员是指针型态时，指针地址会随着类而跟着被复制，要注意的是，直接地复制指针地址是一项非常危险的动作，所以只要类有封装指针型态的数据结构，或是类有封装外部引用的数据成员（例如：指针型态的数据成员），程序员应该为此定义显性的（英语：explicit；由程序员来编写清楚明确的）复制构造函数，以及复制赋值运算符。</p>
<h2 id="使用std-unique-ptr来管理具备专属所有权的资源"><a href="#使用std-unique-ptr来管理具备专属所有权的资源" class="headerlink" title="使用std::unique_ptr来管理具备专属所有权的资源"></a>使用<code>std::unique_ptr</code>来管理具备专属所有权的资源</h2><p>​        当我们想要使用智能指针的时候，我们应该认为<code>std::unique_ptr</code>总是首选。他保证了我们的指针总是独占我们的资源。</p>
<p>​        我们当然可以自定义我们的析构操作：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto delInv &#x3D; [](Invest* pInv)&#123;
	makeLoggy();
    delete pInv;
&#125;

template&lt;typename ...T&gt;
std::unique_ptr&lt;Investment, decltype&lt;delInv&gt;&gt; makeInvest(Ts&amp;&amp;... param)&#123;
    std::unique_ptr&lt;Investment, decltype&lt;delInv&gt;&gt; pInv(nullptr, delInvmt);
    if(...)
        pInv.reset(new Stock(std::forward&lt;Ts&gt;(params)...));
    else
        pInv.reset(new Bond(std::forward&lt;Ts&gt;(params)...));
    
    return pInv;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        使用reset来切换资源管理。</p>
<h2 id="使用-std-shared-ptr-管理具备共享所有权的资源"><a href="#使用-std-shared-ptr-管理具备共享所有权的资源" class="headerlink" title="使用 std::shared_ptr 管理具备共享所有权的资源"></a>使用 std::shared_ptr 管理具备共享所有权的资源</h2><p>​        <code>std::shared_ptr</code>提供了方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。与<code>std::unique_ptr</code>相比，<code>std::shared_ptr</code>所占大小通常是裸指针的两倍，它还会带来控制块的开销，并且要求成本高昂的原子化的引用计数操作。</p>
<p>​        默认的资源析构通过<code>delete</code>运算符来完成，但同时也支持自定义删除器。与<code>std::unique_ptr</code>不同的是，删除器的类型对<code>std::shared_ptr</code>的类型没有影响，也不会影响<code>std::shared_ptr</code>的尺寸大小：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> loggingDel <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> pw<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>loggingDel<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span>                       <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这使得<code>std::shared_ptr</code>的设计更具弹性，拥有不同类型自定义删除器的<code>std::shared_ptr</code>也可以被放在同一个容器中：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> customDeleter1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 自定义删除器</span>
<span class="token keyword">auto</span> customDeleter2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pw<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// 各有不同的类型</span>

std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> customDeleter1<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">pw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> customDeleter2<span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">>></span> vpw<span class="token punctuation">&#123;</span> pw1<span class="token punctuation">,</span> pw2 <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <strong>控制块（control block）：</strong> 每一个由<code>std::shared_ptr</code>管理的对象都拥有一个控制块，它的内存被动态分配在堆上，除了包含引用计数以外，还包含作用于<code>std::weak_ptr</code>的弱计数，自定义删除器和分配器等内容。</p>
<p>一个对象的控制块应该在创建首个指向该对象的<code>std::shared_ptr</code>时确定，因此，控制块的创建遵循以下规则：</p>
<ol>
<li>使用<code>std::make_shared</code>总是会创建一个控制块。</li>
<li>从具备专属所有权的指针（<code>std::unique_ptr</code>或<code>std::auto_ptr</code>）出发构造一个<code>std::shared_ptr</code>时，会创建一个控制块。</li>
<li>用裸指针作为实参调用<code>std::shared_ptr</code>的构造函数时，会创建一个控制块。</li>
</ol>
<p>由以上规则我们可以得出，应该避免使用裸指针类型的变量来创建<code>std::shared_ptr</code>。用同一个裸指针构造出不止一个<code>std::shared_ptr</code>将会使对象拥有多重的控制块，这会导致对资源的多次析构，从而产生未定义行为，如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> pw <span class="token operator">=</span> <span class="token keyword">new</span> Widget<span class="token punctuation">;</span> <span class="token comment">// pw 是个裸指针</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>应该改为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw1</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> loggingDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span>spw1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当你希望一个托管到<code>std::shared_ptr</code>的类能够安全地由<code>this</code>指针创建一个<code>std::shared_ptr</code>时，应该使该类继承自<code>std::enable_shared_from_this</code>，如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Widget</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>std::enable_shared_from_this</code>定义了一个成员函数<code>std::shared_from_this</code>，它会创建一个<code>std::shared_ptr</code>指向当前对象，但不会重复创建控制块：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">>></span> processedWidget<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 处理对象本身</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token comment">// 将指向当前对象的 std::shared_ptr 加入 processedWidget</span>
    processedWidget<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了避免用户在<code>std::shared_ptr</code>指向该对象前就调用了<code>std::shared_from_this</code>（这会导致其无法查询到对象拥有的控制块，产生未定义行为），继承自<code>std::enable_shared_from_this</code>的类通常会将其构造函数声明为 private，并且只允许通过调用返回<code>std::shared_ptr</code>的工厂函数来创建对象。例如，以下是<code>Widget</code>类的一个可能实现：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">enable_shared_from_this</span><span class="token operator">&lt;</span><span class="token class-name">Widget</span><span class="token operator">></span></span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 将实参完美转发给 private 构造函数的工厂函数</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 构造函数</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>std::unique_ptr</code>可以轻易转换为<code>std::shared_ptr</code>，反之却并不成立，一旦资源的生存期被托管给了<code>std::shared_ptr</code>，就不能回收该资源的所有权，并让一个<code>std::unique_ptr</code>来托管它。并且和<code>std::unique_ptr</code>不同，<code>std::shared_ptr</code>直到 C++17 才拥有处理数组的能力（<code>std::shared_ptr&lt;T[]&gt;</code>），在 C++11/14 中，它的 API 仅被设计用来处理指向单个对象的指针。</p>
<h2 id="使用std-weak-ptr防止循环引用导致指针失效"><a href="#使用std-weak-ptr防止循环引用导致指针失效" class="headerlink" title="使用std::weak_ptr防止循环引用导致指针失效"></a>使用<code>std::weak_ptr</code>防止循环引用导致指针失效</h2><p>​        <code>std::weak_ptr</code>并不是一种独立的智能指针，而是<code>std::shared_ptr</code>的一种扩充。它一般是通过<code>std::shared_ptr</code>来创建的，两者会指向相同位置，但<code>std::weak_ptr</code>并不影响所指向对象的引用计数，而是会影响控制块中的弱计数。</p>
<p>​        <strong>使用<code>expired</code>函数来检测<code>std::weak_ptr</code>的空悬：</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> spw <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">wpw</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

spw <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>      <span class="token comment">// Widget 对象被析构，wpw 空悬</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>wpw<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// 若 wpw 不再指向任何对象</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        通过<code>std::weak_ptr</code>创建<code>std::shared_ptr</code>，可以在未失效情况下提供对资源的访问：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 使用 lock 函数时，若 wpw 失效，则 spw1 和 spw2 为空</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> spw1 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> spw2 <span class="token operator">=</span> wpw<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 直接构造时，若 wpw 失效，则抛出 std::bad_weak_ptr 类型的异常</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw3</span><span class="token punctuation">(</span>wpw<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>std::weak_ptr</code>有以下可能的用武之地：</p>
<ul>
<li>创建带缓存的工厂函数：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> Widget<span class="token operator">></span> <span class="token function">fastLoadWidget</span><span class="token punctuation">(</span>WidgetID id<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>WidgetID<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">const</span> Widget<span class="token operator">>></span> cache<span class="token punctuation">;</span>

    <span class="token keyword">auto</span> objPtr <span class="token operator">=</span> cache<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果对象不在缓存中，则返回空指针</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>objPtr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                  <span class="token comment">// 加载并缓存对象</span>
        objPtr <span class="token operator">=</span> <span class="token function">loadWidget</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cache<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> objPtr<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> objPtr<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>观察者设计模式（Observer design pattern）：多个观察者（observer）对象同时监听一个主题（subject）对象，主题对象会在其发生状态改变时发出通知。主题对象不会控制其观察者的生存期，但需要确认当一个观察者对象被析构后，主题对象不会再访问它。一种合理的设计就是让每个主题对象持有指向其观察者对象的<code>std::weak_ptr</code>，以便在使用之前确认它是否空悬。</li>
<li>避免<code>std::shared_ptr</code>循环引用：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pb<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pa<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">auto</span> pa <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> pb <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

pa<span class="token operator">-></span>pb <span class="token operator">=</span> pb<span class="token punctuation">;</span>
pb<span class="token operator">-></span>pa <span class="token operator">=</span> pa<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这种情况下，<code>A</code>和<code>B</code>互相保存着指向对方的<code>std::shared_ptr</code>，产生了循环引用，两者会永久保持彼此的引用计数至少为一，这会阻止<code>A</code>和<code>B</code>被析构，实际上产生了内存泄漏。</p>
<p>将其中一者改为<code>std::weak_ptr</code>可以避免循环的产生：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">></span> pb<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">></span> pa<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="优先选用-std-make-unique-和-std-make-shared，而非直接使用-new"><a href="#优先选用-std-make-unique-和-std-make-shared，而非直接使用-new" class="headerlink" title="优先选用 std::make_unique 和 std::make_shared，而非直接使用 new"></a>优先选用 std::make_unique 和 std::make_shared，而非直接使用 new</h2><p>​        <code>std::make_shared</code>是 C++11 的一部分，但<code>std::make_unique</code>到了 C++14 才被加入标准库，不过要写出一个基础版本的<code>std::make_unique</code>非常容易：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">make_unique</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">></span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        相对于直接使用<code>new</code>运算符，make 函数有以下优势：</p>
<ul>
<li>消除重复代码：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> <span class="token function">upw1</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 使用 make 函数</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">upw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 不使用 make 函数</span>

<span class="token keyword">auto</span> <span class="token function">spw1</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 使用 make 函数</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw2</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 不使用 make 函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>改进了异常安全性：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 有潜在的内存泄漏风险</span>

<span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 不具有潜在的内存泄漏风险</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        在直接使用<code>new</code>运算符的情况下，由于分配<code>Widget</code>对象、执行<code>std::shared_ptr</code>构造函数、执行<code>computePriority</code>函数三者并不存在固定顺序，<code>computePriority</code>函数可能会晚于<code>Widget</code>对象的分配，先于<code>std::shared_ptr</code>的构造函数执行，此时若<code>computePriority</code>产生异常，那么分配的<code>Widget</code>内存就会发生泄漏。使用<code>std::make_shared</code>则不会产生这个问题。</p>
<ul>
<li>使用<code>std::make_shared</code>和<code>std::allocate_shared</code>有助于生成的尺寸更小、速度更快的目标代码。</li>
</ul>
<blockquote>
<p><code>std::make_shared</code>会将指向的对象和与其相关联的控制块分配在单块内存中，这种优化减少了程序的静态尺寸，并且因为只进行一次内存分配，还可以加块代码的运行速度。使用<code>std::make_shared</code>还可以减少对控制块一些簿记信息（bookkeeping information）的需要，潜在地减少了程序的内存占用量（memory footprint）。<code>std::allocate_shared</code>也是同理。</p>
</blockquote>
<p>​        虽然有着如此多的优势，但还是有一些情形下，不能或者不应该使用 make 函数：</p>
<ul>
<li>使用 make 函数<strong>无法自定义删除器，以及直接传递大括号内的初始值设定项：</strong></li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 想要自定义删除器，就只能使用 new 运算符</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>widgetDeleter<span class="token punctuation">)</span><span class="token operator">></span> <span class="token function">upw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> widgetDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span>                          <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> widgetDeleter<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 只能间接传递初始化列表给 make 函数</span>
<span class="token keyword">auto</span> initList <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> spv <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>initList<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>不建议对<strong>自定义内存管理方式的类使用 make 函数</strong>：通常情况下，类自定义的<code>operator new</code>和<code>operator delete</code>被设计成用来分配和释放能精确容纳该类大小的内存块，但<code>std::allocate_shared</code>所要求的内存大小并不等于动态分配对象的大小，而是在其基础上加上控制块的大小。因此，使用 make 函数去创建重载了<code>operator new</code>和<code>operator delete</code>类的对象，通常并不是个好主意。</li>
<li>当处于特别关注内存的系统中时，若存在非常大的对象和比相应的<code>std::shared_ptr</code>生存期更久的<code>std::weak_ptr</code>，不建议使用 make 函数：这会导致对象的析构和内存的释放之间产生延迟，而若直接使用<code>new</code>运算符，内存的释放就不必等待<code>std::weak_ptr</code>的析构。</li>
</ul>
<p>如果你发现自己处于不应该使用<code>std::make_shared</code>的情形下，又不想受到之前所述异常安全问题的影响。<strong>最好的方法是确保在直接使用<code>new</code>时，立即将结果传递给智能指针的构造函数，并且在这条语句中不做其它任何事</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> cusDel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">processWidget</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">computePriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中"><a href="#使用-Pimpl-惯用法时，将特殊成员函数的定义放到实现文件中" class="headerlink" title="使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中"></a>使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中</h2><p>Pimpl 惯用法的第一部分，是声明一个指针类型的数据成员，指向一个非完整类型：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> <span class="token class-name">Impl</span><span class="token punctuation">;</span>
    Impl<span class="token operator">*</span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        第二部分是动态分配和回收持有原始类中数据成员的对象，而分配和回收的代码被放在实现文件中：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Widget</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">Impl</span></span> <span class="token punctuation">&#123;</span>                   <span class="token comment">// Widget::Impl 的实现</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>                   <span class="token comment">// 包含在原始 Widget 类中的数据成员</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>
    Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> Impl<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>   <span class="token comment">// 为 Widget 对象分配数据成员所需内存</span>

<span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">delete</span> pImpl<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>     <span class="token comment">// 为 Widget 对象析构数据成员</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​                而到了 C++11，使用<code>std::unique_ptr</code>替代指向<code>Impl</code>的裸指针成为了首选：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 声明代码位于头文件 widget.h 内</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> <span class="token class-name">Impl</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 实现代码位于实现文件 widget.cpp 内</span>

<span class="token keyword">struct</span> <span class="token class-name">Widget</span><span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">Impl</span></span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 同前</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>
    Gadget g1<span class="token punctuation">,</span> g2<span class="token punctuation">,</span> g3<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Impl<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        遗憾的是，这段代码本身能通过编译，但在创建对象时却会报错。因为编译器自动生成的析构函数默认是<code>inline</code>的，而<code>std::unique_ptr</code>的默认删除器要求其指向完整类型，所以即使默认特殊函数的实现有着正确行为，我们仍必须将其声明和实现分离：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 声明代码位于头文件 widget.h 内</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> <span class="token class-name">Impl</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 实现代码位于实现文件 widget.cpp 内</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Impl<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 写成 Widget::~Widget() = default; 效果相同</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        声明析构函数会阻止编译器生成移动操作，所以假如你需要支持移动操作，也必须采用声明和实现分离的方法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 声明代码位于头文件 widget.h 内</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 实现代码位于实现文件 widget.cpp 内</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
Widget<span class="token operator">&amp;</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        编译器不会为带有<code>std::unique_ptr</code>这种只移类型的类生成拷贝操作，假如你需要支持拷贝操作，则需要自行编写执行深拷贝的函数实现，并且同样需要遵守前面所说的规则：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 声明代码位于头文件 widget.h 内</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Widget<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 实现代码位于实现文件 widget.cpp 内</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Impl<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

Widget<span class="token operator">&amp;</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token operator">*</span>pImpl <span class="token operator">=</span> <span class="token operator">*</span>rhs<span class="token punctuation">.</span>pImpl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        上述建议仅仅适用于<code>std::unique_ptr</code>，而不适用于<code>std::shared_ptr</code>。对于<code>std::shared_ptr</code>而言，删除器类型并非智能指针类型的一部分，这就会导致更大的运行时数据结构以及更慢的目标代码，但在使用编译器生成的特殊函数时，并不要求其指向完整类型。以下代码并不会产生问题：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment">// 不再需要析构函数或移动操作的声明</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">struct</span> <span class="token class-name">Impl</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Impl<span class="token operator">></span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        就 Pimpl 惯用法而言，并不需要在<code>std::unique_ptr</code>和<code>std::shared_ptr</code>的特性之间作出权衡，因为<code>Widget</code>和<code>Impl</code>之间的关系是专属所有权，所以在此处<code>std::unique_ptr</code>就是完成任务的合适工具。</p>
<h2 id="理解-std-move-和-std-forward"><a href="#理解-std-move-和-std-forward" class="headerlink" title="理解 std::move 和 std::forward"></a>理解 std::move 和 std::forward</h2><p>​        <code>std::move</code>执行的是<strong>向右值的无条件强制类型转换</strong>，就其自身而言，它不会移动任何东西。它的基本实现大致是这样的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// C++11 版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// C++14 版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> ReturnType <span class="token operator">=</span> remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ReturnType<span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <code>std::move</code>并不改变常量性，也<strong>不保证经过其强制类型转换后的对象可被移动，针对常量对象执行的移动操作可能会悄无声息地转化为拷贝操作</strong>，如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Annotation</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">Annotation</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string text<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// 想要将 text “移动入” value</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">// 但实际上执行了 std::string 的拷贝构造函数</span>
                                            <span class="token comment">// 而非移动构造函数 string(string&amp;&amp;)</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        因此，如果想要取得对某个对象执行移动操作的能力，就不要将其声明为常量。</p>
<p>​        与<code>std::move</code>不同，<code>std::forward</code>是有条件的。仅当传入的实参被绑定到右值时，<code>std::forward</code>才会针对该实参执行向右值的强制类型转换，它同样不会转发任何东西。<code>std::forward</code>的一个典型应用场景，是某个函数模板使用万能引用作为形参，随后将其传递给另一个函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">const</span> Widget<span class="token operator">&amp;</span> lvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 处理左值</span>
<span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rvalArg<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 处理右值</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">logAndProcess</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 使用万能引用作为实参</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">makeLogEntry</span><span class="token punctuation">(</span><span class="token string">"Calling 'process'"</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        若在调用<code>logAndProcess</code>时传入左值，那么该左值自然会传递给处理左值版本的<code>process</code>函数；若在调用<code>logAndProcess</code>时传入右值，由于函数形参皆为左值，必须要通过<code>std::forward</code>将<code>param</code>强制转换为右值类型，才能得以正确调用处理右值版本的<code>process</code>函数。<code>std::forward</code>会通过模板类型<code>T</code>来判断是否该对<code>param</code>进行强制类型转换。</p>
<p>​        尽管<code>std::move</code>和<code>std::forward</code>归根结底都是强制类型转换，但两者的行为具有本质上的不同：<strong>前者用于为移动操作进行铺垫，而后者仅仅用于转发一个对象到另一个函数，在此过程中该对象仍保持原来的左值性或右值性。</strong>（人话版本：std::forward只是传递变量的左值性和右值性）</p>
<blockquote>
<p>需要注意的是，在运行期，<code>std::move</code>和<code>std::forward</code>都不会做任何操作。</p>
</blockquote>
<h2 id="区分万能引用和右值引用"><a href="#区分万能引用和右值引用" class="headerlink" title="区分万能引用和右值引用"></a>区分万能引用和右值引用</h2><p>​        如果函数模板形参的类型为<code>T&amp;&amp;</code>，并且 T 的类型需要推导得到，或一个对象使用<code>auto&amp;&amp;</code>声明其类型，则此处的<code>T&amp;&amp;</code>和<code>auto&amp;&amp;</code>表示<strong>万能引用（universal reference）</strong>；如果类型声明不是标准的<code>type&amp;&amp;</code>形式，或者并未发生类型推导，则此处的<code>type&amp;&amp;</code>表示右值引用。</p>
<p>符合万能引用的情形如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> var2 <span class="token operator">=</span> var1<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">>></span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token function">emplace_back</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> timeFuncInvocation <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> func<span class="token punctuation">,</span> <span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// C++14</span>
    std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span>                         <span class="token comment">// 调用 func</span>
        std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               <span class="token comment">// 取用 params</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        类型声明不是标准<code>type&amp;&amp;</code>的情形如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// param 是右值引用</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// param 是右值引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        类型是<code>T&amp;&amp;</code>，但并未发生类型推导的情形如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">>></span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">push_back</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// x 是右值引用</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <strong>若使用右值来初始化万能引用，就会得到一个右值引用；同理，若使用左值来初始化万能引用，就会得到一个左值引用。</strong>如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// param 是万能引用</span>

Widget w<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 左值被传递给 f，param 的类型为 Widget&amp;</span>

<span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 右值被传递给 f，param 的类型为 Widget&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="针对右值引用实施-std-move，针对万能引用实施-std-forward"><a href="#针对右值引用实施-std-move，针对万能引用实施-std-forward" class="headerlink" title="针对右值引用实施 std::move，针对万能引用实施 std::forward"></a>针对右值引用实施 std::move，针对万能引用实施 std::forward</h2><p>​        右值引用一定会被绑定到右值，因此当转发右值引用给其他函数时，应当通过<code>std::move</code>对其实施向右值的无条件强制类型转换：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Widget</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
          <span class="token function">p</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>SomeDataStructure<span class="token operator">></span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        而万能引用不一定会被绑定到右值，因此当转发万能引用时，应当通过<code>std::forward</code>对其实施向右值的有条件强制类型转换：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        name <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        虽然针对右值引用实施<code>std::forward</code>也能硬弄出正确行为，但代码啰嗦、易错，且不符合习惯用法；而针对万能引用实施<code>std::move</code>会造成更加严重的后果，这会导致某些左值遭受意外的改动：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        name <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>SomeDataStructure<span class="token operator">></span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>string <span class="token function">getWidgetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 工厂函数</span>

Widget w<span class="token punctuation">;</span>
<span class="token keyword">auto</span> n <span class="token operator">=</span> <span class="token function">getWidgetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
w<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 将 n 移入 w</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                         <span class="token comment">// n 的值变为未知</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        一种手法是将万能引用的版本改成对左值和右值分别进行重载：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        name <span class="token operator">=</span> newName<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        name <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种手法虽然看似可以解决问题，但是拥有更大的缺点：第一，需要编写和维护更多源码；第二，效率会大打折扣（产生额外的临时对象）；第三，可扩展性太差。因此，正确地使用万能引用才是问题的唯一解决之道。</p>
<p>在有些情况下，你可能想在函数内将某个对象不止一次地绑定到右值引用或万能引用，并且想保证在完成对该对象地其它所有操作之前，其值不会发生移动，那么就得仅在最后一次使用该引用时，对其实施<code>std::move</code>或<code>std::forward</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">setSignText</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> text<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    sign<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 使用 text，但不修改其值</span>

    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    signHistory<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>now<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 有条件地将 text 强制转换为右值</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在极少数的情况下，你需要用<code>std::move_if_noexcept</code>来代替<code>std::move</code>。</p>
<blockquote>
<p><code>std::move_if_noexcept</code>是<code>std::move</code>的一个变体，它是否会将对象强制转换为右值，取决于其类型的移动构造函数是否带有 noexcept 声明。</p>
</blockquote>
<p>​        在按值返回的函数中，如果返回的是绑定到右值引用或万能引用的对象，则当你返回该引用时，应当对其实施<code>std::move</code>或<code>std::forward</code>，这样可以避免编译器将其视作左值，从而消除拷贝左值进入返回值存储位置的额外开销：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 按值返回右值引用形参</span>
Matrix <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span>Matrix<span class="token operator">&amp;&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Matrix<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    lhs <span class="token operator">+=</span> rhs<span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 按值返回万能引用形参</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
Fraction <span class="token function">reduceAndCopy</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> frac<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    frac<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>frac<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是若局部对象可能适用于<strong>返回值优化（return value optimization，RVO）</strong>，则请勿对其实施<code>std::move</code>或<code>std::forward</code>。这是因为当 RVO 的前提条件得到满足时，要么发生<strong>拷贝省略（copy elision）</strong>，要么<code>std::move</code>会隐式地被实施于返回的局部对象上；而人为地添加<code>std::move</code>或<code>std::forward</code>，会导致编译器失去执行 RVO 的能力。</p>
<p>​        下面的<code>makeWidget</code>函数满足 RVO 的两个前提条件：<strong>局部对象类型和函数返回值类型相同，且返回的就是局部对象本身</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> w<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但由于函数形参不适合实施拷贝省略，所以编译器必须处理以上代码，使其与以下代码等价：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="避免对万能引用类型进行重载"><a href="#避免对万能引用类型进行重载" class="headerlink" title="避免对万能引用类型进行重载"></a>避免对万能引用类型进行重载</h2><p>​        参为万能引用的函数是 C++ 中最贪婪的，它们会在具现过程中和几乎所有实参类型产生精确匹配），这就是为何把重载和万能引用两者结合通常不会达到预期效果。考虑如下情形：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

std<span class="token double-colon punctuation">::</span>string <span class="token function">nameFromIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">short</span> nameIdx<span class="token punctuation">;</span>      <span class="token comment">// 用 short 类型持有索引值</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token function">logAndAdd</span><span class="token punctuation">(</span>nameIdx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用的却是万能引用版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <code>logAndAdd</code>有两个重载版本，形参类型为万能引用的版本可以将<code>T</code>推导为<code>short</code>，从而产生精确匹配；而形参类型为<code>int</code>的版本却只能在类型提升后才可以匹配到<code>short</code>类型的实参。因此，形参类型为万能引用的版本才是被优先调用的版本。</p>
<p>​        当完美转发出现在类的构造函数中时，情况会变得更加复杂：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>        <span class="token comment">// 完美转发构造函数</span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 形参为 int 的构造函数</span>

    <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> Person<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 拷贝构造函数（由编译器生成）</span>

    <span class="token function">Person</span><span class="token punctuation">(</span>Person<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 移动构造函数（由编译器生成）</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <strong>对于非常量的左值类型，完美转发构造函数一般都会优先于拷贝构造函数形成匹配；而对于常量左值类型，完美转发构造函数和拷贝构造函数具有相等的匹配程度，此时由于非函数模板会优先于函数模板被匹配，编译器才会转向调用拷贝构造函数：</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Person <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">cloneOfP</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 调用完美转发构造函数，无法通过编译</span>

<span class="token keyword">const</span> Person <span class="token function">cp</span><span class="token punctuation">(</span><span class="token string">"Nancy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 对象成为了常量</span>
<span class="token keyword">auto</span> <span class="token function">cloneOfCp</span><span class="token punctuation">(</span>cp<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 会正确调用拷贝构造函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完美转发构造函数还会劫持派生类中对基类的拷贝和移动构造函数的调用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SpecialPerson</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">SpecialPerson</span><span class="token punctuation">(</span><span class="token keyword">const</span> SpecialPerson<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token comment">// 拷贝构造函数</span>
        <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>                    <span class="token comment">// 调用的是基类的完美转发构造函数！</span>

    <span class="token function">SpecialPerson</span><span class="token punctuation">(</span>SpecialPerson<span class="token operator">&amp;&amp;</span> rhs<span class="token punctuation">)</span>      <span class="token comment">// 移动构造函数</span>
        <span class="token operator">:</span> <span class="token function">Person</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>         <span class="token comment">// 调用的是基类的完美转发构造函数！</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="熟悉对万能引用类型进行重载的替代方案"><a href="#熟悉对万能引用类型进行重载的替代方案" class="headerlink" title="熟悉对万能引用类型进行重载的替代方案"></a>熟悉对万能引用类型进行重载的替代方案</h2><p><strong>1. 放弃重载</strong></p>
<p><strong>2. 传递<code>const T&amp;</code>类型的形参</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这种做法可以避免重载万能引用带来的不良影响，但会舍弃一些性能。</p>
<p><strong>3. 传值</strong></p>
<p>​        把传递的形参从引用类型换成值类型，是一种经常能够提升性能，却不会增加任何复杂性的方法，尽管这有些反直觉。当你知道肯定需要复制形参时，考虑按值传递对象：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string n<span class="token punctuation">)</span>  <span class="token comment">// 替换掉 T&amp;&amp; 类型的构造函数</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span>        <span class="token comment">// 同前</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>4. 使用标签分派（tag dispatch）</strong></p>
<p>​        在这个方案中，我们将实际重载和实现功能的函数改为<code>logAndAddImpl</code>，而<code>logAndAdd</code>仅仅用于执行完美转发和标签分派：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">logAndAdd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>
        std<span class="token double-colon punctuation">::</span>is_integral<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// C++14 可以使用 std::remove_reference_t</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        针对<code>std::is_integral</code>产生的布尔值，我们可以写出两个<code>logAndAddImpl</code>重载版本，用于区分它们的类型<code>std::false_type</code>和<code>std::true_type</code>就是所谓 “标签”。具体实现代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> name<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>false_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 非整型实参</span>
    <span class="token keyword">auto</span> now <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>system_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">log</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"logAndAdd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    names<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

std<span class="token double-colon punctuation">::</span>string <span class="token function">nameFromIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">logAndAddImpl</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>true_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 整型实参</span>
    <span class="token function">logAndAdd</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>5. 对接受万能引用的模板施加限制</strong></p>
<p>通过 SFINAE 技术和<code>std::enable_if</code>，我们可以让一些模板在满足了指定条件的情况下才被启用，它的使用方式大致如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
             <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>condition<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">></span>    <span class="token comment">// C++14 可以使用 std::enable_if_t</span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此处我们想要<code>T</code>是<code>Person</code>以外的类型时，才启用该模板构造函数，则我们可以写下面这样的条件：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">!</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>decay<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">></span><span class="token double-colon punctuation">::</span>value  <span class="token comment">// C++17 可以使用 std::is_same_v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>std::decay</code>用于使类型完全退化，在此处用来移除<code>T</code>的引用和 cv 限定符（即<code>const</code>或<code>volatile</code>限定符），使我们可以更加纯粹地关注类型本身。<code>std::decay</code>还可以用于把数组和函数类型强制转换为指针类型，它当然也拥有更易用的 C++14 版本，即<code>std::decay_t</code>。</p>
<p>​        写出这个条件并不意味着完成，我们想要的是为<code>Person</code>和继承自<code>Person</code>的类型都不一样的实参类型启用模板构造函数。标准库中的<code>std::is_base_of</code>用于判断一个类型是否由另一个类型派生而来，用它代替<code>std::is_same</code>就可以得到我们想要的东西（C++17 可以使用<code>std::is_base_of_v</code>）：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span>
        <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
        <span class="token keyword">typename</span> <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>
                       <span class="token operator">!</span>std<span class="token double-colon punctuation">::</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> 
                                        <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>decay<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type
                                       <span class="token operator">></span><span class="token double-colon punctuation">::</span>value
                   <span class="token operator">></span><span class="token double-colon punctuation">::</span>type
    <span class="token operator">></span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        再加上处理整型实参的构造函数重载版本，并进一步限制模板构造函数，禁止其接受整型实参，我们得到的完美的<code>Person</code>类代码如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span>
        <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
        <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span>
            <span class="token operator">!</span>std<span class="token double-colon punctuation">::</span>is_base_of<span class="token operator">&lt;</span>Person<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>decay_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token double-colon punctuation">::</span>value
            <span class="token operator">&amp;&amp;</span>
            <span class="token operator">!</span>std<span class="token double-colon punctuation">::</span>is_integral<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">>></span><span class="token double-colon punctuation">::</span>value
        <span class="token operator">></span>
    <span class="token operator">></span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>              <span class="token comment">// 接受 std::string 类型以及可以强制转换为 </span>
    <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>  <span class="token comment">// std::string 类型的实参的构造函数</span>

    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span>            <span class="token comment">// 接受整型实参的构造函数</span>
    <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token function">nameFromIdx</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment">// 拷贝和移动构造函数等</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>权衡</strong></p>
<p>​        本条款讨论的前三种方案（舍弃重载，传递<code>const T&amp;</code>类型的形参和传值）都需要对待调用的函数形参逐一指定类型，而后两种方案（使用标签分派和对接受万能引用的模板施加限制）则使用了完美转发，因此无需指定形参类型。</p>
<p>​        按照常理，完美转发的效率更高，因为它将类型保持和形参声明时完全一致，所以会避免创建临时对象。但完美转发也有一些不足：首先是针对某些类型无法实现完美转发，其次是完美转发会使得在传递非法形参时，出现更难理解的错误信息。<code>std::is_constructible</code>这个类型特征（type trait）可以在编译期判断某个类型的对象是否可以用另一类型的对象（或不同类型的多个对象）来构造，我们可以用它来验证转发函数的万能引用形参是否合法。下面是增加了<code>static_assert</code>后的<code>Person</code>类，它可以产生更明确的报错信息：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span>  <span class="token comment">// 同前</span>
    <span class="token keyword">explicit</span> <span class="token function">Person</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> n<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 断言可以用 T 类型的对象构造 std::string</span>
        <span class="token keyword">static_assert</span><span class="token punctuation">(</span>
            std<span class="token double-colon punctuation">::</span>is_constructible<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> T<span class="token operator">></span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span>   <span class="token comment">// C++17 可以使用 std::is_constructible_v</span>
            <span class="token string">"Parameter n can't be used to construct a std::string"</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 构造函数通常要完成的工作</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="理解引用折叠"><a href="#理解引用折叠" class="headerlink" title="理解引用折叠"></a>理解引用折叠</h2><p>​        万能引用并非一种新的引用类型，其实它就是在满足下面两个条件的语境中的右值引用：</p>
<ol>
<li>类型推导的过程中会区分左值和右值；</li>
<li>会发生<strong>引用折叠（reference collapsing）</strong>。</li>
</ol>
<p>​        C++ 标准禁止直接声明 “引用的引用” ，但引用折叠不受此限制。当左值被传递给接受万能引用的函数模板时，会发生下面这样的状况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">func</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 调用 func 并传入左值，T 推导出的类型为 Widget&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        代入<code>T</code>的推导类型，我们可以得到下面这样的具现化模板：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>出现了引用的引用！然而这并不违规，引用折叠的规则会把双重引用折叠成单个引用，规则如下：</p>
<blockquote>
<p>如果任一引用为左值引用，则结果为左值引用，否则（即两个皆为右值引用），结果为右值引用。</p>
</blockquote>
<p>所以实际上的函数签名为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        引用折叠是使<code>std::forward</code>得以运作的关键，也是将左值或右值信息编码到万能引用形参<code>T</code>中的实现途径。<code>std::forward</code>的任务是，当且仅当编码在<code>T</code>中的信息表明传递的实参是右值，即<code>T</code>推导出的类型是个非引用类型时，对左值形参实施到右值的强制类型转换。它的基本实现大致是这样的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// C++11 版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// C++14 版本</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        假设传递给函数<code>forward</code>的实参类型是左值<code>Widget</code>，则模板的具现化结果可以写成：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        发生引用折叠后，生成的最终结果如下，可以看出左值类型并不会发生改变：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget<span class="token operator">&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        假设传递给函数<code>forward</code>的实参类型是右值<code>Widget</code>，则模板的具现化结果可以写成：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        发生引用折叠后，生成的最终结果如下，显然左值类型的形参会被强制转换为右值：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>Widget<span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        引用折叠会在四种语境中出现：模板具现化，<code>auto</code>类型推断，创建和使用<code>typedef</code>和别名声明，以及<code>decltype</code>。<code>auto</code>类型推断中发生的引用折叠：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget w<span class="token punctuation">;</span>                       <span class="token comment">// 变量（左值）</span>
Widget <span class="token function">widgetFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回右值的函数</span>

<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> w1 <span class="token operator">=</span> w<span class="token punctuation">;</span>                  <span class="token comment">// 推导出 Widget&amp; &amp;&amp; w1，引用折叠后为 Widget&amp; w1</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> w2 <span class="token operator">=</span> <span class="token function">widgetFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 推导出 Widget&amp;&amp; w1，不会发生引用折叠</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        创建和使用<code>typedef</code>中发生的引用折叠：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">typedef</span> T<span class="token operator">&amp;&amp;</span> RvalueRefToT<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Widget<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">></span> w<span class="token punctuation">;</span> <span class="token comment">// 用左值引用类型来具现化 Widget 模板</span>

<span class="token comment">// 具现化后得到 typedef int&amp; &amp;&amp; RvalueRefToT</span>
<span class="token comment">// 引用折叠后为 typedef int&amp; RvalueRefToT</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        最后一种会发生引用折叠的语境在<code>decltype</code>的运用中：如果在分析一个涉及<code>decltype</code>的类型时出现了引用的引用，则引用折叠会介入并将其消灭。</p>
<h2 id="假定移动操作不存在、成本高、未被使用"><a href="#假定移动操作不存在、成本高、未被使用" class="headerlink" title="假定移动操作不存在、成本高、未被使用"></a>假定移动操作不存在、成本高、未被使用</h2><p>在下面几个情形下，C++11 的移动语义不会给你带来什么好处：</p>
<ul>
<li><strong>没有移动操作：</strong> 待移动的对象未能提供移动操作。因此，移动请求就变成了拷贝请求。</li>
<li><strong>移动未能更快：</strong> 待移动的对象虽然有移动操作，但并不比其拷贝操作更快。</li>
</ul>
<blockquote>
<p>移动操作不比拷贝操作更快的例子：<code>std::array</code>将数据直接存储在对象内，移动<code>std::array</code>需要逐个移动容器内的每个元素；开启了<strong>短字符串优化（small string optimization，SSO）</strong> 的<code>std::string</code>，它会将字符串存储在<code>std::string</code>对象的某个缓冲区内，而非使用堆上的内存。</p>
</blockquote>
<ul>
<li><strong>移动不可用：</strong> 移动本可以发生的情况下，要求移动操作不会抛出异常，但该操作未加上<code>noexcept</code>声明。</li>
<li><strong>源对象是左值：</strong> 只有右值可以作为移动操作的源。</li>
</ul>
<p>因此，我们应该为通用的代码假定移动操作不存在、成本高且未被使用。然而，对于已知的类型或支持移动语义的代码中，就不需要作上述假定，在你知道移动操作成本低廉的情况下，可以放心大胆地将拷贝操作替换为相对不那么昂贵的移动操作。</p>
<h2 id="熟悉完美转发的失败情形"><a href="#熟悉完美转发的失败情形" class="headerlink" title="熟悉完美转发的失败情形"></a>熟悉完美转发的失败情形</h2><p>​        完美转发的含义是我们不仅转发对象，还转发其特征：类型，是左值还是右值，以及是否带有<code>const</code>和<code>volatile</code>限定符。出于此目的，我们会运用万能引用来将左、右值信息编码到类型中，而用于转发的函数自然也该是泛型的，它的标准形式如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">fwd</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        为了使转发函数能接受任意数量的形参，使用可变参数模板也在我们的考虑范围内：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">fwd</span><span class="token punctuation">(</span>Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        若用相同实参调用<code>f</code>和<code>fwd</code>会执行不同的操作，则称<code>fwd</code>将实参完美转发到<code>f</code>失败。完美转发的失败情形源于模板类型推导失败，或推导出错误的类型。下面我们将了解会造成完美转发失败的典型例子。</p>
<p><strong>大括号初始值设定项（Braced initializers）</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// “&#123; 1, 2, 3 &#125;” 会隐式转换为 std::vector&lt;int></span>
<span class="token function">fwd</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 无法通过编译！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        由于<code>fwd</code>的形参为被声明为<code>std::initializer_list</code>，编译器就会被禁止在<code>fwd</code>的调用过程中从表达式<code>&#123; 1, 2, 3 &#125;</code>出发来推导类型。既然无法推导出形参的类型，那么编译器也只能拒绝对<code>fwd</code>的调用。</p>
<p>我们可以通过先用<code>auto</code>声明一个局部变量，再传递给<code>fwd</code>来避免这个问题：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> il <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>  <span class="token comment">// il 的类型被推导为 std::initializer_list&lt;int></span>
<span class="token function">fwd</span><span class="token punctuation">(</span>il<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 没问题，将 il 完美转发给 f</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>0 和 NULL 作空指针</strong></p>
<p>​        当你试图将<code>0</code>或<code>NULL</code>作为空指针传递给模板时，类型推导就会发生错误，将实参推导为一个整型而非指针类型，结果不管是<code>0</code>还是<code>NULL</code>都不会作为空指针被完美转发。解决方法非常简单，传一个<code>nullptr</code>而不是<code>0</code>或<code>NULL</code>。</p>
<p><strong>仅有声明的整型<code>static const</code>成员变量</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>size_t MinVals <span class="token operator">=</span> <span class="token number">28</span><span class="token punctuation">;</span>  <span class="token comment">// 仅提供 MinVals 的声明</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                                          <span class="token comment">// 未给出 MinVals 的定义</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t v<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>Widget<span class="token double-colon punctuation">::</span>MinVals<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 没问题，当作 “f(28)” 处理</span>
<span class="token function">fwd</span><span class="token punctuation">(</span>Widget<span class="token double-colon punctuation">::</span>MinVals<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 可能无法通过链接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        一般而言，编译器会绕过<code>MinVals</code>缺少定义的事实，并用其值替换所有涉及到<code>MinVals</code>的地方，但并不会为其实际分配存储空间。这就导致如果我们尝试对<code>MinVals</code>实施取地址或对它进行引用，就会导致链接无法通过，这也就是为何不能将<code>Widget::MinVals</code>作为实参传递给<code>fwd</code>。</p>
<p>​        按照标准，按引用传递<code>MinVals</code>时要求<code>MinVals</code>有定义。然而并不是所有实现都遵循了这个规定，对于一些编译器和链接器，你会发现将<code>MinVals</code>用于完美转发并不会产生错误，甚至对它取地址也不会。但为了代码的可移植性，还是应当重视此处所讲的规则，为<code>static const</code>成员变量提供定义：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>size_t Widget<span class="token double-colon punctuation">::</span>MinVals<span class="token punctuation">;</span>  <span class="token comment">// 在 Widget 的 .cpp 文件中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>重载函数的名称和模板名称</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 或者 void f(int pf(int))</span>

<span class="token keyword">int</span> <span class="token function">processVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">processVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span>processVal<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 没问题</span>
<span class="token function">fwd</span><span class="token punctuation">(</span>processVal<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 错误！无法确定是哪个重载版本</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
T <span class="token function">workOnVal</span><span class="token punctuation">(</span>T param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>

<span class="token function">fwd</span><span class="token punctuation">(</span>workOnVal<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 错误！无法确定是 workOnVal 的哪个实例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        当我们将<code>processVal</code>传递给<code>f</code>时，由于<code>f</code>的形参类型是已知的，编译器自然也知道它需要的是<code>processVal</code>的哪个重载版本；但纯粹的函数名称<code>processVal</code>并不包含类型信息，类型推导更是无从谈起，将它传递给<code>fwd</code>只会造成完美转发失败而已。</p>
<p>​        要让<code>fwd</code>接受重载函数的名称或模板名称，只能手动指定需要转发的哪个重载版本或模板实例。例如下面的做法就是合理的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> ProcessFuncType <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ProcessFuncType processValPtr <span class="token operator">=</span> processVal<span class="token punctuation">;</span>     <span class="token comment">// 指定了需要的 processVal 签名</span>

<span class="token function">fwd</span><span class="token punctuation">(</span>processValPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">// 没问题</span>
<span class="token function">fwd</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ProcessFuncType<span class="token operator">></span></span></span><span class="token punctuation">(</span>workOnVal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 也没问题</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>位域</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">IPv4Header</span> <span class="token punctuation">&#123;</span>                 <span class="token comment">// 用于表示 IPv4 头部的模型</span>
    std<span class="token double-colon punctuation">::</span><span class="token keyword">uint32_t</span> version<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>
                  IHL<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">,</span>
                  DSCP<span class="token operator">:</span><span class="token number">6</span><span class="token punctuation">,</span>
                  ECN<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>
                  totalLength<span class="token operator">:</span><span class="token number">16</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t sz<span class="token punctuation">)</span><span class="token punctuation">;</span>

IPv4Header h<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token function">f</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 没问题</span>
<span class="token function">fwd</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 错误！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        C++ 标准规定：非常引用不得绑定到位域。位域是由机器字的若干任意部分组成的，但这样的实体是无法对其直接取地址的，无法将指针指向它，因此也无法对其进行引用。</p>
<blockquote>
<p>实际上常引用也不可能绑定到位域，它们绑定到的是 “常规” 对象（某种标准整型，例如<code>int</code>），其中拷贝了位域的值。</p>
</blockquote>
<p>​        将位域传递给转发函数的可能途径是制作一个副本，并以该副本调用转发函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 拷贝位域值，使用的初始化形式参考条款 6</span>
<span class="token keyword">auto</span> length <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span><span class="token keyword">uint16_t</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>totalLength<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">fwd</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 转发该副本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><p>​        在开始本章之前，需要理解几个基本的概念：</p>
<ul>
<li><strong>lambda 表达式（lambda expression）：</strong> 表达式的一种，它的基本写法如下所示：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token operator">&lt;</span> val <span class="token operator">&amp;&amp;</span> val <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><strong>闭包（closure）：</strong> lambda 所创建的运行期对象，根据不同的捕获模式，闭包会持有数据的副本或引用。</li>
<li><strong>闭包类（closure class）：</strong> 实例化闭包的类，每个 lambda 都会使编译器生成唯一的闭包类。lambda 中的语句会成为其闭包类的成员函数中的可执行指令。</li>
</ul>
<blockquote>
<p>lambda 表达式和闭包类存在于编译期，而闭包存在于运行期。</p>
</blockquote>
<h2 id="避免默认捕获模式"><a href="#避免默认捕获模式" class="headerlink" title="避免默认捕获模式"></a>避免默认捕获模式</h2><p>​        C++11 中有两种默认捕获模式：按引用或按值。按引用捕获会导致闭包内包含指向局部变量的引用，或指向定义 lambda 的作用域内形参的引用，一旦由 lambda 所创建的闭包越过了该局部变量或形参的生命周期，那么闭包内的引用就会发生空悬：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> FilterContainer <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">;</span>
FilterContainer filters<span class="token punctuation">;</span>                                <span class="token comment">// 元素为筛选函数的容器</span>

<span class="token keyword">void</span> <span class="token function">addDivisorFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">// 危险！指向 divisor 的引用可能空悬</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>换作用显式方式按引用捕获<code>divisor</code>，问题依旧会发生，但更容易看出 lambda 依赖于<code>divisor</code>的生命周期这一问题：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token operator">&amp;</span>divisor<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        一种权宜之计是不使用容器来存放筛选函数，转而使用 C++11 的<code>std::all_of</code>对每个元素逐一进行判断。但如果将该 lambda 拷贝到其它闭包比<code>divisor</code>生命周期更长的语境中，则空悬引用的问题仍会发生：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">C</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">workWithContainer</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">using</span> ContElemT <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">C</span><span class="token double-colon punctuation">::</span>value_type<span class="token punctuation">;</span>           <span class="token comment">// 取得容器中的元素类型（参考条款 13）</span>

    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>begin<span class="token punctuation">;</span>
    <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>end<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">all_of</span><span class="token punctuation">(</span><span class="token function">begin</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">end</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">// 判断是否所有元素都是 divisor 的倍数</span>
        <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> ContElemT<span class="token operator">&amp;</span> value<span class="token punctuation">)</span>                     <span class="token comment">// C++14 可以直接写成 const auto&amp; value</span>
        <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在本例中，使用默认的按值捕获模式就足以解决问题：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
    <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        但是默认的按值捕获模式也有其问题：默认的按值捕获极易受到空悬指针的影响（尤其是<code>this</code>指针），并且会误导人们认为 lambda 是独立的。考虑如下情形：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> divisor<span class="token punctuation">;</span>    <span class="token comment">// 用于 Widget 的 filters</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于此处的 lambda 而言，<code>divisor</code>既不是局部变量，也不是形参，按理来讲是压根无法被捕获的。事实也确实如此，被捕获的实际上是<code>Widget</code>的<code>this</code>指针，而不是<code>divisor</code>。对于编译器来说，<code>addFilter</code>的代码相当于：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> currentObjectPtr <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span>currentObjectPtr<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value <span class="token operator">%</span> currentObjectPtr<span class="token operator">-></span>divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        理解了这一点，也就能理解 lambda 闭包的存活依赖于它含有的<code>this</code>指针副本所指向的<code>Widget</code>对象的生命周期。假如面临以下代码，空悬指针的问题将出现在我们的眼前：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> FilterContainer <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token punctuation">;</span>
FilterContainer filters<span class="token punctuation">;</span>                    <span class="token comment">// 同前</span>

<span class="token keyword">void</span> <span class="token function">doSomeWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> pw <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 创建 Widget，std::make_unique 的使用参考条款 21</span>

    pw<span class="token operator">-></span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 添加使用了 Widget::divisor 的筛选函数</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>                                           <span class="token comment">// Widget 被销毁，filters 现在持有空悬指针！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        一种解决方法是将你想捕获的成员变量拷贝至局部变量中，之后再捕获该副本局部变量：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> divisorCopy <span class="token operator">=</span> divisor<span class="token punctuation">;</span>

    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span>divisorCopy<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisorCopy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在 C++14 中，捕获成员变量的一种更好的方法是使用<strong>广义 lambda 捕获</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">addFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span>divisor <span class="token operator">=</span> divisor<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>  <span class="token comment">// C++14: 将 divisor 拷贝入闭包并使用副本</span>
        <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        默认的按值捕获模式的另一个缺点是，它会使人们误认为闭包是独立的，与闭包外的数据变化相隔绝。但实际上并非如此，lambda 可能不仅依赖于局部变量和形参，还会依赖于<strong>静态存储期（static storage duration）对象</strong>，这样的对象可以在 lambda 中使用，但却无法被捕获。下面这个例子足以体现这一点会造成的问题：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">addDivisorFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token keyword">auto</span> calc1 <span class="token operator">=</span> <span class="token function">computeSomeValue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">auto</span> calc2 <span class="token operator">=</span> <span class="token function">computeSomeValue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token keyword">auto</span> divisor <span class="token operator">=</span> <span class="token function">computeDivisor</span><span class="token punctuation">(</span>calc1<span class="token punctuation">,</span> calc2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    filters<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>
        <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span>                      <span class="token comment">// 未捕获任何东西！</span>
        <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> value <span class="token operator">%</span> divisor <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// 引用上面的 static 对象</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token operator">++</span>divisor<span class="token punctuation">;</span>                              <span class="token comment">// 意外修改了 divisor</span>
                                            <span class="token comment">// 导致每个 lambda 都出现新的行为</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用初始化捕获将对象移入闭包"><a href="#使用初始化捕获将对象移入闭包" class="headerlink" title="使用初始化捕获将对象移入闭包"></a>使用初始化捕获将对象移入闭包</h2><p>C++14 中新增的<strong>初始化捕获（init capture，又称广义 lambda 捕获）</strong>，可以让你指定：</p>
<ol>
<li>由 lambda 生成的闭包类中成员变量的名字。</li>
<li>一个用于初始化该成员变量的表达式。</li>
</ol>
<p>下面演示了如何使用初始化捕获将<code>std::unique_ptr</code>移入闭包内：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>

    <span class="token keyword">bool</span> <span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">isProcessed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> <span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>

<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> pw <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 创建 Widget，std::make_unique 的使用参考条款 21</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">// 配置 *pw</span>

<span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment">// 使用 std::move(pw) 初始化闭包类的数据成员</span>
            <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pw<span class="token operator">-></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        如果经由<code>std::make_unique</code>创建的对象已具备被 lambda 捕获的合适状态，则闭包类成原对象可以直接由<code>std::make_unique</code>完成初始化：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
            <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pw<span class="token operator">-></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        在初始化捕获的代码中，位于<code>=</code>左侧的是所指定的闭包类成员变量的名称，右侧的则是其初始化表达式。值得一提的是，<code>=</code>的左右两侧位于不同的作用域，左侧作用域就是闭包的作用域，而右侧作用域则与 lambda 定义所在的作用域相同。</p>
<p>​        在 C++11 中，我们虽然无法使用初始化捕获，但是可以依靠原理相同的手写类达到目的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">IsValAndArch</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> DataType <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token punctuation">;</span>

    <span class="token keyword">explicit</span> <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>DataType<span class="token operator">&amp;&amp;</span> ptr<span class="token punctuation">)</span>   <span class="token comment">// std::move 的使用参考条款 25</span>
        <span class="token operator">:</span> <span class="token function">pw</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// 编写仿函数</span>
        <span class="token keyword">return</span> pw<span class="token operator">-></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    DataType pw<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token function">IsValAndArch</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你非要使用 lambda，按移动捕获也可以通过以下方法模拟：</p>
<ol>
<li>将需要捕获的对象移至<code>std::bind</code>所产生的函数对象中。</li>
<li>给予 lambda 一个指向想要 “捕获” 的对象的引用。</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> data<span class="token punctuation">;</span>

<span class="token keyword">auto</span> func <span class="token operator">=</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>   <span class="token comment">// C++11 模拟初始化捕获</span>
              <span class="token punctuation">&#123;</span> <span class="token comment">/* 使用 data */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
              std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>std::bind</code>的第一个实参是个可调用对象，接下来的所有实参表示传给该对象的值。和 lambda 表达式类似，<code>std::bind</code>也会生成函数对象（原书中称其为<strong>绑定对象，bind object</strong>），其中含有传递给<code>std::bind</code>的所有实参的副本，其中左值实参执行的是拷贝构造，而右值实参执行的则是移动构造。因此，在此处用<code>std::move(data)</code>作为实参可以让<code>data</code>被移入绑定对象中，被 lambda 的左值引用形参所接受。</p>
<p>​        默认情况下，lambda 生成的闭包类中的<code>operator()</code>成员函数会带有<code>const</code>限定符，它会导致是闭包类里的所有成员变量在 lambda 的函数体内都会带有<code>const</code>限定符。但是，绑定对象里通过移动构造得到的<code>data</code>副本却并不带有<code>const</code>限定符。因此，为了防止该<code>data</code>副本在 lambda 中被意外修改，我们会将其形参声明为常引用。但如果 lambda 在声明时带有<code>mutable</code>限定符，则闭包里的<code>operator()</code>就不再会带有<code>const</code>限定符，也不必再将形参声明为常引用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token keyword">mutable</span>
              <span class="token punctuation">&#123;</span> <span class="token comment">/* 使用 data */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
              std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>回到之前的例子，使用 C++14 在闭包内创建<code>std::unique_ptr</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span>pw <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
            <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pw<span class="token operator">-></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>它在 C++11 中的模拟代码可以这样编写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span><span class="token operator">&amp;</span> pw<span class="token punctuation">)</span>
                      <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> pw<span class="token operator">-></span><span class="token function">isValidated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> pw<span class="token operator">-></span><span class="token function">isArchived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
                      std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward"><a href="#对-auto-amp-amp-类型的形参使用-decltype-以对其实施-std-forward" class="headerlink" title="对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward"></a>对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward</h2><p>​        C++14 支持<strong>泛型 lambda（generic lambda）</strong>，可以在声明形参时使用<code>auto</code>，即闭包类中的<code>operator()</code>可以用模板实现。例如，给定以下 lambda：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        则闭包类的<code>operator()</code>实现大致如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">SomeCompilerGeneratedClassName</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
    <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// auto 类型的返回值，参考条款 3</span>
        <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在此处，lambda 总会传递左值给<code>normalize</code>，这对于一个会区别对待左、右值的<code>normalize</code>显然是不行的。如果想要保留实参的左、右值性，就需要将形参声明为万能引用，并使用<code>std::forward</code>将其转发给<code>normalize</code>。这样的改造十分简单，唯一的问题是在 lambda 中，我们并没有可用的模板形参<code>T</code>，只能对要转发的形参使用<code>decltype</code>，以取得其类型：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        使用<code>std::forward</code>的惯例是：用左值引用类型的模板形参来表明想要返回左值，用非引用类型的模板形参来表明想要返回右值。而在此处，如果<code>param</code>是左值，则<code>decltype(param)</code>会产生左值引用类型，这符合惯例；但如果<code>param</code>是右值，则<code>decltype(param)</code>会产生右值引用类型，不符合惯例的非引用，在这种情况下，<code>std::forward</code>将被具现化为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Widget<span class="token operator">&amp;&amp;</span> <span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span>remove_reference_t<span class="token operator">&lt;</span>Widget<span class="token operator">&amp;</span><span class="token operator">></span><span class="token operator">&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">&amp;&amp;</span> <span class="token operator">&amp;&amp;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于引用折叠的存在，<code>Widget&amp;&amp; &amp;&amp;</code>将被折叠为<code>Widget&amp;&amp;</code>，所以实际上生成的代码和使用非引用类型作为模板形参生成的版本并没有什么区别。综上所述，在此处使用<code>decltype(param)</code>并不会产生任何问题，这是个非常不错的结果。</p>
<p>C++14 的 lambda 也支持可变参数，只需稍加改动，就可以得到能接受多个参数的完美转发 lambda 版本：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">normalize</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="优先选用-lambda，而非-std-bind"><a href="#优先选用-lambda，而非-std-bind" class="headerlink" title="优先选用 lambda，而非 std::bind"></a>优先选用 lambda，而非 std::bind</h2><p>​        之所以优先选用 lambda 而非 std::bind，最主要的原因是 lambda 具有更高的可读性。举个例子，假设我们有个函数用来设置警报声：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 表示时刻的类型</span>
<span class="token keyword">using</span> Time <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span>time_point<span class="token punctuation">;</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Sound</span> <span class="token punctuation">&#123;</span> Beep<span class="token punctuation">,</span> Siren<span class="token punctuation">,</span> Whistle <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 表示时长的类型</span>
<span class="token keyword">using</span> Duration <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>steady_clock<span class="token double-colon punctuation">::</span>duration<span class="token punctuation">;</span>

<span class="token comment">// 在时刻 t，发出声音 s，持续时长 d</span>
<span class="token keyword">void</span> <span class="token function">setAlarm</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以编写一个 lambda，设置在一小时后发出警报并持续 30 秒，同时提供接口，以指定发出的声音：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundL <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>Sound s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token punctuation">;</span>
    <span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>literals<span class="token punctuation">;</span>              <span class="token comment">// 引入 C++14 中的字面量后缀</span>

    <span class="token function">setAlarm</span><span class="token punctuation">(</span>steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>h<span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token number">30</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C++11 需要用 hours 和 seconds 代替后缀</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来我们将尝试使用<code>std::bind</code>来编写相应的代码。下面的这段代码并不正确，但足以让我们发现<code>std::bind</code>的难用之处：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>literals<span class="token punctuation">;</span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token punctuation">;</span>  <span class="token comment">// 引入占位符</span>

<span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>
                           steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>h<span class="token punctuation">,</span>
                           _1<span class="token punctuation">,</span>
                           <span class="token number">30</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>占位符<code>_1</code>表示它在<code>std::bind</code>形参列表中的映射位置，在此处表示调用<code>setSoundB</code>时传入的第一个实参，会作为第二个实参传递给<code>setAlarm</code>。这显然已经不如 lambda 直观。</p>
<p>更重要的是上述代码所隐含的问题：调用时间的错误。在<code>std::bind</code>的调用中，<code>steady_clock::now() + 1h</code>作为实参被传递给了<code>std::bind</code>，而非<code>setAlarm</code>，这意味着该表达式会在调用<code>std::bind</code>的时刻计算出具体值，而非调用<code>setAlarm</code>的时刻，这与我们的意图显然不符。想要解决这个问题，就要嵌套第二层<code>std::bind</code>的调用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">,</span>
                           std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">plus</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// C++11 无法省略 std::plus&lt;steady_clock::time_point>()</span>
                                     steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                     <span class="token number">1</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           _1<span class="token punctuation">,</span>
                           <span class="token number">30</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个<code>std::bind</code>不如 lambda 的例子是重载。假如有个重载版本会接受第四个形参，用于指定警报的音量：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Volume</span> <span class="token punctuation">&#123;</span> Normal<span class="token punctuation">,</span> Loud<span class="token punctuation">,</span> LoudPlusPlus <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">setAlarm</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">,</span> Volume v<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>原来的 lambda 仍会正常运作，而<code>std::bind</code>会立刻发生错误，因为它只有函数名，并不知道要调用哪个重载版本的函数。为使得<code>std::bind</code>的调用能通过编译，必须将<code>setAlarm</code>强制转换到适当的函数指针类型：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> SetAlarm3ParamType <span class="token operator">=</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Time t<span class="token punctuation">,</span> Sound s<span class="token punctuation">,</span> Duration d<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> setSoundB <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>SetAlarm3ParamType<span class="token operator">></span></span></span><span class="token punctuation">(</span>setAlarm<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">plus</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> steady_clock<span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span>
                           _1<span class="token punctuation">,</span>
                           <span class="token number">30</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是一个更极端的例子，演示了<code>std::bind</code>到底有多晦涩：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// lambda 版本（C++14）</span>
<span class="token keyword">auto</span> betweenL <span class="token operator">=</span> <span class="token punctuation">[</span>lowVal<span class="token punctuation">,</span> highVal<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> lowVal <span class="token operator">&lt;=</span> val <span class="token operator">&amp;&amp;</span> val <span class="token operator">&lt;=</span> highVal<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// std::bind 版本（C++14）</span>
<span class="token keyword">auto</span> betweenB <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">logical_and</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                          std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">less_equal</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lowVal<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">,</span>
                          std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">less_equal</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">,</span> highVal<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>std::bind</code>总是拷贝其实参，调用时需要借助<code>std::ref</code>来达到按引用存储实参的目的，这一点同样也不如 lambda 来得明确：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> compressRateL <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>w<span class="token punctuation">]</span><span class="token punctuation">(</span>CompLevel lev<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token function">compress</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> lev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> compressRateB <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>compress<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>除了可读性以外，编译器通常能更好地以内联优化 lambda 所调用的函数，而对于使用函数指针的<code>std::bind</code>则很难做到，这会导致使用 lambda 有可能会生成比使用<code>std::bind</code>运行得更快的代码。</p>
<p>在 C++11 中，<code>std::bind</code>仅在两个受限的场合还有使用的理由：</p>
<ol>
<li>移动捕获；</li>
<li>多态函数对象（这在 C++14 中可以被泛型 lambda 轻易实现）：</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PolyWidget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

PolyWidget pw<span class="token punctuation">;</span>
<span class="token keyword">auto</span> boundPW <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>pw<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 可以用不同类型的实参调用 PolyWidget::operator()</span>
<span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token number">1930</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">boundPW</span><span class="token punctuation">(</span><span class="token string">"Rosebud"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 原书作者玩的《公民凯恩》梗（应该是吧）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="优先选用基于任务而非基于线程的程序设计"><a href="#优先选用基于任务而非基于线程的程序设计" class="headerlink" title="优先选用基于任务而非基于线程的程序设计"></a>优先选用基于任务而非基于线程的程序设计</h2><p>如果你想以异步方式执行函数<code>doAsyncWork</code>，你可以选择<strong>基于线程（thread-based）</strong> 的方式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">doAsyncWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>也可以将<code>doAsyncWork</code>传递给<code>std::async</code>，这是<strong>基于任务（task-based）</strong> 的方式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>doAsyncWork<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 需要 #include &lt;future></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>“线程” 在带有并发的 C++ 软件中有三重含义：</p>
<ul>
<li><strong>硬件线程（hardware threads）</strong> 是实际执行计算的线程。现代计算机架构会为每个 CPU 内核提供一个或多个硬件线程。</li>
<li><strong>软件线程（software threads，也称系统线程）</strong> 是操作系统（或嵌入式系统）用于实现跨进程的管理，以及进行硬件线程调度的线程。通常，能够创建的软件线程比硬件线程要多，因为当一个软件线程被阻塞时，运行其它未阻塞线程能够提高吞吐率。</li>
<li><strong><code>std::thread</code></strong> 是 C++ 进程中的对象，用作底层软件线程的句柄。有些<code>std::thread</code>对象表现为 “null” 句柄，表示其无软件线程，可能的原因有：处于默认构造状态（没有要执行的函数），被移动了（被移动的目标对象成为了该软件线程的句柄），被联结（join）了（函数已执行结束），被分离（detach）了（与其软件线程的连接被切断）。</li>
</ul>
<p>软件线程和硬件线程都是有限的。如果你试图创建多于系统能提供的数量的线程，就会抛出<code>std::system_error</code>异常，即使待执行的函数带有<code>noexcept</code>限定符也一样。如果非阻塞的软件线程数量超过了硬件线程数量，就会产生<strong>资源超额（oversubscription）</strong> 问题，此时线程调度器会将软件线程的 CPU 时间切片，分配到硬件线程之上。当一个软件线程的时间片执行结束，就会让给另一个软件线程，并产生上下文切换。在这种情况下，新的软件线程几乎不能命中 CPU 缓存，同时还会污染为旧线程所准备的数据（旧线程很可能还会再被调度到同一内核上运行），这会造成高昂的线程管理开销。</p>
<blockquote>
<p>避免资源超额很困难，因为软件线程和硬件线程的最佳比例取决于软件线程的执行频率，那是动态改变的，例如一个程序从 IO 密集型变成计算密集型，会使执行频率发生改变。而且该比例还依赖于上下文切换的开销以及软件线程对于 CPU 缓存的使用效率。计算机本身的架构也会对其具体细节产生很大的影响。</p>
</blockquote>
<p>比起基于线程，基于任务的设计能够减轻手动管理线程的艰难，而且它提供了一种很自然的方式（藉由<code>get</code>函数），让你检查异步执行函数的结果（即返回值或异常）。</p>
<p>虽然说了这么多，但仍有以下几种情况，直接使用线程会更合适：</p>
<ul>
<li><strong>你需要访问非常底层的线程 API。</strong> C++ 并发 API 通常会采用特定平台的低级 API 来实现，例如 pthread 和 Windows 线程库，它们提高的 API 比 C++ 更丰富。为了访问底层的线程 API，<code>std::thread</code>通常会提供<code>native_handle</code>成员函数，而<code>std::async</code>的返回值<code>std::future</code>则没有该功能。</li>
<li><strong>你需要且有能力为你的应用优化线程的使用。</strong> 例如在完成性能分析的情况下为专一硬件平台开发应用。</li>
<li><strong>你需要实现实现超越 C++ 并发 API 的线程技术。</strong> 例如为 C++ 未提供线程池的平台实现线程池。</li>
</ul>
<h2 id="如果异步是必要的，则指定-std-launch-async"><a href="#如果异步是必要的，则指定-std-launch-async" class="headerlink" title="如果异步是必要的，则指定 std::launch::async"></a>如果异步是必要的，则指定 std::launch::async</h2><p>在调用<code>std::async</code>时，有以下两种启动策略可以选择：</p>
<ul>
<li><code>std::launch::async</code>启动策略意味着函数必须以异步方式在另一条线程上执行。</li>
<li><code>std::launch::deferred</code>启动策略意味着函数会被推迟到<code>std::async</code>所返回的<code>std::future</code>的<code>get</code>或<code>wait</code>函数得到调用时才执行（这是个简化说法，关键点其实是<code>std::future</code>引用的共享状态，参考<strong>条款 38</strong>）。在那之后，调用<code>get</code>或<code>wait</code>的线程将会被阻塞，直至函数执行结束为止。如果<code>get</code>或<code>wait</code>都没得到调用，则函数将不会被执行。</li>
</ul>
<p><code>std::async</code>的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行，即下面两个调用是等价的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> fut2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async <span class="token operator">|</span> std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>deferred<span class="token punctuation">,</span>
                       f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种弹性使得<code>std::async</code>和标准库的线程管理组件能够承担起线程的创建和销毁，避免资源超额，以及负载均衡的责任。但也会带来一些意料之外的问题：</p>
<ul>
<li>无法预知<code>f</code>是否会与调用<code>std::async</code>的线程并发执行，它也可能会被推迟执行。</li>
<li>无法预知<code>f</code>是否会在与调用<code>get</code>和<code>wait</code>函数的线程不同的线程上执行。</li>
<li>无法预知<code>f</code>在读或写此<strong>线程本地存储（thread-local，TLS）</strong> 时，会在哪个线程的本地存储上完成操作，这会影响到<code>thread_local</code>变量的使用。</li>
<li>就连<code>f</code>是否会被执行这种基本的事情都无法预知。</li>
</ul>
<p>延迟启动策略还会影响以超时为条件的基于 wait 的循环：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token double-colon punctuation">::</span>literals<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">1</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token number">100</span>ms<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 循环至 f 完成执行</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 若 f 被推迟执行，则 fut.wait_for 返回 std::future_status::deferred</span>
    <span class="token comment">// 循环永远不会被终止！</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决这个问题的方法很简单，只需要确认任务是否被推迟，可以通过调用一个基于超时的函数（例如<code>wait_for</code>）并检查其返回值来实现：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token number">0</span>s<span class="token punctuation">)</span> <span class="token operator">==</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果任务被推迟了</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 调用 fut 的 wait 或 get，以同步方式执行 f</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                                                  <span class="token comment">// 如果任务未被推迟</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>fut<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span><span class="token number">100</span>ms<span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>future_status<span class="token double-colon punctuation">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 不断去做并发任务，直至 f 完成执行</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// fut 已经就绪</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>综上所述，如果需要执行的任务满足以下条件，就可以使用<code>std::async</code>的默认启动策略：</p>
<ol>
<li>任务不需要与调用<code>get</code>或<code>wait</code>的线程并发执行。</li>
<li>读或写哪个线程的<code>thread_local</code>变量并无影响。</li>
<li>保证在<code>std::async</code>返回的<code>std::future</code>对象上调用<code>get</code>或<code>wait</code>，或者可以接受任务可能永不执行。</li>
<li>使用<code>wait_for</code>或<code>wait_until</code>的代码会考虑到任务被推迟的可能性。</li>
</ol>
<p>如果其中任何一个条件不满足，就需要确保任务以异步方式执行：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> fut <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>也可以编写一个辅助函数来自动执行<code>std::async</code>的异步启动策略：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">></span>
<span class="token keyword">inline</span> std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>result_of<span class="token operator">&lt;</span><span class="token function">F</span><span class="token punctuation">(</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>type<span class="token operator">></span> <span class="token comment">// C++14 可以直接用 auto 推导返回值类型</span>
<span class="token function">reallyAsync</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Ts<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>launch<span class="token double-colon punctuation">::</span>async<span class="token punctuation">,</span>
                      std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">></span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>
                      std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">></span></span></span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>用于获取可调用对象返回值类型的<code>std::result_of</code>在 C++17 后被弃用，其替代品为<code>std::invoke_result</code>。</p>
</blockquote>
<h2 id="使-std-thread-对象在所有路径皆不可联结"><a href="#使-std-thread-对象在所有路径皆不可联结" class="headerlink" title="使 std::thread 对象在所有路径皆不可联结"></a>使 std::thread 对象在所有路径皆不可联结</h2><p>当<code>std::thread</code>处于可联结的状态时，它对应于正在运行或可能将要运行的底层执行线程，这包括正在等待调度的或者被阻塞的线程，以及运行结束的线程。</p>
<p>以下几种<code>std::thread</code>对象处于不可联结的状态：</p>
<ul>
<li>默认构造的<code>std::thread</code>。</li>
<li>已移动的<code>std::thread</code>。</li>
<li>已联结（join）的<code>std::thread</code>。</li>
<li>已分离（detach）的<code>std::thread</code>。</li>
</ul>
<p>当<code>std::thread</code>执行析构时，若其处于可联结状态，就会导致程序终止运行（通常会调用<code>std::abort</code>）。考虑以下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">auto</span> tenMillion <span class="token operator">=</span> <span class="token number">10'000'000</span><span class="token punctuation">;</span>             <span class="token comment">// C++14 的单引号数字分隔符</span>

<span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> filter<span class="token punctuation">,</span> <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> goodVals<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 遍历 goodVals</span>
                      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                      <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
                  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 使用 t 的原生句柄来设定线程的优先级</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   <span class="token comment">// 让 t 结束运行</span>
        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                                <span class="token comment">// 计算已实施</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                                   <span class="token comment">// 计算未实施</span>
<span class="token punctuation">&#125;</span>                                                   <span class="token comment">// 此处析构 std::thread 会导致程序终止</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>标准委员会并没有选择让<code>std::thread</code>在销毁时，隐式执行<code>join</code>或<code>detach</code>，因为这带来的问题会比直接让程序终止运行还要严重：</p>
<ul>
<li><strong>隐式<code>join</code></strong> 会使<code>std::thread</code>的析构函数等待底层异步线程执行完毕。这听上去很合理，但却可能导致难以追踪的性能异常。例如，即使<code>conditionAreSatisfied</code>已经返回<code>false</code>了，<code>doWork</code>仍然会继续执行遍历操作，这是违反直觉的。</li>
<li><strong>隐式<code>detach</code></strong> 会使<code>std::thread</code>的析构函数分离<code>std::thread</code>对象和底层执行线程之间的连接，而该底层执行线程会继续运行。这会导致更要命的调试问题。假如<code>conditionAreSatisfied</code>返回了<code>false</code>，则<code>doWork</code>也会直接返回，同时销毁局部变量并弹出栈帧。但线程仍然在<code>doWork</code>的调用点继续运行，并导致栈帧上的内存被意外修改，</li>
</ul>
<p>我们可以编写一个 RAII 类，并让调用者自行选择在销毁时为<code>std::thread</code>调用<code>join</code>还是<code>detach</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ThreadRAII</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">DtorAction</span> <span class="token punctuation">&#123;</span> join<span class="token punctuation">,</span> detach <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// 关于枚举类，参考条款 20</span>

    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">,</span> DtorAction a<span class="token punctuation">)</span>   <span class="token comment">// 对 t 执行操作 a</span>
        <span class="token operator">:</span> <span class="token function">action</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

    <span class="token operator">~</span><span class="token function">ThreadRAII</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 先校验 t 是否处于可联结状态</span>
        <span class="token comment">// 对不可联结的 std::thread 调用 join 或 detach 是未定义行为</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> DtorAction<span class="token double-colon punctuation">::</span>join<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">ThreadRAII</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>         <span class="token comment">// 支持移动操作</span>
    ThreadRAII<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>ThreadRAII<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>            <span class="token comment">// 返回底层的 std::thread 对象</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    DtorAction action<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">;</span>                              <span class="token comment">// 使 t 最后被初始化，确保它可以安全访问其它成员</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>不需要担心在<code>t.joinable()</code>的执行和<code>join</code>或<code>detach</code>的调用之间，有另一个线程会让<code>t</code>变得不可联结。因为<code>std::thread</code>对象只能通过调用成员函数来从可联结状态转换为不可联结状态，而当<code>ThreadRAII</code>对象的析构函数被调用时，不应该有其它线程调用该对象的成员函数。一般地，若要在一个对象上同时调用两个成员函数，只有当所有这些函数都带有<code>const</code>限定符时才安全（参考<strong>条款 16</strong>）。</p>
</blockquote>
<p>在<code>doWork</code>函数的代码中，可以这样使用<code>ThreadRAII</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">doWork</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> filter<span class="token punctuation">,</span> <span class="token keyword">int</span> maxVal <span class="token operator">=</span> tenMillion<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> goodVals<span class="token punctuation">;</span>

    ThreadRAII <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>filter<span class="token punctuation">,</span> maxVal<span class="token punctuation">,</span> <span class="token operator">&amp;</span>goodVals<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
                                 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> maxVal<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                                 <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">filter</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> goodVals<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
                             <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                 ThreadRAII<span class="token double-colon punctuation">::</span>DtorAction<span class="token double-colon punctuation">::</span>join<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> nh <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">native_handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">conditionAreSatisfied</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        t<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">performComputation</span><span class="token punctuation">(</span>goodVals<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="注意不同线程句柄的析构行为"><a href="#注意不同线程句柄的析构行为" class="headerlink" title="注意不同线程句柄的析构行为"></a>注意不同线程句柄的析构行为</h2><p>future 位于通信信道的一端，被调用者通过该信道将结果发送给调用者。被调用者（通常以异步方式运行）将其计算所得的结果写入信道（通常经过<code>std::promise</code>对象），而调用者则使用 future 来读取该结果。</p>
<p>但被调用者的结果要存储在哪里呢？既不能存储在被调用者的<code>std::promise</code>对象中，因为它是个局部对象，在被调用者执行结束后会被销毁；也不能存储在调用者的 future 中，因为<code>std::future</code>可能会被用来创建<code>std::shared_future</code>，而后者会导致原始<code>std::future</code>析构之后被多次拷贝，但被调用者的结果并不能保证一定可以被拷贝，很难做到使它与最后一个指向它的 future 生命周期一样长。</p>
<p>因此该结果会被存储在位于两者外部的某个位置，这个位置称为<strong>共享状态（shared state）</strong>，通常用堆上的对象来表示，但是其类型、接口和实现皆未在标准中指定。我们可以把调用者，被调用者以及共享状态之间的关系用下图来表示：</p>
<p><img src="v2-006b36a9b3ae2533a73d8c1646d49511_1440w.webp" alt="img"></p>
<p>共享状态的存在非常重要，因为 future 对象的析构行为取决于与其关联的共享状态。具体来说就是：</p>
<ul>
<li>常规的 future 对象在析构时仅会析构该 future 的成员变量。这相当于对底层执行线程执行了隐式<code>detach</code>。</li>
<li>引用了共享状态（使用<code>std::async</code>启动未延迟任务时创建的）的最后一个 future 对象的析构函数将会被阻塞住，直至该任务结束。这相当于对正在运行<code>std::async</code>所创建任务的线程执行了隐式<code>join</code>。</li>
</ul>
<p>也就是说，只有在满足下列条件时，future 的非常规析构行为才会被触发：</p>
<ol>
<li>future 所引用的共享状态是在调用<code>std::async</code>时创建的；</li>
<li>该任务执行异步启动策略，即<code>std::launch::async</code>（参考<strong>条款 36</strong>）；</li>
<li>该 future 是最后一个引用了该共享状态的 future。</li>
</ol>
<p>future 的 API 没有提供任何办法判断它引用的共享状态是否诞生于<code>std::async</code>的调用，因此任意给定一个 future 对象，我们没有办法判断它是否会在析构函数中阻塞。这可能会导致一些意外的情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 该容器的析构函数可能会发生阻塞</span>
<span class="token comment">// 因为它持有 future 可能会有一个或多个</span>
<span class="token comment">// 满足触发非常规析构行为的条件</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">>></span> futs<span class="token punctuation">;</span>    <span class="token comment">// 关于 std::future&lt;void>，参考条款 39</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>                          <span class="token comment">// Widget 对象的析构函数可能会发生阻塞</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> fut<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用<code>std::packaged_task</code>也能创建出共享对象，但是其衍生的 future 都会执行常规的析构行为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calcValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>       <span class="token comment">// 给 calcValue 加上包装</span>
    <span class="token function">pt</span><span class="token punctuation">(</span>calcValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 使之能以异步方式执行</span>

    <span class="token keyword">auto</span> fut <span class="token operator">=</span> pt<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 取得 pt 的 future</span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// std::packaged_task 是只移类型</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment">// 析构 std::thread（参考条款 37）</span>
<span class="token punctuation">&#125;</span>                                   <span class="token comment">// 以常规方式析构 future 对象 fut</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="考虑对一次性事件通信使用-void-的-futures"><a href="#考虑对一次性事件通信使用-void-的-futures" class="headerlink" title="考虑对一次性事件通信使用 void 的 futures"></a>考虑对一次性事件通信使用 void 的 futures</h2><p>有的时候，让一个任务能够在发生了特定事件后，通知另一个异步运行的任务，会是很有用的。为了实现这种简单的事件通信，使用条件变量会是一个显而易见的做法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>condition_variable cv<span class="token punctuation">;</span>             <span class="token comment">// 事件的条件变量</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>                           <span class="token comment">// 配合 cv 使用的互斥量</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">// 检测事件</span>
cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 通知反应任务，对多个任务使用 notify_all</span>

<span class="token comment">// 反应任务的代码</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">// 准备作出反应</span>
<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为互斥量加锁</span>

    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// 等待通知到来</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment">// 针对事件作出反应</span>
<span class="token punctuation">&#125;</span>                                       <span class="token comment">// 通过 lk 的析构函数为 m 解锁</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">// 继续等待反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种途径会导致以下几个问题：</p>
<ul>
<li><strong>代码异味（code smell）：</strong> 虽然代码能够运行，但总感觉哪里不太对劲。此处对互斥量的使用似乎有些多余，互斥量是用于控制共享数据访问的，但检测和反应任务之间大可以根本不需要这种介质。</li>
<li>如果检测任务在反应任务调用<code>wait</code>之前就通知了条件变量，则反应任务将会失去响应。</li>
<li>反应任务的<code>wait</code>语句无法应对<strong>虚假唤醒（spurious wakeups）</strong>，即使条件变量没有得到通知，针对该条件变量等待的代码也有可能被唤醒。如果反应线程可以确认它所等待的事件是否已经发生，那么我们可以通过将 lambda 传递给<code>wait</code>来处理这种情况：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> 事件是否真的已经发生<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>基于 flag 的设计可以避免上述问题，但这一设计基于轮询而非阻塞，会对 CPU 核心产生额外的性能消耗：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 共享的 bool flag</span>
                                <span class="token comment">// 关于 std::atomic，参考条款 40</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment">// 检测事件</span>
flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token comment">// 通知反应任务</span>

<span class="token comment">// 反应任务的代码</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment">// 准备作出反应</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 等待事件</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                             <span class="token comment">// 针对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>条件变量可以和 flag 一起使用，但这样的通信机制设计看起来不太自然：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>condition_variable cv<span class="token punctuation">;</span>                 <span class="token comment">// 同前</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>

<span class="token keyword">bool</span> <span class="token function">flag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">// 非 std::atomic 对象</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment">// 检测事件</span>
<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">></span> <span class="token function">g</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 为 m 加锁</span>
    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                            <span class="token comment">// 通知反应任务（第一部分）</span>
<span class="token punctuation">&#125;</span>
cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 通知反应任务（第二部分）</span>

<span class="token comment">// 反应任务的代码</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment">// 准备作出反应</span>
<span class="token punctuation">&#123;</span>
    std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">></span> <span class="token function">lk</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 同前</span>

    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>flag<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> flag<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 使用 lambda 应对虚假唤醒</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                     <span class="token comment">// 针对事件作出反应</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                         <span class="token comment">// 继续等待反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外一种方法是摆脱条件变量，互斥量和 flag，让反应任务去等待检测任务设置的 future。这种设计简单易行，检测任务有一个<code>std::promise</code>对象，反应任务有对应的 future。当检测任务发现它查找的事件已经发生时，它会设置<code>std::promise</code>对象；与此同时，反应任务调用<code>wait</code>以等待它的 future。由于在此处我们并不会真正向信道发送任何数据，所以对于<code>std::promise</code>、<code>std::future</code>和<code>std::shared_future</code>的模板类型形参，都只需使用<code>void</code>即可：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment">// 检测事件</span>
p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 通知反应任务</span>

<span class="token comment">// 反应任务的代码</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment">// 准备作出反应</span>
p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待 p 对应的 future</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token comment">// 针对事件作出反应</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种手法有两个最大的局限性：</p>
<ul>
<li><code>std::promise</code>和 future 之间依赖共享状态，而共享状态会带来在堆上分配和回收空间的成本。</li>
<li><code>std::promise</code>对象只能设置一次，这意味着该手法只能应用于一次性通信的情况。</li>
</ul>
<p>假如你想创建多个能暂停一次的线程，使用<code>void</code> future 手法就是合理的选择。代码演示如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> p<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">detect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">auto</span> sf <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// sf 的类型是 std::shared_future&lt;void></span>

    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">></span> vt<span class="token punctuation">;</span>                        <span class="token comment">// 反应任务的容器</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadsToRun<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vt<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token punctuation">[</span>sf<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span> sf<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">react</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sf 局部副本之上的 wait</span>
    <span class="token punctuation">&#125;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                 <span class="token comment">// 若在此处抛出异常，则 detect 会失去响应！</span>

    p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment">// 让所有线程取消暂停</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                                 <span class="token comment">// 完成其它工作</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> vt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                <span class="token comment">// 把所有线程设为不可联结的状态</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="对并发使用-std-atomic，对特殊内存使用-volatile"><a href="#对并发使用-std-atomic，对特殊内存使用-volatile" class="headerlink" title="对并发使用 std::atomic，对特殊内存使用 volatile"></a>对并发使用 std::atomic，对特殊内存使用 volatile</h2><p><code>std::atomic</code>可以保证它提供的操作被其它线程视为具有原子性，它产生的效果和受到互斥锁保护的操作类似，但是通常<code>std::atomic</code>的原子操作是通过特定的机器指令实现的，这比锁的实现更高效。考虑以下应用了<code>std::atomic</code>的代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ai</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 ai 初始化为 0</span>
ai <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                <span class="token comment">// 原子地将 ai 设为 10</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ai<span class="token punctuation">;</span>        <span class="token comment">// 原子地读取 ai 地值</span>
<span class="token operator">++</span>ai<span class="token punctuation">;</span>                   <span class="token comment">// 原子地将 ai 自增为 11</span>
<span class="token operator">--</span>ai<span class="token punctuation">;</span>                   <span class="token comment">// 原子地将 ai 自减为 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是，在<code>std::cout &lt;&lt; ai</code>语句中，<code>std::atomic</code>仅能保证对于<code>ai</code>的读取操作具有原子性，而不能保证整条语句都具有原子性，在读取<code>ai</code>的值和调用<code>operator&lt;&lt;</code>之间，可能会有别的线程修改了<code>ai</code>的值，但这对使用按值传参的<code>operator&lt;&lt;</code>并没有什么影响。</p>
<p><code>ai</code>的自增和自减操作是<strong>读取-修改-写入（read-modify-write，RWM）</strong> 操作，<code>std::atomic</code>能确保它们整体以原子方式执行。这是<code>std::atomic</code>最重要的特性之一：<code>std::atomic</code>对象之上的所有成员函数都能被其它线程视为原子性的。</p>
<p><code>std::atomic</code>在 RWM 上具有的优势与<code>volatile</code>相比十分明显：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">ac</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// atomic counter</span>
<span class="token keyword">volatile</span> <span class="token keyword">int</span> <span class="token function">vc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// volatile counter</span>

<span class="token comment">/* 在两个同时运行的线程中各自执行自增操作 */</span>

<span class="token comment">// 线程 1</span>
<span class="token operator">++</span>ac<span class="token punctuation">;</span>
<span class="token operator">++</span>vc<span class="token punctuation">;</span>

<span class="token comment">// 线程 2</span>
<span class="token operator">++</span>ac<span class="token punctuation">;</span>
<span class="token operator">++</span>vc<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在两个执行结束后，<code>ac</code>的值一定为 2，而<code>vc</code>却不一定，数据竞争导致它的最终结果实际上是无法预测的，下面是一种可能的情况：</p>
<ol>
<li>线程 1 读取<code>vc</code>的值为 0；</li>
<li>线程 2 读取<code>vc</code>的值仍为 0；</li>
<li>线程 1 将读取的值 0 自增为 1，写入<code>vc</code>；</li>
<li>线程 2 也将读取的值 0 自增为 1，写入<code>vc</code>；</li>
<li><code>vc</code>最终的值为 1。</li>
</ol>
<p>除了 RWM 以外，<code>std::atomic</code>还在确保<strong>顺序一致性（sequential consistency）</strong> 上具有优势，这种一致性是它默认采用的（尽管 C++ 还支持其它的一致性模型，但它们的安全性无法得到保证），它规定：在源代码中，<strong>任何位于<code>std::atomic</code>变量的写入操作之前的代码不得发生于写入操作之后</strong>。使用<code>std::atomic</code>可以保证以下代码中的赋值语句不会进行重新排序：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">valAvailable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> imptValue <span class="token operator">=</span> <span class="token function">computeImportantValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 计算出值</span>
valAvailable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token comment">// 通知其它任务，值已可用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果不使用<code>std::atomic</code>，语句的顺序可能会被编译器或底层硬件重新排列，以使得代码运行得更快：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 重新排序后的结果</span>
valAvailable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> imptValue <span class="token operator">=</span> <span class="token function">computeImportantValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>std::atomic</code>是只移类型，因此以下代码无法通过编译：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>正确的方式是调用<code>std::atomic</code>的成员函数<code>load</code>和<code>store</code>来以原子方式读取和写入：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">y</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>尽管在很多时候<code>load</code>和<code>store</code>并不是必要的，但是有些开发者还是很喜欢使用它们，因为这样做可以在代码中明确强调所使用的变量并非常规。这在很大程度上是一个代码风格的问题。</p>
<p><code>volatile</code>是用来处理特殊内存的工具，它会被用在读写操作不应该被优化的内存上。一般来讲，编译器会为常规内存的冗余读取和写入自动执行优化，例如以下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 读取 x</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span>      <span class="token comment">// 再次读取 x</span>

x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// 写入 x</span>
x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>     <span class="token comment">// 再次写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在经过优化后就能变成十分精简的版本：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// 读取 x</span>

x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>     <span class="token comment">// 写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但对于特殊内存，我们可能不想要编译器去执行这种优化。例如用于内存映射 I/O 的内存，这种内存的位置实际上会被用于与外部设备通信，而非用于读取或写入常规内存。这时，<code>volatile</code>就能派上用场：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">volatile</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token comment">// 以 volatile 声明 x</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token comment">// 初始化 x</span>

<span class="token keyword">auto</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>     <span class="token comment">// 读取 x</span>
y <span class="token operator">=</span> x<span class="token punctuation">;</span>          <span class="token comment">// 再次读取 x（不会被优化掉）</span>

x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>         <span class="token comment">// 写入 x（不会被优化掉）</span>
x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>         <span class="token comment">// 再次写入 x</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>std::atomic</code>和<code>volatile</code>用于不同的目的，它们甚至可以一起使用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">volatile</span> std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vai<span class="token punctuation">;</span>  <span class="token comment">// 针对 vai 的操作具有原子性</span>
                                <span class="token comment">// 并且不会被优化掉</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"><a href="#对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递" class="headerlink" title="对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递"></a>对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递</h2><p>为了实现对传入函数的左值实参执行拷贝，对右值实参执行移动，我们一共有以下三种方法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>                                  <span class="token comment">// 方法一：</span>
<span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment">// 对左值和右值分别重载</span>
    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> names<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>                                  <span class="token comment">// 方法二：</span>
<span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment">// 使用万能引用</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>                                  <span class="token comment">// 方法三：</span>
<span class="token keyword">public</span><span class="token operator">:</span>                                         <span class="token comment">// 按值传递参数</span>
    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 C++98 中，按值传递的形参总会通过拷贝构造函数创建，但在 C++11 后，形参仅在传入左值时才会被拷贝构造，而如果传入的是个右值，它会被移动构造。</p>
<p>对于可拷贝的，移动开销低的，并且总是会被拷贝的形参而言，按值传递和按引用传递的效率很接近，而且按值传递更容易实现，还可能会生成更少的目标代码。</p>
<p>对于不可拷贝的形参，由于它的拷贝构造函数已被禁用，我们也不需要为其左值类型的实参提供支持，只需要编写一个接受右值引用的版本就行了。考虑一个类，它含有一个<code>std::unique_ptr</code>类型的数据成员和对应的 setter，而<code>std::unique_ptr</code>是个只移类型，所以我们只需要编写单个函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">setPtr</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span><span class="token operator">&amp;&amp;</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        p <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Widget w<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
w<span class="token punctuation">.</span><span class="token function">setPtr</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"Modern C++"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用按值传参的前提是形参移动的成本足够低廉，因为按值传参会比按引用传参多一次额外的移动操作，如果这个前提不成立，那么执行不必要的移动就与执行不必要的拷贝没有什么区别。另外，你应当只对一定会被拷贝的形参考虑使用按值传参，以下代码就是一个反例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">addName</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string newName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newName<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> minLen<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span>newName<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> maxLen<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            names<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> names<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使没有向<code>names</code>添加任何内容，该函数也会造成构造和析构<code>newName</code>的开销，而如果使用按引用传参，就可以避免这笔开销。</p>
<p>通过构造拷贝形参的开销可能会比通过赋值拷贝形参要大得多。考虑以下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Password</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">Password</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string pwd<span class="token punctuation">)</span>  <span class="token comment">// 按值传参</span>
        <span class="token operator">:</span> <span class="token function">text</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>       <span class="token comment">// 对 text 进行构造</span>

    <span class="token keyword">void</span> <span class="token function">changeTo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string newPwd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 按值传参</span>
        text <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>newPwd<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 对 text 进行赋值</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>string text<span class="token punctuation">;</span>                   <span class="token comment">// 表示密码</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

std<span class="token double-colon punctuation">::</span>string <span class="token function">initPwd</span><span class="token punctuation">(</span><span class="token string">"Supercalifragilisticexpialidocious"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 旧密码</span>
Password <span class="token function">p</span><span class="token punctuation">(</span>initPwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

std<span class="token double-colon punctuation">::</span>string newPassword <span class="token operator">=</span> <span class="token string">"Beware the Jabberwock"</span><span class="token punctuation">;</span>          <span class="token comment">// 新密码</span>
p<span class="token punctuation">.</span><span class="token function">changeTo</span><span class="token punctuation">(</span>newPassword<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在此处，旧密码比新密码更长，因此不需要进行任何内存分配和回收。如果采用重载的方式，可能就不会发生任何动态内存管理操作：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Password</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">void</span> <span class="token function">changeTo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> newPwd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 对左值的重载</span>
        text <span class="token operator">=</span> newPwd<span class="token punctuation">;</span>                      <span class="token comment">// 若 text.capacity() >= newPwd.size()</span>
                                            <span class="token comment">// 则可以复用 text 的内存</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在此情形下，使用按值传参就会造成额外的内存分配和回收的开销，这可能会比移动<code>std::string</code>的开销高出几个数量级。</p>
<p>综上所述，通过赋值拷贝一个形参进行按值传参所造成的额外开销，取决于传参的类型，左值和右值的比例，这个类型是否需要动态分配内存，以及，如果需要分配内存的话，赋值操作符的具体实现，还有赋值目标所占的内存是否至少和赋值源所占的内存一样大。对于<code>std::string</code>来说，开销还取决于实现是否使用了 SSO（参考<strong>条款 29</strong>），如果是，那么要赋的值是否匹配 SSO 缓冲区。</p>
<p>最后要注意的一点是，按值传参肯定会导致<strong>对象切片（object slicing）</strong> 的问题，所以基类类型不适合用于按值传递：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                           <span class="token comment">//基类</span>

<span class="token keyword">class</span> <span class="token class-name">SpecialWidget</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Widget</span></span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//派生类</span>

<span class="token keyword">void</span> <span class="token function">processWidget</span><span class="token punctuation">(</span>Widget w<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 针对任意类型的 Widget 的函数</span>
                                                <span class="token comment">// 包括派生类型</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 

SpecialWidget sw<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token function">processWidget</span><span class="token punctuation">(</span>sw<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">// 发生对象切片，processWidget 只能看到 Widget</span>
                                                <span class="token comment">// 而非 SpecialWidget</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="考虑置入而非插入"><a href="#考虑置入而非插入" class="headerlink" title="考虑置入而非插入"></a>考虑置入而非插入</h2><p>假如你想向 STL 容器中添加新元素，<strong>插入函数（insertion function）</strong> 通常是合乎逻辑的选择，但对于性能狂人而言，其背后所隐含的临时对象带来的开销是难以忍受的。考虑以下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span>    <span class="token comment">// 持有 std::string 对象的容器</span>
vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 添加字符串字面量</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此处添加的字符串字面量和<code>std::string</code>类型并不匹配，因此需要先创建一个<code>std::string</code>类型的临时对象，然后再将其绑定到<code>push_back</code>函数的右值引用形参。换句话说，你可以把这句调用看作下面这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在这之后，<code>push_back</code>会在<code>std::vector</code>中构造出一个形参的副本，这个过程是通过调用移动构造函数来完成的（这已经是第二次调用构造函数了）。在<code>push_back</code>返回后，临时对象将立刻被销毁，这又调用了<code>std::string</code>的析构函数。</p>
<p>从原理上来说，<strong>置入函数（emplacement function）</strong> 在大部分时候应该比插入函数更高效，而且不会有更低效的可能性。<code>emplace_back</code>函数使用了完美转发，因此调用它不会带来任何的临时对象：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但令人遗憾的是，插入函数还是有可能比置入函数更快的，这取决于传递的实参类型，使用的容器种类，置入或插入到容器中的位置，容器中类型的构造函数的异常安全性，和对于禁止重复值的容器（<code>std::set</code>，<code>std::map</code>，<code>std::unordered_set</code>和<code>set::unordered_map</code>）而言，要添加的值是否已经在容器中。不过在以下这些情况，置入函数很有可能会运行得更快：</p>
<ul>
<li>待添加的值是通过构造而非赋值方式加入容器。一个反例是向<code>std::vector</code>中已经被占据的位置置入对象：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">></span> vs<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                                 <span class="token comment">// 向 vs 中添加元素</span>

vs<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>vs<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"xyzzy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 向 vs 的开头添加元素，该位置已经存在对象</span>
                                    <span class="token comment">// 使用的是赋值而非构造方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>基于节点的容器一般都使用构造来添加新元素，而大多数标准库容器都是基于节点的，除了<code>std::vector</code>，<code>std::deque</code>和<code>std::string</code>等（<code>std::array</code>也不是基于节点的，但是它不支持置入和插入，所以和我们的讨论无关）。在不是基于节点的容器中，你可以确信<code>emplace_back</code>是使用构造来向容器添加元素的，这对于<code>std::deque</code>的<code>emplace_front</code>也同样成立。</p>
</blockquote>
<ul>
<li>传递的实参类型和容器所持有的类型不同。</li>
<li>容器不会因为存在重复值而拒绝待添加的值。</li>
</ul>
<p>在面对<code>new Widget</code>这样的表达式时，置入函数也没有什么优势。考虑以下两种向<code>std::shared_ptr</code>容器中添加新元素的方式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">killWidget</span><span class="token punctuation">(</span>Widget<span class="token operator">*</span> pWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 自定义删除器</span>

ptrs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Widget<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 和 ptrs.push_back(&#123; new Widget, killWidget &#125;) 等价</span>

ptrs<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此处使用<code>push_back</code>仍然会创建出<code>std::shared_ptr</code>类型的临时对象，但该临时对象却拥有了正面意义，如果在为链表节点分配内存时抛出了内存不足的异常，那么该<code>std::shared_ptr</code>临时对象可以自动调用<code>killWidget</code>来释放<code>Widget</code>的内存；但在使用<code>emplace_back</code>的情况下，起到保障作用的<code>std::shared_ptr</code>临时对象将不再存在，如果发生同样的异常，那么<code>Widget</code>的内存将不可避免地被泄漏。</p>
<p>如果你参考<strong>条款 21</strong> 所述，使用独立语句将<code>new Widget</code>产生的指针转交给资源管理对象，那么使用置入函数和插入函数的效果也是差不多的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Widget<span class="token operator">></span> <span class="token function">spw</span><span class="token punctuation">(</span><span class="token keyword">new</span> Widget<span class="token punctuation">,</span> killWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>

ptrs<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>spw<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 或 ptrs.emplace_back(std::move(spw))</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后需要注意的一点是，置入函数可能会执行在插入函数中会被拒绝的类型转换。这是因为置入函数使用的是直接初始化，而插入函数使用的是拷贝初始化，只有直接初始化会将带有<code>explicit</code>限定符的构造函数纳入考虑范围。因此在使用置入函数时，要特别关注是否传递了正确的实参：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>regex<span class="token operator">></span> regexes<span class="token punctuation">;</span>    <span class="token comment">// C++11 提供了对正则表达式的支持</span>

regexes<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 无法通过编译！</span>
regexes<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 能通过编译，但会产生未定义行为</span>
                                    <span class="token comment">// 相当于执行 std::regex(nullptr)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2024/01/19/EffectiveModernCpp/">http://charliechen114514.github.io/2024/01/19/EffectiveModernCpp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/20/%E5%BA%93%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Logger%E5%BA%93/" title="库设计：一个简单的Logger库"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">库设计：一个简单的Logger库</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/19/Linux%E6%BC%AB%E6%B8%B8%E5%90%88%E9%9B%86/" title="Linux漫游合集"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux漫游合集</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_RecursionSpecial</div></div></a></div><div><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_in_C(1)</div></div></a></div><div><a href="/2024/01/09/2024%E5%AF%92%E5%81%87%E6%95%B4%E6%B4%BB-C-Cppb%E9%AB%98%E7%BA%A7%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/" title="2024寒假整活_C_Cppb高级编译技术"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-09</div><div class="title">2024寒假整活_C_Cppb高级编译技术</div></div></a></div><div><a href="/2023/12/03/C-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%93%8D%E4%BD%9C%E6%89%93%E5%8D%B0tuple/" title="C++使用模板操作打印tuple"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="title">C++使用模板操作打印tuple</div></div></a></div><div><a href="/2023/12/28/AutoClassGenerator%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" title="AutoClassGenerator开发记录"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-28</div><div class="title">AutoClassGenerator开发记录</div></div></a></div><div><a href="/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/" title="Cpp异常处理与并发编程简单笔记"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-16</div><div class="title">Cpp异常处理与并发编程简单笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Effective-Modern-C"><span class="toc-number">1.</span> <span class="toc-text">Effective Modern C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%88%AB%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.1.</span> <span class="toc-text">理解模板类别推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-1-ParamType%E5%85%B7%E6%9C%89%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E6%98%AF%E5%BC%95%E7%94%A8%E5%9E%8B%E5%88%AB%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">Case 1:ParamType具有指针或者是引用型别，但不是一个万能引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#case-2-param%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">case 2: param是一个万能引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E2%80%9D%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">为什么是“万能引用”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-number">1.5.</span> <span class="toc-text">引用折叠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#case-3-param%E6%97%A2%E4%B8%8D%E6%98%AF%E6%8C%87%E9%92%88%E5%8F%88%E4%B8%8D%E6%98%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">case 3: param既不是指针又不是引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E5%8F%82"><span class="toc-number">1.5.2.</span> <span class="toc-text">数组实参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3auto%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.6.</span> <span class="toc-text">理解auto型别推导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3decltype"><span class="toc-number">1.7.</span> <span class="toc-text">理解decltype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decltype-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.8.</span> <span class="toc-text">decltype 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E7%9F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">获知表达式的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype-%E7%9A%84%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-number">1.8.2.</span> <span class="toc-text">decltype 的推导规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E7%B1%BB%E8%AE%BF%E9%97%AE%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.8.3.</span> <span class="toc-text">标识符表达式和类访问表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%8B%AC%E5%8F%B7%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.8.5.</span> <span class="toc-text">带括号的表达式和加法运算表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.6.</span> <span class="toc-text">decltype 的实际应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype-%E7%9A%84%E5%BA%94%E7%94%A8%E5%A4%9A%E5%87%BA%E7%8E%B0%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%AD"><span class="toc-number">1.8.7.</span> <span class="toc-text">decltype 的应用多出现在泛型编程中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype-%E7%94%A8%E5%9C%A8%E9%80%9A%E8%BF%87%E5%8F%98%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8A%BD%E5%8F%96%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.8.8.</span> <span class="toc-text">decltype 用在通过变量表达式抽取变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%E8%AF%AD%E6%B3%95%E2%80%94%E2%80%94auto-%E5%92%8Cdecltype-%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.9.</span> <span class="toc-text">返回类型后置语法——auto 和decltype 的结合使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-forward"><span class="toc-number">1.9.</span> <span class="toc-text">std::forward</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0-1"><span class="toc-number">1.10.</span> <span class="toc-text">引用折叠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-forward%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.</span> <span class="toc-text">std::forward函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8std-forward%E5%AE%9E%E7%8E%B0%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">1.12.</span> <span class="toc-text">利用std::forward实现完美转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.12.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.12.2.</span> <span class="toc-text">完美转发应用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.12.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-forward%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%8F%82%E8%80%83%E8%87%AAChatGPT%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">std::forward实现原理（参考自ChatGPT）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.14.</span> <span class="toc-text">C ++ Lambda表达式详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.14.1.</span> <span class="toc-text">1.Lambda表达式概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.14.2.</span> <span class="toc-text">2.Lambda表达式定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">2.1 Lambda表达式示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">2.2 Lambda表达式语法定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.14.2.3.</span> <span class="toc-text">2.3 Lambda表达式参数详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-Lambda%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="toc-number">1.14.2.3.1.</span> <span class="toc-text">2.3.1 Lambda捕获列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-Lambda%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">1.14.2.3.2.</span> <span class="toc-text">2.3.2 Lambda参数列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-%E5%8F%AF%E5%8F%98%E8%A7%84%E6%A0%BCmutable"><span class="toc-number">1.14.2.3.3.</span> <span class="toc-text">2.3.3 可变规格mutable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-number">1.14.2.3.4.</span> <span class="toc-text">2.3.4 异常说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.14.2.3.5.</span> <span class="toc-text">2.3.5 返回类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-6-Lambda%E5%87%BD%E6%95%B0%E4%BD%93"><span class="toc-number">1.14.2.3.6.</span> <span class="toc-text">2.3.6 Lambda函数体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.14.3.</span> <span class="toc-text">3.Lambda表达式的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">3.1 Lambda表达式的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">3.2 Lambda表达式的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.14.4.</span> <span class="toc-text">4.Lambda表达式工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.14.4.1.</span> <span class="toc-text">4.1 Lambda表达式工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-C-%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">1.14.4.2.</span> <span class="toc-text">4.2 C++仿函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.14.5.</span> <span class="toc-text">5.Lamdba表达式适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E7%94%A8%E4%BA%8ESTL%E7%AE%97%E6%B3%95%E5%BA%93"><span class="toc-number">1.14.5.1.</span> <span class="toc-text">5.1 Lamdba表达式应用于STL算法库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E7%9F%AD%E5%B0%8F%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%8D%E7%94%A8%E5%87%BD%E6%95%B0%E5%9C%BA%E6%99%AF"><span class="toc-number">1.14.5.2.</span> <span class="toc-text">5.2 短小不需要复用函数场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">1.14.5.3.</span> <span class="toc-text">5.3 Lamdba表达式应用于多线程场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BA%94%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8Efunction"><span class="toc-number">1.14.5.4.</span> <span class="toc-text">5.4 Lamdba表达式应用于函数指针与function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A5%E5%8F%82"><span class="toc-number">1.14.5.5.</span> <span class="toc-text">5.5 Lamdba表达式作为函数的入参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-Lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9C%A8QT%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.14.5.6.</span> <span class="toc-text">5.6 Lamdba表达式在QT中的应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93auto%E6%8E%A8%E5%AF%BC%E7%9A%84%E5%9E%8B%E5%88%AB%E4%B8%8D%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%BC%BA%E8%BD%AC%E4%B9%8B"><span class="toc-number">1.15.</span> <span class="toc-text">当auto推导的型别不符合要求的时候，强转之</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%86-%E5%92%8C"><span class="toc-number">1.16.</span> <span class="toc-text">区分()和{}</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8nullptr%E8%80%8C%E4%B8%8D%E6%98%AF0-NULL"><span class="toc-number">1.17.</span> <span class="toc-text">优先选用nullptr而不是0, NULL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D%E8%80%8C%E4%B8%8D%E6%98%AFtypedef"><span class="toc-number">1.18.</span> <span class="toc-text">优先使用别名而不是typedef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8enum-class%E8%80%8C%E4%B8%8D%E6%98%AFenum"><span class="toc-number">1.19.</span> <span class="toc-text">优先使用enum class而不是enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8A%8A%E5%87%BD%E6%95%B0%E5%A1%9E%E5%88%B0private%E4%B8%94%E4%B8%8D%E4%B8%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">1.20.</span> <span class="toc-text">优先使用删除函数，而不是把函数塞到private且不下定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E6%84%8F%E5%9C%A8%E6%94%B9%E5%86%99%E7%9A%84%E5%87%BD%E6%95%B0%E6%B7%BB%E5%8A%A0override"><span class="toc-number">1.21.</span> <span class="toc-text">为意在改写的函数添加override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8const-iterator%E8%80%8C%E4%B8%8D%E6%98%AFiterator"><span class="toc-number">1.22.</span> <span class="toc-text">优先选用const_iterator而不是iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%A6%81%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%91%E5%B0%84%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%B0%B1%E5%BA%94%E8%AF%A5%E5%8A%A0%E4%B8%8Anoexcept%E5%A3%B0%E6%98%8E"><span class="toc-number">1.23.</span> <span class="toc-text">只要函数不发射异常，就应该加上noexcept声明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Microsoft-Team%E7%BB%99%E5%87%BA%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">1.23.1.</span> <span class="toc-text">Microsoft Team给出的解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.24.</span> <span class="toc-text">保证const成员函数的线程安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E7%89%B9%E7%A7%8D%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6"><span class="toc-number">1.25.</span> <span class="toc-text">理解特种成员函数的生成机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8std-unique-ptr%E6%9D%A5%E7%AE%A1%E7%90%86%E5%85%B7%E5%A4%87%E4%B8%93%E5%B1%9E%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">1.26.</span> <span class="toc-text">使用std::unique_ptr来管理具备专属所有权的资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-std-shared-ptr-%E7%AE%A1%E7%90%86%E5%85%B7%E5%A4%87%E5%85%B1%E4%BA%AB%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">1.27.</span> <span class="toc-text">使用 std::shared_ptr 管理具备共享所有权的资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8std-weak-ptr%E9%98%B2%E6%AD%A2%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E6%8C%87%E9%92%88%E5%A4%B1%E6%95%88"><span class="toc-number">1.28.</span> <span class="toc-text">使用std::weak_ptr防止循环引用导致指针失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8-std-make-unique-%E5%92%8C-std-make-shared%EF%BC%8C%E8%80%8C%E9%9D%9E%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-new"><span class="toc-number">1.29.</span> <span class="toc-text">优先选用 std::make_unique 和 std::make_shared，而非直接使用 new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Pimpl-%E6%83%AF%E7%94%A8%E6%B3%95%E6%97%B6%EF%BC%8C%E5%B0%86%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%94%BE%E5%88%B0%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">1.30.</span> <span class="toc-text">使用 Pimpl 惯用法时，将特殊成员函数的定义放到实现文件中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-std-move-%E5%92%8C-std-forward"><span class="toc-number">1.31.</span> <span class="toc-text">理解 std::move 和 std::forward</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.32.</span> <span class="toc-text">区分万能引用和右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%9E%E6%96%BD-std-move%EF%BC%8C%E9%92%88%E5%AF%B9%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%AE%9E%E6%96%BD-std-forward"><span class="toc-number">1.33.</span> <span class="toc-text">针对右值引用实施 std::move，针对万能引用实施 std::forward</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%AF%B9%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">1.34.</span> <span class="toc-text">避免对万能引用类型进行重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%9F%E6%82%89%E5%AF%B9%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">1.35.</span> <span class="toc-text">熟悉对万能引用类型进行重载的替代方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-number">1.36.</span> <span class="toc-text">理解引用折叠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E5%AE%9A%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C%E4%B8%8D%E5%AD%98%E5%9C%A8%E3%80%81%E6%88%90%E6%9C%AC%E9%AB%98%E3%80%81%E6%9C%AA%E8%A2%AB%E4%BD%BF%E7%94%A8"><span class="toc-number">1.37.</span> <span class="toc-text">假定移动操作不存在、成本高、未被使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%86%9F%E6%82%89%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%9A%84%E5%A4%B1%E8%B4%A5%E6%83%85%E5%BD%A2"><span class="toc-number">1.38.</span> <span class="toc-text">熟悉完美转发的失败情形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.39.</span> <span class="toc-text">lambda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E9%BB%98%E8%AE%A4%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.40.</span> <span class="toc-text">避免默认捕获模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8D%95%E8%8E%B7%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%85%A5%E9%97%AD%E5%8C%85"><span class="toc-number">1.41.</span> <span class="toc-text">使用初始化捕获将对象移入闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9-auto-amp-amp-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BD%A2%E5%8F%82%E4%BD%BF%E7%94%A8-decltype-%E4%BB%A5%E5%AF%B9%E5%85%B6%E5%AE%9E%E6%96%BD-std-forward"><span class="toc-number">1.42.</span> <span class="toc-text">对 auto&amp;&amp; 类型的形参使用 decltype 以对其实施 std::forward</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8-lambda%EF%BC%8C%E8%80%8C%E9%9D%9E-std-bind"><span class="toc-number">1.43.</span> <span class="toc-text">优先选用 lambda，而非 std::bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%80%89%E7%94%A8%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1%E8%80%8C%E9%9D%9E%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.44.</span> <span class="toc-text">优先选用基于任务而非基于线程的程序设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%BC%82%E6%AD%A5%E6%98%AF%E5%BF%85%E8%A6%81%E7%9A%84%EF%BC%8C%E5%88%99%E6%8C%87%E5%AE%9A-std-launch-async"><span class="toc-number">1.45.</span> <span class="toc-text">如果异步是必要的，则指定 std::launch::async</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF-std-thread-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E7%9A%86%E4%B8%8D%E5%8F%AF%E8%81%94%E7%BB%93"><span class="toc-number">1.46.</span> <span class="toc-text">使 std::thread 对象在所有路径皆不可联结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B%E5%8F%A5%E6%9F%84%E7%9A%84%E6%9E%90%E6%9E%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.47.</span> <span class="toc-text">注意不同线程句柄的析构行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E8%99%91%E5%AF%B9%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BA%8B%E4%BB%B6%E9%80%9A%E4%BF%A1%E4%BD%BF%E7%94%A8-void-%E7%9A%84-futures"><span class="toc-number">1.48.</span> <span class="toc-text">考虑对一次性事件通信使用 void 的 futures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%B9%B6%E5%8F%91%E4%BD%BF%E7%94%A8-std-atomic%EF%BC%8C%E5%AF%B9%E7%89%B9%E6%AE%8A%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8-volatile"><span class="toc-number">1.49.</span> <span class="toc-text">对并发使用 std::atomic，对特殊内存使用 volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%A7%BB%E5%8A%A8%E6%88%90%E6%9C%AC%E4%BD%8E%E4%B8%94%E6%80%BB%E6%98%AF%E8%A2%AB%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8F%AF%E6%8B%B7%E8%B4%9D%E5%BD%A2%E5%8F%82%EF%BC%8C%E8%80%83%E8%99%91%E5%B0%86%E5%85%B6%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">1.50.</span> <span class="toc-text">对于移动成本低且总是被拷贝的可拷贝形参，考虑将其按值传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%80%83%E8%99%91%E7%BD%AE%E5%85%A5%E8%80%8C%E9%9D%9E%E6%8F%92%E5%85%A5"><span class="toc-number">1.51.</span> <span class="toc-text">考虑置入而非插入</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/20/ArchLinux%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" title="虚拟机Arch Linux With KDE6(x11)安装小记"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="虚拟机Arch Linux With KDE6(x11)安装小记"/></a><div class="content"><a class="title" href="/2024/03/20/ArchLinux%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" title="虚拟机Arch Linux With KDE6(x11)安装小记">虚拟机Arch Linux With KDE6(x11)安装小记</a><time datetime="2024-03-20T05:09:52.000Z" title="发表于 2024-03-20 13:09:52">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/16/C-%E5%90%8E%E7%AB%AF%E5%85%A5%E9%97%A8-1-cpp%E5%9F%BA%E7%A1%80/" title="C++后端入门 1-cpp基础"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++后端入门 1-cpp基础"/></a><div class="content"><a class="title" href="/2024/03/16/C-%E5%90%8E%E7%AB%AF%E5%85%A5%E9%97%A8-1-cpp%E5%9F%BA%E7%A1%80/" title="C++后端入门 1-cpp基础">C++后端入门 1-cpp基础</a><time datetime="2024-03-15T23:36:49.000Z" title="发表于 2024-03-16 07:36:49">2024-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/08/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%B5%85%E8%AE%BA/" title="C++智能指针浅论"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++智能指针浅论"/></a><div class="content"><a class="title" href="/2024/03/08/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%B5%85%E8%AE%BA/" title="C++智能指针浅论">C++智能指针浅论</a><time datetime="2024-03-08T14:09:12.000Z" title="发表于 2024-03-08 22:09:12">2024-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/05/Linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="Linux内核深度学习"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux内核深度学习"/></a><div class="content"><a class="title" href="/2024/03/05/Linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="Linux内核深度学习">Linux内核深度学习</a><time datetime="2024-03-05T01:04:41.000Z" title="发表于 2024-03-05 09:04:41">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/29/Opencv490-MSVC-Mingw-WITHQT-OpencvContrib4-x%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/" title="Opencv490+MSVC_Mingw+WITHQT+OpencvContrib4_x编译教程"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Opencv490+MSVC_Mingw+WITHQT+OpencvContrib4_x编译教程"/></a><div class="content"><a class="title" href="/2024/01/29/Opencv490-MSVC-Mingw-WITHQT-OpencvContrib4-x%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/" title="Opencv490+MSVC_Mingw+WITHQT+OpencvContrib4_x编译教程">Opencv490+MSVC_Mingw+WITHQT+OpencvContrib4_x编译教程</a><time datetime="2024-01-29T10:03:05.000Z" title="发表于 2024-01-29 18:03:05">2024-01-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>