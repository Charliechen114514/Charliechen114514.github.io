<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>重新学习Linux系统编程-5 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高级进程管理进程调度​        进程调度是一个高级话题，他决定了CPU在何时执行哪个程序，跑哪个进程。多任务的操作系统分为协同式和抢占式两类。Linux是后一种，当前的进程调度器是CFS调度器，也就是完全公平的调度器。 时间片​        时间片指代的是系统分配给进程的时间长短。时间片的分配就涉及到了分配算法的问题。在Linux里是不使用时间片这个概念的。 IO约束进程和处理器约束进程​">
<meta property="og:type" content="article">
<meta property="og:title" content="重新学习Linux系统编程-5">
<meta property="og:url" content="http://charliechen114514.github.io/2024/01/20/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-5/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="高级进程管理进程调度​        进程调度是一个高级话题，他决定了CPU在何时执行哪个程序，跑哪个进程。多任务的操作系统分为协同式和抢占式两类。Linux是后一种，当前的进程调度器是CFS调度器，也就是完全公平的调度器。 时间片​        时间片指代的是系统分配给进程的时间长短。时间片的分配就涉及到了分配算法的问题。在Linux里是不使用时间片这个概念的。 IO约束进程和处理器约束进程​">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2024-01-20T07:30:50.000Z">
<meta property="article:modified_time" content="2024-01-20T07:31:03.836Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2024/01/20/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '重新学习Linux系统编程-5',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-20 15:31:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">重新学习Linux系统编程-5</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-20T07:30:50.000Z" title="发表于 2024-01-20 15:30:50">2024-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-20T07:31:03.836Z" title="更新于 2024-01-20 15:31:03">2024-01-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="重新学习Linux系统编程-5"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="高级进程管理"><a href="#高级进程管理" class="headerlink" title="高级进程管理"></a>高级进程管理</h1><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>​        进程调度是一个高级话题，他决定了CPU在何时执行哪个程序，跑哪个进程。多任务的操作系统分为协同式和抢占式两类。Linux是后一种，当前的进程调度器是CFS调度器，也就是完全公平的调度器。</p>
<h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>​        时间片指代的是系统分配给进程的时间长短。时间片的分配就涉及到了分配算法的问题。在Linux里是不使用时间片这个概念的。</p>
<h3 id="IO约束进程和处理器约束进程"><a href="#IO约束进程和处理器约束进程" class="headerlink" title="IO约束进程和处理器约束进程"></a>IO约束进程和处理器约束进程</h3><p>​        那些一直消耗所有的可用的时间片的进程是处理器约束进程，特点就是几乎不阻塞，老老实实的使用时间片完成任务。另一方面，IO约束进程就是经常发生等待（文件，网络等），他们一般不会消耗CPU计算力但是却是耗时的</p>
<h3 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><p>​        这指代的是进程存在优先级，那些优先级高的程序将有权力剥夺低权限的进程的CPU。这样所有的进程都可以通过调整优先级的方式都获得运行。</p>
<h2 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h2><p>​        CFS（Completely Fair Scheduler，完全公平调度器)用于Linux系统中普通进程的调度。它给cfs_rq（cfs的run queue）中的每一个进程设置一个虚拟时钟，vruntime。如果一个进程得以执行，随着时间的增长（一个个tick的到来），其vruntime将不断增大。没有得到执行的进程vruntime不变。调度器总是选择vruntime跑得最慢的那个进程来执行。这就是所谓的“完全公平”。为了区别不同优先级的进程，优先级高的进程vruntime增长得慢，以至于它可能得到更多的运行机会。</p>
<p>​        CFS不区分具体的cpu算力消耗型进程，还是io消耗型进程，统一采用红黑树算法来管理所有的调度实体sched_entity，算法效率为O(log(n))。每个进程都由一个struct task_struct来表示，为什么这里又定义了一个sched_entity？</p>
<p>​        这是由于调度需要一些更详细的信息，比如当前运行时间或上次运行时间，因此就搞出了一个sched_entity的概念，为了存储一些调度相关的信息，给调度器用。CFS跟踪调度实体sched_entity的虚拟运行时间vruntime，平等对待运行队列中的调度实体sched_entity，将执行时间少的调度实体sched_entity排列到红黑树的最左边。调度实体sched_entity通过enqueue_entity()和dequeue_entity()来进行红黑树的出队入队。</p>
<h3 id="调整优先级的办法"><a href="#调整优先级的办法" class="headerlink" title="调整优先级的办法"></a>调整优先级的办法</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token keyword">int</span> <span class="token function">nice</span><span class="token punctuation">(</span><span class="token keyword">int</span> inc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        第一个就是使用nice，<strong>nice值越高，进程优先度越低！</strong>事实上，这里的inc值指代的是增加的量，默认的进程的nice值已经是非root下的最高值了，用回户进程调用只会降低优先级</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/resource.h></span></span>
<span class="token keyword">int</span> <span class="token function">getpriority</span><span class="token punctuation">(</span><span class="token keyword">int</span> which<span class="token punctuation">,</span> <span class="token class-name">id_t</span> who<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">setpriority</span><span class="token punctuation">(</span><span class="token keyword">int</span> which<span class="token punctuation">,</span> <span class="token class-name">id_t</span> who<span class="token punctuation">,</span> <span class="token keyword">int</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        更加好的API是这个</p>
<pre class="line-numbers language-none"><code class="language-none">The scheduling priority of the process, process group, or user,
as indicated by which and who is obtained with the getpriority()
call and set with the setpriority() call.  The process attribute
dealt with by these system calls is the same attribute (also
known as the &quot;nice&quot; value) that is dealt with by nice(2).

The value which is one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER,
and who is interpreted relative to which (a process identifier
for PRIO_PROCESS, process group identifier for PRIO_PGRP, and a
user ID for PRIO_USER).  A zero value for who denotes
(respectively) the calling process, the process group of the
calling process, or the real user ID of the calling process.

The prio argument is a value in the range -20 to 19 (but see
NOTES below), with -20 being the highest priority and 19 being
the lowest priority.  Attempts to set a priority outside this
range are silently clamped to the range.  The default priority is
0; lower values give a process a higher scheduling priority.

The getpriority() call returns the highest priority (lowest
numerical value) enjoyed by any of the specified processes.  The
setpriority() call sets the priorities of all of the specified
processes to the specified value.

Traditionally, only a privileged process could lower the nice
value (i.e., set a higher priority).  However, since Linux
2.6.12, an unprivileged process can decrease the nice value of a
target process that has a suitable RLIMIT_NICE soft limit; see
getrlimit(2) for details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们还可以调整IO响应优先级：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;linux&#x2F;ioprio.h&gt;    &#x2F;* Definition of IOPRIO_* constants *&#x2F;
#include &lt;sys&#x2F;syscall.h&gt;     &#x2F;* Definition of SYS_* constants *&#x2F;
#include &lt;unistd.h&gt;

int syscall(SYS_ioprio_get, int which, int who);
int syscall(SYS_ioprio_set, int which, int who, int ioprio);

Note: glibc provides no wrappers for these system calls,
necessitating the use of syscall(2).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="处理器的亲和性"><a href="#处理器的亲和性" class="headerlink" title="处理器的亲和性"></a>处理器的亲和性</h2><p>​        我们知道，为了防止处理器的缓存无效，我们往往会让进程进程可能的在一个处理器上跑。有多大的努力系统会让进程在一个处理器上跑就说明了亲和性是如何的</p>
<pre class="line-numbers language-none"><code class="language-none">      #define _GNU_SOURCE             &#x2F;* See feature_test_macros(7) *&#x2F;
       #include &lt;sched.h&gt;

       int sched_setaffinity(pid_t pid, size_t cpusetsize,
                             const cpu_set_t *mask);
       int sched_getaffinity(pid_t pid, size_t cpusetsize,
                             cpu_set_t *mask);
DESCRIPTION         top
       A thread&#39;s CPU affinity mask determines the set of CPUs on which
       it is eligible to run.  On a multiprocessor system, setting the
       CPU affinity mask can be used to obtain performance benefits.
       For example, by dedicating one CPU to a particular thread (i.e.,
       setting the affinity mask of that thread to specify a single CPU,
       and setting the affinity mask of all other threads to exclude
       that CPU), it is possible to ensure maximum execution speed for
       that thread.  Restricting a thread to run on a single CPU also
       avoids the performance cost caused by the cache invalidation that
       occurs when a thread ceases to execute on one CPU and then
       recommences execution on a different CPU.

       A CPU affinity mask is represented by the cpu_set_t structure, a
       &quot;CPU set&quot;, pointed to by mask.  A set of macros for manipulating
       CPU sets is described in CPU_SET(3).

       sched_setaffinity() sets the CPU affinity mask of the thread
       whose ID is pid to the value specified by mask.  If pid is zero,
       then the calling thread is used.  The argument cpusetsize is the
       length (in bytes) of the data pointed to by mask.  Normally this
       argument would be specified as sizeof(cpu_set_t).

       If the thread specified by pid is not currently running on one of
       the CPUs specified in mask, then that thread is migrated to one
       of the CPUs specified in mask.

       sched_getaffinity() writes the affinity mask of the thread whose
       ID is pid into the cpu_set_t structure pointed to by mask.  The
       cpusetsize argument specifies the size (in bytes) of mask.  If
       pid is zero, then the mask of the calling thread is returned.
RETURN VALUE         top
       On success, sched_setaffinity() and sched_getaffinity() return 0
       (but see &quot;C library&#x2F;kernel differences&quot; below, which notes that
       the underlying sched_getaffinity() differs in its return value).
       On failure, -1 is returned, and errno is set to indicate the
       error.
ERRORS         top
       EFAULT A supplied memory address was invalid.

       EINVAL The affinity bit mask mask contains no processors that are
              currently physically on the system and permitted to the
              thread according to any restrictions that may be imposed
              by cpuset cgroups or the &quot;cpuset&quot; mechanism described in
              cpuset(7).

       EINVAL (sched_getaffinity() and, before Linux 2.6.9,
              sched_setaffinity()) cpusetsize is smaller than the size
              of the affinity mask used by the kernel.

       EPERM  (sched_setaffinity()) The calling thread does not have
              appropriate privileges.  The caller needs an effective
              user ID equal to the real user ID or effective user ID of
              the thread identified by pid, or it must possess the
              CAP_SYS_NICE capability in the user namespace of the
              thread pid.

       ESRCH  The thread whose ID is pid could not be found.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>​        使用下面的系统调用获取对应的资源限制数目：</p>
<pre class="line-numbers language-none"><code class="language-none">       #include &lt;sys&#x2F;resource.h&gt;

       int getrlimit(int resource, struct rlimit *rlim);
       int setrlimit(int resource, const struct rlimit *rlim);

       int prlimit(pid_t pid, int resource,
                   const struct rlimit *_Nullable new_limit,
                   struct rlimit *_Nullable old_limit);

   Feature Test Macro Requirements for glibc (see
   feature_test_macros(7)):

       prlimit():
           _GNU_SOURCE
DESCRIPTION         top
       The getrlimit() and setrlimit() system calls get and set resource
       limits.  Each resource has an associated soft and hard limit, as
       defined by the rlimit structure:

           struct rlimit &#123;
               rlim_t rlim_cur;  &#x2F;* Soft limit *&#x2F;
               rlim_t rlim_max;  &#x2F;* Hard limit (ceiling for rlim_cur) *&#x2F;
           &#125;;

       The soft limit is the value that the kernel enforces for the
       corresponding resource.  The hard limit acts as a ceiling for the
       soft limit: an unprivileged process may set only its soft limit
       to a value in the range from 0 up to the hard limit, and
       (irreversibly) lower its hard limit.  A privileged process (under
       Linux: one with the CAP_SYS_RESOURCE capability in the initial
       user namespace) may make arbitrary changes to either limit value.

       The value RLIM_INFINITY denotes no limit on a resource (both in
       the structure returned by getrlimit() and in the structure passed
       to setrlimit()).

       The resource argument must be one of:

       RLIMIT_AS
              This is the maximum size of the process&#39;s virtual memory
              (address space).  The limit is specified in bytes, and is
              rounded down to the system page size.  This limit affects
              calls to brk(2), mmap(2), and mremap(2), which fail with
              the error ENOMEM upon exceeding this limit.  In addition,
              automatic stack expansion fails (and generates a SIGSEGV
              that kills the process if no alternate stack has been made
              available via sigaltstack(2)).  Since the value is a long,
              on machines with a 32-bit long either this limit is at
              most 2 GiB, or this resource is unlimited.

       RLIMIT_CORE
              This is the maximum size of a core file (see core(5)) in
              bytes that the process may dump.  When 0 no core dump
              files are created.  When nonzero, larger dumps are
              truncated to this size.

       RLIMIT_CPU
              This is a limit, in seconds, on the amount of CPU time
              that the process can consume.  When the process reaches
              the soft limit, it is sent a SIGXCPU signal.  The default
              action for this signal is to terminate the process.
              However, the signal can be caught, and the handler can
              return control to the main program.  If the process
              continues to consume CPU time, it will be sent SIGXCPU
              once per second until the hard limit is reached, at which
              time it is sent SIGKILL.  (This latter point describes
              Linux behavior.  Implementations vary in how they treat
              processes which continue to consume CPU time after
              reaching the soft limit.  Portable applications that need
              to catch this signal should perform an orderly termination
              upon first receipt of SIGXCPU.)

       RLIMIT_DATA
              This is the maximum size of the process&#39;s data segment
              (initialized data, uninitialized data, and heap).  The
              limit is specified in bytes, and is rounded down to the
              system page size.  This limit affects calls to brk(2),
              sbrk(2), and (since Linux 4.7) mmap(2), which fail with
              the error ENOMEM upon encountering the soft limit of this
              resource.

       RLIMIT_FSIZE
              This is the maximum size in bytes of files that the
              process may create.  Attempts to extend a file beyond this
              limit result in delivery of a SIGXFSZ signal.  By default,
              this signal terminates a process, but a process can catch
              this signal instead, in which case the relevant system
              call (e.g., write(2), truncate(2)) fails with the error
              EFBIG.

       RLIMIT_LOCKS (Linux 2.4.0 to Linux 2.4.24)
              This is a limit on the combined number of flock(2) locks
              and fcntl(2) leases that this process may establish.

       RLIMIT_MEMLOCK
              This is the maximum number of bytes of memory that may be
              locked into RAM.  This limit is in effect rounded down to
              the nearest multiple of the system page size.  This limit
              affects mlock(2), mlockall(2), and the mmap(2) MAP_LOCKED
              operation.  Since Linux 2.6.9, it also affects the
              shmctl(2) SHM_LOCK operation, where it sets a maximum on
              the total bytes in shared memory segments (see shmget(2))
              that may be locked by the real user ID of the calling
              process.  The shmctl(2) SHM_LOCK locks are accounted for
              separately from the per-process memory locks established
              by mlock(2), mlockall(2), and mmap(2) MAP_LOCKED; a
              process can lock bytes up to this limit in each of these
              two categories.

              Before Linux 2.6.9, this limit controlled the amount of
              memory that could be locked by a privileged process.
              Since Linux 2.6.9, no limits are placed on the amount of
              memory that a privileged process may lock, and this limit
              instead governs the amount of memory that an unprivileged
              process may lock.

       RLIMIT_MSGQUEUE (since Linux 2.6.8)
              This is a limit on the number of bytes that can be
              allocated for POSIX message queues for the real user ID of
              the calling process.  This limit is enforced for
              mq_open(3).  Each message queue that the user creates
              counts (until it is removed) against this limit according
              to the formula:

                  Since Linux 3.5:

                      bytes &#x3D; attr.mq_maxmsg * sizeof(struct msg_msg) +
                              MIN(attr.mq_maxmsg, MQ_PRIO_MAX) *
                                    sizeof(struct posix_msg_tree_node)+
                                              &#x2F;* For overhead *&#x2F;
                              attr.mq_maxmsg * attr.mq_msgsize;
                                              &#x2F;* For message data *&#x2F;

                  Linux 3.4 and earlier:

                      bytes &#x3D; attr.mq_maxmsg * sizeof(struct msg_msg *) +
                                              &#x2F;* For overhead *&#x2F;
                              attr.mq_maxmsg * attr.mq_msgsize;
                                              &#x2F;* For message data *&#x2F;

              where attr is the mq_attr structure specified as the
              fourth argument to mq_open(3), and the msg_msg and
              posix_msg_tree_node structures are kernel-internal
              structures.

              The &quot;overhead&quot; addend in the formula accounts for overhead
              bytes required by the implementation and ensures that the
              user cannot create an unlimited number of zero-length
              messages (such messages nevertheless each consume some
              system memory for bookkeeping overhead).

       RLIMIT_NICE (since Linux 2.6.12, but see BUGS below)
              This specifies a ceiling to which the process&#39;s nice value
              can be raised using setpriority(2) or nice(2).  The actual
              ceiling for the nice value is calculated as 20 - rlim_cur.
              The useful range for this limit is thus from 1
              (corresponding to a nice value of 19) to 40 (corresponding
              to a nice value of -20).  This unusual choice of range was
              necessary because negative numbers cannot be specified as
              resource limit values, since they typically have special
              meanings.  For example, RLIM_INFINITY typically is the
              same as -1.  For more detail on the nice value, see
              sched(7).

       RLIMIT_NOFILE
              This specifies a value one greater than the maximum file
              descriptor number that can be opened by this process.
              Attempts (open(2), pipe(2), dup(2), etc.)  to exceed this
              limit yield the error EMFILE.  (Historically, this limit
              was named RLIMIT_OFILE on BSD.)

              Since Linux 4.5, this limit also defines the maximum
              number of file descriptors that an unprivileged process
              (one without the CAP_SYS_RESOURCE capability) may have &quot;in
              flight&quot; to other processes, by being passed across UNIX
              domain sockets.  This limit applies to the sendmsg(2)
              system call.  For further details, see unix(7).

       RLIMIT_NPROC
              This is a limit on the number of extant process (or, more
              precisely on Linux, threads) for the real user ID of the
              calling process.  So long as the current number of
              processes belonging to this process&#39;s real user ID is
              greater than or equal to this limit, fork(2) fails with
              the error EAGAIN.

              The RLIMIT_NPROC limit is not enforced for processes that
              have either the CAP_SYS_ADMIN or the CAP_SYS_RESOURCE
              capability, or run with real user ID 0.

       RLIMIT_RSS
              This is a limit (in bytes) on the process&#39;s resident set
              (the number of virtual pages resident in RAM).  This limit
              has effect only in Linux 2.4.x, x &lt; 30, and there affects
              only calls to madvise(2) specifying MADV_WILLNEED.

       RLIMIT_RTPRIO (since Linux 2.6.12, but see BUGS)
              This specifies a ceiling on the real-time priority that
              may be set for this process using sched_setscheduler(2)
              and sched_setparam(2).

              For further details on real-time scheduling policies, see
              sched(7)

       RLIMIT_RTTIME (since Linux 2.6.25)
              This is a limit (in microseconds) on the amount of CPU
              time that a process scheduled under a real-time scheduling
              policy may consume without making a blocking system call.
              For the purpose of this limit, each time a process makes a
              blocking system call, the count of its consumed CPU time
              is reset to zero.  The CPU time count is not reset if the
              process continues trying to use the CPU but is preempted,
              its time slice expires, or it calls sched_yield(2).

              Upon reaching the soft limit, the process is sent a
              SIGXCPU signal.  If the process catches or ignores this
              signal and continues consuming CPU time, then SIGXCPU will
              be generated once each second until the hard limit is
              reached, at which point the process is sent a SIGKILL
              signal.

              The intended use of this limit is to stop a runaway real-
              time process from locking up the system.

              For further details on real-time scheduling policies, see
              sched(7)

       RLIMIT_SIGPENDING (since Linux 2.6.8)
              This is a limit on the number of signals that may be
              queued for the real user ID of the calling process.  Both
              standard and real-time signals are counted for the purpose
              of checking this limit.  However, the limit is enforced
              only for sigqueue(3); it is always possible to use kill(2)
              to queue one instance of any of the signals that are not
              already queued to the process.

       RLIMIT_STACK
              This is the maximum size of the process stack, in bytes.
              Upon reaching this limit, a SIGSEGV signal is generated.
              To handle this signal, a process must employ an alternate
              signal stack (sigaltstack(2)).

              Since Linux 2.6.23, this limit also determines the amount
              of space used for the process&#39;s command-line arguments and
              environment variables; for details, see execve(2).

   prlimit()
       The Linux-specific prlimit() system call combines and extends the
       functionality of setrlimit() and getrlimit().  It can be used to
       both set and get the resource limits of an arbitrary process.

       The resource argument has the same meaning as for setrlimit() and
       getrlimit().

       If the new_limit argument is not NULL, then the rlimit structure
       to which it points is used to set new values for the soft and
       hard limits for resource.  If the old_limit argument is not NULL,
       then a successful call to prlimit() places the previous soft and
       hard limits for resource in the rlimit structure pointed to by
       old_limit.

       The pid argument specifies the ID of the process on which the
       call is to operate.  If pid is 0, then the call applies to the
       calling process.  To set or get the resources of a process other
       than itself, the caller must have the CAP_SYS_RESOURCE capability
       in the user namespace of the process whose resource limits are
       being changed, or the real, effective, and saved set user IDs of
       the target process must match the real user ID of the caller and
       the real, effective, and saved set group IDs of the target
       process must match the real group ID of the caller.
RETURN VALUE         top
       On success, these system calls return 0.  On error, -1 is
       returned, and errno is set to indicate the error.
ERRORS         top
       EFAULT A pointer argument points to a location outside the
              accessible address space.

       EINVAL The value specified in resource is not valid; or, for
              setrlimit() or prlimit(): rlim-&gt;rlim_cur was greater than
              rlim-&gt;rlim_max.

       EPERM  An unprivileged process tried to raise the hard limit; the
              CAP_SYS_RESOURCE capability is required to do this.

       EPERM  The caller tried to increase the hard RLIMIT_NOFILE limit
              above the maximum defined by &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;nr_open (see
              proc(5))

       EPERM  (prlimit()) The calling process did not have permission to
              set limits for the process specified by pid.

       ESRCH  Could not find a process with the ID specified in pid.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>常见的参数：</p>
<pre class="line-numbers language-none"><code class="language-none">RLIMIT_AS&#x2F;RLIMIT_VMEM: 这两个资源表示的是同一个含义，都是只address space限制，可用内存用户地址空间最大长度，会影响到sbrk和mmap函数。
RLIMIT_STACK：栈的长度，默认一般是8K
RLIMIT_CORE：程序crash后生成的core dump文件的大小，如果为0将不生成对应的core文件。
RLIMIT_NOFILE：进程能够打开的最多文件数目，此限制会影响到sysconf的_SC_OPEN_MAX的返回值。
RLIMIT_NPROC：每个用户ID能够拥有的最大子进程数目，此限制会影响到sysconf的_SC_CHILD_MAX的返回值。
RLIMIT_NICE:对应进程的优先级nice值。
RLIMIT_SWAP：进程能够消耗的最大swap空间。
RLIMIT_CPU：CPU时间的最大值（秒单位），超过此限制后会发送SIGXCPU信号给进程。
RLIMIT_DATA：数据段的最大长度。默认为unlimited
RLIMIT_FSIZE：创建文件的最大字节长度。默认为ulimited
RLIMIT_MSGQUEUE：为posix消息队列可分配的最大存储字节数
RLIMIT_SIGPENDING：可排队的信号最大数量
RLIMIT_NPTS：可同时打开的伪终端数目
RLIMIT_RSS：最大可驻内存字节长度
RLIMIT_SBSIZE：单个用户所有套接字缓冲区的最大长度
RLIMIT_MEMLOCK：一个进程使用mlock能够锁定存储空间中的最大字节长度
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2024/01/20/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-5/">http://charliechen114514.github.io/2024/01/20/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/01/20/%E5%BA%93%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Logger%E5%BA%93/" title="库设计：一个简单的Logger库"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">库设计：一个简单的Logger库</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/23/TCP-IP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%EF%BC%8C2%EF%BC%8C3/" title="TCP&#x2F;IP 网络编程笔记——1，2，3"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-23</div><div class="title">TCP&#x2F;IP 网络编程笔记——1，2，3</div></div></a></div><div><a href="/2023/08/17/Unix-network-programming-Guidance/" title="Unix网络编程 - 1"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-17</div><div class="title">Unix网络编程 - 1</div></div></a></div><div><a href="/2023/08/19/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE/" title="Unix网络编程——导论与三种协议"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="title">Unix网络编程——导论与三种协议</div></div></a></div><div><a href="/2023/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BF%AE%E5%85%BB%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/" title="嵌入式C修养——前导"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-20</div><div class="title">嵌入式C修养——前导</div></div></a></div><div><a href="/2024/01/16/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-3/" title="重新学习Linux系统编程-3"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-16</div><div class="title">重新学习Linux系统编程-3</div></div></a></div><div><a href="/2024/01/15/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-2/" title="重新学习Linux系统编程-2"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="title">重新学习Linux系统编程-2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">高级进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-number">1.1.1.</span> <span class="toc-text">时间片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E7%BA%A6%E6%9D%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E7%BA%A6%E6%9D%9F%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">IO约束进程和处理器约束进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">抢占式调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CFS"><span class="toc-number">1.2.</span> <span class="toc-text">CFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%8A%9E%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">调整优先级的办法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%BA%B2%E5%92%8C%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">处理器的亲和性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">资源限制</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/20/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-5/" title="重新学习Linux系统编程-5"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重新学习Linux系统编程-5"/></a><div class="content"><a class="title" href="/2024/01/20/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-5/" title="重新学习Linux系统编程-5">重新学习Linux系统编程-5</a><time datetime="2024-01-20T07:30:50.000Z" title="发表于 2024-01-20 15:30:50">2024-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/20/%E5%BA%93%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Logger%E5%BA%93/" title="库设计：一个简单的Logger库"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="库设计：一个简单的Logger库"/></a><div class="content"><a class="title" href="/2024/01/20/%E5%BA%93%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Logger%E5%BA%93/" title="库设计：一个简单的Logger库">库设计：一个简单的Logger库</a><time datetime="2024-01-20T06:40:11.000Z" title="发表于 2024-01-20 14:40:11">2024-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/19/EffectiveModernCpp/" title="EffectiveModernCpp"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EffectiveModernCpp"/></a><div class="content"><a class="title" href="/2024/01/19/EffectiveModernCpp/" title="EffectiveModernCpp">EffectiveModernCpp</a><time datetime="2024-01-19T12:39:07.000Z" title="发表于 2024-01-19 20:39:07">2024-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/" title="重新学习Linux系统编程-4"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重新学习Linux系统编程-4"/></a><div class="content"><a class="title" href="/2024/01/19/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-4/" title="重新学习Linux系统编程-4">重新学习Linux系统编程-4</a><time datetime="2024-01-19T12:04:36.000Z" title="发表于 2024-01-19 20:04:36">2024-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/19/Linux%E6%BC%AB%E6%B8%B8%E5%90%88%E9%9B%86/" title="Linux漫游合集"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux漫游合集"/></a><div class="content"><a class="title" href="/2024/01/19/Linux%E6%BC%AB%E6%B8%B8%E5%90%88%E9%9B%86/" title="Linux漫游合集">Linux漫游合集</a><time datetime="2024-01-19T11:55:46.000Z" title="发表于 2024-01-19 19:55:46">2024-01-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>