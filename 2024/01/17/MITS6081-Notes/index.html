<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>MITS6081 Notes | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MIT 6.S081概述​        操作系统有很多不同的种类，其中一个就是对硬件的抽象。要知道硬件给予的接口一般都很原始，我们操作系统就是提供一个更加高级的接口为应用程序服务：比如说方便且具有可移植性的通过进程或者是文件系统等抽象（虚拟&#x2F;抽象）​        另一个重要的功能就是为许多应用程序提供复用硬件的能力（如你可以在一个操作系统中同时运行一个文本编辑器，录音机或者是多个数据库服务器等">
<meta property="og:type" content="article">
<meta property="og:title" content="MITS6081 Notes">
<meta property="og:url" content="http://charliechen114514.github.io/2024/01/17/MITS6081-Notes/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="MIT 6.S081概述​        操作系统有很多不同的种类，其中一个就是对硬件的抽象。要知道硬件给予的接口一般都很原始，我们操作系统就是提供一个更加高级的接口为应用程序服务：比如说方便且具有可移植性的通过进程或者是文件系统等抽象（虚拟&#x2F;抽象）​        另一个重要的功能就是为许多应用程序提供复用硬件的能力（如你可以在一个操作系统中同时运行一个文本编辑器，录音机或者是多个数据库服务器等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2024-01-17T02:28:48.000Z">
<meta property="article:modified_time" content="2024-01-17T02:32:17.562Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Operating System">
<meta property="article:tag" content="Assembly">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2024/01/17/MITS6081-Notes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MITS6081 Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-17 10:32:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MITS6081 Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-17T02:28:48.000Z" title="发表于 2024-01-17 10:28:48">2024-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-17T02:32:17.562Z" title="更新于 2024-01-17 10:32:17">2024-01-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MITS6081 Notes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MIT-6-S081"><a href="#MIT-6-S081" class="headerlink" title="MIT 6.S081"></a>MIT 6.S081</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        操作系统有很多不同的种类，其中一个就是对硬件的抽象。要知道硬件给予的接口一般都很原始，我们操作系统就是提供一个更加高级的接口为应用程序服务：比如说方便且具有可移植性的通过进程或者是文件系统等抽象（虚拟/抽象）<br>​        另一个重要的功能就是为许多应用程序提供复用硬件的能力（如你可以在一个操作系统中同时运行一个文本编辑器，录音机或者是多个数据库服务器等）值得注意的是，它们的运行之间互相并不干扰，这就是操作系统给上层提供的一种叫做“虚拟”的抽象（多路复用）我们把强调互不干扰这个方面功能，我们叫做隔离性；<br>​        另一方面，一些不相同的用户进程中文件的交流可能需要用到一些共享数据，这个就叫做共享能力。<br>​        进一步去想的我们的数据不是随时随地都可以被随意的共享，是我们用户需要共享数据时才会去共享，不想共享共享数据时就不去共享，我们称这实现这样功能的系统叫做安全权限或者是系统权限系统，即访问控制系统。接着，操作系统应该能为大多数应用软件至少提供硬件资源分配的能力，甚至还会去试着去提高程序的性能<br>​        我们尝试将计算机抽象成一个具有金字塔结构的一个系统，在系统的最底层则是硬件层，它可能包含了CPU，RAM，硬盘或者是网络收发器等硬件，而在最顶层可能用运行的是用户能够直观看到或者是潜在的一些应用软件，比如说文本编辑器VI，unix操作系统常用的编译器CC，或者是图形化的终端命令行shell等。这些用户进程下的这些应用程序所在的空间，它的运行空间，我们通常称为用户空间。那么，中间的这一层——介于硬件和用户软件的这一层——则是我们这本课程关心的重点，<br>​        这个层里面有一个内核，它是计算机资源的守护者。内核总是在开机时第一个运行，它帮助管理计算机的数据管理用户进程，并且有很多数据结构来帮助访问文件等数据结构。本门课程就是关注诸如如何管理用户进程，如何使用文件系统管理文件，如何用户层与内核层之间接口交互等问题。<br>​        内核当中有许多东西，我们首先说的就是内核：内核作为操作系统的核心，管理着众多底层的东西：我们首先说内核自身，他作为一个进程为内核服务进行管理，他管理着各个程序的内存分配。我们知道不同的进程要求吧不同的内存数量。内核的一项任务就是分配合理的内存。<br>​        内核还会作用于文件系统：我们知道文件系统分为多个逻辑部分。现在我们则是从文件管理的角度去理解他。换而言之，我们就是把文件视作数据和占据数据的内存。赋予一个名字并且管理他。通常的讲，我们的文件具有访问控制，决定谁，能够怎么用这样的文件。内核内部的访问控制权限将会决定之。<br>​        对于分时操作系统，每个进程可能由不同的用户运行，每个进程都有不同的访问权限等。一个成熟的操作系统还必须提供进程间的通信功能，换而言之，进程之间可以交换数据。诸如TCP/IP通信时的信息传递。一般的操作系统通过库函数来实现操作状态内核对底层硬件的一种调用。熟知Linux系统调用与库函数的人应该知道：</p>
<pre class="line-numbers language-none"><code class="language-none">int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        可以用来打开一个文件——他是一个系统调用。</p>
<p>亦或者</p>
<pre class="line-numbers language-none"><code class="language-none">write(int fd, const void* buffer, const size_t size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        用来向目标文件写入数据。</p>
<p>亦或者</p>
<pre class="line-numbers language-none"><code class="language-none">pid_t fork();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        开启一个Linux线程——他完全拷贝父线程的资源并且将程序起点定在开启线程的下一行。他们像是函数，但实际上又有所不同——他们跳进内核去了！</p>
<p>​        为什么书写这些东西是有趣而又有挑战的呢？答案是——因为我们准备去写其他人习以为常的环境！我们希望让我们的操作系统更有效率，更加可移植，更加的对于上层用户来讲是简单的。这需要我们具有一定的设计。</p>
<blockquote>
<p>Q &amp;&amp; A 我们的系统调用和普通函数有什么区别嘛（包括那些不涉及系统调用的库函数）</p>
<p>简单的讲——一般的函数不具备调用敏感硬件的能力，换而言之，没有任何关于内核的权限。想要使用底层的硬件就必须要向使用系统调用，意味着我们需要通过系统调用来操作敏感硬件。而在内核态，也就是通过修改PSW寄存器的FLAG描述位而进入内核态的程序才有权限。比如说可以直接任意的访问磁盘等</p>
</blockquote>
<p>​        另外，我们需要“即灵活”又“有一定约束”的控制程序，不让他们之间相互干扰。</p>
<blockquote>
<p>Q &amp;&amp; A 我们需要成为操作系统专家才能写程序嘛？</p>
<p>OF COURSE NOT，我们可以通过大量的书写，维护，调试程序慢慢建立对操作系统的认识，我们的日常书写可能不会跟操作系统打太多的交道。但是仍然值得一学来看看电脑究竟发生了什么</p>
</blockquote>
<p>​        下面，我们来尝试着运行一下MIT提供的教学代码：也就是xv6。</p>
<p>​        这里，我使用的平台是Windows11 + Ubuntu22.04 + QEMU + 20231015左右的xv6源码。</p>
<p>​        首先</p>
<pre class="line-numbers language-none"><code class="language-none">git clone http:&#x2F;&#x2F;github.com&#x2F;mit-pdos&#x2F;xv6-riscv.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>(By the way, 原来MIT给出的代理使用的是git代理，这里鄙人手动换了一下，切成这里的http代理加速，具体需求按照自己的环境决定)</code></p>
<p>​        其次，下好Qemu：</p>
<p><img src="image-20231015205403523.png" alt="image-20231015205403523"></p>
<p>​        这里是截至到2023年10月15号，鄙人在<a target="_blank" rel="noopener" href="https://www.qemu.org/download/#linux">Download QEMU - QEMU</a>找到的instruction。我自己是为了节约时间，选择了：</p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt-get install qemu-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        安装结束后，当你尝试：</p>
<pre class="line-numbers language-none"><code class="language-none">cd &#x2F;yourpath&#x2F;xv6-riscv
make qemu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        意外发生：那就是一般而言，我们的电脑没有支持RISC-V指令集的GNU编译工具链，所以——</p>
<pre class="line-numbers language-none"><code class="language-none">apt search binutils  |grep binutils-riscv64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        一下找到3个：（笔者这里已经安装结束，故给出【已安装】提示）</p>
<p><img src="image-20231015205743938.png" alt="image-20231015205743938"></p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt install binutils-riscv64-linux-gnu
sudo apt install binutils-riscv64-linux-gnu-dbg
sudo apt install binutils-riscv64-unknown-elf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        以及在这后：还会存在一个报错，那就是没有RISC-V指令集的GCC编译器：</p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt install gcc-10-riscv64-linux-gnu
cd &#x2F;usr&#x2F;bin # 懒癌是这样的
sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-unknown-elf-gcc #<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        现在，我们就软链接了<code>riscv64-unknown-elf-gcc</code>，不出意外的话，不会报错了</p>
<pre class="line-numbers language-none"><code class="language-none">make qemu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20231015210125513.png" alt="image-20231015210125513"></p>
<p>​        结束。</p>
<h2 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h2><p>​        我们来看看这些文件，他们可以在我们的Linux编程底下同样的可以使用之：举个例子。</p>
<p>TASK: 利用xv6下的kernel, user文件夹下的函数，构建一个copy.c，当我们保证在64个字节大小的最大输入范围下，实现echo功能：（提示：在UNIX操作系统中，往往会选择0作为程序标准输入流，1作为程序标准输出流，当然这不一定）</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; copy.c: copy the stdin to the stdout
#include &quot;..&#x2F;kernel&#x2F;types.h&quot;
#include &quot;..&#x2F;user&#x2F;user.h&quot;

int main()
&#123;
    char buf[64];

    while(1)&#123;

        int n &#x3D; read(0, buf, 64);
        &#x2F;&#x2F; get less or none bins, quit then
        if(n &lt;&#x3D; 0)
            break;
        &#x2F;&#x2F; else output to the shell 
        write(1, buf, n); &#x2F;&#x2F; must be n, as a param to discribe
                        &#x2F;&#x2F; how much letter should be written
    &#125;

    exit(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们手撸一个Cmake让他跑起来：</p>
<pre class="line-numbers language-none"><code class="language-none"># this build files try to use the kernel written by
# MIT , kernel code is provided in https:&#x2F;&#x2F;github.com&#x2F;mit-pdos&#x2F;xv6-riscv

cmake_minimum_required(VERSION 3.20)
project(OSEXP VERSION 1.0)
add_executable(OSEXP copy.c)
target_include_directories(OSEXP PUBLIC ..&#x2F;kernel&#x2F; ..&#x2F;user&#x2F;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        结果显然不错——就是有最大长度让人不太舒服</p>
<p><img src="image-20231015213151774.png" alt="image-20231015213151774"></p>
<p>​        现在我们再看看这几行代码——</p>
<p>​        当我们引入头文件结束之后，我们程序进到程序入口Main这里，执行到：</p>
<pre class="line-numbers language-none"><code class="language-none">char buf[64];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们在栈上开辟了64个字节大小的内存，</p>
<pre class="line-numbers language-none"><code class="language-none">while(1)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这里我们实现了除非接受到终止信号（Ctrl + C），程序将会永远运行下去， except for…埋伏笔</p>
<pre class="line-numbers language-none"><code class="language-none">int n &#x3D; read(0, buf, 64);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这里的read很朴实，先前的提示给过，结合POSIX标准（Portable Opreate System Interface of uniX），我们的read都统一的设定为这样的函数描述：</p>
<pre class="line-numbers language-none"><code class="language-none">read(int from_where, void* what_buf, size_t bufSize);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        只要提供给文件描述符（将这个分发的数字抽象成文件自身），数据块及其大小，就可以从标准输入流中读取数据了。读取的时候，可能会出现异常或者是没有输入（n &lt;= 0）的情况，那就：</p>
<pre class="line-numbers language-none"><code class="language-none">break; &#x2F;&#x2F; Process get an error and it appears and is dealed in Software Level <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        否则，那就直接向标准输出，也就是我们的终端，返回我们刚刚送进去的一切。</p>
<blockquote>
<p>Ｑ＆＆Ａ：如果我们发疯，我们明明只有64个bytes却让他读65个，会怎么样</p>
<p>答案是：UB，哈哈。可能是程序计数器的内容，或者是栈上其他的什么内容，参数。。。什么都可能是！总而言之，小心，再小心的设置边界参数，这里没人会帮助你检查的！</p>
</blockquote>
<p>我们发现，对于操作系统和更底层的硬件来讲，他们丝毫不关心这些二进制流（一串有意义的01）意味着什么，如何解释是上面的事情，他们只是老实的搬运字节，设置字节等等。</p>
<p>TASK：尝试使用kernel,user, fcntl下的open和write函数打开文件并且进行读写。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;kernel&#x2F;types.h&quot;
#include &quot;kernel&#x2F;fcntl.h&quot;
#include &quot;user&#x2F;user.h&quot;

int main()
&#123;
    int fd &#x3D; open(&quot;output.txt&quot;, O_CREATE | O_WRONLY);
    write(fd, &quot;Oh my Godness!\n&quot;, 16);
    

    exit(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对了，这个时候就可以考虑不使用cmake了，我们可以把他放进qemu上实际跑一下。方法是：</p>
<ol>
<li><p>把我们写的.c文件移至user文件夹下，修改Makefile文件的这些部分：</p>
<p><img src="image-20231015223804516.png" alt="image-20231015223804516"></p>
</li>
</ol>
<p>​        可以看到光标部分添加了一行</p>
<pre class="line-numbers language-none"><code class="language-none">$U&#x2F;_&#123;srcname&#125;\<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这里表示的就是把我们的用户代码添加进来的意思。现在，执行</p>
<pre class="line-numbers language-none"><code class="language-none">make qemu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        然后ls，发现系统内多存在了一个文件，那就是我们的exp2文件，运行之，啥现象没有！</p>
<pre class="line-numbers language-none"><code class="language-none">exp2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        但是再次ls，发现多出来我们的output.txt了，</p>
<pre class="line-numbers language-none"><code class="language-none">$cat output.txt
&gt;&gt;&gt; Oh my Godness!
$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        可以注意到：内核自己维护了一张表——他包含了每个进程中对不同文件的编号。所以，对于不同的进程，相同标号的文件有的时候可能是指向一个不一样的文件。只是恰巧文件编号相同了罢了</p>
<p>​        下面提到了shell，shell作为字符终端有着广泛的应用，在UNIX系统操作上，我们可以用之完成批处理等任务。或者是执行程序：</p>
<pre class="line-numbers language-none"><code class="language-none">$ ls<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们发现程序被列出来了，它实际上是去枚举当前目录的文件，并且打印在终端上。shell还允许你重定向IO，换而言之，你可以将结果输出到其他地方</p>
<pre class="line-numbers language-none"><code class="language-none">$ ls &gt; out.txt
$ cat out.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        发现跟终端输出完全一样</p>
<blockquote>
<p>Q$$A 编译器如何处理对涉及到系统调用的代码？</p>
<p>答案是：事实上，我们需要调用系统调用的地方，本质上都是使用汇编写的（执行陷入指令），这里，在RISC-V下有一条汇编指令叫做ecall，他将程序的控制权转交内核。换而言之，这里实际上跳转进入的不是一个用C写的代码段，而使用特有的机器指令写的代码段。编译器只负责翻译添加将一些需要的参数传递进入需要的寄存器的指令就结束他的工作</p>
</blockquote>
<p>TASK：尝试使用并发编程：fork()</p>
<pre class="line-numbers language-none"><code class="language-none">#include&quot;kernel&#x2F;types.h&quot;
#include&quot;user&#x2F;user.h&quot;

int main()
&#123;
	int pid;

	pid &#x3D; fork();

	printf(&quot;fork returns %d\n&quot;,pid);

	if(pid &#x3D;&#x3D; 0)
	&#123;
		printf(&quot;Message from the child\n&quot;);
	&#125;
	else
	&#123;
		printf(&quot;Message from the parent\n&quot;);
	&#125;

	exit(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20231015230049104.png" alt="image-20231015230049104"></p>
<p>​        结果不太雅观——毕竟混在一起了。注意到，我们的fork是这样工作的</p>
<ul>
<li>在主线程中，调用fork返回给自身的线程是一个大于0的整数</li>
<li>对于子线程则就是0，我们就是在代码里实现分支的控制的</li>
<li>出现乱码的原因是——他几乎是真正并发的输出内容</li>
</ul>
<p>​        下面展示的是exec的作用：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;kernel&#x2F;types.h&quot;
#include &quot;user&#x2F;user.h&quot;

int main()
&#123;
	char* argv[] &#x3D; &#123;&quot;echo&quot;, &quot;this&quot;, &quot;is&quot;, &quot;echo&quot;, 0&#125;;

	exec(&quot;echo&quot;, argv);

	printf(&quot;exec failed!\n&quot;);
	
	exit(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20231015231154779.png" alt="image-20231015231154779"></p>
<p>​        我们发现，程序被替换了！exp4在进程中被替换成了argv[0]的echo，换而言之，执行的是</p>
<pre class="line-numbers language-none"><code class="language-none">echo this is echo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个指令。exec的作用就是将将要执行的进程替换掉自身，然后执行那个替换的线程去，用新程序覆盖这个程序的上下文和内存空间</p>
<p>​        对了，最后的那个0，就是\0的意思，终止符。这是因为exec要用，要知道指令参数停在哪个位置。不然就会越界了！</p>
<p>​        所以shell是如何调用命令的呢？fork一个线程然后调用exec指令来开真正的新线程</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;kernel&#x2F;types.h&quot;
#include &quot;user&#x2F;user.h&quot;

int main()
&#123;
	int pid, status;
	
	pid &#x3D; fork();

	if(pid &#x3D;&#x3D; 0)
	&#123;
		char* argv[] &#x3D; &#123;&quot;echo&quot;, &quot;THIS&quot;, &quot;IS&quot;, &quot;ECHO&quot;, 0&#125;;
		exec(&quot;echo&quot;, argv);
		printf(&quot;FAILED TO EXECUTE THE ECHO\n&quot;);
	&#125;else&#123;
		printf(&quot;parents are waiting\n&quot;);
		wait(&amp;status);
		printf(&quot;Get the child process exits with the status:&gt; %d&quot;, status);
	&#125;

	exit(0);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20231015232750315.png" alt="image-20231015232750315"></p>
<p>​        这里，如果子程序执行失败，就会把错误码1返回回来，他会交给主线程wait里，上报到操作系统提示出错了。UNIX中认为凡是退出码是0的都是正常退出的！</p>
<p>​        by the way，close这个函数指的是释放系统资源，这里指得就是文件描述符分配表，那些不close的文件会占着表资源不放，从而使后面的调用open的文件描述符返回的是下一个index。</p>
<p>现在，我们开始更多的讨论操作系统更加具体的特性</p>
<h2 id="ISOLATION-隔离性"><a href="#ISOLATION-隔离性" class="headerlink" title="ISOLATION:隔离性"></a>ISOLATION:隔离性</h2><p>​        操作系统必须给每一个进程提供一个较为独立的环境。换而言之，就是相互之间不要相互影响。我们求解质数的程序不要去影响其他程序，操作系统应该可以正确的处理应用程序和应用程序之间，应用程序和系统程序之间的区别。</p>
<p>​        我们想一下：假使我们的CPU不支持系统层面的并发。那么，我们可能就会发现电脑变得很笨——他没办法同时运行多个程序。万一有一个程序，无意或者是有意的占据CPU很久，那么，电脑就会瘫痪。</p>
<p>​        操作系统有义务，在——无论是怎样的应用程序，都必须周期性的，强迫的扔下占为己有的CPU，然后切换到别的程序运行。这样，在高频率的CPU工作下，我们就会看到貌似所有的程序都在同时运行。</p>
<p>​        在空间上，如果我们不对之做虚拟的映射（操作系统预先的排布），可能就会出现两个程序互相侵占对方空间的情况——电脑开着开着就挂了！</p>
<p>​        UNIX提供了硬件的抽象。方法是我们只需要使用这些接口即可。让我们可以实现一种强隔离。我们的软件使用的是被抽象的CPU来完成工作。这样，操作系统实现了硬件复用功能。</p>
<blockquote>
<p>Q&amp;&amp;A：我们的进程是不是实际上分用CPU，即：一个进程用CPU的一个部分，另一个进程使用另一部分。或者是对于多核系统则是使用不同的核？</p>
<p>是的，当我们运行大于核数量的进程时，则会在时间上分配时间片，换而言之，一个进程只能运行某个时间长度就会被停止换上另一个，随后在切换回来。好像他们在同时运行那样。</p>
</blockquote>
<p>​        应用程序的进程是由text, global data等部分组成，他们共同访问抽象的内存，而不是直接访问物理的内存。操作系统提供了转换。</p>
<p>​        文件则是对磁盘块的抽象，正如同我们只能操作文件，而不是直接操纵磁盘空间。操作系统维护映射关系。防止磁盘块和磁盘块之间发生冲突，保证两者相互不干扰。</p>
<blockquote>
<p>Q&amp;&amp;A：是否会有一个更复杂的内核试着重新调度同一个核的进程以减少缓存缺失</p>
<p>是的，存在缓存亲和性这个东西，操作系统尝试避免缓存缺失或者类似的事情来优化性能。</p>
<p>Q&amp;&amp;A：xv6中哪里可以查阅操作系统复用进程</p>
<p>proc.c文件。但是那是之后会详细展开。那是最接近的</p>
</blockquote>
<p>​        操作系统必须具有防御性质的功能，换而言之，防止恶意程序毁坏系统并处理之，应用程序不应该打破隔离，而是在划定的范围内运作。</p>
<p>​        一个重要的假设就是：所有的应用程序都是有恶意的，这样就可以迫使我们设计的安全。</p>
<p>​        实现强隔离的方式之一就是硬件支持：这里有两种方法：</p>
<ol>
<li>用户内核模式，也就是kernel模式。当然在RISC-V这又叫管理者模式，一回事情。</li>
<li>另一种是页表，虚拟内存</li>
</ol>
<p>​        所有目前的处理器都支持这样的两个方式。</p>
<h2 id="Kernel-mode-内核模式"><a href="#Kernel-mode-内核模式" class="headerlink" title="Kernel mode 内核模式"></a>Kernel mode 内核模式</h2><p>​        处理器支持两种模式：用户模式和内核模式。当处在内核模式的时候，CPU可以执行特权指令和非特权指令。而在用户模式则指可以执行非特权指令。</p>
<p>​        非特权指令包括add, sub ,mul等运算指令，或者是跳转流（jmp），或者是常见的分支结构等等。</p>
<p>​        特权指令则是引入直接硬件操作，包括直接配置页表寄存器，禁止时钟中断等跟硬件密切相关的指令。当用户想要直接运行特权指令，处理器不会执行。除非向操作系统申请并且同意。</p>
<blockquote>
<p>Q&amp;&amp;A：如何判断当下的处理器处于的是内核模式还是用户模式?</p>
<p>存在硬件支持! 处理器有一个Flag寄存器,其中有一位标志位记录之:用户模式是1,内核模式是0(一般而言).所以当处理器解码指令的时候就会检查操作码.当发现此位是1而却要执行特权指令,就会发出拒绝的信号.</p>
</blockquote>
<p>​        当然RISC-V还有第三种:机器模式,但是这里先不展开</p>
<blockquote>
<p>Q&amp;&amp;A 用户可以直接绕过操作系统嘛?</p>
<p>额,一般不能.</p>
<p>Q&amp;&amp;A BIOS呢?</p>
<p>答案是,计算机执行的第一段代码就是跟BIOS相关的,他指引着操作系统的位置.一般而言,这段代码被写入专门的BIOS芯片,作只读处理(ROM), 所以一般认为是没有恶意的!</p>
<p>Q&amp;&amp;A：那既然设置为特权位这个指令就是一个特权指令,用户程序如何满足自己需要特权指令的需求呢?</p>
<p>中断:换而言之,交给操作系统判断是否可以执行,随后才会允许程序”内陷”到内核态工作.</p>
</blockquote>
<h2 id="Page-Table页表"><a href="#Page-Table页表" class="headerlink" title="Page Table页表"></a>Page Table页表</h2><p>​        页表的工作就是将虚拟内存映射到真实的物理内存.其基本思想就是给每一个进程提供自己的页表,使用这个方式,进程只能访问它的页表显示的物理内存,这样只要设置页表的映射的物理内存相互不相交即可防止一个进程干涉另一个进程的物理内存.这样就提供了一个强隔离的物理内存布局.</p>
<p><img src="image-20231018220231082.png" alt="image-20231018220231082"></p>
<p>​        这里有一个进入内核方法:对于RISC-V,就是ecall指令</p>
<pre class="line-numbers language-none"><code class="language-none">ecall &lt;n&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这就是应用程序想要访问的系统调用的编号.进入内核的一个由内核控制的特动区域.如:调用fork,我们没有直接使用内核的fork,而是使用的系统调用编号, 如syscall,传递给a0,再去调用内核的fork.</p>
<blockquote>
<p>Q&amp;&amp;A 内核在哪里决定程序可以调用特定的内核系统调用呢?</p>
<p>在内核侧, 我们的内核去检查是不是应用程序该工作的地方等等.</p>
<p>Q&amp;&amp;A 操作系统如何从程序那里夺回控制权</p>
<p>存在一个定时器,到点回收,然后分配给其他进程</p>
<p>Q&amp;&amp;A 为啥用C实现操作系统</p>
<p>人话: C语言容易控制硬件,很方便的语言.</p>
</blockquote>
<h2 id="TCB（trust-computing-base）可信任编程基础"><a href="#TCB（trust-computing-base）可信任编程基础" class="headerlink" title="TCB（trust computing base）可信任编程基础"></a>TCB（trust computing base）可信任编程基础</h2><p>​        必须正确，不能有bug，我们就是这样认为内核。内核必须假设应用程序是有恶意的，这样的思维就是安全思维。</p>
<p>​        内核根据代码量和管理的事情的多少分为宏内核和微内核。宏内核具有大量的代码，出现严重的bug的可能比较大。好的地方就是在于存在实现不同的子模块可以紧密联系带来很高的性能。比如说Linux。微内核则是可能的减少内核代码。总言之就是让bug总是在操作系统之外，但是性能会比较差，原因就是系统调用次数增加（如文件系统会频繁的调用内核）。</p>
<p>​        xv6是宏内核。下面简单说一下xv6文件构成。</p>
<p>​        结合上面所说的，我们的代码分为内核代码，用户代码：</p>
<p><img src="image-20231018221850358.png" alt="image-20231018221850358"></p>
<p>​        kernel下面有这样的一些文件：</p>
<pre class="line-numbers language-none"><code class="language-none">Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        2023&#x2F;10&#x2F;15     19:44           3478 bio.c
-a----        2023&#x2F;10&#x2F;15     19:44            263 buf.h
-a----        2023&#x2F;10&#x2F;15     19:44           3991 console.c
-a----        2023&#x2F;10&#x2F;15     19:44           6315 defs.h
-a----        2023&#x2F;10&#x2F;15     19:44            819 elf.h
-a----        2023&#x2F;10&#x2F;15     19:44            624 entry.S
-a----        2023&#x2F;10&#x2F;15     19:44           4089 exec.c
-a----        2023&#x2F;10&#x2F;15     19:44            125 fcntl.h
-a----        2023&#x2F;10&#x2F;15     19:44           3791 file.c
-a----        2023&#x2F;10&#x2F;15     19:44           1039 file.h
-a----        2023&#x2F;10&#x2F;15     19:44          17008 fs.c
-a----        2023&#x2F;10&#x2F;15     19:44           1872 fs.h
-a----        2023&#x2F;10&#x2F;15     19:44           1737 kalloc.c
-a----        2023&#x2F;10&#x2F;15     19:44            908 kernel.ld
-a----        2023&#x2F;10&#x2F;15     19:44           3087 kernelvec.S
-a----        2023&#x2F;10&#x2F;15     19:44           5956 log.c
-a----        2023&#x2F;10&#x2F;15     19:44           1277 main.c
-a----        2023&#x2F;10&#x2F;15     19:44           2260 memlayout.h
-a----        2023&#x2F;10&#x2F;15     19:44            764 param.h
-a----        2023&#x2F;10&#x2F;15     19:44           2725 pipe.c
-a----        2023&#x2F;10&#x2F;15     19:44            955 plic.c
-a----        2023&#x2F;10&#x2F;15     19:44           2305 printf.c
-a----        2023&#x2F;10&#x2F;15     19:44          15076 proc.c
-a----        2023&#x2F;10&#x2F;15     19:44           3589 proc.h
-a----        2023&#x2F;10&#x2F;15     19:44            988 ramdisk.c
-a----        2023&#x2F;10&#x2F;15     19:44           7252 riscv.h
-a----        2023&#x2F;10&#x2F;15     19:44            852 sleeplock.c
-a----        2023&#x2F;10&#x2F;15     19:44            275 sleeplock.h
-a----        2023&#x2F;10&#x2F;15     19:44           2747 spinlock.c
-a----        2023&#x2F;10&#x2F;15     19:44            208 spinlock.h
-a----        2023&#x2F;10&#x2F;15     19:44           2473 start.c
-a----        2023&#x2F;10&#x2F;15     19:44            314 stat.h
-a----        2023&#x2F;10&#x2F;15     19:44           1519 string.c
-a----        2023&#x2F;10&#x2F;15     19:44            836 swtch.S
-a----        2023&#x2F;10&#x2F;15     19:44           3616 syscall.c
-a----        2023&#x2F;10&#x2F;15     19:44            507 syscall.h
-a----        2023&#x2F;10&#x2F;15     19:44           8993 sysfile.c
-a----        2023&#x2F;10&#x2F;15     19:44           1198 sysproc.c
-a----        2023&#x2F;10&#x2F;15     19:44           3990 trampoline.S
-a----        2023&#x2F;10&#x2F;15     19:44           5576 trap.c
-a----        2023&#x2F;10&#x2F;15     19:44            244 types.h
-a----        2023&#x2F;10&#x2F;15     19:44           4876 uart.c
-a----        2023&#x2F;10&#x2F;15     19:44           3582 virtio.h
-a----        2023&#x2F;10&#x2F;15     19:44           8991 virtio_disk.c
-a----        2023&#x2F;10&#x2F;15     19:44          10707 vm.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        用户代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        2023&#x2F;10&#x2F;15     19:44            659 cat.c
-a----        2023&#x2F;10&#x2F;15     19:44            315 echo.c
-a----        2023&#x2F;10&#x2F;15     19:44            808 forktest.c
-a----        2023&#x2F;10&#x2F;15     19:44           2130 grep.c
-a----        2023&#x2F;10&#x2F;15     19:44           8128 grind.c
-a----        2023&#x2F;10&#x2F;15     19:44           1158 init.c
-a----        2023&#x2F;10&#x2F;15     19:44            441 initcode.S
-a----        2023&#x2F;10&#x2F;15     19:44            271 kill.c
-a----        2023&#x2F;10&#x2F;15     19:44            302 ln.c
-a----        2023&#x2F;10&#x2F;15     19:44           1646 ls.c
-a----        2023&#x2F;10&#x2F;15     19:44            373 mkdir.c
-a----        2023&#x2F;10&#x2F;15     19:44           2113 printf.c
-a----        2023&#x2F;10&#x2F;15     19:44            368 rm.c
-a----        2023&#x2F;10&#x2F;15     19:44           8830 sh.c
-a----        2023&#x2F;10&#x2F;15     19:44           1103 stressfs.c
-a----        2023&#x2F;10&#x2F;15     19:44           2017 ulib.c
-a----        2023&#x2F;10&#x2F;15     19:44           1768 umalloc.c
-a----        2023&#x2F;10&#x2F;15     19:44           1072 user.h
-a----        2023&#x2F;10&#x2F;15     19:44            632 user.ld
-a----        2023&#x2F;10&#x2F;15     19:44          64992 usertests.c
-a----        2023&#x2F;10&#x2F;15     19:44            688 usys.pl
-a----        2023&#x2F;10&#x2F;15     19:44            888 wc.c
-a----        2023&#x2F;10&#x2F;15     19:44            248 zombie.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        至于mkfs就是<code>make file system</code>的意思，我们每次编译运行的时候都会生成一个空的镜像文件系统文件</p>
<pre class="line-numbers language-none"><code class="language-none">Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
-a----        2023&#x2F;10&#x2F;15     19:44           6610 mkfs.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        编译是这样的：proc.c被GCC编译成proc.S在被汇编器编译成二进制文件。其他同理</p>
<p>​        QEMU是如何模拟RISC-V的呢？答案是，使用C模拟，使用</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">for(;;)&#123;
	read_instructions;
    decode_instructions;
    execute_instructions;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        就是这样。模拟一切特权和非特权指令。</p>
<p>​        我们下面尝试一下使用gdb调试，我们后面会通过这样的方式来查阅运行时发生了什么。</p>
<p>​        我们这里使用的是通用的riscv64-unknown-elf-gdb，这里给出安装方式</p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt-get install libncurses5-dev python2 python2-dev texinfo libreadline-dev
# 从清华大学开源镜像站下载gdb源码(约23MB)
wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gnu&#x2F;gdb&#x2F;gdb-13.1.tar.xz
# 解压gdb源码压缩包
tar -xvf gdb-13.1.tar.xz
# 进入gdb源码目录
cd gdb-13.1
mkdir build &amp;&amp; cd build
# 配置编译选项，这里只编译riscv64-unknown-elf一个目标文件
..&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local --target&#x3D;riscv64-unknown-elf --enable-tui&#x3D;yes
# 在上面一行编译配置选项中，很多其他的文章会配置一个python选项
# 但我在尝试中发现配置了python选项后后面的编译过程会报错，不添加python选项则没有问题

# 开始编译，这里编译可能消耗较长时间，具体时长取决于机器性能
make -j$(nproc)
# 编译完成后进行安装
sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none"># 测试一下是否安装成功
riscv64-unknown-elf-gdb -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="image-20231018234732892.png" alt="image-20231018234732892"></p>
<p>​        对了，这里需要：</p>
<pre class="line-numbers language-none"><code class="language-none">To enable execution of this file add
	add-auto-load-safe-path &#x2F;home&#x2F;charliechen114514&#x2F;.config&#x2F;gdb&#x2F;.gdbinit
line to your configuration file &quot;&#x2F;home&#x2F;charliechen114514&#x2F;.config&#x2F;gdb&#x2F;gdbinit&quot;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        这样的输出，注意，这里结合自己的位置和文件添加对应的<code>add-auto-load-safe-path</code>。</p>
<p>​        下面，就可以开始调试了：在我们的xv6源码顶层目录，也就是我们先前输入make qemu的那一层目录下，这次我们输入</p>
<pre class="line-numbers language-none"><code class="language-none">make CPUS&#x3D;1 qemu-gdb <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        新开一个终端，我们可以直接在同级目录下：</p>
<pre class="line-numbers language-none"><code class="language-none">riscv64-unknown-elf-gdb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20231018235106056.png" alt="image-20231018235106056"></p>
<p>​        然后你会发现，gdb就会等待你的输入，我们为了研究程序如何进入enrty，打一个断点</p>
<p>​        源汇编程序：</p>
<pre class="line-numbers language-none"><code class="language-none">0000000080000000 &lt;_entry&gt;:
    80000000:	00009117          	auipc	sp,0x9
    80000004:	89013103          	ld	sp,-1904(sp) # 80008890 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;
    80000008:	6505                	lui	a0,0x1
    8000000a:	f14025f3          	csrr	a1,mhartid
    8000000e:	0585                	addi	a1,a1,1
    80000010:	02b50533          	mul	a0,a0,a1
    80000014:	912a                	add	sp,sp,a0
    80000016:	078000ef          	jal	ra,8000008e &lt;start&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        打上：</p>
<pre class="line-numbers language-none"><code class="language-none">b _entry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20231018235254016.png" alt="image-20231018235254016"></p>
<p>​        断点成功，输入c就会运行到_entry上，si表示的是执行下一条指令。</p>
<p>​        我们的机器现在在机器模式，马上他就会在内核模式，打一个断点在main那里：</p>
<pre class="line-numbers language-none"><code class="language-none">b main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20231018235605072.png" alt="image-20231018235605072"></p>
<p>​        我们的机器就会停在这里</p>
<p><img src="image-20231018235714429.png" alt="image-20231018235714429"></p>
<p>​        输入layout split获得上面那样的界面，输入n来让自己一步走一个C语言代码</p>
<pre class="line-numbers language-none"><code class="language-none">consoleinit();
printfinit();
printf(&quot;\n&quot;);
printf(&quot;xv6 kernel is booting\n&quot;);
printf(&quot;\n&quot;);
kinit();         &#x2F;&#x2F; physical page allocator
kvminit();       &#x2F;&#x2F; create kernel page table
kvminithart();   &#x2F;&#x2F; turn on paging
procinit();      &#x2F;&#x2F; process table
trapinit();      &#x2F;&#x2F; trap vectors
trapinithart();  &#x2F;&#x2F; install kernel trap vector
plicinit();      &#x2F;&#x2F; set up interrupt controller
plicinithart();  &#x2F;&#x2F; ask PLIC for device interrupts
binit();         &#x2F;&#x2F; buffer cache
iinit();         &#x2F;&#x2F; inode table
fileinit();      &#x2F;&#x2F; file table
virtio_disk_init(); &#x2F;&#x2F; emulated hard disk
userinit();      &#x2F;&#x2F; first user process
__sync_synchronize();
started &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​                然后就开始我们的第一个进程了</p>
<h2 id="Page-Tables-and-Virtual-Memory"><a href="#Page-Tables-and-Virtual-Memory" class="headerlink" title="Page Tables and Virtual Memory"></a>Page Tables and Virtual Memory</h2><p>​        我们知道虚拟内存是指使用一系列方式将之映射至物理地址。我们的这一映射实现了物理内存的隔离，很简单，只需要保证段基址的映射是互斥的即可！</p>
<p>​        我们只需要正确的设置页表就可以实现进程的强隔离。这样就可以有效的防止进程之间的干扰。举个例子，我们在执行一个A(ADR 3000-4000)程序的时候，代码中可能有一段：</p>
<pre class="line-numbers language-none"><code class="language-none">ld ax, 1000
sd $7, (ax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        坏了，一下子写如其他程序去了。这下怎么办？</p>
<p>​        办法1：使用地址空间(Address space)：我们给每个进程都独立的分配一段空间。他们是从0开始到某一个大小…</p>
<p><img src="image-20231027221831276.png" alt="image-20231027221831276"></p>
<pre class="line-numbers language-none"><code class="language-none">ld ax, 1000
sd $7, (ax)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        我们让之变成自己空间的1000，然后在映射到真实的物理地址上去。</p>
<blockquote>
<p>Q&amp;&amp;A:在物理空间上就有有限的空间，我们是否需要设置虚拟空间的最大值？</p>
<p>答案是，不需要，两者没有直接的关系！</p>
<p>Q&amp;&amp;A:当我们的机器上运行了过多的程序的时候，是不是意味着物理空间还是会被耗尽，尽管虚拟空间可以满足之</p>
<p>是的，我们的进程会去分配一个大的页表。事实上，再Lab2的查询当前空余空间的时候，我们看到了kalloc函数就会检查进程的页表，对于存在合适大小的空间时则会返回这个空间的地址，若是没有，则会返回空指针。</p>
</blockquote>
<p>​        如何实现单个物理内存的复用呢？答案就是使用页表。这是硬件支持的，由处理器或内存管理单元支持的。CPU执行的任何指令，如</p>
<pre class="line-numbers language-mips" data-language="mips"><code class="language-mips">$d $7, (a0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这里我们使用的任何地址都是虚拟地址，这些虚拟地址在送往IP寻址的时候总是会先经过MMU转换得到真实的地址才会进一步处理。</p>
<p><img src="image-20231102164045398.png" alt="image-20231102164045398"></p>
<p>​        页表这样的映射会存在内存当中，CPU也会由一些内存指出物理地址的页表在哪里，从而方便查找。CPU会告诉MMU这样的页表在哪里（SATP寄存器）。</p>
<blockquote>
<p>Q&amp;&amp;A:MMU只是做转换但是不会做保存吗</p>
<p>对，只是这样</p>
</blockquote>
<p>​        每个应用程序都会拥有自己的页表，当我们执行一个应用程序的时候，SATP就会指向这个进程的页表，也就是说，cat, shell等程序的页表会在他们执行的时候被加载。</p>
<blockquote>
<p>Q&amp;&amp;A: SATP这个寄存器应当是写在内核的，对吗？</p>
<p>正确的，只有内核特权级的代码才有权力改变他。用户程序不可以，因为这样会违反操作系统的隔离性。写入或者是读取SATP是一个特权指令</p>
</blockquote>
<p>​        结合地址寄存器是64位的（我们在讨论64位的操作系统！），显然，我们可以有<code>&#123;2^64&#125;</code>个地址，那么，假使我们是对每一个字节进行映射。。。嘿！那太荒唐了，这个表自身就要至少跟系统的内存一样大！所以事情不应该是这样的。答案是——不是对字节进行映射而是对页表</p>
<p>​        我们<strong>将连续的一系列内存</strong>打包，给他们赋予一个页的称号。在RISC-V下，一个页4KB，也就是4096个字节。几乎所有的寄存器都是支持这样的页大小。现在，我们可以将虚拟地址表示两个部分组成的量——一个是页表号（Index），另一个就是Offset，换而言之就是页表内部的偏移。不过可以注意的是，CPU自身使用的虚拟地址位数只有39位，也就是大概512GB。而对于使用真实的物理地址的寄存器也只会使用56位，12位描述段偏移（Offset, 2^12 = 4096B = 4KB），44位则是存储页标号</p>
<blockquote>
<pre><code>     在这个设计中虚拟内存和物理内存的位数是不一样的，虚拟内存是39位，前27位映射物理页面，后12位表示页面偏移，而物理内存是56位，前44位表示页面，后12位表示偏移
</code></pre></blockquote>
<p>​        但是,使用单机页表,页表还是会很大, 每一个进程都会持有一个巨大的页表,那么,我们就继续贯彻这一使用映射表的原则,进行多级页表的处理</p>
<p>​        下面我们来看看最后的十个位:</p>
<p>​        V:Valid,当这一位被设置的时候,就会说明这个PTE(Page Table Entry)是可以使用的,我们可以使用它来进行转换,如果是0,那就会告知之没有必要继续使用这个PTE,也就是说这个页表是被废弃的.</p>
<p>​        R与W:分别描述了这个页表是否可以书写或者是看这个页表可不可以读取</p>
<blockquote>
<p>Q&amp;&amp;A:三级页表是如何工作的,他如何取到实际物理地址</p>
<p>逐步追寻PPN指向的页表然后查找到最终的44位实际物理地址.</p>
</blockquote>
<p><img src="image-20231102170938201.png" alt="image-20231102170938201"></p>
<p>​        重新阐述一下他是如何工作的:我们首先查找到虚拟地址,将之划分为9,9,9,12,其他位.9,9,9代表了页表在哪里,第一个页表,也就是顶级的页表由SATP寄存器指出,L2只是告知PPN,这个PPN描述了下一级的页表的地址,至于下一级页表的Index还是由虚拟地址给出.直到我们到达了最低层的页表,他直接描述了我们的物理地址.我们就这样减少了页表的内存大小,后面的OFFSET在这里全部置0了,这就告诉我们页表的物理地址是4K对齐的,他总是4K的倍数</p>
<p>​        如果硬件发现页表中的映射存在问题则会返回一个页表错误(page fault),操作系统会更新页表然后重新加载页表.</p>
<p><img src="image-20231102173506651.png" alt="image-20231102173506651"></p>
<blockquote>
<p>Q&amp;&amp;A:我们的MMU在看到虚拟内存是0x8000以下的未知的时候就会映射到IO设备,以上的话就会映射到本地DRAM是吗?</p>
<p>是的!</p>
</blockquote>
<p>​        回到主线,我们看到内核栈上的一些映射很高,这是因为内核栈有一个没有映射的守护页(Gaurd Page)在下面.如果发生栈溢出了(内核栈冲破了PHYSTOP,GAURD PAGE的VA将会送到MMU，从而引发页错误，迫使操作系统检查栈溢出的问题．)    </p>
<p>​        页表的映射可以是一对一,一对多以及多对多的.这很有趣</p>
<blockquote>
<p>补充:每一个进程都会由一个内核栈</p>
</blockquote>
<p>​        我们来看看kvminit(kernel - virtual - memory - init )上一次我们看了boot的流程，我们跟到了main函数。main函数中调用的一个函数是kvminit（3.9），这个函数会设置好kernel的地址空间。kvminit的代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span>
<span class="token function">kvminit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
  kernel_pagetable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">pagetable_t</span><span class="token punctuation">)</span> <span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>kernel_pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// uart registers</span>
  <span class="token function">kvmmap</span><span class="token punctuation">(</span>UART0<span class="token punctuation">,</span> UART0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// virtio mmio disk interface</span>
  <span class="token function">kvmmap</span><span class="token punctuation">(</span>VIRTIO0<span class="token punctuation">,</span> VIRTIO0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// CLINT</span>
  <span class="token function">kvmmap</span><span class="token punctuation">(</span>CLINT<span class="token punctuation">,</span> CLINT<span class="token punctuation">,</span> <span class="token number">0x10000</span><span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// PLIC</span>
  <span class="token function">kvmmap</span><span class="token punctuation">(</span>PLIC<span class="token punctuation">,</span> PLIC<span class="token punctuation">,</span> <span class="token number">0x400000</span><span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// map kernel text executable and read-only.</span>
  <span class="token function">kvmmap</span><span class="token punctuation">(</span>KERNBASE<span class="token punctuation">,</span> KERNBASE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>etext<span class="token operator">-</span>KERNBASE<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_X<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// map kernel data and the physical RAM we'll make use of.</span>
  <span class="token function">kvmmap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>etext<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>etext<span class="token punctuation">,</span> PHYSTOP<span class="token operator">-</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>etext<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_W<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// map the trampoline for trap entry/exit to</span>
  <span class="token comment">// the highest virtual address in the kernel.</span>
  <span class="token function">kvmmap</span><span class="token punctuation">(</span>TRAMPOLINE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>trampoline<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_X<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们在前一部分看了kernel的地址空间长成什么样，这里我们来看一下代码是如何将它设置好的。首先在kvminit中设置一个断点，之后运行代码到断点位置。在gdb中执行layout split，可以看到（从上面的代码也可以看出）函数的第一步是为最高一级page directory分配物理page（注，调用kalloc就是分配物理page）。下一行将这段内存初始化为0。</p>
<p><img src="f45cef7c2ef2e4fc2b0ab0b2e57c6675.png" alt="image-20210912214818243"></p>
<p>之后，通过kvmmap函数，将每一个I/O设备映射到内核。例如，下图中高亮的行将UART0映射到内核的地址空间。</p>
<p><img src="7acb32e844e3993da51627768fef3a10.png" alt="image-20210912214847004"></p>
<p>我们可以查看一个文件叫做memlayout.h，它将4.5中的文档翻译成了一堆常量。在这个文件里面可以看到，UART0对应了地址0x10000000（注，4.5中的文档是真正SiFive RISC-V的文档，而下图是QEMU的地址，所以4.5中的文档地址与这里的不符）。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F; Physical memory layout

&#x2F;&#x2F; qemu -machine virt is set up like this,
&#x2F;&#x2F; based on qemu&#39;s hw&#x2F;riscv&#x2F;virt.c:
&#x2F;&#x2F;
&#x2F;&#x2F; 00001000 -- boot ROM, provided by qemu
&#x2F;&#x2F; 02000000 -- CLINT
&#x2F;&#x2F; 0C000000 -- PLIC
&#x2F;&#x2F; 10000000 -- uart0 
&#x2F;&#x2F; 10001000 -- virtio disk 
&#x2F;&#x2F; 80000000 -- boot ROM jumps here in machine mode
&#x2F;&#x2F;             -kernel loads the kernel here
&#x2F;&#x2F; unused RAM after 80000000.

&#x2F;&#x2F; the kernel uses physical memory thus:
&#x2F;&#x2F; 80000000 -- entry.S, then kernel text and data
&#x2F;&#x2F; end -- start of kernel page allocation area
&#x2F;&#x2F; PHYSTOP -- end RAM used by the kernel

&#x2F;&#x2F; qemu puts UART registers here in physical memory.
#define UART0 0x10000000L
#define UART0_IRQ 10

&#x2F;&#x2F; virtio mmio interface
#define VIRTIO0 0x10001000
#define VIRTIO0_IRQ 1

&#x2F;&#x2F; local interrupt controller, which contains the timer.
#define CLINT 0x2000000L
#define CLINT_MTIMECMP(hartid) (CLINT + 0x4000 + 8*(hartid))
#define CLINT_MTIME (CLINT + 0xBFF8) &#x2F;&#x2F; cycles since boot.

&#x2F;&#x2F; qemu puts programmable interrupt controller here.
#define PLIC 0x0c000000L
#define PLIC_PRIORITY (PLIC + 0x0)
#define PLIC_PENDING (PLIC + 0x1000)
#define PLIC_MENABLE(hart) (PLIC + 0x2000 + (hart)*0x100)
#define PLIC_SENABLE(hart) (PLIC + 0x2080 + (hart)*0x100)
#define PLIC_MPRIORITY(hart) (PLIC + 0x200000 + (hart)*0x2000)
#define PLIC_SPRIORITY(hart) (PLIC + 0x201000 + (hart)*0x2000)
#define PLIC_MCLAIM(hart) (PLIC + 0x200004 + (hart)*0x2000)
#define PLIC_SCLAIM(hart) (PLIC + 0x201004 + (hart)*0x2000)

&#x2F;&#x2F; the kernel expects there to be RAM
&#x2F;&#x2F; for use by the kernel and user pages
&#x2F;&#x2F; from physical address 0x80000000 to PHYSTOP.
#define KERNBASE 0x80000000L
#define PHYSTOP (KERNBASE + 128*1024*1024)

&#x2F;&#x2F; map the trampoline page to the highest address,
&#x2F;&#x2F; in both user and kernel space.
#define TRAMPOLINE (MAXVA - PGSIZE)

&#x2F;&#x2F; map kernel stacks beneath the trampoline,
&#x2F;&#x2F; each surrounded by invalid guard pages.
#define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)

&#x2F;&#x2F; User memory layout.
&#x2F;&#x2F; Address zero first:
&#x2F;&#x2F;   text
&#x2F;&#x2F;   original data and bss
&#x2F;&#x2F;   fixed-size stack
&#x2F;&#x2F;   expandable heap
&#x2F;&#x2F;   ...
&#x2F;&#x2F;   TRAPFRAME (p-&gt;trapframe, used by the trampoline)
&#x2F;&#x2F;   TRAMPOLINE (the same page as in the kernel)
#define TRAPFRAME (TRAMPOLINE - PGSIZE)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以，通过kvmmap可以将物理地址映射到相同的虚拟地址（注，因为kvmmap的前两个参数一致）。</p>
<p>在page table实验中，第一个练习是实现vmprint，这个函数会打印当前的kernel page table。我们现在跳过这个函数，看一下执行完第一个kvmmap时的kernel page table。</p>
<p><img src="8ff08c09037abe53e04bc5409bbe2a34.png" alt="image-20210912214921846"></p>
<p>我们来看一下这里的输出。第一行是最高一级page directory的地址，这就是存在SATP或者将会存在SATP中的地址。第二行可以看到最高一级page directory只有一条PTE序号为0，它包含了中间级page directory的物理地址。第三行可以看到中间级的page directory只有一条PTE序号为128，它指向了最低级page directory的物理地址。第四行可以看到最低级的page directory包含了PTE指向物理地址。你们可以看到最低一级 page directory中PTE的物理地址就是0x10000000，对应了UART0。</p>
<p>前面是物理地址，我们可以从虚拟地址的角度来验证这里符合预期。我们将地址0x10000000向右移位12bit，这样可以得到虚拟地址的高27bit（index部分）。之后我们再对这部分右移位9bit，并打印成10进制数，可以得到128，这就是中间级page directory中PTE的序号。这与之前（4.4）介绍的内容是符合的。</p>
<p><img src="71e8d96f2073f01d645a728512641f36.png" alt="image-20210912214935429"></p>
<p>从标志位来看（fl部分），最低一级page directory中的PTE有读写标志位，并且Valid标志位也设置了（4.3底部有标志位的介绍）。</p>
<p>内核会持续的按照这种方式，调用kvmmap来设置地址空间。之后会对VIRTIO0、CLINT、PLIC、kernel text、kernel data、最后是TRAMPOLINE进行地址映射。最后我们还会调用vmprint打印完整的kernel page directory，可以看出已经设置了很多PTE。</p>
<h2 id="光速复习"><a href="#光速复习" class="headerlink" title="光速复习"></a>光速复习</h2><p>​        C是如何转化为汇编语言的呢？</p>
<p>​        C一般会有main函数，还会有其他的函数等等，但是事实上CPU根本不理解这些东西，这中间需要编译器，汇编器帮助我们转化为机器语言。这些机器语言需要匹配不同机器上的ISA（指令集）。C经过编译器成为汇编语言，然后经过汇编器成为二进制文件，这些是处理器真正可以理解的文件。</p>
<p>​        我们目前研究的RISC-V跟市面上常见的x86-64不太一样，后者属于CISC指令集，而且指令很复杂而又庞大。</p>
<p>​        回到正题，当我们去查看编译器编译的代码会发现之面目全非，只是因为这里实行了大量的优化</p>
<p><img src="image-20231114203521224.png" alt="image-20231114203521224"></p>
<p><img src="image-20231114203612032.png" alt="image-20231114203612032"></p>
<p>​        我们查阅汇编文件，会发现一行行的是这样构成的，第一列是一串数字，它实际上是地址，标志着这个指令在内存中的位置，后面的就是实际的汇编代码。</p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>通过<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=gdb调试&amp;spm=1001.2101.3001.7020">gdb调试</a>我们可以监控程序执行的每一个细节，包括变量的值、函数的调用过程、内存中数据、线程的调度等，从而发现隐藏的错误或者低效的代码，程序的调试过程主要有：单步执行，跳入函数，跳出函数，设置断点，设置观察点，查看变量。<br>本文将主要介绍linux下的gdb调试工具常用的命令和具体的使用实例。</p>
<h3 id="二、调试过程介绍"><a href="#二、调试过程介绍" class="headerlink" title="二、调试过程介绍"></a>二、调试过程介绍</h3><p><strong>2.1 编译程序加参数时生成调试信息</strong><br>-g 和 -ggdb 都是令 gcc 生成调试信息，但是它们也是有区别的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>g</td>
<td>该选项可以利用操作系统的“原生格式（native format）”生成调试信息。GDB 可以直接利用这个信息，其它调试器也可以使用这个调试信息</td>
</tr>
<tr>
<td>ggdb</td>
<td>使 GCC为GDB 生成专用的更为丰富的调试信息，但是，此时就不能用其他的调试器来进行调试了 (如 ddx)</td>
</tr>
</tbody>
</table>
</div>
<p>-g也是分级别的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>g1</td>
<td>级别1（-g1）不包含局部变量和与行号有关的调试信息，因此只能够用于回溯跟踪和堆栈转储之用。回溯跟踪指的是监视程序在运行过程中的函数调用历史，堆栈转储则是一种以原始的十六进制格式保存程序执行环境的方法，两者都是经常用到的调试手段</td>
</tr>
<tr>
<td>g2</td>
<td>这是默认的级别，此时产生的调试信息包括扩展的符号表、行号、局部或外部变量信息</td>
</tr>
<tr>
<td>g3</td>
<td>包含级别2中的所有调试信息，以及源代码中定义的宏</td>
</tr>
</tbody>
</table>
</div>
<p><strong>2.2 gdb调试常用命令解析</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>file [filename]</td>
<td>装入想要调试的可执行文件</td>
</tr>
<tr>
<td>kill [filename]</td>
<td>终止正在调试的程序</td>
</tr>
<tr>
<td>break [file:]function</td>
<td>在(file文件的)function函数中设置一个断点</td>
</tr>
<tr>
<td>clear</td>
<td>删除一个断点，这个命令需要指定代码行或者函数名作为参数</td>
</tr>
<tr>
<td>run [arglist]</td>
<td>运行您的程序 (如果指定了arglist,则将arglist作为参数运行程序)</td>
</tr>
<tr>
<td>bt Backtrace:</td>
<td>显示程序堆栈信息</td>
</tr>
<tr>
<td>print expr</td>
<td>打印表达式的值</td>
</tr>
<tr>
<td>continue</td>
<td>继续运行您的程序 (在停止之后，比如在一个断点之后)</td>
</tr>
<tr>
<td>list</td>
<td>列出产生执行文件的源代码的一部分</td>
</tr>
<tr>
<td>next</td>
<td>单步执行 (在停止之后); 跳过函数调用</td>
</tr>
<tr>
<td>nexti</td>
<td>执行下一行的源代码中的一条汇编指令</td>
</tr>
<tr>
<td>set</td>
<td>设置变量的值。例如：set nval=54 将把54保存到nval变量中</td>
</tr>
<tr>
<td>step</td>
<td>单步执行 (在停止之后); 进入函数调用</td>
</tr>
<tr>
<td>stepi</td>
<td>继续执行程序下一行源代码中的汇编指令。如果是函数调用，这个命令将进入函数的内部，单步执行函数中的汇编代码</td>
</tr>
<tr>
<td>watch</td>
<td>使你能监视一个变量的值而不管它何时被改变</td>
</tr>
<tr>
<td>rwatch</td>
<td>指定一个变量，如果这个变量被读，则暂停程序运行，在调试器中显示信息，并等待下一个调试命令。参考rwatch和watch命令</td>
</tr>
<tr>
<td>awatch</td>
<td>指定一个变量，如果这个变量被读或者被写，则暂停程序运行，在调试器中显示信息，并等待下一个调试命令。参考rwatch和watch命令</td>
</tr>
<tr>
<td>Ctrl-C</td>
<td>在当前位置停止执行正在执行的程序，断点在当前行</td>
</tr>
<tr>
<td>disable</td>
<td>禁止断点功能，这个命令需要禁止的断点在断点列表索引值作为参数</td>
</tr>
<tr>
<td>display</td>
<td>在断点的停止的地方，显示指定的表达式的值。(显示变量)</td>
</tr>
<tr>
<td>undisplay</td>
<td>删除一个display设置的变量显示。这个命令需要将display list中的索引做参数</td>
</tr>
<tr>
<td>enable</td>
<td>允许断点功能，这个命令需要允许的断点在断点列表索引值作为参数</td>
</tr>
<tr>
<td>finish</td>
<td>继续执行，直到当前函数返回</td>
</tr>
<tr>
<td>ignore</td>
<td>忽略某个断点制定的次数。例：ignore 4 23 忽略断点4的23次运行，在第24次的时候中断</td>
</tr>
<tr>
<td>info [name]</td>
<td>查看name信息</td>
</tr>
<tr>
<td>load</td>
<td>动态载入一个可执行文件到调试器</td>
</tr>
<tr>
<td>xbreak</td>
<td>在当前函数的退出的点上设置一个断点</td>
</tr>
<tr>
<td>whatis</td>
<td>显示变量的值和类型</td>
</tr>
<tr>
<td>ptype</td>
<td>显示变量的类型</td>
</tr>
<tr>
<td>return</td>
<td>强制从当前函数返回</td>
</tr>
<tr>
<td>txbreak</td>
<td>在当前函数的退出的点上设置一个临时的断点(只可使用一次)</td>
</tr>
<tr>
<td>make</td>
<td>使你能不退出 gdb 就可以重新产生可执行文件</td>
</tr>
<tr>
<td>shell</td>
<td>使你能不离开 gdb 就执行 UNIX shell 命令</td>
</tr>
<tr>
<td>help [name]</td>
<td>显示GDB命令的信息，或者显示如何使用GDB的总体信息</td>
</tr>
<tr>
<td>quit</td>
<td>退出gdb</td>
</tr>
</tbody>
</table>
</div>
<p><strong>2.3 gdb调试常用参数解析</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>指定可执行文件名</td>
</tr>
<tr>
<td>-c</td>
<td>指定coredump文件</td>
</tr>
<tr>
<td>-d</td>
<td>指定目录加入到源文件搜索路径</td>
</tr>
<tr>
<td>–cd</td>
<td>指定目录作为路径运行gdb</td>
</tr>
<tr>
<td>-s</td>
<td>指定文件读取符号表</td>
</tr>
<tr>
<td>-p</td>
<td>指定attach进程</td>
</tr>
</tbody>
</table>
</div>
<h3 id="三、具体调试示例讲解"><a href="#三、具体调试示例讲解" class="headerlink" title="三、具体调试示例讲解"></a>三、具体调试示例讲解</h3><p><strong>3.1 调试已运行的进程</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> gdb　　<span class="token operator">-</span>p　　    进程名 <span class="token comment">//对指定进程进行调试</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> gdb　　attach　　进程名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>3.2 调试线程</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info　　thread　　<span class="token comment">//调试已运行的进程下再列出线程</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> thread　　线程号   <span class="token comment">//切换至线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>3.3 查看相关信息</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info　　thread　　  <span class="token comment">//列出线程</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info　　<span class="token keyword">register</span>　 <span class="token comment">//列出寄存器</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info　　frame　   <span class="token comment">//列出栈帧</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info　　files　　<span class="token comment">//列出当前文件</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info　　share　 <span class="token comment">//列出当前共享库</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3.4 修改程序执行相关参数</strong><br><strong>1、程序运行参数</strong><br>set args 可指定运行时参数。如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span>set args <span class="token number">10</span> <span class="token number">20</span> <span class="token number">30</span> <span class="token number">40</span> <span class="token number">50</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span>show args 命令可以查看设置好的运行参数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>2、其他参数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>path</td>
<td>可设定程序的运行路径</td>
</tr>
<tr>
<td>show paths</td>
<td>查看程序的运行路径</td>
</tr>
<tr>
<td>set environment varname [=value]</td>
<td>设置环境变量。如：set env USER=hchen</td>
</tr>
<tr>
<td>show environment [varname]</td>
<td>查看环境变量</td>
</tr>
<tr>
<td>show language</td>
<td>查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。</td>
</tr>
<tr>
<td>info frame</td>
<td>查看当前函数的程序语言。</td>
</tr>
<tr>
<td>info source</td>
<td>查看当前文件的程序语言。</td>
</tr>
<tr>
<td>info breakpoints</td>
<td>显示所有断点</td>
</tr>
<tr>
<td>info terminal</td>
<td>显示程序用到的终端的模式</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3.5 常用的调试步骤</strong><br><strong>1、断点的添加</strong><br>使用break 或者b命令</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>break function</td>
<td>在进入指定函数时停住</td>
</tr>
<tr>
<td>break n</td>
<td>在指定行号停住，如(gdb) break 46</td>
</tr>
<tr>
<td>break +offset或break -offset</td>
<td>在当前行号的前面或后面的offset行停住。offiset为自然数。</td>
</tr>
<tr>
<td>break filename:linenum</td>
<td>在源文件filename的linenum行处停住。</td>
</tr>
<tr>
<td>break filename:function</td>
<td>在源文件filename的function函数的入口处停住。</td>
</tr>
<tr>
<td>break *address</td>
<td>在程序运行的内存地址处停住。</td>
</tr>
<tr>
<td>break</td>
<td>break命令没有参数时，表示在下一条指令处停住。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>2、断点的删除</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>删除n号断点</td>
<td>(gdb) delete n</td>
</tr>
<tr>
<td>删除所有断点</td>
<td>(gdb) delete</td>
</tr>
<tr>
<td>清除行n上面的所有断点</td>
<td>(gdb) clear n</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3、程序运行进度调试</strong><br><strong>（1）连续执行程序，直到遇到断点</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span>run<span class="token operator">|</span>r<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>（2）继续执行程序，直到下个断点</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token operator">|</span>c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>（3）执行下一行语句</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span>next<span class="token operator">|</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>（4）单步进入</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> step<span class="token operator">|</span>s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样，也会执行一行代码，不过如果遇到函数的话就会进入函数的内部，再一行一行的执行。执行完当前函数返回到调用它的函数<br><strong>（5）跳出当前函数</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> finish <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里，运行程序，直到当前函数运行完毕返回再停止。例如进入的单步执行如果已经进入了某函数，可以退出该函数返回到它的调用函数中<br><strong>（6）跳转指令</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> jump location   <span class="token comment">//指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>4、打印程序相关信息</strong><br><strong>（1） print 命令</strong><br>输出或者修改指定变量或者表达式的值</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print <span class="token function">num</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p <span class="token function">num</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print file<span class="token operator">::</span><span class="token function">variable</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print function<span class="token operator">::</span>variable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 file用于指定具体的文件名，funciton 用于指定具体所在函数的函数名，variable表示要查看的目标变量或表达式。<br>另外，print也可以打印出类或者结构体变量的值。</p>
<p><strong>（2）打印数组</strong><br>查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token operator">*</span>array <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span> <span class="token punctuation">(</span>len <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p <span class="token operator">*</span>array@len <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其<br>保存在变量len中，其输出结果，大约是下面这个样子的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p <span class="token operator">*</span>array@len 
$<span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">38</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了</p>
<p><strong>（3）源代码显示</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>list n</td>
<td>显示程序第n行的周围的源程序。</td>
</tr>
<tr>
<td>list function</td>
<td>显示函数名为function的函数的源程序。</td>
</tr>
<tr>
<td>list +n</td>
<td>显示当前行n后面的源程序。</td>
</tr>
<tr>
<td>list -n</td>
<td>显示当前行n前面的源程序。</td>
</tr>
<tr>
<td>set listsize</td>
<td>设置一次显示源代码的行数。</td>
</tr>
<tr>
<td>show listsize</td>
<td>查看当前listsize的设置。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>（4）查看源代码的内存地址</strong><br>你可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟“行号”，“函<br>数名”，“文件名:行号”，“文件名:函数名”，这个命令会打印出所指定的源码在运行时的内<br>存地址，如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info line tst<span class="token punctuation">.</span>c<span class="token operator">:</span>func 
Line <span class="token number">5</span> of <span class="token string">"tst.c"</span> starts at address <span class="token number">0x8048456</span> and ends at <span class="token number">0x804845d</span> <span class="token punctuation">.</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>还有一个命令（disassemble）你可以查看源程序的当前执行时的机器码，这个命令会把目前<br>内存中的指令dump出来。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">disassemble <span class="token punctuation">[</span>Address<span class="token punctuation">]</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble <span class="token number">0x00000000004008fd</span>  <span class="token comment">//反汇编包含给定地址的整个函数，包括其上方的指令。</span>

disassemble <span class="token punctuation">[</span>Start<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span>End<span class="token punctuation">]</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble <span class="token number">0x000000000040068a</span><span class="token punctuation">,</span><span class="token number">0x00000000004006ac</span>  <span class="token comment">// 指定要反汇编的起始地址和结束地址</span>

disassemble <span class="token punctuation">[</span>Function<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">+</span><span class="token punctuation">[</span>Length<span class="token punctuation">]</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble main<span class="token punctuation">,</span> <span class="token operator">+</span><span class="token number">10</span>       <span class="token comment">//指定从给定地址或函数开始反汇编的字节数</span>
<span class="token number">12345678</span>
disassemble <span class="token operator">/</span>m <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
        指定此选项后，反汇编命令将显示与反汇编指令相对应的源代码行。例如：
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble <span class="token operator">/</span>m main
disassemble <span class="token operator">/</span>r <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
        当指定此选项时，反汇编命令将显示所有反汇编指令的原始字节值。
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> disassemble <span class="token operator">/</span>r main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（5）查看内存地址保存的值</strong><br>你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span>nfu addr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。<br>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是<br>指令地址，那么格式可以是i。<br>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可<br>以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当<br>我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作<br>一个值取出来。<br>addr表示一个内存地址。<br>n/f/u三个参数可以一起使用。例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> x<span class="token operator">/</span><span class="token number">3u</span>h <span class="token number">0x54320</span> <span class="token comment">//从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>（6）查看寄存器</strong><br>要查看寄存器的值，很简单，可以使用如下命令：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info registers <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看寄存器的情况。（除了浮点寄存器）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info all<span class="token operator">-</span>registers <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看所有寄存器的情况。（包括浮点寄存器）<br>寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈<br>地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前<br>加一个$符号就可以了。如：p $eip。</p>
<p><strong>（7）显示当前调用函数堆栈中的函数</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> backtrace <span class="token punctuation">[</span><span class="token operator">-</span>full<span class="token punctuation">]</span> <span class="token punctuation">[</span>n<span class="token punctuation">]</span>
<span class="token comment">/*命令产生一张列表，包含着从最近的过程开始的所有有效过程和调用这些过程的参数。
n：一个整数值，当为正整数时，表示打印最里层的 n 个栈帧的信息；n为负整数时，那么表示打印最外层n个栈帧的信息；
-full：打印栈帧信息的同时，打印出局部变量的值
注意，当调试多线程程序时，该命令仅用于打印当前线程中所有栈帧的信息。
如果想要打印所有线程的栈帧信息，应执行thread apply all backtrace命令*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（8）frame 命令详解</strong><br>frame 或 f 会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。<br>查看当前栈帧中存储的信息</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info frame
Stack level <span class="token number">0</span><span class="token punctuation">,</span> frame at <span class="token number">0x7ffc1da10e80</span><span class="token operator">:</span>
 rip <span class="token operator">=</span> <span class="token number">0x7f800008b4e3</span> in __epoll_wait_nocancel<span class="token punctuation">;</span> saved rip <span class="token operator">=</span> <span class="token number">0x5560eac8b902</span>
 called by frame at <span class="token number">0x7ffc1da11280</span>
 Arglist at <span class="token number">0x7ffc1da10e70</span><span class="token punctuation">,</span> args<span class="token operator">:</span> 
 Locals at <span class="token number">0x7ffc1da10e70</span><span class="token punctuation">,</span> Previous frame's sp is <span class="token number">0x7ffc1da10e80</span>
 Saved registers<span class="token operator">:</span>
  rip at <span class="token number">0x7ffc1da10e78</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该命令会依次打印出当前栈帧的如下信息：<br>1、当前栈帧的编号，以及栈帧的地址；<br>2、当前栈帧对应函数的存储地址，以及该函数被调用时的代码存储的地址<br>3、当前函数的调用者，对应的栈帧的地址；<br>4、编写此栈帧所用的编程语言；<br>5、函数参数的存储地址以及值；<br>6、函数中局部变量的存储地址；<br>7、栈帧中存储的寄存器变量，例如指令寄存器（64位环境中用 rip 表示，32为环境中用eip 表示）、<br>堆栈基指针寄存器（64位环境用 rbp表示，32位环境用 ebp表示）等。</p>
<p><strong>4、gdb其他命令用法</strong><br><strong>（1）搜索源代码</strong><br>不仅如此，GDB还提供了源代码搜索的命令：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> forward<span class="token operator">-</span>search     <span class="token comment">//向前面搜索。 </span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> reverse<span class="token operator">-</span>search    <span class="token comment">//从当前行的开始向后搜索</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>（2）设置观察点(WatchPoint)</strong><br>观察点一般用来观察某个表达式(变量也是一种表达式)的值是否变化了。如果有变化，马上停住程序。有下面的几种方法来设置观察点：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">watch 	为表达式<span class="token punctuation">(</span>变量<span class="token punctuation">)</span>expr设置一个观察点。一旦表达式值有变化时，马上停住程序
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> watch i <span class="token operator">!=</span> <span class="token number">10</span> 
<span class="token comment">//这里，i != 10这个表达式一旦变化，则停住。watch &lt;expr> 为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序(也是一种断点)。 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>（3）设置捕捉点(CatchPoint)</strong><br>可设置捕捉点来补捉程序运行时的一些事件。如载入共享库(动态链接库)或是C++的异常。设置捕捉点的格式为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//catch 	当event发生时，停住程序</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info catch 
<span class="token comment">//打印出当前的函数中的异常处理信息。</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> info locals 
<span class="token comment">//打印出当前函数中所有局部变量及其值。 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（4）强制调用函数</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> call <span class="token operator">&lt;</span>expr<span class="token operator">></span> 
<span class="token comment">/*这里,&lt;expr>可以是一个函数，这样就会返回函数的返回值，如果函数的返回类型是void那么就不会打印函数的返回值,但是实践发现，函数运行过程中的打印语句还是没有被打印出来。 
表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返
回值是void，那么就不显示。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他<br>来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返<br>回值，并把该值存入历史数据中。</p>
<p><strong>（5）终止一个正在调试的程序</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> kill 
<span class="token comment">//输入kill就会终止正在调试的程序了。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>注意：</strong>当调试完成后，如果想令当前程序进行执行，消除调试操作对它的影响，需手动将 GDB 调试器与程序分离，分离过程分为 2 步：<br>1、执行 detach 指令，使GDB调试器和程序分离；<br>2、执行 quit（或q）指令，退出GDB调试</p>
<h2 id="关于RISC-V和汇编"><a href="#关于RISC-V和汇编" class="headerlink" title="关于RISC-V和汇编"></a>关于RISC-V和汇编</h2><p>​        下面这张表是寄存器表</p>
<p><img src="image-20231114204930357.png" alt="image-20231114204930357"></p>
<p>​        我们的汇编实际上都是在围绕着寄存器操作。</p>
<p>​        load类的指令可以加载值进入寄存器，store类指令则是可以将寄存器的结果存回地址的某一处或者是另一个寄存器。他是最快的存取数据的方法，这就是为什么我们一般喜欢操纵寄存器来处理。</p>
<p>​        寄存器分为caller和callee两种，调用者和被调用的寄存器，可以这样理解。caller 寄存器在函数调用期间会被覆盖，但是callee寄存器不会。比如说调用函数，返回地址等。当我们写函数的时候，我们需要使用caller寄存器取调用之，而对于那些保存别调用的寄存器我们需要想办法存留这些值</p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p><img src="image-20231114205809889.png" alt="image-20231114205809889"></p>
<p>​        堆栈的存在让函数的调用正常工作，它允许函数调用和函数结束调用后返回上级。上面的这张图是堆栈的简化图</p>
<p>​        所以我们发现，那些不再继续调用函数的函数通常不会再使得栈帧增长，我们称呼之为叶子函数。</p>
<p><img src="image-20231114210229716.png" alt="image-20231114210229716"></p>
<p>​        让我们看看，如果我们把保存函数栈帧和加载回栈帧的汇编代码删去了会如何</p>
<p><img src="image-20231114210340636.png" alt="image-20231114210340636"></p>
<p>​        答案是无限循环调用，当我们加载到最后的函数调用地址后，函数执行完成走向ret，查看sp寄存器发现仍然是该函数的地址，所以进入后继续执行</p>
<p>​    我们这谈到的是陷入。他描述的是操作系统从用户模式切换到内核模式时候的行为。</p>
<p>​        寄存器分为通用寄存器和特殊寄存器，他们辅助着CPU的工作。比如说，SATP（Supervisor Address Translation and Protection (SATP) register，STVEC（Supervisor Trap Vector base address register），他处理着内核当中的trap指令。SEPC寄存器（Supervisor Exception Pragram Counter）处理在trap期间保存程序计数器。Sscratc（Supervisor Scratch Register）—寄存器等处理之这些重要的工作。</p>
<p>​        我们知道，当CPU切换上下文或者是陷入的时候，他需要保存上下文的工作，这就需要保存现场。也就是各个寄存器的值。需要使用到栈来保存（进入压栈，出去弹栈）</p>
<p>​        管理者模式不会有什么太多的特别之处。简单讲，它可以控制SATP，STVEC，SEPC，Sscratch，和设置哪些PTE是可以被用户访问到的(PTE_U)</p>
<p><img src="image-20231115164227258.png" alt="image-20231115164227258"></p>
<p>​        首先是 ecall 指令进入内核态；然后在 trampoline 处执行 uservec，完成初始化操作；随后执行 usertrap，判断中断类型，这里是系统调用中断；转到 syscall 中，根据 a7 寄存器中的值，调用对应的系统调用函数，即 sys_write 函数；最后使用 ret 指令进行返回，同时恢复寄存器的值，恢复到用户进行系统调用前的状态。</p>
<h1 id="MIT-S081-9-Page-Fault"><a href="#MIT-S081-9-Page-Fault" class="headerlink" title="MIT S081 9 Page Fault"></a>MIT S081 9 Page Fault</h1><p>​        这次我们的主题是懒分配，我们需要了解的是写入时才会复制进程（fork），按照需求调用页，以及内存映射文件mmap。现代操作系统都完成了这些功能。</p>
<p>​        先回顾一下，虚拟内存有两个好处：</p>
<ol>
<li>隔离：让每个进程各司其职而不会互相干扰。</li>
<li>一定程度的间接性</li>
</ol>
<p>​        内核控制着虚拟地址如何映射到实际地址。xv6中有一个trampoline页，它运行内核将一个页面映射到多个页面。另一个则是守护页，它用来在用户空间和内核空间中保护栈。现在为之，我们的映射都是相对静态的。页面错误将会使得这一行为动态起来。也就是说，我们的内核通过页面错误来动态的调整映射</p>
<p>​        首先，发生页面错误需要我们去响应。这个错误地址会出现在stval寄存器下。同时还会有错误类型提供（跳转还是加载），他们会在scause寄存器中出现。</p>
<p>​        当在用户态下发生页面错误，操作系统就会跳转到内核态，当在内核态出现页面错误后，回去设置stval寄存器，scause寄存器等等</p>
<p>​        以及，还会去查看一场程序计数器看看发生在什么位置</p>
<h2 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a><code>sbrk</code></h2><p>​        这个函数运行我们扩展堆，当我们的调用这个函数的时候，我们的内核会返回尚未使用的物理内存，再反向映射到我们的用户内存当中，将内存置零。之后，应用程序就可以使用。也可以使用负数来缩小。</p>
<p>​        在xv6中的对分配是急分配的，也就是一调用就会分配。但是在实际上现代操作系统不会这样做。这是为了避免应用程序过多的申请但是出现实际上并不需要的情况。于是“懒分配”应运而生。在懒分配下，sbrk几乎什么也不做，只是给p-&gt;sz加数，但是不分配任何内存。现在，当我们的应用程序需要使用这块内存的时候，会触发一个也错误，督促内核尽快完成分配</p>
<blockquote>
<p>假设某一个时刻，应用程序申请了很多内存，把内存消耗殆尽了，但是这个时候由于采取了懒分配而并没有实际分配，请问这个时候的应用程序何时才会知道自己的物理内存不够了</p>
<p>答案：他被杀死的时候（乐），此时发生页错误，内核去分配的时候发现并没有更多的物理内存，所以会直接砍死这个进程</p>
</blockquote>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">uint64 sys_sbrk(void)
&#123;
    int addr;
    int n;
    
    if(argint(0, &amp;n) &lt; 0)
    &#123;
        return -1;
    &#125;
    addr &#x3D; myproc()-&gt;sz;
    if(growproc(n) &lt; 0)
        return -1;
    return addr;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是原本的代码，现在我们来看看懒分配如何做：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">uint64 sys_sbrk(void)
&#123;
    int addr;
    int n;
    
    if(argint(0, &amp;n) &lt; 0)
    &#123;
        return -1;
    &#125;
    addr &#x3D; myproc()-&gt;sz;
    myproc()-&gt;sz +&#x3D; n;
    if(growproc(n) &lt; 0)
        return -1;
    return addr;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20231116084800260.png" alt="image-20231116084800260"></p>
<p>​        这里我们看到scause的值是15，出现的就是加载到页面的时候发现也不存在而爆出的也错误。</p>
<p>​        当我们接受到这个错误的时候，前往开辟内存。在 usertrap中写代码处理：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">...
else if(r_scause &#x3D;&#x3D; 15)
&#123;
    uint64 va &#x3D; r_stval();
    uint64 ka &#x3D; (uint64)kalloc();
    if(ka &#x3D;&#x3D; 0)
    &#123;
        p-&gt;killed &#x3D; 1;
    &#125;
    else
    &#123;
        memset((void*)ka, 0, PGSIZE);
        va &#x3D; PGROUNDDOWN(va);
        if(mappages(p-&gt;pagetable, va, PGSIZE, ka, PTE_W|PTE_U|PTE_R) !&#x3D; 0)
        &#123;
            kfree((void*)ka);
            p-&gt;killed &#x3D; 1;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20231116085708297.png" alt="image-20231116085708297"></p>
<p><img src="image-20231116085741018.png" alt="image-20231116085741018"></p>
<p>​        咋还是抛错了呢？答案是：那些被懒分配了的但是还没被是急分配的页面。所以，我们在这里，并不需要检查</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if((*pte &amp; PTE_V) &#x3D;&#x3D; 0)
	panic(...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        而是放心大胆的让他continue就好了。虚拟地址只是被告知多了，但实际上没有多，所以，我们不需要去释放那些甚至就没被映射的页。（就像没malloc就不去free）</p>
<p><img src="image-20231116085958255.png" alt="image-20231116085958255"></p>
<p>​        成功了。</p>
<p>​        事实上，操作系统里有很多空页。当我们查看二进制文件的布局可以看到：</p>
<p><img src="image-20231116091239038.png" alt="image-20231116091239038"></p>
<p>​        大量的0页。我们现在既然已经采用了虚拟内存映射到真实的物理内存，那就</p>
<p><img src="image-20231116092318022.png" alt="image-20231116092318022"></p>
<p>​        我们注意，这个页显然是不能写入的（原因显而易见，改动那些大量的映射到同一页的页数据会是一个灾难）。当我们需要一个向一个新的0页写入的时候就会实际分配一个0页。</p>
<h2 id="Copy-on-write-fork"><a href="#Copy-on-write-fork" class="headerlink" title="Copy-on-write fork"></a><code>Copy-on-write fork</code></h2><p>​        我想Linux用户都会熟悉fork操作，这里就不多介绍了。注意到我们的父子进程在<code>Copy-on-write fork</code>下，在我们并没有在子进程下进行写入的时候，仍然会去将父进程和子进程的映射保持一致，当子进程的页面要被写入的时候，按照数量来进行开辟与改射。怎么判断要写入了呢？先将page设置成只读的就好，诱发页错误开新页。</p>
<pre class="line-numbers language-none"><code class="language-none">copy page, map it, and restart the instrcution<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        但是问题来了：内核如何区分我们是在溢出写入还是正常的去获取页面呢？答案是回到硬件。在PTE的RSW位。所有我们会使用这个保留的位来辨别情况。</p>
<p>​        我们下面考虑这样的一个问题：当父子进程都在映射同一个空间的时候,突然有父进程或者是子进程被释放了,我们应该怎么做?是释放页面吗?显然不能!子进程可能还在使用这些页.所以我们引入一个引用计数器,放在哪里呢?可以放在进程维护的表里!</p>
<h2 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a><code>Demand Paging</code></h2><p>​        我们知道我们需要按照需求调页:意思就是,啥时候真用到了啥时候才会映射.举个例子,当我们运行第一行代码的时候,触发page-fault来加载页.</p>
<p>​        另一方面,当我们的物理内存不足,除了把进程砍掉,可能还可以去换掉那些最近最少使用的页面（LRU），这可以借助PTE里的D位或者是A位统计进行。</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a><code>mmap</code></h2><p>​        我们会把大文件也给进行页映射，这样我们就可以直接操作大文件从而节约时间。我们不会立即映射，而是将相关的信息保存在vma中。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>​        本节课我们讨论的是锁：我们来看看我们为什么需要锁：我们直到对于多个程序需要用到核心，就需要对之进行一定的调配，防止错乱。他们可能会去访问一些公共数据。这样，就会产生读者和写着，我们应该如何防止出现写与读的同时冲突呢？这就是我们要解决的问题。</p>
<p><img src="image-20231203094122479.png" alt="image-20231203094122479"></p>
<p>​        我们看到单个核心的频率逐渐达到极限，为了进一步提升效率，就需要我们转向多核心的内核。操作系统必须合理的调配之让核心的运行具有并行性。</p>
<p>​        锁应运而生。没有锁，我们对于共享数据的访问就会产生竞态条件。</p>
<p>​        这是一个典型的使用锁的<code>kernel_free</code>函数</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void kfree(void* pa)
&#123;
    struct run* r;
    ...;
    acquire(&amp;kmem.lock);
    r-&gt;next &#x3D; kmem.freelist;
    kmem.freelist &#x3D; r;
    release(&amp;kmem.lock);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们把锁去掉如何呢？答案是，出现的竞态条件将会使得CPU之间完全不知道有些事情已经做了导致重复的释放（重复调用kfree）</p>
<p><img src="image-20231203094646491.png" alt="image-20231203094646491"></p>
<p>​        啊哈，挂起来了。CPU之间几乎会同时执行，这就需要我们对正在访问的共享数据结构上锁，让其他CPU知道某一实体正在访问这个数据结构</p>
<h2 id="抽象我们的锁"><a href="#抽象我们的锁" class="headerlink" title="抽象我们的锁"></a>抽象我们的锁</h2><p>​        我们的锁需要两个最基本的操作:<code>acquire</code>和<code>release</code>，也就是获取锁和释放锁。<code>acquire</code>必须保证只有一个进程可以获得锁。release就是释放锁。</p>
<pre class="line-numbers language-none"><code class="language-none">acquire(Lock)
&#x2F;&#x2F;
&#x2F;&#x2F; critical section临界区
&#x2F;&#x2F;
release(Lock)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们定义在如上区间的代码为临界区。</p>
<p>​        当然，现在多出来的是并行锁——也就是说，不一定只有一个进程可以获取锁。事实上，应该是对于一个共享数据提供一个对之的锁方才可以。</p>
<h2 id="什么时候用锁"><a href="#什么时候用锁" class="headerlink" title="什么时候用锁"></a>什么时候用锁</h2><p>​        建议是：当可能出现多个进程同时访问一个共享的数据结构的时候，需要我们对进程上锁！（很保守的规则）。</p>
<h2 id="锁是否自动"><a href="#锁是否自动" class="headerlink" title="锁是否自动"></a>锁是否自动</h2><p>​        不是，需要我们自己手动来进行，因为那样会太过死板。</p>
<h2 id="锁的性质"><a href="#锁的性质" class="headerlink" title="锁的性质"></a>锁的性质</h2><ol>
<li>首先，他保证了所有访问该数据结构的进程不会丢失更新</li>
<li>使得操作具有原子性</li>
<li>帮助维护一个不变的量</li>
</ol>
<h2 id="锁会产生的问题"><a href="#锁会产生的问题" class="headerlink" title="锁会产生的问题"></a>锁会产生的问题</h2><p>​        可能存在死锁的问题：举个例子，CPU1获取了锁A，同时CPU2获取了锁B，然后在下一步的操作里CPU1希望获取锁B，但是CPU2同时希望获取锁A方才可以解除对锁A的占有——会发现双方都在窥探自己手中的锁却没法释放——寄了。</p>
<p>​        解决办法？那就是规定锁的获取顺序！也就是说，获取某一个锁之前需要务必保证另一个锁是可以获取的！</p>
<p>​        另一个就是性能的问题——那就是他将本可以并行化的操作串行化。所以我们的解决办法就是试图重构那些过于频繁发生的锁竞争的部分</p>
<h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h2><p>​        注意到RISC-V上有一个硬件支持的testandset指令，可以防止在软件层面上两个CPU同时获取到锁。也就是说我们在硬件层面上支持原子操作。</p>
<p>​        注意，有的时候编译器和处理器会对代码进行重排，为了防止重排（会导致一些本是acquire-release临界区代码不再临界区）</p>
<h2 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h2><p>​        我们将会查看关于xv6的线程的底层实现。为什么会有线程呢？我们希望电脑可以做到同时间去做多个事件。并且期望这些事情没有发生错乱。</p>
<p>​        另一个需要线程的原因是可以简化程序的组织逻辑（不是书写逻辑）。所以，分解我们 的程序，从而使用线程来分担那些可以被分担的部分是一件很重要的事情。</p>
<p>​        对于线程的定义多样，我们认为一个线程就是一个CPU正在执行的程序流的体现，换而言之，也就是一个CPU上做的事情的流水线，我们认为这是一个线程，他按照普通的方式一条一条的执行指令。</p>
<p>​        思考线程的最重要的，也是最关键的部分就是去思考线程的状态(State of the process)，而这往往需要我们看到PC(Program Coounter)，我们很关心这个进程到哪里了。这是我们关心我们的目标线程，我们还需要关心其他的线程和这个本线程之间的关系。她决定给了我们对于这些线程协作方式的指导。</p>
<p>​        除了PC以外，一些寄存器的值也是需要我们进行保留的。组织这些我们需要线程系统来完成这件事情。由此，就需要关心如何交织起来这些多线程。</p>
<p>​        xv6在支持自动的多个用户进程之间的切换，每一个进程都有他们独属于自己的内存。而对于系统线程则是会共享内存，用户线程则不会。</p>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>​        就是依靠定时器中断来切换进程。内核取得控制权的第一步就是依据定时器的中断陷入，进入中断处理程序，从而进行进程的切换处理。随后，内核让出调度器，让调度器执行其他的进程。</p>
<p>​        这是抢占调度。即使我们的代码不愿意让出CPU，我们仍然会直接剥夺CPU分给其他的程序。上面一段的陈述则是xv6对于进程抢夺的实现。</p>
<p>​        我们还需要区分那些线程的完整状态比如说：</p>
<blockquote>
<p>一些线程就在跑：RUNNING（运行态）</p>
<p>一些线程准备好了，就等待CPU的选择执行: RUNNABLE（就绪态）</p>
<p>一些线程并不需要被运行，可能是在等待IO: SLEEPING</p>
</blockquote>
<p>​        进程的切换就需要把这些状态字进行必须要的操作。从而恢复上下文。在用户层面上，每一个进程都有内存，用户堆栈，PC，寄存器等，当发生中断的时候，会把这些东西保存到trapframe里去。</p>
<p>​        注意，当我们切换到其他进程的时候，会从用户走到内核，内核中走向调度进程的进程中，切换内核进程再返回到其他的用户进程</p>
<p><img src="image-20240113140709423.png" alt="image-20240113140709423"></p>
<p>​        注意所有的流程都需要有原子性，我们不希望在我们切换的时候发生调度产生未定义行为。</p>
<h1 id="Threads-1"><a href="#Threads-1" class="headerlink" title="Threads"></a>Threads</h1><p>​        我们将会查看关于xv6的线程的底层实现。为什么会有线程呢？我们希望电脑可以做到同时间去做多个事件。并且期望这些事情没有发生错乱。</p>
<p>​        另一个需要线程的原因是可以简化程序的组织逻辑（不是书写逻辑）。所以，分解我们 的程序，从而使用线程来分担那些可以被分担的部分是一件很重要的事情。</p>
<p>​        对于线程的定义多样，我们认为一个线程就是一个CPU正在执行的程序流的体现，换而言之，也就是一个CPU上做的事情的流水线，我们认为这是一个线程，他按照普通的方式一条一条的执行指令。</p>
<p>​        思考线程的最重要的，也是最关键的部分就是去思考线程的状态(State of the process)，而这往往需要我们看到PC(Program Coounter)，我们很关心这个进程到哪里了。这是我们关心我们的目标线程，我们还需要关心其他的线程和这个本线程之间的关系。她决定给了我们对于这些线程协作方式的指导。</p>
<p>​        除了PC以外，一些寄存器的值也是需要我们进行保留的。组织这些我们需要线程系统来完成这件事情。由此，就需要关心如何交织起来这些多线程。</p>
<p>​        xv6在支持自动的多个用户进程之间的切换，每一个进程都有他们独属于自己的内存。而对于系统线程则是会共享内存，用户线程则不会。</p>
<h2 id="进程切换-1"><a href="#进程切换-1" class="headerlink" title="进程切换"></a>进程切换</h2><p>​        就是依靠定时器中断来切换进程。内核取得控制权的第一步就是依据定时器的中断陷入，进入中断处理程序，从而进行进程的切换处理。随后，内核让出调度器，让调度器执行其他的进程。</p>
<p>​        这是抢占调度。即使我们的代码不愿意让出CPU，我们仍然会直接剥夺CPU分给其他的程序。上面一段的陈述则是xv6对于进程抢夺的实现。</p>
<p>​        我们还需要区分那些线程的完整状态比如说：</p>
<blockquote>
<p>一些线程就在跑：RUNNING（运行态）</p>
<p>一些线程准备好了，就等待CPU的选择执行: RUNNABLE（就绪态）</p>
<p>一些线程并不需要被运行，可能是在等待IO: SLEEPING</p>
</blockquote>
<p>​        进程的切换就需要把这些状态字进行必须要的操作。从而恢复上下文。在用户层面上，每一个进程都有内存，用户堆栈，PC，寄存器等，当发生中断的时候，会把这些东西保存到trapframe里去。</p>
<p>​        注意，当我们切换到其他进程的时候，会从用户走到内核，内核中走向调度进程的进程中，切换内核进程再返回到其他的用户进程</p>
<p><img src="image-20240113140709423-1705458707970-41.png" alt="image-20240113140709423"></p>
<p>​        注意所有的流程都需要有原子性，我们不希望在我们切换的时候发生调度产生未定义行为。</p>
<h2 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h2><p>​        文件系统可以认为是最面向用户的部分。我们实际上一直在使用这些服务。他又这些值得注意的特性：</p>
<blockquote>
<p>用户友好的命名（路径啊等帮助在组织文件结构）</p>
<p>在用户和进程之间共享文件</p>
<p>持久性和可修复性</p>
</blockquote>
<p>​        注意到文件系统的另一个有趣的话题是日志恢复，我们下一节课在讨论之。</p>
<p>​        文件系统会使用缓存技术，这是因为写入硬盘缓存是需要事件的。</p>
<h3 id="一些常见的API"><a href="#一些常见的API" class="headerlink" title="一些常见的API"></a>一些常见的API</h3><blockquote>
<p>open: 打开文件，返回文件句柄</p>
<p>write: 向文件文件写入字节等信息</p>
<p>read: 从文件读入数据进行程序的加载</p>
<p>link : 链接文件，可以想象成超链接</p>
<p>unlink：解除链接</p>
</blockquote>
<h3 id="文件系统的层次和结构问题"><a href="#文件系统的层次和结构问题" class="headerlink" title="文件系统的层次和结构问题"></a>文件系统的层次和结构问题</h3><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p>​        这是一个表征文件独立对象的东西：里面有文件的信息。文件系统实际上是使用inode来编排信息。会有一些计数指针指向之，当计数为0的时候会自动删除。</p>
<h4 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h4><p>​        文件描述符，实际上就是给程序进行操作的文件句柄。</p>
<p><img src="image-20240115093231324.png" alt="image-20240115093231324"></p>
<p>​        这是文件结构的层次</p>
<h3 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h3><p>​        我们的存储设备主要是</p>
<p><img src="image-20240115093311840.png" alt="image-20240115093311840"></p>
<p>​        磁盘的布局可以认为是一个巨大的字符数组，文件系统的作用就是在磁盘上布置数据结构来操纵和恢复磁盘。</p>
<p>​        一般而言，0号磁盘用于做引导快而不被使用，在xv6中，1号块则是做超级快，2-32块则是做日志快用于书写日志，32-45则是保存inodes数据，之后还会有一个bitmap block从而跟踪后面的数据块，后面的就是data了。 </p>
<p><img src="image-20240115093814579.png" alt="image-20240115093814579"></p>
<p><img src="image-20240115094121158.png" alt="image-20240115094121158"></p>
<p>​        inode的内部结构如图所示。</p>
<h2 id="文件夹"><a href="#文件夹" class="headerlink" title="文件夹"></a>文件夹</h2><p>​        文件夹的结构和文件是类似的，不过起到的是引导的作用</p>
<p><img src="image-20240115094644120.png" alt="image-20240115094644120"></p>
<h2 id="写入文件可能发生了什么"><a href="#写入文件可能发生了什么" class="headerlink" title="写入文件可能发生了什么"></a>写入文件可能发生了什么</h2><p><img src="image-20240115095224385.png" alt="image-20240115095224385"></p>
<h1 id="Crash-Recovery"><a href="#Crash-Recovery" class="headerlink" title="Crash Recovery"></a>Crash Recovery</h1><p>​        我们下面要讨论的就是文件系统的恢复问题，也就是说当我们的系统意外崩溃了，我们的文件系统会如何做出反应。</p>
<p>​        很多的文件系统是多步的操作，这也就意味着在一些不太友好的时机断电会导致文件系统出现局部的信息不对等等。所以这就要求我们的文件系统配备日志进行修复，把没有做完的事情补充完整。</p>
<p><img src="image-20240116074653541.png" alt="image-20240116074653541"></p>
<p>​        以<code>echo &quot;hi&quot; &gt; x</code>为例子，我们这里就会call系统调用create，然后再写入文件。可以看到文件系统实际上执行了很多步的操作。如果这个时候发生了断点，就会意味着所有内存的数据（RAM）会发生清零，我们只有磁盘的数据了。如果没有日志恢复，就会意味着可能执行到中间的某部分但是没有执行完毕，明明有所分配但是却没办法操作他，导致我们产生了一个broken inode。</p>
<p>​        这些解决方法是日志。首先他需要保证对文件系统的调用必须是原子的，也就是说，一些操作必须一次性的完成。另一个特性就是快速恢复。最后一点就是它尽可能要高效率。</p>
<p>​        现在有了日志，我们的操作发生改变了：比起来直接写入磁盘，我们转向写入日志，我们在对文件系统进行任何的更新的时候总是先写入日志。然后，提交这些日志开始执行操作，最后就是实操（安装），最后就是把日志清理掉。</p>
<p>​        中间的任何步骤发生了中断，我们的步骤就是退回去到上一步，然后把我们的操作重新执行一遍。</p>
<h1 id="Recovery-in-Linux-Ext3"><a href="#Recovery-in-Linux-Ext3" class="headerlink" title="Recovery in Linux Ext3"></a>Recovery in Linux Ext3</h1><p>​        我们下面就是讨论Linux 的 ext3文件系统是如何进行文件系统日志恢复的</p>
<p>​        xv6的实现相对简单，他就是日志头和写入日志的块组成。所有的操作一开始会对日志进行操作，然后方才真正的写入磁盘。</p>
<p><img src="image-20240116082250945.png" alt="image-20240116082250945"></p>
<p>​        ext3跟xv6很相似，但是不同之处在于它支持同时跟踪多个事务。</p>
<p>​        下面我们来讨论日志的格式。日志的头部有一个超级快：它包含第一个有效事务的偏移量和序列号</p>
<p><img src="image-20240116082614179.png" alt="image-20240116082614179"></p>
<p>​        提交块的区分是一个魔数，我们利用它来区分数据块和提交快</p>
<p>​        提升ext3的性能办法是：</p>
<blockquote>
<p>异步系统调用：只是更新缓存没有急着直接写</p>
<p>批量处理：在真正写的时候批量处理磁盘事务</p>
<p>并发：调用多线程写文件</p>
</blockquote>
<p>​        异步系统的调用有一个缺点：系统调用返回不一定真正意味着磁盘数据真正的写入的磁盘。意味着我们的磁盘写入行为需要很谨慎。所幸的是存在系统调用来完成真真正正的写入。就是<code>fsync</code>调用，他保证磁盘会真正立马的写入数据。</p>
<p>​        批量处理则是处理那些频繁的写入问题，让我们把本来需要多次的磁盘写入合并成一次。</p>
<p>​        并发处理有两种，相对于xv6。它允许多个系统调用同时执行，同样的处于不同阶段的事务可以同时进行。比如说允许一个事务处理系统调用，另一些可能正在向磁盘写入，这是没有关系的</p>
<p><img src="image-20240116084514576.png" alt="image-20240116084514576"></p>
<p>​        提交的基本步骤如下：</p>
<ol>
<li>首先就是阻塞新的系统调用</li>
<li>对于正在进行的系统调用则是等待他们完成</li>
<li>开启新的事务，结束对新的系统调用的阻塞</li>
<li>现在开始写描述块，记录那些快发生了修改</li>
<li>我们还会把修改从缓存写入日志</li>
<li>等待4， 5完成了，提交记录</li>
<li>等待6的完成</li>
<li>到这里，事务到达了提交点，我们将会保证这个写入已经完成了</li>
<li>将事务块从日志写入磁盘</li>
<li>复用日志。</li>
</ol>
<p>​        我们判断日志的状态就是看日志的状态数据部分。我们是如何区分数据块和描述块的？答案是魔数<code>(magic number)</code></p>
<p>​        现在回答这个问题：为什么只能有一个事务处理log呢？</p>
<p><img src="image-20240116085524455.png" alt="image-20240116085524455"></p>
<p>​        我们需要保证写入的原子性，一旦打破了可能会出现未定义的行为。</p>
<h2 id="Virtual-Memory-in-User-Application"><a href="#Virtual-Memory-in-User-Application" class="headerlink" title="Virtual Memory in User Application"></a>Virtual Memory in User Application</h2><p>​        这一次我们讲用户应用程序的虚拟内存。</p>
<p>​        OS内核使用虚拟内存页表，实现了很多高效的算法。这里，我们希望用户应用程序也可以像内核程序一样，积极的响应页错误等。</p>
<p>​        我们需要什么系统原语呢？Trap，就是在页缺陷的时候升级特权位，让页补充程序将需要的页换进来。</p>
<p>​        另一个原语Prot1则是用来降低可访问权限。比如说从读写降到只读，从只读降低到不可访问。</p>
<p>​        那么ProtN自然就是调用N次Prot1了，为什么会有这个原语呢？答案是每一次调用Prot1都会刷新TLB，刷新TLB代价太大，所以就可以合并降低权限操作来保证只访问一次TLB。</p>
<p>​        相反的操作是UnProt，就是提升权限。Dirty就是标记一个页被修改过。Map2则是允许一个页被映射两次</p>
<p>​        Unix今天实现了上述陈述的几个子集。mmap就是将文件或者是设备映射到了调用者的地址空间，换而言之，访问这个设备就像访问内存一样的行为，从而提升效率（相比访问文件要快）</p>
<p>​        mprotect则是将特定的部分内存设置保护位。等等</p>
<p><img src="image-20240117083805988.png" alt="image-20240117083805988"></p>
<p>​        这是一个内核处理页访问的经典步骤。</p>
<blockquote>
<p>首先程序访问到了一个可以触发页错误的页面，然后内核保存用户程序状态，随后依照页错误处理程序查看如何正确处理，对于那些页缺失等就是直接换入页然后重新向上传递和恢复到用户态，对于那些例如Sigment Fault的不可恢复的错误，那么首先会查看是否有处理此类错误的程序，安装了的话就会将事件向上传播到用户态，使用这类程序处理这些错误，反之就是直接砍掉进程，恢复到用户模式</p>
</blockquote>
<p>​        我们有一个技巧：对于那些操作昂贵的操作，可以将结果打表记录，然后下此是应用类似的操作的时候可以取表做变换操作。这是一个空间换时间的操作。</p>
<h2 id="OS内核层次"><a href="#OS内核层次" class="headerlink" title="OS内核层次"></a>OS内核层次</h2><h3 id="宏内核"><a href="#宏内核" class="headerlink" title="宏内核"></a>宏内核</h3><p>​        我们这次讨论的是微内核。对于传统的而言，大多数操作系统都是宏内核，也就是内核仿佛是一个庞大的整体，具有强大的抽象的抽象能力，他让我们可以对应用程序隐藏不必要的细节。</p>
<p>​        另外，我们可以认为内核是一个巨大的应用程序，文件系统，调用器等部分只是子函数，这让这些组件之间的耦合度比较高。</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>​        宏内核太大了，耦合度过高，传统的内核一旦触发一些错误，容易导致整个系统的崩溃。另一方面，他太过庞大，我们往往只需要其中几个部分。这促使我们思考需要对庞大的内核进行部分的解耦合。</p>
<p>​        在微内核中，我们将会有一个小的内核，支持IPC进程特性的机制和类似进程的概念TASK，将其余一切常见的服务，比如说类似copy-on-write，或者是文件系统等内容放到用户态。相互之间的通信使用的是类似IPC的通信提供服务</p>
<p><img src="image-20240117090130677.png" alt="image-20240117090130677"></p>
<p>​        我们发现微内核更轻量，更容易定制，而且由于耦合度较低，他让系统变得十分的稳定。另外，还允许我们对之提供更多的操作系统抽象。</p>
<p>​        它在内部有一个叫做Task或者地址空间的概念，这或多或少的对应了Uinx内的进程概念。Task包含了一些内存，地址从0开始，并且可以像进程一样执行指令。区别于XV6的是，每个Task可以有多个线程，L4会调度每个Task内的多个线程的执行。这样设计的原因是，可以非常方便的用线程来作为组织程序结构的工具。我不知道在论文发表的时候，L4是否支持了多处理器，或许它包含了在多个处理器上运行同一个程序的能力。所以L4内核知道Task，知道线程，也知道地址空间，这样你就可以告诉L4如何映射地址空间内的内存Page。<br>​        另一个L4提供的就是是IPC。每一个线程都有一个标识符，其中一个线程可以说，我想要向拥有这个标识符的另一个线程发送几个字节。</p>
<p><img src="image-20240117090435859.png" alt="image-20240117090435859"></p>
<p>​        然而微内核不是那么好，由于解耦，我们的直接通信变成了传递性质的通信，导致我们的处理变慢，</p>
<p>​        现在考虑v改进的IPC通信。</p>
<p><img src="image-20240117090849338.png" alt="image-20240117090849338"></p>
<p>​        也就是跳过内存的缓存，这要求我们提前知道两个通信的进程，将CS客户模式转变为P2P的通信模式。</p>
<p><img src="image-20240117091010595.png" alt="image-20240117091010595"></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>​        我们现在讨论虚拟机，我们将计算机进行抽象，我们有虚拟机器管理程序，向上提供一系列计算机的抽象。也就是对外表现为同一台机器上有多个操作系统。</p>
<p><img src="image-20240117091157636.png" alt="image-20240117091157636"></p>
<p>​        有两种模式——客户用户和客户监管者模式，他们都接受来自VMM的服务。</p>
<p>​        VMM可以完全由软件实现，它翻译指令给真实CPU。但是它速度太慢。另一方面，我们可以直接让他直接接触真正的CPU，但是必须采取一些操作。</p>
<p>​        我们的第一步就是让内核以用户态运行。然后运行到特权指令时，运行在监管者模式的VMM将会截获特权指令交管给VMM处理。这里会提供硬件的虚拟抽象</p>
<p><img src="image-20240117092033701.png" alt="image-20240117092033701"></p>
<p>​        总而言之，VMM就是仿照硬件的行为为上层提供抽象。</p>
<p><img src="image-20240117092437152.png" alt="image-20240117092437152"></p>
<p>​        还有一种就是硬件级别的支持虚拟机。</p>
<p><img src="image-20240117092543513.png" alt="image-20240117092543513"></p>
<h2 id="内核与高级编程语言"><a href="#内核与高级编程语言" class="headerlink" title="内核与高级编程语言"></a>内核与高级编程语言</h2><h3 id="使用-C-语言实现-OS"><a href="#使用-C-语言实现-OS" class="headerlink" title="使用 C 语言实现 OS"></a>使用 C 语言实现 OS</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>内存分配和释放的控制能力</li>
<li>几乎无隐藏的代码</li>
<li>直接访问内存的能力(可以读写 PTE 的标志位或设备寄存器)</li>
<li>极少的依赖(不需要运行时)</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>缓冲区越界</li>
<li>使用已释放的内存(use-after-free bugs)</li>
<li>线程共享动态内存(很难确定是否可以释放内存)</li>
</ul>
<h3 id="使用高级编程语言-HLLs-实现-OS"><a href="#使用高级编程语言-HLLs-实现-OS" class="headerlink" title="使用高级编程语言(HLLs)实现 OS"></a>使用高级编程语言(HLLs)实现 OS</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>提供了内存安全性(memory-safety). 上述 C 语言实现 OS 的内存漏洞不会存在.</li>
<li>类型安全</li>
<li>通过 GC 实现的自动内存管理</li>
<li>并发更友好</li>
<li>更好的抽象(接口, 类等面向对象语法更易写出模块化代码)</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>更差的性能(High Level Language Tax):<ul>
<li>边界检查, 类型检查, 空指针检查</li>
<li>垃圾回收</li>
</ul>
</li>
<li>与内核编程不兼容<ul>
<li>无内存直接访问能力</li>
<li>不能集成汇编语言</li>
<li>受限的并发/并行(与内核所需的并行不一致, 比如在线程调度时线程的锁会传递, 在用户程序中不常见)</li>
</ul>
</li>
</ul>
<h3 id="论文背景"><a href="#论文背景" class="headerlink" title="论文背景"></a>论文背景</h3><ul>
<li>缺少对内核中高级编程语言的优劣分析的工作</li>
<li>使用高级编程语言构建操作系统内核与 Linux 内核比较</li>
</ul>
<h3 id="选择的高级语言"><a href="#选择的高级语言" class="headerlink" title="选择的高级语言"></a>选择的高级语言</h3><p>Golang</p>
<ul>
<li>容易调用汇编代码</li>
<li>静态编译语言, 性能更好</li>
<li>容易并发</li>
<li>容易静态分析</li>
<li>带有垃圾回收</li>
</ul>
<h3 id="Biscuit"><a href="#Biscuit" class="headerlink" title="Biscuit"></a>Biscuit</h3><p>使用 Golang 实现的宏内核操作系统</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>支持多核 CPU</li>
<li>支持用户程序多线程</li>
<li>高性能日志文件系统</li>
<li>虚拟内存系统</li>
<li>完整的 TCP/IP 栈</li>
<li>高性能驱动: 网卡和磁盘驱动</li>
</ul>
<h4 id="用户程序"><a href="#用户程序" class="headerlink" title="用户程序"></a>用户程序</h4><ul>
<li>用户进程有自己的地址空间(页表)</li>
<li>用户/内核内存空间由硬件隔离</li>
<li>每个用户线程有对应的内核线程</li>
<li>内核线程由 go runtime 提供的 goroutine 实现</li>
</ul>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ol>
<li>用户线程将参数保存在寄存器中</li>
<li>用户线程执行 <code>SYSENTER</code> 指令进入到系统内核</li>
<li>控制权转移到内核线程</li>
<li>内核线程执行系统调用, 通过 <code>SYSEXIT</code> 返回到用户空间</li>
</ol>
<h4 id="实现的挑战"><a href="#实现的挑战" class="headerlink" title="实现的挑战"></a>实现的挑战</h4><ul>
<li>在裸机上运行 Go runtime</li>
<li>使用 goroutines 运行不同应用程序</li>
<li>在临界区中的设备中断处理</li>
<li>最困难: 堆耗尽<ul>
<li>多数内核: 通过 <code>malloc()</code> 返回错误</li>
<li>Go 调用 <code>new</code> 分配对象, 总是成功</li>
</ul>
</li>
</ul>
<h4 id="堆耗尽的解决方法"><a href="#堆耗尽的解决方法" class="headerlink" title="堆耗尽的解决方法"></a>堆耗尽的解决方法</h4><h5 id="不合适的方法"><a href="#不合适的方法" class="headerlink" title="不合适的方法"></a>不合适的方法</h5><ul>
<li>报 panic</li>
<li>在内存分配器中等待 -&gt; 可能导致死锁</li>
<li>检测并处理无内存时返回的空指针</li>
</ul>
<h5 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h5><p>保留<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>. 在程序执行系统调用前调用 <code>reserve()</code> 函数预先保留足够内存(保留的内存通过算法分析得到)<br>优点:</p>
<ul>
<li>内核中没有检查</li>
<li>不用错误处理代码</li>
<li>没有死锁问题</li>
</ul>
<h3 id="选择-C-语言或-HLL-实现-OS"><a href="#选择-C-语言或-HLL-实现-OS" class="headerlink" title="选择 C 语言或 HLL 实现 OS"></a>选择 C 语言或 HLL 实现 OS</h3><ul>
<li>性能至关重要 -&gt; C 语言 (提升至少 15%)</li>
<li>最小化内存使用 -&gt; C 语言</li>
<li>安全至关重要 -&gt; HLL</li>
<li>性能不那么重要 -&gt; HLL</li>
</ul>
<h2 id="NetWork"><a href="#NetWork" class="headerlink" title="NetWork"></a>NetWork</h2><p>​        我们下面讨论网络与操作系统的联系。</p>
<p>​        网络的设计技巧就是对所有的实现经可能分层，这里我们不关心底层到底时如何实现交换机和主机的连接的。</p>
<p><img src="image-20240117093532849.png" alt="image-20240117093532849"></p>
<p>​        我们的网络链接大抵就是这样。</p>
<p>​        对于底层的实现我们可以看到：</p>
<p><img src="image-20240117093724533.png" alt="image-20240117093724533"></p>
<p>​        这是假设我们的两个主机正在通信：以太网协议实际上就是允许我们在通信的时候可以提供足够的信息。这里的地址就是MAC地址。</p>
<p><img src="image-20240117094203125.png" alt="image-20240117094203125"></p>
<p>​        这里就是ARP通信(地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议)</p>
<p><img src="image-20240117094656386.png" alt="image-20240117094656386"></p>
<p>​        很有趣的是,我们在事实上就是频繁的封装,每一个层都只是认为它所携带的前面的内容都是数据而不是其他的</p>
<p><img src="image-20240117094747091.png" alt="image-20240117094747091"></p>
<p><img src="image-20240117095145914.png" alt="image-20240117095145914"></p>
<p><img src="image-20240117095748588.png" alt="image-20240117095748588"></p>
<p>​        上图是一个常见的网络协议栈.我们就是这样转化和封装数据帧让然后发送的.</p>
<p>​        对于接受,操作系统注册了一个中断用于接收NIC网卡发送的数据,然后将之直接压入缓冲队列</p>
<p><img src="image-20240117095914255.png" alt="image-20240117095914255"></p>
<p>​        对于这样,如果自己就是目标主机,那么就会直接发送到上层,不是则会再次进入缓冲队列等待下一次发送.</p>
<h2 id="MeltDown"><a href="#MeltDown" class="headerlink" title="MeltDown"></a>MeltDown</h2><p>​        也就是安全Issue,,我们现在思考就是如何开展和防御攻击,从而更好的理解内核.</p>
<h3 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h3><p>核心代码</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">8192</span><span class="token punctuation">]</span>
r1 <span class="token operator">=</span> <span class="token operator">&lt;</span>a kernel virtual address<span class="token operator">></span>
r2 <span class="token operator">=</span> <span class="token operator">*</span>r1
r2 <span class="token operator">=</span> r2 <span class="token operator">&amp;</span> <span class="token number">1</span>
r2 <span class="token operator">=</span> r2 <span class="token operator">*</span> <span class="token number">4096</span>
r3 <span class="token operator">=</span> buf<span class="token punctuation">[</span>r2<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul>
<li>攻击者在内存中声明了一个缓冲区 <code>buf</code>, 这个缓冲区为普通的用户内存且可被正常访问.</li>
<li>攻击者拥有了内核中的一个虚拟内存地址, 其中包含了一些想要窃取的数据</li>
<li>这里的程序是 C 和汇编的混合. 第 3 行代码的意思是从这个内存地址取值出来并保存在寄存器 r2 中</li>
<li>第 4 行获取寄存器 r2 的低比特位, 所以此处这种特定的攻击只是从内核一个内存地址中读取一个比特</li>
<li>第 5 行将这个值乘以 4096, 因为低比特位要么是 1, 要么是 0, 所以这意味着 r2 要么是 4096, 要么是 0</li>
<li>第 6 行中读取前面申请的缓冲区, 要么读取位置 0, 要么读取位置 4096.</li>
</ul>
<h3 id="不能工作的原因"><a href="#不能工作的原因" class="headerlink" title="不能工作的原因"></a>不能工作的原因</h3><p>​        在大部分操作系统中, 内核内存会被完整映射到用户空间, 即所有内核的 PTE 都会出现在用户程序的页表中, 通过 PTE_U 等标志位来进行权限隔离, 使得用户代码不能直接访问内核内存地址.<br>​        因此, 第 3 行读取内核内存地址指向的数据是不被允许的, 会触发 Page Fault.</p>
<h3 id="攻击成功的关键"><a href="#攻击成功的关键" class="headerlink" title="攻击成功的关键"></a>攻击成功的关键</h3><h4 id="预测执行-Speculative-execution"><a href="#预测执行-Speculative-execution" class="headerlink" title="预测执行(Speculative execution)"></a>预测执行(Speculative execution)</h4><p>论文中称之为乱序执行(Out-of-order execution)</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">r0 <span class="token operator">=</span> <span class="token operator">&lt;</span>something<span class="token operator">></span>
r1 <span class="token operator">=</span> valid    <span class="token comment">// r1 is a  register; valid is in RAM</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>r1 <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
    r2<span class="token operator">=</span> <span class="token operator">*</span>r0
    r3 <span class="token operator">=</span> r2 <span class="token operator">+</span><span class="token number">1</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    r3 <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        代码第 2 行需要一个 load 指令将内存数据加载到寄存器, 会花费上百个时钟周期.<br>​        第 3 行代码是个 if 条件分支, CPU 会通过预测执行选择一个分支执行(在将 valid 实际加载到 r1 完成之前). 直到第 2 行代码执行完成后, CPU 再确定预测的分支是否正确, 若预测正确则继续执行, 若预测错误会回滚预测执行的代码.<br>CPU 的分支预测可能基于之前的分支选择.<br>​        若 r0 不是有效的指针, 超前执行到第 4 行时不会产生错误, 直到第 2 行代码运行完成, 因此错误的产生可能会延后数百个 CPU 周期.<br>​        确定一条指令是否正确的超前执行了而不是被抛弃了这个时间点, 对应的技术术语是 Retired.<br>​        在此例子中, CPU 进行了两个推测: 一个是 CPU 推测了 if 分支的走向, 并选择了一个分支提前执行; 除此之外, CPU 推测了代码第 4 行能够成功完成. 对于 load 指令, 如果数据在 CPU 缓存中且相应的 PTE 存在于页表, 不论当前代码是否有权限，Intel CPU 总是能将数据取出. 如果没有权限, 只有在代码第 4 行 Retired 时, 才会生成 Page Fault, 并导致预测执行被取消.<br>​        在论文中提到, Meltdown 发生在 Intel CPU 上而不会发生在 AMD 的 CPU 上. 普遍接受的观点是, AMD CPU 预测执行时在没有权限读取内存时, 不会将内存地址中的数据读出(即先进行了权限检查), 而 Intel CPU 则可以.</p>
<h4 id="CPU-缓存"><a href="#CPU-缓存" class="headerlink" title="CPU 缓存"></a>CPU 缓存</h4><p>CPU 包含 L1 缓存, L2 缓存等多级缓存.<br>当 CPU 执行 load/store 指令时, 首先会访问 L1 缓存. L1 缓存最快, 只需要几个 CPU 周期, 通过虚拟地址索引.<br>若地址不在 L1 缓存中, 则需要判断目标虚拟地址是否在 TLB 中记录, 若在, 便通过 L2 缓存获取数据. L2 缓存比 L1 缓存更大, 需要几十个 CPU 周期, 记录着物理地址.<br>若不在 L2 缓存最终会花费上百个 CPU 周期从内存中读取数据.<br><img src="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGVha0Nyb3NzZXI=,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br>        在一个多核 CPU 上, 每个 CPU 核会有一个 L1 缓存, 很小很快; 同时每个 CPU 核还有一个大一些的 L2 缓存; 此外通常还有一个共享的 L3 缓存. 另一种架构是, 所有的 L2 缓存结合起来, 所有 CPU 共享. 通常 L1 缓存是虚拟地址寻址, 而 L2 和 L3 缓存是物理地址寻址.<br><img src="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGVha0Nyb3NzZXI=,size_17,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"><br><img src="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGVha0Nyb3NzZXI=,size_16,color_FFFFFF,t_70,g_se,x_16-1705457168756-2.png" alt="在这里插入图片描述"></p>
<h3 id="Flush-Reload"><a href="#Flush-Reload" class="headerlink" title="Flush + Reload"></a>Flush + Reload</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>​        一段特定的代码是否使用了(被允许访问的)特定地址的内存</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p><img src="watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGVha0Nyb3NzZXI=,size_13,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p>
<ol>
<li>确保目标地址 x 不在缓存中. Intel 提供了指令 clFlush 用于刷新缓存确保接收的地址不在缓存中.</li>
<li>调用某段可能使用内存地址 x 的代码.</li>
<li>使用 rdtsc 指令记录时间(返回 CPU 启动后经过的 CPU 周期数).</li>
<li>加载内存地址 x 的数据到对象</li>
<li>再通过 rdtsc 指令读取时间. 若两次读取时间的差是个位数, 则第 2 步中使用了内存地址 x 的数据; 若读取时间的差值较大(超过 100), 则使用了内存地址 x.</li>
</ol>
<h3 id="熔断攻击"><a href="#熔断攻击" class="headerlink" title="熔断攻击"></a>熔断攻击</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">8192</span><span class="token punctuation">]</span>

<span class="token comment">// the Flush of Flush+Reload</span>
clflush buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
clflush buf<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span>

<span class="token operator">&lt;</span>some expensive instruction like divide<span class="token operator">></span>

r1 <span class="token operator">=</span> <span class="token operator">&lt;</span>a kernel virtual address<span class="token operator">></span>
r2 <span class="token operator">=</span> <span class="token operator">*</span>r1
r2 <span class="token operator">=</span> r2 <span class="token operator">&amp;</span> <span class="token number">1</span>     <span class="token comment">// speculated</span>
r2 <span class="token operator">=</span> r2 <span class="token operator">*</span> <span class="token number">4096</span>  <span class="token comment">// speculated</span>
r3 <span class="token operator">=</span> buf<span class="token punctuation">[</span>r2<span class="token punctuation">]</span>    <span class="token comment">// speculated</span>

<span class="token operator">&lt;</span>handle the page fault from <span class="token string">"r2=*r1"</span><span class="token operator">></span>

<span class="token comment">// the Reload of Flush+Reload</span>
a <span class="token operator">=</span> rdtsc
r0 <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
b <span class="token operator">=</span> rdtsc
r1 <span class="token operator">=</span> buf<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span>
c <span class="token operator">=</span> rdtsc
<span class="token keyword">if</span> b<span class="token operator">-</span>a <span class="token operator">&lt;</span> c<span class="token operator">-</span>b<span class="token operator">:</span>
    low bit was probably a <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>声明了一个缓冲区 <code>buf</code>, 现在从内核地址窃取 1 比特数据.</p>
<ol>
<li>首先 clflush 缓存中的数据.</li>
<li>执行费时的指令, 从而使得后续代码 CPU 可以预测执行</li>
<li>预测执行 10~13 行</li>
<li>由于第 10 行访问了不可访问的内核地址引发 page fault, 进入到下面的 page fault 处理程序</li>
<li>检测 buf[0] 和 buf[4096] 读取的 CPU 用时, 来判断内核地址的 1 比特数据.</li>
</ol>
<h3 id="Meltdown-修复"><a href="#Meltdown-修复" class="headerlink" title="Meltdown 修复"></a>Meltdown 修复</h3><h4 id="KAISER-KPTI"><a href="#KAISER-KPTI" class="headerlink" title="KAISER(KPTI)"></a>KAISER(KPTI)</h4><p>在 Linux 中称为 KPTI (Kernel page table isolation). <strong>不将内核内存映射到用户的页表中</strong>. 在执行系统调用时切换到拥有内核内存映射的另一个页表(类似 xv6).<br>缺点: 降低系统调用性能(需要切换页表, 同时导致 TLB , L1 缓存被清空).</p>
<h4 id="硬件修复"><a href="#硬件修复" class="headerlink" title="硬件修复"></a>硬件修复</h4><p>一般数据的权限标志位会在 L1 缓存中, 因此 CPU 可以在获取数据时检查权限标志位. 通过在<strong>更早的时间检测权限标识位</strong>保证预测执行指令不会访问到无权访问的数据.</p>
<h2 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h2><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=读写锁&amp;spm=1001.2101.3001.7020">读写锁</a></h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul>
<li><code>r_lock(&amp;l)</code></li>
<li><code>r_unlock(&amp;l)</code></li>
<li><code>w_lock(&amp;l)</code></li>
<li><code>w_unlock(&amp;l)</code></li>
</ul>
<p><strong>多个</strong>数据<strong>读取</strong>者可以获取读锁并发读, 但只能有<strong>一个</strong>数据<strong>写入</strong>者获取写锁.</p>
<h4 id="简要实现"><a href="#简要实现" class="headerlink" title="简要实现"></a>简要实现</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// A simplified version of Linux's read/write lock.</span>

<span class="token comment">// n=0   ->  not locked</span>
<span class="token comment">// n=-1  ->  locked by one writer</span>
<span class="token comment">// n>0   ->  locked by n readers</span>
<span class="token keyword">struct</span> <span class="token class-name">rwlock</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token function">r_lock</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">while</span> <span class="token number">1</span><span class="token operator">:</span>
        x <span class="token operator">=</span> l<span class="token operator">-></span>n
        <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">if</span> <span class="token function">CAS</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>l<span class="token operator">-></span>n<span class="token punctuation">,</span> x<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span>
            
<span class="token comment">// CAS(p, a, b) is atomic compare-and-swap instruction</span>
<span class="token comment">//    if *p == a, set *p = b, return true</span>
<span class="token comment">//    else return false</span>

<span class="token function">w_lock</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token keyword">while</span> <span class="token number">1</span><span class="token operator">:</span>
        <span class="token keyword">if</span> <span class="token function">CAS</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>l<span class="token operator">-></span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>```<br>rwlock<pre class="line-numbers language-none"><code class="language-none">
  结构体: 其中有一个计数器n

  - &#96;n&#96; 为 0 表示锁未被以任何形式持有
  - &#96;n&#96; 为 -1 表示被数据写入者持有写锁
  - &#96;n&#96; 大于 0, 表示有 n 个数据读取者持有读锁.

- &#96;r_lock()&#96;: 在循环中等待写入者释放锁(n&lt;0). 获取锁(n&gt;&#x3D;0)后对锁原子操作(CAS)加 1.
  CAS: Compare-and-swap.

- 多个 &#96;r_lock()&#96; 同时调用时只有其中 1 个 CAS 能够执行成功返回 1, 其余失败的将继续循环尝试执行 CAS.

- 该实现读取者优先, 读取者过多时写入者可能一直等待.

##### 性能问题

- 多个数据读取者同时调用 &#96;r_lock()&#96; 时, 都会读取技术 &#96;l-&gt;n&#96; 将其加载到 CPU 的 cache 并调用 CAS 指令修改计数值. 在多核 CPU 情况下, 只有一个 CAS 指令成功, 其它失败, 同时需要告知其它 CPU 的 cache 失效(让其它 CPU 核不缓存该数据, 称之为无效化, invalidation). 假设有 n 个读取者, 则每个 &#96;r_lock()&#96; 平均循环 n 2 \frac&#123;n&#125;&#123;2&#125;2n 次, 且每次循环涉及 O ( n ) O(n)O(n) 的 CPU 消息, 则**获取锁的成本为 \**O ( n 2 ) O(n^2)O(n2)\****.
- 读写锁将一个**只读操作变成了**需要修改锁的计数器 &#96;l-&gt;n&#96; 的**写操作**.

### RCU

RCU: Read Copy Update. 通过 RCU 通过数据写入者进行一些额外的规则和操作, 使得数据**读取者可以不使用任何锁**进行读取.

#### 基本实现

以单向链表为场景:
![在这里插入图片描述](a59919635f804723b5924f26a816d35b.png)
一个结点元素内容为字符串的单向链表. 涉及的写入操作有三种:

- 修改结点内容(字符串)
- 插入结点
- 删除结点

RCU **不能直接修改结点的内容**, 而是**创建并初始化一个新的结点**, 用新结点替换旧结点. 这样数据读取者永远不会看到一个正在修改的链表元素.
![在这里插入图片描述](4b6fd8971d644fdb9e467e4e221f8915.png)
旧结点 E2 和结点 E3 的指向关系不会删除, 因为更新指向新结点指针时, 可能有读取者读取到了 E2.
将 E1 的 next 指针从旧的结点 E2 切换到新的结点 E2 的过程, 被称为**提交写入**(committing write). **单个提交写入操作是原子的**. 以提交写入操作的完成为分界, 读取者要么要么读取的是旧元素, 要么读取的新元素.
RCU 主要用于具备单个写入提交操作的数据结构上. 如双向链表则对 RCU 不太友好, 而树(无父指针)对于 RCU 是友好的.
![在这里插入图片描述](watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUGVha0Nyb3NzZXI&#x3D;,size_11,color_FFFFFF,t_70,g_se,x_16.png)

#### 内存屏障

编译器和 CPU 都会重排指令, 需要使用内存屏障(barrier)以防止指令重排.
![在这里插入图片描述](0e3d8a3abcd848e4bf05ee1dea32f1e5.png)
读取者和写入者都需要使用内存屏障:

- 数据写入者: 在**提交写入(committing write)操作之前加入内存屏障**, 以确保完成提交写入时, 元素已完全初始化.
  ![在这里插入图片描述](3e6c8cf65c0946cb972c05b579c38cdd.png)
- 数据读取者: 在**读取了结点的指针后, 读取指针指向的内容之前加入内存屏障**.(此处可能是避免指针的值被先前缓存等情况, 课程中也未讲清楚).
  ![在这里插入图片描述](c8a7923b47734dbb8844f6997aff12c3.png)

#### 旧元素释放

对于旧元素在被替换后释放的时机.

##### GC

对于带有 GC(垃圾回收)的编程语言可以无需考虑该问题, 由 GC 进行元素释放.

##### 延迟冻结(Delaying Freeze)

对于无 GC 的情况(如 Linux 系统), 读写规则如下:

- 数据读取者: **不允许在线程切换的上下文切换时持有 RCU 保护的数据**, 即数据**读取者不能在 RCU 的临界区内出让 CPU**.
- 数据写入者: 在每个 CPU 核至少执行过一次上下文切换后再释放元素(每个核都进行过上下文切换则没有核还持有该元素).

![在这里插入图片描述](f19095cb3d7c42c3a8ffe09e0acc9a1e.png)
数据写入者的代码:

&#96;&#96;&#96;c
E1-&gt;next &#x3D; e;
synchronize_rcu();
free(old);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<ol>
<li>首先完成对数据的修改</li>
<li>调用 <code>synchronize_rcu()</code> 已迫使每个 CPU 核发送一次上下文切换, 这也确保没有 CPU 核再持有指向旧元素的指针</li>
<li>释放旧元素</li>
</ol>
<ul>
<li>该情况写入者需要等待 <code>synchronize_rcu()</code> 进行上下文切换.</li>
<li>使用 <code>call_rcu()</code> 可以立刻返回. 该函数参数为待释放的对象和执行释放的回调函数. RCU 系统会将这两个参数存入一个列表, 并立刻返回. 在后台 RCU 系统会检查每个 CPU 核的上下文切换计数, 当每个核都发生过上下文切换后, 调用回调函数进行对象的释放. 缺点是大量调用该函数, 参数列表会很长占用大量内存导致内存耗尽.</li>
</ul>
<h4 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// list reader:</span>

<span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
e <span class="token operator">=</span> head
<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    e <span class="token operator">=</span> <span class="token function">rcu_dereference</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    look at e<span class="token operator">-></span>x <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    e <span class="token operator">=</span> e<span class="token operator">-></span>next
<span class="token punctuation">&#125;</span>
<span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>数据读取位于 <code>rcu_read_lock()</code> 和 <code>rcu_read_unlock()</code> 之间. 这两个函数值<strong>设置一个标志位来阻止定时器中断导致的线程上下文切换</strong>(中断还会发生, 但不切换上下文).<br>这里的<strong>标志位是每个 CPU 独有的数据</strong>, 而不是所有 CPU 共享, 因此不会引起 CPU 间的缓存一致消息.</li>
<li><code>rcu_dereference()</code> 函数会插入内存屏障. 首先会从内存中拷贝 <code>e</code>, 触发一个内存屏障, 之后返回指向 <code>e</code> 的指针. 之后就可读取 <code>e</code> 指针指向的数据内容, 并走向下一个链表元素.</li>
<li>数据读取代码值, <strong>不能将链表元素返回(包括指针以及字符串内容), 以避免访问过程中触发上下文切换, 只能返回元素的拷贝</strong>.</li>
<li>数据读取几乎无额外开销, 仅标志位设置和内存屏障有少量开销, 读取速度很快.</li>
</ul>
<h4 id="数据写入"><a href="#数据写入" class="headerlink" title="数据写入"></a>数据写入</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// replace the first list element:</span>
<span class="token function">acquire</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span>
old <span class="token operator">=</span> head
e <span class="token operator">=</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
e<span class="token operator">-></span>x <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
e<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next
<span class="token function">rcu_assign_pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>head<span class="token punctuation">,</span>e<span class="token punctuation">)</span>
<span class="token function">release</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span>

<span class="token function">synchronize_rcu</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">free</span><span class="token punctuation">(</span>old<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>此处使用自旋锁(<code>spinlock</code>)避免数据写入者之间的竞争.</li>
<li>通过 <code>old</code> 保存待释放的结点</li>
<li>使用 <code>alloc()</code> 分配并初始化一个新的结点元素</li>
<li><code>rcu_assign_pointer()</code> 函数会设置一个内存屏障, 以确保之前的所有写操作都执行完成, 再将 <code>head</code> 指向新分配的链表元素 <code>e</code></li>
<li>释放自旋锁后, 调用 <code>synchronize_rcu()</code> 确保任何一个可能持有了旧的链表元素的 CPU 都执行一次上下文切换</li>
<li>最后释放旧链表元素</li>
</ol>
<p>​        数据写入性能很差. 因为有了非常耗时的 <code>synchronize_rcu()</code> 函数调用.</p>
<h4 id="RCU的总结"><a href="#RCU的总结" class="headerlink" title="RCU的总结"></a>RCU的总结</h4><ul>
<li>适用于读操作远多于写操作的情况</li>
<li>直接应用 RCU 的数据结构在更新时<strong>需要能支持单个提交写入操作</strong>(如单向链表, 树).</li>
<li>RCU <strong>不能原地更新数据</strong>, 而是使用一个新元素进行替代.</li>
<li>RCU <strong>不能保证数据读取者一定读取的是新的数据</strong>, 即数据读取者可能读取到更新前的旧数据.</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2024/01/17/MITS6081-Notes/">http://charliechen114514.github.io/2024/01/17/MITS6081-Notes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Operating-System/">Operating System</a><a class="post-meta__tags" href="/tags/Assembly/">Assembly</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/18/MissingClassInCS/" title="MissingClassInCS"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MissingClassInCS</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/" title="Cpp异常处理与并发编程简单笔记"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Cpp异常处理与并发编程简单笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%98%E5%8E%9F%E7%9C%9F%E7%9B%B8%EF%BC%88%E8%B6%85%E9%95%BF%E8%AE%B0%E5%BD%95%E7%89%88%EF%BC%89/" title="操作系统还原真相（超长记录版）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-25</div><div class="title">操作系统还原真相（超长记录版）</div></div></a></div><div><a href="/2024/01/15/xv6%E9%80%9F%E9%80%9A/" title="xv6速通"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-15</div><div class="title">xv6速通</div></div></a></div><div><a href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_RecursionSpecial</div></div></a></div><div><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_in_C(1)</div></div></a></div><div><a href="/2024/01/09/2024%E5%AF%92%E5%81%87%E6%95%B4%E6%B4%BB-C-Cppb%E9%AB%98%E7%BA%A7%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/" title="2024寒假整活_C_Cppb高级编译技术"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-09</div><div class="title">2024寒假整活_C_Cppb高级编译技术</div></div></a></div><div><a href="/2023/12/03/C-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%93%8D%E4%BD%9C%E6%89%93%E5%8D%B0tuple/" title="C++使用模板操作打印tuple"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="title">C++使用模板操作打印tuple</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MIT-6-S081"><span class="toc-number">1.</span> <span class="toc-text">MIT 6.S081</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E8%BA%AB"><span class="toc-number">1.2.</span> <span class="toc-text">热身</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ISOLATION-%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">ISOLATION:隔离性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kernel-mode-%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">Kernel mode 内核模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Table%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">Page Table页表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCB%EF%BC%88trust-computing-base%EF%BC%89%E5%8F%AF%E4%BF%A1%E4%BB%BB%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.6.</span> <span class="toc-text">TCB（trust computing base）可信任编程基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Tables-and-Virtual-Memory"><span class="toc-number">1.7.</span> <span class="toc-text">Page Tables and Virtual Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E9%80%9F%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.8.</span> <span class="toc-text">光速复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.8.2.</span> <span class="toc-text">二、调试过程介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B7%E4%BD%93%E8%B0%83%E8%AF%95%E7%A4%BA%E4%BE%8B%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.8.3.</span> <span class="toc-text">三、具体调试示例讲解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ERISC-V%E5%92%8C%E6%B1%87%E7%BC%96"><span class="toc-number">1.9.</span> <span class="toc-text">关于RISC-V和汇编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-number">1.10.</span> <span class="toc-text">堆栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MIT-S081-9-Page-Fault"><span class="toc-number">2.</span> <span class="toc-text">MIT S081 9 Page Fault</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sbrk"><span class="toc-number">2.1.</span> <span class="toc-text">sbrk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Copy-on-write-fork"><span class="toc-number">2.2.</span> <span class="toc-text">Copy-on-write fork</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Demand-Paging"><span class="toc-number">2.3.</span> <span class="toc-text">Demand Paging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap"><span class="toc-number">2.4.</span> <span class="toc-text">mmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">2.5.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%88%91%E4%BB%AC%E7%9A%84%E9%94%81"><span class="toc-number">2.6.</span> <span class="toc-text">抽象我们的锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%94%81"><span class="toc-number">2.7.</span> <span class="toc-text">什么时候用锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%98%AF%E5%90%A6%E8%87%AA%E5%8A%A8"><span class="toc-number">2.8.</span> <span class="toc-text">锁是否自动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">2.9.</span> <span class="toc-text">锁的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E4%BC%9A%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.</span> <span class="toc-text">锁会产生的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hints"><span class="toc-number">2.11.</span> <span class="toc-text">Hints</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Threads"><span class="toc-number">2.12.</span> <span class="toc-text">Threads</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">2.13.</span> <span class="toc-text">进程切换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Threads-1"><span class="toc-number">3.</span> <span class="toc-text">Threads</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2-1"><span class="toc-number">3.1.</span> <span class="toc-text">进程切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File-System"><span class="toc-number">3.2.</span> <span class="toc-text">File System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84API"><span class="toc-number">3.2.1.</span> <span class="toc-text">一些常见的API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E5%92%8C%E7%BB%93%E6%9E%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.2.</span> <span class="toc-text">文件系统的层次和结构问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#inode"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">inode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fd"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">fd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">3.2.3.</span> <span class="toc-text">存储设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">3.3.</span> <span class="toc-text">文件夹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">3.4.</span> <span class="toc-text">写入文件可能发生了什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Crash-Recovery"><span class="toc-number">4.</span> <span class="toc-text">Crash Recovery</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recovery-in-Linux-Ext3"><span class="toc-number">5.</span> <span class="toc-text">Recovery in Linux Ext3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-Memory-in-User-Application"><span class="toc-number">5.1.</span> <span class="toc-text">Virtual Memory in User Application</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OS%E5%86%85%E6%A0%B8%E5%B1%82%E6%AC%A1"><span class="toc-number">5.2.</span> <span class="toc-text">OS内核层次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%86%85%E6%A0%B8"><span class="toc-number">5.2.1.</span> <span class="toc-text">宏内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">5.2.2.</span> <span class="toc-text">微内核</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">5.3.</span> <span class="toc-text">虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%B8%8E%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">5.4.</span> <span class="toc-text">内核与高级编程语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-OS"><span class="toc-number">5.4.1.</span> <span class="toc-text">使用 C 语言实现 OS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-HLLs-%E5%AE%9E%E7%8E%B0-OS"><span class="toc-number">5.4.2.</span> <span class="toc-text">使用高级编程语言(HLLs)实现 OS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E8%83%8C%E6%99%AF"><span class="toc-number">5.4.3.</span> <span class="toc-text">论文背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%9A%84%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80"><span class="toc-number">5.4.4.</span> <span class="toc-text">选择的高级语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Biscuit"><span class="toc-number">5.4.5.</span> <span class="toc-text">Biscuit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">5.4.5.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">5.4.5.2.</span> <span class="toc-text">用户程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">5.4.5.3.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">5.4.5.4.</span> <span class="toc-text">实现的挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E8%80%97%E5%B0%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.5.5.</span> <span class="toc-text">堆耗尽的解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%88%E9%80%82%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.4.5.5.1.</span> <span class="toc-text">不合适的方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.4.5.5.2.</span> <span class="toc-text">最终解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-C-%E8%AF%AD%E8%A8%80%E6%88%96-HLL-%E5%AE%9E%E7%8E%B0-OS"><span class="toc-number">5.4.6.</span> <span class="toc-text">选择 C 语言或 HLL 实现 OS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NetWork"><span class="toc-number">5.5.</span> <span class="toc-text">NetWork</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MeltDown"><span class="toc-number">5.6.</span> <span class="toc-text">MeltDown</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81"><span class="toc-number">5.6.1.</span> <span class="toc-text">第一段代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">5.6.2.</span> <span class="toc-text">基本流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.6.3.</span> <span class="toc-text">不能工作的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%88%90%E5%8A%9F%E7%9A%84%E5%85%B3%E9%94%AE"><span class="toc-number">5.6.4.</span> <span class="toc-text">攻击成功的关键</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E6%B5%8B%E6%89%A7%E8%A1%8C-Speculative-execution"><span class="toc-number">5.6.4.1.</span> <span class="toc-text">预测执行(Speculative execution)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPU-%E7%BC%93%E5%AD%98"><span class="toc-number">5.6.4.2.</span> <span class="toc-text">CPU 缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flush-Reload"><span class="toc-number">5.6.5.</span> <span class="toc-text">Flush + Reload</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">5.6.5.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.6.5.2.</span> <span class="toc-text">步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%86%94%E6%96%AD%E6%94%BB%E5%87%BB"><span class="toc-number">5.6.6.</span> <span class="toc-text">熔断攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Meltdown-%E4%BF%AE%E5%A4%8D"><span class="toc-number">5.6.7.</span> <span class="toc-text">Meltdown 修复</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KAISER-KPTI"><span class="toc-number">5.6.7.1.</span> <span class="toc-text">KAISER(KPTI)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%BF%AE%E5%A4%8D"><span class="toc-number">5.6.7.2.</span> <span class="toc-text">硬件修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RCU"><span class="toc-number">5.7.</span> <span class="toc-text">RCU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">5.7.1.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.7.1.2.</span> <span class="toc-text">简要实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="toc-number">5.7.1.3.</span> <span class="toc-text">数据读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5"><span class="toc-number">5.7.1.4.</span> <span class="toc-text">数据写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RCU%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">5.7.1.5.</span> <span class="toc-text">RCU的总结</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/MissingClassInCS/" title="MissingClassInCS"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MissingClassInCS"/></a><div class="content"><a class="title" href="/2024/01/18/MissingClassInCS/" title="MissingClassInCS">MissingClassInCS</a><time datetime="2024-01-18T02:18:25.000Z" title="发表于 2024-01-18 10:18:25">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/17/MITS6081-Notes/" title="MITS6081 Notes"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MITS6081 Notes"/></a><div class="content"><a class="title" href="/2024/01/17/MITS6081-Notes/" title="MITS6081 Notes">MITS6081 Notes</a><time datetime="2024-01-17T02:28:48.000Z" title="发表于 2024-01-17 10:28:48">2024-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/" title="Cpp异常处理与并发编程简单笔记"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cpp异常处理与并发编程简单笔记"/></a><div class="content"><a class="title" href="/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/" title="Cpp异常处理与并发编程简单笔记">Cpp异常处理与并发编程简单笔记</a><time datetime="2024-01-16T12:15:37.000Z" title="发表于 2024-01-16 20:15:37">2024-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/16/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-3/" title="重新学习Linux系统编程-3"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重新学习Linux系统编程-3"/></a><div class="content"><a class="title" href="/2024/01/16/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-3/" title="重新学习Linux系统编程-3">重新学习Linux系统编程-3</a><time datetime="2024-01-16T05:17:44.000Z" title="发表于 2024-01-16 13:17:44">2024-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%A6%82%E8%AE%BA/" title="计算机网络笔记概论"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络笔记概论"/></a><div class="content"><a class="title" href="/2024/01/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%A6%82%E8%AE%BA/" title="计算机网络笔记概论">计算机网络笔记概论</a><time datetime="2024-01-16T05:17:18.000Z" title="发表于 2024-01-16 13:17:18">2024-01-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>