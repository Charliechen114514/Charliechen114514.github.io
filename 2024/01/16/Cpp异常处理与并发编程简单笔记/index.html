<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Cpp异常处理与并发编程简单笔记 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++ 新特性学习异常处理 Exception Handle​        我们简单的聊聊异常处理先： ​        C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。  throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch:">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp异常处理与并发编程简单笔记">
<meta property="og:url" content="http://charliechen114514.github.io/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="C++ 新特性学习异常处理 Exception Handle​        我们简单的聊聊异常处理先： ​        C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。  throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2024-01-16T12:15:37.000Z">
<meta property="article:modified_time" content="2024-01-16T12:16:26.836Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Cpp异常处理与并发编程简单笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-16 20:16:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Cpp异常处理与并发编程简单笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-16T12:15:37.000Z" title="发表于 2024-01-16 20:15:37">2024-01-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-16T12:16:26.836Z" title="更新于 2024-01-16 20:16:26">2024-01-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Cpp异常处理与并发编程简单笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-新特性学习"><a href="#C-新特性学习" class="headerlink" title="C++ 新特性学习"></a>C++ 新特性学习</h1><h2 id="异常处理-Exception-Handle"><a href="#异常处理-Exception-Handle" class="headerlink" title="异常处理 Exception Handle"></a>异常处理 Exception Handle</h2><p>​        我们简单的聊聊异常处理先：</p>
<p>​        C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p>
<ul>
<li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li>
<li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li>
<li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void handleError()&#123;
    try
    &#123;
        try &#123;
            &#x2F;&#x2F; do sth
            &#x2F;&#x2F; and sth bad occurred
            throw &quot;An error occurred!&quot;;
            &#x2F;&#x2F; ... do other things then

        &#125;
        catch (const char *exceptionWord) &#123;
            std::cerr &lt;&lt; exceptionWord;
            throw 114;
        &#125; catch (int &amp;errorCode) &#123;
            std::cerr &lt;&lt; &quot;So we get the error code:&gt; &quot; &lt;&lt; errorCode;
            &#x2F;&#x2F; throw std::exception();
        &#125; catch (std::exception &amp;e) &#123; ; &#x2F;&#x2F; do nothing
        &#125;
    &#125;catch(int&amp; errorCode)&#123;
        std::cerr &lt;&lt; &quot;So we get the error code:&gt; &quot; &lt;&lt; errorCode;
        &#x2F;&#x2F; throw std::exception();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        如你所见，这就是一个复杂的处理异常的代码，我们分析来看，无非就是</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">try&#123;
	&#x2F;&#x2F; handle sthh
    throw Exception
&#125;catch(Exception&amp; e)&#123;
    &#x2F;&#x2F; handle with e
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        一段代码内，可能会抛出不同类型的异常，举一个例子：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isParam1Unfit(const char* para1);
bool isParam2Unfit(int&amp; code);
bool isParam3Unfit(Product&amp; pro);

void checkVadility(const char* para1, int&amp; code, Product&amp; pro)
try&#123;
	if(isParam1Unfit(para1))&#123;
        throw para1;
    &#125;
    else if(isParam2Unfit(code))&#123;
        throw code;
    &#125;
    else if(isParam3Unfit(pro))&#123;
        throw pro;
    &#125;
    catch(const char* e1)&#123;
        &#x2F;&#x2F; handle e1;
    &#125;
    catch(int&amp; e2)&#123;
        &#x2F;&#x2F; handle e2
    &#125;
    catch(Product&amp; e3)&#123;
        &#x2F;&#x2F; handle e3
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        当然这样写很不规范，但是在这里我意在说明一件事情：那就是我们可以抛出任何类型的异常，对于这些异常，我们进入对应类型的catch模块处理。（抽象的讲：就是不同类型的错误不同处理）</p>
<blockquote>
<p><code>catch(...)</code>表示的是接受任何异常，无论是什么类型的！往往我们可以在这里处理<strong>“任何其他未知的异常”</strong></p>
</blockquote>
<p>​        合理的使用这段代码的办法是：定义一个基于std::exception的我们的自己的异常。我们改造上面的代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool isParam1Unfit(const char* para1);
bool isParam2Unfit(int&amp; code);
bool isParam3Unfit(Product&amp; pro);

class NameException : public std::exception
&#123;
	public:
    	const char* what()&#123;
            return &quot;name error&quot;;
        &#125;
&#125;

class CodeException : public std::exception
&#123;
	public:
    	const char* what()&#123;
            return &quot;code error&quot;;
        &#125;
&#125;

class ProductUnfitException : : public std::exception
&#123;
	public:
    	const char* what()&#123;
            return &quot;product error&quot;;
        &#125;
&#125;

void checkVadility(const char* para1, int&amp; code, Product&amp; pro)
try&#123;
	if(isParam1Unfit(para1))&#123;
        throw NameException();
    &#125;
    else if(isParam2Unfit(code))&#123;
        throw CodeException();
    &#125;
    else if(isParam3Unfit(pro))&#123;
        throw ProductUnfitException();
    &#125;
&#125;    
catch(const NameException&amp; e1)&#123;
    std::cerr &lt;&lt; e1.what();
&#125;
catch(const CodeException&amp; e2)&#123;
    std::cerr &lt;&lt; e2.what();
&#125;
catch(const ProductUnfitException&amp; e3)&#123;
    std::cerr &lt;&lt; e3.what();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到，我们的代码一旦走到<code>throw</code>就会跳转到对应的catch处理模块。而我们的处理模块就需要尽可能的完成我们的异常处理工作。反之，本级代码无法处理着将会传递给上一级调用端去处理。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void handleError()&#123;
    try
    &#123;
        try &#123;
            &#x2F;&#x2F; do sth
            &#x2F;&#x2F; and sth bad occurred
            throw &quot;An error occurred!&quot;;
            &#x2F;&#x2F; ... do other things then

        &#125;
        catch (const char *exceptionWord) &#123;
            std::cerr &lt;&lt; exceptionWord;
            throw 114;
        &#125; catch (int &amp;errorCode) &#123;
            std::cerr &lt;&lt; &quot;So we get the error code:&gt; &quot; &lt;&lt; errorCode;
            &#x2F;&#x2F; throw std::exception();
        &#125; catch (std::exception &amp;e) &#123; ; &#x2F;&#x2F; do nothing
        &#125;
    &#125;catch(int&amp; errorCode)&#123;
        std::cerr &lt;&lt; &quot;So we get the error code:&gt; &quot; &lt;&lt; errorCode;
        &#x2F;&#x2F; throw std::exception();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        以这个代码为例，我们的内部异常就会抛出一个<code>const char*</code>类型的异常，转向到内部的异常处理之后再次抛出一个int类型的异常。现在，他就会外溢int类型的error到外部，然后被外部的：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">catch(int&amp; errorCode)&#123;
        std::cerr &lt;&lt; &quot;So we get the error code:&gt; &quot; &lt;&lt; errorCode;
        &#x2F;&#x2F; throw std::exception();
        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        接住。</p>
<p><img src="image-20240116182203834.png" alt="image-20240116182203834"></p>
<p>​        这就是结果。</p>
<p>​        那些没有被handle的exception回外溢到最外层。C++默认的处理方式是调用std::terminate，但后就是std::exit退出部分。</p>
<h2 id="并发编程基础"><a href="#并发编程基础" class="headerlink" title="并发编程基础"></a>并发编程基础</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>​        我们下面速通并发（不是）</p>
<p>​        很简单，我们可以简单的认为一个线程跑的是一个任务，所以，对于一个简单的线程，实质上传递一个（仿）函数就可以。</p>
<p>​        我们举一个例子，算质数的例子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
class PrimeProducer
&#123;
public:
    PrimeProducer() &#x3D; delete;
    PrimeProducer(int bounding_low, int boundingHigh):m_high(boundingHigh),m_low(bounding_low)&#123;&#125;;

    void getPrime()&#123;
        for(int i &#x3D; m_low; i &lt;&#x3D; m_high; i++)
            if(isPrime(i))
                std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        std::cout &lt;&lt; &quot;\n&quot;;
    &#125;

    void operator()()&#123;
        getPrime();
    &#125;

private:
    bool isPrime(int cur)
    &#123;
        for(int i &#x3D; 2; i &lt;&#x3D; std::sqrt(cur); i++)
        &#123;
            if(cur % i &#x3D;&#x3D; 0)
            &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;

    int m_low &#x3D; 2;
    int m_high &#x3D; 2;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        代码并不复杂，就是打印质数</p>
<pre class="line-numbers language-none"><code class="language-none">PrimeProducer(2, 100)();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们这样就完成了一个任务的封装。这种形式是仿函数的。</p>
<p>​        那么，现在我们就用线程来完成任务</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
std::vector&lt;int&gt; primes;

void showResult()&#123;
    for(const auto&amp; it : primes)&#123;
        std::cout &lt;&lt; it &lt;&lt; &quot; &quot;;
    &#125;
    std::cout &lt;&lt; &quot;\n&quot;;
&#125;

class PrimeProducer
&#123;
public:
    PrimeProducer() &#x3D; delete;
    PrimeProducer(int bounding_low, int boundingHigh):m_high(boundingHigh),m_low(bounding_low)&#123;&#125;;

    void getPrime()&#123;
        for(int i &#x3D; m_low; i &lt;&#x3D; m_high; i++)
            if(isPrime(i)) &#123;
                &#x2F;&#x2F;std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
                primes.push_back(i);
            &#125;
        &#x2F;&#x2F;std::cout &lt;&lt; &quot;\n&quot;;
    &#125;

    void operator()()&#123;
        getPrime();
    &#125;

private:
    bool isPrime(int cur)
    &#123;
        if(cur &lt;&#x3D; 1)
            return false;
        for(int i &#x3D; 2; i &lt;&#x3D; std::sqrt(cur); i++)
        &#123;
            if(cur % i &#x3D;&#x3D; 0)
            &#123;
                return false;
            &#125;
        &#125;
        return true;
    &#125;

    int m_low &#x3D; 2;
    int m_high &#x3D; 2;
&#125;;


int main()
&#123;
    std::thread pools[3];
    int boundLow &#x3D; 1;
    int boundHigh &#x3D; 100;
    for(auto&amp; each_thread : pools)
    &#123;
        each_thread &#x3D; std::thread(PrimeProducer(boundLow, boundHigh));
        boundHigh +&#x3D; 100;
        boundLow +&#x3D; 100;
    &#125;

    for(auto&amp; each_thread : pools)
    &#123;
        each_thread.join();
    &#125;

    showResult();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        先别急啥意思，我先贴一个：</p>
<p>​        std::thread就是我们的线程对象， 它在 <code>&lt;thread&gt;</code> 头文件中声明</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;thread&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        说的就是这个事情。</p>
<h4 id="std-thread-构造"><a href="#std-thread-构造" class="headerlink" title="std::thread 构造"></a>std::thread 构造</h4><div class="table-container">
<table>
<thead>
<tr>
<th>构造函数</th>
<th>声明</th>
</tr>
</thead>
<tbody>
<tr>
<td>default</td>
<td><code>thread() noexcept;</code></td>
</tr>
<tr>
<td>initialization</td>
<td><code>template &lt;class Fn, class... Args&gt; explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;... args);</code></td>
</tr>
<tr>
<td>copy [deleted]</td>
<td><code>thread (const thread&amp;) = delete;</code></td>
</tr>
<tr>
<td>move</td>
<td><code>thread (thread&amp;&amp; x) noexcept;</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>默认构造函数，创建一个空的 thread 执行对象。这个时候，由于没有任务可以执行，他不会做出任何事情。</li>
<li>初始化构造函数，创建一个 thread对象，该thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。</li>
<li>拷贝构造函数(被禁用)，意味着 thread 不可被拷贝构造。</li>
<li>move 构造函数，move 构造函数，调用成功之后 x 不代表任何 thread 执行对象。</li>
<li>注意：可被 joinable 的 thread 对象必须在他们销毁之前被主线程 join 或者将其设置为 detached.</li>
</ul>
<h4 id="move-赋值操作"><a href="#move-赋值操作" class="headerlink" title="move 赋值操作"></a>move 赋值操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th>move</th>
<th><code>thread&amp; operator= (thread&amp;&amp; rhs) noexcept;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>copy [deleted]</td>
<td><code>thread&amp; operator= (const thread&amp;) = delete;</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>move 赋值操作，如果当前对象不可 joinable，需要传递一个右值引用(rhs)给 move 赋值操作；如果当前对象可被 joinable，则 terminate() 报错。</li>
<li>拷贝赋值操作被禁用，thread 对象不可被拷贝。</li>
</ul>
<p>​        也就是说，我们这里的：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">each_thread &#x3D; std::thread(PrimeProducer(boundLow, boundHigh));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        其实做的是移动操作。</p>
<p>​        那么，join和detach是啥意思呢？join表示的是发出后在这句调用的位置线程要结束运行，父进程才不会被阻塞，否则就等待到子进程结束运行，detach就是让他放飞自我，一般而言不会对裸的任务直接detach，不确定性太大了。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>​        这个使用于那些必须要求我们原子性访问变量的部分。</p>
<p>​        话说的有点抽象，我们就来跑一下上面的程序，这次我们把gap拉大来：</p>
<p><img src="image-20240116192428592.png" alt="image-20240116192428592"></p>
<p>​        崩溃了？为什么呢？我们一开debug来看看：</p>
<p><img src="image-20240116192457868.png" alt="image-20240116192457868"></p>
<p>​        检查调用栈，马上就可以猜出问题了！那就是多个进程之间发生了向同一个位置push_back，马上就会出现问题。这是因为STL事实上不提供任何强度的线程安全！我们需要做一些措施，保证我们的插入是原子性的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; ...
    void getPrime()&#123;
        mtx.lock();
        for(int i &#x3D; m_low; i &lt;&#x3D; m_high; i++)
            if(isPrime(i)) &#123;
                &#x2F;&#x2F;std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
                primes.push_back(i);
            &#125;
        &#x2F;&#x2F;std::cout &lt;&lt; &quot;\n&quot;;
        mtx.unlock();
    &#125;
&#x2F;&#x2F;&#x2F; 。。。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        你看到了实际上就是对全局变量开锁。维护住锁了才可以</p>
<p>简单看看互斥量的种类：</p>
<h4 id="Mutex-系列类-四种"><a href="#Mutex-系列类-四种" class="headerlink" title="Mutex 系列类(四种)"></a>Mutex 系列类(四种)</h4><ul>
<li>std::mutex，最基本的 Mutex 类。</li>
<li>std::recursive_mutex，递归 Mutex 类。</li>
<li>std::time_mutex，定时 Mutex 类。</li>
<li>std::recursive_timed_mutex，定时递归 Mutex 类。</li>
</ul>
<h4 id="Lock-类（两种）"><a href="#Lock-类（两种）" class="headerlink" title="Lock 类（两种）"></a>Lock 类（两种）</h4><ul>
<li>std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。</li>
<li>std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li>
</ul>
<h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><ul>
<li>std::once_flag</li>
<li>std::adopt_lock_t</li>
<li>std::defer_lock_t</li>
<li>std::try_to_lock_t</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li>std::try_lock，尝试同时对多个互斥量上锁。（注意锁不上就不锁了！）</li>
<li>std::lock，可以同时对多个互斥量上锁。</li>
<li>std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。</li>
</ul>
<p>下面以 std::mutex 为例介绍 C++11 中的互斥量用法。</p>
<p>​        std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p>
<h4 id="std-mutex-的成员函数"><a href="#std-mutex-的成员函数" class="headerlink" title="std::mutex 的成员函数"></a>std::mutex 的成员函数</h4><ul>
<li>构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。</li>
<li>lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
<li>unlock()， 解锁，释放对互斥量的所有权。</li>
<li>try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span>
std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span>           <span class="token comment">// locks access to counter</span>
<span class="token keyword">volatile</span> <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">addCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        counter<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
        mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    std<span class="token operator">::</span>thread pool<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span> i <span class="token operator">:</span> pool<span class="token punctuation">)</span>
        i <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span>addCounter<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span> i <span class="token operator">:</span> pool<span class="token punctuation">)</span>
        i<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> counter<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="lock详解"><a href="#lock详解" class="headerlink" title="lock详解"></a>lock详解</h3><p>C++11 标准为我们提供了两种基本的锁类型，分别如下：</p>
<ul>
<li>std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。</li>
<li>std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li>
</ul>
<p>另外还提供了几个与锁类型相关的 Tag 类，分别如下:</p>
<ul>
<li><code>std::adopt_lock_t，一个空的标记类，定义如下：</code></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">struct adopt_lock_t &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 该类型的常量对象adopt_lock（adopt_lock 是一个常量对象，定义如下</p>
<pre class="line-numbers language-none"><code class="language-none">constexpr&#96; &#96;adopt_lock_t adopt_lock &#123;&#125;;，&#96;&#96;&#x2F;&#x2F; constexpr 是 C++11 中的新关键字）
通常作为参数传入给 unique_lock 或 lock_guard 的构造函数。 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><code>std::defer_lock_t</code>一个空的标记类，定义如下：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">struct defer_lock_t &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 该类型的常量对象<code>defer_lock</code>是一个常量对象，定义如下：</p>
<pre class="line-numbers language-none"><code class="language-none">constexpr&#96; &#96;defer_lock_t defer_lock &#123;&#125;;，&#96;&#96;&#x2F;&#x2F; constexpr 是 C++11 中的新关键字）, 通常作为参数传入给 unique_lock 或 lock_guard 的构造函数。 
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>std::try_to_lock_t</code>，一个空的标记类，定义如下：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">struct try_to_lock_t &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该类型的常量对象  <code>try_to_lock</code>是一个常量对象，定义如下：</p>
<pre class="line-numbers language-none"><code class="language-none">constexpr try_to_lock_t try_to_lock &#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>通常作为参数传入给 unique_lock 或 lock_guard 的构造函数。</code>后面我们会详细介绍以上三种 Tag 类型在配合 lock_gurad 与 unique_lock 使用时的区别。</p>
<h4 id="std-lock-guard-介绍"><a href="#std-lock-guard-介绍" class="headerlink" title="std::lock_guard 介绍"></a>std::lock_guard 介绍</h4><p>std::lock_gurad 是 C++11 中定义的模板类。定义如下：</p>
<pre class="line-numbers language-none"><code class="language-none">template &lt;class Mutex&gt;
class lock_guard;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        lock_guard 对象通常用于管理某个锁(Lock)对象，因此与 Mutex RAII 相关，方便线程对互斥量上锁，即在某个 lock_guard 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 lock_guard 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 shared_ptr 等智能指针管理动态分配的内存资源 )。</p>
<p>​        模板参数 Mutex 代表互斥量类型，例如 std::mutex 类型，它应该是一个基本的 BasicLockable 类型，标准库中定义几种基本的 BasicLockable 类型，分别 std::mutex, std::recursive_mutex, std::timed_mutex，std::recursive_timed_mutex (以上四种类型均已在上一篇博客中介绍)以及 std::unique_lock(本文后续会介绍 std::unique_lock)。(注：BasicLockable 类型的对象只需满足两种操作，lock 和 unlock，另外还有 Lockable 类型，在 BasicLockable 类型的基础上新增了 try_lock 操作，因此一个满足 Lockable 的对象应支持三种操作：lock，unlock 和 try_lock；最后还有一种 TimedLockable 对象，在 Lockable 类型的基础上又新增了 try_lock_for 和 try_lock_until 两种操作，因此一个满足 TimedLockable 的对象应支持五种操作：lock, unlock, try_lock, try_lock_for, try_lock_until)。</p>
<p>​        在 lock_guard 对象构造时，传入的 Mutex 对象(即它所管理的 Mutex 对象)会被当前线程锁住。在lock_guard 对象被析构时，它所管理的 Mutex 对象会自动解锁，由于不需要程序员手动调用 lock 和 unlock 对 Mutex 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码。</p>
<p>​        值得注意的是，lock_guard 对象并不负责管理 Mutex 对象的生命周期，lock_guard 对象只是简化了 Mutex 对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个 lock_guard 对象的声明周期内，它所管理的锁对象会一直保持上锁状态；而 lock_guard 的生命周期结束之后，它所管理的锁对象会被解锁。</p>
<h4 id="std-lock-guard-构造函数"><a href="#std-lock-guard-构造函数" class="headerlink" title="std::lock_guard 构造函数"></a>std::lock_guard 构造函数</h4><p>lock_guard 构造函数如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>locking (1)</th>
<th><code>explicit lock_guard (mutex_type&amp; m);</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>adopting (2)</td>
<td><code>lock_guard (mutex_type&amp; m, adopt_lock_t tag);</code></td>
</tr>
<tr>
<td>copy <a href="3">deleted</a></td>
<td><code>lock_guard (const lock_guard&amp;) = delete;</code></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>locking 初始化</p>
<ul>
<li>lock_guard 对象管理 Mutex 对象 m，并在构造时对 m 进行上锁（调用 m.lock()）。</li>
</ul>
</li>
<li><p>adopting初始化</p>
<ul>
<li>lock_guard 对象管理 Mutex 对象 m，与 locking 初始化(1) 不同的是， Mutex 对象 m 已被当前线程锁住。</li>
</ul>
</li>
<li><p>拷贝构造</p>
<ul>
<li><p>lock_guard 对象的拷贝构造和移动构造(move construction)均被禁用，因此 lock_guard 对象不可被拷贝构造或移动构造。</p>
<h3 id="期物"><a href="#期物" class="headerlink" title="期物"></a>期物</h3></li>
</ul>
</li>
</ol>
<p>​        其实，我们的这样场景更多，那就是一个线程工作，另一个线程去接受这个线程的结果很多，我们将之抽象为一个是Provider,一个是Receiver.我们在一些时候需要阻塞Receiver直到我们收获了东西。</p>
<p><code>&lt;future&gt;</code> 头文件中包含了以下几个类和函数：</p>
<ul>
<li>Providers 类：std::promise, std::package_task</li>
<li>Futures 类：std::future, shared_future.</li>
<li>Providers 函数：std::async()</li>
<li>其他类型：std::future_error, std::future_errc, std::future_status, std::launch.</li>
</ul>
<h4 id="std-promise-类介绍"><a href="#std-promise-类介绍" class="headerlink" title="std::promise 类介绍"></a>std::promise 类介绍</h4><p>​        promise 对象可以保存某一类型 T 的值，该值可被 future 对象读取（可能在另外一个线程中），因此 promise 也提供了一种线程同步的手段。在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联，并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值。</p>
<p>​        可以通过 get_future 来获取与该 promise 对象相关联的 future 对象，调用该函数之后，两个对象共享相同的共享状态(shared state)</p>
<ul>
<li>promise 对象是异步 Provider，它可以在某一时刻设置共享状态的值。</li>
<li>future 对象可以异步返回共享状态的值，或者在必要的情况下阻塞调用者并等待共享状态标志变为 ready，然后才能获取共享状态的值</li>
</ul>
<h4 id="std-promise-构造函数"><a href="#std-promise-构造函数" class="headerlink" title="std::promise 构造函数"></a>std::promise 构造函数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>default</th>
<th><code>promise();</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>with allocator</td>
<td><code>template &lt;class Alloc&gt; promise (allocator_arg_t aa, const Alloc&amp; alloc);</code></td>
</tr>
<tr>
<td>copy [deleted]</td>
<td><code>promise (const promise&amp;) = delete;</code></td>
</tr>
<tr>
<td>move</td>
<td><code>promise (promise&amp;&amp; x) noexcept;</code></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>默认构造函数，初始化一个空的共享状态。</li>
<li>带自定义内存分配器的构造函数，与默认构造函数类似，但是使用自定义分配器来分配共享状态。</li>
<li>拷贝构造函数，被禁用。</li>
<li>移动构造函数。</li>
</ol>
<p>另外，std::promise 的 operator= 没有拷贝语义，即 std::promise 普通的赋值操作被禁用，operator= 只有 move 语义，所以 std::promise 对象是禁止拷贝的。</p>
<h4 id="std-promise-get-future"><a href="#std-promise-get-future" class="headerlink" title="std::promise::get_future"></a>std::promise::get_future</h4><p>该函数返回一个与 promise 共享状态相关联的 future <em>。</em>返回的 future 对象可以访问由 promise 对象设置在共享状态上的值或者某个异常对象。只能从 promise 共享状态获取一个 future 对象。在调用该函数之后，promise 对象通常会在某个时间点准备好(设置一个值或者一个异常对象)，如果不设置值或者异常，promise 对象在析构时会自动地设置一个 future_error 异常(broken_promise)来设置其自身的准备状态。上面的例子中已经提到了 get_future，此处不再重复。</p>
<p>​        看一个例子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;mutex&gt;
#include &lt;future&gt;

bool isPrime(int cur)&#123;
    if(cur &lt;&#x3D; 1)
        return false;
    for(int i &#x3D; 2; i &lt;&#x3D; std::sqrt(cur); i++)
        if(cur % i &#x3D;&#x3D; 0)
            return false;
    return true;
&#125;

&#x2F;&#x2F; Producer
void producePrime(std::promise&lt;std::vector&lt;int&gt;*&gt;&amp; pro, int beg, int end)
&#123;
    auto* vec &#x3D; new std::vector&lt;int&gt;;
    for(int i &#x3D; beg; i &lt;&#x3D; end; i++)
        if(isPrime(i))
            vec-&gt;push_back(i);

    pro.set_value(vec);
&#125;

void receivePrime(std::future&lt;std::vector&lt;int&gt;*&gt;&amp; fut)
&#123;
    std::vector&lt;int&gt;* res &#x3D; fut.get();
    for(const auto&amp; i : *res)
        std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
    std::cout &lt;&lt; &quot;\n&quot;;
    delete res;
&#125;
int main()
&#123;
    std::promise&lt;std::vector&lt;int&gt;*&gt; promisePrimes;
    std::future&lt;std::vector&lt;int&gt;*&gt; futurePrimes &#x3D; promisePrimes.get_future();
    std::thread t1(producePrime, std::ref(promisePrimes), 1, 100);
    std::thread t2(receivePrime, std::ref(futurePrimes));

    t1.join();
    t2.join();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>​        条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待，条件变量的条件成立而挂起;另一个线程使条件成立（给出条件成立信号）。为了防止竞争，条件变量的使用总是和一个互斥量结合在一起。</p>
<p>​        <condition_variable > 头文件主要包含了与条件变量相关的类和函数。相关的类包括 std::condition_variable 和 std::condition_variable_any，还有枚举类型std::cv_status。另外还包括函数 std::notify_all_at_thread_exit()</p>
<p>​        std::condition_variable 对象的某个 wait 函数被调用的时候，它使用 std::unique_lock(通过 std::mutex) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 std::condition_variable 对象上调用了 notification 函数来唤醒当前线程。</p>
<p>​        std::condition_variable 对象通常使用 std::unique_lock<std::mutex> 来等待，如果需要使用另外的 lockable 类型，可以使用 std::condition_variable_any 类，本文后面会讲到 std::condition_variable_any 的用法。</p>
<p><strong>std::condition_variable 构造函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>default (1)</th>
<th><code>condition_variable();</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>copy [deleted] (2)</td>
<td><code>condition_variable (const condition_variable&amp;) = delete;</code></td>
</tr>
</tbody>
</table>
</div>
<p>std::condition_variable 的拷贝构造函数被禁用，只提供了默认构造函数。</p>
<p><strong>std::condition_variable::wait() 介绍</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>unconditional (1)</th>
<th><code>void wait (unique_lock&lt;mutex&gt;&amp; lck);</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>predicate (2)</td>
<td><code>template &lt;class Predicate&gt;  void wait (unique_lock&lt;mutex&gt;&amp; lck, Predicate pred);</code></td>
</tr>
</tbody>
</table>
</div>
<p>​        std::condition_variable 提供了两种 wait() 函数。当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用 notify_* 唤醒了当前线程。</p>
<p>​        在线程被阻塞时，该函数会自动调用 <code>lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。</code>另外，一旦当前线程获得通知(notified，通常是另外某个线程调用 notify_* 唤醒了当前线程)，wait() 函数也是自动调用 lck.lock()，使得 lck 的状态和 wait 函数被调用时相同。</p>
<p>​        在第二种情况下（即设置了 Predicate），只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。因此第二种情况类似以下代码：</p>
<pre class="line-numbers language-none"><code class="language-none">while (!pred()) wait(lck);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>std::condition_variable::wait_for() 介绍</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>unconditional (1)</th>
<th><code>template &lt;class Rep, class Period&gt;  cv_status wait_for (unique_lock&lt;mutex&gt;&amp; lck,                      const chrono::duration&lt;Rep,Period&gt;&amp; rel_time);</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>predicate (2)</td>
<td><code>template &lt;class Rep, class Period, class Predicate&gt;       bool wait_for (unique_lock&lt;mutex&gt;&amp; lck,                      const chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred);</code></td>
</tr>
</tbody>
</table>
</div>
<p>​        与 <strong>std::condition_variable::wait()</strong> 类似，不过 wait_for 可以指定一个时间段，在当前线程收到通知或者指定的时间 rel_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_for 返回，剩下的处理步骤和 wait() 类似。</p>
<p>​        另外，wait_for 的重载版本（<strong>predicte(2)</strong>）的最后一个参数 pred 表示 wait_for 的预测条件，只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞</p>
<h4 id="std-condition-variable-any-介绍"><a href="#std-condition-variable-any-介绍" class="headerlink" title="std::condition_variable_any 介绍"></a>std::condition_variable_any 介绍</h4><p>​        与 std::condition_variable 类似，只不过 std::condition_variable_any 的 wait 函数可以接受任何 lockable 参数，而 std::condition_variable 只能接受 std::unique_lock<std::mutex> 类型的参数，除此以外，和 std::condition_variable 几乎完全一样。</p>
<h4 id="std-cv-status-枚举类型介绍"><a href="#std-cv-status-枚举类型介绍" class="headerlink" title="std::cv_status 枚举类型介绍"></a>std::cv_status 枚举类型介绍</h4><div class="table-container">
<table>
<thead>
<tr>
<th>cv_status::no_timeout</th>
<th>wait_for 或者 wait_until 没有超时，即在规定的时间段内线程收到了通知。</th>
</tr>
</thead>
<tbody>
<tr>
<td>cv_status::timeout</td>
<td>wait_for 或者 wait_until 超时。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="std-notify-all-at-thread-exit"><a href="#std-notify-all-at-thread-exit" class="headerlink" title="std::notify_all_at_thread_exit"></a>std::notify_all_at_thread_exit</h4><p>函数原型为：</p>
<pre class="line-numbers language-none"><code class="language-none">void notify_all_at_thread_exit (condition_variable&amp; cond, unique_lock&lt;mutex&gt; lck);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当调用该函数的线程退出时，所有在 cond 条件变量上等待的线程都会收到通知。</p>
<h4 id="看一个例子"><a href="#看一个例子" class="headerlink" title="看一个例子"></a>看一个例子</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

&#x2F;&#x2F; 锁
std::mutex m;
&#x2F;&#x2F; 条件变量
std::condition_variable cv;
&#x2F;&#x2F; 这里就是数据了
std::string data;
&#x2F;&#x2F; 比较特殊，这里公开暴露了两个控制变量，实际上最好集成在类里
bool ready &#x3D; false;
bool processed &#x3D; false;

void worker_thread()
&#123;
    &#x2F;&#x2F; Wait until main() sends data
    std::unique_lock&lt;std::mutex&gt; lk(m);
    &#x2F;&#x2F;子进程的中wait函数对互斥量进行解锁，同时线程进入阻塞或者等待状态。
    cv.wait(lk, []&#123;return ready;&#125;);

    &#x2F;&#x2F; after the wait, we own the lock.
    std::cout &lt;&lt; &quot;Worker thread is processing data\n&quot;;
    data +&#x3D; &quot; after processing&quot;;

    &#x2F;&#x2F; Send data back to main()
    processed &#x3D; true;
    std::cout &lt;&lt; &quot;Worker thread signals data processing completed\n&quot;;

    &#x2F;&#x2F; Manual unlocking is done before notifying, to avoid waking up
    &#x2F;&#x2F; the waiting thread only to block again (see notify_one for details)
    lk.unlock();
    cv.notify_one();
&#125;

int main()
&#123;
    std::thread worker(worker_thread);

    data &#x3D; &quot;Example data&quot;;
    &#x2F;&#x2F; send data to the worker thread
    &#123;
        &#x2F;&#x2F;主线程堵塞在这里，等待子线程的wait()函数释放互斥量。
        std::lock_guard&lt;std::mutex&gt; lk(m);
        ready &#x3D; true;
        std::cout &lt;&lt; &quot;main() signals data ready for processing\n&quot;;
    &#125;
    cv.notify_one();

    &#x2F;&#x2F; wait for the worker
    &#123;
        std::unique_lock&lt;std::mutex&gt; lk(m);
        cv.wait(lk, []&#123;return processed;&#125;);
    &#125;
    std::cout &lt;&lt; &quot;Back in main(), data &#x3D; &quot; &lt;&lt; data &lt;&lt; &#39;\n&#39;;

    worker.join();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/">http://charliechen114514.github.io/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/17/MITS6081-Notes/" title="MITS6081 Notes"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MITS6081 Notes</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/15/xv6%E9%80%9F%E9%80%9A/" title="xv6速通"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">xv6速通</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_RecursionSpecial</div></div></a></div><div><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_in_C(1)</div></div></a></div><div><a href="/2024/01/09/2024%E5%AF%92%E5%81%87%E6%95%B4%E6%B4%BB-C-Cppb%E9%AB%98%E7%BA%A7%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/" title="2024寒假整活_C_Cppb高级编译技术"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-09</div><div class="title">2024寒假整活_C_Cppb高级编译技术</div></div></a></div><div><a href="/2023/12/03/C-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%93%8D%E4%BD%9C%E6%89%93%E5%8D%B0tuple/" title="C++使用模板操作打印tuple"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="title">C++使用模板操作打印tuple</div></div></a></div><div><a href="/2023/12/28/AutoClassGenerator%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" title="AutoClassGenerator开发记录"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-28</div><div class="title">AutoClassGenerator开发记录</div></div></a></div><div><a href="/2023/02/09/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89string-h%E7%B3%BB%E5%88%97/" title="C语言常用函数（1）string.h系列"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">C语言常用函数（1）string.h系列</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">C++ 新特性学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-Exception-Handle"><span class="toc-number">1.1.</span> <span class="toc-text">异常处理 Exception Handle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">并发编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-thread-%E6%9E%84%E9%80%A0"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">std::thread 构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#move-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">move 赋值操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">互斥量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutex-%E7%B3%BB%E5%88%97%E7%B1%BB-%E5%9B%9B%E7%A7%8D"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Mutex 系列类(四种)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock-%E7%B1%BB%EF%BC%88%E4%B8%A4%E7%A7%8D%EF%BC%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Lock 类（两种）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">其他类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-mutex-%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">std::mutex 的成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.3.</span> <span class="toc-text">lock详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-lock-guard-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">std::lock_guard 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-lock-guard-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">std::lock_guard 构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%9F%E7%89%A9"><span class="toc-number">1.2.4.</span> <span class="toc-text">期物</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-promise-%E7%B1%BB%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">std::promise 类介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-promise-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">std::promise 构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-promise-get-future"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">std::promise::get_future</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#std-condition-variable-any-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">std::condition_variable_any 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-cv-status-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">std::cv_status 枚举类型介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#std-notify-all-at-thread-exit"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">std::notify_all_at_thread_exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">看一个例子</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/27/%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8A%E7%BC%96%E8%AF%91%E5%8F%AF%E7%94%A8%E7%9A%84Tesseract-OCR-in-C-%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8Visual-Studio%E4%B8%8EQt6%E4%B8%8A/" title="如何在Windows上编译可用的Tesseract OCR in C++ 并部署在Visual Studio与Qt6上"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何在Windows上编译可用的Tesseract OCR in C++ 并部署在Visual Studio与Qt6上"/></a><div class="content"><a class="title" href="/2024/07/27/%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8A%E7%BC%96%E8%AF%91%E5%8F%AF%E7%94%A8%E7%9A%84Tesseract-OCR-in-C-%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8Visual-Studio%E4%B8%8EQt6%E4%B8%8A/" title="如何在Windows上编译可用的Tesseract OCR in C++ 并部署在Visual Studio与Qt6上">如何在Windows上编译可用的Tesseract OCR in C++ 并部署在Visual Studio与Qt6上</a><time datetime="2024-07-27T09:13:46.000Z" title="发表于 2024-07-27 17:13:46">2024-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/27/STM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8EPlatformIO-VSCode-CubeMX%E7%9A%84%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="STM32开发环境配置记录——关于PlatformIO + VSCode + CubeMX的集成环境配置"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32开发环境配置记录——关于PlatformIO + VSCode + CubeMX的集成环境配置"/></a><div class="content"><a class="title" href="/2024/07/27/STM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8EPlatformIO-VSCode-CubeMX%E7%9A%84%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="STM32开发环境配置记录——关于PlatformIO + VSCode + CubeMX的集成环境配置">STM32开发环境配置记录——关于PlatformIO + VSCode + CubeMX的集成环境配置</a><time datetime="2024-07-27T09:07:15.000Z" title="发表于 2024-07-27 17:07:15">2024-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/27/QEMU-Vscode-Arm-Arch%E2%80%98s-Linux%E8%B0%83%E8%AF%95%E5%B0%8F%E8%AE%B0/" title="QEMU + Vscode + Arm Arch‘s Linux调试小记"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QEMU + Vscode + Arm Arch‘s Linux调试小记"/></a><div class="content"><a class="title" href="/2024/07/27/QEMU-Vscode-Arm-Arch%E2%80%98s-Linux%E8%B0%83%E8%AF%95%E5%B0%8F%E8%AE%B0/" title="QEMU + Vscode + Arm Arch‘s Linux调试小记">QEMU + Vscode + Arm Arch‘s Linux调试小记</a><time datetime="2024-07-27T09:03:08.000Z" title="发表于 2024-07-27 17:03:08">2024-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/27/Linux-%E5%A6%82%E4%BD%95%E7%8E%B0%E4%BB%A3%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85%E5%86%85%E6%A0%B8/" title="Linux_如何现代的编译和安装内核"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux_如何现代的编译和安装内核"/></a><div class="content"><a class="title" href="/2024/07/27/Linux-%E5%A6%82%E4%BD%95%E7%8E%B0%E4%BB%A3%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85%E5%86%85%E6%A0%B8/" title="Linux_如何现代的编译和安装内核">Linux_如何现代的编译和安装内核</a><time datetime="2024-07-27T09:01:36.000Z" title="发表于 2024-07-27 17:01:36">2024-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/27/Linux-Coding-%E5%B0%8F%E5%86%99%E4%B8%80%E4%B8%AAdebugfs/" title="Linux Coding:小写一个debugfs"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux Coding:小写一个debugfs"/></a><div class="content"><a class="title" href="/2024/07/27/Linux-Coding-%E5%B0%8F%E5%86%99%E4%B8%80%E4%B8%AAdebugfs/" title="Linux Coding:小写一个debugfs">Linux Coding:小写一个debugfs</a><time datetime="2024-07-27T09:00:32.000Z" title="发表于 2024-07-27 17:00:32">2024-07-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>