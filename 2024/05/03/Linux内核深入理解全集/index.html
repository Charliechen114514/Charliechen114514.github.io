<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Linux内核深入理解全集 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux 内核深入理解 - 绪论​    任何计算机系统都包含一个名为操作系统的基本程序集合！在这个集合里最重要的程序被称为内核。当操作系统启动的时候内核会被装进RAM当中。 ​    操作系统说来说去就是两个主要目标：他充当底层的物理部件好用的抽象，给予上层服务一个好的平台  与硬件部分进行交互，为包含在硬件平台上的所有底层可编程部件提供服务！ 为运行在计算机系统上层的应用程序即所谓的用户程序">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核深入理解全集">
<meta property="og:url" content="http://charliechen114514.github.io/2024/05/03/Linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%A8%E9%9B%86/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="Linux 内核深入理解 - 绪论​    任何计算机系统都包含一个名为操作系统的基本程序集合！在这个集合里最重要的程序被称为内核。当操作系统启动的时候内核会被装进RAM当中。 ​    操作系统说来说去就是两个主要目标：他充当底层的物理部件好用的抽象，给予上层服务一个好的平台  与硬件部分进行交互，为包含在硬件平台上的所有底层可编程部件提供服务！ 为运行在计算机系统上层的应用程序即所谓的用户程序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2024-05-03T10:37:21.000Z">
<meta property="article:modified_time" content="2024-05-03T10:41:38.219Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Operating System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2024/05/03/Linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%A8%E9%9B%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux内核深入理解全集',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-03 18:41:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux内核深入理解全集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-03T10:37:21.000Z" title="发表于 2024-05-03 18:37:21">2024-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-03T10:41:38.219Z" title="更新于 2024-05-03 18:41:38">2024-05-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">327.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>1035分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux内核深入理解全集"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux-内核深入理解-绪论"><a href="#Linux-内核深入理解-绪论" class="headerlink" title="Linux 内核深入理解 - 绪论"></a>Linux 内核深入理解 - 绪论</h1><p>​    任何计算机系统都包含一个名为操作系统的基本程序集合！在这个集合里最重要的程序被称为内核。当操作系统启动的时候内核会被装进RAM当中。</p>
<p>​    操作系统说来说去就是两个主要目标：他充当底层的物理部件好用的抽象，给予上层服务一个好的平台</p>
<ul>
<li>与硬件部分进行交互，为包含在硬件平台上的所有底层可编程部件提供服务！</li>
<li>为运行在计算机系统上层的应用程序即所谓的用户程序提供一个执行环境！</li>
</ul>
<p>​    为了保障安全。我们的操作系统引入了一组概念，也就是用户模式和特权模式。我们会在之后的博客中有所涉及：简单的讲：一些涉及到底层硬件访问的操作需要在特权模式下进行，反之则会在用户模式下进行！程序的运行有时会在两者之间进行频繁的切换，从而更好地完成程序所提供的服务。</p>
<h3 id="多用户系统"><a href="#多用户系统" class="headerlink" title="多用户系统"></a>多用户系统</h3><p>​    多用户系统就是一台能够并发的执行和独立的执行分别属于两个或者多个用户的若干应用程序的计算机。</p>
<p>​    并发意味着几个应用程序同时处于活动状态执行自己应用进程所需要执行的任务，而并不需要考虑其它应用程序在做什么！</p>
<p>​    多用户操作系统必须包含以下几个特点</p>
<ol>
<li>核实用户身份的认证机制</li>
<li>防止有错误的用户程序妨碍其它应用程序在系统中运行的保护机制</li>
<li>防止有恶意的用户程序干涉或者窥视其他用户的活动的保护机制</li>
<li>限制分配给每个用户的资源数的记账机制</li>
</ol>
<p>​    于是我们会把用户进行分为用户组在多用户系统中每个用户在机器上都会有自己的私用空间！典型的它需要一些磁盘空间来存储文件！以及接受私人邮件信息等！这一些都需要分层的特权来实现一定的保护机制！</p>
<p>​    所有的用户都用一个唯一的数字来进行标识，也就是用户标识符！通常一个计算机系统只能够由有限个人来使用。当其中的某个用户开始一个工作session的时候，操作系统会要求输入一个登录口令。如果用户输入无效则会拒绝登录，从而保障用户的隐私。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>​    所有的操作系统都有一个基本的抽象：也就是进程！</p>
<p>​    进程可以定义为一个程序执行时的一个实例或者一个运行程序所使用的上下文。在传统的操作系统中：一个进程在地址空间中执行一个独立的指令序列，地址空间是允许引用的内存地址集合。</p>
<p>​    在多用户系统中必须实施一种执行环境：在这样的环境里，几个进程可以并发的活动，并能竞争系统资源。允许进程并发活动的系统叫多道程序系统或多处理系统。</p>
<p>​    作为一个单处理器系统上，只有一个进程能够占用CPU。这也就意味着实际上只有一条执行流，那么他们是如何实现一种感官上的并发呢？</p>
<p>​    这需要操作系统的进程是抢占式的！也就是说操作系统需要记录每个进程所占有的CPU时间，并且周期性地激活调度程序。以保证感官上的并发！Unix操作系统是一个具有抢占式进程的多处理操作系统。换而言之，Unix操作系统是一个抢占式的多道处理操作系统！</p>
<h3 id="内核体系架构"><a href="#内核体系架构" class="headerlink" title="内核体系架构"></a>内核体系架构</h3><p>​    大部分Unix内核是单块结构的！也就是说它们属于宏内核操作系统！每一个内核层都被集成到整个内核程序中，并且代表当前进程是在内核态下运行！相反微内核操作系统只需要内核有一个很小的函数：即通常包括几个同步原语，一个简单的调度程序，和IPC通信机制。运行在微内核上的几个系统进程实现宏内核操作系统实现的功能：如内存分配，设备驱动，系统调用处理等。</p>
<p>​    事实证明微内核操作系统的效率比较低，因为它需要花费大量的时间进行进程之间的通信。不过微内核操作系统比单核快内核有一定的理论优势，因为它强迫系统程序员采用模块化的方法来构建程序。所以Linux充分吸收了微内核操作系统的优点：提供了一个模块的机制！模块是这样的一个目标文件：它上面的代码可以在运行时链接到内核，或者从内核中解除链接。这种目标代码通常是由一组函数组成，从而来实现文件系统，驱动程序，或其他内核上层功能。</p>
<p>​    使用模块的主要优点有：</p>
<ul>
<li>首先它保证了一种模块化的方法</li>
<li>其次它实现了一种平台无关性</li>
<li>接着它可以节省内存使用，当我们不再需要他的时候可以动态的进行解除，同样的在我们需要它的时候可以动态的进行加载</li>
<li>最后他无性能损失！</li>
</ul>
<h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><p>我们这样定义文件：</p>
<blockquote>
<p>Unix文件是一个以字节序列组成的信息载体!</p>
</blockquote>
<p>​    内核并不负责解释自己文件的内容！</p>
<p>​    文件或目录名由除/和空字符之外的任意ASCII字符序列组成！大多数文件系统对文件名的长度都会有所限制。（比如说我们的常见的Ext2是255，你不可以把文件名搞得太长！）</p>
<p>​    这个可以查看自己的ulimit值</p>
<p>​    与树的根相对应的目录被称为根目录，按照惯例它的名字是<code>/</code></p>
<p>​    在同一目录中的文件名并不能相同，而在不同目录中的文件名则可以相同（因为可以通过连接不同的目录文件名从而唯一的标识这个文件）</p>
<p>​    Unix的每个进程都有一个工作目录（pwd，想你的shell怎么区分你当前在文件系统海洋的何处！）</p>
<p>​    当标识文件名时引用符号<code>.</code>和<code>..</code>：它们分别标识当前工作目录，和父目录。如果当前工作目录是根目录，那么这两个目录就是完全一致的！</p>
<h3 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h3><p>​    包含在文件目录的文件名就是一个文件的硬链接，或者简称链接。</p>
<p>​    在同一目录或不同的目录中同一个文件可以有好几个链接！因此对应几个文件名。</p>
<p>​    他有两方面的限制：首先他不允许用户给目录创建硬链接，因为这可能会把目录树变为环形图，从而就不可能通过名字来定位一个文件！</p>
<p>​    其次只有在同一文件系统中的文件才能创建链接！这带来比较大的限制！因为现在操作系统可能包含了多种文件系统！这些文件系统位于不同的磁盘和根目录或分区，用户也许无法知道它们的物理划分！</p>
<p>​    为了克服这些限制则引入了软链接，或者是符号链接。符号链接是短文件这些文件包含了另一个文件的任意路径名。路径名可以指向位于任意一个操作系统文件系统的任意文件或目录，甚至可以指向一个根本不存在的文件！</p>
<h3 id="Unix文件类型"><a href="#Unix文件类型" class="headerlink" title="Unix文件类型"></a>Unix文件类型</h3><p>​    Unix文件类型可以是以下列的一种：</p>
<ul>
<li>普通文件</li>
<li>目录</li>
<li>符号链接</li>
<li>面向块的设备文件</li>
<li>面向字符的设备文件</li>
<li>管道</li>
<li>命名管道</li>
<li>套接字</li>
</ul>
<p>​    前三种文件类型是所有Unix文件系统的基本类型</p>
<h3 id="文件描述符与索引节点"><a href="#文件描述符与索引节点" class="headerlink" title="文件描述符与索引节点"></a>文件描述符与索引节点</h3><p>​    Unix对文件的内容和描述文件的信息给出了清楚的区分！除了设备文件和特殊文件系统外，每个文件都由字符序列组成！文件内容不包含任何克控制信息！如文件长度或者文件结束符。</p>
<p>​    我们使用索引节点在内核中表示文件，从而代表一大块文件数据进行管理！</p>
<p>​    文件也有访问权限和文件模式：文件的潜在用户有三种</p>
<ol>
<li>作为文件所有者的</li>
<li>用户同组用户但是不包括所有者</li>
<li>所有剩下的用户</li>
</ol>
<p>​    文件有三种访问类型：读，写与执行！</p>
<h3 id="文件操作的系统调用"><a href="#文件操作的系统调用" class="headerlink" title="文件操作的系统调用"></a>文件操作的系统调用</h3><p>​    有open, read, write, close等，这里我们暂时不加讨论！（可以参考Linux系统编程手册学习！）</p>
<h2 id="Unix内核简述"><a href="#Unix内核简述" class="headerlink" title="Unix内核简述"></a>Unix内核简述</h2><p>​    我们下面重点来讨论Unix内核，首先我们要说的是进程/内核模式：</p>
<p>​    如前所述CPU既可以运行在用户态，也可以运行在内核态。当一个程序在用户态下执行的时候，它并不能直接访问内核的数据结构和程序，然而当应用程序在内核态下运行时则不再会有这些限制。当应用程序有所请求内核服务时，内核才会把这个进程流陷入内核态。当完成任务时把进程送回用户态。进程是动态的实体，在系统内通常只有有限的生存期。创建，撤销，同步现有进程的任务都要委托给内核中的一组例程来完成！</p>
<p>​    内核本身不是一个进程，而是进程的管理者。除用户进程之外：Unix系统还包括几个所谓的内核进程的特权进程。它们具有以下特点：</p>
<ul>
<li>它们以内核态运行在内核地址空间</li>
<li>他们不与用户直接交互，因此不需要终端设备！</li>
<li>他们通常在系统启动时创建然后一直处于活跃状态直到系统关闭</li>
</ul>
<h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>为了让内核管理进程所有的进程都需要用一个进程描述符进行抽象。当内核暂停一个进程的时候，就会把几个相关处理器寄存器的内容保存在进程描述符里，包括：</p>
<ul>
<li>程序计数器和栈指针寄存器</li>
<li>通用寄存器</li>
<li>浮点寄存器</li>
<li>包括CPU状态信息的处理器控制器</li>
<li>用来跟踪进程对RAM访问的内存管理寄存器    </li>
</ul>
<p>​    当内核决定恢复一个进程的时候，他用进程描述符中合适的字段来装载CPU寄存器。因为程序计数器中所存的值指向下一条将要执行的指令，所以进程恐怕停止的地方恢复执行！</p>
<h3 id="可重入内核"><a href="#可重入内核" class="headerlink" title="可重入内核"></a>可重入内核</h3><p>​    所有的Unix内核都是可重入的！</p>
<p>​    这意味着若干个进程可以同时在内核态下执行，当然在单处理器系统上只有一个进程在真正的执行！但是有许多进程可能在等待CPU或者某一个IO操作完成时在内核台下被阻塞！</p>
<p>​    提供可重入的一种方式就是编写函数，以便这些函数只能更改局部变量，而不更改全局数据结构。这样的函数叫做可重入函数！</p>
<p>​    如果一个硬件中断发生，可重入内核可以挂起正在执行的进程，即使这个进程处于内核态</p>
<p>​    在最简单的情况下CPU从第一条指令到最后一条指令顺序的执行内核控制路径。也就是表示内核处理系统调用异常或中断所执行的指令序列</p>
<p>​    然而当下述事情发生之一，CPU交错执行内核控制路径：</p>
<ul>
<li>运行在用户态下的进程调用了一个系统调用，而相应的内核控制路径。正是这个请求没有办法立即得到满足，然后内核控制路径调用调度程序选择一个新的进程。进行调度完成后，进程切换。发生第一个内核控制路径还没有完成，而CPU又重新执行其他的内核控制路径。在这种情况下，两条控制路径代表两个不同的进程。</li>
<li>在执行当执行一个内核控制路径时，CPU检测到了一个异常：比如说访问了一个不在RAM中的页，那么第一个控制路径将会被挂起，而CPU开始执行合适的过程。比如说在这个例子中我们则是给那进程分配一个新页，并从磁盘中读取它的内容。当这个过程结束后第一个控制路径可以恢复执行，在这种情况下两个控制路径代表同一个进程在执行</li>
<li>当CPU在运行一个启用了中断的内核控制路径时，一个硬件中断发生。一个控制路径还没执行完，CPU马上开始执行另一个内核控制路径来处理这个中断。当这个中断处理程序终止时，第一个内核控制路径恢复。在这个情况下两条内核控制路径运行是同一进程的可执行上下文。所花费的系统CPU时间都算给了这个进程。然而中断处理程序无需代表这个进程运行</li>
<li>在支持抢占式调度的内核中，CPU正在运行。但是被一个更加高级的进程加入就绪队列。中断发生，调度开始。第一个内核控制路径并没有执行完。CPU代表高优先级进程又开始了另一个内核控制路径，只有把内核编译成支持抢占式调度后才有可能会出现这种情况！（你放心，咱们就是这个hhh） </li>
</ul>
<h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>​    每个进程运行在它的私有地址空间！在用户态下运行的进程涉及到私有栈，数据区和代码区。</p>
<p>​    当在内核态运行时，进程访问内核的数据区，代码区。但是使用的是另外的私有栈。尽管看起来每个进程都在访问他们自己的私有栈，但是为了更好的进程间通信，有时进程之间也会共享部分地址空间！</p>
<p>​    Linux支持映射内存（mmap）系统调用，该系统调用将允许存放在块设备上的文件或信息映射到进程的部分地址空间。这为正常的读写传送数据方式提供了另一种选择 </p>
<h3 id="同步和临界区"><a href="#同步和临界区" class="headerlink" title="同步和临界区"></a>同步和临界区</h3><p>​    实现可重入的内核需要利用同步机制，如果内核控制路径对某个内核数据结构进行操作被挂起时，那么其他内核控制路径就不应该对这个数据结构进行操作，否则会破坏一致性状态！</p>
<p>​    如何同步内核控制路径呢最彻底的办法就是使用非抢占式的内核（<code>Weird huh?</code>），其次就是禁止中断，再就是使用信号量自旋锁等内核机制来防止竞争条件！</p>
<p>​    在我们使用防止竞争条件的内核上锁机制时，需要避免死锁情况！在这里不予详细讨论！</p>
<h3 id="信号与进程之间的通信"><a href="#信号与进程之间的通信" class="headerlink" title="信号与进程之间的通信"></a>信号与进程之间的通信</h3><p>​    Unix信号提供了一种把系统事件报告给进程的一种机制。</p>
<p>​    有两种系统事件：</p>
<ul>
<li>异步通告</li>
<li>同步错误或异常</li>
</ul>
<p>​    如果进程并没有指定如何处理信号时，内核会按照信号的编号进行默认操作。有可能有以下五种默认操作：</p>
<p>终止进程</p>
<p>将执行上下文和进程地址空间的内容写入一个文件，并且终止进程</p>
<p>忽略信号</p>
<p>挂起进程</p>
<p>如果进程曾被暂停，则恢复它</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>​    Unix在进程和它正在执行的程序之间做出了清晰的划分！fork和_exit这两个系统调用分别用来创建一个进程和终止，与exec类系统调用则是装入一个全新的程序！以及还有僵死进程。如果父进程丢失了跟踪子进程的情况，那么这个子进程就认为僵尸进程。内核会检查子进程是否终止。引入僵死进程的特殊状态是为了表示终止的进程。很多内核也实现了waitpid系统调用，让父进程可以显示的等待一个特殊的子进程。对于那些已经成为僵尸进程的进程，他们将会被一个以init的特殊系统进程收养进行清除！</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>​    所有新进的Unix系统都提供了一种有用的抽象：叫做虚拟内存！</p>
<p>​    它作为一种逻辑层处于应用程序的内在请求与硬件内存单元管理单元之间。虚拟内存有很多用途与优点，它可以让</p>
<ul>
<li>若干进程并发执行</li>
<li>应用程序所需内存大于可用物理内存时也可以运行</li>
<li>程序集有部分代码装入内存时进程可以执行</li>
<li>允许每个进程访问可用物理内存的子集进程</li>
<li>可以共享库数据或程序或函数等一个单独内存映像</li>
<li>程序是可定位的！也就是说我们可以把程序放在物理内存中的任何地方</li>
<li>程序员可以编写与机器无关的代码！因为他们根本不需要关心物理内存的组织结构，也就是说他把物理内存进行了一层抽象</li>
</ul>
<p>​    虚拟内存子系统的主要成分是虚拟地址空间进程所用的一组内存地址。不同于物理内存地址！</p>
<h3 id="随机访问存储器的使用"><a href="#随机访问存储器的使用" class="headerlink" title="随机访问存储器的使用"></a>随机访问存储器的使用</h3><p>​    随机访问存储器的使用分为两个部分：</p>
<p>一部分被专门用来存放内核映像，另一部分则由虚拟内存系统来进行处理：</p>
<ul>
<li>用来满足内核对缓冲区描述服务及其它动态内核数据结构的请求</li>
<li>满足进程对一般性内存区的请求即对文件内存映射的请求</li>
<li>借助于高速缓存从磁盘或者其他缓冲设备获得较好的性能内存</li>
</ul>
<h3 id="内核分配器"><a href="#内核分配器" class="headerlink" title="内核分配器"></a>内核分配器</h3><p>​    它是一个子系统，试图满足系统中所有部分对内存的请求！其中一些请求可能来自内核其他子系统。他们需要一些内核使用的内存，还有一些请求则是来自用户程序的系统调用，以用来增加用户程序进程的地址空间！</p>
<p>​    一个好的内核内存分配器需要具有以下特点：</p>
<p>它必须快，实际上这是最重要的属性！因为它为所有的内核子系统所调用</p>
<p>必须把内存的浪费减到最少</p>
<p>必须努力减轻内存的碎片问题</p>
<p>必须能与其他内存管理子系统进行合作，以便借用和释放页框</p>
<p>​    现在已经提出了好几种内核内存分配器进程！这个可以查询其他资料！</p>
<h3 id="进程的虚拟地址空间处理"><a href="#进程的虚拟地址空间处理" class="headerlink" title="进程的虚拟地址空间处理"></a>进程的虚拟地址空间处理</h3><p>​    进程的虚拟地址空间包括了进程可以引用的所有虚拟内存地址，内核通常用一组内存区描述符描述进程！虚拟地址空间内核分配给进程的虚拟地址空间主要有以下这几个部分：</p>
<ul>
<li>组成程序的可执行代码</li>
<li>程序的初始化和未初始化的数据</li>
<li>初始程序栈</li>
<li>所需共享库的可执行代码和数据</li>
<li>堆</li>
</ul>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><p>​    物理内存的一大优势就是用来磁盘和其它块设备的高速缓存！因为磁盘访问非常的慢，这与访问内存相比实在太长！因此磁盘通常是影响系统性能的一大瓶颈所在，最早的Unix系统中早就已经实现了一个策略就是对推迟写磁盘的时间，我们将在后续的实现中看看Linux是如何做到的！</p>
<h1 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h1><h2 id="引论，三个地址"><a href="#引论，三个地址" class="headerlink" title="引论，三个地址"></a>引论，三个地址</h2><p>​    下面来说说内存寻址！</p>
<p>​    程序员偶尔会引用内存地址作为访问内存单元的一种方式。我们有三种不同的地址：逻辑地址，线性地址，和物理地址</p>
<blockquote>
<p>逻辑地址：指的是包含在机器语言指令中用来表示一个操作数或一条指令的地址！这种寻址方式在80X86著名的分段结构中表现得尤为具体，，它促使MSDOS程序员或Windows程序员把程序分成若干段（当然说的是汇编程序员hhh）。每一个逻辑地址都由一个段和偏移量组成！偏移量指明了从段开始的地方，到实际地址之间的距离</p>
<p>线性地址也被称为虚拟地址，是一个32位无符号整数（在32位平台上，自然的在64位平台上个就是64位无符号整数），可以用来表达高达4GB的地址！现行地址通常用16进制数字表示！</p>
<p>物理地址用来内存芯片及内存单元寻址。他们从与微处理器的地址引脚，发送到内存总线上的电信号。相对应物理地址由32位或36位无符号整数表示。内存控制单元通过一种分段单元的硬件电路把一个逻辑地址转换成一个线性地址，接着第二个称为分页单元的硬件电路把线性地址转换为一个物理地址！</p>
</blockquote>
<h2 id="硬件中的分段"><a href="#硬件中的分段" class="headerlink" title="硬件中的分段"></a>硬件中的分段</h2><p>​    从80286模型开始，英特尔微处理器以两种不同的方式执行地址转换这两种方式！分别被称为<strong>实模式和保护模式</strong></p>
<p>​    段选择符和段寄存器一个逻辑地址有两个部分组成一个段标识符和一个段内相对地址的偏移量段标识符是一个16位长的字段也被称为段选择符为了快速方便地找到段选择符处理器提供一个叫做段寄存器的寄存器他的唯一目的是为了存放段选择符这些段寄存器被称为CS，SS，DS，ES，FS和GS。尽管只有六个段寄存器，但程序可以把同一个段的寄存器用作不同目的。方法是先把这个值保存在内存中，用完再恢复。其中有三者是有专门用途的。</p>
<blockquote>
<p><code>CS(code segment)</code>：代码段寄存器！指向包含程序指令的段</p>
<p><code>SS(stack segmment)</code>：栈段寄存器！指向包含当前程序栈的段</p>
<p><code>DS(data segment)</code>：数据段寄存器！指向包含静态数据或者全局数据段！</p>
</blockquote>
<p>​    CS寄存器还有一个重要的功能：它还有一个两位的字段用以指明CPU的当前特权级（<code>Current Privilage Level</code>）</p>
<p>​    值为零时代表最高优先级值！为三时表示最低优先级！Linux只用零级和三级，分别被称为内核态和用户态！</p>
<h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>​    每个段由八个字节的段描述符表示，他表示了一个段的特征！段描述符放在GDT或LDT中。通常只定义一个GDT而每个进程除了存放在GDP的段，以外如果还创建了附加的段，可以有自己的LDT。段序描述符字段由以下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>base</td>
<td>表示段的首字节的线性地址</td>
</tr>
<tr>
<td>G</td>
<td>粒度标志！表示如果该位清零，则段大小以字节为单位。否则以4096字节的倍数。</td>
</tr>
<tr>
<td>limit</td>
<td>存放段中最后一个内存单元的偏移量，从而决定了段的长度。这就跟G扯上关系了：<br>如果既被置为零，则一个段的大小在1B到1MB之间变化，否则则在4KB到4GB之间变化</td>
</tr>
<tr>
<td>S</td>
<td>系统标志！如果它被清零则，这是一个系统段，存放着像LDT这种关键数据结构！否则它就是一个普通的代码段或数据段</td>
</tr>
<tr>
<td>type</td>
<td>描述了段的类型特征和它的存取权限</td>
</tr>
<tr>
<td>DPL</td>
<td>描述符特权级字段，用于限制这对这个段的存取！他表示为访问这个段要求的CPU最小优先级！</td>
</tr>
<tr>
<td>P</td>
<td>segment present标志！表示当前段并不在主存当中，Linux总是把这个标志设为一，因为他从不把整个段交换到磁盘上。</td>
</tr>
<tr>
<td>D/B</td>
<td>取决于是代码段还是数据段</td>
</tr>
<tr>
<td>AVL</td>
<td>系统使用但是已经被Linux所忽略</td>
</tr>
</tbody>
</table>
</div>
<p>​    以下是Linux中被广泛使用的类型！</p>
<ul>
<li>代码段描述符：表示这个段是一个代码段，它可以放在GDP或LDT中此时该描述符志S标志为一</li>
<li>数据段描述符：表示这个段描述了一个数据段，也可以被放在GDP或LDT中，S标志为1。栈段是通过一般的数据段所实现的！</li>
<li>任务状态的描述符：表示这个段的描述代表一个任务状态段，也就是TSS！这个段用来保存处理寄存器的内容</li>
<li>局部描述符表描述符：表示这个段描述符代表一个包含了LDT的段。他只会出现在GDT中！相应的type字段的值为2，S被置为零。</li>
</ul>
<h3 id="快速访问段描述符"><a href="#快速访问段描述符" class="headerlink" title="快速访问段描述符"></a>快速访问段描述符</h3><p>​    我们回忆一下：逻辑地址是由一个16位段选择符和32位偏移量组成段寄存器！仅仅存放段选择符。为了加速逻辑地址到线性地址的转换，8086处理器提供了一种附加的非编程的寄存器：共六个可编程的段寄存器所使用。每一个非编程的寄存器含有八个字节的段描述符，由相应的段寄存器的段选择符来指定。每当一个段选择符被装入段寄存器时，相应的段描述符就从内存被装到对应的非编程CPU寄存器中！从那个时候起，针对那个段的逻辑地址转换就可以不用访问主存中的GDP或LDT。处理器只需要引用存放段描述符的CPU寄存器即可！仅当段寄存器的内容发生改变时，才会有必要访问GDP或LDT。这体现了一种缓存机制！</p>
<p>​    段选择符字段有三个字段名：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标识</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>指定了放在GD T或LBT中的相应段描述符的一个入口</td>
</tr>
<tr>
<td>TI</td>
<td>指明断续描述符是在GDP中（TI = 0）还是在LDT中（TI = 1）</td>
</tr>
<tr>
<td>RPL</td>
<td>请求者特权：即当相应的段选择符装入了CS寄存器中只是CPU当前的特权级！它还可以用来访问数据段时，有选择的削弱处理器的特权级分段单元。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="分段单元"><a href="#分段单元" class="headerlink" title="分段单元"></a>分段单元</h3><p>​    分段单元会执行以下操作：</p>
<ol>
<li>它会检查段选择符的TI字段，以决定段描述符保存在哪一个描述符表中，TI字段指明段描述符市的GDP中还是在激活的LDT中</li>
<li>从段选择符的index字段中计算段描述符地址：index字段的值乘以八，这个结果与gdpr或ldtr寄存器中的内容相加。</li>
<li>把逻辑地址的偏移量与段描述符Base字段的值相加就会得到线性地址</li>
</ol>
<p>​    Linux当中的分段是非常有限的！实际上分段和分页在某种程度上会显得有些多余，因为它们都可以划分进程的物理地址空间！分段可以给每一个进程分配以不同的线性空间，而分页则可以把同一线性地址空间映射到不同的物理内存。与分段相比，linux更青睐于使用分页方式：因为当所有进程使用相同的段寄存器值时，内存管理变得非常简单！也就是他们可以共享同样的一组线性地址！Linux的设计目标之一就是可以把它们移植到大多数流行的处理平台之下然而RISC体系结构对分段的支持非常有限！</p>
<p>​    Linux下的逻辑地址与线性地址是一致的：即逻辑地址的偏移量字段的值予以相应的线性地址的值总是一致的</p>
<h3 id="Linux-GDT"><a href="#Linux-GDT" class="headerlink" title="Linux GDT"></a>Linux GDT</h3><p>​    单处理器系统中只有一个GDT，而在多处理器系统中每个CPU对应一个GDT所。有的GDT都存放在cpu_gdt_table数组中:而所有GDP的地址和它们的大小（这个大小是初始化GDTR计算器使用）被存放在cpu_gdt_desp数组中！</p>
<p>​    每一个GDP的包含18个段分别指向下列的段：</p>
<ul>
<li>用户态和内核态下的代码段和数数据段共四个任务状态段</li>
<li>TSS，每个处理器有一个！</li>
<li>一个包含缺省局部描述符表的段，这个段是被所有进程共享的段！</li>
<li>三个局部线程存储段TLS，这种机制允许多线程应用程序使用最多三个局部与线程的数据段！</li>
<li>与高级电源管理相关的三个段</li>
<li>与支持即插即用功能的BIOS服务程序相关的五个段</li>
<li>被内核用来处理双重错误异常的特殊TSS段</li>
</ul>
<h3 id="Linux-LDT"><a href="#Linux-LDT" class="headerlink" title="Linux LDT"></a>Linux LDT</h3><p>​    大多数Linux程序并不会使用局部描述符！然而在某些情况下进程仍然会需要创建自己的局部描述符表，比如说像Wine那样的程序</p>
<h2 id="硬件中的分页"><a href="#硬件中的分页" class="headerlink" title="硬件中的分页"></a>硬件中的分页</h2><p>​    分页单元把线性地址转换为物理地址。其中一个关键的任务就是把请求的访问类型与线性地址的访问权限所相比较，如果这次访问是无效的，则会产生一个缺页异常！</p>
<p>​    为了效率，线性地址被分为固定长度为单位的组，称为页！页内不连续的线性地址会被映射到连续的物理地址当中去。这样内核可以指定一个页的物理地址和存取权限，而不用指定页所包含所有的线性地址的存取权限！我们通常遵循习惯使用习惯，让页来表示一组线性地址，包含这组地址中的数据。</p>
<p>​    分页单元把所有的分成固定长度的页框，有时也叫做物理页。每一个页框包含一个页，也就是说一个框的长度和一个页的长度是一致的。页框是主存的一部分，也就是存储区域。区分一个页和页框很重要，前者只是一个数据块，前者可以存放在任何页框和磁盘中。</p>
<p>​    把线性地址映射到物理地址的数据结构称为页表，页表存放在主存当中。并且启用分页单元之前就必须由内核对列表进行适当的初始化，从80386开始所有的值80X86处理器都会支持分页！它通过设置CR零寄存器的PG标志启用。当PG等于零时，线性地址就会被解释为物理地址。</p>
<p>​    32位线性地址经常会被分成三个域：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>directory目录</th>
<th>table（页表）</th>
<th>offset偏移量</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>10</td>
<td>12</td>
</tr>
</tbody>
</table>
</div>
<p>​    线性地址的转换分为两步走：每一步都基于一种转换表。第一种转换表被称为页目录表，第二种则是被称为页表。</p>
<p>​    使用这种二级模式的目的在于：减少每个进程页表所需要的RAM的数量！（自己想象如果给每一个信息地址的维护一个映射项的话这个页表将会有多么恐怖的大！）。页目录项和页表项有相同的结构！每项都包含下面的字段：</p>
<ul>
<li>present标志：如果被置为1，所指的页或页表它就在主存当中！如果该标志被置为零，则这一页并不在主存！当中如果执行一个地址转换所需的页表项或页目录项中的present被置为零，那么分页单元就会把该线性地址存放在控制寄存器CR2中，并产生14号异常缺页异常！操作系统会介入进行相应的处理。</li>
<li>Field：包含页框物理地址最高二十位的字段！由于每一个页框有4kb标志的容量它的物理地址必须是4096的倍数，因此物理地址的最低12位总是零</li>
<li>access：每当分页单元对应的页框进行寻址时，就会设置这个标志！当选中的页被交换出去，这个标志可以作系统所使用。分页单元从不会重置这个标志，而是必须由操作系统去做！</li>
<li>read/write标志：含有页或页表的存取权限</li>
<li>dirty标志：只用来列表项中每当对一个页框进行写操作时就会设置这个标识，当选中的页被交换出去，这个标志可以作系统所使用。分页单元从不会重置这个标志，而是必须由操作系统去做！</li>
<li>user/supervisor标志：标志很有访问页或页表所需的特权级</li>
<li>PCD和PWT标志：硬件控制硬件高速缓存处理页或页表的方式</li>
<li>page size：只用于页目录项，如果被置为一则该目录页目录项指的是2mb或4mb的页框！</li>
<li>global标识：只应用于页表项，这个标志是用来防止常用页从TLB高速缓存中刷新出去 </li>
</ul>
<h2 id="PAE"><a href="#PAE" class="headerlink" title="PAE"></a>PAE</h2><p>​    常规分页机制32位地址线理论上可以寻址4GB的RAM地址空间。但是，大型的服务器需要大于4GB的RAM来同时运行数以千计的进程。</p>
<p>​    因此：Intel通过在处理器上把管脚数从32增加到36，以提高处理器的寻址能力，使其达到2^36=64GB，同时引入了一种新的分页机制PAE(Physical Address Extension，物理地址扩展)把32位线性地址转换为36位物理地址才能使用所增加的物理内存，通过设置CR4的第5位来开启对PAE的支持。引入PAE就是为了访问大于4GB的RAM，线性地址仍然是32位，而物理地址是36位。</p>
<p>把一个32位的虚拟地址分成4个部分：</p>
<ul>
<li>0-11：页内偏移</li>
<li>12-20：页表（Page Table）</li>
<li>21-29：页表目录表（Page Table Directory）</li>
<li>30-31：页目录指针表（Page Directory Pointer Table）</li>
</ul>
<h2 id="硬件高速缓存"><a href="#硬件高速缓存" class="headerlink" title="硬件高速缓存"></a>硬件高速缓存</h2><p>​    这是为了缓解微处理器的频率与访问RAM芯片的频率相差过大的矛盾所引入的！为了缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存机制：硬件高速缓存则是基于著名的局部性原理，该原理既适用于程序结构，也适用于数据结构！这表明由于程序的循环结构与相关数组可以组织成线性数组，最近最常用的相邻地址在最近的将来又被用到的可能性极大，因此引入小而快的内存来存放最近最常使用的代码和数据变得很有意义！</p>
<p>​    高速缓存又被细分为行的子集。在一种极端情况下高速缓存可以是直接映射的这是主存中的一个行，总是存放在高速缓存中完全相同的位置！在另一种极端情况下高速缓存是充分关联的，这意味着主存中的任意一个行，可以存放在高速缓存中的任意位置！</p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p>​    除了通用硬件高速缓存之外，还有一种转换后缓冲器或TLB的高速缓存用于加快线性地址转换</p>
<p>​    当线性地址第一次被使用时，通过慢速访问RAM中的页表，计算出相应的物理地址。同时物理地址被存放在一个TLB表象中，以便以后对同一个线性地址的引用时，得到快速的转换。</p>
<p>​    在多处理器系统中每个CPU都有自己的TLB这叫做CPU的本地TLB。与硬件高速缓存相反TLB的对应项不必同步，这是因为运行在现有CPU上可以使用同一个线性地址与不同的物理地址发生联系！</p>
<h2 id="Linux中的分页"><a href="#Linux中的分页" class="headerlink" title="Linux中的分页"></a>Linux中的分页</h2><p>​    Linux从2.6开始使用四级分页：</p>
<ul>
<li>页全局目录（Page Global Directory）</li>
<li>页上级目录（Page Upper Directory）</li>
<li>页中间目录（Page Middle Directory）</li>
<li>页表（Page Table）</li>
</ul>
<blockquote>
<ul>
<li><p>页全局目录包含若干页上级目录的地址；</p>
</li>
<li><p>页上级目录又依次包含若干页中间目录的地址；</p>
</li>
<li><p>而页中间目录又包含若干页表的地址；</p>
</li>
<li><p>每一个页表项指向一个页框。</p>
<p>因此线性地址因此被分成五个部分，而每一部分的大小与具体的计算机体系结构有关。</p>
</li>
</ul>
</blockquote>
<h3 id="页表类型定义pgd-t、pmd-t、pud-t和pte-t"><a href="#页表类型定义pgd-t、pmd-t、pud-t和pte-t" class="headerlink" title="页表类型定义pgd_t、pmd_t、pud_t和pte_t"></a>页表类型定义pgd_t、pmd_t、pud_t和pte_t</h3><p>​    Linux分别采用<code>pgd_t</code>、<code>pmd_t</code>、<code>pud_t</code>和<code>pte_t</code>四种数据结构来表示页全局目录项、页上级目录项、页中间目录项和页表项。这四种数据结构本质上都是无符号长整型unsigned long！</p>
<p>​    Linux为了更严格数据类型检查，将无符号长整型unsigned long分别封装成四种不同的页表项。如果不采用这种方法，那么一个无符号长整型数据可以传入任何一个与四种页表相关的函数或宏中，这将大大降低程序的健壮性。</p>
<blockquote>
<p>pgprot_t是另一个64位（PAE激活时）或32位（PAE禁用时）的数据类型，它表示与一个单独表项相关的保护标志。</p>
</blockquote>
<p>首先我们查看一下子这些类型是如何定义的</p>
<h4 id="pteval-t，pmdval-t，pudval-t，pgdval-t"><a href="#pteval-t，pmdval-t，pudval-t，pgdval-t" class="headerlink" title="pteval_t，pmdval_t，pudval_t，pgdval_t"></a>pteval_t，pmdval_t，pudval_t，pgdval_t</h4><blockquote>
<p>参照<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/arch/x86/include/asm/pgtable_64_types.h#L227">arch/x86/include/asm/pgtable_64_types.h</a></p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__ASSEMBLY__</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/types.h></span></span>

<span class="token comment">/*
 * These are used to make use of C type-checking..
 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span>   pteval_t<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span>   pmdval_t<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span>   pudval_t<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span>   pgdval_t<span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span>   pgprotval_t<span class="token punctuation">;</span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> pteval_t pte<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> pte_t<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">/* !__ASSEMBLY__ */</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="pgd-t、pmd-t、pud-t和pte-t"><a href="#pgd-t、pmd-t、pud-t和pte-t" class="headerlink" title="pgd_t、pmd_t、pud_t和pte_t"></a>pgd_t、pmd_t、pud_t和pte_t</h4><blockquote>
<p>参照 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/arch/x86/include/asm/pgtable_types.h#L227">/arch/x86/include/asm/pgtable_types.h</a></p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> pgdval_t pgd<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> pgd_t<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pgd_t <span class="token function">native_make_pgd</span><span class="token punctuation">(</span>pgdval_t val<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>pgd_t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> val <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pgdval_t <span class="token function">native_pgd_val</span><span class="token punctuation">(</span>pgd_t pgd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> pgd<span class="token punctuation">.</span>pgd<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pgdval_t <span class="token function">pgd_flags</span><span class="token punctuation">(</span>pgd_t pgd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">native_pgd_val</span><span class="token punctuation">(</span>pgd<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PTE_FLAGS_MASK<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">CONFIG_PGTABLE_LEVELS <span class="token operator">></span> <span class="token number">3</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> pudval_t pud<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> pud_t<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pud_t <span class="token function">native_make_pud</span><span class="token punctuation">(</span>pmdval_t val<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>pud_t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> val <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pudval_t <span class="token function">native_pud_val</span><span class="token punctuation">(</span>pud_t pud<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> pud<span class="token punctuation">.</span>pud<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm-generic/pgtable-nopud.h></span></span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pudval_t <span class="token function">native_pud_val</span><span class="token punctuation">(</span>pud_t pud<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">native_pgd_val</span><span class="token punctuation">(</span>pud<span class="token punctuation">.</span>pgd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">CONFIG_PGTABLE_LEVELS <span class="token operator">></span> <span class="token number">2</span></span></span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span> pmdval_t pmd<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> pmd_t<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pmd_t <span class="token function">native_make_pmd</span><span class="token punctuation">(</span>pmdval_t val<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>pmd_t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> val <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pmdval_t <span class="token function">native_pmd_val</span><span class="token punctuation">(</span>pmd_t pmd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> pmd<span class="token punctuation">.</span>pmd<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;asm-generic/pgtable-nopmd.h></span></span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pmdval_t <span class="token function">native_pmd_val</span><span class="token punctuation">(</span>pmd_t pmd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">native_pgd_val</span><span class="token punctuation">(</span>pmd<span class="token punctuation">.</span>pud<span class="token punctuation">.</span>pgd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pudval_t <span class="token function">pud_pfn_mask</span><span class="token punctuation">(</span>pud_t pud<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">native_pud_val</span><span class="token punctuation">(</span>pud<span class="token punctuation">)</span> <span class="token operator">&amp;</span> _PAGE_PSE<span class="token punctuation">)</span>
                <span class="token keyword">return</span> PHYSICAL_PUD_PAGE_MASK<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                <span class="token keyword">return</span> PTE_PFN_MASK<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pudval_t <span class="token function">pud_flags_mask</span><span class="token punctuation">(</span>pud_t pud<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token operator">~</span><span class="token function">pud_pfn_mask</span><span class="token punctuation">(</span>pud<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pudval_t <span class="token function">pud_flags</span><span class="token punctuation">(</span>pud_t pud<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">native_pud_val</span><span class="token punctuation">(</span>pud<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token function">pud_flags_mask</span><span class="token punctuation">(</span>pud<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pmdval_t <span class="token function">pmd_pfn_mask</span><span class="token punctuation">(</span>pmd_t pmd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">native_pmd_val</span><span class="token punctuation">(</span>pmd<span class="token punctuation">)</span> <span class="token operator">&amp;</span> _PAGE_PSE<span class="token punctuation">)</span>
                <span class="token keyword">return</span> PHYSICAL_PMD_PAGE_MASK<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
                <span class="token keyword">return</span> PTE_PFN_MASK<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pmdval_t <span class="token function">pmd_flags_mask</span><span class="token punctuation">(</span>pmd_t pmd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token operator">~</span><span class="token function">pmd_pfn_mask</span><span class="token punctuation">(</span>pmd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pmdval_t <span class="token function">pmd_flags</span><span class="token punctuation">(</span>pmd_t pmd<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">native_pmd_val</span><span class="token punctuation">(</span>pmd<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token function">pmd_flags_mask</span><span class="token punctuation">(</span>pmd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pte_t <span class="token function">native_make_pte</span><span class="token punctuation">(</span>pteval_t val<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>pte_t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span>pte <span class="token operator">=</span> val <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pteval_t <span class="token function">native_pte_val</span><span class="token punctuation">(</span>pte_t pte<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> pte<span class="token punctuation">.</span>pte<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> pteval_t <span class="token function">pte_flags</span><span class="token punctuation">(</span>pte_t pte<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">native_pte_val</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span> <span class="token operator">&amp;</span> PTE_FLAGS_MASK<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="xxx-val和-xxx"><a href="#xxx-val和-xxx" class="headerlink" title="xxx_val和__xxx"></a>xxx_val和__xxx</h4><blockquote>
<p>参照<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/arch/x86/include/asm/pgtable.h#L227">/arch/x86/include/asm/pgtable.h</a></p>
</blockquote>
<p>​    五个类型转换宏（_ pte、_ pmd、_ pud、_ pgd和__ pgprot）把一个无符号整数转换成所需的类型。</p>
<p>​    另外的五个类型转换宏（pte_val，pmd_val， pud_val， pgd_val和pgprot_val）执行相反的转换，即把上面提到的四种特殊的类型转换成一个无符号整数。</p>
<pre class="line-numbers language-scss" data-language="scss"><code class="language-scss">#define pgd_<span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>      native_pgd_<span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
#define __<span class="token function">pgd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>        native_make_<span class="token function">pgd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>

#ifndef __PAGETABLE_PUD_FOLDED
#define pud_<span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>      native_pud_<span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
#define __<span class="token function">pud</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>        native_make_<span class="token function">pud</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
#endif

#ifndef __PAGETABLE_PMD_FOLDED
#define pmd_<span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>      native_pmd_<span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
#define __<span class="token function">pmd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>        native_make_<span class="token function">pmd</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
#endif

#define pte_<span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>      native_pte_<span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
#define __<span class="token function">pte</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>        native_make_<span class="token function">pte</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这里需要区别指向页表项的指针和页表项所代表的数据。以pgd_t类型为例子，如果已知一个pgd_t类型的指针pgd，那么通过pgd_val(*pgd)即可获得该页表项(也就是一个无符号长整型数据)，这里利用了面向对象的思想。</p>
<h3 id="页表描述宏"><a href="#页表描述宏" class="headerlink" title="页表描述宏"></a>页表描述宏</h3><p>参照<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/pgtable_64_types.h#L227">arch/x86/include/asm/pgtable_64</a></p>
<p>​    linux中使用下列宏简化了页表处理，对于每一级页表都使用有以下三个关键描述宏：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">宏字段</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">XXX_SHIFT</td>
<td style="text-align:left">指定Offset字段的位数</td>
</tr>
<tr>
<td style="text-align:left">XXX_SIZE</td>
<td style="text-align:left">页的大小</td>
</tr>
<tr>
<td style="text-align:left">XXX_MASK</td>
<td style="text-align:left">用以屏蔽Offset字段的所有位。</td>
</tr>
</tbody>
</table>
</div>
<p>我们的四级页表，对应的宏分别由PAGE，PMD，PUD，PGDIR</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">宏字段前缀</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PGDIR</td>
<td style="text-align:left">页全局目录(Page Global Directory)</td>
</tr>
<tr>
<td style="text-align:left">PUD</td>
<td style="text-align:left">页上级目录(Page Upper Directory)</td>
</tr>
<tr>
<td style="text-align:left">PMD</td>
<td style="text-align:left">页中间目录(Page Middle Directory)</td>
</tr>
<tr>
<td style="text-align:left">PAGE</td>
<td style="text-align:left">页表(Page Table)</td>
</tr>
</tbody>
</table>
</div>
<h4 id="PAGE宏–页表-Page-Table"><a href="#PAGE宏–页表-Page-Table" class="headerlink" title="PAGE宏–页表(Page Table)"></a>PAGE宏–页表(Page Table)</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PAGE_SHIFT</td>
<td style="text-align:left">指定Offset字段的位数</td>
</tr>
<tr>
<td style="text-align:left">PAGE_SIZE</td>
<td style="text-align:left">页的大小</td>
</tr>
<tr>
<td style="text-align:left">PAGE_MASK</td>
<td style="text-align:left">用以屏蔽Offset字段的所有位。</td>
</tr>
</tbody>
</table>
</div>
<p>定义如下，在<code>/arch/x86/include/asm/page_types.h</code>文件中</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* PAGE_SHIFT determines the page size */</span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PAGE_SHIFT</span>      <span class="token expression"><span class="token number">12</span></span></span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PAGE_SIZE</span>       <span class="token expression"><span class="token punctuation">(</span><span class="token function">_AC</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>UL<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> PAGE_SHIFT<span class="token punctuation">)</span></span></span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PAGE_MASK</span>       <span class="token expression"><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>PAGE_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当用于80x86处理器时，PAGE_SHIFT返回的值为12。</p>
<p>由于页内所有地址都必须放在Offset字段， 因此80x86系统的页的大小PAGE_SIZE是<code>2^12=4096</code>字节。</p>
<p>PAGE_MASK宏产生的值为0xfffff000，用以屏蔽Offset字段的所有位。</p>
<h4 id="PMD-Page-Middle-Directory-页目录"><a href="#PMD-Page-Middle-Directory-页目录" class="headerlink" title="PMD-Page Middle Directory (页目录)"></a>PMD-Page Middle Directory (页目录)</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PMD_SHIFT</td>
<td style="text-align:left">指定线性地址的Offset和Table字段的总位数；换句话说，是页中间目录项可以映射的区域大小的对数</td>
</tr>
<tr>
<td style="text-align:left">PMD_SIZE</td>
<td style="text-align:left">用于计算由页中间目录的一个单独表项所映射的区域大小，也就是一个页表的大小</td>
</tr>
<tr>
<td style="text-align:left">PMD_MASK</td>
<td style="text-align:left">用于屏蔽Offset字段与Table字段的所有位</td>
</tr>
</tbody>
</table>
</div>
<p>当PAE 被禁用时，PMD_SHIFT 产生的值为22（来自Offset 的12 位加上来自Table 的10 位），<br>PMD_SIZE 产生的值为222 或 4 MB，<br>PMD_MASK产生的值为 0xffc00000。</p>
<p>相反，当PAE被激活时，<br>PMD_SHIFT 产生的值为21 (来自Offset的12位加上来自Table的9位)，<br>PMD_SIZE 产生的值为2^21 或2 MB<br>PMD_MASK产生的值为 0xffe00000。</p>
<blockquote>
<p>大型页不使用最后一级页表，所以产生大型页尺寸的LARGE_PAGE_SIZE 宏等于PMD_SIZE(2PMD_SHIFT)，而在大型页地址中用于屏蔽Offset字段和Table字段的所有位的LARGE_PAGE_MASK宏，就等于PMD_MASK。</p>
</blockquote>
<h4 id="PUD-SHIFT-页上级目录-Page-Upper-Directory"><a href="#PUD-SHIFT-页上级目录-Page-Upper-Directory" class="headerlink" title="PUD_SHIFT-页上级目录(Page Upper Directory)"></a>PUD_SHIFT-页上级目录(Page Upper Directory)</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PUD_SHIFT</td>
<td style="text-align:left">确定页上级目录项能映射的区域大小的位数</td>
</tr>
<tr>
<td style="text-align:left">PUD_SIZE</td>
<td style="text-align:left">用于计算页全局目录中的一个单独表项所能映射的区域大小。</td>
</tr>
<tr>
<td style="text-align:left">PUD_MASK</td>
<td style="text-align:left">用于屏蔽Offset字段，Table字段，Middle Air字段和Upper Air字段的所有位</td>
</tr>
</tbody>
</table>
</div>
<p>在80x86处理器上，PUD_SHIFT总是等价于PMD_SHIFT，而PUD_SIZE则等于4MB或2MB。</p>
<h4 id="PGDIR-SHIFT-页全局目录-Page-Global-Directory"><a href="#PGDIR-SHIFT-页全局目录-Page-Global-Directory" class="headerlink" title="PGDIR_SHIFT-页全局目录(Page Global Directory)"></a>PGDIR_SHIFT-页全局目录(Page Global Directory)</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PGDIR_SHIFT</td>
<td style="text-align:left">确定页全局页目录项能映射的区域大小的位数</td>
</tr>
<tr>
<td style="text-align:left">PGDIR_SIZE</td>
<td style="text-align:left">用于计算页全局目录中一个单独表项所能映射区域的大小</td>
</tr>
<tr>
<td style="text-align:left">PGDIR_MASK</td>
<td style="text-align:left">用于屏蔽Offset, Table，Middle Air及Upper Air的所有位</td>
</tr>
</tbody>
</table>
</div>
<p>当PAE 被禁止时，<br>PGDIR_SHIFT 产生的值为22（与PMD_SHIFT 和PUD_SHIFT 产生的值相同），<br>PGDIR_SIZE 产生的值为 222 或 4 MB，<br>PGDIR_MASK 产生的值为 0xffc00000。</p>
<p>相反，当PAE被激活时，<br>PGDIR_SHIFT 产生的值为30 (12 位Offset 加 9 位Table再加 9位 Middle Air),<br>PGDIR_SIZE 产生的值为230 或 1 GB<br>PGDIR_MASK产生的值为0xc0000000</p>
<p>PTRS_PER_PTE, PTRS_PER_PMD, PTRS_PER_PUD以及PTRS_PER_PGD</p>
<p>用于计算页表、页中间目录、页上级目录和页全局目录表中表项的个数。当PAE被禁止时，它们产生的值分别为1024，1，1和1024。当PAE被激活时，产生的值分别为512，512，1和4。</p>
<h3 id="页表处理函数"><a href="#页表处理函数" class="headerlink" title="页表处理函数"></a>页表处理函数</h3><p>内核还提供了许多宏和函数用于读或修改页表表项：</p>
<ul>
<li>如果相应的表项值为0，那么，宏pte_none、pmd_none、pud_none和 pgd_none产生的值为1，否则产生的值为0。</li>
<li>宏pte_clear、pmd_clear、pud_clear和 pgd_clear清除相应页表的一个表项，由此禁止进程使用由该页表项映射的线性地址。ptep_get_and_clear( )函数清除一个页表项并返回前一个值。</li>
<li>set_pte，set_pmd，set_pud和set_pgd向一个页表项中写入指定的值。set_pte_atomic与set_pte作用相同，但是当PAE被激活时它同样能保证64位的值能被原子地写入。</li>
<li>如果a和b两个页表项指向同一页并且指定相同访问优先级，pte_same(a,b)返回1，否则返回0。</li>
<li>如果页中间目录项指向一个大型页（2MB或4MB），pmd_large(e)返回1，否则返回0。</li>
</ul>
<p>宏pmd_bad由函数使用并通过输入参数传递来检查页中间目录项。如果目录项指向一个不能使用的页表，也就是说，如果至少出现以下条件中的一个，则这个宏产生的值为1：</p>
<ul>
<li>页不在主存中（Present标志被清除）。</li>
<li>页只允许读访问(Read/Write标志被清除)。</li>
<li>Acessed或者Dirty位被清除（对于每个现有的页表，Linux总是<br>强制设置这些标志）。</li>
</ul>
<p>pud_bad宏和pgd_bad宏总是产生0。没有定义pte_bad宏，因为页表项引用一个不在主存中的页，一个不可写的页或一个根本无法访问的页都是合法的。</p>
<p>如果一个页表项的Present标志或者Page Size标志等于1，则pte_present宏产生的值为1，否则为0。</p>
<p>前面讲过页表项的Page Size标志对微处理器的分页部件来讲没有意义，然而，对于当前在主存中却又没有读、写或执行权限的页，内核将其Present和Page Size分别标记为0和1。</p>
<p>这样，任何试图对此类页的访问都会引起一个缺页异常，因为页的Present标志被清0，而内核可以通过检查Page Size的值来检测到产生异常并不是因为缺页。</p>
<p>如果相应表项的Present标志等于1，也就是说，如果对应的页或页表被装载入主存，pmd_present宏产生的值为1。pud_present宏和pgd_present宏产生的值总是1。</p>
<h4 id="查询页表项中任意一个标志的当前值"><a href="#查询页表项中任意一个标志的当前值" class="headerlink" title="查询页表项中任意一个标志的当前值"></a>查询页表项中任意一个标志的当前值</h4><p>下表中列出的函数用来查询页表项中任意一个标志的当前值；除了pte_file()外，其他函数只有在pte_present返回1的时候，才能正常返回页表项中任意一个标志。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">pte_user( )</td>
<td style="text-align:left">读 User/Supervisor 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_read( )</td>
<td style="text-align:left">读 User/Supervisor 标志（表示 80x86 处理器上的页不受读的保护）</td>
</tr>
<tr>
<td style="text-align:left">pte_write( )</td>
<td style="text-align:left">读 Read/Write 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_exec( )</td>
<td style="text-align:left">读 User/Supervisor 标志（ 80x86 处理器上的页不受代码执行的保护）</td>
</tr>
<tr>
<td style="text-align:left">pte_dirty( )</td>
<td style="text-align:left">读 Dirty 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_young( )</td>
<td style="text-align:left">读 Accessed 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_file( )</td>
<td style="text-align:left">读 Dirty 标志（当 Present 标志被清除而 Dirty 标志被设置时，页属于一个非线性磁盘文件映射）</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-3-2-设置页表项中各标志的值"><a href="#2-3-2-设置页表项中各标志的值" class="headerlink" title="2.3.2 设置页表项中各标志的值"></a>2.3.2 设置页表项中各标志的值</h4><p>下表列出的另一组函数用于设置页表项中各标志的值</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">mk_pte_huge( )</td>
<td style="text-align:left">设置页表项中的 Page Size 和 Present 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_wrprotect( )</td>
<td style="text-align:left">清除 Read/Write 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_rdprotect( )</td>
<td style="text-align:left">清除 User/Supervisor 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_exprotect( )</td>
<td style="text-align:left">清除 User/Supervisor 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_mkwrite( )</td>
<td style="text-align:left">设置 Read/Write 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_mkread( )</td>
<td style="text-align:left">设置 User/Supervisor 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_mkexec( )</td>
<td style="text-align:left">设置 User/Supervisor 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_mkclean( )</td>
<td style="text-align:left">清除 Dirty 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_mkdirty( )</td>
<td style="text-align:left">设置 Dirty 标志</td>
</tr>
<tr>
<td style="text-align:left">pte_mkold( )</td>
<td style="text-align:left">清除 Accessed 标志（把此页标记为未访问）</td>
</tr>
<tr>
<td style="text-align:left">pte_mkyoung( )</td>
<td style="text-align:left">设置 Accessed 标志（把此页标记为访问过）</td>
</tr>
<tr>
<td style="text-align:left">pte_modify(p,v)</td>
<td style="text-align:left">把页表项 p 的所有访问权限设置为指定的值</td>
</tr>
<tr>
<td style="text-align:left">ptep_set_wrprotect()</td>
<td style="text-align:left">与 pte_wrprotect( ) 类似，但作用于指向页表项的指针</td>
</tr>
<tr>
<td style="text-align:left">ptep_set_access_flags( )</td>
<td style="text-align:left">如果 Dirty 标志被设置为 1 则将页的访问权设置为指定的值，并调用flush_tlb_page() 函数</td>
</tr>
<tr>
<td style="text-align:left">ptep_mkdirty()</td>
<td style="text-align:left">与 pte_mkdirty( ) 类似，但作用于指向页表项的指针。</td>
</tr>
<tr>
<td style="text-align:left">ptep_test_and_clear_dirty( )</td>
<td style="text-align:left">与 pte_mkclean( ) 类似，但作用于指向页表项的指针并返回 Dirty 标志的旧值</td>
</tr>
<tr>
<td style="text-align:left">ptep_test_and_clear_young( )</td>
<td style="text-align:left">与 pte_mkold( ) 类似，但作用于指向页表项的指针并返回 Accessed标志的旧值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="宏函数-把一个页地址和一组保护标志组合成页表项，或者执行相反的操作"><a href="#宏函数-把一个页地址和一组保护标志组合成页表项，或者执行相反的操作" class="headerlink" title="宏函数-把一个页地址和一组保护标志组合成页表项，或者执行相反的操作"></a>宏函数-把一个页地址和一组保护标志组合成页表项，或者执行相反的操作</h4><p>现在，我们来讨论下表中列出的宏，它们把一个页地址和一组保护标志组合成页表项，或者执行相反的操作，从一个页表项中提取出页地址。请注意这其中的一些宏对页的引用是通过 “页描述符”的线性地址，而不是通过该页本身的线性地址。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">宏名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">pgd_index(addr)</td>
<td style="text-align:left">找到线性地址 addr 对应的的目录项在页全局目录中的索引（相对位置）</td>
</tr>
<tr>
<td style="text-align:left">pgd_offset(mm, addr)</td>
<td style="text-align:left">接收内存描述符地址 mm 和线性地址 addr 作为参数。这个宏产生地址addr 在页全局目录中相应表项的线性地址；通过内存描述符 mm 内的一个指针可以找到这个页全局目录</td>
</tr>
<tr>
<td style="text-align:left">pgd_offset_k(addr)</td>
<td style="text-align:left">产生主内核页全局目录中的某个项的线性地址，该项对应于地址 addr</td>
</tr>
<tr>
<td style="text-align:left">pgd_page(pgd)</td>
<td style="text-align:left">通过页全局目录项 pgd 产生页上级目录所在页框的页描述符地址。在两级或三级分页系统中，该宏等价于 pud_page() ，后者应用于页上级目录项</td>
</tr>
<tr>
<td style="text-align:left">pud_offset(pgd, addr)</td>
<td style="text-align:left">参数为指向页全局目录项的指针 pgd 和线性地址 addr 。这个宏产生页上级目录中目录项 addr 对应的线性地址。在两级或三级分页系统中，该宏产生 pgd ，即一个页全局目录项的地址</td>
</tr>
<tr>
<td style="text-align:left">pud_page(pud)</td>
<td style="text-align:left">通过页上级目录项 pud 产生相应的页中间目录的线性地址。在两级分页系统中，该宏等价于 pmd_page() ，后者应用于页中间目录项</td>
</tr>
<tr>
<td style="text-align:left">pmd_index(addr)</td>
<td style="text-align:left">产生线性地址 addr 在页中间目录中所对应目录项的索引（相对位置）</td>
</tr>
<tr>
<td style="text-align:left">pmd_offset(pud, addr)</td>
<td style="text-align:left">接收指向页上级目录项的指针 pud 和线性地址 addr 作为参数。这个宏产生目录项 addr 在页中间目录中的偏移地址。在两级或三级分页系统中，它产生 pud ，即页全局目录项的地址</td>
</tr>
<tr>
<td style="text-align:left">pmd_page(pmd)</td>
<td style="text-align:left">通过页中间目录项 pmd 产生相应页表的页描述符地址。在两级或三级分页系统中， pmd 实际上是页全局目录中的一项</td>
</tr>
<tr>
<td style="text-align:left">mk_pte(p,prot)</td>
<td style="text-align:left">接收页描述符地址 p 和一组访问权限 prot 作为参数，并创建相应的页表项</td>
</tr>
<tr>
<td style="text-align:left">pte_index(addr)</td>
<td style="text-align:left">产生线性地址 addr 对应的表项在页表中的索引（相对位置）</td>
</tr>
<tr>
<td style="text-align:left">pte_offset_kernel(dir,addr)</td>
<td style="text-align:left">线性地址 addr 在页中间目录 dir 中有一个对应的项，该宏就产生这个对应项，即页表的线性地址。另外，该宏只在主内核页表上使用</td>
</tr>
<tr>
<td style="text-align:left">pte_offset_map(dir, addr)</td>
<td style="text-align:left">接收指向一个页中间目录项的指针 dir 和线性地址 addr 作为参数，它产生与线性地址 addr 相对应的页表项的线性地址。如果页表被保存在高端存储器中，那么内核建立一个临时内核映射，并用 pte_unmap 对它进行释放。 pte_offset_map_nested 宏和 pte_unmap_nested 宏是相同的，但它们使用不同的临时内核映射</td>
</tr>
<tr>
<td style="text-align:left">pte_page( x )</td>
<td style="text-align:left">返回页表项 x 所引用页的描述符地址</td>
</tr>
<tr>
<td style="text-align:left">pte_to_pgoff( pte )</td>
<td style="text-align:left">从一个页表项的 pte 字段内容中提取出文件偏移量，这个偏移量对应着一个非线性文件内存映射所在的页</td>
</tr>
<tr>
<td style="text-align:left">pgoff_to_pte(offset )</td>
<td style="text-align:left">为非线性文件内存映射所在的页创建对应页表项的内容</td>
</tr>
</tbody>
</table>
</div>
<h4 id="简化页表项的创建和撤消"><a href="#简化页表项的创建和撤消" class="headerlink" title="简化页表项的创建和撤消"></a>简化页表项的创建和撤消</h4><p>下面我们罗列最后一组函数来简化页表项的创建和撤消。当使用两级页表时，创建或删除一个页中间目录项是不重要的。如本节前部分所述，页中间目录仅含有一个指向下属页表的目录项。所以，页中间目录项只是页全局目录中的一项而已。然而当处理页表时，创建一个页表项可能很复杂，因为包含页表项的那个页表可能就不存在。在这样的情况下，有必要分配一个新页框，把它填写为 0 ，并把这个表项加入。</p>
<p>如果 PAE 被激活，内核使用三级页表。当内核创建一个新的页全局目录时，同时也分配四个相应的页中间目录；只有当父页全局目录被释放时，这四个页中间目录才得以释放。当使用两级或三级分页时，页上级目录项总是被映射为页全局目录中的一个单独项。与以往一样，下表中列出的函数描述是针对 80x86 构架的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">函数名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">pgd_alloc( mm )</td>
<td style="text-align:left">分配一个新的页全局目录。如果 PAE 被激活，它还分配三个对应用户态线性地址的子页中间目录。参数 mm( 内存描述符的地址 )在 80x86 构架上被忽略</td>
</tr>
<tr>
<td style="text-align:left">pgd_free( pgd)</td>
<td style="text-align:left">释放页全局目录中地址为 pgd 的项。如果 PAE 被激活，它还将释放用户态线性地址对应的三个页中间目录</td>
</tr>
<tr>
<td style="text-align:left">pud_alloc(mm, pgd, addr)</td>
<td style="text-align:left">在两级或三级分页系统下，这个函数什么也不做：它仅仅返回页全局目录项 pgd 的线性地址</td>
</tr>
<tr>
<td style="text-align:left">pud_free(x)</td>
<td style="text-align:left">在两级或三级分页系统下，这个宏什么也不做</td>
</tr>
<tr>
<td style="text-align:left">pmd_alloc(mm, pud, addr)</td>
<td style="text-align:left">定义这个函数以使普通三级分页系统可以为线性地址 addr 分配一个新的页中间目录。如果 PAE 未被激活，这个函数只是返回输入参数 pud 的值，也就是说，返回页全局目录中目录项的地址。如果 PAE 被激活，该函数返回线性地址 addr 对应的页中间目录项的线性地址。参数 mm 被忽略</td>
</tr>
<tr>
<td style="text-align:left">pmd_free(x)</td>
<td style="text-align:left">该函数什么也不做，因为页中间目录的分配和释放是随同它们的父全局目录一同进行的</td>
</tr>
<tr>
<td style="text-align:left">pte_alloc_map(mm, pmd, addr)</td>
<td style="text-align:left">接收页中间目录项的地址 pmd 和线性地址 addr 作为参数，并返回与 addr 对应的页表项的地址。如果页中间目录项为空，该函数通过调用函数 pte_alloc_one( ) 分配一个新页表。如果分配了一个新页表， addr 对应的项就被创建，同时 User/Supervisor 标志被设置为 1 。如果页表被保存在高端内存，则内核建立一个临时内核映射，并用 pte_unmap 对它进行释放</td>
</tr>
<tr>
<td style="text-align:left">pte_alloc_kernel(mm, pmd, addr)</td>
<td style="text-align:left">如果与地址 addr 相关的页中间目录项 pmd 为空，该函数分配一个新页表。然后返回与 addr 相关的页表项的线性地址。该函数仅被主内核页表使用</td>
</tr>
<tr>
<td style="text-align:left">pte_free(pte)</td>
<td style="text-align:left">释放与页描述符指针 pte 相关的页表</td>
</tr>
<tr>
<td style="text-align:left">pte_free_kernel(pte)</td>
<td style="text-align:left">等价于 pte_free( ) ，但由主内核页表使用</td>
</tr>
<tr>
<td style="text-align:left">clear_page_range(mmu, start,end)</td>
<td style="text-align:left">从线性地址 start 到 end 通过反复释放页表和清除页中间目录项来清除进程页表的内容</td>
</tr>
</tbody>
</table>
</div>
<h2 id="处理硬件高速缓存与TLB"><a href="#处理硬件高速缓存与TLB" class="headerlink" title="处理硬件高速缓存与TLB"></a>处理硬件高速缓存与TLB</h2><ol>
<li><p><code>void flush_tlb_all(void)</code></p>
<blockquote>
<p>最严格的刷新。在这个接口运行后，任何以前的页表修改都会对cpu可见。</p>
<p>这通常是在内核页表被改变时调用的，因为这种转换在本质上是“全局”的。</p>
</blockquote>
</li>
<li><p><code>void flush_tlb_mm(struct mm_struct *mm)</code></p>
<blockquote>
<p>这个接口从TLB中刷新整个用户地址空间。在运行后，这个接口必须确保 以前对地址空间‘mm’的任何页表修改对cpu来说是可见的。也就是说，在 运行后，TLB中不会有‘mm’的页表项。</p>
<p>这个接口被用来处理整个地址空间的页表操作，比如在fork和exec过程 中发生的事情。</p>
</blockquote>
</li>
<li><p><code>void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)</code></p>
<blockquote>
<p>这里我们要从TLB中刷新一个特定范围的（用户）虚拟地址转换。在运行后， 这个接口必须确保以前对‘start’到‘end-1’范围内的地址空间‘vma-&gt;vm_mm’ 的任何页表修改对cpu来说是可见的。也就是说，在运行后，TLB中不会有 ‘mm’的页表项用于‘start’到‘end-1’范围内的虚拟地址。</p>
<p>“vma”是用于该区域的备份存储。主要是用于munmap()类型的操作。</p>
<p>提供这个接口是希望端口能够找到一个合适的有效方法来从TLB中删除多 个页面大小的转换，而不是让内核为每个可能被修改的页表项调用 flush_tlb_page(见下文)。</p>
</blockquote>
</li>
<li><p><code>void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)</code></p>
<blockquote>
<p>这一次我们需要从TLB中删除PAGE_SIZE大小的转换。‘vma’是Linux用来跟 踪进程的mmap区域的支持结构体，地址空间可以通过vma-&gt;vm_mm获得。另 外，可以通过测试（vma-&gt;vm_flags &amp; VM_EXEC）来查看这个区域是否是 可执行的（因此在split-tlb类型的设置中可能在“指令TLB”中）。</p>
<p>在运行后，这个接口必须确保之前对用户虚拟地址“addr”的地址空间 “vma-&gt;vm_mm”的页表修改对cpu来说是可见的。也就是说，在运行后，TLB 中不会有虚拟地址‘addr’的‘vma-&gt;vm_mm’的页表项。</p>
<p>这主要是在故障处理时使用。</p>
</blockquote>
</li>
<li><p><code>void update_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)</code></p>
<blockquote>
<p>在每个缺页异常结束时，这个程序被调用，以告诉体系结构特定的代码，在 软件页表中，在地址空间“vma-&gt;vm_mm”的虚拟地址“地址”处，现在存在 一个翻译。</p>
<p>可以用它所选择的任何方式使用这个信息来进行移植。例如，它可以使用这 个事件来为软件管理的TLB配置预装TLB转换。目前sparc64移植就是这么干 的。</p>
</blockquote>
</li>
</ol>
<p>接下来，我们有缓存刷新接口。一般来说，当Linux将现有的虚拟-&gt;物理映射 改变为新的值时，其顺序将是以下形式之一:</p>
<pre class="line-numbers language-none"><code class="language-none">1) flush_cache_mm(mm);
        change_all_page_tables_of(mm);
        flush_tlb_mm(mm);

2) flush_cache_range(vma, start, end);
        change_range_of_page_tables(mm, start, end);
        flush_tlb_range(vma, start, end);

3) flush_cache_page(vma, addr, pfn);
        set_pte(pte_pointer, new_pte_val);
        flush_tlb_page(vma, addr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    缓存级别的刷新将永远是第一位的，因为这允许我们正确处理那些缓存严格， 且在虚拟地址被从缓存中刷新时要求一个虚拟地址的虚拟-&gt;物理转换存在的系统。 HyperSparc cpu就是这样一个具有这种属性的cpu。</p>
<p>​    下面的缓存刷新程序只需要在特定的cpu需要的范围内处理缓存刷新。大多数 情况下，这些程序必须为cpu实现，这些cpu有虚拟索引的缓存，当虚拟-&gt;物 理转换被改变或移除时：必须被刷新。因此，例如，IA32处理器的物理索引的物理标记的缓存没有必要实现这些接口，因为这些缓存是完全同步的，并且不依赖于翻译信息。</p>
<p>下面逐个列出这些程序:</p>
<ol>
<li><p><code>void flush_cache_mm(struct mm_struct *mm)</code></p>
<blockquote>
<p>这个接口将整个用户地址空间从高速缓存中刷掉。也就是说，在运行后， 将没有与‘mm’相关的缓存行。</p>
<p>这个接口被用来处理整个地址空间的页表操作，比如在退出和执行过程 中发生的事情。</p>
</blockquote>
</li>
<li><p><code>void flush_cache_dup_mm(struct mm_struct *mm)</code></p>
<blockquote>
<p>这个接口将整个用户地址空间从高速缓存中刷新掉。也就是说，在运行 后，将没有与‘mm’相关的缓存行。</p>
<p>这个接口被用来处理整个地址空间的页表操作，比如在fork过程中发生 的事情。</p>
<p>这个选项与flush_cache_mm分开，以允许对VIPT缓存进行一些优化。</p>
</blockquote>
</li>
<li><p><code>void flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)</code></p>
<blockquote>
<p>在这里，我们要从缓存中刷新一个特定范围的（用户）虚拟地址。运行 后，在“start”到“end-1”范围内的虚拟地址的“vma-&gt;vm_mm”的缓存中 将没有页表项。</p>
<p>“vma”是被用于该区域的备份存储。主要是用于munmap()类型的操作。</p>
<p>提供这个接口是希望端口能够找到一个合适的有效方法来从缓存中删 除多个页面大小的区域， 而不是让内核为每个可能被修改的页表项调 用 flush_cache_page (见下文)。</p>
</blockquote>
</li>
<li><p><code>void flush_cache_page(struct vm_area_struct *vma, unsigned long addr, unsigned long pfn)</code></p>
<blockquote>
<p>这一次我们需要从缓存中删除一个PAGE_SIZE大小的区域。“vma”是 Linux用来跟踪进程的mmap区域的支持结构体，地址空间可以通过 vma-&gt;vm_mm获得。另外，我们可以通过测试（vma-&gt;vm_flags &amp; VM_EXEC）来查看这个区域是否是可执行的（因此在“Harvard”类 型的缓存布局中可能是在“指令缓存”中）。</p>
<p>“pfn”表示“addr”所对应的物理页框（通过PAGE_SHIFT左移这个 值来获得物理地址）。正是这个映射应该从缓存中删除。</p>
<p>在运行之后，对于虚拟地址‘addr’的‘vma-&gt;vm_mm’，在缓存中不会 有任何页表项，它被翻译成‘pfn’。</p>
<p>这主要是在故障处理过程中使用。</p>
</blockquote>
</li>
<li><p><code>void flush_cache_kmaps(void)</code></p>
<blockquote>
<p>只有在平台使用高位内存的情况下才需要实现这个程序。它将在所有的 kmaps失效之前被调用。</p>
<p>运行后，内核虚拟地址范围PKMAP_ADDR(0)到PKMAP_ADDR(LAST_PKMAP) 的缓存中将没有页表项。</p>
<p>这个程序应该在asm/highmem.h中实现。</p>
</blockquote>
</li>
<li><p><code>void flush_cache_vmap(unsigned long start, unsigned long end)</code> <code>void flush_cache_vunmap(unsigned long start, unsigned long end)</code></p>
<blockquote>
<p>在这里，在这两个接口中，我们从缓存中刷新一个特定范围的（内核） 虚拟地址。运行后，在“start”到“end-1”范围内的虚拟地址的内核地 址空间的缓存中不会有页表项。</p>
<p>这两个程序中的第一个是在vmap_range()安装了页表项之后调用的。 第二个是在vunmap_range()删除页表项之前调用的。</p>
</blockquote>
<p>​    这是处理页表的一些API：</p>
</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">void copy_user_page(void *to, void *from, unsigned long addr, struct page *page)&#96; &#96;void clear_user_page(void *to, unsigned long addr, struct page *page)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>这两个程序在用户匿名或COW页中存储数据。它允许一个端口有效地 避免用户空间和内核之间的D-cache别名问题。</p>
<p>例如，一个端口可以在复制过程中把“from”和“to”暂时映射到内核 的虚拟地址上。这两个页面的虚拟地址的选择方式是，内核的加载/存 储指令发生在虚拟地址上，而这些虚拟地址与用户的页面映射是相同 的“颜色”。例如，Sparc64就使用这种技术。</p>
<p>“addr”参数告诉了用户最终要映射这个页面的虚拟地址，“page”参 数给出了一个指向目标页结构体的指针。</p>
<p>如果D-cache别名不是问题，这两个程序可以简单地直接调用 memcpy/memset而不做其他事情。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void flush_dcache_page(struct page *page)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>任何时候，当内核写到一个页面缓存页，或者内核要从一个页面缓存页中读出，并且这个页面的用户空间共享/可写映射可能存在时， 这个程序就会被调用。</p>
<p>​    这个程序只需要为有可能被映射到用户进程的地址空间的 页面缓存调用。因此，例如，处理页面缓存中vfs符号链 接的VFS层代码根本不需要调用这个接口。“内核写入页面缓存的页面”这句话的意思是，具体来说，内核执行存 储指令，在该页面的页面-&gt;虚拟映射处弄脏该页面的数据。在这里，通 过刷新的手段处理D-cache的别名是很重要的，以确保这些内核存储对 该页的用户空间映射是可见的。推论的情况也同样重要，如果有用户对这个文件有共享+可写的映射， 我们必须确保内核对这些页面的读取会看到用户所做的最新的存储。</p>
<p>​    如果D-cache别名不是一个问题，这个程序可以简单地定义为该架构上 的nop。在page-&gt;flags (PG_arch_1)中有一个位是“架构私有”。内核保证， 对于分页缓存的页面，当这样的页面第一次进入分页缓存时，它将清除这个位。这使得这些接口可以更有效地被实现。如果目前没有用户进程映射这个 页面，它允许我们“推迟”（也许是无限期）实际的刷新过程。请看 sparc64的flush_dcache_page和update_mmu_cache实现，以了解如 何做到这一点。</p>
<p>​    这个想法是，首先在flush_dcache_page()时，如果page-&gt;mapping-&gt;i_mmap 是一个空树，只需标记架构私有页标志位。之后，在update_mmu_cache() 中，会对这个标志位进行检查，如果设置了，就进行刷新，并清除标志位。通常很重要的是，如果你推迟刷新，实际的刷新发生在同一个 CPU上，因为它将cpu存储到页面上，使其变脏。同样，请看 sparc64关于如何处理这个问题的例子。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void flush_dcache_folio(struct folio *folio)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>该函数的调用情形与flush_dcache_page()相同。它允许架构针对刷新整个 folio页面进行优化，而不是一次刷新一页。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void copy_to_user_page(struct vm_area_struct *vma, struct page *page, unsigned long user_vaddr, void *dst, void *src, int len)&#96; &#96;void copy_from_user_page(struct vm_area_struct *vma, struct page *page, unsigned long user_vaddr, void *dst, void *src, int len)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>当内核需要复制任意的数据进出任意的用户页时（比如ptrace()），它将使 用这两个程序。</p>
<p>任何必要的缓存刷新或其他需要发生的一致性操作都应该在这里发生。如果 处理器的指令缓存没有对cpu存储进行窥探，那么你很可能需要为 copy_to_user_page()刷新指令缓存。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void flush_anon_page(struct vm_area_struct *vma, struct page *page, unsigned long vmaddr)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>当内核需要访问一个匿名页的内容时，它会调用这个函数（目前只有 get_user_pages()）。注意：flush_dcache_page()故意对匿名页不起作 用。默认的实现是nop（对于所有相干的架构应该保持这样）。对于不一致性 的架构，它应该刷新vmaddr处的页面缓存。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void flush_icache_range(unsigned long start, unsigned long end)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>当内核存储到它将执行的地址中时（例如在加载模块时），这个函数被调用。</p>
<p>如果icache不对存储进行窥探，那么这个程序将需要对其进行刷新。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void flush_icache_page(struct vm_area_struct *vma, struct page *page)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>flush_icache_page的所有功能都可以在flush_dcache_page和update_mmu_cache 中实现。在未来，我们希望能够完全删除这个接口。</p>
</blockquote>
<p>​    最后一类API是用于I/O到内核内特意设置的别名地址范围。这种别名是通过使用 vmap/vmalloc API设置的。由于内核I/O是通过物理页进行的，I/O子系统假定用户 映射和内核偏移映射是唯一的别名。这对vmap别名来说是不正确的，所以内核中任何 试图对vmap区域进行I/O的东西都必须手动管理一致性。它必须在做I/O之前刷新vmap 范围，并在I/O返回后使其失效。</p>
<blockquote>
<pre class="line-numbers language-none"><code class="language-none">void flush_kernel_vmap_range(void *vaddr, int size)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>刷新vmap区域中指定的虚拟地址范围的内核缓存。这是为了确保内核在vmap范围 内修改的任何数据对物理页是可见的。这个设计是为了使这个区域可以安全地执 行I/O。注意，这个API并 <em>没有</em> 刷新该区域的偏移映射别名。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void invalidate_kernel_vmap_range(void *vaddr, int size) invalidates<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>在vmap区域的一个给定的虚拟地址范围的缓存，这可以防止处理器在物理页的I/O 发生时通过投机性地读取数据而使缓存变脏。这只对读入vmap区域的数据是必要的。</p>
</blockquote>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www。cnblogs。com/jason-lu/archive/2012/11/22/2783184。html#:~:text=物理地址扩展 (PAE">物理地址扩展(PAE)分页机制 - 冷烟花 - 博客园 (cnblogs。com)</a>分页机制 常规分页机制32位地址线理论上可以寻址4GB的RAM地址空间%2C但是%2C大型的服务器需要大雨4GB的RAM来同时运行数以千计的进程%2C因此%2CIntel通过在处理器上把管脚数从32增加到36%2C以提高处理器的寻址能力%2C使其达到2^36%3D64GB%2C同时引入了一种新的分页机制PAE，(Physical Address Extension%2C物理地址扩展)把32位线性地址转换为36位物理地址才能使用所增加的物理内存%2C通过设置CR4的第5位来开启对PAE的支持。引入PAE就是为了访问大于4GB的RAM%2C线性地址仍然是32位%2C而物理地址是36位。)</p>
<p><a target="_blank" rel="noopener" href="https://www。cnblogs。com/ck1020/p/6078214。html">PAE 分页模式详解 - jack。chen - 博客园 (cnblogs。com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linhaostudy/p/10038100.html">Linux分页机制之分页机制的实现详解—Linux内存管理(八) - yooooooo - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/translations/zh_CN/core-api/cachetlb.html">Linux下的缓存和TLB刷新 — The Linux Kernel documentation</a></p>
</blockquote>
<h1 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h1><p>​    下面开始讨论一个非常重要的抽象：这在我们前边已经提到过了的！也就是进程！</p>
<p>​    进程在使用中常有几个不同的含义，比如说在一般的操作系统教科书中给出了通用定义是：</p>
<blockquote>
<p>进程是程序执行的一个实例</p>
</blockquote>
<p>​    进程就像生命一般他们被产生，有或多或少的有效生命周期，，可以产生一个或者多个子进程，但是它们最终都会死亡！从内核观点上看进程的目的就是分配系统资源的一个实体</p>
<p>​    当一个进程创建时，它几乎与父进程相同。它接收父进程地址空间的一个逻辑拷贝，并开始执行父进程相同的代码！</p>
<p>​    Linux使用轻量级进程，对多线程应用程序提供了更好的支持。两个轻量级进程基本上可以共享一些资源诸如打开的文件，地址空间等。只要其中一个修改了共享资源，另一个就立即查看各种修改</p>
<h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>​    为了管理进程，内核必须对每个进程所做的事情有清楚的描述！</p>
<p>​    首先我们要看的是进程的状态：顾名思义当我们查看源码时，进程描述符中的state字段就描述了进程当前的状态。它由一组标志组成。有以下几种可能的状态：</p>
<ul>
<li>可运行状态(TASK_RUNNING)：其进程要么在CPU上执行要么准备执行与</li>
<li>可中断的等待状态(TASK_INTERRUPTIBLE)：进程被挂起直到某个条件为真，产生一个硬件中断，释放进程，正等待的系统资源或传递一个信号都是可以唤醒进程的条件</li>
<li>不可中断的等待状态(TASK_UNINTERRUPTIBLE)：与可中断的等待状态类似，但是有一个例外：把信号传递到睡眠进程不能改变它的状态。这种状态很少用到，但在一些特定的情况下，也就是要求进程必须等待直到一个不能被中断的事件发生时，这种状态很有用！例如当进程打开一个设备文件，设备驱动程序开始探测相应的硬件设备时会用到这个状态，探测完成以前设备驱动程序是不可以被中断的！否则硬件设备会处于一种不可预知的状态！</li>
<li>暂停状态(TASK_STOPPED)：进程的执行被暂停，当进程接收到这四个信号：SIGSTOP，SIGTSTP，SIGTTIN，SIGTTOU，进入暂停状态</li>
<li>跟踪状态(TASK_TRACED)：进程的执行已经被调试程序暂停，当一个进程被另一个进程监控时，任何信号都可以把这个进程置于这个状态！</li>
</ul>
<p>​    还有两个进程状态，是既可以存放在进程描述符当中，，也可以存放在退出状态字段当中！</p>
<ul>
<li>僵死状态：进程的执行被终止，但是父进程并没有发布wait4或wait pid系统调用来返回有关死亡进程的信息</li>
<li>将死撤销状态：最终状态由于父进程发出了上面提到的两个系统调用，因而进程由系统进行删除。为了防止其他执行进程在同一进程上也执行wait类系统调用而把进程的状态由僵死状态设为僵死撤销状态！</li>
</ul>
<h3 id="标识一个进程"><a href="#标识一个进程" class="headerlink" title="标识一个进程"></a>标识一个进程</h3><p>​    一般来说能被独立调度的每个进程上下文都必须有它自己的进程描述符！也就是pid。pid存放在进程描述符的pid字段中，它被顺序编号。内核使用一个pid_map_array位图来表示当前已经被分配的pid号和闲置的pid号。</p>
<p>​    进程描述符处理进程是动态实体，因此内核必须能够同时处理很多进程！并把进程描述符存放在动态内存中，而不是永久分配给内核的内存区！</p>
<p>​    标识当前进程是使用一个叫做thread_info的结构。进程最常用地址不是thread_info地址而是进程描述符的地址，为了获得当前CPU上运行形成的描述符指针内核需要调用current宏。该宏本质上等价于<code>current thread info()-&gt;task</code></p>
<h3 id="进程组织"><a href="#进程组织" class="headerlink" title="进程组织"></a>进程组织</h3><p>​    Linux使用双向链表来管理进程！被称为进程链表。</p>
<p>​    task_running状态的进程列表，当内核寻找一个新进程在CPU上运行时，必须只考虑可以运行的。进程在Linux 2.6实现的运行队列与之前的实现有所不同，其目的是让调度程序能够在固定时间内选出最佳的可知运行进程！与队列中的可运行的进程数无关</p>
<h3 id="进程之间的关系"><a href="#进程之间的关系" class="headerlink" title="进程之间的关系"></a>进程之间的关系</h3><p>​    程序创建的进程具有父子关系。如果一个进程创建多个子进程，则多个子进程之间又有兄弟关系。进程描述符中表示进程亲属关系的字段描述如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>描述符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>real parent</td>
<td>指向创建了P的进程的描述符,如果P的进程不再存在就指向进程init进程描述符</td>
</tr>
<tr>
<td>parent</td>
<td>P的当前父进程，它的值通常与real parent一致。但偶尔有所不同，比如说另一个进程发出监控P的Ptrace调用时。</td>
</tr>
<tr>
<td>Children</td>
<td>链表的头部链表中的所有元素都是P创建的子进程</td>
</tr>
<tr>
<td>sibling</td>
<td>指向兄弟进程链表中的下一个元素，或前一个元素的指针。这些兄弟进程的父进程都是P</td>
</tr>
</tbody>
</table>
</div>
<h3 id="如何组织进程"><a href="#如何组织进程" class="headerlink" title="如何组织进程"></a>如何组织进程</h3><p>​    运行队列链表把处于task running状态的所有进程组织在，一起不同的状态要求不同的处理！Linux选择下面的方式之一：</p>
<p>​    没有未处理<code>task_stopped</code>和<code>exit_zombie</code>或者是<code>exit_dead</code>状态的进程建立专门的链表。由于对处于暂停僵死，死亡状态进程的访问比较简单，或者通过pid或者通过特定父进程的子进程链表。所以不必对这三种状态进行分组</p>
<p>​    根据不同的特殊事件把处于<code>task_interrupttable</code>或<code>task_uninterruptable</code>状态的进程细分为许多类，每个类都对应一个特殊事件。</p>
<p>​    在这种情况下进程状态提供的信息满足不了快速检索进程的需要，所以需要另外引入进程列表！</p>
<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>​    等待队列在内核中有很多用途！特别是在处理中断处理进程同步及定时（进程必须经常等待某些事情的发生——等待队列是由双向链表所实现的！关于具体操作可以参看相关的博客。</p>
<h2 id="进程资源限制"><a href="#进程资源限制" class="headerlink" title="进程资源限制"></a>进程资源限制</h2><p>​    每一个进程都有资源限制：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rlimit</span> <span class="token punctuation">&#123;</span>
               <span class="token class-name">rlim_t</span> rlim_cur<span class="token punctuation">;</span>  <span class="token comment">/* Soft limit */</span>
               <span class="token class-name">rlim_t</span> rlim_max<span class="token punctuation">;</span>  <span class="token comment">/* Hard limit (ceiling for rlim_cur) */</span>
           <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这是常见的一些限制</p>
<ul>
<li>RLIMIT_AS<ul>
<li>进程虚拟内存限制大小（字节数），即进程总的可用存储空间的最大长度</li>
<li>yixie试图（brk()、sbrk()、mmap()、mremap()以及 shmat()）超出这个限制会得到 ENOMEM 错误。</li>
<li>在实践中，程序中会超出这个限制的最常见的地方是在调用 malloc 包中的函数时，因为它们会使用 sbrk()和mmap()。当碰到这个限制时，栈增长操作也会失败，进而会出现下面 RLIMIT_STACK 限制中列出的情况。</li>
</ul>
</li>
<li>RLIMIT_CORE<ul>
<li>核心文件大小（字节数），即core文件的最大字节数</li>
<li>当达到这个限制时，核心 dump 文件就不会再产生了</li>
<li>如果值为0标识阻止创建core文件<ul>
<li>这种做法有时候是比较有用的，因为核心 dump 文件可能会变得非常大，而最终用户通常又不知道如何处理这些文件。</li>
<li>另一个禁用核心 dump文件的原因是安全性——防止程序占用的内存中的内容输出到磁盘上。</li>
<li>如果 RLIMIT_FSIZE限制值低于这个限制值，那么核心 dump 文件的最大大小会被限制为 RLIMIT_FSIZE 字节。</li>
</ul>
</li>
</ul>
</li>
<li>RLIMIT_CPU<ul>
<li>进程最多使用的 CPU 时间（包括系统模式和用户模式）。</li>
<li>当超过此软限制时，向该进程发送SIGXCPU信号（SIGXCPU 信号的默认动作是终止一个进程并输出一个核心 dump。此外，也可以捕获这个信号并将控制返回给主程序。）。</li>
<li>不同的 UNIX 实现对进程处理完 SIGXCPU 信号之后继续消耗 CPU 时间这种情况的处理方式不同。大多数会每隔固定时间间隔向进程发送一个 SIGXCPU 信号。</li>
<li>在达到软限制值之后，Linux 内核会在进程每消耗一秒钟的 CPU 时间后向其发送一个 SIGXCPU 信号。当进程持续执行直至达到硬 CPU 限制时，内核会向其发送一个 SIGKILL 信号，该信号总是会终止进程。</li>
</ul>
</li>
<li>RLIMIT_DATA<ul>
<li>数据段的最大字节长度。这是初始化数据段、非初始化数据段、堆的总和</li>
<li>试图（sbrk()和 brk()）访问这个限制之外的数据段会得到ENOMEM 的错误。</li>
<li>与 RLIMIT_AS 一样，程序中会超出这个限制的最常见的地方是在调用malloc 包中的函数时。</li>
</ul>
</li>
<li>RLIMIT_FSIZE<ul>
<li>文件大小（字节数），即可以创建的文件的最大字节长度</li>
<li>当超过此软限制时，向该进程发送SIGXFSZ信号。并且系统调用（如 write()或truncate()）会返回EFBIG错误。</li>
<li>SIGXFSZ信号的默认动作是终止进程并产生一个核心dump。此外，也可以捕获这个信号并将控制返回给主程序。不管怎样，后续视图扩充该文件的操作都会得到同样的信号和错误。</li>
</ul>
</li>
<li>RLIMIT_MEMLOCK<ul>
<li>一个进程最多能够将多少字节的虚拟内存锁进物理内存以防止内存被交换出去</li>
<li>这个限制会影响 mlock()和 mlockall()系统调用以及 mmap()和 shmctl()系统调用的加锁参数</li>
<li>如果在调用 mlockall()时指定了 MCL_FUTURE 标记，那么 RLIMIT_MEMLOCK 限制也会导致后续的 brk()、sbrk()、mmap()和 mremap()调用失败</li>
</ul>
</li>
<li>RLIMIT_MSGQUEUE<ul>
<li>能够为调用进程的真实用户 ID 的 POSIX 消息队列分配的最大字节数。</li>
<li>RLIMIT_MSGQUEUE 限制只会影响调用进程。这个用户下的其他进程不会受到影响，因为它们也会设置这个限制或继承这个限制。</li>
</ul>
</li>
<li>RLIMIT_NICE<ul>
<li>规定了使用 sched_setscheduler()和 nice()能够为进程设置的最大 nice 值。</li>
<li>这个最大值是通过公式 20 – rlim_cur 计算得来的，其中 rlim_cur 是当前的 RLIMIT_NICE 软资源限制</li>
</ul>
</li>
<li>RLIMIT_NOFILE<ul>
<li>一个进程能够分配的最大文件描述符数量加 1</li>
<li>试图（如 open()、pipe()、socket()、accept()、shm_open()、dup()、dup2()、fcntl(F_DUPFD)和 epoll_create()）分配的文件描述符数量超出这个限制时会失败。<ul>
<li>在大多数情况，失败的错误是 EMFILE</li>
<li>在 dup2(fd, newfd)调用中，失败的错误是 EBADF，</li>
<li>在 fcntl(fd, F_DUPFD, newfd)调用中当 newfd 大于或等于这个限制时，失败的错误是 EINVAL。</li>
</ul>
</li>
<li>更改此限制将影响到sysconf函数在参数_SC_OPEN_MAX中返回的值</li>
<li>在 Linux 上可以通过使用 readdir()扫描/proc/PID/fd 目录下的内容来检查一个进程当前打开的文件描述符，这个目录包含了进程当前打开的每个文件描述符的符号链接。</li>
<li>从 2.6.25 的版本开始，这个限制由 Linux 特有的/proc/sys/fs/nr_open 文件定义。这个文件中的默认值是 1048576，超级用户可以修改这个值。试图将软或硬 RLIMIT_NOFILE 限制设置为一个大于最大值的值会产生 EPERM 错误。</li>
<li>还存在一个系统级别的限制，它规定了系统中所有进程能够打开的文件数量，通过 Linux 特有的/proc/sys/fs/file-max 文件能够获取和修改这个限制。<ul>
<li>只有特权（CAP_SYS_ADMIN）进程才能够超出 file-max 的限制。</li>
<li>在非特权进程中，当系统调用碰到 file-max 限制时会返回 ENFILE 错误</li>
</ul>
</li>
</ul>
</li>
<li>RLIMIT_NPROC<ul>
<li>规定了调用进程的真实用户 ID 下最多能够创建的进程数量。</li>
<li>试图（fork()、vfork()和 clone()）超出这个限制会得到 EAGAIN 错误</li>
<li>RLIMIT_NPROC 限制只影响调用进程。这个用户下的其他进程不会受到影响，除非它们也设置或继承了这个限制。这个限制不适用于特权（CAP_SYS_ADMIN 和 CAP_SYS_RESOURCE）进程。</li>
<li>Linux 还提供了系统层面的限制来规定所有用户能够创建的进程数量。在 Linux 2.4以及之后的版本中，可以使用 Linux 特有的/proc/sys/kernel/threads-max 文件来获取和修改这个限制</li>
<li>准确地说，RLIMIT_NPROC 资源限制和 threads-max 文件实际上限制的是所能创建的线程数量，而不是进程的数量</li>
<li>更改此限制将影响到sysconf函数在参数_SC_CHILD_MAX中返回的值</li>
<li>不存在一种统一的方法能够在不同系统中找出某个特定用户 ID 已经创建的进程数。</li>
</ul>
</li>
<li>RLIMIT_RSS<ul>
<li>进程驻留集中的最大页面数，即当前位于物理内存中的虚拟内存页面总数。</li>
<li>Linux 提供了这个限制，但当前并没有起任何作用</li>
<li>如果可用的物理存储器非常少，则内核将从进程处取同超过RSS的部分</li>
</ul>
</li>
<li>RLIMIT_RTPRIO<ul>
<li>规定了使用 sched_ setscheduler()和 sched_setparam()能够为进程设置的最高实时优先级（自 Linux 2.6.12 起）</li>
</ul>
</li>
<li>RLIMIT_RTTIME<ul>
<li>规定了一个进程在实时调度策略中不睡眠（即执行一个阻塞系统调用）的情况下最大能消耗的 CPU 秒数（微秒；自 Linux 2.6.25 起）</li>
<li>如果进程达到了软限制，那么内核会向进程发送一个 SIGXCPU 信号，之后进程每消耗一秒的 CPU 时间都会收到一个SIGXCPU 信号。在达到硬限制时，内核会向进程发送一个 SIGKILL 信号。</li>
</ul>
</li>
<li>RLIMIT_SBSIZE<ul>
<li>在任一给定时刻，一个用户可以占用的套接字缓冲区的最大长度(字节)</li>
</ul>
</li>
<li>RLIMIT_SIGPENDING<br>- 一个进程可排队的信号最大数量制（Linux 特有的，自 Linux 2.6.8 起）<br>- 试图（sigqueue()）超出这个限制会得到 EAGAIN错误。<br>- RLIMIT_SIGPENDING 只影响调用进程。这个用户下的其他进程不会受到影响，除非它们也设置或继承了这个限制</li>
<li>RLIMIT_STACK<ul>
<li>栈段的大小（字节数）</li>
<li>试图扩展栈大小以至于超出这个限制会导致内核向该进程发送一个 SIGSEGV 信号。</li>
<li>由于栈空间已经被用光了，因此捕获这个信号的唯一方式是建立另外一个备用的信号栈，</li>
</ul>
</li>
<li>RLIMIT_VMEN<ul>
<li>这时RLIMIT_AS的同义词</li>
</ul>
</li>
</ul>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>​    为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程！以恢复以前挂起的某个进程的执行。这种行为被称为进程切换，任务切换或者是上下文切换。</p>
<h3 id="硬件上下文"><a href="#硬件上下文" class="headerlink" title="硬件上下文"></a>硬件上下文</h3><p>​    尽管每个进程都可以拥有自己的地址空间，但所有的进程必须共享CPU的寄存器！因此在恢复一个进程的执行以前内核必须确保每个寄存器装入了挂起进程时的值。进程恢复至执行前必须装入寄存器的一组数据被称为硬件上下文</p>
<p>​    硬件上下文是进程可执行上下文的一个子集，因为可执行上下文包含进程执行时需要的所有信息。Linux 2.6使用软件执行线程切换：通过一组move指令逐步执行切换，这样能较好地控制所装入数据的合法性。尤其是这时检查ds和es段寄存器的值成为可能</p>
<p>​    任务状态段TSS用来存放硬件上下文，尽管Linux并不使用硬件上下文切换，但它强制为每个系统中每个不同的CPU创建一个TSS。这么做的理由有：当8086的一个CPU从用户态切换到内核态时它就从TSS中获取内核态堆栈的地址，当用户态进程试图通过IN或OUT指令访问一个io端口时，CPU需要访问存放在TSS中的io许可全位图，以检查该进程是否有访问端口的能力！</p>
<p>​    执行进程切换进程切换只能发生在精心定义的点：schedule函数。这里我们仅关心内核如何执行一个进程切换//从本质上来说每个进程切换有两步组成：</p>
<p>切换页全局目录已安装一个新的地址空间。</p>
<p>切换内核态堆栈和硬件上下文</p>
<p>​    因为硬件上下文提供了内核执行新进程所需要的所有信息，包括CPU的寄存器！</p>
<h3 id="switch-to宏"><a href="#switch-to宏" class="headerlink" title="switch_to宏"></a>switch_to宏</h3><p>​    进程切换的第二步由switch_to宏执行。它是内核中与硬件关系最密切的历程之一。首先该宏有三个参数它们是prev，next和last。在任何进程切换中涉及到三个进程而不是两个。因为假设内核正决定战役进程A而激活B，在schedule函数中Prev指向a的描述符而next指向B的描述符。一旦是a暂停，a的执行流就被冻结了。随后当内核再次想激活a时，又必须暂停另一个进程C！这通常不同于B（你想想B可能也被切换走了）于是就要用prev指向C，而next选项a来执行另一个switch to宏。当a恢复它的执行流时就会找到他原来的内核栈。于是prev局部变量还是指向a的描述符。next指向B的描述符。此时代表a的执行的内核就失去了对C的任何作用，但是事实表明这个引用对于完成进程切换还是很有用！</p>
<p>​    switch_to宏最后一个参数表示输出参数，它表示宏把进程C的描述地址写在了什么位置</p>
<p>​    下面来简述简述汇编语言是如何实现进程切换的：</p>
<ul>
<li>在EAX和EDX寄存器中分别保存prev和next的值</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">movl prev, %eax
movl next, %edx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>把eflags和ebp寄存器的内容保存在prev内核栈中，必须保存他们的原因是编译器认为在switch to结束之前他们的值是保持不变的！</p>
<pre class="line-numbers language-none"><code class="language-none">pushfl
pushl %ebp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​    把ESP的内容保存到prev指向的thread.esp中，使该字段指向prev内核栈的栈顶</p>
<pre class="line-numbers language-none"><code class="language-none">movl %esp, 484(%eax)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    把next指向thread.esp装入ESP，此时内核开始在next的内核栈上操作！因此这条指令实际上完成了从prev项next的切换</p>
<pre class="line-numbers language-none"><code class="language-none">mov 484(%edx), %esp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    把标记为一的地址存入prev-&gt;thread.eip。当被替换的进程重新执行时，进程执行被标记为一的那条指令。</p>
<pre class="line-numbers language-none"><code class="language-none">movl $1f, 480(%eax)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    宏把next thread.eip的值压入next的内核栈：</p>
<pre class="line-numbers language-none"><code class="language-none">pushl 480(%edx)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    跳到<code>__switch_to()</code>C函数，(这里就是主要完成硬件上下文切换,更新TSS，我们不讲)</p>
<pre class="line-numbers language-none"><code class="language-none">jmp __switch_to<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    这里被进程B替换的进程A再次获得CPU。它执行一些保存eflags和ebp寄存器内容的指令，这里两条指令的第一条被标记为1</p>
<pre class="line-numbers language-none"><code class="language-none">1: 
	popl %ebp
	popfl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​    注意这些pop指令是如何引用prev进程的内核栈的！当进程调度程序选择prev作为进程，在CPU上运行时将执行这些指令！</p>
<p>​    拷贝寄存器的内容到switch_to宏的第三个参数last标识的内存区域中：</p>
<pre class="line-numbers language-none"><code class="language-none">movl %eax, last<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>Unix操作系统仅仅依赖进程创建来满足用户的需求现代Unix内核引入了三种不同的机制来加快进程创建和减轻进程创建的开销写时复制技术允许父子进程读取相同的物理也只有两者中的有一个试图写一个物理页内核就把这个页拷贝到一个新的物理页并且把新的物理页分配给正在写的进程轻量级进程允许父子之间共享每进程之间的内河的很多数据结构比如说列表打开文件表和信号处理微fork系统调用创建的进程能共享其父进程的内存地址空间为了防止父进程重写子进程需要的数据需要阻塞父进程的执行一直到子进程退出或执行一个新的程序为止但是这个调用基本上不被提倡</p>
<p>​    在Linux在中，我们使用clone来创建轻量级的进程，这是一些常见的标志</p>
<pre class="line-numbers language-none"><code class="language-none">CLONE_NEWNS：使新进程拥有一个新的、独立的挂载命名空间，可以隔离文件系统。
CLONE_NEWUTS：使新进程拥有一个新的、独立的 UTS 命名空间，可以隔离主机名和域名。
CLONE_NEWIPC：使新进程拥有一个新的、独立的 IPC 命名空间，可以隔离 System V IPC 和 POSIX 消息队列。
CLONE_NEWNET：使新进程拥有一个新的、独立的网络命名空间，可以隔离网络设备、协议栈和端口。
CLONE_NEWPID：使新进程拥有一个新的、独立的 PID 命名空间，可以隔离进程 ID。
CLONE_NEWUSER：使新进程拥有一个新的、独立的用户命名空间，可以隔离用户和组 ID。
CLONE_FILES：使新进程共享打开的文件描述符表，但不共享文件描述符的状态（例如文件偏移量）。
CLONE_FS：使新进程共享文件系统信息（例如当前工作目录和根目录）。
CLONE_VM：使新进程共享虚拟内存空间，即在进程之间共享代码和数据段。
CLONE_SIGHAND：使新进程共享信号处理程序。
CLONE_THREAD：使新进程成为调用进程的线程，与父进程共享进程 ID 和资源，但拥有独立的栈。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="do-fork"><a href="#do-fork" class="headerlink" title="do_fork"></a>do_fork</h3><p>​    clone, fork, vfork底层：</p>
<p>​    它执行以下这些步骤</p>
<ul>
<li>通过查找pidmap_array位图，为子进程分配新的PID</li>
<li>检查父进程的ptrace字段（current-&gt;ptrace）：如果它的值不等于0，说明有另外一个进程正在跟踪父进程，因而，do_fork()检查debugger程序是否自己想跟踪子进程（独立于由父进程指定的CLONE_PTRACE标志的值）。在这种情况下，如果子进程不是内核线程（CLONE_UNTRACED标志被清0），那么do_fork()函数设置CLONE_PTRACE标志。</li>
<li>调用copy_process()复制进程描述符。如果所有必须的资源都是可用的，该函数返回刚创建的task_struct描述符的地址。这是创建过程的关键步骤，将在do_fork()之后描述它。</li>
<li>如果设置了CLONE_STOPPED标志，或者必须跟踪子进程，即在p-&gt;ptrace中设置了PT_PTRACED标志，那么子进程的状态被设置成TASK_STOPPED，并为子进程增加挂起的SIGSTOP信号。在另外一个进程(不妨假设是跟踪进程或是父进程)把子进程的状态恢复为TASK_RUNNING之前（通常是通过发送SIGCONT信号），子进程将一直保持TASK_STOPPED状态。</li>
<li>如果没有设置CLONE_STOPPED标志，则调用wake_up_new_task()函数以执行下述操作： </li>
</ul>
<p>​     a.调整父进程和子进程的调度参数</p>
<p>​     b.如果子进程将和父进程运行在同一个CPU上（当内核创建一个新进程时父进程有可能会被转移到另一个CPU上执行），而且父进程和子进程不能共享同一组页表（CLONE_VM标志被清0），那么，就把子进程插入父进程运行队列，插入时让子进程恰好在父进程前面，因此而迫使子进程先于父进程运行。如果子进程刷新其地址空间，并在创建之后执行新程序，那么这种简单的处理会产生较好的性能。而如果我们让父进程先运行，那么写时复制机制将会执行一系列不必要的页面复制。</p>
<p>​     c.否则，如果子进程与父进程运行在不同的CPU上，或者父进程和子进程共享同一组页表（CLONE_VM标志被置位），就把子进程插入父进程运行队列的队尾。</p>
<ul>
<li>如果CLONE_STOPPED标志被置位，则把子进程置为TASK_STOPPED状态。</li>
<li>如果父进程被跟踪，则把子进程的PID存入current的ptrace_message字段并调用ptrace_notify()。ptrace_notify()是当前进程停止运行，并向当前进程的父进程发送SIGCHLD信号。子进程的祖父进程是跟踪父进程的debugger进程。SIGCHLD信号通知debugger进程：current已经创建了一个子进程，可以通过查找current-&gt;ptrace_message字段获得子进程的PID。</li>
<li>如果设置了CLONE_VFORK标志，则把父进程插入等待队列，并挂起父进程直到子进程释放自己的内存地址空间（也就是说，直到子进程结束或执行新的程序）。</li>
<li>结束并返回子进程的PID。</li>
</ul>
<p>​    欸，来看看中间的<code>copy_process</code></p>
<ul>
<li>定义返回值亦是<code>retval</code>和新的进程描述符<code>task_struct</code>结构p。</li>
<li>标志合法性检查。对clone_flags所传递的标志组合进行合法性检查。当出现以下三种情况时，返回出错代号：</li>
<li><ul>
<li>CLONE_NEWNS和CLONE_FS同时被设置。前者标志表示子进程需要自己的命名空间，而后者标志则代表子进程共享父进程的根目录和当前工作目录，两者不可兼容。在传统的Unix系统中，整个系统只有一个已经安装的文件系统树。每个进程从系统的根文件系统开始，通过合法的路径可以访问任何文件。在2.6版本中的内核中，每个进程都可以拥有属于自己的已安装文件系统树，也被称为命名空间。通常大多数进程都共享init进程所使用的已安装文件系统树，只有在clone_flags中设置了CLONE_NEWNS标志时，才会为此新进程开辟一个新的命名空间。</li>
<li>CLONE_THREAD被设置，但CLONE_SIGHAND未被设置。如果子进程和父进程属于同一个线程组（CLONE_THREAD被设置），那么子进程必须共享父进程的信号（CLONE_SIGHAND被设置）。</li>
<li>CLONE_SIGHAND被设置，但CLONE_VM未被设置。如果子进程共享父进程的信号，那么必须同时共享父进程的内存描述符和所有的页表（CLONE_VM被设置）。</li>
</ul>
</li>
<li><p>安全性检查。通过调用security_task_create()和后面的security_task_alloc()执行所有附加的安全性检查。询问 Linux Security Module (LSM) 看当前任务是否可以创建一个新任务。LSM是SELinux的核心。<br>复制进程描述符。通过dup_task_struct()为子进程分配一个内核栈、thread_info结构和task_struct结构。注意，这里将当前进程描述符指针作为参数传递到此函数中。</p>
</li>
<li><p>首先，该函数分别定义了指向task_struct和thread_info结构体的指针。接着，prepare_to_copy为正式的分配进程描述符做一些准备工作。主要是将一些必要的寄存器的值保存到父进程的thread_info结构中。这些值会在稍后被复制到子进程的thread_info结构中。执行alloc_task_struct宏，该宏负责为子进程的进程描述符分配空间，将该片内存的首地址赋值给tsk，随后检查这片内存是否分配正确。执行alloc_thread_info宏，为子进程获取一块空闲的内存区，用来存放子进程的内核栈和thread_info结构，并将此会内存区的首地址赋值给ti变量，随后检查是否分配正确。</p>
</li>
<li>上面已经说明过orig是传进来的current宏，指向当前进程描述符的指针。arch_dup_task_struct直接将orig指向的当前进程描述符内容复制到当前里程描述符tsk。接着，用atomic_set将子进程描述符的使用计数器设置为2，表示该进程描述符正在被使用并且处于活动状态。最后返回指向刚刚创建的子进程描述符内存区的指针。</li>
<li>通过dup_task_struct可以看到，当这个函数成功操作之后，子进程和父进程的描述符中的内容是完全相同的。在稍后的copy_process代码中，我们将会看到子进程逐步与父进程区分开来。</li>
<li>一些初始化。通过诸如ftrace_graph_init_task，rt_mutex_init_task完成某些数据结构的初始化。调用copy_creds()复制证书（应该是复制权限及身份信息）。</li>
<li>检测系统中进程的总数量是否超过了max_threads所规定的进程最大数。</li>
<li>复制标志。通过copy_flags，将从do_fork()传递来的的clone_flags和pid分别赋值给子进程描述符中的对应字段。</li>
<li>初始化子进程描述符。初始化其中的各个字段，使得子进程和父进程逐渐区别出来。这部分工作包含初始化子进程中的children和sibling等队列头、初始化自旋锁和信号处理、初始化进程统计信息、初始化POSIX时钟、初始化调度相关的统计信息、初始化审计信息。它在copy_process函数中占据了相当长的一段的代码，不过考虑到task_struct结构本身的复杂性，也就不足为奇了。</li>
<li>调度器设置。调用sched_fork函数执行调度器相关的设置，为这个新进程分配CPU，使得子进程的进程状态为TASK_RUNNING。并禁止内核抢占。并且，为了不对其他进程的调度产生影响，此时子进程共享父进程的时间片。</li>
<li>复制进程的所有信息。根据clone_flags的具体取值来为子进程拷贝或共享父进程的某些数据结构。比如copy_semundo()、复制开放文件描述符（copy_files）、复制符号信息（copy_sighand 和 copy_signal）、复制进程内存（copy_mm）以及最终复制线程（copy_thread）。</li>
<li>复制线程。通过copy_threads()函数更新子进程的内核栈和寄存器中的值。在之前的dup_task_struct()中只是为子进程创建一个内核栈，至此才是真正的赋予它有意义的值。</li>
<li>当父进程发出clone系统调用时，内核会将那个时候CPU中寄存器的值保存在父进程的内核栈中。这里就是使用父进程内核栈中的值来更新子进程寄存器中的值。特别的，内核将子进程eax寄存器中的值强制赋值为0，这也就是为什么使用fork()时子进程返回值是0。而在do_fork函数中则返回的是子进程的pid，这一点在上述内容中我们已经有所分析。另外，子进程的对应的thread_info结构中的esp字段会被初始化为子进程内核栈的基址。</li>
<li>分配pid。用alloc_pid函数为这个新进程分配一个pid，Linux系统内的pid是循环使用的，采用位图方式来管理。简单的说，就是用每一位（bit）来标示该位所对应的pid是否被使用。分配完毕后，判断pid是否分配成功。成功则赋给p-&gt;pid。</li>
<li>更新属性和进程数量。根据clone_flags的值继续更新子进程的某些属性。将 nr_threads加一，表明新进程已经被加入到进程集合中。将total_forks加一，以记录被创建进程数量。</li>
<li>如果上述过程中某一步出现了错误，则通过goto语句跳到相应的错误代码处；如果成功执行完毕，则返回子进程的描述符p。</li>
</ul>
<h3 id="内核进程"><a href="#内核进程" class="headerlink" title="内核进程"></a>内核进程</h3><pre><code> 所有进程的祖先是0进程，他在初始化阶段从无到有的创建一个进程。进程1是init进程！
</code></pre><h2 id="撤销有一个进程"><a href="#撤销有一个进程" class="headerlink" title="撤销有一个进程"></a>撤销有一个进程</h2><p>​    进程的终止有两个：exitt_group来终结一个进程组，exit系统调用终结摸一个线程</p>
<h3 id="do-group-exit"><a href="#do-group-exit" class="headerlink" title="do_group_exit"></a>do_group_exit</h3><p>​    这个函数用来杀死属于current进程组的所有进程！它接收进程终止代号作为参数</p>
<ul>
<li>首先它检查退出进程的signal_group_exit标志是否不为零，如果不为零，说明内核已经开始为进程组执行退出的过程！在这种情况下就把存放在<code>current-&gt;signal-&gt;group-&gt;exit_code</code>中的值当做退出码，然后跳到第四步</li>
<li>否则设置进程的signal group exit标志并把中指戴好存放在<code>current-&gt;signal-&gt;group-&gt;exit_code</code>字段调用</li>
<li>zap_other_threads函数杀死杀死current进程组的其他进程</li>
<li>调用do_exit函数，把进程的终止代号传递给他 </li>
</ul>
<h3 id="do-exit函数"><a href="#do-exit函数" class="headerlink" title="do_exit函数"></a>do_exit函数</h3><p>​    做这些事情：</p>
<ol>
<li>把进程描述符的flag字段设置为PF＿EXITING标志，以表示进程正在被删除。</li>
<li>如果需要，通过函数del_timer_sync()从动态定时器队列中删除进程描述符。</li>
<li>分别调用exit_mm()、exit_sem()、__exit_files()、__exit_fs()、exit_namespace()和exit_thread()函数从进程描述符中分离出与分页、信号量、文件系统、打开文件描述符、命名空间以及I/O权限位图相关的数据结构。如果没有其它进程共享这些数据结构，那么这些函数还删除所有这些数据结构中。</li>
<li>如果实现了被杀死进程的执行域和可执行格式的内核函数包含在内核模块中，则函数递减它们的使用计数器。</li>
<li>把进程描述符的exit_code字段设置成进程的终止代号，这个值要么是_exit()或exit_group()系统调用参数，要么是由内核提供的一个错误代码。</li>
<li><p>调用exit_notify()函数执行下面的操作：</p>
<ul>
<li>更新父进程和子进程的亲属关系。如果同一线程组中有正在运行的进程，就让终止进程所创建的所有子进程都变成同一线程组中另外一个进程的子进程，否则让它们成为init的子进程</li>
<li>检查被终止进程其进程描述符的exit_signal字段是否不等于－1，并检查进程是否是其所属进程组的最后一个成员。在这种情况下，函数通过给正被终止进程的父进程发送一个信号，以通知父进程子进程死亡。</li>
<li>否则，也就是exit_signal字段等于-1，或者线程组中还有其它进程，那么只要进程正在被跟踪，就向父进程发送一个SIGCHLD信号。</li>
<li>如果进程描述符的exit_signal字段等于-1，而且进程没有被跟踪，就把进程描述符的exit_state字段置为EXIT＿DEAD，然后调用release_task()回收进程的其它数据结构占用的内存，并递减进程描述符的使用计数器，以使进程描述符本身正好不会被释放。</li>
<li>否则，如果进程描述符的exit_signal字段不等于-1，或<strong>进程正在被跟踪，就把exit_state字段置为EXIT_ZOMBIE</strong>。</li>
<li>把进程描述符的flags字段设置为PF_DEAD标志。</li>
</ul>
</li>
<li><p>调用schedule()函数选择一个新进程运行。调度程序忽略处于EXIT_ZOMBIE状态的进程，所以这种进程正好在schedule()中的宏switch_to被调用之后停止执行。</p>
</li>
</ol>
<h1 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhizhengguan/article/details/112215744#:~:text=进程资源限制 1 如在执行任意一个程序之前如果不想让它消耗太多资源系统，则可以设置该进程的资源限制。 2 使用 shell的内置命令 ulimit,可以设置 shell 的资源限制（在 C shell 中是 limit）。 shell创建用来执行用户命令的进程会继承这些限制">Unix/Linux编程：进程资源限制_如何限制一个进程能够使用的线程等资源-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoudaxia/article/details/7367044">Linux进程管理(2)：进程创建的copy_process和进程销毁_copy process-CSDN博客</a></p>
</blockquote>
<h1 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h1><p>​    中断通常被定义为一个事件：让事件改变处理器执行的指令顺序这样的事件，与CPU芯片内外部硬件电路产生的电信号相对应！</p>
<p>​    中断通常分为同步中断与异步中断：</p>
<p>​    同步中断指的是当指令执行时，由CPU控制单元产生的。之所以称为同步，是因为只有在一条指令终止执行后，CPU才会发出中断！</p>
<p>​    异步中断是由其他硬件设备依照CPU时钟信号随机产生的</p>
<p>​    在英特尔微处理器手册中：也会把同步和异步中断分别称为异常和中断</p>
<p>​    中断则是由间隔定时器或者io设备产生的，举个例子你敲击键盘的时候，你的一次按键就会引发一个中断，希望操作系统介入进行处理！</p>
<p>​    另一方面异常是由程序的错误产生的，或者是由内核必须处理的异常条件产生的！比如说内核通过发送一个信号来处理异常，或者内核执行恢复异常所需要的步骤，比如说缺页，比如说对内核服务的一个请求</p>
<h2 id="中断信号的作用"><a href="#中断信号的作用" class="headerlink" title="中断信号的作用"></a>中断信号的作用</h2><p>​    顾名思义，中断信号提供了一种特殊的方式来让处理器转而去运行正常控制流之外的代码。当一个中断信号到达的时候CPU必须停止它当前所做的事情，转而切换去处理这些终端。为了做到这一点就需要把内核态堆栈保存PC当前的值，并且把中断相关类型的的一个地址放进程序计数器中。这样才会跳转去执行处理中断的代码。</p>
<p>​    中断处理器内核执行的最敏感的任务之一，因为它必须要满足：</p>
<ol>
<li>让内核正打算去完成别的事情的，由于中断随时都会到来，因此内核的目标就是：让中断尽可能的处理完尽可能把更多的更详细的处理向后推，所以中断响应分为两个部分：</li>
</ol>
<ul>
<li>关键而紧急的部分这一部分，内核立即执行。</li>
<li>其推迟的部分，则是内核随后执行。</li>
</ul>
<ol>
<li>因为中断随时会到来，所以内核可能正在处理其中一个中断的时候，另一个中断又发生了。应该尽可能地允许这种情况发生，因为这将会保持更多的io设备处于忙状态。因此中断处理程序必须编写成可以使相应的内核控制路径以嵌套的方式进行，执行到最后一个内核控制路径终止时，内核可以恢复被中断进程的执行，或者如果中断信号已导致了重新调度，内核可以切换到另外的进程。</li>
<li>尽管内核在处理前一个中断的时候，可以接受新的中断，但在内核代码区中仍然存在着一些临界区，在这些临界区中中断必须被禁止</li>
</ol>
<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>​    英特尔文档把中断和异常又分为了以下几类：</p>
<ol>
<li>中断：</li>
</ol>
<p>​    又分出两类即：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>可屏蔽中断</td>
<td>IO设备发出的所有中断请求（Interruppt Request）都产生可屏蔽的中断，它处于两状态：屏蔽的和非屏蔽的，如果一个中断是被屏蔽的，那么控制单元会被它会忽略它</td>
</tr>
<tr>
<td>非可屏蔽中断</td>
<td>只有少数的几个危机事件是这样的，非屏蔽的中断总是由CPU辨认</td>
</tr>
</tbody>
</table>
</div>
<p>异常：</p>
<p>异常分两类，处理器探测异常和编程异常。</p>
<p>处理器探测异常有三种</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>故障</td>
<td>通常可以被纠正，一旦纠正，程序就可以在不失连贯性的情况下，重新开始！保存在EIP中的值就是引起故障的指令地址，因此当异常处理程序终止时，那条指令会被重新执行</td>
</tr>
<tr>
<td>陷阱</td>
<td>在陷阱执行后，立即报告内核把控制权返回给程序后，就可以继续它的执行而不失去连贯性。保存在EIP中的值是一个随后要执行的指令地址，只有当没有必要重新执行已中止的指令时，才会触发陷阱。陷阱的主要目的是为了调试程序</td>
</tr>
<tr>
<td>异常终止</td>
<td>异常终止指的是发生了一个严重的错误及控制单元出现了问题，不能在EIP寄存器中保存引发了这个异常指令所在的确切位置。异常终止用的报告严重的错误，如硬件故障或系统表中无效的值或不一样的值。</td>
</tr>
</tbody>
</table>
</div>
<p>编程异常：在编程者发出请求时发生是由int或int3指令触发的当into（检查溢出）和bound（检查地址出界）指令检查的条件不为真时，会引发编程异常控制单元！编程异常当作陷阱来处理，编程异常也被称为软中断，这样的异常常有两种的用途执行：系统调用以及给调试程序通报一个特定的事件。</p>
<h3 id="IRQ与中断"><a href="#IRQ与中断" class="headerlink" title="IRQ与中断"></a>IRQ与中断</h3><p>​    每个能够发出中断请求的硬件设备系都有一条名为IRQ的输出线，所有现有的IRQ线都与一个名为可编程中断控制器的硬件电路的输入引脚相连，可编程中断控制器执行下列动作：</p>
<ul>
<li>监视IRQ线检查产生的信号，如果有两条或两条以上的IRQ线上产生信号，选择引脚编号较小的IRQ线</li>
<li>如果一个引发信号出现在线上，那么它会把接收到的信发信号转换成对应的向量，把这个向量存放在中断控制器的一个io端口，从而允许CPU通过数据总线读取此向量。把引发信号发送到处理器的INTR引脚，也就是产生了一个中断</li>
<li>等待直到CPU通过把这个中断信号写进可编程中断控制器的io端口号，来确认它，当这种情况发生时，清理INTR线。然后继续监视。</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>​    这里给出一些常见的异常：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>异   常   一   览   表</th>
<th>向量号</th>
<th>异常名称</th>
<th>异常类型</th>
<th>出错代码</th>
<th>相关指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>除法出错</td>
<td>故障</td>
<td>无</td>
<td>DIV,IDIV</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>调试异常</td>
<td>故障/陷阱</td>
<td>无</td>
<td>任何指令</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>单字节INT3</td>
<td>陷阱</td>
<td>无</td>
<td>INT 3</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>溢出</td>
<td>陷阱</td>
<td>无</td>
<td>INTO</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>边界检查</td>
<td>故障</td>
<td>无</td>
<td>BOUNT</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>非法操作码</td>
<td>故障</td>
<td>无</td>
<td>非法指令编码或操作数</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>设备不可用</td>
<td>故障</td>
<td>无</td>
<td>浮点指令或WAIT</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>双重故障</td>
<td>中止</td>
<td>有</td>
<td>任何指令</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>协处理器段越界</td>
<td>中止</td>
<td>无</td>
<td>访问存储器的浮点指令</td>
<td></td>
</tr>
<tr>
<td>0AH</td>
<td>无效TSS异常</td>
<td>故障</td>
<td>有</td>
<td>JMP、CALL、IRET或中断</td>
<td></td>
</tr>
<tr>
<td>0BH</td>
<td>段不存在</td>
<td>故障</td>
<td>有</td>
<td>装载段寄存器的指令</td>
<td></td>
</tr>
<tr>
<td>0CH</td>
<td>堆栈段异常</td>
<td>故障</td>
<td>有</td>
<td>装载SS寄存器的任何指令、对SS寻址的段访问的任何指令</td>
<td></td>
</tr>
<tr>
<td>0DH</td>
<td>通用保护异常</td>
<td>故障</td>
<td>有</td>
<td>任何特权指令、任何访问存储器的指令</td>
<td></td>
</tr>
<tr>
<td>0EH</td>
<td>页异常</td>
<td>故障</td>
<td>有</td>
<td>任何访问存储器的指令</td>
<td></td>
</tr>
<tr>
<td>10H</td>
<td>协处理器出错</td>
<td>故障</td>
<td>无</td>
<td>浮点指令或WAIT</td>
<td></td>
</tr>
<tr>
<td>11H—0FFH</td>
<td>软中断</td>
<td>陷阱</td>
<td>无</td>
<td>INT n</td>
</tr>
</tbody>
</table>
</div>
<h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>​    中断描述符表IDT是一个系统表，它与每一个中断或者异常向量相联系</p>
<p>​    每一个向量在表中都有相应的中断或异常处理程序的入口地址，内核在允许中断发生前，必须适当初始化IDT</p>
<p>​    下图为IDT的结构表示图：</p>
<p><img src=".\v2-50034e68241345db7c96b90647155494_1440w.webp" alt="img"></p>
<p>这些描述符是:</p>
<ul>
<li>任务门<code>Task Gate</code>：当中断信号发生时，必须取代当前进程的那个进程的TSS选择符，存放在任务门中</li>
<li>中断门<code>Interrupt Gate</code>：包含段选择符和中断或异常处理程序的段内偏移量，当控制权转移到应适当的段时，处理器清IF标志，从而关闭即将会发生的可屏蔽中断。</li>
<li>陷阱门<code>Trap Gate</code>：与中断门相似只是控制权传递到一个适当的段时处理器不修改IF标志Linux使用中断门处理中断应用陷阱门处理异常 </li>
</ul>
<h3 id="硬件处理"><a href="#硬件处理" class="headerlink" title="硬件处理"></a>硬件处理</h3><p>​    现在描述CPU控制单元是如何处理中断和异常的！</p>
<p>​    我们现在假定内核已经被初始化，因此CPU将会在保护模式下运行。</p>
<p>​    当执行了一条指令后，CS和EIP这对寄存器将会包含下一条将要执行的指令的逻辑地址。在处理那条指令之前控制单元会检查在运行前一条指令是否已经发生一个中断或者异常，如果发生了，那么它将会：</p>
<ol>
<li><p>确定与中断或异常关联的向量（看一眼是哪个异常）</p>
</li>
<li><p>读由寄存器指向的<code>IDT</code>表中的<code>i</code>项（肘！IDT表爆破）</p>
</li>
<li><p>从<code>gdpr</code>寄存器中获取GDP的基地址，并在GDP中查找，以读取IDT表项的选择符所标识的段描述符。这个描述符指定中断或异常处理程序所在段的基地址（看看这个程序在哪里）</p>
</li>
<li><p>确信中断事由授权的中断发生源发出的，首先将当前特权级CPL与段描述符的描述符特权级DPL的相比较：如果CPL小于DPL了就会产生一个<code>general protection</code>异常，因为中断处理程序的特权不能低于引起中断的程序的特权！对于编程异常则需要做进一步的安全检查：比较CPL了与处于IDT中的门描述符的DPL了，如果DPL小于CPL了那么就产生一个<code>general protection</code>，这最后一个检查可以避免用户应用程序访问特殊的陷阱门和中断门（配不配处理这个异常）</p>
</li>
<li><p>检查是否发生了特权级变化：也就是说CPL是否不同于所选择的段描述符的DPL，如果是，控制单元必须开始使用与新的特权级相关的栈，通过执行以下步骤来做到这一点：</p>
<blockquote>
<ol>
<li>读TR寄存器以访问运行进程的TSS段</li>
<li>用于新特权级相关的栈段和栈指针的正确值装载SS和ESP寄存器这些值，可以在TSS中找到在新的段中</li>
<li>保存SS和ESP以前的值，这些值定义了与旧特训级相关的栈的逻辑地址。</li>
</ol>
</blockquote>
</li>
<li><p>如果故障已经发生，用引起异常的指令地址装载CS和EIP寄存器，从而使得这条指令能够再次被执行！</p>
</li>
<li><p>在栈中保存eflags,cs,EIP等内容，如果引用异常产生了一个硬件出错码，把它保存到栈中，装在CS和EIP寄存器其值分别为IDT表中第I项门描述服务的段选择符和偏移量字段，这些值给出了中断或者异常处理的第一条指令的逻辑地址！</p>
</li>
</ol>
<p>​    控制单元所执行的最后一步就是跳转到这些异常处理程序，换句话说处理完中断信号后控制单元所执行的指令，就是被选中处理程序的第一条指令！</p>
<p>​    当中断或处理结束后和异常被处理结束后相应的处理程序必须参与生一条iret指令，他把控制权转交给被中断的进程。这将会迫使控制单元：</p>
<ol>
<li>用保存在栈中的值装在CS或eflags寄存器，如果一个硬件出错码曾经被压入栈中，并且在EIP内容的上面，那么执行Iret指令前必须弹出这个硬件错误码（准备回家）</li>
<li>检查处理程序的CPL是否等于CS中的最低两位的值如果是iret终止执行，否则执行下一步。（看看特权级够不够）</li>
<li>从栈中装载SS和ESP寄存器因此返回到与特权级相关的栈（也就是恢复栈）</li>
<li>检查DS ES FS 以及 GS段寄存器的内容，如果其中一个寄存器包含选择符是一个段描述符，并且其的DPL值小于CPL了，那么我们会清理相应的段寄存器控制单元，这么做是为了防止用户态的程序利用内核以前所用的段寄存器，如果不清理这些寄存器，那么一些怀有恶意的用户态程序就有可能利用他们来访问内核地址。（安全处理，安全恢复环境）</li>
</ol>
<h3 id="中断和异常处理程序的嵌套执行"><a href="#中断和异常处理程序的嵌套执行" class="headerlink" title="中断和异常处理程序的嵌套执行"></a>中断和异常处理程序的嵌套执行</h3><p>​    每个中断或异常都会引起一个内核控制路径，或者说当前的进程在内核态执行单独的指令序列。</p>
<p>​    内核控制路径可以任意嵌套！一个中断处理程序可以被另一个中断处理程序所中断，因此这样就引起了内核控制路径的嵌套执行。允许内核控制路径嵌套执行必须要付出相应的代价，也就是中断处理程序必须永不阻塞换，中断处理程序在运行期间是不能够发生进程切换。</p>
<p>​    基于以下两个主要原因，Linux交错执行内核控制路径：</p>
<ol>
<li>为了提高可编程中断控制器和设备控制中器的吞吐量。假定设备控制器在一条线上产生了一条信号，pic把这个信号转换成一个外部中断，然后pic和控制设备器保持阻塞一直到pic从内核CPU处接收一条应答信息！由于内核控制路径的交错执行内核即使正在处理前一个中断也能够发送应答。</li>
<li>为了实现一种没有优先级的中断模型，每个C中断处理程序都可以被另一个中断处理程序所延缓，因此在硬件设备之间没必要预定义优先级，这简化了内核代码，也提高了内核的可移植性！</li>
</ol>
<h2 id="初始化IDT"><a href="#初始化IDT" class="headerlink" title="初始化IDT"></a>初始化IDT</h2><p>​    Linux在基于Intel给出的三种门之外，还更加细分了他们：</p>
<blockquote>
<p><strong>中断门(interrupt gate)</strong>：用户态的进程不能访问的一个lntel中断门(门的DPL字段为0)。所有的Linux中 断处理程序都通过中断门激活，并全部限制在内核态。</p>
<p><strong>系统门(syslem gate)</strong>：用户态的进程可以访问的一个Intel陷阱门(门的DPL字段为到.通过系统门来激 活三个Linux异常处理程序，它们的向量是4，5及128，因此，在用户态下.可以 发布into、 bound及int $Ox80三条汇编语言指令。</p>
<p><strong>系统中断门(system interrupt gate)</strong>：能够被用户态进程访问的Intel中断门(门的DPL字段为3). 与向量3相关的异常 处理程序是由系统中断门激活的，因此，在用户态可以使用汇编语言指令int3.</p>
<p><strong>陷阱门(Irapgate)</strong>：用户态的进程不能访问的一个Inte)陷阱门(f]的DPL字段为0). 大部分Linux异 常处理程序都通过陷阱门来激活.</p>
<p><strong>任务门(task gate)</strong>：不能被用户态进程访问的Intel任务门(门的DPL字段为0).Linux对”Doublefault” 异常的处理程序是由任务门激活的.</p>
</blockquote>
<p>​    IDT会被初始化两次。第一次是在BIOS程序中，此时CPU还工作在实模式下。一旦Linux启动，IDT会被搬运到RAM的受保护区域并被第二次初始化，因为Linux不会使用任何BIOS程序。</p>
<p>IDT结构被存储在idt_table表中，包含256项。idt_descr变量存储IDT的大小和它的地址，在系统的初始化阶段，内核用来设置idtr寄存器，专用汇编指令是lidt。</p>
<p>内核初始化的时候，汇编函数setup_idt()用相同的中断门填充idt_table表的所有项，都指向ignore_int()中断处理函数：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">setup_idt:
    lea ignore_int, %edx
    movl $(__KERNEL_CS &lt;&lt; 16), %eax
    movw %dx, %ax           &#x2F;*  &#x3D; 0x0010 &#x3D; cs *&#x2F;
    movw $0x8e00, %dx       &#x2F;* 中断门，DPL&#x3D;0 *&#x2F;
    lea idt_table, %edi     &#x2F;* 加载idt表的地址到寄存器edi中 *&#x2F;
    mov $256, %ecx
rp_sidt:
    movl %eax, (%edi)       &#x2F;* 设置中断处理函数 *&#x2F;
    movl %edx, 4(%edi)      &#x2F;* 设置段描述符 *&#x2F;
    addl $8, %edi           &#x2F;* 跳转到IDT表的下一项 *&#x2F;
    dec %ecx                &#x2F;* 自减 *&#x2F;
    jne rp_sidt
    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>中断处理函数<code>ignore_int()</code>，也是一个汇编语言编写的函数，相当于一个null函数，它执行：</p>
<ol>
<li>保存一些寄存器到堆栈中。</li>
<li>调用printk()函数打印<code>Unknown interrupt</code>系统消息`。</li>
<li>从堆栈中恢复寄存器的内容。</li>
<li>执行iret指令回到调用处。</li>
</ol>
<p>​    正常情况下，此时的中断处理函数ignore_int()是不应该被执行的。如果在console或者log日志中出现<code>Unknown interrupt</code>的消息，说明发生硬件错误或者内核错误。</p>
<p>​    完成这次IDT表的初始化之后，内核还会进行第二次初始化，用真正的trap或中断处理函数代替刚才的null函数。一旦这两步初始化都完成，IDT表就包含具体的中断、陷阱和系统门，用以控制每个中断请求。</p>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>​     这里讨论三种中断类型：</p>
<p>​    IO中断，时钟中断。和处理器间中断io</p>
<p>​    中断处理程序必须足够灵活地给多个设备同时提供服务，比如说在PCI总线的体系架构中几个设备可以共享一个IRQ线，这也就意味着仅仅中断向量是并不能说明所有问题的！中断处理程序的灵活性是以两种不同的方式实现的：</p>
<p>IRQ共享</p>
<p>中断处理程序执行多个中断服务例程，每个中断服务例程是一个与单独设备相关的函数，因此不可能预先知道哪个特定的设备产生，因此每个IRQ，也就是中断服务例程，都会被执行验证它的设备是否需要关注，如果是，当设备产生中断时则需要执行相关的所有操作</p>
<p>IRQ动态分配</p>
<p>一条线可能在最后的时刻才会与一个设备驱动程序相关联，这样，即使几个硬件设备并不共享线，同一个向量也可以在这几个设备在不同时刻中使用。当一个中断发生时，并不是所有的操作都具有急迫性，，因此Linux会把紧随中断要执行的操作分为三类：</p>
<blockquote>
<p>紧急的：这样的操作比如说对pic应答中断，对pic或设备控制器中编程重修改，由设备和处理器同时访问的数据结构这样的操作都可以很快的被执行，他们是紧急的，因为他们必须要尽快的执行紧急操作！要在一个中断处理程序内立即执行，而且是在禁止可屏蔽中断的情况下</p>
<p>非紧急的：这样的操作比如说修改那些只有处理器才会访问的数据结构，这样的操作必须也很快完成，因此它们由中断处理程序立即执行，但它们是在开中断的情况下执行的</p>
<p>非紧急可延迟的：比如说把缓冲区的内容拷贝到进程的地址空间中，这样的操作可能被延迟较长的时间间隔，而不会影响内核的操作！</p>
</blockquote>
<p>​    不管引起中断的电路类型如何所有的io中断处理程序都执行四个基本的操作：</p>
<ol>
<li>在内核态堆栈中保存的值与寄存器的内容</li>
<li>为正在给线服务的pic发送个应答，这将允许pic进一步发出中断</li>
<li>执行共享这个IRQ的所有设备都中断服务例程</li>
<li>跳到ret_from_intr的地址后终止</li>
</ol>
<p>​    为一个IRQ可配置设备选择一条线，有三种方式：</p>
<ul>
<li>设置一些硬件跳线跳接器</li>
<li>安装设备时执行一个实用程序，这样的程序可以让用户选择一个可用的RQ号或者探测系统自身以确定一个可用的IRQ号</li>
<li>在系统启动时执行一个硬件协议，外设宣布他们准备使用哪些中断线，然后协商一个最终的值以尽可能减少冲突，该过程一旦完成，每个中断处理程序都会通过访问设备的某个IO端口函数来读取所分配的IRQ</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>对于每一个外设的IRQ都用 struct irq_desc 来描述，我们称之中断描述符（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=struct&amp;spm=1001.2101.3001.7020">struct</a> irq_desc）。linux kernel中会有一个数据结构保存了关于所有IRQ的中断描述符信息，我们称之中断描述符DB（上图中红色框图内）。当发生中断后，首先获取触发中断的HW interupt ID，然后通过irq domain翻译成IRQ number，然后通过IRQ number就可以获取对应的中断描述符</p>
<h4 id="中断描述符"><a href="#中断描述符" class="headerlink" title="中断描述符"></a>中断描述符</h4><p>通用中断处理模块可以用一个线性的table来管理一个个的外部中断，这个表的每个元素就是一个irq描述符，在kernel中定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> irq_desc<span class="token punctuation">[</span>NR_IRQS<span class="token punctuation">]</span> __cacheline_aligned_in_smp <span class="token operator">=</span> <span class="token punctuation">&#123;</span> 
    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> NR_IRQS<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> 
        <span class="token punctuation">.</span>handle_irq    <span class="token operator">=</span> handle_bad_irq<span class="token punctuation">,</span> 
        <span class="token punctuation">.</span>depth        <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> 
        <span class="token punctuation">.</span>lock        <span class="token operator">=</span> <span class="token function">__RAW_SPIN_LOCK_UNLOCKED</span><span class="token punctuation">(</span>irq_desc<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">,</span> 
    <span class="token punctuation">&#125;</span> 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    系统中每一个连接外设的中断线（irq request line）用一个中断描述符来描述，每一个外设的 interrupt request line 分配一个中断号（irq number），系统中有多少个中断线（或者叫做中断源）就有多少个中断描述符（struct irq_desc）。NR_IRQS定义了该硬件平台IRQ的最大数目。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token punctuation">&#123;</span> 
    <span class="token keyword">struct</span> <span class="token class-name">irq_data</span>        irq_data<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __percpu    <span class="token operator">*</span>kstat_irqs<span class="token punctuation">;</span>－－－－－－IRQ的统计信息 
    <span class="token class-name">irq_flow_handler_t</span>    handle_irq<span class="token punctuation">;</span>－－－－－－－－流控函数 
    <span class="token keyword">struct</span> <span class="token class-name">irqaction</span>    <span class="token operator">*</span>action<span class="token punctuation">;</span> －－－－－－－－－－－处理函数
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        status_use_accessors<span class="token punctuation">;</span>－－－－－中断描述符的状态，参考IRQ_xxxx 
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        core_internal_state__do_not_mess_with_it<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        depth<span class="token punctuation">;</span>－－－－－－－－－－描述嵌套深度的信息
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        wake_depth<span class="token punctuation">;</span>－－－－－－－－电源管理中的wake up source相关
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        irq_count<span class="token punctuation">;</span> 
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>        last_unhandled<span class="token punctuation">;</span>   
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        irqs_unhandled<span class="token punctuation">;</span> 
    <span class="token class-name">raw_spinlock_t</span>        lock<span class="token punctuation">;</span> 
    <span class="token keyword">struct</span> <span class="token class-name">cpumask</span>        <span class="token operator">*</span>percpu_enabled<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SMP </span></span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cpumask</span>    <span class="token operator">*</span>affinity_hint<span class="token punctuation">;</span>－－－－和irq affinity相关，后续单独文档描述 
    <span class="token keyword">struct</span> <span class="token class-name">irq_affinity_notify</span> <span class="token operator">*</span>affinity_notify<span class="token punctuation">;</span> 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_GENERIC_PENDING_IRQ </span></span>
    <span class="token class-name">cpumask_var_t</span>        pending_mask<span class="token punctuation">;</span> 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>        threads_oneshot<span class="token punctuation">;</span> 
    <span class="token class-name">atomic_t</span>        threads_active<span class="token punctuation">;</span> 
    <span class="token class-name">wait_queue_head_t</span>       wait_for_threads<span class="token punctuation">;</span> 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_PROC_FS </span></span>
    <span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span>    <span class="token operator">*</span>dir<span class="token punctuation">;</span>－－－－－－－－该IRQ对应的proc接口 
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span>
    <span class="token keyword">int</span>            parent_irq<span class="token punctuation">;</span> 
    <span class="token keyword">struct</span> <span class="token class-name">module</span>        <span class="token operator">*</span>owner<span class="token punctuation">;</span> 
    <span class="token keyword">const</span> <span class="token keyword">char</span>        <span class="token operator">*</span>name<span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span> ____cacheline_internodealigned_in_smp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="响应函数-irqaction"><a href="#响应函数-irqaction" class="headerlink" title="响应函数 irqaction"></a>响应函数 irqaction</h4><p>在 irq_desc 中，struct irqaction <em>action,主要是用来存用户注册的中断处理函数,一个中断可以有多个处理函数 ,当一个中断有多个处理函数,说明这个是共享中断。所谓<em>*共享中断</em></em>就是一个中断的来源有很多,这些来源共享同一个引脚。所以在irq_desc结构体中的action成员是个链表,以action为表头,若是一个以上的链表就是共享中断</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token punctuation">&#123;</span>
         <span class="token class-name">irq_handler_t</span> handler<span class="token punctuation">;</span>      <span class="token comment">//等于用户注册的中断处理函数,中断发生时就会运行这个中断处理函数</span>
         <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>         <span class="token comment">//中断标志,注册时设置,比如上升沿中断，下降沿中断等</span>
         <span class="token class-name">cpumask_t</span> mask<span class="token punctuation">;</span>           <span class="token comment">//中断掩码</span>
         <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>          <span class="token comment">//中断名称,产生中断的硬件的名字</span>
         <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">;</span>              <span class="token comment">//设备id</span>
         <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>        <span class="token comment">//指向下一个成员</span>
         <span class="token keyword">int</span> irq<span class="token punctuation">;</span>                    <span class="token comment">//中断号,</span>
         <span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span> <span class="token operator">*</span>dir<span class="token punctuation">;</span>    <span class="token comment">//指向IRQn相关的/proc/irq/</span>
 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="中断数据-irq-data"><a href="#中断数据-irq-data" class="headerlink" title="中断数据 irq_data"></a>中断数据 irq_data</h4><p>中断描述符中应该会包括底层irq chip相关的数据结构，linux kernel中把这些数据组织在一起，形成struct irq_data，具体代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token punctuation">&#123;</span> 
    u32            mask<span class="token punctuation">;</span>－－－－－－－－－－TODO 
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        irq<span class="token punctuation">;</span>－－－－－－－－IRQ number 
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>        hwirq<span class="token punctuation">;</span>－－－－－－－HW interrupt ID 
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        node<span class="token punctuation">;</span>－－－－－－－NUMA node index 
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        state_use_accessors<span class="token punctuation">;</span>－－－－－－－－底层状态，参考IRQD_xxxx 
    <span class="token keyword">struct</span> <span class="token class-name">irq_chip</span>        <span class="token operator">*</span>chip<span class="token punctuation">;</span>－－－－－－－－－－该中断描述符对应的irq chip数据结构 
    <span class="token keyword">struct</span> <span class="token class-name">irq_domain</span>    <span class="token operator">*</span>domain<span class="token punctuation">;</span>－－－－－－－－该中断描述符对应的irq domain数据结构 
    <span class="token keyword">void</span>            <span class="token operator">*</span>handler_data<span class="token punctuation">;</span>－－－－－－－－和外设specific handler相关的私有数据 
    <span class="token keyword">void</span>            <span class="token operator">*</span>chip_data<span class="token punctuation">;</span>－－－－－－－－－和中断控制器相关的私有数据 
    <span class="token keyword">struct</span> <span class="token class-name">msi_desc</span>        <span class="token operator">*</span>msi_desc<span class="token punctuation">;</span> 
    cpumask_var_t        affinity<span class="token punctuation">;</span>－－－－－－－和irq affinity相关 
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="操作合集-irq-chip"><a href="#操作合集-irq-chip" class="headerlink" title="操作合集 irq_chip"></a>操作合集 irq_chip</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">irq_chip</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span>    <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span>    <span class="token punctuation">(</span><span class="token operator">*</span>irq_startup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>初始化中断
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_shutdown<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>结束中断
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_enable<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>使能中断
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_disable<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>关闭中断
 
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_ack<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>应答中断
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_mask<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>屏蔽中断
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_mask_ack<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>应答并屏蔽中断
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_unmask<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>解除中断屏蔽
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_eoi<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>发送EOI信号，表示硬件中断处理已经完成。
 
    <span class="token keyword">int</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_set_affinity<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cpumask</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> bool force<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>绑定中断到某个CPU
    <span class="token keyword">int</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_retrigger<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>重新发送中断到CPU
    <span class="token keyword">int</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_set_type<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flow_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>设置触发类型
    <span class="token keyword">int</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_set_wake<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>使能<span class="token operator">/</span>关闭中断在电源管理中的唤醒功能。
 
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_bus_lock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_bus_sync_unlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_cpu_online<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_cpu_offline<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_resume<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_pm_shutdown<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>    flags<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="软中断，Tasklet和Work-Queue"><a href="#软中断，Tasklet和Work-Queue" class="headerlink" title="软中断，Tasklet和Work Queue"></a>软中断，<code>Tasklet</code>和<code>Work Queue</code></h2><p>​    由内核执行的几个任务之间有一些不是紧急的，他们可以被延缓一段时间！把可延迟的中断从中断处理程序中抽出来，有利于使得内核保持较短的响应时间，所以我们现在使用以下面的这些结构，来把这样的非紧急的中断处理函数抽象出来！下面列出还在使用三个的机制：</p>
<blockquote>
<p><strong>软中断（softirq）</strong>：内核2.3引入，是最基本、最优先的软中断处理形式，为了避免名字冲突，本文中将这种子类型的软中断叫softirq。</p>
<p><strong>tasklet</strong>：其底层使用softirq机制实现，提供了一种用户方便使用的软中方式，为软中断提供了很好的扩展性。（封装了soft_irq）</p>
<p><strong>work queue</strong>：前两种软中断执行时是禁止抢占的（softirq的ksoftirq除外），对于用户进程不友好。如果在softirq执行时间过长，会继续推后到work queue中执行，work queue执行处于进程上下文，其可被抢占，也可以被调度，如果软中断需要执行睡眠、阻塞，直接选择work queue。</p>
</blockquote>
<h3 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h3><p>前已注册的软中断有10种，定义为一个全局数组：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> softirq_vec<span class="token punctuation">[</span>NR_SOFTIRQS<span class="token punctuation">]</span><span class="token punctuation">;</span>
 
<span class="token keyword">enum</span> <span class="token punctuation">&#123;</span>
    HI_SOFTIRQ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">/* 优先级高的tasklets */</span>
    TIMER_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 定时器的下半部 */</span>
    NET_TX_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 发送网络数据包 */</span>
    NET_RX_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 接收网络数据包 */</span>
    BLOCK_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* BLOCK装置 */</span>
    BLOCK_IOPOLL_SOFTIRQ<span class="token punctuation">,</span>
    TASKLET_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 正常优先级的tasklets */</span>
    SCHED_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 调度程序 */</span>
    HRTIMER_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 高分辨率定时器 */</span>
    RCU_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* RCU锁定 */</span>
    NR_SOFTIRQS <span class="token comment">/* 10 */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（2）注册软中断处理函数</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * @nr: 软中断的索引号
 * @action: 软中断的处理函数
 */</span>
<span class="token keyword">void</span> <span class="token function">open_softirq</span><span class="token punctuation">(</span><span class="token keyword">int</span> nr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>action<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    softirq_vec<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">.</span>action <span class="token operator">=</span> action<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">open_softirq</span><span class="token punctuation">(</span>NET_TX_SOFTIRQ<span class="token punctuation">,</span> net_tx_action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">open_softirq</span><span class="token punctuation">(</span>NET_RX_SOFTIRQ<span class="token punctuation">,</span> net_rx_action<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>（3）触发软中断</strong></p>
<p>调用raise_softirq()来触发软中断。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">raise_softirq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
    <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">raise_softirq_irqoff</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
 
<span class="token comment">/* This function must run with irqs disabled */</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">rasie_softirq_irqsoff</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">__raise_softirq_irqoff</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">/* If we're in an interrupt or softirq, we're done
     * (this also catches softirq-disabled code). We will
     * actually run the softirq once we return from the irq
     * or softirq.
     * Otherwise we wake up ksoftirqd to make sure we
     * schedule the softirq soon.
     */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">in_interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">/* 如果不处于硬中断或软中断 */</span>
        <span class="token function">wakeup_softirqd</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 唤醒ksoftirqd/n进程 */</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Percpu变量irq_cpustat_t中的__softirq_pending是等待处理的软中断的位图，通过设置此变量即可告诉内核该执行哪些软中断。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">static</span> inline <span class="token keyword">void</span> <span class="token function">__rasie_softirq_irqoff</span><span class="token punctuation">(</span><span class="token parameter">unsigned int nr</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">trace_softirq_raise</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">or_softirq_pending</span><span class="token punctuation">(</span>1UL <span class="token operator">&lt;&lt;</span> nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
 
typedef struct <span class="token punctuation">&#123;</span>
    unsigned int __softirq_pending<span class="token punctuation">;</span>
    unsigned int __nmi_count<span class="token punctuation">;</span> <span class="token comment">/* arch dependent */</span>
<span class="token punctuation">&#125;</span> irq_cpustat_t<span class="token punctuation">;</span>
 
irq_cpustat_t irq_stat<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
#define <span class="token function">__IRQ_STAT</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> member<span class="token punctuation">)</span> <span class="token punctuation">(</span>irq_stat<span class="token punctuation">[</span>cpu<span class="token punctuation">]</span><span class="token punctuation">.</span>member<span class="token punctuation">)</span>
#define <span class="token function">or_softirq_pending</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">percpu_or</span><span class="token punctuation">(</span>irq_stat<span class="token punctuation">.</span>__softirq_pending<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
#define <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">percpu_read</span><span class="token punctuation">(</span>irq_stat<span class="token punctuation">.</span>__softirq_pending<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>唤醒ksoftirqd内核线程处理软中断。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">wakeup_softirqd</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">void</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/* Interrupts are disabled: no need to stop preemption */</span>
    struct task_struct <span class="token operator">*</span>tsk <span class="token operator">=</span> <span class="token function">__get_cpu_var</span><span class="token punctuation">(</span>ksoftirqd<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tsk <span class="token operator">&amp;&amp;</span> tsk<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">!=</span> <span class="token constant">TASK_RUNNING</span><span class="token punctuation">)</span>
        <span class="token function">wake_up_process</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在下列地方，待处理的软中断会被检查和执行：</p>
<p>a. 从一个硬件中断代码处返回时</p>
<p>b. 在ksoftirqd内核线程中</p>
<p>c. 在那些显示检查和执行待处理的软中断的代码中，如网络子系统中</p>
<p>而不管是用什么方法唤起，软中断都要在do_softirq()中执行。如果有待处理的软中断，do_softirq()会循环遍历每一个，调用它们的相应的处理程序。</p>
<p>在中断处理程序中触发软中断是最常见的形式。中断处理程序执行硬件设备的相关操作，然后触发相应的软中断，最后退出。内核在执行完中断处理程序以后，马上就会调用do_softirq()，于是软中断开始执行中断处理程序完成剩余的任务。</p>
<p>下面来看下do_softirq()的具体实现。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">asmlinkage <span class="token keyword">void</span> <span class="token function">do_softirq</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">void</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    __u32 pending<span class="token punctuation">;</span>
    unsigned long flags<span class="token punctuation">;</span>
 
    <span class="token comment">/* 如果当前已处于硬中断或软中断中，直接返回 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
        <span class="token keyword">return</span><span class="token punctuation">;</span>
 
    <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pending <span class="token operator">=</span> <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pending<span class="token punctuation">)</span> <span class="token comment">/* 如果有激活的软中断 */</span>
        <span class="token function">__do_softirq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 处理函数 */</span>
    <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/* We restart softirq processing MAX_SOFTIRQ_RESTART times,
 * and we fall back to softirqd after that.
 * This number has been established via experimentation.
 * The two things to balance is latency against fairness - we want
 * to handle softirqs as soon as possible, but they should not be
 * able to lock up the box.
 */</span>
asmlinkage <span class="token keyword">void</span> <span class="token function">__do_softirq</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">void</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    struct softirq_action <span class="token operator">*</span>h<span class="token punctuation">;</span>
    __u32 pending<span class="token punctuation">;</span>
    <span class="token comment">/* 本函数能重复触发执行的次数，防止占用过多的cpu时间 */</span>
    int max_restart <span class="token operator">=</span> <span class="token constant">MAX_SOFTIRQ_RESTART</span><span class="token punctuation">;</span>
    int cpu<span class="token punctuation">;</span>
 
    pending <span class="token operator">=</span> <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 激活的软中断位图 */</span>
    <span class="token function">account_system_vtime</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 本地禁止当前的软中断 */</span>
    <span class="token function">__local_bh_disable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>unsigned long<span class="token punctuation">)</span><span class="token function">__builtin_return_address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">SOFTIRQ_OFFSET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">lockdep_softirq_enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* current->softirq_context++ */</span>
    cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 当前cpu编号 */</span>
 
<span class="token literal-property property">restart</span><span class="token operator">:</span>
    <span class="token comment">/* Reset the pending bitmask before enabling irqs */</span>
    <span class="token function">set_softirq_pending</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 重置位图 */</span>
    <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    h <span class="token operator">=</span> softirq_vec<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            unsigned int vec_nr <span class="token operator">=</span> h <span class="token operator">-</span> softirq_vec<span class="token punctuation">;</span> <span class="token comment">/* 软中断索引 */</span>
            int prev_count <span class="token operator">=</span> <span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">kstat_incr_softirqs_this_cpu</span><span class="token punctuation">(</span>vec_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token function">trace_softirq_entry</span><span class="token punctuation">(</span>vec_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            h<span class="token operator">-</span><span class="token operator">></span><span class="token function">action</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 调用软中断的处理函数 */</span>
            <span class="token function">trace_softirq_exit</span><span class="token punctuation">(</span>vec_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>prev_count <span class="token operator">!=</span> <span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">printk</span><span class="token punctuation">(</span><span class="token constant">KERN_ERR</span> <span class="token string">"huh, entered softirq %u %s %p"</span> <span class="token string">"with preempt_count %08x,"</span>
                    <span class="token string">"exited with %08x?\n"</span><span class="token punctuation">,</span> vec_nr<span class="token punctuation">,</span> softirq_to_name<span class="token punctuation">[</span>vec_nr<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token operator">-</span><span class="token operator">></span>action<span class="token punctuation">,</span> prev_count<span class="token punctuation">,</span>
                    <span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token function">rcu_bh_qs</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        h<span class="token operator">++</span><span class="token punctuation">;</span>
        pending <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pending <span class="token operator">=</span> <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">&amp;</span> <span class="token operator">--</span>max_restart<span class="token punctuation">)</span> <span class="token comment">/* 重复触发 */</span>
        goto restart<span class="token punctuation">;</span>
 
    <span class="token comment">/* 如果重复触发了10次了，接下来唤醒ksoftirqd/n内核线程来处理 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pending<span class="token punctuation">)</span>
        <span class="token function">wakeup_softirqd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 
    <span class="token function">lockdep_softirq_exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">account_system_vtime</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__local_bh_enable</span><span class="token punctuation">(</span><span class="token constant">SOFTIRQ_OFFSET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（4）ksoftirqd内核线程</strong></p>
<p>​    内核不会立即处理重新触发的软中断。当大量软中断出现的时候，内核会唤醒一组内核线程来处理。这些线程的优先级最低(nice值为19)，这能避免它们跟其它重要的任务抢夺资源。但它们最终肯定会被执行，所以这个折中的方案能够保证在软中断很多时用户程序不会因为得不到处理时间而处于饥饿状态，同时也保证过量的软中断最终会得到处理。</p>
<p>每个处理器都有一个这样的线程，名字为ksoftirqd/n，n为处理器的编号。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">static</span> int <span class="token function">run_ksoftirqd</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">void</span> <span class="token operator">*</span>__bind_cpu</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_INTERRUPTIBLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    current<span class="token operator">-</span><span class="token operator">></span>flags <span class="token operator">|=</span> <span class="token constant">PF_KSOFTIRQD</span><span class="token punctuation">;</span> <span class="token comment">/* I am ksoftirqd */</span>
 
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">kthread_should_stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 如果没有要处理的软中断 */</span>
            <span class="token function">preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
        <span class="token punctuation">&#125;</span>
 
        <span class="token function">__set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_RUNNING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">/* Preempt disable stops cpu going offline.
             * If already offline, we'll be on wrong CPU: don't process.
             */</span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpu_is_offline</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>__bind_cpu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">/* 被要求释放cpu */</span>
                 goto wait_to_die<span class="token punctuation">;</span>
 
            <span class="token function">do_softirq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 软中断的统一处理函数 */</span>
 
            <span class="token function">preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">cond_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">rcu_note_context_switch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>__bind_cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
 
        <span class="token function">preempt_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_INTERRUPTIBLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token function">__set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_RUNNING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
<span class="token literal-property property">wait_to_die</span><span class="token operator">:</span>
    <span class="token function">preempt_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* Wait for kthread_stop */</span>
    <span class="token function">set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_INTERRUPTIBLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">kthread_should_stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_INTERRUPTIBLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
 
    <span class="token function">__set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_RUNNING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Tasklet-API"><a href="#Tasklet-API" class="headerlink" title="Tasklet API"></a>Tasklet API</h3><p>动态初始化函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void tasklet_init(struct tasklet_struct *t,void (*func)(unsigned long), unsigned long data)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>t: struct tasklet_struct</code> 结构指针</li>
<li><code>func</code>：小任务函数</li>
<li><code>data</code>：传递给工作函数的实际参数</li>
</ul>
<p>静态初始化：静态初始化DECLARE_TASKLET(name, func, data)，定义一个名字为 name 的结构变量 ，并且使用 func,data对结构进行初始化，这个宏定义的 tasklet 是可调度的。静态初始化DECLARE_TASKLET_DISABLED(name, func, data)和DECLARE_TASKLET(name, func, data)，不同是它开始不能被调度。必须先把 count 设置为0,才可以调度</p>
<pre class="line-numbers language-none"><code class="language-none">name：struct tasklet_struct的名字
func：tasklet函数指针
data：传递给func函数的参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>激活/取消激活 tasklet  </p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void tasklet_disable(struct tasklet_struct *t)   &#x2F;&#x2F; 把 count 设置为1
void tasklet_enable (struct tasklet_struct *t)   &#x2F;&#x2F; 把count 设置为0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>调度函数</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void  tasklet_schedule (struct tasklet_struct *t)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>调度某个指定的tasklet小任务，调用后tasklet关联的函数会执行.一旦执行，则会在适当时候去执行 tasklet_struct 绑定的函数。对同一个 struct tasklet_struct 连续调度多次，效果等同一次（前提条件：当前一次调用，绑定函数还没有执行）。</p>
<p>5）kill掉函数（取消任务）</p>
<pre class="line-numbers language-none"><code class="language-none">tasklet_kill(struct tasklet_struct *t);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>6） tasklet和普通工作队列区别：</p>
<p>它所绑定的函数不能休眠</p>
<p>它的响应速度高于普通工作队列。</p>
<hr>
<h3 id="tasklet-微线程的编程步骤："><a href="#tasklet-微线程的编程步骤：" class="headerlink" title="tasklet 微线程的编程步骤："></a><strong>tasklet 微线程的编程步骤：</strong></h3><p>taskle 内核机制实现过程是非常复杂的，但是对于驱动开发者来说，重点是掌握如果使用内核已经给我们实现好的tasklet机制。tasklet编程其实只有简单的几步，下面我们总结一下tasklet机制的编程步骤。</p>
<p><strong>1. 定义tasklet 工作函数</strong></p>
<p><strong>2. 定义tasklet 结构变量</strong></p>
<p>定义分有静态定义和动态定义两种方式：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 动态定义：
struct tasklet_struct my_tasklet;
&#x2F;&#x2F; 静态定义：
DECLARE_TASKLET(my_tasklet, my_tasklet_function, data);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p> <strong>3. 初始化tasklet结构，绑定工作函数</strong></p>
<p>如果上一步是采用静态定义，则这一步不用再做，跳过。如果是采用动态定义tasklet，则使用tasklet_init()函数进行初始化以及绑定。</p>
<pre class="line-numbers language-none"><code class="language-none">tasklet_init(&amp;my_tasklet, my_tasklet_function, data)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>4. 在适当的地方调度工作函数</strong></p>
<p>tasklet一般是用于处理中断的下半部的，所以<strong>一般在中断的上半部调度</strong>tasklet工作函数。</p>
<pre class="line-numbers language-none"><code class="language-none">tasklet_schedule(&amp;my_tasklet);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>5. 销毁tasklet工作任务</strong></p>
<p>在确定不再使用tasklet时，应该在适当的地方调用tasklet_kill()函数销毁tasklet任务，释放资源，这个适当的地方一般的tasklet初始化地方是相反的，比如，如果是在模块初始化函数初始化了tasklet,则相应地是在模块卸载函数调用tasklet_kill函数来销毁tasklet任务。</p>
<pre class="line-numbers language-none"><code class="language-none">tasklet_kill(&amp;my_tasklet);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="从中断和异常返回"><a href="#从中断和异常返回" class="headerlink" title="从中断和异常返回"></a>从中断和异常返回</h3><p><img src=".\image-20240501110101822.png" alt="image-20240501110101822"></p>
<p>​    我们用《深入理解Linux内核》的一张大图来收尾。</p>
<p>​    我们的ret_from_intr和ret_from_exception本质上等价于：</p>
<p><strong>入口点</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">ret_from_exception:
	cli    &#x2F;&#x2F; 只有从异常返回时才使用 cli，禁用本地中断
ret_from_intr:
	movl $-8192, %ebp  &#x2F;&#x2F; 将当前 thread_info 描述符的地址装载到 ebp 寄存器
	andl %esp, %ebp
	movl 0x30(%esp), %eax
	movb 0x2c(%esp), %al

	&#x2F;&#x2F; 根据发生中断或异常压入栈中的 cs 和 eflags 寄存器的值，
	&#x2F;&#x2F; 确定中断的程序在中断时是否运行在用户态
	testl $0x0002003, %eax  
	jnz resume_userspace
	jpm resume_kernel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>恢复内核控制路径</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">rusume_kernel:
	cli
	cmpl $0, 0x14(%ebp)  &#x2F;&#x2F; 如果 thread_info 描述符的 preempt_count 字段为0（运行内核抢占）
	jz need_resched      &#x2F;&#x2F; 跳到 need_resched
restore_all:       &#x2F;&#x2F; 否则，被中断的程序重新开始执行
	popl %ebx
	popl %ecx
	popl %edx
	popl %esi
	popl %edi
	popl %ebp
	popl %eax
	popl %ds
	popl %es
	addl $4, %esp
	iret   &#x2F;&#x2F; 结束控制<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>检查内核抢占</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">need_resched:
	movl 0x8(%ebp), %ecx
	testb $(1&lt;&lt;TIF_NEED_RESCHED), %cl  &#x2F;&#x2F; 如果 current-&gt;thread_info 的 flags 字段中的 TIF_NEED_RESCHED &#x3D;&#x3D; 0，没有需要切换的进程
	jz restore_all                     &#x2F;&#x2F; 因此跳到 restore_all
	testl $0x00000200, 0x30(%ebp)      &#x2F;&#x2F; 如果正在被恢复的内核控制路径是在禁用本地 CPU 的情况下运行
	jz restore_all                     &#x2F;&#x2F; 也跳到 restore_all，否则进程切换可能回破坏内核数据结构
	call preempt_schedule_irq          &#x2F;&#x2F; 进程切换，设置 preempt_count 字段的 PREEMPT_ACTIVE 标志，大内核锁计数器暂时设置为 -1，调用 schedule()
	jmp need_resched <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>恢复用户态程序</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">resume_userspace:
	cli  &#x2F;&#x2F; 禁用本地中断
	movl 0x8(%ebp), %ecx

	&#x2F;&#x2F; 检测 current-&gt;thread_info 的 flags 字段，
	&#x2F;&#x2F; 如果只设置了 TIF_SYSCALL_TRACE，TIF_SYSCALL_AUDIT 或 TIF_SINGLESTEP 标志，
	&#x2F;&#x2F; 跳到 restore_all
	andl $0x0000ff6e, %ecx
	je restore_all
	jmp work_pending<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>检测重调度标志</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">work_pending:
	testb $(1&lt;&lt;TIF_NEED_RESCHED), %cl
	jz work_notifysig
work_resched:
	call schedule  &#x2F;&#x2F; 如果进程切换请求被挂起，选择另外 一个进程运行
	cli
	jmp resume_userspace  &#x2F;&#x2F; 当前面的进程要恢复时<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>处理挂起信号、虚拟 8086 模式和单步执行</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">work_notifysig:
	movl %esp, %eax
	testl $0x00020000, 0x30(%esp)
	je 1f

&#x2F;&#x2F; 如果用户态程序 eflags 寄存器的 VM 控制标志被设置
work_notifysig_v86:
	pushl %ecx
	call save_v86_state    &#x2F;&#x2F; 在用户态地址空间建立虚拟8086模式的数据结构
	popl %ecx
	movl %eax, %esp
1:
	xorl %edx, %edx
	call do_notify_resume  &#x2F;&#x2F; 处理挂起信号和单步执行
	jmp restore_all        &#x2F;&#x2F; 恢复被中断的程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="Reference-2"><a href="#Reference-2" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/450293200">80x86中断 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2072999">Linux内核19-中断描述符表IDT的初始化-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoutaopower/article/details/90648475">Linux 中断 —— GIC (数据结构 irq_domain/irq_desc/irq_data/irq_chip/irqaction)_irq_data、irq_chip、irq_domain和irq_desc-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1518703">Linux内核硬中断 / 软中断的原理和实现-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010299133/article/details/100177713">linux内核之tasklet使用_tasklet 改绑定-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012319493/article/details/83315423">深入理解 Linux 内核—-中断和异常_ret_from_exception-CSDN博客</a>中断与异常</p>
<p>​    中断通常被定义为一个事件：让事件改变处理器执行的指令顺序这样的事件，与CPU芯片内外部硬件电路产生的电信号相对应！</p>
<p>​    中断通常分为同步中断与异步中断：</p>
<p>​    同步中断指的是当指令执行时，由CPU控制单元产生的。之所以称为同步，是因为只有在一条指令终止执行后，CPU才会发出中断！</p>
<p>​    异步中断是由其他硬件设备依照CPU时钟信号随机产生的</p>
<p>​    在英特尔微处理器手册中：也会把同步和异步中断分别称为异常和中断</p>
<p>​    中断则是由间隔定时器或者io设备产生的，举个例子你敲击键盘的时候，你的一次按键就会引发一个中断，希望操作系统介入进行处理！</p>
<p>​    另一方面异常是由程序的错误产生的，或者是由内核必须处理的异常条件产生的！比如说内核通过发送一个信号来处理异常，或者内核执行恢复异常所需要的步骤，比如说缺页，比如说对内核服务的一个请求</p>
<h2 id="中断信号的作用-1"><a href="#中断信号的作用-1" class="headerlink" title="中断信号的作用"></a>中断信号的作用</h2><p>​    顾名思义，中断信号提供了一种特殊的方式来让处理器转而去运行正常控制流之外的代码。当一个中断信号到达的时候CPU必须停止它当前所做的事情，转而切换去处理这些终端。为了做到这一点就需要把内核态堆栈保存PC当前的值，并且把中断相关类型的的一个地址放进程序计数器中。这样才会跳转去执行处理中断的代码。</p>
<p>​    中断处理器内核执行的最敏感的任务之一，因为它必须要满足：</p>
<ol>
<li>让内核正打算去完成别的事情的，由于中断随时都会到来，因此内核的目标就是：让中断尽可能的处理完尽可能把更多的更详细的处理向后推，所以中断响应分为两个部分：</li>
</ol>
<ul>
<li>关键而紧急的部分这一部分，内核立即执行。</li>
<li>其推迟的部分，则是内核随后执行。</li>
</ul>
<ol>
<li>因为中断随时会到来，所以内核可能正在处理其中一个中断的时候，另一个中断又发生了。应该尽可能地允许这种情况发生，因为这将会保持更多的io设备处于忙状态。因此中断处理程序必须编写成可以使相应的内核控制路径以嵌套的方式进行，执行到最后一个内核控制路径终止时，内核可以恢复被中断进程的执行，或者如果中断信号已导致了重新调度，内核可以切换到另外的进程。</li>
<li>尽管内核在处理前一个中断的时候，可以接受新的中断，但在内核代码区中仍然存在着一些临界区，在这些临界区中中断必须被禁止</li>
</ol>
<h2 id="中断和异常-1"><a href="#中断和异常-1" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>​    英特尔文档把中断和异常又分为了以下几类：</p>
<ol>
<li>中断：</li>
</ol>
<p>​    又分出两类即：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>可屏蔽中断</td>
<td>IO设备发出的所有中断请求（Interruppt Request）都产生可屏蔽的中断，它处于两状态：屏蔽的和非屏蔽的，如果一个中断是被屏蔽的，那么控制单元会被它会忽略它</td>
</tr>
<tr>
<td>非可屏蔽中断</td>
<td>只有少数的几个危机事件是这样的，非屏蔽的中断总是由CPU辨认</td>
</tr>
</tbody>
</table>
</div>
<p>异常：</p>
<p>异常分两类，处理器探测异常和编程异常。</p>
<p>处理器探测异常有三种</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>故障</td>
<td>通常可以被纠正，一旦纠正，程序就可以在不失连贯性的情况下，重新开始！保存在EIP中的值就是引起故障的指令地址，因此当异常处理程序终止时，那条指令会被重新执行</td>
</tr>
<tr>
<td>陷阱</td>
<td>在陷阱执行后，立即报告内核把控制权返回给程序后，就可以继续它的执行而不失去连贯性。保存在EIP中的值是一个随后要执行的指令地址，只有当没有必要重新执行已中止的指令时，才会触发陷阱。陷阱的主要目的是为了调试程序</td>
</tr>
<tr>
<td>异常终止</td>
<td>异常终止指的是发生了一个严重的错误及控制单元出现了问题，不能在EIP寄存器中保存引发了这个异常指令所在的确切位置。异常终止用的报告严重的错误，如硬件故障或系统表中无效的值或不一样的值。</td>
</tr>
</tbody>
</table>
</div>
<p>编程异常：在编程者发出请求时发生是由int或int3指令触发的当into（检查溢出）和bound（检查地址出界）指令检查的条件不为真时，会引发编程异常控制单元！编程异常当作陷阱来处理，编程异常也被称为软中断，这样的异常常有两种的用途执行：系统调用以及给调试程序通报一个特定的事件。</p>
<h3 id="IRQ与中断-1"><a href="#IRQ与中断-1" class="headerlink" title="IRQ与中断"></a>IRQ与中断</h3><p>​    每个能够发出中断请求的硬件设备系都有一条名为IRQ的输出线，所有现有的IRQ线都与一个名为可编程中断控制器的硬件电路的输入引脚相连，可编程中断控制器执行下列动作：</p>
<ul>
<li>监视IRQ线检查产生的信号，如果有两条或两条以上的IRQ线上产生信号，选择引脚编号较小的IRQ线</li>
<li>如果一个引发信号出现在线上，那么它会把接收到的信发信号转换成对应的向量，把这个向量存放在中断控制器的一个io端口，从而允许CPU通过数据总线读取此向量。把引发信号发送到处理器的INTR引脚，也就是产生了一个中断</li>
<li>等待直到CPU通过把这个中断信号写进可编程中断控制器的io端口号，来确认它，当这种情况发生时，清理INTR线。然后继续监视。</li>
</ul>
<h3 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h3><p>​    这里给出一些常见的异常：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>异   常   一   览   表</th>
<th>向量号</th>
<th>异常名称</th>
<th>异常类型</th>
<th>出错代码</th>
<th>相关指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>除法出错</td>
<td>故障</td>
<td>无</td>
<td>DIV,IDIV</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>调试异常</td>
<td>故障/陷阱</td>
<td>无</td>
<td>任何指令</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>单字节INT3</td>
<td>陷阱</td>
<td>无</td>
<td>INT 3</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>溢出</td>
<td>陷阱</td>
<td>无</td>
<td>INTO</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>边界检查</td>
<td>故障</td>
<td>无</td>
<td>BOUNT</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>非法操作码</td>
<td>故障</td>
<td>无</td>
<td>非法指令编码或操作数</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>设备不可用</td>
<td>故障</td>
<td>无</td>
<td>浮点指令或WAIT</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>双重故障</td>
<td>中止</td>
<td>有</td>
<td>任何指令</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>协处理器段越界</td>
<td>中止</td>
<td>无</td>
<td>访问存储器的浮点指令</td>
<td></td>
</tr>
<tr>
<td>0AH</td>
<td>无效TSS异常</td>
<td>故障</td>
<td>有</td>
<td>JMP、CALL、IRET或中断</td>
<td></td>
</tr>
<tr>
<td>0BH</td>
<td>段不存在</td>
<td>故障</td>
<td>有</td>
<td>装载段寄存器的指令</td>
<td></td>
</tr>
<tr>
<td>0CH</td>
<td>堆栈段异常</td>
<td>故障</td>
<td>有</td>
<td>装载SS寄存器的任何指令、对SS寻址的段访问的任何指令</td>
<td></td>
</tr>
<tr>
<td>0DH</td>
<td>通用保护异常</td>
<td>故障</td>
<td>有</td>
<td>任何特权指令、任何访问存储器的指令</td>
<td></td>
</tr>
<tr>
<td>0EH</td>
<td>页异常</td>
<td>故障</td>
<td>有</td>
<td>任何访问存储器的指令</td>
<td></td>
</tr>
<tr>
<td>10H</td>
<td>协处理器出错</td>
<td>故障</td>
<td>无</td>
<td>浮点指令或WAIT</td>
<td></td>
</tr>
<tr>
<td>11H—0FFH</td>
<td>软中断</td>
<td>陷阱</td>
<td>无</td>
<td>INT n</td>
</tr>
</tbody>
</table>
</div>
<h3 id="中断向量表-1"><a href="#中断向量表-1" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>​    中断描述符表IDT是一个系统表，它与每一个中断或者异常向量相联系</p>
<p>​    每一个向量在表中都有相应的中断或异常处理程序的入口地址，内核在允许中断发生前，必须适当初始化IDT</p>
<p>​    下图为IDT的结构表示图：</p>
<p><img src=".\v2-50034e68241345db7c96b90647155494_1440w.webp" alt="img"></p>
<p>这些描述符是:</p>
<ul>
<li>任务门<code>Task Gate</code>：当中断信号发生时，必须取代当前进程的那个进程的TSS选择符，存放在任务门中</li>
<li>中断门<code>Interrupt Gate</code>：包含段选择符和中断或异常处理程序的段内偏移量，当控制权转移到应适当的段时，处理器清IF标志，从而关闭即将会发生的可屏蔽中断。</li>
<li>陷阱门<code>Trap Gate</code>：与中断门相似只是控制权传递到一个适当的段时处理器不修改IF标志Linux使用中断门处理中断应用陷阱门处理异常 </li>
</ul>
<h3 id="硬件处理-1"><a href="#硬件处理-1" class="headerlink" title="硬件处理"></a>硬件处理</h3><p>​    现在描述CPU控制单元是如何处理中断和异常的！</p>
<p>​    我们现在假定内核已经被初始化，因此CPU将会在保护模式下运行。</p>
<p>​    当执行了一条指令后，CS和EIP这对寄存器将会包含下一条将要执行的指令的逻辑地址。在处理那条指令之前控制单元会检查在运行前一条指令是否已经发生一个中断或者异常，如果发生了，那么它将会：</p>
<ol>
<li><p>确定与中断或异常关联的向量（看一眼是哪个异常）</p>
</li>
<li><p>读由寄存器指向的<code>IDT</code>表中的<code>i</code>项（肘！IDT表爆破）</p>
</li>
<li><p>从<code>gdpr</code>寄存器中获取GDP的基地址，并在GDP中查找，以读取IDT表项的选择符所标识的段描述符。这个描述符指定中断或异常处理程序所在段的基地址（看看这个程序在哪里）</p>
</li>
<li><p>确信中断事由授权的中断发生源发出的，首先将当前特权级CPL与段描述符的描述符特权级DPL的相比较：如果CPL小于DPL了就会产生一个<code>general protection</code>异常，因为中断处理程序的特权不能低于引起中断的程序的特权！对于编程异常则需要做进一步的安全检查：比较CPL了与处于IDT中的门描述符的DPL了，如果DPL小于CPL了那么就产生一个<code>general protection</code>，这最后一个检查可以避免用户应用程序访问特殊的陷阱门和中断门（配不配处理这个异常）</p>
</li>
<li><p>检查是否发生了特权级变化：也就是说CPL是否不同于所选择的段描述符的DPL，如果是，控制单元必须开始使用与新的特权级相关的栈，通过执行以下步骤来做到这一点：</p>
<blockquote>
<ol>
<li>读TR寄存器以访问运行进程的TSS段</li>
<li>用于新特权级相关的栈段和栈指针的正确值装载SS和ESP寄存器这些值，可以在TSS中找到在新的段中</li>
<li>保存SS和ESP以前的值，这些值定义了与旧特训级相关的栈的逻辑地址。</li>
</ol>
</blockquote>
</li>
<li><p>如果故障已经发生，用引起异常的指令地址装载CS和EIP寄存器，从而使得这条指令能够再次被执行！</p>
</li>
<li><p>在栈中保存eflags,cs,EIP等内容，如果引用异常产生了一个硬件出错码，把它保存到栈中，装在CS和EIP寄存器其值分别为IDT表中第I项门描述服务的段选择符和偏移量字段，这些值给出了中断或者异常处理的第一条指令的逻辑地址！</p>
</li>
</ol>
<p>​    控制单元所执行的最后一步就是跳转到这些异常处理程序，换句话说处理完中断信号后控制单元所执行的指令，就是被选中处理程序的第一条指令！</p>
<p>​    当中断或处理结束后和异常被处理结束后相应的处理程序必须参与生一条iret指令，他把控制权转交给被中断的进程。这将会迫使控制单元：</p>
<ol>
<li>用保存在栈中的值装在CS或eflags寄存器，如果一个硬件出错码曾经被压入栈中，并且在EIP内容的上面，那么执行Iret指令前必须弹出这个硬件错误码（准备回家）</li>
<li>检查处理程序的CPL是否等于CS中的最低两位的值如果是iret终止执行，否则执行下一步。（看看特权级够不够）</li>
<li>从栈中装载SS和ESP寄存器因此返回到与特权级相关的栈（也就是恢复栈）</li>
<li>检查DS ES FS 以及 GS段寄存器的内容，如果其中一个寄存器包含选择符是一个段描述符，并且其的DPL值小于CPL了，那么我们会清理相应的段寄存器控制单元，这么做是为了防止用户态的程序利用内核以前所用的段寄存器，如果不清理这些寄存器，那么一些怀有恶意的用户态程序就有可能利用他们来访问内核地址。（安全处理，安全恢复环境）</li>
</ol>
<h3 id="中断和异常处理程序的嵌套执行-1"><a href="#中断和异常处理程序的嵌套执行-1" class="headerlink" title="中断和异常处理程序的嵌套执行"></a>中断和异常处理程序的嵌套执行</h3><p>​    每个中断或异常都会引起一个内核控制路径，或者说当前的进程在内核态执行单独的指令序列。</p>
<p>​    内核控制路径可以任意嵌套！一个中断处理程序可以被另一个中断处理程序所中断，因此这样就引起了内核控制路径的嵌套执行。允许内核控制路径嵌套执行必须要付出相应的代价，也就是中断处理程序必须永不阻塞换，中断处理程序在运行期间是不能够发生进程切换。</p>
<p>​    基于以下两个主要原因，Linux交错执行内核控制路径：</p>
<ol>
<li>为了提高可编程中断控制器和设备控制中器的吞吐量。假定设备控制器在一条线上产生了一条信号，pic把这个信号转换成一个外部中断，然后pic和控制设备器保持阻塞一直到pic从内核CPU处接收一条应答信息！由于内核控制路径的交错执行内核即使正在处理前一个中断也能够发送应答。</li>
<li>为了实现一种没有优先级的中断模型，每个C中断处理程序都可以被另一个中断处理程序所延缓，因此在硬件设备之间没必要预定义优先级，这简化了内核代码，也提高了内核的可移植性！</li>
</ol>
<h2 id="初始化IDT-1"><a href="#初始化IDT-1" class="headerlink" title="初始化IDT"></a>初始化IDT</h2><p>​    Linux在基于Intel给出的三种门之外，还更加细分了他们：</p>
<blockquote>
<p><strong>中断门(interrupt gate)</strong>：用户态的进程不能访问的一个lntel中断门(门的DPL字段为0)。所有的Linux中 断处理程序都通过中断门激活，并全部限制在内核态。</p>
<p><strong>系统门(syslem gate)</strong>：用户态的进程可以访问的一个Intel陷阱门(门的DPL字段为到.通过系统门来激 活三个Linux异常处理程序，它们的向量是4，5及128，因此，在用户态下.可以 发布into、 bound及int $Ox80三条汇编语言指令。</p>
<p><strong>系统中断门(system interrupt gate)</strong>：能够被用户态进程访问的Intel中断门(门的DPL字段为3). 与向量3相关的异常 处理程序是由系统中断门激活的，因此，在用户态可以使用汇编语言指令int3.</p>
<p><strong>陷阱门(Irapgate)</strong>：用户态的进程不能访问的一个Inte)陷阱门(f]的DPL字段为0). 大部分Linux异 常处理程序都通过陷阱门来激活.</p>
<p><strong>任务门(task gate)</strong>：不能被用户态进程访问的Intel任务门(门的DPL字段为0).Linux对”Doublefault” 异常的处理程序是由任务门激活的.</p>
</blockquote>
<p>​    IDT会被初始化两次。第一次是在BIOS程序中，此时CPU还工作在实模式下。一旦Linux启动，IDT会被搬运到RAM的受保护区域并被第二次初始化，因为Linux不会使用任何BIOS程序。</p>
<p>IDT结构被存储在idt_table表中，包含256项。idt_descr变量存储IDT的大小和它的地址，在系统的初始化阶段，内核用来设置idtr寄存器，专用汇编指令是lidt。</p>
<p>内核初始化的时候，汇编函数setup_idt()用相同的中断门填充idt_table表的所有项，都指向ignore_int()中断处理函数：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&gt;setup_idt:
  lea ignore_int, %edx
  movl $(__KERNEL_CS &lt;&lt; 16), %eax
  movw %dx, %ax           &#x2F;*  &#x3D; 0x0010 &#x3D; cs *&#x2F;
  movw $0x8e00, %dx       &#x2F;* 中断门，DPL&#x3D;0 *&#x2F;
  lea idt_table, %edi     &#x2F;* 加载idt表的地址到寄存器edi中 *&#x2F;
  mov $256, %ecx
&gt;rp_sidt:
  movl %eax, (%edi)       &#x2F;* 设置中断处理函数 *&#x2F;
  movl %edx, 4(%edi)      &#x2F;* 设置段描述符 *&#x2F;
  addl $8, %edi           &#x2F;* 跳转到IDT表的下一项 *&#x2F;
  dec %ecx                &#x2F;* 自减 *&#x2F;
  jne rp_sidt
  ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>中断处理函数<code>ignore_int()</code>，也是一个汇编语言编写的函数，相当于一个null函数，它执行：</p>
<ol>
<li>保存一些寄存器到堆栈中。</li>
<li>调用printk()函数打印<code>Unknown interrupt</code>系统消息`。</li>
<li>从堆栈中恢复寄存器的内容。</li>
<li>执行iret指令回到调用处。</li>
</ol>
<p>​    正常情况下，此时的中断处理函数ignore_int()是不应该被执行的。如果在console或者log日志中出现<code>Unknown interrupt</code>的消息，说明发生硬件错误或者内核错误。</p>
<p>​    完成这次IDT表的初始化之后，内核还会进行第二次初始化，用真正的trap或中断处理函数代替刚才的null函数。一旦这两步初始化都完成，IDT表就包含具体的中断、陷阱和系统门，用以控制每个中断请求。</p>
<h2 id="中断处理-1"><a href="#中断处理-1" class="headerlink" title="中断处理"></a>中断处理</h2><p>​     这里讨论三种中断类型：</p>
<p>​    IO中断，时钟中断。和处理器间中断io</p>
<p>​    中断处理程序必须足够灵活地给多个设备同时提供服务，比如说在PCI总线的体系架构中几个设备可以共享一个IRQ线，这也就意味着仅仅中断向量是并不能说明所有问题的！中断处理程序的灵活性是以两种不同的方式实现的：</p>
<p>IRQ共享</p>
<p>中断处理程序执行多个中断服务例程，每个中断服务例程是一个与单独设备相关的函数，因此不可能预先知道哪个特定的设备产生，因此每个IRQ，也就是中断服务例程，都会被执行验证它的设备是否需要关注，如果是，当设备产生中断时则需要执行相关的所有操作</p>
<p>IRQ动态分配</p>
<p>一条线可能在最后的时刻才会与一个设备驱动程序相关联，这样，即使几个硬件设备并不共享线，同一个向量也可以在这几个设备在不同时刻中使用。当一个中断发生时，并不是所有的操作都具有急迫性，，因此Linux会把紧随中断要执行的操作分为三类：</p>
<blockquote>
<p>紧急的：这样的操作比如说对pic应答中断，对pic或设备控制器中编程重修改，由设备和处理器同时访问的数据结构这样的操作都可以很快的被执行，他们是紧急的，因为他们必须要尽快的执行紧急操作！要在一个中断处理程序内立即执行，而且是在禁止可屏蔽中断的情况下</p>
<p>非紧急的：这样的操作比如说修改那些只有处理器才会访问的数据结构，这样的操作必须也很快完成，因此它们由中断处理程序立即执行，但它们是在开中断的情况下执行的</p>
<p>非紧急可延迟的：比如说把缓冲区的内容拷贝到进程的地址空间中，这样的操作可能被延迟较长的时间间隔，而不会影响内核的操作！</p>
</blockquote>
<p>​    不管引起中断的电路类型如何所有的io中断处理程序都执行四个基本的操作：</p>
<ol>
<li>在内核态堆栈中保存的值与寄存器的内容</li>
<li>为正在给线服务的pic发送个应答，这将允许pic进一步发出中断</li>
<li>执行共享这个IRQ的所有设备都中断服务例程</li>
<li>跳到ret_from_intr的地址后终止</li>
</ol>
<p>​    为一个IRQ可配置设备选择一条线，有三种方式：</p>
<ul>
<li>设置一些硬件跳线跳接器</li>
<li>安装设备时执行一个实用程序，这样的程序可以让用户选择一个可用的RQ号或者探测系统自身以确定一个可用的IRQ号</li>
<li>在系统启动时执行一个硬件协议，外设宣布他们准备使用哪些中断线，然后协商一个最终的值以尽可能减少冲突，该过程一旦完成，每个中断处理程序都会通过访问设备的某个IO端口函数来读取所分配的IRQ</li>
</ul>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>对于每一个外设的IRQ都用 struct irq_desc 来描述，我们称之中断描述符（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=struct&amp;spm=1001.2101.3001.7020">struct</a> irq_desc）。linux kernel中会有一个数据结构保存了关于所有IRQ的中断描述符信息，我们称之中断描述符DB（上图中红色框图内）。当发生中断后，首先获取触发中断的HW interupt ID，然后通过irq domain翻译成IRQ number，然后通过IRQ number就可以获取对应的中断描述符</p>
<h4 id="中断描述符-1"><a href="#中断描述符-1" class="headerlink" title="中断描述符"></a>中断描述符</h4><p>通用中断处理模块可以用一个线性的table来管理一个个的外部中断，这个表的每个元素就是一个irq描述符，在kernel中定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> irq_desc<span class="token punctuation">[</span>NR_IRQS<span class="token punctuation">]</span> __cacheline_aligned_in_smp <span class="token operator">=</span> <span class="token punctuation">&#123;</span> 
  <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> NR_IRQS<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> 
      <span class="token punctuation">.</span>handle_irq    <span class="token operator">=</span> handle_bad_irq<span class="token punctuation">,</span> 
      <span class="token punctuation">.</span>depth        <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> 
      <span class="token punctuation">.</span>lock        <span class="token operator">=</span> <span class="token function">__RAW_SPIN_LOCK_UNLOCKED</span><span class="token punctuation">(</span>irq_desc<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">,</span> 
  <span class="token punctuation">&#125;</span> 
<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    系统中每一个连接外设的中断线（irq request line）用一个中断描述符来描述，每一个外设的 interrupt request line 分配一个中断号（irq number），系统中有多少个中断线（或者叫做中断源）就有多少个中断描述符（struct irq_desc）。NR_IRQS定义了该硬件平台IRQ的最大数目。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">irq_desc</span> <span class="token punctuation">&#123;</span> 
  <span class="token keyword">struct</span> <span class="token class-name">irq_data</span>        irq_data<span class="token punctuation">;</span> 
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __percpu    <span class="token operator">*</span>kstat_irqs<span class="token punctuation">;</span>－－－－－－IRQ的统计信息 
  <span class="token class-name">irq_flow_handler_t</span>    handle_irq<span class="token punctuation">;</span>－－－－－－－－流控函数 
  <span class="token keyword">struct</span> <span class="token class-name">irqaction</span>    <span class="token operator">*</span>action<span class="token punctuation">;</span> －－－－－－－－－－－处理函数
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        status_use_accessors<span class="token punctuation">;</span>－－－－－中断描述符的状态，参考IRQ_xxxx 
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        core_internal_state__do_not_mess_with_it<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        depth<span class="token punctuation">;</span>－－－－－－－－－－描述嵌套深度的信息
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        wake_depth<span class="token punctuation">;</span>－－－－－－－－电源管理中的wake up source相关
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        irq_count<span class="token punctuation">;</span> 
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>        last_unhandled<span class="token punctuation">;</span>   
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        irqs_unhandled<span class="token punctuation">;</span> 
  <span class="token class-name">raw_spinlock_t</span>        lock<span class="token punctuation">;</span> 
  <span class="token keyword">struct</span> <span class="token class-name">cpumask</span>        <span class="token operator">*</span>percpu_enabled<span class="token punctuation">;</span>
<span class="token operator">></span>#ifdef CONFIG_SMP 
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cpumask</span>    <span class="token operator">*</span>affinity_hint<span class="token punctuation">;</span>－－－－和irq affinity相关，后续单独文档描述 
  <span class="token keyword">struct</span> <span class="token class-name">irq_affinity_notify</span> <span class="token operator">*</span>affinity_notify<span class="token punctuation">;</span> 
<span class="token operator">></span>#ifdef CONFIG_GENERIC_PENDING_IRQ 
  <span class="token class-name">cpumask_var_t</span>        pending_mask<span class="token punctuation">;</span> 
<span class="token operator">></span>#endif 
<span class="token operator">></span>#endif 
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>        threads_oneshot<span class="token punctuation">;</span> 
  <span class="token class-name">atomic_t</span>        threads_active<span class="token punctuation">;</span> 
  <span class="token class-name">wait_queue_head_t</span>       wait_for_threads<span class="token punctuation">;</span> 
<span class="token operator">></span>#ifdef CONFIG_PROC_FS 
  <span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span>    <span class="token operator">*</span>dir<span class="token punctuation">;</span>－－－－－－－－该IRQ对应的proc接口 
<span class="token operator">></span>#endif 
  <span class="token keyword">int</span>            parent_irq<span class="token punctuation">;</span> 
  <span class="token keyword">struct</span> <span class="token class-name">module</span>        <span class="token operator">*</span>owner<span class="token punctuation">;</span> 
  <span class="token keyword">const</span> <span class="token keyword">char</span>        <span class="token operator">*</span>name<span class="token punctuation">;</span> 
<span class="token operator">></span><span class="token punctuation">&#125;</span> ____cacheline_internodealigned_in_smp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="响应函数-irqaction-1"><a href="#响应函数-irqaction-1" class="headerlink" title="响应函数 irqaction"></a>响应函数 irqaction</h4><p>在 irq_desc 中，struct irqaction <em>action,主要是用来存用户注册的中断处理函数,一个中断可以有多个处理函数 ,当一个中断有多个处理函数,说明这个是共享中断。所谓<em>*共享中断</em></em>就是一个中断的来源有很多,这些来源共享同一个引脚。所以在irq_desc结构体中的action成员是个链表,以action为表头,若是一个以上的链表就是共享中断</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token punctuation">&#123;</span>
       <span class="token class-name">irq_handler_t</span> handler<span class="token punctuation">;</span>      <span class="token comment">//等于用户注册的中断处理函数,中断发生时就会运行这个中断处理函数</span>
       <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>         <span class="token comment">//中断标志,注册时设置,比如上升沿中断，下降沿中断等</span>
       <span class="token class-name">cpumask_t</span> mask<span class="token punctuation">;</span>           <span class="token comment">//中断掩码</span>
       <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>          <span class="token comment">//中断名称,产生中断的硬件的名字</span>
       <span class="token keyword">void</span> <span class="token operator">*</span>dev_id<span class="token punctuation">;</span>              <span class="token comment">//设备id</span>
       <span class="token keyword">struct</span> <span class="token class-name">irqaction</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>        <span class="token comment">//指向下一个成员</span>
       <span class="token keyword">int</span> irq<span class="token punctuation">;</span>                    <span class="token comment">//中断号,</span>
       <span class="token keyword">struct</span> <span class="token class-name">proc_dir_entry</span> <span class="token operator">*</span>dir<span class="token punctuation">;</span>    <span class="token comment">//指向IRQn相关的/proc/irq/</span>

<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="中断数据-irq-data-1"><a href="#中断数据-irq-data-1" class="headerlink" title="中断数据 irq_data"></a>中断数据 irq_data</h4><p>中断描述符中应该会包括底层irq chip相关的数据结构，linux kernel中把这些数据组织在一起，形成struct irq_data，具体代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token punctuation">&#123;</span> 
  u32            mask<span class="token punctuation">;</span>－－－－－－－－－－TODO 
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        irq<span class="token punctuation">;</span>－－－－－－－－IRQ number 
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>        hwirq<span class="token punctuation">;</span>－－－－－－－HW interrupt ID 
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        node<span class="token punctuation">;</span>－－－－－－－NUMA node index 
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>        state_use_accessors<span class="token punctuation">;</span>－－－－－－－－底层状态，参考IRQD_xxxx 
  <span class="token keyword">struct</span> <span class="token class-name">irq_chip</span>        <span class="token operator">*</span>chip<span class="token punctuation">;</span>－－－－－－－－－－该中断描述符对应的irq chip数据结构 
  <span class="token keyword">struct</span> <span class="token class-name">irq_domain</span>    <span class="token operator">*</span>domain<span class="token punctuation">;</span>－－－－－－－－该中断描述符对应的irq domain数据结构 
  <span class="token keyword">void</span>            <span class="token operator">*</span>handler_data<span class="token punctuation">;</span>－－－－－－－－和外设specific handler相关的私有数据 
  <span class="token keyword">void</span>            <span class="token operator">*</span>chip_data<span class="token punctuation">;</span>－－－－－－－－－和中断控制器相关的私有数据 
  <span class="token keyword">struct</span> <span class="token class-name">msi_desc</span>        <span class="token operator">*</span>msi_desc<span class="token punctuation">;</span> 
  cpumask_var_t        affinity<span class="token punctuation">;</span>－－－－－－－和irq affinity相关 
<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="操作合集-irq-chip-1"><a href="#操作合集-irq-chip-1" class="headerlink" title="操作合集 irq_chip"></a>操作合集 irq_chip</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token keyword">struct</span> <span class="token class-name">irq_chip</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span>    <span class="token operator">*</span>name<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span>    <span class="token punctuation">(</span><span class="token operator">*</span>irq_startup<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>初始化中断
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_shutdown<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>结束中断
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_enable<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>使能中断
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_disable<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>关闭中断

  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_ack<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>应答中断
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_mask<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>屏蔽中断
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_mask_ack<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>应答并屏蔽中断
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_unmask<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>解除中断屏蔽
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_eoi<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>发送EOI信号，表示硬件中断处理已经完成。

  <span class="token keyword">int</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_set_affinity<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cpumask</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> bool force<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>绑定中断到某个CPU
  <span class="token keyword">int</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_retrigger<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>重新发送中断到CPU
  <span class="token keyword">int</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_set_type<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flow_type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>设置触发类型
  <span class="token keyword">int</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_set_wake<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> on<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>使能<span class="token operator">/</span>关闭中断在电源管理中的唤醒功能。

  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_bus_lock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_bus_sync_unlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_cpu_online<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_cpu_offline<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_suspend<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_resume<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span>        <span class="token punctuation">(</span><span class="token operator">*</span>irq_pm_shutdown<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">irq_data</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span>    flags<span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="软中断，Tasklet和Work-Queue-1"><a href="#软中断，Tasklet和Work-Queue-1" class="headerlink" title="软中断，Tasklet和Work Queue"></a>软中断，<code>Tasklet</code>和<code>Work Queue</code></h2><p>​    由内核执行的几个任务之间有一些不是紧急的，他们可以被延缓一段时间！把可延迟的中断从中断处理程序中抽出来，有利于使得内核保持较短的响应时间，所以我们现在使用以下面的这些结构，来把这样的非紧急的中断处理函数抽象出来！下面列出还在使用三个的机制：</p>
<blockquote>
<p><strong>软中断（softirq）</strong>：内核2.3引入，是最基本、最优先的软中断处理形式，为了避免名字冲突，本文中将这种子类型的软中断叫softirq。</p>
<p><strong>tasklet</strong>：其底层使用softirq机制实现，提供了一种用户方便使用的软中方式，为软中断提供了很好的扩展性。（封装了soft_irq）</p>
<p><strong>work queue</strong>：前两种软中断执行时是禁止抢占的（softirq的ksoftirq除外），对于用户进程不友好。如果在softirq执行时间过长，会继续推后到work queue中执行，work queue执行处于进程上下文，其可被抢占，也可以被调度，如果软中断需要执行睡眠、阻塞，直接选择work queue。</p>
</blockquote>
<h3 id="软中断-1"><a href="#软中断-1" class="headerlink" title="软中断"></a>软中断</h3><p>前已注册的软中断有10种，定义为一个全局数组：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> softirq_vec<span class="token punctuation">[</span>NR_SOFTIRQS<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token operator">></span><span class="token keyword">enum</span> <span class="token punctuation">&#123;</span>
  HI_SOFTIRQ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">/* 优先级高的tasklets */</span>
  TIMER_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 定时器的下半部 */</span>
  NET_TX_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 发送网络数据包 */</span>
  NET_RX_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 接收网络数据包 */</span>
  BLOCK_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* BLOCK装置 */</span>
  BLOCK_IOPOLL_SOFTIRQ<span class="token punctuation">,</span>
  TASKLET_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 正常优先级的tasklets */</span>
  SCHED_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 调度程序 */</span>
  HRTIMER_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* 高分辨率定时器 */</span>
  RCU_SOFTIRQ<span class="token punctuation">,</span> <span class="token comment">/* RCU锁定 */</span>
  NR_SOFTIRQS <span class="token comment">/* 10 */</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（2）注册软中断处理函数</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token comment">/**
>* @nr: 软中断的索引号
>* @action: 软中断的处理函数
>*/</span>
<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">open_softirq</span><span class="token punctuation">(</span><span class="token keyword">int</span> nr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>action<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">softirq_action</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
  softirq_vec<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">.</span>action <span class="token operator">=</span> action<span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token function">open_softirq</span><span class="token punctuation">(</span>NET_TX_SOFTIRQ<span class="token punctuation">,</span> net_tx_action<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token function">open_softirq</span><span class="token punctuation">(</span>NET_RX_SOFTIRQ<span class="token punctuation">,</span> net_rx_action<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>（3）触发软中断</strong></p>
<p>调用raise_softirq()来触发软中断。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">raise_softirq</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
  <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">raise_softirq_irqoff</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span>

<span class="token operator">></span><span class="token comment">/* This function must run with irqs disabled */</span>
<span class="token operator">></span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">rasie_softirq_irqsoff</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> nr<span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
  <span class="token function">__raise_softirq_irqoff</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">/* If we're in an interrupt or softirq, we're done
   * (this also catches softirq-disabled code). We will
   * actually run the softirq once we return from the irq
   * or softirq.
   * Otherwise we wake up ksoftirqd to make sure we
   * schedule the softirq soon.
   */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">in_interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">/* 如果不处于硬中断或软中断 */</span>
      <span class="token function">wakeup_softirqd</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 唤醒ksoftirqd/n进程 */</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Percpu变量irq_cpustat_t中的__softirq_pending是等待处理的软中断的位图，通过设置此变量即可告诉内核该执行哪些软中断。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">></span><span class="token keyword">static</span> inline <span class="token keyword">void</span> <span class="token function">__rasie_softirq_irqoff</span><span class="token punctuation">(</span>unsigned int nr<span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
  <span class="token function">trace_softirq_raise</span><span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">or_softirq_pending</span><span class="token punctuation">(</span>1UL <span class="token operator">&lt;&lt;</span> nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span>

<span class="token operator">></span>typedef struct <span class="token punctuation">&#123;</span>
  unsigned int __softirq_pending<span class="token punctuation">;</span>
  unsigned int __nmi_count<span class="token punctuation">;</span> <span class="token comment">/* arch dependent */</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span> irq_cpustat_t<span class="token punctuation">;</span>

<span class="token operator">></span>irq_cpustat_t irq_stat<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token operator">></span>#define <span class="token function">__IRQ_STAT</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> member<span class="token punctuation">)</span> <span class="token punctuation">(</span>irq_stat<span class="token punctuation">[</span>cpu<span class="token punctuation">]</span><span class="token punctuation">.</span>member<span class="token punctuation">)</span>
<span class="token operator">></span>#define <span class="token function">or_softirq_pending</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">percpu_or</span><span class="token punctuation">(</span>irq_stat<span class="token punctuation">.</span>__softirq_pending<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">></span>#define <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">percpu_read</span><span class="token punctuation">(</span>irq_stat<span class="token punctuation">.</span>__softirq_pending<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>唤醒ksoftirqd内核线程处理软中断。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">wakeup_softirqd</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
  <span class="token comment">/* Interrupts are disabled: no need to stop preemption */</span>
  struct task_struct <span class="token operator">*</span>tsk <span class="token operator">=</span> <span class="token function">__get_cpu_var</span><span class="token punctuation">(</span>ksoftirqd<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>tsk <span class="token operator">&amp;&amp;</span> tsk<span class="token operator">-</span><span class="token operator">></span>state <span class="token operator">!=</span> <span class="token constant">TASK_RUNNING</span><span class="token punctuation">)</span>
      <span class="token function">wake_up_process</span><span class="token punctuation">(</span>tsk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在下列地方，待处理的软中断会被检查和执行：</p>
<p>a. 从一个硬件中断代码处返回时</p>
<p>b. 在ksoftirqd内核线程中</p>
<p>c. 在那些显示检查和执行待处理的软中断的代码中，如网络子系统中</p>
<p>而不管是用什么方法唤起，软中断都要在do_softirq()中执行。如果有待处理的软中断，do_softirq()会循环遍历每一个，调用它们的相应的处理程序。</p>
<p>在中断处理程序中触发软中断是最常见的形式。中断处理程序执行硬件设备的相关操作，然后触发相应的软中断，最后退出。内核在执行完中断处理程序以后，马上就会调用do_softirq()，于是软中断开始执行中断处理程序完成剩余的任务。</p>
<p>下面来看下do_softirq()的具体实现。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">></span>asmlinkage <span class="token keyword">void</span> <span class="token function">do_softirq</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
  __u32 pending<span class="token punctuation">;</span>
  unsigned long flags<span class="token punctuation">;</span>

  <span class="token comment">/* 如果当前已处于硬中断或软中断中，直接返回 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
      <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token function">local_irq_save</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  pending <span class="token operator">=</span> <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pending<span class="token punctuation">)</span> <span class="token comment">/* 如果有激活的软中断 */</span>
      <span class="token function">__do_softirq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 处理函数 */</span>
  <span class="token function">local_irq_restore</span><span class="token punctuation">(</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">></span><span class="token comment">/* We restart softirq processing MAX_SOFTIRQ_RESTART times,
>* and we fall back to softirqd after that.
>* This number has been established via experimentation.
>* The two things to balance is latency against fairness - we want
>* to handle softirqs as soon as possible, but they should not be
>* able to lock up the box.
>*/</span>
<span class="token operator">></span>asmlinkage <span class="token keyword">void</span> <span class="token function">__do_softirq</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
  struct softirq_action <span class="token operator">*</span>h<span class="token punctuation">;</span>
  __u32 pending<span class="token punctuation">;</span>
  <span class="token comment">/* 本函数能重复触发执行的次数，防止占用过多的cpu时间 */</span>
  int max_restart <span class="token operator">=</span> <span class="token constant">MAX_SOFTIRQ_RESTART</span><span class="token punctuation">;</span>
  int cpu<span class="token punctuation">;</span>

  pending <span class="token operator">=</span> <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 激活的软中断位图 */</span>
  <span class="token function">account_system_vtime</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* 本地禁止当前的软中断 */</span>
  <span class="token function">__local_bh_disable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>unsigned long<span class="token punctuation">)</span><span class="token function">__builtin_return_address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">SOFTIRQ_OFFSET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">lockdep_softirq_enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* current->softirq_context++ */</span>
  cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 当前cpu编号 */</span>

<span class="token operator">></span>restart<span class="token operator">:</span>
  <span class="token comment">/* Reset the pending bitmask before enabling irqs */</span>
  <span class="token function">set_softirq_pending</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 重置位图 */</span>
  <span class="token function">local_irq_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  h <span class="token operator">=</span> softirq_vec<span class="token punctuation">;</span>
  <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          unsigned int vec_nr <span class="token operator">=</span> h <span class="token operator">-</span> softirq_vec<span class="token punctuation">;</span> <span class="token comment">/* 软中断索引 */</span>
          int prev_count <span class="token operator">=</span> <span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">kstat_incr_softirqs_this_cpu</span><span class="token punctuation">(</span>vec_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token function">trace_softirq_entry</span><span class="token punctuation">(</span>vec_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>
          h<span class="token operator">-</span><span class="token operator">></span><span class="token function">action</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 调用软中断的处理函数 */</span>
          <span class="token function">trace_softirq_exit</span><span class="token punctuation">(</span>vec_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>prev_count <span class="token operator">!=</span> <span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
              <span class="token function">printk</span><span class="token punctuation">(</span><span class="token constant">KERN_ERR</span> <span class="token string">"huh, entered softirq %u %s %p"</span> <span class="token string">"with preempt_count %08x,"</span>
                  <span class="token string">"exited with %08x?\n"</span><span class="token punctuation">,</span> vec_nr<span class="token punctuation">,</span> softirq_to_name<span class="token punctuation">[</span>vec_nr<span class="token punctuation">]</span><span class="token punctuation">,</span> h<span class="token operator">-</span><span class="token operator">></span>action<span class="token punctuation">,</span> prev_count<span class="token punctuation">,</span>
                  <span class="token function">preempt_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">&#125;</span>
          <span class="token function">rcu_bh_qs</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      h<span class="token operator">++</span><span class="token punctuation">;</span>
      pending <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>pending<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">local_irq_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  pending <span class="token operator">=</span> <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">&amp;</span> <span class="token operator">--</span>max_restart<span class="token punctuation">)</span> <span class="token comment">/* 重复触发 */</span>
      goto restart<span class="token punctuation">;</span>

  <span class="token comment">/* 如果重复触发了10次了，接下来唤醒ksoftirqd/n内核线程来处理 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pending<span class="token punctuation">)</span>
      <span class="token function">wakeup_softirqd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

  <span class="token function">lockdep_softirq_exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">account_system_vtime</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">__local_bh_enable</span><span class="token punctuation">(</span><span class="token constant">SOFTIRQ_OFFSET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>（4）ksoftirqd内核线程</strong></p>
<p>​    内核不会立即处理重新触发的软中断。当大量软中断出现的时候，内核会唤醒一组内核线程来处理。这些线程的优先级最低(nice值为19)，这能避免它们跟其它重要的任务抢夺资源。但它们最终肯定会被执行，所以这个折中的方案能够保证在软中断很多时用户程序不会因为得不到处理时间而处于饥饿状态，同时也保证过量的软中断最终会得到处理。</p>
<p>每个处理器都有一个这样的线程，名字为ksoftirqd/n，n为处理器的编号。</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">></span><span class="token keyword">static</span> int <span class="token function">run_ksoftirqd</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>__bind_cpu<span class="token punctuation">)</span>
<span class="token operator">></span><span class="token punctuation">&#123;</span>
  <span class="token function">set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_INTERRUPTIBLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  current<span class="token operator">-</span><span class="token operator">></span>flags <span class="token operator">|=</span> <span class="token constant">PF_KSOFTIRQD</span><span class="token punctuation">;</span> <span class="token comment">/* I am ksoftirqd */</span>

  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">kthread_should_stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 如果没有要处理的软中断 */</span>
          <span class="token function">preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
      <span class="token punctuation">&#125;</span>

      <span class="token function">__set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_RUNNING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">local_softirq_pending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token comment">/* Preempt disable stops cpu going offline.
           * If already offline, we'll be on wrong CPU: don't process.
           */</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">cpu_is_offline</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>__bind_cpu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">/* 被要求释放cpu */</span>
               goto wait_to_die<span class="token punctuation">;</span>

          <span class="token function">do_softirq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 软中断的统一处理函数 */</span>

          <span class="token function">preempt_enable_no_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">cond_resched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token function">rcu_note_context_switch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>long<span class="token punctuation">)</span>__bind_cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>

      <span class="token function">preempt_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_INTERRUPTIBLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token function">__set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_RUNNING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token operator">></span>wait_to_die<span class="token operator">:</span>
  <span class="token function">preempt_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* Wait for kthread_stop */</span>
  <span class="token function">set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_INTERRUPTIBLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">kthread_should_stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_INTERRUPTIBLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token function">__set_current_state</span><span class="token punctuation">(</span><span class="token constant">TASK_RUNNING</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">></span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Tasklet-API-1"><a href="#Tasklet-API-1" class="headerlink" title="Tasklet API"></a>Tasklet API</h3><p>动态初始化函数：</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;void tasklet_init(struct tasklet_struct *t,void (*func)(unsigned long), unsigned long data)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><code>t: struct tasklet_struct</code> 结构指针</li>
<li><code>func</code>：小任务函数</li>
<li><code>data</code>：传递给工作函数的实际参数</li>
</ul>
<p>静态初始化：静态初始化DECLARE_TASKLET(name, func, data)，定义一个名字为 name 的结构变量 ，并且使用 func,data对结构进行初始化，这个宏定义的 tasklet 是可调度的。静态初始化DECLARE_TASKLET_DISABLED(name, func, data)和DECLARE_TASKLET(name, func, data)，不同是它开始不能被调度。必须先把 count 设置为0,才可以调度</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;name：struct tasklet_struct的名字
&gt;func：tasklet函数指针
&gt;data：传递给func函数的参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>激活/取消激活 tasklet  </p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">&gt;void tasklet_disable(struct tasklet_struct *t)   &#x2F;&#x2F; 把 count 设置为1
&gt;void tasklet_enable (struct tasklet_struct *t)   &#x2F;&#x2F; 把count 设置为0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>调度函数</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">&gt;void  tasklet_schedule (struct tasklet_struct *t)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>调度某个指定的tasklet小任务，调用后tasklet关联的函数会执行.一旦执行，则会在适当时候去执行 tasklet_struct 绑定的函数。对同一个 struct tasklet_struct 连续调度多次，效果等同一次（前提条件：当前一次调用，绑定函数还没有执行）。</p>
<p>5）kill掉函数（取消任务）</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;tasklet_kill(struct tasklet_struct *t);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>6） tasklet和普通工作队列区别：</p>
<p>它所绑定的函数不能休眠</p>
<p>它的响应速度高于普通工作队列。</p>
<hr>
<h3 id="tasklet-微线程的编程步骤：-1"><a href="#tasklet-微线程的编程步骤：-1" class="headerlink" title="tasklet 微线程的编程步骤："></a><strong>tasklet 微线程的编程步骤：</strong></h3><p>taskle 内核机制实现过程是非常复杂的，但是对于驱动开发者来说，重点是掌握如果使用内核已经给我们实现好的tasklet机制。tasklet编程其实只有简单的几步，下面我们总结一下tasklet机制的编程步骤。</p>
<p><strong>1. 定义tasklet 工作函数</strong></p>
<p><strong>2. 定义tasklet 结构变量</strong></p>
<p>定义分有静态定义和动态定义两种方式：</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;&#x2F;&#x2F; 动态定义：
&gt;struct tasklet_struct my_tasklet;
&gt;&#x2F;&#x2F; 静态定义：
&gt;DECLARE_TASKLET(my_tasklet, my_tasklet_function, data);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3. 初始化tasklet结构，绑定工作函数</strong></p>
<p>如果上一步是采用静态定义，则这一步不用再做，跳过。如果是采用动态定义tasklet，则使用tasklet_init()函数进行初始化以及绑定。</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;tasklet_init(&amp;my_tasklet, my_tasklet_function, data)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>4. 在适当的地方调度工作函数</strong></p>
<p>tasklet一般是用于处理中断的下半部的，所以<strong>一般在中断的上半部调度</strong>tasklet工作函数。</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;tasklet_schedule(&amp;my_tasklet);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>5. 销毁tasklet工作任务</strong></p>
<p>在确定不再使用tasklet时，应该在适当的地方调用tasklet_kill()函数销毁tasklet任务，释放资源，这个适当的地方一般的tasklet初始化地方是相反的，比如，如果是在模块初始化函数初始化了tasklet,则相应地是在模块卸载函数调用tasklet_kill函数来销毁tasklet任务。</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;tasklet_kill(&amp;my_tasklet);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="从中断和异常返回-1"><a href="#从中断和异常返回-1" class="headerlink" title="从中断和异常返回"></a>从中断和异常返回</h3><p><img src=".\image-20240501110101822.png" alt="image-20240501110101822"></p>
<p>​    我们用《深入理解Linux内核》的一张大图来收尾。</p>
<p>​    我们的ret_from_intr和ret_from_exception本质上等价于：</p>
<p><strong>入口点</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&gt;ret_from_exception:
cli    &#x2F;&#x2F; 只有从异常返回时才使用 cli，禁用本地中断
&gt;ret_from_intr:
movl $-8192, %ebp  &#x2F;&#x2F; 将当前 thread_info 描述符的地址装载到 ebp 寄存器
andl %esp, %ebp
movl 0x30(%esp), %eax
movb 0x2c(%esp), %al

&#x2F;&#x2F; 根据发生中断或异常压入栈中的 cs 和 eflags 寄存器的值，
&#x2F;&#x2F; 确定中断的程序在中断时是否运行在用户态
testl $0x0002003, %eax  
jnz resume_userspace
jpm resume_kernel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>恢复内核控制路径</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&gt;rusume_kernel:
cli
cmpl $0, 0x14(%ebp)  &#x2F;&#x2F; 如果 thread_info 描述符的 preempt_count 字段为0（运行内核抢占）
jz need_resched      &#x2F;&#x2F; 跳到 need_resched
&gt;restore_all:       &#x2F;&#x2F; 否则，被中断的程序重新开始执行
popl %ebx
popl %ecx
popl %edx
popl %esi
popl %edi
popl %ebp
popl %eax
popl %ds
popl %es
addl $4, %esp
iret   &#x2F;&#x2F; 结束控制<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>检查内核抢占</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&gt;need_resched:
movl 0x8(%ebp), %ecx
testb $(1&lt;&lt;TIF_NEED_RESCHED), %cl  &#x2F;&#x2F; 如果 current-&gt;thread_info 的 flags 字段中的 TIF_NEED_RESCHED &#x3D;&#x3D; 0，没有需要切换的进程
jz restore_all                     &#x2F;&#x2F; 因此跳到 restore_all
testl $0x00000200, 0x30(%ebp)      &#x2F;&#x2F; 如果正在被恢复的内核控制路径是在禁用本地 CPU 的情况下运行
jz restore_all                     &#x2F;&#x2F; 也跳到 restore_all，否则进程切换可能回破坏内核数据结构
call preempt_schedule_irq          &#x2F;&#x2F; 进程切换，设置 preempt_count 字段的 PREEMPT_ACTIVE 标志，大内核锁计数器暂时设置为 -1，调用 schedule()
jmp need_resched <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>恢复用户态程序</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&gt;resume_userspace:
cli  &#x2F;&#x2F; 禁用本地中断
movl 0x8(%ebp), %ecx

&#x2F;&#x2F; 检测 current-&gt;thread_info 的 flags 字段，
&#x2F;&#x2F; 如果只设置了 TIF_SYSCALL_TRACE，TIF_SYSCALL_AUDIT 或 TIF_SINGLESTEP 标志，
&#x2F;&#x2F; 跳到 restore_all
andl $0x0000ff6e, %ecx
je restore_all
jmp work_pending<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>检测重调度标志</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&gt;work_pending:
testb $(1&lt;&lt;TIF_NEED_RESCHED), %cl
jz work_notifysig
&gt;work_resched:
call schedule  &#x2F;&#x2F; 如果进程切换请求被挂起，选择另外 一个进程运行
cli
jmp resume_userspace  &#x2F;&#x2F; 当前面的进程要恢复时<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>处理挂起信号、虚拟 8086 模式和单步执行</strong></p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&gt;work_notifysig:
movl %esp, %eax
testl $0x00020000, 0x30(%esp)
je 1f

&gt;&#x2F;&#x2F; 如果用户态程序 eflags 寄存器的 VM 控制标志被设置
&gt;work_notifysig_v86:
pushl %ecx
call save_v86_state    &#x2F;&#x2F; 在用户态地址空间建立虚拟8086模式的数据结构
popl %ecx
movl %eax, %esp
&gt;1:
xorl %edx, %edx
call do_notify_resume  &#x2F;&#x2F; 处理挂起信号和单步执行
jmp restore_all        &#x2F;&#x2F; 恢复被中断的程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="Reference-3"><a href="#Reference-3" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/450293200">80x86中断 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2072999">Linux内核19-中断描述符表IDT的初始化-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhoutaopower/article/details/90648475">Linux 中断 —— GIC (数据结构 irq_domain/irq_desc/irq_data/irq_chip/irqaction)_irq_data、irq_chip、irq_domain和irq_desc-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1518703">Linux内核硬中断 / 软中断的原理和实现-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010299133/article/details/100177713">linux内核之tasklet使用_tasklet 改绑定-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012319493/article/details/83315423">深入理解 Linux 内核—-中断和异常_ret_from_exception-CSDN博客</a></p>
</blockquote>
</blockquote>
<h1 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h1><p>​    嗯，我们下面来聊聊内核同步的话题，内核同步是为了解决内核异步抢占而产生的。</p>
<h2 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h2><p>​    在Linux中内核抢占比较复杂：</p>
<ul>
<li>无论在抢占内核还是在非抢占内核，，运行在内核态的程序都可以自动放弃CPU，比如说：其原因可能是竞争，由于等待资源，而不得不进入睡眠状态。往往把这种状态称为计划性进程切换，但是抢占式内核在响应引起进程切换的异步事件，例如说唤醒高优先级进程的中断处理程序的方式上，与非抢占的内核是有差别的。我们把这种进程切换称之为强制性的进程切换</li>
<li>所有的进程切换都由宏：switch_to来完成，在抢占式的内核和非抢占式的内核中，当进程的执行完某一些具有内核功能的线程，而且调度程序被调度后，就会发生进程切换！不过在非抢占内核中，当前进程是不可能被替换！除非他打算换到用户态上去！</li>
</ul>
<p>​    因此抢占式内核的主要特点：是一个在内核态运行的进程可能在执行内核函数期间被另一个进程取代！</p>
<p>​    在Linux中当被<code>current thread info</code>宏所引用的<code>thread_info</code>描述符的preempt_count字段大于零时，就会禁止内核抢占他！</p>
<p>​    在如下任何一种情况发生时，取值都大于零：</p>
<blockquote>
<ol>
<li>内核正在执行内中断服务例程</li>
<li>可延迟函数被禁止</li>
<li>通过把抢占计数器设置为正数而显示的禁用内核抢占</li>
</ol>
</blockquote>
<p>​    上面的原则告诉我们只有当内核正在执行异常处理程序，而且内核抢占没有被显式地禁用的时候，才会抢占内核</p>
<p>​    那么什么时候同步是必须的呢：我们之前就有提到过刚计算的结果依赖于两个或两个以上的交叉内核控制路径的嵌套方式时，才有可能会引起竞争！（说白了就是两个执行流撞在一起，有多个进程同时执行同一段代码），临界区是一段代码，在其他的内核控制路径能够进入临界区前，进入临界区的内核控制路径必须全部执行完！这段临界区的代码交叉内核控制路径使内核开发的工作者变得复杂，他们必须小心地识别出异常处理程序，中断处理程序，可延迟函数和内核进程中的临界区。一旦临界区被确定，就必须对其采取一定的保护措施</p>
<p>​    那么什么时候同步是不必要的呢：</p>
<ul>
<li>所有中断处理程序响应来自pic的中断并且禁用了IRQ线，此外在中断处理程序的结束之前不允许产生相同的中断事件！</li>
<li>中断处理程序，软中断，tasklet既不可以被抢占也不可能被阻塞，所以他们不可能长时间的处于挂起状态！即使在最坏的情况下它们的执行也只是有轻微的延迟，因为在其执行的过程中可能会发生其他中断执行！</li>
<li>中断处理的内核控制路径不能被执行可延迟函数，或系统调用服务例程的内核控制路径所中断</li>
<li>软中断和tasklet不能在一个给定的CPU上交错执行</li>
<li>同一个tasklet不可能同时在几个CPU上执行！</li>
</ul>
<p>​    以上的每一种设计选择都可以看作是一种约束，下面是一些可能简化了的例子</p>
<blockquote>
<ul>
<li>已中断处理程序和tasklet不必编写成可重入的函数</li>
<li>仅被软中断和task light访问的每CPU变量并不需要同步</li>
<li>仅被一种tasklet访问的数据结构是不需要同步的</li>
</ul>
</blockquote>
<h2 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h2><p>下面来看看同步原语，内核中使用的同步技术</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>技术</th>
<th>说明</th>
<th>适用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>每CPU变量</td>
<td>在CPU中复制数据结构</td>
<td>所有CPU</td>
</tr>
<tr>
<td>原子操作</td>
<td>对一个计数器原子的读修改写的指令</td>
<td>所有CPU</td>
</tr>
<tr>
<td>内存屏障</td>
<td>避免指令重新排序</td>
<td>本地CPU或者所有CPU</td>
</tr>
<tr>
<td>自旋锁</td>
<td>加锁时忙等待</td>
<td>所有CPU</td>
</tr>
<tr>
<td>信号量</td>
<td>加锁是阻塞等待（睡眠）</td>
<td>所有CPU</td>
</tr>
<tr>
<td>顺序锁</td>
<td>基于访问计数器的锁</td>
<td>所有CPU</td>
</tr>
<tr>
<td>本地中断的禁止</td>
<td>禁止单个CPU上的中断处理</td>
<td>本地CPU</td>
</tr>
<tr>
<td>本地软中断的禁止</td>
<td>禁止单个CPU上的可延迟函数处理</td>
<td>本地CPU</td>
</tr>
<tr>
<td>RCU</td>
<td>通过指针而不是锁来访问共享数据结构</td>
<td>所有CPU</td>
</tr>
</tbody>
</table>
</div>
<h3 id="per-CPU变量"><a href="#per-CPU变量" class="headerlink" title="per-CPU变量"></a>per-CPU变量</h3><p>​    最好的同步技术就是把不需要同步的内核放在首位正如我们将要看到事实上每一种显示的同步原语都会有不容忽视的性能开销最简单也是最重要的同步技术包括把内核变量声明为每CPU变量每CPU变量主要是数据结构的数组系统的每个CPU都对应数组的一个元素一个CPU不应该访问其他CPU对应的数组元素另外它可以随意读或修改他们自己的元素而不必担心竞争条件因为这是他唯一有资格这么做的CPU但是这也意味着每CPU变量基本上只能在特殊情况下才能够使用也就是当他确定这个系统上的CPU上的数据的逻辑上是独立的此外在单处理器和多处理器系统中内核抢占都可能会使每cpu变量产生竞争条件总的原则是内核控制路径应该禁用抢占的情况下去访问每cpu变量</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>为每个CPU定义一个变量的拷贝的宏定义在文件<code>include/linux/percpu-defs.h</code>中，如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEFINE_PER_CPU</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">,</span> name<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">DEFINE_PER_CPU_SECTION</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> name<span class="token punctuation">,</span> </span><span class="token string">""</span><span class="token expression"><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>若我们使用<code>DEFINE_PER_CPU(int, per_cpu_n)</code>为每个CPU定义变量，其展开宏如下。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">section</span><span class="token punctuation">(</span><span class="token string">".data..percpu"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">int</span> per_cpu_n

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEFINE_PER_CPU_SECTION</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">,</span> name<span class="token punctuation">,</span> sec<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">__PCPU_ATTRS</span><span class="token punctuation">(</span>sec<span class="token punctuation">)</span> <span class="token function">__typeof__</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> name</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__PCPU_ATTRS</span><span class="token expression"><span class="token punctuation">(</span>sec<span class="token punctuation">)</span>                        </span><span class="token punctuation">\</span>
    <span class="token expression">__percpu <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">section</span><span class="token punctuation">(</span>PER_CPU_BASE_SECTION sec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    </span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PER_CPU_BASE_SECTION</span> <span class="token string">".data..percpu"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在链接过程中，所有通过<code>DEFINE_PER_CPU</code>宏定义的变量都将链接到一起。在操作系统启动时，Linux 将为该段分配一段内存。 查看编译出的内核镜像可找到<code>.data..percpu</code>段</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text"># readelf -S vmlinux
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [21] .data..percpu     PROGBITS         0000000000000000  01000000
       000000000001d000  0000000000000000  WA       0     0     4096<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>per CPU 变量的访问通过宏<code>get_cpu_var</code>完成 。Linux内核是可抢占的，并且在访问访问 per cpu变量时我们需要知道当前代码运行在哪个CPU核上。 因此，在访问每个cpu变量时，应当不允许抢占当前代码并将其移至另一个CPU。例如，若在获取到 CPU id 为 1 后，该任务被抢占而移动到了 CPU 2上继续运行，这时访问的将仍然是 CPU 1的per cpu 变量。因此，在 <code>get_cpu_var</code> 宏中，首先要调用<code>preempt_disable()</code>函数禁止任务抢占。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// in  include/linux/percpu-defs.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">get_cpu_var</span><span class="token expression"><span class="token punctuation">(</span>var<span class="token punctuation">)</span>                        </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                                    </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">this_cpu_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>var<span class="token punctuation">)</span><span class="token punctuation">;</span>                        </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我比较好奇的是 <code>this_cpu_ptr</code>是如何实现的。内核如何将该变量对应到属于该CPU的 per CPU 变量内存呢？</p>
<p>在初始化时，内核会使用一个数组<code>__per_cpu_offset[cpu]</code>记录每个CPU静态per cpu 变量的偏移地址。在ARM64架构下， OS 启动时将 per cpu 偏移地址写入到 TPDIR_EL1 和 TPDIR_EL2 寄存器中。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> __init <span class="token function">setup_per_cpu_areas</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> delta<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    delta <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>pcpu_base_addr <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>__per_cpu_start<span class="token punctuation">;</span>
    <span class="token function">for_each_possible_cpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span>
        __per_cpu_offset<span class="token punctuation">[</span>cpu<span class="token punctuation">]</span> <span class="token operator">=</span> delta <span class="token operator">+</span> pcpu_unit_offsets<span class="token punctuation">[</span>cpu<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/* arch/arm64/include/asm/percpu.h */</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">set_my_cpu_offset</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> off<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token function">ALTERNATIVE</span><span class="token punctuation">(</span><span class="token string">"msr tpidr_el1, %0"</span><span class="token punctuation">,</span>
                 <span class="token string">"msr tpidr_el2, %0"</span><span class="token punctuation">,</span>
                 ARM64_HAS_VIRT_HOST_EXTN<span class="token punctuation">)</span>
            <span class="token operator">::</span> <span class="token string">"r"</span> <span class="token punctuation">(</span>off<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>this_cpu_ptr</code>的宏展开如下：即相当于 percpu 变量指针 ptr 加上__my_cpu_offset。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">arch_raw_cpu_ptr</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token function">SHIFT_PERCPU_PTR</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> __my_cpu_offset<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">raw_cpu_ptr</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>                        </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                                    </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">__verify_pcpu_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">arch_raw_cpu_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">this_cpu_ptr</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span>    <span class="token function">raw_cpu_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>__my_cpu_offset</code>宏即是从当前cpu的<code>tpidr_el1</code>、<code>tpidr_el2</code>寄存器中取出此前设置的__per_cpu_offset[cpu]值，实现如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">__my_cpu_offset</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> off<span class="token punctuation">;</span>

    <span class="token comment">/*
     * We want to allow caching the value, so avoid using volatile and
     * instead use a fake stack read to hazard against barrier().
     */</span>
    <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token function">ALTERNATIVE</span><span class="token punctuation">(</span><span class="token string">"mrs %0, tpidr_el1"</span><span class="token punctuation">,</span>
            <span class="token string">"mrs %0, tpidr_el2"</span><span class="token punctuation">,</span>
            ARM64_HAS_VIRT_HOST_EXTN<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token string">"=r"</span> <span class="token punctuation">(</span>off<span class="token punctuation">)</span> <span class="token operator">:</span>
        <span class="token string">"Q"</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span>current_stack_pointer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> off<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有时会需要指定某个 CPU 获取其某个 per cpu 变量的地址，通过宏<code>per_cpu_ptr</code>实现，源码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SHIFT_PERCPU_PTR</span><span class="token expression"><span class="token punctuation">(</span>__p<span class="token punctuation">,</span> __offset<span class="token punctuation">)</span>                    </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">RELOC_HIDE</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span><span class="token punctuation">)</span> __kernel __force <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>__offset<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">per_cpu_ptr</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span>                        </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>                                    </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">__verify_pcpu_ptr</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>                        </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">SHIFT_PERCPU_PTR</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">per_cpu_offset</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><strong>user，</strong>kernel，<strong>safe，</strong>force等定义在<code>compiler_type.h</code>头文件中。看到两个很奇怪的现象，一个是只有在<strong>CHECKER</strong>宏打开的情况下，他们的定义才会被实现，否则他们的定义是空的。第二个是它们的attribute的定义，并不是gcc支持的属性。那到底是哪里使用到了呢？原来linux的作者们自己开发了一套编译期代码检查的工具Sparse，可以用于在编译阶段快速发现代码中隐含的问题。[1]</p>
</blockquote>
<ul>
<li>address_space 定义了指针能指向的内存的类型，0代表kernel space，1代表user space，2代表设备地址空间，3代表cpu局部的内存空间</li>
<li>safe 表示变量可以为空</li>
<li>force 表示变量可以强制类型转换</li>
</ul>
<h4 id="Per-CPU-变量的应用"><a href="#Per-CPU-变量的应用" class="headerlink" title="Per CPU 变量的应用"></a>Per CPU 变量的应用</h4><p>记录每个CPU 的 id 是 per CPU 变量的应用之一。</p>
<p>那么有了 Per CPU变量之后，如何获得当前执行代码的CPU 编号？ 内核函数<code>smp_processor_id()</code>用来获取当前 CPU 的 id 。</p>
<p>CPU id 的存储依赖于 per CPU 变量（DEFINE_PER_CPU宏用来定义 cpu_number 变量）。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 每个CPU的cpuid是放置在cpu_number这个percpu变量中</span>
<span class="token function">DEFINE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> cpu_number<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在内核初始化时，<code>smp_prepare_cpus()</code>函数执行<code>per_cpu(cpu_number, cpu) = cpu;</code>设定每个核的编号。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// in /arch/arm64/kernel/smp.c</span>
<span class="token keyword">void</span> __init <span class="token function">smp_prepare_cpus</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> max_cpus<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">cpu_operations</span> <span class="token operator">*</span>ops<span class="token punctuation">;</span>
    <span class="token keyword">int</span> err<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> cpu<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> this_cpu<span class="token punctuation">;</span>

    <span class="token function">init_cpu_topology</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    this_cpu <span class="token operator">=</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">for_each_possible_cpu</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 设置 CPU id</span>
        <span class="token function">per_cpu</span><span class="token punctuation">(</span>cpu_number<span class="token punctuation">,</span> cpu<span class="token punctuation">)</span> <span class="token operator">=</span> cpu<span class="token punctuation">;</span>
        <span class="token comment">// 确定在哪个核上执行的，若是本身则跳过。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cpu <span class="token operator">==</span> <span class="token function">smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        ops <span class="token operator">=</span> <span class="token function">get_cpu_ops</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ops<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        err <span class="token operator">=</span> ops<span class="token operator">-></span><span class="token function">cpu_prepare</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>

        <span class="token function">set_cpu_present</span><span class="token punctuation">(</span>cpu<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">numa_store_cpu_info</span><span class="token punctuation">(</span>cpu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>smp_processer_id ()</code>函数(定义在 <code>include/linux/smp.h</code>)展开如下。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name function">smp_processor_id</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">__smp_processor_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__smp_processor_id</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">raw_smp_processor_id</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>raw_smp_processor_id</code>与处理器架构相关（下例为ARM64）的实现如下，<code>raw_cpu_ptr</code> 获取到 cpu_number 的地址，在解引用得到 cpu id。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">raw_smp_processor_id</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">raw_cpu_ptr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cpu_number<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="per-CPU-变量在多文件下的用法"><a href="#per-CPU-变量在多文件下的用法" class="headerlink" title="per CPU 变量在多文件下的用法"></a>per CPU 变量在多文件下的用法</h4><p>声明一个 per cpu 变量并在另一个文件中引用，以获取当前 task_struct 为例（x86下 current 宏的实现）。</p>
<p>定义方式如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DEFINE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span> ____cacheline_aligned <span class="token operator">=</span>
    <span class="token operator">&amp;</span>init_task<span class="token punctuation">;</span>
<span class="token function">EXPORT_PER_CPU_SYMBOL</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在另一个文件中引用方式如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">DECLARE_PER_CPU</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token punctuation">,</span> current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> __always_inline <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">this_cpu_read_stable</span><span class="token punctuation">(</span>current_task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">current</span> <span class="token expression"><span class="token function">get_current</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>​    若干汇编语言指令是具有RCU类型的，也就是说他们访问存储器单元两次！第一次读原值，第二次写新值</p>
<p>​    避免由于RCU指令引起的竞争条件的容易的办法，就是确保这样的操作在芯片级就是原子性的！</p>
<p>​    任何一个这样的操作都必须单个指令进行执行中间，是不允许中断的且避免其他的CPU访问统一存储器单元。这些很小的原子操作可以建立在其他更灵活的机制的基础之上创建临界区</p>
<p>​    让我们根据这样的分类来回顾一下8086的指令：</p>
<p>进行零次或一次对齐内存访问的汇编指令是原子的</p>
<p>如果在读操作之后写操作之前没有其他处理器占用内存总线，那么在从内存中读取数据，更新数据并且把更新后的数据写回内存中的这些RCU汇编语言指令是原子的！当然在单处理器系统中永远不会发生内存总线窃取的情况</p>
<p>操作码前缀是lock字节<code>(0xf0)</code>的汇编语言指令，即使在多处理器系统中，也是原子的！当控制单元检测到这个前缀时，就会锁定内存总线直到这条指令完成为止，因此在加速的指令执行时其他处理器是不能够访问这个内存单元的！</p>
<p>操作码前缀是reg字节（<code>0xf2, 0xf3</code>）的汇编语言指令不是原子的！这条指令强行让控制单元多次重复相同的指令控制单元，在执行新的循环之前要检查挂起的中断！</p>
<h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><div class="table-container">
<table>
<thead>
<tr>
<th>API</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ATOMIC_INIT(int i)</td>
<td>定义原子变量的时候对其初始化。</td>
</tr>
<tr>
<td>int atomic_read(atomic_t *v)</td>
<td>读取 v 的值，并且返回。</td>
</tr>
<tr>
<td>void atomic_set(atomic_t *v, int i)</td>
<td>向 v 写入 i 值。</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t *v)</td>
<td>给 v 加上 i 值。</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t *v)</td>
<td>从 v 减去 i 值。</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t *v)</td>
<td>给 v 加 1，也就是自增。</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t *v)</td>
<td>从 v 减 1，也就是自减</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t *v)</td>
<td>从 v 减 1，并且返回 v 的值。</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t *v)</td>
<td>给 v 加 1，并且返回 v 的值。</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t *v)</td>
<td>从 v 减 i，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t *v)</td>
<td>从 v 减 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t *v)</td>
<td>给 v 加 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_add_negative(int i, atomic_t *v)</td>
<td>给 v 加 i，如果结果为负就返回真，否则返回假</td>
</tr>
</tbody>
</table>
</div>
<p>相应的也提供了 64 位原子变量的操作 API 函数，这里我们就不详细讲解了，和表 中的 API 函数有用法一样，只是将“atomic_”前缀换为“atomic64_”，将 int 换为 long long。如果使用的是 64 位的 SOC，那么就要使用 64 位的原子操作函数。</p>
<h3 id="优化和内存屏障"><a href="#优化和内存屏障" class="headerlink" title="优化和内存屏障"></a>优化和内存屏障</h3><p>​    当使用边缘优化的编译器时，它会重排汇编指令从而达到以最优，此外现代CPU通常会并行地执行若干条指令且可能重新安排内存访问这种重新排序可以极大地加速程序的执行然而当处理同步时则必须避免指令重新排序优化屏障源于保证编译程序不会混淆放在原语操作之前的汇编语言指令和放在原语操作之后的汇编语言这些汇编语言指令在C中都有对应的语句在Linux中优化屏障就是barrier宏，它展开为：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">asm</span> <span class="token function">volitile</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token operator">::</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    指令ASM告诉编译程序要插入汇编语言片段，volatile关键字禁止编译器把ASM指令与程序中的其他指令重新组合！memory关键字强制编译器假定RAM中的所有内存单元已经被汇编语言指令修改，因此编译器不能使用存放在CPU寄存器中的内存单元的值来优化ASM指令前的代码</p>
<p>​    注意优化屏障并不保证不使当前CPU把汇编语言指令混在一起执行，这是内存屏障的工作！</p>
<p>​    内存屏障源于保证在原语之后的操作开始之前，原语之前的操作已经完成。因此内存屏障类似于防火墙，让任何汇编语句指令都不能通过！在以下这些汇编指令在8086处理中是串行的！因为他们起到了内存屏障的作用：</p>
<p>对IO端口进行操作的所有指令</p>
<p>有lock前缀的所有指令</p>
<p>写控制寄存器系统寄存器或调试寄存器的所有指令</p>
<p>在奔腾4微处理器中引入的汇编指令lfence, sfence, mfence</p>
<p>关于内存屏障的汇编指令少数专门的汇编语言指令</p>
<p>Linux使用六个内存屏障原语，如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内存屏障的宏定义</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>mb()</td>
<td>适用于多处理器和单处理器的内存屏障。</td>
</tr>
<tr>
<td>rmb()</td>
<td>适用于多处理器和单处理器的读内存屏障。</td>
</tr>
<tr>
<td>wmb()</td>
<td>适用于多处理器和单处理器的写内存屏障。</td>
</tr>
<tr>
<td>smp_mb()</td>
<td>适用于多处理器的内存屏障。</td>
</tr>
<tr>
<td>smp_rmb()</td>
<td>适用于多处理器的读内存屏障。</td>
</tr>
<tr>
<td>smp_wmb()</td>
<td>适用于多处理器的写内存屏障。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>​    这是一种广泛使用的锁，关于锁，可以认为是对访问公共资源的一种限制。如果内核控制路径希望访问资源，就必须获取钥匙来打开这个锁！当且只当资源空闲时，也就是没有任何进程来访问这段资源的时候，它才能成功，然后持有这个锁！其他进程想要在这个进程处理。这个数据结构的时候必须等待这个进程处理完毕，释放掉这个锁之后，其他进程才能够接着访问这个数据结构！</p>
<blockquote>
<p>严肃的版本：</p>
<p>自旋锁是用来在多处理器环境中工作的一种特殊的锁，如果内核控制路径发现自旋锁是开着的！那么获取锁，并且继续执行，相反，则会在周围旋转反复执行一条紧凑的循环指令，直到锁被释放！</p>
<p>自旋锁的循环指令表示忙等待，即使等待的内核控制路径是无事可做的。它也会在CPU上保持运行，不过自旋锁通常非常方便。因为很多内核资源只锁一毫秒的时间片段，所以说释放CPU和随后又获得CPU是不会消耗多少时间的！ </p>
</blockquote>
<p>这里有更加详细的自旋锁的文章，可以参看：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/80727111">[Linux中的spinlock机制一] - CAS和ticket spinlock - 知乎 (zhihu.com)]</a></p>
</blockquote>
<h4 id="自旋锁-API-函数"><a href="#自旋锁-API-函数" class="headerlink" title="自旋锁 API 函数"></a>自旋锁 API 函数</h4><p>最基本的自旋锁 API 函数如下表 所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化一个自选变量。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非 0，否则返回 0</td>
</tr>
</tbody>
</table>
</div>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>​    读写自旋锁的引入是为了增加内核的并发能力，因为我们思考：只要没有内核控制路径对希望上锁的数据结构进行修改，我们就没有必要对这个数据结构进行上锁。只有当我们想要对这个结构进行写操作的时候那么我们才会对这个资源进行上锁。</p>
<h4 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h4><p>与 spinlock 一样，Read/Write spinlock 有如下的 APIs：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>接口API描述</strong></th>
<th><strong>Read/Write Spinlock API</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>定义rw spin lock并初始化</td>
<td>DEFINE_RWLOCK</td>
</tr>
<tr>
<td>动态初始化rw spin lock</td>
<td>rwlock_init</td>
</tr>
<tr>
<td>获取指定的rw spin lock</td>
<td>read_lock  write_lock</td>
</tr>
<tr>
<td>获取指定的rw spin lock同时disable本CPU中断</td>
<td>read_lock_irq  write_lock_irq</td>
</tr>
<tr>
<td>保存本CPU当前的irq状态，disable本CPU中断并获取指定的rw spin lock</td>
<td>read_lock_irqsave  write_lock_irqsave</td>
</tr>
<tr>
<td>获取指定的rw spin lock同时disable本CPU的bottom half</td>
<td>read_lock_bh  write_lock_bh</td>
</tr>
<tr>
<td>释放指定的spin lock</td>
<td>read_unlock  write_unlock</td>
</tr>
<tr>
<td>释放指定的rw spin lock同时enable本CPU中断</td>
<td>read_unlock_irq  write_unlock_irq</td>
</tr>
<tr>
<td>释放指定的rw spin lock同时恢复本CPU的中断状态</td>
<td>read_unlock_irqrestore  write_unlock_irqrestore</td>
</tr>
<tr>
<td>获取指定的rw spin lock同时enable本CPU的bottom half</td>
<td>read_unlock_bh  write_unlock_bh</td>
</tr>
<tr>
<td>尝试去获取rw spin lock，如果失败，不会spin，而是返回非零值</td>
<td>read_trylock  write_trylock</td>
</tr>
</tbody>
</table>
</div>
<h3 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h3><p>​    RCU就是Read, Copy, Update机制，这是为了保护在多数情况下被多个CPU读的数据结构，而设计的一种同步技术！它允许多个读者和写者并发执行，而且它是不会使用锁的。就是说它不使用被所有CPU共享的锁或计数器</p>
<p>​    在这一点上与读写自旋锁与顺序锁相比，它具有更大的优势！它的关键思想在于限制RCP的范围：</p>
<ul>
<li>RCU只会保护被动态分配，并通过指针引用的数据结构</li>
<li>在被RCU保护的临界区中任何内核控制路径都不能睡眠</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>​    它本质上就是一个更加高级的锁，一个允许最大若干进程访问资源的锁。</p>
<p>​    Linux有两个信号量：内核信号量和IPC信号量，我们现在只关心前者</p>
<h4 id="API-3"><a href="#API-3" class="headerlink" title="API"></a>API</h4><div class="table-container">
<table>
<thead>
<tr>
<th>函数定义</th>
<th>功能说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sema_init(struct semaphore *sem, int val)</td>
<td>初始化信号量，将信号量计数器值设置val。</td>
</tr>
<tr>
<td>down(struct semaphore *sem)</td>
<td>获取信号量，不建议使用此函数，因为是 UNINTERRUPTABLE 的睡眠。</td>
</tr>
<tr>
<td>down_interruptible(struct semaphore *sem)</td>
<td>可被中断地获取信号量，如果睡眠被信号中断，返回错误-EINTR。</td>
</tr>
<tr>
<td>down_killable (struct semaphore *sem)</td>
<td>可被杀死地获取信号量。如果睡眠被致命信号中断，返回错误-EINTR。</td>
</tr>
<tr>
<td>down_trylock(struct semaphore *sem)</td>
<td>尝试原子地获取信号量，如果成功获取，返回0，不能获取，返回1。</td>
</tr>
<tr>
<td>down_timeout(struct semaphore *sem, long jiffies)</td>
<td>在指定的时间jiffies内获取信号量，若超时未获取，返回错误-ETIME。</td>
</tr>
<tr>
<td>up(struct semaphore *sem)</td>
<td>释放信号量sem。</td>
</tr>
</tbody>
</table>
</div>
<p>注意：down_interruptible 接口，在获取不到信号量的时候，该任务会进入 INTERRUPTABLE 的睡眠，但是 down() 接口会导致进入 UNINTERRUPTABLE 的睡眠，down 用的较少。</p>
<h4 id="1-信号量的结构："><a href="#1-信号量的结构：" class="headerlink" title="1. 信号量的结构："></a><strong>1. 信号量的结构：</strong></h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">raw_spinlock_t</span>		lock<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span>		count<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span>	wait_list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>信号量用结构<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=semaphore&amp;spm=1001.2101.3001.7020">semaphore</a>描述，它在自旋锁的基础上改进而成，它包括一个自旋锁、信号量计数器和一个等待队列。用户程序只能调用信号量API函数，而不能直接访问信号量结构。</p>
<h4 id="2-初始化函数sema-init"><a href="#2-初始化函数sema-init" class="headerlink" title="2. 初始化函数sema_init"></a>2. 初始化函数sema_init</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__SEMAPHORE_INITIALIZER</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> n<span class="token punctuation">)</span>				</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">&#123;</span>									</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">.</span>lock		<span class="token operator">=</span> <span class="token function">__RAW_SPIN_LOCK_UNLOCKED</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">,</span>	</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">.</span>count		<span class="token operator">=</span> n<span class="token punctuation">,</span>						</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">.</span>wait_list	<span class="token operator">=</span> <span class="token function">LIST_HEAD_INIT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>wait_list<span class="token punctuation">)</span><span class="token punctuation">,</span>		</span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">&#125;</span></span></span>
 
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">lock_class_key</span> __key<span class="token punctuation">;</span>
	<span class="token operator">*</span>sem <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span><span class="token punctuation">)</span> <span class="token function">__SEMAPHORE_INITIALIZER</span><span class="token punctuation">(</span><span class="token operator">*</span>sem<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">lockdep_init_map</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>lock<span class="token punctuation">.</span>dep_map<span class="token punctuation">,</span> <span class="token string">"semaphore->lock"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>__key<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>初始化了信号量中的 spinlock 结构，count 计数器和初始化链表。</p>
<h4 id="3-可中断获取信号量函数down-interruptible"><a href="#3-可中断获取信号量函数down-interruptible" class="headerlink" title="3. 可中断获取信号量函数down_interruptible"></a>3. 可中断获取信号量函数down_interruptible</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> noinline <span class="token keyword">int</span> __sched <span class="token function">__down_interruptible</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">__down_common</span><span class="token punctuation">(</span>sem<span class="token punctuation">,</span> TASK_INTERRUPTIBLE<span class="token punctuation">,</span> MAX_SCHEDULE_TIMEOUT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
 
<span class="token keyword">int</span> <span class="token function">down_interruptible</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
	<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
	<span class="token function">raw_spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span>sem<span class="token operator">-></span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		sem<span class="token operator">-></span>count<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		result <span class="token operator">=</span> <span class="token function">__down_interruptible</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">raw_spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>down_interruptible</em> 进入后，获取信号量获取成功，进入临界区，否则进入 <em><strong>down_interruptible-&gt;</strong>down_common</em></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> __sched <span class="token function">__down_common</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">long</span> state<span class="token punctuation">,</span>
								<span class="token keyword">long</span> timeout<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span> waiter<span class="token punctuation">;</span>
 
	<span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token punctuation">.</span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sem<span class="token operator">-></span>wait_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	waiter<span class="token punctuation">.</span>task <span class="token operator">=</span> current<span class="token punctuation">;</span>
	waiter<span class="token punctuation">.</span>up <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
 
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">signal_pending_state</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">goto</span> interrupted<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>timeout <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
			<span class="token keyword">goto</span> timed_out<span class="token punctuation">;</span>
		<span class="token function">__set_current_state</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">raw_spin_unlock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		timeout <span class="token operator">=</span> <span class="token function">schedule_timeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">raw_spin_lock_irq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>waiter<span class="token punctuation">.</span>up<span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
 
 timed_out<span class="token operator">:</span>
	<span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">-</span>ETIME<span class="token punctuation">;</span>
 
 interrupted<span class="token operator">:</span>
	<span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token punctuation">.</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token operator">-</span>EINTR<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加入到等待队列，将状态设置成为 <em>TASK_INTERRUPTIBLE</em> ， 并设置了调度的 Timeout ： <em>MAX_SCHEDULE_TIMEOUT</em></p>
<p>在调用了 <em>schedule_timeout</em>，使得进程进入了睡眠状态。</p>
<h4 id="4-释放信号量函数-up"><a href="#4-释放信号量函数-up" class="headerlink" title="4. 释放信号量函数 up"></a>4. 释放信号量函数 up</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span>
 
	<span class="token function">raw_spin_lock_irqsave</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>wait_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		sem<span class="token operator">-></span>count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token function">__up</span><span class="token punctuation">(</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">raw_spin_unlock_irqrestore</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>lock<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果等待队列为空，没有睡眠的进程期望获取这个信号量，则直接 count++，否则调用 __up：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> noinline <span class="token keyword">void</span> __sched <span class="token function">__up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span> <span class="token operator">*</span>waiter <span class="token operator">=</span> <span class="token function">list_first_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>wait_list<span class="token punctuation">,</span>
						<span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token operator">-></span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	waiter<span class="token operator">-></span>up <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token function">wake_up_process</span><span class="token punctuation">(</span>waiter<span class="token operator">-></span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token keyword">static</span> noinline <span class="token keyword">void</span> __sched <span class="token function">__up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">semaphore</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span> <span class="token operator">*</span>waiter <span class="token operator">=</span> <span class="token function">list_first_entry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sem<span class="token operator">-></span>wait_list<span class="token punctuation">,</span>
						<span class="token keyword">struct</span> <span class="token class-name">semaphore_waiter</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>waiter<span class="token operator">-></span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	waiter<span class="token operator">-></span>up <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token function">wake_up_process</span><span class="token punctuation">(</span>waiter<span class="token operator">-></span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>取出队列中的元素，进行唤醒操作。</p>
<h1 id="Reference-4"><a href="#Reference-4" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45309916/article/details/117430355">Linux—原子操作（介绍及其操作函数集）_原子操作函数-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/584275908">一文读懂优化屏障和内存屏障 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/89439043">[Linux中的RCU机制一] - 原理与使用方法 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://stephenzhou.blog.csdn.net/article/details/86614945">Linux 内核同步（五）：信号量（semaphore）_sema_init-CSDN博客</a></p>
</blockquote>
<h1 id="定时测量"><a href="#定时测量" class="headerlink" title="定时测量"></a>定时测量</h1><p>​    为了准备讨论稍后的进程调度等相关内容（这是因为很多计算机的活动高度依赖定时器），我们需要首先讨论一下定时驱动。这通常对用户并不可见！为了进行这些跟定时高强度相关的操作程序，必须能从每个文件中检索到文件的最后访问时间及时间戳，因此这些的时间标记是必须由定时测量来完成的。</p>
<p>​    Linux内核必须完成主要两种定时测量：</p>
<ul>
<li>保存当前的时间和日期以便能通过<code>time()</code>，<code>ftime()</code>和<code>gettimeofday()</code>系统调用把它们返回给用户程序，也可以由内核本身把当前时间作为文件和网络包的时间戳维持</li>
<li>定时器这种机制能够告诉内核或用户程序某一时间间隔已经过去了</li>
</ul>
<p>​    定时测量是由基于固定频率振荡器和计数器的几个硬件电路完成的。</p>
<h2 id="时钟和定时器电路"><a href="#时钟和定时器电路" class="headerlink" title="时钟和定时器电路"></a>时钟和定时器电路</h2><h3 id="实时时钟"><a href="#实时时钟" class="headerlink" title="实时时钟"></a>实时时钟</h3><p>​    所有的PC都包含一个叫做实时时钟的时钟，它是独立于CPU和其他芯片的。即使当PC被切断电源，RTC还在工作。因为它靠一个小电池或蓄电池工作，CMOS RAM和RTC被集成在一个芯片上，RTC能在IRQ8上发出周期性的中断，频率在二到8192赫兹之间，也可以对RTC进行编程使得RTC达到某个特定的值时，激活IRQ。也就是作为一个闹钟来工作。Linux只用R TC来获取时间和日期，不过通过对<code>/dev/rtc</code>设备文件进行操作也允许进程对RTC进行编程，内核通过0X70和0X71 IO端口访问RTC时间戳。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>所有的8086微处理器都包括一条clk输入引线，它接受外部振荡器的时钟信号。从奔腾开始，8086微处理器都会包含一个计数器，它在每个时钟信号到来时加一。该计数器是利用64位的时间戳计数器寄存器来实现的。可以通过汇编语言指令读这个寄存器，当使用这个寄存器时，内核必须考虑到时钟信号的频率，例如如果时钟节拍的频率是1G赫兹，那么时钟抽计数器每纳秒增加一次！</p>
<h3 id="可编程间隔定数"><a href="#可编程间隔定数" class="headerlink" title="可编程间隔定数"></a>可编程间隔定数</h3><p>定时器除了实时时钟和时间戳计数器，IBM兼容PC还包含了的三种类型的时间测量设备，叫做可编程间隔计数器。它类似于微波炉的闹钟，即让用户意识到烹饪的时间已经过了！不过他的工作方式是发出一个特殊的中断，即时钟中断来通知内核又一个时间间隔过去了。与闹钟的另一个区别是PIT永远以内核确定的固定频率不停地发出中断</p>
<h3 id="CPU本地定时器"><a href="#CPU本地定时器" class="headerlink" title="CPU本地定时器"></a>CPU本地定时器</h3><p>还有一种测量设备是CPU本地定时器，它能够产生单步中断或周期性中断的设备，有点儿像刚刚所说的可编程间隔定时器。不过还是有几点区别：</p>
<ol>
<li>首先它是32位的而，pic计数器是16位的。因此可以对本地定时器编程来产生很低频率的中断</li>
<li>本地APIC定时器只发送给自己的处理器，而PIT产生一个全局性中断。系统中的任意一个中CPU都可以对其进行处理</li>
<li>APIC定时器是基于总线时钟信号的每隔1，2，4，8，16，32，64，128总线时钟信号到来时，对该定时器进行递减，就可以实现编程的目的！相反PIT有自己的内部时钟振荡器，可以更加灵活的编程 </li>
</ol>
<h3 id="高精度事件定时器HPET"><a href="#高精度事件定时器HPET" class="headerlink" title="高精度事件定时器HPET"></a>高精度事件定时器HPET</h3><p>​    提供了许多可以被内核应用的应聘时器这种新定时器芯片，主要由八个32位或64位的独立计时器。每个计时器都由它们的时钟信号所驱动，可以通过映射到内存空间的寄存器来对HPET芯片进行编程</p>
<h3 id="ACPI电源管理定时器"><a href="#ACPI电源管理定时器" class="headerlink" title="ACPI电源管理定时器"></a>ACPI电源管理定时器</h3><p>​    它是另一种时钟设备，包含在几乎所有基于ACPI的主板上，它的时钟信号拥有大约为3.58兆赫兹的固定频率。该设备实际上是一个简单的计数器，它在每个时钟节拍到来时增加一次。为了读取计数器的当前值，需要访问io端口！其io端口的地址由BIOS在初始化阶段进行确定！</p>
<h2 id="Linux计时体系"><a href="#Linux计时体系" class="headerlink" title="Linux计时体系"></a>Linux计时体系</h2><p>​    Linux必须与之执行与定时相关的操作，例如</p>
<ul>
<li>内核可以周期性地更新自系统启动以来所经过的时间！</li>
<li>更新时间和日期确定当前进程在每个CPU上已运行了多久时间，如果已经超过了分配给他的时间，那么就抢占他！</li>
<li>更新资源使用统计数检查</li>
</ul>
<p>每个软定时器Linux的计时体系结构是一组与时间流相关的内核结构与函数</p>
<h3 id="计时体系结构的数据结构"><a href="#计时体系结构的数据结构" class="headerlink" title="计时体系结构的数据结构"></a>计时体系结构的数据结构</h3><h4 id="定时器对象"><a href="#定时器对象" class="headerlink" title="定时器对象"></a>定时器对象</h4><p>为了使用统一的方式管理定时器资源：我们使用timer_opts来抽象：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>标识定时器源的一个字符串</td>
</tr>
<tr>
<td>mark_offset</td>
<td>记录上一个节拍的准确时间，由时钟中断处理程序调用</td>
</tr>
<tr>
<td>get_offset</td>
<td>返回自上一个节拍开始所经过的时间</td>
</tr>
<tr>
<td>monotonic_clock</td>
<td>返回自内核初始化开始所经过的纳秒数</td>
</tr>
<tr>
<td>delay</td>
<td>等待指定数目的循环</td>
</tr>
</tbody>
</table>
</div>
<p>​    mark_offset由时钟中断处理程序调用，以适当的数据结构记录每个节拍到来时的准确时间。get_offset用已记录的值来计算自上一次时钟中断以来经过的时间（以us为单位）。cur_timer存放了某个定时器对象的地址，该定时器是系统可利用的定时器资源中”最好的”。</p>
<p>​    下表显示了优先权的排序表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>定时器对象名称</th>
<th>说明</th>
<th>定时插补</th>
<th>延迟</th>
</tr>
</thead>
<tbody>
<tr>
<td>timer_hpet</td>
<td>高精度事件定时器</td>
<td>HPET</td>
<td>HPET</td>
</tr>
<tr>
<td>timer_pmtmr</td>
<td>ACPI电源管理定时器</td>
<td>ACPI PMT</td>
<td>TSC</td>
</tr>
<tr>
<td>timer_tsc</td>
<td>时间戳计数器</td>
<td>TSC</td>
<td>TSC</td>
</tr>
<tr>
<td>timer_pit</td>
<td>可编程间隔定时器</td>
<td>PIT</td>
<td>紧致循环</td>
</tr>
<tr>
<td>timer_none</td>
<td>普通虚拟定时器资源</td>
<td></td>
<td>紧致循环</td>
</tr>
</tbody>
</table>
</div>
<h3 id="jiffies变量"><a href="#jiffies变量" class="headerlink" title="jiffies变量"></a>jiffies变量</h3><p>​    记录自系统启动以来产生的节拍总数。<strong>由于使用了time_after，time_after_eq，time_before，time_before_eq，内核很好的处理了jiffies变量的溢出。</strong></p>
<p>​    jiffies被初始化为0xfffb6c20，它是一个32位有符号值，等于-300000。因此，计数器将会在系统启动后的5分钟内处于溢出状态。使那些不对jiffies做溢出检测的有缺陷代码在开发阶段被及时发现。（这个技巧是为了迫使内核程序员编写程序时考虑jifffies的溢出）80x86中，jiffies通过连接器被换算成一个64位计数器的低32位，这个64位计数器称作jiffies_64。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">get_jiffies_64</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> seq<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> ret<span class="token punctuation">;</span>
	<span class="token keyword">do</span><span class="token punctuation">&#123;</span>
		seq <span class="token operator">=</span> <span class="token function">read_seqbegin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>xtime_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ret <span class="token operator">=</span> jiffies_64<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">read_seqretry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>xtime_lock<span class="token punctuation">,</span> seq<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在临界区增加jiffies_64值时必须用write_seqlock(&amp;time_lock)和write_sequnlock(&amp;xtime_lock)进行保护。</p>
<h3 id="xtime变量"><a href="#xtime变量" class="headerlink" title="xtime变量"></a>xtime变量</h3><p>xtime作为一个extern的timespec的全局变量，存放当前时间和日期。</p>
<pre class="line-numbers language-none"><code class="language-none">struct timespec
 &#123;
     __kernel_time_t       tv_sec;         &#x2F;* 秒数 *&#x2F;
     long                  tv_nsec;        &#x2F;* 纳秒数,1纳秒(ns)&#x3D;1e-9秒(s) *&#x2F;
 &#125;;
extern struct timespec xtime;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>tv_sec</code>：存放自1970.1.1午夜以来经过的秒数<br><code>tv_nesc</code>：存放自上一秒开始经过的纳秒数</p>
</blockquote>
<p>通常每个节拍更新一次。</p>
<h3 id="单处理器系统上的计时体系结构"><a href="#单处理器系统上的计时体系结构" class="headerlink" title="单处理器系统上的计时体系结构"></a>单处理器系统上的计时体系结构</h3><p>​    单处理器系统上，所有与定时有关的活动都是由IRQ线0上的可编程间隔定时器产生的中断触发的。Linux中，某些活动都尽可能在中断产生后立即执行，其余活动延迟。</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>内核初始化期间，time_init函数被调用来建立计时体系结构，通常执行如下：</p>
<ol>
<li>初始化xtime。用get_cmos_time从实时时钟上读取自1970年1月1日午夜以来经过的秒数。设置xtime的tv_nsec，</li>
<li>初始化wall_to_monotonic。它存放将被加到xtime上的秒数和纳秒数，以此来获得单向的时间流。外部时钟的闰秒和同步都可能突发低改变xtime的tv_sec和tv_nsec，使得它们不再是单向递增。</li>
<li>如内核支持HPET，将调hpet_enable来确认ACPI固件是否探测到该芯片并将它的寄存器映射到内存地址空间中。如结果是肯定，则hpet_enable将对HPET的第一个定时器编程使其以每秒1000次的频率引发IRQ0处的中断。否则，内核将使用PIT：该芯片已经被init_IRQ编程，使得它以每秒1000次的频率引发IRQ0处的中断。</li>
<li>调select_timer来挑选系统中可利用的最好的定时器资源，并设置cur_timer变量指向该定时器资源对应的定时器对象的地址。</li>
<li>调setup_irq(0, &amp;irq0)来创建与IRQ0相应的中断门，IRQ0引脚线连接着系统时钟中断源（PIT或HPET）。irq0被静态定义如下：</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">irqaction</span> irq0 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	timer_interrupt<span class="token punctuation">,</span>
	SA_INTERRUPT<span class="token punctuation">,</span>
	<span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"timer"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    从现在起，timer_interrupt函数会在每个节拍到来时被调用，而中断被禁止，因为IRQ0主描述符的状态字段中SA_INTERRUPT被置位。</p>
<h3 id="时钟中断处理程序"><a href="#时钟中断处理程序" class="headerlink" title="时钟中断处理程序"></a>时钟中断处理程序</h3><p>这里我们需要关注的就是timer_interrupt，他是PIT或HPET的中断服务例程 </p>
<blockquote>
<ol>
<li><p>在xtime_lock顺序锁上产生一个write_seqlock</p>
</li>
<li><p>执行cur_timer的mark_offset。</p>
</li>
</ol>
<blockquote>
<ol>
<li>cur_timer指向timer_hpet对象，这种情况下，HPET芯片作为时钟中断源。make_offset检查自上一节拍以来是否丢失时钟中断，相应地更新jiffies_64。记录HPET周期计数器当前值。</li>
<li>cur_timer指向timer_pmtmr：PIT芯片作为时钟中断源，但内核用APIC电源管理定时器以更高的分辨率来测量时间。make_offset检查自上一个节拍以来是否丢失时钟中断，如丢失，则更新jiffies_64。它记录APIC电源管理定时计数器当前值。</li>
<li>cur_timer指向timer_tsc对象：PIT芯片作为时钟中断源，但是内核用时间戳计数器以更高的分辨率来测量时间。make_offset检查自上一个节拍以来是否丢失时钟中断，如丢失，则更新jiffies_64。它记录TSC计数器当前值。</li>
<li>cur_timer指向timer_pit：PIT芯片作为时钟中断源，除此之外没别的定时器电路。mark_offset啥也不做。</li>
</ol>
</blockquote>
<ol>
<li>调do_timer_interrupt</li>
</ol>
<blockquote>
<ol>
<li>使jiffies_64增1.</li>
<li>调update_times更新系统日期和时间。</li>
<li>调update_process_times</li>
<li>调profile_tick</li>
<li>如使用外部时钟来同步系统时钟，则每隔660s调一次set_rtc_mmss来调整实时时钟。</li>
</ol>
</blockquote>
<ol>
<li><p>调write_sequnlock释放xtime_lock顺序锁</p>
</li>
<li><p>返回值1，报告中断已经被有效地处理了。</p>
</li>
</ol>
</blockquote>
<h3 id="多处理器系统上的计时体系结构"><a href="#多处理器系统上的计时体系结构" class="headerlink" title="多处理器系统上的计时体系结构"></a>多处理器系统上的计时体系结构</h3><p>​    多处理器系统可依赖两种不同的时钟中断源：可编程间隔定时器，高精度事件定时器，CPU本地定时器产生的中断。Linux2.6中，PIT或HPET产生的全局时钟中断触发不涉及具体CPU的活动，如，处理软定时器，保持系统时间的更新。一个CPU本地时钟中断触发涉及本地CPU的计时活动，如，监视当前进程的运行时间，更新资源使用统计数</p>
<h3 id="初始化阶段-1"><a href="#初始化阶段-1" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>​    全局时钟中断处理程序由time_init初始化。Linux内核为本地时钟中断保留第239号中断向量。在内核初始化阶段，函数apic_intr_init根据第239号向量和低级中断处理程序apic_timer_interrupt的地址设置IDT的中断门。每个APIC必须被告知多久产生一次本地时钟中断。calibrate_APIC_clock通过正在启动的CPU的本地APIC来计算一个节拍内收到了多少个总线时钟信号。然后这个确切的值被用来对本地所有APIC编程，由此在每个节拍产生一次本地时钟中断。这是由setup_APIC_timer完成的。</p>
<p>​    所有本地APIC定时器都是同步的，因为它们都基于公共总线时钟信号。意味着用于引导CPU的calibrate_APIC_clock计算出来的值对系统中的其他CPU同样有效</p>
<h3 id="全局时钟中断处理程序"><a href="#全局时钟中断处理程序" class="headerlink" title="全局时钟中断处理程序"></a>全局时钟中断处理程序</h3><p>SMP版本的timer_interrupt与UP版本的该处理程序在几个地方有差异：</p>
<ol>
<li>timer_interrupt调do_timer_interrupt向I/O APIC芯片的一个端口写入，以应答定时器的中断请求。</li>
<li>update_process_times不被调用，因为该函数执行与特定CPU相关的一个操作。</li>
<li>profile_tick不被调用，因为该函数执行与特定CPU相关的操作。</li>
</ol>
<h3 id="本地时钟中断处理程序"><a href="#本地时钟中断处理程序" class="headerlink" title="本地时钟中断处理程序"></a>本地时钟中断处理程序</h3><p>该处理程序执行系统中与特定CPU相关的计时活动，即监管内核代码并检测当前进程在特定CPU上已经运行了多长时间。apic_timer_interrupt等价于：</p>
<pre class="line-numbers language-none"><code class="language-none">apic_timer_interrupt:
	pushl $(239-256)
	SAVE_ALL
	movl %esp, %eax
	call smp_apic_timer_interrupt
	jmp ret_from_intr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>被称作smp_apic_timer_interrupt的高级中断处理函数执行如下步骤：</p>
<ol>
<li>获得CPU逻辑号</li>
<li>使irq_stat数组第n项的apic_timer_irqs字段加1</li>
<li>应答本地APIC上的中断</li>
<li>调irq_enter</li>
<li>调smp_local_timer_interrupt</li>
<li>调irq_exit</li>
</ol>
<p>smp_local_timer_interrupt执行每个CPU的计时活动。事实上，它执行下面的主要步骤：</p>
<ol>
<li>调profile_tick</li>
<li>调update_process_times检查当前进程运行的时间并更新一些本地CPU统计数。系统管理员通过写入/proc/profile可修改内核代码监管器的抽样频率。为实现修改，内核改变本地时钟中断产生的频率。smp_local_timer_interrupt保持每个节拍精确调用update_process_times一次。</li>
</ol>
<h3 id="更新时间和日期"><a href="#更新时间和日期" class="headerlink" title="更新时间和日期"></a>更新时间和日期</h3><p>用户程序从xtime变量中获得当前时间和日期。内核必须周期性地更新该变量，才能使它的值保持相当的精确。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">update_times</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> ticks<span class="token punctuation">;</span>
	ticks <span class="token operator">=</span> jiffies <span class="token operator">-</span> wall_jiffies<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>ticks<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		wall_jiffies <span class="token operator">+=</span> ticks<span class="token punctuation">;</span>
		<span class="token function">update_wall_time</span><span class="token punctuation">(</span>ticks<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">calc_load</span><span class="token punctuation">(</span>ticks<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    对丢失的定时器中断的检查在cur_timer的mark_offset中完成。update_wall_time连续调update_wall_time_one_tick ticks次，每次调用都给xtime.tv_nsec加上1000000。如xtime.tv_nsec大于999999999，则update_wall_time更新xtime的tv_sec。</p>
<h3 id="更新系统统计数"><a href="#更新系统统计数" class="headerlink" title="更新系统统计数"></a>更新系统统计数</h3><p>内核在与定时相关的其他任务中必须周期性地收集若干数据用于：</p>
<ol>
<li>检查运行进程的CPU资源限制</li>
<li>更新与本地CPU工作负载有关的统计数</li>
<li>计算平均系统负载</li>
<li>监管内核代码</li>
</ol>
<h3 id="更新本地CPU统计数"><a href="#更新本地CPU统计数" class="headerlink" title="更新本地CPU统计数"></a>更新本地CPU统计数</h3><p>使用的是<code>update_process_times</code>，这是流程：</p>
<ol>
<li>检查当前进程运行了多长时间。时钟中断发生时，根据当前进程运行在用户态还是内核态，选择调account_user_time还是account_system_time<br>1.1. 更新当前进程描述符的utime或stime。在进程描述符中提供两个被称作cutime和cstime的附加字段，分别来统计子进程在用户态和内核态下所经过的CPU节拍数。<br>1.2. 检查是否已达到总的CPU时限。如是， 向current进程发SIGXCPU和SIGKILL。<br>1.3. 调account_it_virt和account_it_prof来检查进程定时器<br>1.4. 更新一些内核统计数</li>
<li>调raise_softirq来激活本地CPU上的TIMER_SOFTIRQ任务队列</li>
<li>如必须回收一些老版本的，受RCU保护的数据结构，则检查本地CPU是否经历了静止状态并调tasklet_schedule来激活本地CPU的rcu_tasklet任务队列。</li>
<li>调scheduler_tick，函数使当前进程的时间片计数器减1，并检查计数器是否已减到0。</li>
</ol>
<h3 id="记录系统负载"><a href="#记录系统负载" class="headerlink" title="记录系统负载"></a>记录系统负载</h3><p>​    任何Unix内核都要记录系统进行了多少CPU活动。这些统计数据由各种管理实用程序来使用。用户输入uptime后可看到一些统计数据：如相对于最后1分钟，5分钟，15分钟的平均负载。单处理器系统上，值0意味着没活跃的进程。值1意味着一个单独的进程100%占有CPU。值大于1说明几个运行着的进程共享CPU。</p>
<h3 id="监管内核代码"><a href="#监管内核代码" class="headerlink" title="监管内核代码"></a>监管内核代码</h3><p>Linux包含一个被称作readprofiler的最低要求的代码监管器，Linux开发者用其发现内核在内核态什么地方花费时间。</p>
<p><strong>监管器基于非常简单的蒙特卡洛算法：每次时钟中断发生时，内核确定该中断是否发生在内核态。</strong>如是，内核从堆栈取回中断发生前eip的值，并用这个值揭示中断发生前内核在做什么。采样数据积聚在”热点”上。</p>
<p>profile_tick为代码监管器采集数据。为激活代码监管器，Linux内核启动时必须传递”profile=N”，这里2^N标识要监管的代码段大小。采集的数据可从/proc/profile读取。可通过修改这个文件来重置计数器。多处理器系统上，修改此文件还可改变抽样频率。</p>
<p>内核开发者用readprofile命令。Linux 2.6内核还包括另一个监管器，oprofile。使用oprofile时，profile_tick调timer_notify收集数据。</p>
<h3 id="检查非屏蔽中断监视器"><a href="#检查非屏蔽中断监视器" class="headerlink" title="检查非屏蔽中断监视器"></a>检查非屏蔽中断监视器</h3><p>多处理器系统上，Linux为内核开发者提供另一种功能：看门狗系统。这对于探测引起系统冻结的内核bug可能有用，启动内核时传递nmi_watchdog</p>
<p>看门狗基于本地和I/O APIC一个特性：它们能在每个CPU上产生周期性的NMI中断。</p>
<p>一旦每个时钟节拍到来，所有的CPU，都开始执行NMI中断处理程序；该中断处理程序又调用do_nmi。这个函数获得CPU的逻辑号n，检查irq_stat数组第n项的apic_timer_flags。如工作正常，则第n项的必定不同于前一个NMI中断中读出的值。CPU正常运行时，第n项的apic_timer_irq被本地时钟中断处理程序增加。当NMI中断处理程序检测到一个CPU冻结时，把引起恐慌的信息记录在日志文件， 转储该CPU寄存器的内容和内核栈的内容，最后杀死当前进程。</p>
<h3 id="软定时器和延迟函数"><a href="#软定时器和延迟函数" class="headerlink" title="软定时器和延迟函数"></a>软定时器和延迟函数</h3><p>Linux考虑两种类型的定时器：动态定时器，间隔定时器第一种类型由内核使用，间隔定时器可以由进程在用户态创建。对定时器函数的检查总是由可延迟函数进行，内核不能确保定时器函数正好在定时到期时开始执行，只能保证在适当的时间执行它们。对必须严格遵守定时时间的实时应用而言，定时器并不适合。</p>
<h3 id="动态定时器"><a href="#动态定时器" class="headerlink" title="动态定时器"></a>动态定时器</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">timer_list</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> entry<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> expires<span class="token punctuation">;</span>
	<span class="token class-name">spinlock_t</span> lock<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> magic<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> data<span class="token punctuation">;</span>
	<span class="token class-name">tvec_base_t</span> <span class="token operator">*</span>base<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了创建并激活一个动态定时器，内核必须：</p>
<ol>
<li>如需要，创建一个新的timer_list</li>
<li>调init_timer(&amp;t)</li>
<li>把定时器到期时激活函数地址存入function，设置data。</li>
<li>尚未插入链表时，赋值expires，调add_timer(&amp;t)插入链表</li>
<li>已经插入链表时，调mod_timer更新expires。</li>
</ol>
<p>一旦定时器到期，内核就自动把元素t从它的链表中删除。有时进程应用del_timer，del_timer_sync，del_singleshot_timer_sync显式从定时器链表删除一个定时器。LInux 2.6中，定时器函数总会在第一个执行add_timer或稍后执行mod_timer的那个CPU上运行。</p>
<h3 id="动态定时器与竞争条件"><a href="#动态定时器与竞争条件" class="headerlink" title="动态定时器与竞争条件"></a>动态定时器与竞争条件</h3><p>一种凭经验做法是释放资源前停止定时器。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">del_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">X_Release_Resources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    多处理器系统上，这段代码是不安全的。因为调del_timer时，定时器函数可能已在其他CPU上运行了。为避免这种竞争条件，内核提供了del_timer_sync：从链表删除定时器，检查定时器函数是否还在CPU上运行，如是，等待运行结束。如内核开发者知道定时器函数从不重新激活定时器，就能使用更简单更快速的del_singleshot_timer_sync来使定时器无效，并等待直到定时器函数结束。</p>
<p>​    也存在其他种类的竞争条件：如，修改已激活定时器expires正确方法是调mod_timer，而非删除再创建。后一种途径中，要修改同一定时器expires的两个内核控制路径可能交错在一起。定时器函数在SMP上的安全实现是通过每个timer_list对象包含的lock达到：内核访问动态定时器链表时，需禁止中断，获取自旋锁。</p>
<h3 id="动态定时器的数据结构"><a href="#动态定时器的数据结构" class="headerlink" title="动态定时器的数据结构"></a>动态定时器的数据结构</h3><p>​    把expires值划分成不同的大小，并允许动态定时器从大expires值的链表到小expires值的链表进行有效的过滤。多处理器系统中活动的动态定时器集合被分配到各个不同的CPU中。</p>
<p>​    动态定时器的主要数据结构是一个叫tvec_bases的每CPU变量：它包含NR_CPUS个元素，系统中每个CPU各有一个。每个元素是一个tvec_base_t的结构：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tvec_t_base_s</span><span class="token punctuation">&#123;</span>
	<span class="token class-name">spinlock_t</span> lock<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> timer_jiffies<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">timer_list</span><span class="token operator">*</span> running_timer<span class="token punctuation">;</span>
	<span class="token class-name">tvec_root_t</span> tv1<span class="token punctuation">;</span>
	<span class="token class-name">tvec_t</span> tv2<span class="token punctuation">;</span>
	<span class="token class-name">tvec_t</span> tv3<span class="token punctuation">;</span>
	<span class="token class-name">tvec_t</span> tv4<span class="token punctuation">;</span>
	<span class="token class-name">tvec_t</span> tv5<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token class-name">tvec_base_t</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    tvec_root_t包含一个vec数组，数组由256个list_head元素组成。结构包含了在紧接着到来的255个节拍内将要到期的所有动态定时器。字段tv2,tv3,tv4结构都是tvec_t，该类型有一个数组vec（包含64个list_head）。这些链表包含在紧接着到来的214-1，220-1，2^26-1个节拍内将到期的所有动态定时器。字段tv5，vec数组最后一项是一个大expires字段值的动态定时器链表。timer_jiffies表示需检查的动态定时器的最早到时时间。多处理器系统中，running_timer指向由本地CPU当前正在处理的动态定时器的timer_list结构。</p>
<h3 id="动态定时器处理"><a href="#动态定时器处理" class="headerlink" title="动态定时器处理"></a>动态定时器处理</h3><p>​    Linux 2.6中该活动由可延迟函数执行。即由TIMER_SOFTIRQ软中断执行。run_timer_softirq是与TIMER_SOFTIRQ软中断请求相关的可延迟函数。它实质上执行如下操作：</p>
<ol>
<li><p>把与本地CPU相关的tvec_base_t地址存放到base</p>
</li>
<li><p>获得base-&gt;lock并禁止本地中断</p>
</li>
<li><p>开始执行一个while，当base-&gt;timer_jiffies大于jiffies时终止每次循环中：</p>
<blockquote>
<ol>
<li><p>计算base-&gt;tv1中索引，索引保存着下一次要处理的定时器index = base-&gt;timer_jiffies &amp; 255</p>
</li>
<li><p>如索引值为0：调cascade来过滤动态定时器</p>
</li>
<li><p>使base-&gt;timer_jiffies值加1</p>
</li>
<li><p>对base-&gt;tv1.vec[index]链表上的每一个定时器，执行它对应的定时器函数。特别是，链表上每个timer_list元素t实质上执行：</p>
<blockquote>
<ol>
<li>将t从base-&gt;tv1的链表上删除</li>
<li>多处理器系统中，将base-&gt;running_timer设置为&amp;t</li>
<li>设置t.base为NULL</li>
<li>释放base-&gt;lock，允许本地中断</li>
<li>传递t.data为参数，执行定时器函数t.function</li>
<li>获得base-&gt;lock，禁止本地中断</li>
<li>如链表中还有其他定时器，继续处理</li>
</ol>
</blockquote>
</li>
<li><p>链表上所有定时器已经被处理。继续执行最外层while循环的下一次循环。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>最外层的while循环结束。base-&gt;running_timer=NULL</p>
</li>
<li><p>释放base-&gt;lock自旋锁，允许本地中断。</p>
</li>
</ol>
<p>调用每个动态定时器函数前，激活中断并释放自旋锁。这保证了动态定时器的数据结构不被交错执行的内核控制路径所破坏。</p>
<h3 id="动态定时器应用：nanosleep系统调用"><a href="#动态定时器应用：nanosleep系统调用" class="headerlink" title="动态定时器应用：nanosleep系统调用"></a>动态定时器应用：nanosleep系统调用</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_INTERRUPTIBLE<span class="token punctuation">;</span>
remaining <span class="token operator">=</span> <span class="token function">schedule_timeout</span><span class="token punctuation">(</span><span class="token function">timespec_to_jiffies</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>内核使用动态定时器来实现进程的延时。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">timer_list</span> timer<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">long</span> expire <span class="token operator">=</span> timeout <span class="token operator">+</span> jiffies<span class="token punctuation">;</span>
<span class="token function">init_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
timer<span class="token punctuation">.</span>expires <span class="token operator">=</span> expire<span class="token punctuation">;</span>
timer<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>current<span class="token punctuation">;</span>
timer<span class="token punctuation">.</span>function <span class="token operator">=</span> process_timeout<span class="token punctuation">;</span>
<span class="token function">add_timer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">del_singleshot_timer_sync</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>
timeout <span class="token operator">=</span> expire <span class="token operator">-</span> jiffies<span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>timeout <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>返回值0表示延时到期。timeout表示如进程因某些其他原因被唤醒，到延迟到期时还剩余的节拍数。延迟到期时，执行</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">process_timeout</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> __data<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">wake_up_process</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">task_t</span><span class="token operator">*</span><span class="token punctuation">)</span>__data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h3><p>由于动态定时器通常有很大的设置开销和一个相当大的最小等待时间（1ms），所以设备驱动器使用它会很不方便。这时，内核使用udelay，ndelay：前者接收一个微妙级的时间间隔，后者接收纳秒级。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">udelay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> usecs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> loops<span class="token punctuation">;</span>
	loops <span class="token operator">=</span> <span class="token punctuation">(</span>usecs<span class="token operator">*</span>HZ<span class="token operator">*</span>current_cpu_data<span class="token punctuation">.</span>loops_per_jiffy<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000000</span><span class="token punctuation">;</span>
	cur_timer<span class="token operator">-></span><span class="token function">delay</span><span class="token punctuation">(</span>loops<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">ndelay</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> nsecs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> loops<span class="token punctuation">;</span>
	loops <span class="token operator">=</span> <span class="token punctuation">(</span>nsecs<span class="token operator">*</span>HZ<span class="token operator">*</span>current_cpu_data<span class="token punctuation">.</span>loops_per_jiffy<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000000000</span><span class="token punctuation">;</span>
	cur_timer<span class="token operator">-></span><span class="token function">delay</span><span class="token punctuation">(</span>loops<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    两个函数都依赖于cur_timer的delay，它接收”loops”中的时间间隔作为参数。不过每次”loops”精确的持续时间取决于cur_timer涉及的定时器对象。</p>
<ol>
<li>如cur_timer指向timer_hpet，timer_pmtmr和timer_tsc，则一次”loop”对应一个CPU循环–也就是两个连续CPU时钟信号间的时间间隔</li>
<li>如cur_timer指向timer_none或timer_pit，则一次”loop”对应于一条紧凑指令循环在一次单独的循环中所花费的时间。</li>
</ol>
<p>​    初始化阶段，select_timer设置好cur_timer后，内核通过calibrate_delay决定一个节拍里有多少次”loop”。值保存在current_cpu_data.loops_per_jiffy中，这样udelay，ndelay能根据它来把微妙和纳秒转换成”loops”。</p>
<p>​    如可利用HPET或TSC硬件电路，则cur_timer-&gt;dalay使用它们来获取精确的时间测量。否则，该方法执行一个紧凑指令循环的loops次循环。</p>
<h3 id="与定时测量相关的系统调用"><a href="#与定时测量相关的系统调用" class="headerlink" title="与定时测量相关的系统调用"></a>与定时测量相关的系统调用</h3><h4 id="time和gettimeofday系统调用"><a href="#time和gettimeofday系统调用" class="headerlink" title="time和gettimeofday系统调用"></a>time和gettimeofday系统调用</h4><blockquote>
<p><code>time:</code> 返回从1970年1月1日午夜开始所走过的秒数<br><code>gettimeofday:</code>返回从1970年1月1日午夜开始所走过的秒数及前一秒内走过的微妙数，值存放在数据结构timeval中。</p>
</blockquote>
<p>另一个被广泛使用的函数ftime不再作为一个系统调用来执行，它返回从1970年1月1日午夜开始所走过的秒数与前1秒内所走过的毫秒数。这是使用<code>do_gettimeofday</code>更新这些函数所需要的资源：</p>
<ol>
<li><p>为读操作获取xtime_lock</p>
</li>
<li><p>调cur_timer的get_offset来确定自上次时钟中断走过的微妙数</p>
<blockquote>
<ol>
<li>如cur_timer指向timer_hpet，将HPET计数器的当前值与上一次时钟中断处理程序执行时在同一个计数器中保存的值比较。</li>
<li>如cur_timer指向timer_pmtmr，将ACPI PMT计数器的当前值与上一次时钟中断处理程序执行时在同一个计数器里保存的值比较。</li>
<li>如cur_timer指向timer_tsc，将时间戳计数器的当前值与上一次时钟中断处理程序执行时在同一个TSC里保存的值比较</li>
<li>如cur_timer指向timer_pit，读取PIT计数器的当前值来计算自上一次PIT时钟中断以来走过的微妙数。</li>
</ol>
</blockquote>
</li>
<li><p>如某定时器中断丢失，该函数为usec加上相应的延迟：usec += (jiffies - wall_jiffies) * 1000;</p>
</li>
<li><p>为usec加上前1秒内走过的微妙数usec += (xtime.tv_nsec / 1000);</p>
</li>
<li><p>将xtime的内容复制到系统调用参数tv指定的用户空间缓冲区中，并给微妙字段的值加上usec：tv-&gt;tv_sec = xtime-&gt;tv_sec;tv-&gt;tv_usec = usec;</p>
</li>
<li><p>在xtime_lock顺序锁上调read_seqretry，且如另一条内核控制路径同时为写操作而获得了xtime_lock，跳回1</p>
</li>
<li><p>检查tv_usec字段是否溢出，如必要调整</p>
</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">while<span class="token punctuation">(</span>tv-<span class="token operator">></span>tv_usec <span class="token operator">>=</span> <span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	tv-<span class="token operator">></span>tv_usec -<span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>
	tv-<span class="token operator">></span>tv_sec++<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>拥有root权限的用户态下的进程可用stime，settimeofday来修改系统当前日期和时间。</p>
<h3 id="settimer和alarm"><a href="#settimer和alarm" class="headerlink" title="settimer和alarm"></a>settimer和alarm</h3><p>Linux允许用户态的进程激活一种叫间隔定时器的特殊定时器。这种定时器引起的Unix信号被周期性地发送到进程。间隔定时器：</p>
<ol>
<li>发送信号所必须的频率，或如只需产生一个信号，则频率为空。</li>
<li>在下一个信号被产生以前所剩余的时间settimer：</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">ITIMER_REAL
	真正过去的时间；进程接收SIGALRM
ITIMER_VIRTUAL
	进程在用户态下花费的时间；进程接收SIGVTALRM
ITIMER_PROF
	进程既在用户态下又在内核态下花费的时间；进程接收SIGPROF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为能实现每种策略，进程描述符要包含3对字段：</p>
<ol>
<li>it_real_incr和it_real_value</li>
<li>it_virt_incr和it_virt_value</li>
<li>it_prof_incr和it_prof_value<br>每对中第一个字段存放着两个信号之间以节拍为单位的间隔；另一个字段存放着定时器当前值。ITIMER_REAL利用动态定时器实现。每个进程描述符包含一个real_timer的动态定时器对象。</li>
</ol>
<p>​    ITIMER_VIRTUAL和ITIMER_PROF，只有当进程运行时，它们才能被更新。update_process_times在单处理器上由PIT时钟中断处理程序调用；多处理器上由本地时钟中断处理程序调用。</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>​    我们这里，准备讨论一下进程调度这个话题，这是对进程那一章节的继续补充！</p>
<h2 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h2><p>​    Linux的调度基于分时技术！多个进程以时间多路复用的方式进行运行。因为CPU的时间被分成了片分配给每个进程。当然单处理器在任何给定时刻只能运行一个进程，如果当前进程的时间片或时限到期时，进程没有运行完毕，那么进程切换就可以！</p>
<p>​    发生分时机依赖于定时中断，因此对进程是透明的，不需要在程序中插入额外的代码来进行切换。</p>
<p>​    在Linux中进程的优先级是动态进行分配的，调度程序跟踪器进程正在做什么，动态的调整它们的优先级！传统上把进程分为io受限或CPU受限，前者频繁的使用io设备，并且花费等很多时间等待io操作完成。后者则需要大量的CPU时间的数值计算这样的应用程序。</p>
<p>​    另一种则把进程分为三类：</p>
<ol>
<li>交互式进程：这类进程经常与用户进行交互，因此需要花很多时间等待键盘和鼠标操作</li>
<li>批处理进程：这些进程不必与用户进行一种交互，经常在后台进行运行。这样的进程不必很快响应，因此经常受到调度程序的慢怠</li>
<li>实时进程：这些进程有很强的调度需求，这样的进程绝不会被低优先级的进程阻塞。他们应该有一个很短的响应时间。 </li>
</ol>
<h4 id="一些API："><a href="#一些API：" class="headerlink" title="一些API："></a>一些API：</h4><div class="table-container">
<table>
<thead>
<tr>
<th>系统调用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>nice</td>
<td>改变一个普通进程的静态优先级</td>
</tr>
<tr>
<td>getpriority</td>
<td>获得一组普通进程的最大静态优先级</td>
</tr>
<tr>
<td>setpriority</td>
<td>设置一组普通进程的静态优先级</td>
</tr>
<tr>
<td>sched_getscheduler</td>
<td>获得一个进程的调度策略</td>
</tr>
<tr>
<td>sched_setscheduler</td>
<td>设置一个进程的调度策略和实时优先级</td>
</tr>
<tr>
<td>sched_getparam</td>
<td>获得一个进程的实时优先级</td>
</tr>
<tr>
<td>sched_setparam</td>
<td>设置一个进程的实时优先级</td>
</tr>
<tr>
<td>sched_yield</td>
<td>自愿放弃处理器而不阻塞</td>
</tr>
<tr>
<td>sched_get_priority_min</td>
<td>获得一种策略的最小实时优先级</td>
</tr>
<tr>
<td>sched_get_priority_max</td>
<td>获得一种策略的最大实时优先级</td>
</tr>
<tr>
<td>sched_rr_get_interval</td>
<td>获得时间片轮转策略的时间片值</td>
</tr>
<tr>
<td>sched_setaffinity</td>
<td>设置进程的CPU亲和力掩码</td>
</tr>
<tr>
<td>sched_getaffinity</td>
<td>获得进程的CPU亲和力掩码</td>
</tr>
</tbody>
</table>
</div>
<h3 id="进程抢占"><a href="#进程抢占" class="headerlink" title="进程抢占"></a>进程抢占</h3><p>​    Linux的进程是抢占式的，如果进程进入task running状态，内核检查它的动态优先级是否大于当前正在运行的进程的优先级！如果是，进程切换发生。</p>
<h3 id="时间片的选择应该如何"><a href="#时间片的选择应该如何" class="headerlink" title="时间片的选择应该如何"></a>时间片的选择应该如何</h3><p>​    时间片的长短对系统性能很关键，不可太长也不可太短，如果太短，由进程切换引起的系统额外开销会变得很高；如果太长，系统看起来的响应非常的差。所以对时间片大小的选择始终是一种折中 。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>​    每次进程切换时，内核扫描可运行进程链表，计算进程的优先级，再选择”最佳”进程来运行。在固定的时间内（与可运行的进程数量无关）选中要运行的进程。很好处理了与处理器数量的比例关系，每个<code>CPU</code>都拥有自己的可运行进程队列。新算法较好解决了区分交互式进程，批处理进程的问题。每个<code>Linux</code>进程总是按下面的调度类型被调度：</p>
<blockquote>
<p><code>SCHED_FIFO</code>：当调度程序把<code>CPU</code>分配给进程时候，它把该进程描述符保留在运行队列链表的当前位置。如没其他可运行的更高优先级实时进程，进程就继续用<code>CPU</code>。想用多久用多久。<br><code>SCHED_RR</code>：时间片轮转的实时进程。调度程序把<code>CPU</code>分配给进程时候，把该进程的描述符放在运行队列链表的末尾。保证对所有具有相同优先级的<code>SCHED_RR</code>实时进程公平地分配<code>CPU</code>时间。<br><code>SCHED_NORMAL</code>：普通的分时进程。（默认的）</p>
</blockquote>
<h3 id="普通进程的调度"><a href="#普通进程的调度" class="headerlink" title="普通进程的调度"></a>普通进程的调度</h3><p>​    每个普通进程有它自己的静态优先级，<strong>调度程序使用静态优先级来估价系统中这个进程和其他普通进程间调度的程度</strong>。内核用<code>100</code>（高）到<code>139</code>（低）的数表示普通进程的静态优先级。值越大静态优先级越低。<strong>新进程总是继承其父进程的静态优先级。通过把某些<code>&quot;nice&quot;</code>值传递给系统调用<code>nice</code>和<code>setpriority</code>，用户可改变自己拥有的进程的静态优先级</strong>。</p>
<h3 id="基本时间片"><a href="#基本时间片" class="headerlink" title="基本时间片"></a>基本时间片</h3><p>静态优先级本质上决定了进程的基本时间片，即进程用完了以前的时间片时，系统分配给进程的时间片长度。静态优先级和基本时间片的关系用下列公式确定：<br>基本时间片（<code>ms</code>）：<br>若静态优先级 <code>&lt; 120</code>，<code>(140 - 静态优先级) * 20</code><br>若静态优先级 <code>&gt;= 120</code>，<code>(140 - 静态优先级) * 5</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>说明</th>
<th>静态优先级</th>
<th>nice值</th>
<th>基本时间片</th>
<th>交互式@值</th>
<th>睡眠时间极限值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最高静态优先级</td>
<td>100</td>
<td>-20</td>
<td>800ms</td>
<td>-3</td>
<td>299ms</td>
</tr>
<tr>
<td>高静态优先级</td>
<td>110</td>
<td>-10</td>
<td>600ms</td>
<td>-1</td>
<td>499ms</td>
</tr>
<tr>
<td>缺省静态优先级</td>
<td>120</td>
<td>0</td>
<td>100ms</td>
<td>+2</td>
<td>799ms</td>
</tr>
<tr>
<td>低静态优先级</td>
<td>130</td>
<td>+10</td>
<td>50ms</td>
<td>+4</td>
<td>999ms</td>
</tr>
<tr>
<td>最低静态优先级</td>
<td>139</td>
<td>+19</td>
<td>5ms</td>
<td>+6</td>
<td>1199ms</td>
</tr>
</tbody>
</table>
</div>
<h3 id="动态优先级和平均睡眠时间"><a href="#动态优先级和平均睡眠时间" class="headerlink" title="动态优先级和平均睡眠时间"></a>动态优先级和平均睡眠时间</h3><p>普通进程除了静态优先级，还有动态优先级，其值的范围是<code>100</code>（高）~<code>139</code>（低）。动态优先级是调度程序在选择新进程来运行时候使用的数。它与静态优先级的关系用下面的经验公式表示：<br>动态优先级<code>=max(100, min(静态优先级 - bonus + 5, 139))</code></p>
<p><code>bonus</code>是范围<code>0~10</code>的值，值小于<code>5</code>表示降低动态优先级以示惩罚，值大于<code>5</code>表示增加动态优先级以示奖赏。<code>bonus</code>值依赖于进程过去的情况，更准确些，与进程的平均睡眠时间相关。粗略讲，平均睡眠时间是进程在睡眠状态所消耗的平均纳秒数。如，在<code>TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE</code>状态所计算出的平均睡眠时间是不同的。且，进程在运行过程中平均睡眠时间递减，平均睡眠时间永远不会大于<code>1s</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>平均睡眠时间</th>
<th>bonus</th>
<th>粒度</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0,100ms)</td>
<td>0</td>
<td>5120</td>
</tr>
<tr>
<td>[100ms,200ms)</td>
<td>1</td>
<td>2560</td>
</tr>
<tr>
<td>[200ms,300ms)</td>
<td>2</td>
<td>1280</td>
</tr>
<tr>
<td>[300ms,400ms)</td>
<td>3</td>
<td>640</td>
</tr>
<tr>
<td>[400ms,500ms)</td>
<td>4</td>
<td>320</td>
</tr>
<tr>
<td>[500ms,600ms)</td>
<td>5</td>
<td>160</td>
</tr>
<tr>
<td>[600ms,700ms)</td>
<td>6</td>
<td>80</td>
</tr>
<tr>
<td>[700ms,800ms)</td>
<td>7</td>
<td>40</td>
</tr>
<tr>
<td>[800ms,900ms)</td>
<td>8</td>
<td>20</td>
</tr>
<tr>
<td>[900ms,1000ms)</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>1s</td>
<td>10</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p>​    平均睡眠时间也被调度程序用来确定一个给定进程是交互式进程，还是批处理进程。对于交互式进程的计算方式是：动态优先级 <code>&lt;= 3 * 静态优先级 / 4 + 28</code>或 <code>bonus - 5 &gt;= 静态优先级 / 4 - 28</code></p>
<p>总结：</p>
<blockquote>
<ol>
<li>优先级越高获得的时间片越大</li>
<li>睡眠时间越长，动态优先级在静态优先级基础上越高（值越小）。</li>
</ol>
</blockquote>
<h3 id="活动与过期进程"><a href="#活动与过期进程" class="headerlink" title="活动与过期进程"></a>活动与过期进程</h3><p>​    当然，我们想到即使是不具有较高静态优先级的普通进程获得较大的CPU时间片，也不应该使得静态优先级较低的进程无法运行！（活动队列一直被高优先级的进程抢占！）为了避免进程饥饿，当一个进程用完它的时间片时，它应该被还没有用完时间片的低优先级进程取代！</p>
<p>​    为了实现这种机制调度程序分了两个不相交的可运行进程的集合：</p>
<ul>
<li>活动进程：这些进程还没有用完他们的时间片因此引起他们的运行运行</li>
<li>过期进程：这些可运行进程已经完它们的时间片，因此禁止被运行直到所有活动进程都过期 </li>
</ul>
<h3 id="实时进程的调度"><a href="#实时进程的调度" class="headerlink" title="实时进程的调度"></a>实时进程的调度</h3><p>​    每个实时进程都与一个实时优先级相关！实时优先级是一个从1到99的值！调用程序总是让优先级高的进程运行，换句话说实时进程运行的过程中禁止低优先级进程的运行！与普通进程相反，实时进程总是可以被当成活动进程！</p>
<p>​    如果几个可运行的实时进程具有相同的优先级那么调度，进程选择第一个出现在本地CPU的运行队列的相应的列表的进程！与进程只有在以下列这些事情发生的时候实时进程才会被另外一个进程取代：</p>
<ul>
<li>进程被另一个具有较高优先级对实时进程抢占</li>
<li>实时进程执行了阻塞操作并且进入了睡眠进程</li>
<li>停止或者被杀死进程</li>
<li>通过系统调用sched_yield自愿放弃CPU</li>
<li>进程正是基于时间片轮转的实时进程，而且用完了它的时间片 </li>
</ul>
<h2 id="调度程序所使用的数据结构"><a href="#调度程序所使用的数据结构" class="headerlink" title="调度程序所使用的数据结构"></a>调度程序所使用的数据结构</h2><h3 id="数据结构runqueue"><a href="#数据结构runqueue" class="headerlink" title="数据结构runqueue"></a>数据结构runqueue</h3><p>​    系统中的每个<code>CPU</code>都有它自己的运行队列，所有的<code>runqueue</code>结构存放在<code>runqueues</code>每<code>CPU</code>变量中。宏<code>this_rq</code>产生本地<code>CPU</code>运行队列的地址，宏<code>cpu_rq(n)</code>产生索引为<code>n</code>的<code>CPU</code>的运行队列的地址。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>spinlock_t</td>
<td>lock</td>
<td>保护进程链表的自旋锁</td>
</tr>
<tr>
<td>unsigned long</td>
<td>nr_running</td>
<td>运行队列链表中可运行进程的数量</td>
</tr>
<tr>
<td>unsigned long</td>
<td>cpu_load</td>
<td>基于运行队列中进程的平均数量的CPU负载因子</td>
</tr>
<tr>
<td>unsigned long</td>
<td>nr_switches</td>
<td>CPU执行进程切换的次数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>nr_uninterruptible</td>
<td>先前在运行队列链表，现在睡眠在TASK_UNINTERRUPTIBLE状态的进程的数量</td>
</tr>
<tr>
<td>unsigned long</td>
<td>expired_timestamp</td>
<td>过期队列中最老的进程被插入队列的时间</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>timestamp_last_tick</td>
<td>最近一次定时器中断的时间戳的值</td>
</tr>
<tr>
<td>task_t*</td>
<td>curr</td>
<td>当前正运行进程的描述符指针</td>
</tr>
<tr>
<td>task_t*</td>
<td>idle</td>
<td>当前CPU上swapper进程的描述符指针</td>
</tr>
<tr>
<td>struct mm_struct*</td>
<td>prev_mm</td>
<td>进程切换期间用来存放被替换进程的内存描述符地址</td>
</tr>
<tr>
<td>prio_array_t*</td>
<td>active</td>
<td>指向活动进程链表的指针</td>
</tr>
<tr>
<td>prio_array_t*</td>
<td>expired</td>
<td>指向过期进程链表的指针</td>
</tr>
<tr>
<td>prio_array_t[2]</td>
<td>arrays</td>
<td>活动进程和过期进程的两个集合</td>
</tr>
<tr>
<td>int</td>
<td>best_expired_prio</td>
<td>过期进程中静态优先级最高的进程</td>
</tr>
<tr>
<td>atomic_t</td>
<td>nr_iowait</td>
<td>先前在运行队列链表中，现在正等待磁盘I/O操作结束的进程的数量</td>
</tr>
<tr>
<td>struct sched_domain*</td>
<td>sd</td>
<td>指向当前CPU的基本调度域</td>
</tr>
<tr>
<td>int</td>
<td>active_balance</td>
<td>如要把一些进程从本地运行队列迁移到另外的运行队列，就设置</td>
</tr>
<tr>
<td>int</td>
<td>push_cpu</td>
<td>未使用</td>
</tr>
<tr>
<td>task_t*</td>
<td>migration_thread</td>
<td>迁移内核线程的进程描述符指针</td>
</tr>
<tr>
<td>struct list_head</td>
<td>migration_queue</td>
<td>从运行队列中被删除的进程的链表</td>
</tr>
</tbody>
</table>
</div>
<p>​    系统中每个可运行进程属于且只属于一个运行队列。只要可运行进程保持在同一个运行队列中，它就只可能在拥有该运行队列的<code>CPU</code>上执行。可运行进程会从一个运行队列迁移到另一个运行队列。</p>
<p>​    运行队列的<code>arrays</code>字段是一个包含两个<code>prio_array_t</code>结构的数组。每个数据结构都表示一个可运行进程的集合，并包括<code>140</code>个双向链表头（每个链表对应一个可能的进程优先级），一个优先级位图，一个集合中所包含的进程数量的计数器。</p>
<p>​    <code>arrays</code>中两个数据结构的作用会发生周期性的变化：活动进程突然变成过期进程，过期进程变成活动进程。调度程序简单地交换运行队列的<code>active</code>和<code>expired</code>字段的内容以完成变化。</p>
<h3 id="进程描述符-1"><a href="#进程描述符-1" class="headerlink" title="进程描述符"></a>进程描述符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned long</td>
<td>thread_info-&gt;flags</td>
<td>存放TIF_NEED_RESCHED，如必须调调度程序，则设置</td>
</tr>
<tr>
<td>unsigned int</td>
<td>thread_info-&gt;cpu</td>
<td>可运行进程所在运行队列的CPU逻辑号</td>
</tr>
<tr>
<td>unsigned long</td>
<td>state</td>
<td>进程的当前状态</td>
</tr>
<tr>
<td>int</td>
<td>prio</td>
<td>进程的动态优先级</td>
</tr>
<tr>
<td>int</td>
<td>static_prio</td>
<td>进程的静态优先级</td>
</tr>
<tr>
<td>struct list_head</td>
<td>run_list</td>
<td>指向进程所属的运行队列链表中的下一个和前一个元素。链表节点。</td>
</tr>
<tr>
<td>prio_array_t*</td>
<td>array</td>
<td>指向包含进程的运行队列的集合prio_array_t</td>
</tr>
<tr>
<td>unsigned long</td>
<td>sleep_avg</td>
<td>进程的平均睡眠时间</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>timestamp</td>
<td>进程最近插入运行队列时间，或涉及本进程的最近一次进程切换的时间</td>
</tr>
<tr>
<td>unsigned long long</td>
<td>last_ran</td>
<td>最近一次替换本进程的进程切换时间</td>
</tr>
<tr>
<td>int</td>
<td>activated</td>
<td>进程被唤醒时使用的条件代码</td>
</tr>
<tr>
<td>unsigned long</td>
<td>policy</td>
<td>进程的调度类型（SCHED_NORMAL,SCHED_RR,SCHED_FIFO）</td>
</tr>
<tr>
<td>cpumask_t</td>
<td>cpus_allowed</td>
<td>能执行进程的CPU的位掩码</td>
</tr>
<tr>
<td>unsigned int</td>
<td>time_slice</td>
<td>在进程的时间片中还剩余的时钟节拍数</td>
</tr>
<tr>
<td>unsigned int</td>
<td>first_time_slice</td>
<td>如进程肯定不会用完其时间片，就设置</td>
</tr>
<tr>
<td>unsigned long</td>
<td>rt_priority</td>
<td>进程的实时优先级</td>
</tr>
</tbody>
</table>
</div>
<p>进程被创建时</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">p<span class="token operator">-></span>time_slice <span class="token operator">=</span> <span class="token punctuation">(</span>current<span class="token operator">-></span>time_slice<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>
current<span class="token operator">-></span>time_slice<span class="token operator">>>=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>父进程剩余的节拍数被划分成两等份。一份给父进程，一份给子进程。子进程在首个时间片内终止或执行新程序，剩余时间奖励给父进程。</p>
<h3 id="调度程序所使用的函数"><a href="#调度程序所使用的函数" class="headerlink" title="调度程序所使用的函数"></a>调度程序所使用的函数</h3><ol>
<li><code>scheduler_tick</code>：维持最新的<code>time_slice</code>计数器</li>
<li><code>try_to_wake_up</code>：唤醒睡眠进程</li>
<li><code>recalc_task_prio</code>更新进程的动态优先级</li>
<li><code>schedule</code>选择要被执行的新进程</li>
<li><code>load_balance</code>:维持多处理器系统中运行队列的平衡</li>
</ol>
<h3 id="scheduler-tick"><a href="#scheduler-tick" class="headerlink" title="scheduler_tick"></a>scheduler_tick</h3><p>每次时钟节拍到来时，<code>scheduler_tick</code>：</p>
<blockquote>
<ol>
<li><p>把转换为纳秒的<code>TSC</code>当前值存入本地运行队列的<code>timestamp_last_tick</code>。这个时间戳是从<code>sched_clock</code>获得的。</p>
</li>
<li><p>检查当前进程是否是本地<code>CPU</code>的<code>swapper</code>进程。如是，</p>
<blockquote>
<p>如本地运行队列除了<code>swapper</code>外，还包括一个可运行的进程，就设置当前进程的<code>TIF_NEED_RESCHED</code>。如内核支持超线程技术，则只要一个逻辑<code>CPU</code>运行队列中的所有进程 都有比 另一个逻辑<code>CPU</code>上已经在执行的进程 有低得多的优先级（两个逻辑<code>CPU</code>对应同一个物理<code>CPU</code>），前一逻辑<code>CPU</code>就可能空闲。超线程下，将<code>2</code>个进程安排在两个不同物理<code>cpu</code>，相比在同一物理<code>cpu</code>的多个逻辑<code>cpu</code>可以更好并发，然后跳到第七步！</p>
</blockquote>
</li>
<li><p>检查<code>current-&gt;array</code>是否指向本地运行队列的活动链表。如不是，设置<code>TIF_NEED_RESCHED</code>。跳到<code>7</code></p>
</li>
<li><p>获得<code>this_rq()-&gt;lock</code></p>
</li>
<li><p>递减当前进程的时间片计数器。检查是否已用完时间片。由于进程的调度类型不同，这一步操作也有很大差别。稍后讨论。</p>
</li>
<li><p>释放<code>this_rq()-&gt;lock</code></p>
</li>
<li><p>调<code>rebalance_tick</code>。保证不同<code>CPU</code>的运行队列包含数量基本相同的可运行进程。</p>
</li>
</ol>
</blockquote>
<h3 id="更新实时进程的时间片"><a href="#更新实时进程的时间片" class="headerlink" title="更新实时进程的时间片"></a>更新实时进程的时间片</h3><p>​    如当前进程是<code>FIFO</code>的实时进程，<code>scheduler_tick</code>什么也不做。维持当前进程的最新时间片计数器没意义。如<code>current</code>表示基于时间片轮转的实时进程，<code>scheduler_tick</code>就递减它的时间片计数器并检查时间片是否被用完</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span><span class="token punctuation">(</span>current<span class="token operator">-></span>policy <span class="token operator">==</span> SCHED_RR <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token operator">--</span>current<span class="token operator">-></span>time_slice<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	current<span class="token operator">-></span>time_slice <span class="token operator">=</span> <span class="token function">task_timeslice</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
	current<span class="token operator">-></span>first_time_slice <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">set_tsk_need_resched</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>current<span class="token operator">-></span>run_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">list_add_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>current<span class="token operator">-></span>run_list<span class="token punctuation">,</span> <span class="token function">this_rq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>active<span class="token operator">-></span>queue<span class="token operator">+</span>current<span class="token operator">-></span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如函数确定时间片用完了，就执行操作以抢占当前进程。</p>
<ol>
<li>调<code>task_timeslice</code>重填进程的时间片计数器</li>
<li><code>scheduler_tick</code>调<code>set_tsk_need_resched</code>设置<code>TIF_NEED_RESCHED</code></li>
<li>把进程描述符移到与当前进程优先级相应的运行队列活动链表尾部。</li>
</ol>
<h3 id="更新普通进程的时间片"><a href="#更新普通进程的时间片" class="headerlink" title="更新普通进程的时间片"></a>更新普通进程的时间片</h3><p>如当前进程是普通进程，<code>scheduler_tick</code>：</p>
<ol>
<li><p>递减<code>current-&gt;time_slice</code></p>
</li>
<li><p>如时间片用完</p>
<blockquote>
<ol>
<li><p>调<code>dequeue_task</code>从可运行进程的<code>this_rq()-&gt;active</code>集合中删除<code>current</code>指向的进程</p>
</li>
<li><p>调<code>set_tsk_need_resched</code>设置<code>TIF_NEED_RESCHED</code></p>
</li>
<li><p>更新<code>current</code>指向的进程的动态优先级，<code>current-&gt;prio = effective_prio(current);</code></p>
</li>
<li><p>重填进程的时间片</p>
<pre class="line-numbers language-none"><code class="language-none">current-&gt;time_slice &#x3D; task_timeslice(current);
current-&gt;first_time_slice &#x3D; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>如果本地运行队列的<code>expired_timestamp</code>等于<code>0</code>，就把当前时钟节拍值赋给<code>expired_timestamp</code></p>
</li>
<li><p>把当前进程插入活动进程集合或过期进程集合</p>
<pre class="line-numbers language-none"><code class="language-none">if(!TASK_INTERACTIVE(current) || EXPIRED_STARVING(this_rq())
&#123;
	enqueue_task(current, this_rq()-&gt;expired);
	if(current-&gt;static_prio &lt; this_rq()-&gt;best_expired_prio)
		this_rq()-&gt;best_expired_prio &#x3D; current-&gt;static_prio;
&#125;
else
	enqueue_task(current, this_rq()-&gt;active);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>宏<code>EXPIRED_STARVING</code>检查运行队列中的第一个过期进程的等待时间是否已经超过<code>1000</code>个时钟节拍乘以运行队列中可运行进程数加<code>1</code>。如是，产生<code>1</code>。如当前进程的静态优先级大于一个过期进程的静态优先级。也产生<code>1</code>。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>如时间片没用完。检查当前进程的剩余时间片是否太长。</p>
<blockquote>
<pre class="line-numbers language-none"><code class="language-none">  &gt;if(TASK_INTERACTIVE(p) 
&amp;&amp; !((task_timeslice(p)-p-&gt;time_slice % TIMESLICE_GRANULARITY(p)) 
&amp;&amp; (p-&gt;time_slice &gt;&#x3D; TIMESLICE_GRANULARITY(p))
&amp;&amp; (p-&gt;array &#x3D;&#x3D; rq-&gt;active))
  &gt;&#123;
list_del(&amp;current-&gt;run_list);
list_add_tail(&amp;current-&gt;run_list, this_rq()-&gt;active-&gt;queue+current-&gt;prio);
set_tsk_need_resched(p);
  &gt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
</li>
</ol>
<p>​    基本上，具有高静态优先级的交互式进程，其时间片被分成大小为<code>TIMESLICE_GRANULARITY</code>的几个片段，每次用完一个片段，就重新调度一次。以便时间片太长下，其他活动进程有机会得到执行。</p>
<h3 id="try-to-wake-up"><a href="#try-to-wake-up" class="headerlink" title="try_to_wake_up"></a>try_to_wake_up</h3><p>​    把进程状态置为<code>TASK_RUNNING</code>，把进程插入本地<code>CPU</code>的运行队列来唤醒睡眠或停止的进程。参数：</p>
<blockquote>
<ol>
<li>被唤醒进程的描述符指针</li>
<li>可被唤醒的进程状态掩码</li>
<li>一个标志，用来禁止被唤醒的进程抢占本地<code>CPU</code>上正运行的进程</li>
</ol>
</blockquote>
<p>操作：</p>
<blockquote>
<ol>
<li><p>调<code>task_rq_lock</code>禁用本地中断。获得最后执行进程的<code>cpu</code>所拥有的运行队列<code>rq</code>锁。</p>
</li>
<li><p>检查进程状态<code>p-&gt;state</code>是否属于被当作参数传递给函数的状态掩码。如不是，跳到<code>9</code>。</p>
</li>
<li><p>如<code>p-&gt;array</code>不等于<code>NULL</code>。跳到<code>8</code></p>
</li>
<li><p>在多处理器系统中，函数检查要被唤醒的进程是否应该从最近运行的<code>CPU</code>的运行队列迁移到另外一个<code>CPU</code>的运行队列。实际上，函数根据一些启发式规则选择一个目标运行队列。</p>
<blockquote>
<ol>
<li>如系统中某些<code>CPU</code>空闲，就选择空闲<code>CPU</code>的运行队列。按优先选择当前正执行进程的<code>CPU</code>和本地<code>CPU</code>这种顺序。</li>
<li>如先前执行进程的CPU<code>的</code>工作量远小于本地<code>CPU</code>的工作量，就选择先前的运行队列作为目标</li>
<li>如进程最近被执行过，就选择老的运行队列作为目标（可能仍用这个进程的数据填充硬件高速缓存）</li>
<li>如把进程移到本地<code>CPU</code>以缓解<code>CPU</code>之间的不平衡，目标就是本地运行队列</li>
</ol>
<p>此时，已经确定了目标<code>CPU</code>和对应的目标运行队列<code>rq</code>。</p>
</blockquote>
</li>
<li><p>如进程处于<code>TASK_UNINTERRUPTIBLE</code>，递减目标运行队列的<code>nr_uninterruptible</code>，把进程描述符的<code>p-&gt;activated</code>置为<code>-1</code>。</p>
</li>
<li><p>调<code>active_task</code></p>
<blockquote>
<ol>
<li><p>调<code>sched_clock</code>获取以纳秒为单位的当前时间戳。如目标<code>CPU</code>不是本地<code>CPU</code>，就补偿本地时钟中断的偏差。从而得到准确的目标<code>cpu</code>上的时间戳。</p>
<blockquote>
<pre class="line-numbers language-none"><code class="language-none">&gt;now&#x3D;(sched_clock()-this_rq()-&gt;timestamp_last_tick)+rq-&gt;timestamp_last_tick;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
</li>
<li><p>调<code>recalc_task_prio</code>，把进程描述符的指针和上一步计算出的时间戳传递给它。重新计算平均睡眠时间，动态优先级。</p>
</li>
<li><p>调整<code>p-&gt;activated</code>，以便反映从中断唤醒，从非中断唤醒，不可中断睡眠进程唤醒。</p>
</li>
<li><p>据<code>6.1</code>.算出的时间戳设置<code>p-&gt;timestamp</code></p>
</li>
<li><p>把进程描述符插入活动进程集合</p>
</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">enqueue_task(p, rq-&gt;active);
rq-&gt;nr_running++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</blockquote>
</li>
<li><p>. 如目标<code>CPU</code>不是本地<code>CPU</code>，或没设置<code>sync</code>。就检查可运行的新进程的动态优先级是否比<code>rq</code>运行队列中当前进程动态优先级高。如是，就让目标<code>cpu</code>及时发生新的调度。</p>
</li>
<li><p>把进程的<code>p-&gt;state</code>置为<code>TASK_RUNNING</code></p>
</li>
<li><p>调<code>task_rq_unlock</code>打开<code>rq</code>运行队列的锁并打开本地中断</p>
</li>
<li><p>返回<code>1</code>或<code>0</code></p>
</li>
</ol>
</blockquote>
<h3 id="recalc-task-prio"><a href="#recalc-task-prio" class="headerlink" title="recalc_task_prio"></a>recalc_task_prio</h3><p>更新进程的平均睡眠时间，动态优先级．接收进程描述符指针<code>p</code>，和由<code>sched_clock</code>计算出的当前时间戳。操作：</p>
<ol>
<li><p>把<code>min</code>(<code>now - p-&gt;timestamp,</code> 1 0 9 10^9109)的结果赋给局部变量<code>sleep_time</code>。这样计算出来的是进程的睡眠时间。<code>p-&gt;timestamp</code>包含导致进程进入睡眠状态的进程切换的时间戳。<code>sleep_time</code>中存放的是从进程最后一次执行开始，进程消耗在睡眠状态的纳秒数。睡眠时间长时，<code>sleep_time</code>就等于<code>1s</code></p>
</li>
<li><p>如<code>sleep_time</code>不大于<code>0</code>，跳到<code>8</code>。</p>
</li>
<li><p>若进程不是内核线程，进程不是从<code>TASK_UNINTERRUPTIBLE</code>被唤醒，进程连续睡眠的时间超过给定的睡眠时间极限。都满足，函数把<code>p-&gt;sleep_avg</code>设置为相当于 <code>900</code>个时钟节拍的值。（用最大平均睡眠时间减去一个标准进程的基本时间片长度获得一个经验值）跳<code>8</code>。</p>
<p>睡眠时间极限，进程静态优先级。这些经验规则的目的是保证已经睡眠了很长时间的进程，获得一个预先确定且足够长的平均睡眠时间，以使这些进程能尽快获得服务。</p>
</li>
<li><p>执行<code>CURRENT_BONUS</code>计算进程原来的平均睡眠时间的<code>bonus</code>值。如<code>(10 - bonus)</code>大于<code>0</code>，函数用这个值与<code>sleep_time</code>相乘。因为要把<code>sleep_time</code>加到进程的平均睡眠时间上，所以当前平均睡眠时间越短，它增加的就越快。</p>
</li>
<li><p>如进程处于<code>TASK_UNINTERRUPTIBLE</code>且不是内核线程，执行下述：</p>
<blockquote>
<ol>
<li>检查平均睡眠时间<code>p-&gt;sleep_avg</code>是否大于或等于进程的睡眠时间极限。如是，把局部变量<code>sleep_time</code>重新置为<code>0</code>，因此不用调整平均睡眠时间，跳<code>6</code>。</li>
<li>如<code>sleep_time+p-&gt;sleep_avg</code>的和大于或等于睡眠时间极限，就把<code>p-&gt;sleep_avg</code>置为睡眠时间极限并把<code>sleep_time</code>置为<code>0</code>。通过对进程平均睡眠时间的轻微限制，函数不会对睡眠时间很长的批处理进程给予过多奖赏。</li>
</ol>
</blockquote>
</li>
<li><p>把<code>sleep_time</code>加到进程的平均睡眠时间上。</p>
</li>
<li><p>检查<code>p-&gt;sleep_avg</code>是否超过<code>1000</code>个时钟节拍（以纳秒为单位），如是，函数就把它减到<code>1000</code>个时钟节拍（以纳秒为单位）。</p>
</li>
<li><p>更新进程的动态优先级：<code>p-&gt;prio=effective_prio(p);</code>函数依据<code>p</code>的静态优先级，<code>sleep_avg</code>按前面介绍的规则计算动态优先级。</p>
</li>
</ol>
<h2 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h2><p>​    从运行队列的链表找到一个进程，随后将<code>CPU</code>分配给这个进程。<code>schedule</code>可由几个内核控制路径调用，可采取直接调用或延迟调用的方式。</p>
<h3 id="从使用角度介绍schedule使用场景–直接调用"><a href="#从使用角度介绍schedule使用场景–直接调用" class="headerlink" title="从使用角度介绍schedule使用场景–直接调用"></a>从使用角度介绍schedule使用场景–直接调用</h3><p>如<code>current</code>进程因不能获得必须的资源而要立刻被阻塞，就直接调调度程序。此时，要阻塞进程的内核路径按下述步骤：</p>
<ol>
<li>把<code>current</code>进程插入适当的等待队列</li>
<li>把<code>current</code>进程状态改为<code>TASK_INTERRUPTIBLE</code>或<code>TASK_UNINTERRUPTIBLE</code></li>
<li>调<code>schedule</code></li>
<li>检查资源是否可用。如不可用就跳到<code>2</code>。</li>
<li>一旦资源可用，就从等待队列中删除<code>current</code>。</li>
</ol>
<h3 id="从使用角度介绍schedule使用场景–延迟调用"><a href="#从使用角度介绍schedule使用场景–延迟调用" class="headerlink" title="从使用角度介绍schedule使用场景–延迟调用"></a>从使用角度介绍schedule使用场景–延迟调用</h3><p>也可把<code>current</code>进程的<code>TIF_NEED_RESCHED</code>标志设置为<code>1</code>，而以延迟方式调用调度程序。<br>由于总是在恢复用户态进程的执行前检查这个标志的值，所以<code>schedule</code>将在不久后的某个时间被明确地调用。</p>
<p>以下是延迟调用调度程序的典型例子：</p>
<ol>
<li>当<code>current</code>进程用完了它的<code>CPU</code>时间片时，由<code>schedule_tick</code>完成<code>schedule</code>的延迟调用。</li>
<li>当一个被唤醒进程的优先级比当前进程的优先级高，由<code>try_to_wake_up</code>完成<code>schedule</code>的延迟调用</li>
<li>当发出系统调用<code>sched_setscheduler</code>时。</li>
</ol>
<h3 id="进程切换之前schedule所执行的操作"><a href="#进程切换之前schedule所执行的操作" class="headerlink" title="进程切换之前schedule所执行的操作"></a>进程切换之前schedule所执行的操作</h3><p><code>schedule</code>任务之一是用另外一个进程来替换当前正执行的进程。<br>该函数的关键结果是设置一个叫<code>next</code>的变量，使它指向被选中的进程，该进程将取代<code>current</code>进程。如系统中没优先级高于<code>current</code>进程的可运行进程，则最终<code>next</code>与<code>current</code>相等，不发生任何进程切换。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">need_resched<span class="token operator">:</span>
	<span class="token function">preempt_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	prev <span class="token operator">=</span> current<span class="token punctuation">;</span>
	rq <span class="token operator">=</span> <span class="token function">thi_rq</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>下一步，<code>schedule</code>要保证<code>prev</code>不占用大内核锁</p>
<pre class="line-numbers language-none"><code class="language-none">if(prev-&gt;lock_depth &gt;&#x3D; 0)
	up(&amp;kernel_sem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​    注意，<code>schedule</code>不改变<code>lock_depth</code>；进程切换会自动释放和重新获取大内核锁。调<code>sched_clock</code>以读取<code>TSC</code>，将它的值换成纳秒。获得的时间戳存放在局部变量<code>now</code>。<code>schedule</code>计算<code>prev</code>所用的<code>CPU</code>时间片长度：</p>
<pre class="line-numbers language-none"><code class="language-none">now &#x3D; sched_clock();
run_time &#x3D; now - prev-&gt;timestamp;
if(run_time &gt; 1000000000)
	run_time &#x3D; 1000000000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通常使用限制在<code>1s</code>的时间。<code>run_time</code>的值用来限制进程对<code>CPU</code>的使用。不过，鼓励进程有较长的平均睡眠时间：</p>
<pre class="line-numbers language-none"><code class="language-none">run_time &#x2F;&#x3D; (CURRENT_BONUS(prev) ? : 1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>记住，<code>CURRENT_BONUS</code>返回<code>0~10</code>之间的值，它与进程的平均睡眠时间是成比例的。这样 平均睡眠时间越长，有效的<code>run_time</code>就越小。开始寻找可运行进程前，<code>schedule</code>需关掉本地中断，并获得所要保护的运行队列的自旋锁。</p>
<pre class="line-numbers language-none"><code class="language-none">spin_lock_irq(&amp;rq-&gt;lock);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>prev</code>可能是一个正被终止的进程。为确认这个事实，<code>schedule</code>检查<code>PF_DEAD</code>标志：</p>
<pre class="line-numbers language-none"><code class="language-none">if(prev-&gt;flags &amp; PF_DEAD)
	prev-&gt;state &#x3D; EXIT_DEAD;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>schedule</code>检查<code>prev</code>的状态。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 进程状态不是可运行&amp;允许内核抢占
if(prev-&gt;state !&#x3D; TASK_RUNNING &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE))
&#123;
	&#x2F;&#x2F; 进程状态是可中断休眠&amp;存在待处理信号
	if(prev-&gt;state &#x3D;&#x3D; TASK_INTERRUPTIBLE &amp;&amp; signal_pending(prev))
		prev-&gt;state &#x3D; TASK_RUNNING;&#x2F;&#x2F; 恢复进程状态为可运行
	else
	&#123;
		if(prev-&gt;state &#x3D;&#x3D; TASK_UNINTERRUPTIBLE)
			rq-&gt;nr_uninterruptible++;
		&#x2F;&#x2F; 将进程从其所在的进程链表移除。这样进程被移除在调度目标考虑范围外。
		deactive_task(prev, rq);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    现在<code>schedule</code>检查运行队列中剩余的可运行进程数。如有可运行的进程，<code>schedule</code>就调<code>dependent_sleeper</code>。绝大多数情况下，该函数立即返回<code>0</code>。但，如内核支持超线程技术，函数检查要被选中执行的进程，其优先级是否比已经在相同物理<code>CPU</code>的某个逻辑<code>CPU</code>上运行的兄弟进程的优先级低；这种特殊情况下，<code>schedule</code>拒绝选中低优先级进程，执行<code>swapper</code>。这样是为了避免低优先级进程抢占同一物理<code>cpu</code>内的共享资源。</p>
<pre class="line-numbers language-none"><code class="language-none">if(rq-&gt;nr_running)
&#123;
	if(dependent_sleeper(smp_processor_id(), rq))
	&#123;
		next &#x3D; rq_idle;
		goto switch_tasks;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如运行队列中没可运行的进程存在，就调<code>idle_balance</code>。从另外一个运行队列迁移一些可运行进程到本地运行队列中。<code>idle_balance</code>与<code>load_balance</code>类似。</p>
<pre class="line-numbers language-none"><code class="language-none">if(!rq-&gt;nr_running)
&#123;
	idle_balance(smp_processor_id(), rq);
	if(!rq-&gt;nr_running)&#123;
		next &#x3D; rq_idle;
		rq-&gt;expired_timestamp &#x3D; 0;
		wake_sleeping_dependent(smp_processor_id(), rq);
		if(!rq-&gt;nr_running)
			goto switch_tasks;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如<code>idle_balance</code>没成功把进程迁移到本地运行队列， <code>wake_sleeping_dependent</code>是检查兄弟进程正在运行空闲进程，且存在可运行进程下，设置其调度标志。在单处理器系统，或把进程迁移到本地运行队列的种种努力都失败情况下，函数选择<code>swapper</code>作为<code>next</code>并继续执行下一步骤。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 走到这里，是可以继续在运行队列中选择目标进程
array &#x3D; rq-&gt;active;
if(!array-&gt;nr_active)
&#123;
	&#x2F;&#x2F; 交换活动队列，过期队列
	rq-&gt;active &#x3D; rq-&gt;expired;
	rq-&gt;expired &#x3D; array;
	array &#x3D; rq-&gt;active;
	rq-&gt;expired_timestamp &#x3D; 0;
	rq-&gt;best_expired_prio &#x3D; 140;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>schedule</code>搜索活动进程集合位掩码的第一个非<code>0</code>位。当对应的优先级链表不为空时，就把位掩码相应位置<code>1</code>。第一个非<code>0</code>位的下标对应包含最佳运行进程的链表。</p>
<pre class="line-numbers language-none"><code class="language-none">idx &#x3D; sched_find_first_bit(array-&gt;bitmap);
next  &#x3D; list_entry(array-&gt;queue[idx].next, task_t, run_list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>函数<code>sched_find_first_bit</code>基于<code>bsfl</code>汇编语言指令的，它返回<code>32</code>位字中被设置为<code>1</code>的最低位的位下标。局部变量<code>next</code>现在存放将取代<code>prev</code>的进程描述符指针。<code>schedule</code>检查<code>next-&gt;activated</code>，该字段的编码值表示进程在被唤醒时的状态。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>进程处于TASK_RUNNING</td>
</tr>
<tr>
<td>1</td>
<td>进程处于TASK_INTERRUPTIBLE或TASK_STOPPED，且正被系统服务例程或内核线程唤醒</td>
</tr>
<tr>
<td>2</td>
<td>进程处于TASK_INTERRUPTIBLE或TASK_STOPPED，且正被中断处理程序或可延迟函数唤醒</td>
</tr>
<tr>
<td>-1</td>
<td>进程处于TASK_UNINTERRUPTIBLE且正被唤醒</td>
</tr>
</tbody>
</table>
</div>
<p>如<code>next</code>是一个普通进程，且正从<code>TASK_INTERRUPTIBLE</code>或<code>TASK_STOPPED</code>被唤醒，调度程序就把自从进程插入运行队列开始所经过的纳秒数加到进程的平均睡眠时间中。即进程的睡眠时间被增加了，以包含进程在运行队列中等待<code>CPU</code>所消耗的时间。</p>
<pre class="line-numbers language-none"><code class="language-none">if(next-&gt;prio &gt;&#x3D; 100 &amp;&amp; next-&gt;activated &gt; 0)
&#123;
	unsigned long long delta &#x3D; now - next-&gt;timestamp;
	if(next-&gt;activated &#x3D;&#x3D; 1)
		delta &#x3D; (delta * 38) &#x2F; 128;
	array &#x3D; next-&gt;array;
	dequeue_task(next, task);
	recalc_task_prio(next, next-&gt;timestamp + delta);&#x2F;&#x2F; 内部会用参数2 - 参数1的timestamp字段计算平均睡眠时间
&#125;
enqueue_task(next, array);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调度程序把被中断处理程序和可延迟函数所唤醒的进程与被系统调用服务例程和内核线程所唤醒的进程区分开来。前一种，调度程序增加全部运行队列等待时间。后一种，它只增加等待时间的部分。交互式进程更可能被异步事件而不是同步事件唤醒。</p>
<h3 id="schedule完成进程切换时操作"><a href="#schedule完成进程切换时操作" class="headerlink" title="schedule完成进程切换时操作"></a>schedule完成进程切换时操作</h3><p>到这里已经完成了目标进程的选择。</p>
<pre class="line-numbers language-none"><code class="language-none">switch_tasks:
	prefetch(next);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>prefetch</code>提示<code>CPU</code>控制单元把<code>next</code>的进程描述符第一部分字段的内容装入硬件高速缓存。替代<code>prev</code>之前，调度程序应完成一些管理工作</p>
<pre class="line-numbers language-none"><code class="language-none">clear_tsk_need_resched(prev);
rcu_qsctr_inc(prev-&gt;thread_info-&gt;cpu);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>clear_tsk_need_resched</code>清除<code>prev</code>的<code>TIF_NEED_RESCHED</code>标志。函数记录<code>CPU</code>正在经历静止状态。<code>schedule</code>还必须基于进程所使用的<code>CPU</code>时间片减少<code>prev</code>的平均睡眠时间</p>
<pre class="line-numbers language-none"><code class="language-none">prev-&gt;sleep_avg -&#x3D; run_time;
if((long)prev-&gt;sleep_avg &lt;&#x3D; 0)
	prev-&gt;sleep_avg &#x3D; 0;
&#x2F;&#x2F; 记录进程失去cpu的时间点
&#x2F;&#x2F; 这样，便能在后续用于记录睡眠了多长时间
prev-&gt;timestamp &#x3D; prev-&gt;last_ran &#x3D; now;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>prev</code>和<code>next</code>很可能是同一个进程：如在当前运行队列中没优先级较高或相等的其他活动进程时，会发生这种情况。</p>
<pre class="line-numbers language-none"><code class="language-none">if(prev &#x3D;&#x3D; next)
&#123;
	spin_unlock_irq(&amp;rq-&gt;lock);
	goto finish_schedule;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>prev</code>和<code>next</code>是不同的进程，进程切换发生。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 目标进程记录开始获得cpu的时间。这样后续就可用来统计运行时间。
next-&gt;timestamp &#x3D; now;
rq-&gt;nr_switches++;
rq-&gt;curr &#x3D; next;
prev &#x3D; context_switch(rq, prev, next);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="context-switch"><a href="#context-switch" class="headerlink" title="context_switch"></a>context_switch</h3><p><code>context_switch</code>建立<code>next</code>的地址空间，进程描述符的<code>active_mm</code>指向进程所使用的内存描述符，<code>mm</code>指向进程所拥有的内存描述符。</p>
<p>内核线程没自己的地址空间，且它的<code>mm</code>置为<code>NULL</code>。<code>context_switch</code>确保，如<code>next</code>是一个内核线程，使用<code>prev</code>的地址空间。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 表明next是一个内核线程
if(!next-&gt;mm)
&#123;
	&#x2F;&#x2F; 保持之前active_mm 
	next-&gt;active_mm &#x3D;&#x3D; prev-&gt;active_mm;
	atomic_inc(&amp;prev-&gt;active_mm-&gt;mm_count);
	&#x2F;&#x2F; 进入懒惰TLB
	enter_lazy_tlb(prev-&gt;active_mm, next);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果<code>next</code>是内核线程，<code>schedule</code>把进程设置为懒惰<code>TLB</code>模式。如<code>next</code>是一个普通进程，<code>context_switch</code>用<code>next</code>的地址空间替换<code>prev</code>的。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 表明next是一个普通进程
if(next-&gt;mm)
	switch_mm(prev-&gt;active_mm, next-&gt;mm, next);&#x2F;&#x2F; 完成页表切换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如<code>prev</code>是内核线程或正退出的进程，<code>context_switch</code>就把指向<code>prev</code>内存描述符的指针保存到运行队列的<code>prev_mm</code>，重新设置<code>prev-&gt;active_mm</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 之前是内核线程
if(!prev-&gt;mm)
&#123;
	rq-&gt;prev_mm &#x3D; prev-&gt;active_mm;
	prev-&gt;active_mm &#x3D; NULL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在，<code>context_switch</code>终于可调<code>switch_to</code>执行<code>prev</code>和<code>next</code>之间的进程切换了。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 设置寄存器，栈，执行流程切换
switch_to(prev, next, prev);
&#x2F;&#x2F; 表示被换出进程恢复执行
return prev;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="进程切换后schedule所执行的操作"><a href="#进程切换后schedule所执行的操作" class="headerlink" title="进程切换后schedule所执行的操作"></a>进程切换后schedule所执行的操作</h3><p>稍后调度程序又选择<code>prev</code>执行时由<code>prev</code>执行。然而，那个时刻，<code>prev</code>局部变量并不指向我们开始描述<code>schedule</code>时所替换出去的原来那个进程，而是指向<code>prev</code>被调度时由<code>prev</code>替换出的原来那个进程。</p>
<pre class="line-numbers language-none"><code class="language-none">barrier();
finish_task_switch(prev);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>finish_task_switch</code>函数：</p>
<pre class="line-numbers language-none"><code class="language-none">mm &#x3D; this_rq()-&gt;prev-&gt;mm;
this_rq()-&gt;prev_mm &#x3D; NULL;
prev_task_flags &#x3D; prev-&gt;flags;
spin_unlock_irq(&amp;this_rq()-&gt;lock);
if(mm)
	mmdrop(mm);
if(prev_task_flags &amp; PF_DEAD)
	put_task_struct(prev);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如<code>prev</code>是一个内核线程，则运行队列的<code>prev_mm</code>字段存放借给<code>prev</code>的内存描述符的地址。<code>mmdrop</code>减少内存描述符的使用计数器；如计数器等于<code>0</code>，函数还需释放与页表相关的所有描述符和虚拟存储区。<code>finish_task_switch</code>函数还要释放运行队列的自旋锁并打开本地中断。检查<code>prev</code>是否是一个正在从系统中被删除的僵死任务。如是，就调<code>put_task_struct</code>以释放进程描述符引用计数器，并撤销所有其余对该进程的引用。</p>
<pre class="line-numbers language-none"><code class="language-none">finish_schedule:
	prev &#x3D; current;
	if(prev-&gt;lock_depth &gt;&#x3D; 0)
		__reacquire_kernel_lock();
	preempt_enable_no_resched();
	if(test_bit(TIF_NEED_RESCHED, &amp;current_thread_info()-&gt;flags))
		goto need_resched;
	return;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>schedule</code>在需要时重新获得大内核锁，重新启用内核抢占。并检查是否一些其他的进程已设置了当前进程的<code>TIF_NEED_RESCHED</code>。如是，整个<code>schedule</code>重新执行。如否，结束</p>
<h3 id="多处理器系统中运行队列的平衡"><a href="#多处理器系统中运行队列的平衡" class="headerlink" title="多处理器系统中运行队列的平衡"></a>多处理器系统中运行队列的平衡</h3><p>(1). 标准的多处理器体系结构<br>这些机器所共有的<code>RAM</code>芯片集被所有<code>CPU</code>共享<br>(2). 超线程<br>当前线程在访问内存的间隙，处理器可使用它的机器周期去执行另一个线程。一个物理<code>CPU</code>包含多个逻辑<code>CPU</code>。<br>(3). <code>NUMA</code><br>把<code>CPU</code>和<code>RAM</code>以本地”节点”为单位分组。通常一个节点包括一个<code>CPU</code>和几个<code>RAM</code>芯片。<br>内存仲裁器（一个使系统中的<code>CPU</code>以串行方式访问<code>RAM</code>的专用电路）是典型的多处理器系统的性能瓶颈。<br>在<code>NUMA</code>体系结构中，当<code>CPU</code>访问与它同在一个节点中的”本地”<code>RAM</code>芯片时，几乎没有竞争，因此访问通常很快。<br>另一方面，访问其所属节点外的”远程”<code>RAM</code>芯片就非常慢。</p>
<p>这些基本的多处理器系统类型经常被组合使用。如，内核把一个包括两个不同超线程<code>CPU</code>的主板看作四个逻辑<code>CPU</code>。<code>schedule</code>从本地<code>CPU</code>的运行队列挑选新进程运行。一个指定的<code>CPU</code>只能执行其相应的运行队列中的可运行进程。一个可运行进程总是存放在某一个运行队列中：任何一个可运行进程都不可能同时出现在两个或多个运行队列。</p>
<p>某些情况下，把可运行进程限制在一个指定的<code>CPU</code>上可能引起严重的性能损失。如考虑频繁使用<code>CPU</code>的大量批处理进程：如它们绝大多数都在同一个运行队列中，则系统中的一个<code>CPU</code>将会超负荷。而其他一些<code>CPU</code>几乎处于空闲状态。故，内核周期性地检查运行队列的工作量是否平衡，并在需要的时候，把一些进程从一个运行队列迁移到另一个运行队列。但为了从多处理系统获得最佳性能，负载平衡算法应考虑系统中<code>CPU</code>的拓扑结构。从内核<code>2.6.</code>7开始，<code>Linux</code>提出一种基于”调度域”概念的复杂的运行队列平衡算法。有了调度域概念，使得这种算法很容易适应各种已有的多处理器体系结构。</p>
<h3 id="调度域"><a href="#调度域" class="headerlink" title="调度域"></a>调度域</h3><p>调度域实际上是一个<code>CPU</code>集合，它们的工作量应由内核保持平衡。一般，调度域采取分层的组织形式：最上层的调度域（通常包括系统中的所有<code>CPU</code>）包括多个子调度域，每个子调度域包括一个<code>CPU</code>子集。正是调度域的这种分层结构，使工作量的平衡能以如下有效方式来实现。</p>
<p>每个调度域被依次划分成一个或多个组，每个组代表调度域的一个<code>CPU</code>子集。工作量的平衡总是在调度域的组之间来完成。只有在调度域的某个组的总工作量远远低于同一个调度域的另一个组的工作量时，才把进程从一个<code>CPU</code>迁移到另一个<code>CPU</code>。<br>(1). <code>2-CPU</code>的<code>SMP</code><br>基本域（<code>0</code>级）：<br>有两个组，每组一个<code>CPU</code><br>(2). <code>2-CPU</code>，有超线程的<code>SMP</code><br>一级域：<br>有两个组，每组一个物理<code>CPU</code><br>基本域（<code>0</code>级）：<br>有两个组，每组一个逻辑<code>CPU</code><br>(3). <code>8-CPU</code>的<code>NUMA</code>（每个节点有四个<code>CPU</code>）<br>一级域：<br>有两个组，每组一个节点<br>基本域（<code>0</code>级）：<br>有四个组，每组1个CPU</p>
<p>每个调度域由一个<code>sched_domain</code>表示。调度域中的每个组由<code>sched_group</code>表示。每个<code>sched_domain</code>包括一个<code>groups</code>字段，它指向组描述符链表中的第一个元素。此外，<code>sched_domain</code>结构的<code>parent</code>指向父调度域的描述符。系统中所有物理<code>CPU</code>的<code>sched_domain</code>都存放在每<code>CPU</code>变量<code>phys_domains</code>中。</p>
<p>如内核不支持超线程技术，这些域就在域层次结构的最底层，运行队列描述符的<code>sd</code>字段指向它们，即它们是基本调度域。相反，如内核支持超线程技术，则底层调度域存放在每<code>CPU</code>变量<code>cpu_domains</code>中。</p>
<h3 id="rebalance-tick"><a href="#rebalance-tick" class="headerlink" title="rebalance_tick"></a>rebalance_tick</h3><p>为保持系统中运行队列的平衡，每经过一次时钟节拍，<code>scheduler_tick</code>就调用<code>rebalance_tick</code>。它接收参数有：本地<code>CPU</code>的下标<code>this_cpu</code>，本地运行队列的地址<code>this_rq</code>，一个标志<code>idle</code>，该标志可取下面值：<br>(1). <code>SCHED_IDLE</code><br><code>CPU</code>当前空闲，即<code>current</code>是<code>swapped</code>进程<br>(2). <code>NOT_IDLE</code><br><code>CPU</code>当前不空闲，即<code>current</code>不是<code>swapper</code>进程</p>
<p><code>rebalance_tick</code>先确定运行队列中的进程数，更新运行队列的平均工作量，为完成此工作。函数要访问运行队列描述符的<code>nr_running</code>和<code>cpu_load</code>。最后，<code>rebalance_tick</code>开始在所有调度域上的循环，其路径是从基本域（本地运行队列描述符的<code>sd</code>字段所引用的域）到最上层的域。每次循环中，函数确定是否已到调用函数<code>load_balance</code>的时间，从而在调度域上执行重新平衡的操作。</p>
<p>由存放在<code>sched_domain</code>描述符中的参数和<code>idle</code>值决定调用<code>load_balance</code>的频率。如<code>idle</code>等于<code>SCHED_IDLE</code>，则运行队列为空。<code>rebalance_tick</code>就以很高的频率调<code>load_balance</code>。大概每一到两个节拍处理一次对应于逻辑和物理<code>CPU</code>的调度域。如<code>idle</code>等于<code>NOT_IDLE</code>，<code>rebalance_tick</code>就以很低的频率调度<code>load_balance</code>。大概每<code>10ms</code>处理一次逻辑<code>CPU</code>对应的调度域，每<code>100ms</code>处理一次物理<code>CPU</code>对应的调度域。</p>
<h3 id="load-balance"><a href="#load-balance" class="headerlink" title="load_balance"></a>load_balance</h3><p>检查是否调度域处于严重的不平衡状态。它检查是否可通过把最繁忙的组中的一些进程迁移到本地<code>CPU</code>的运行队列来减轻不平衡的状况。如是，函数尝试实现这个迁移。它接收四个参数：<br>(1). <code>this_cpu</code><br>本地<code>CPU</code>的下标<br>(2). <code>this_rq</code><br>本地运行队列的描述符的地址<br>(3). <code>sd</code><br>指向被检查的调度域的描述符<br>(4). <code>idle</code><br>取值为<code>SCHED_IDLE</code>(本地<code>CPU</code>空闲)或<code>NOT_IDLE</code></p>
<p>函数执行下面的操作：<br>(1). 获得<code>this_rq-&gt;lock</code><br>(2). 调<code>find_busiest_group</code>分析调度域中各组的工作量。<br>函数返回最繁忙组的<code>sched_group</code>描述符的地址，假设这个组不包括本地<code>CPU</code>，此时，函数还返回为了恢复平衡而被迁移到本地运行队列的进程数。另一方面，如最繁忙的组包括本地<code>CPU</code>或所有组本来就是平衡的，函数返回<code>NULL</code>。<br>(3). 如<code>find_busiest_group</code>在调度域中没找到既不包括本地<code>CPU</code>又非常繁忙的组，就释放<code>this_rq-&gt;lock</code>，调整调度域描述符的参数，以延迟本地<code>CPU</code>下一次对<code>load_balance</code>的调度，函数终止。<br>(4). 调<code>find_busiest_queue</code>以查找<code>2</code>中找到的组中最繁忙的<code>CPU</code>，函数返回相应运行队列的描述符地址<code>busiest</code>。</p>
<p>(5). 获取另一自旋锁，即<code>busiest-&gt;lock</code>。为避免死锁，先释放<code>this_rq-&gt;lock</code>，通过增加<code>CPU</code>下标获得这两个锁<br>(6). 调<code>move_tasks</code>，尝试从最繁忙运行队列中把一些进程迁移到本地运行队列<code>this_rq</code><br>(7). 如<code>move_tasks</code>没成功。则调度域还是不平衡。把<code>busiest-&gt;active_balance</code>置为<code>1</code>，唤醒<code>migration</code>内核线程，它的描述符存在<code>busiest-&gt;migration_thread</code>。</p>
<p><code>Migration</code>顺着调度域的链搜索-从最繁忙运行队列的基本域到最上层域，寻找空闲<code>CPU</code>。如找到，该内核线程就调<code>move_tasks</code>把一个进程迁移到空闲运行队列。<br>(8). 释放<code>busiest-&gt;lock</code>和<code>this_rq-&gt;lock</code><br>(9). 结束。</p>
<h3 id="move-tasks"><a href="#move-tasks" class="headerlink" title="move_tasks"></a>move_tasks</h3><p>把进程从源运行队列迁移到本地运行队列。接收<code>6</code>个参数：<br>(1). <code>this_rq</code><br>(2). <code>this_cpu</code><br>(3). <code>busiest</code><br>(4). <code>max_nr_move</code><br>(5). <code>sd</code><br>(6). <code>idle</code></p>
<p>函数先分析<code>busiest</code>运行队列的过期进程，从优先级高的进程开始，扫描完所有过期进程后，扫描<code>busiest</code>运行队列的活动进程。对所有的候选进程调<code>can_migrate_task</code>。如下列条件都满足，则<code>can_migrate_task</code>返回<code>1</code>：<br>(1). 进程当前没在远程<code>CPU</code>上执行<br>(2). 本地<code>CPU</code>包含在进程描述符的<code>cpus_allowed</code>位掩码<br>(3). 至少满足下列条件之一<br>(3.1). 本地<code>CPU</code>空闲。如内核支持超线程，则所有本地物理芯片中的逻辑<code>CPU</code>必须空闲。<br>(3.2). 内核在平衡调度域时因反复进行进程迁移都不成功陷入困境。<br>(3.3). 被迁移的进程不是”高速缓存命中”的（最近不曾在远程<code>CPU</code>上执行，可设想远程<code>CPU</code>上的硬件高速缓存中没该进程的数据）</p>
<p>如<code>can_migrate_task</code>返回<code>1</code>，<code>move_tasks</code>调<code>pull_task</code>把候选进程迁移到本地运行队列。<code>pull_tasks</code>执行<code>dequeue_task</code>从远程队列删除进程，执行<code>enqueue_task</code>把进程插入本地运行队列。如刚被迁移的进程比当前进程拥有更高的动态优先级，就调<code>resched_task</code>抢占本地<code>CPU</code>的当前进程。</p>
<h2 id="与调度相关的系统调用"><a href="#与调度相关的系统调用" class="headerlink" title="与调度相关的系统调用"></a>与调度相关的系统调用</h2><h3 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h3><p>允许进程改变它们的基本优先级，负增加下，调<code>capable</code>核实进程是否有<code>CAP_SYS_NICE</code>。且，函数调<code>security_task_setnice</code>安全钩。</p>
<h3 id="getpriority和setpriority"><a href="#getpriority和setpriority" class="headerlink" title="getpriority和setpriority"></a>getpriority和setpriority</h3><p><code>nice</code>只影响调用它的进程，<code>getpriority</code>和<code>setpriority</code>作用于给定组中所有进程的基本优先级。<code>getpriority</code>返回<code>20</code>减去组中所有进程之中最低<code>nice</code>字段的值；<code>setpriority</code>把给定组中所有进程的基本优先级都设置为一个给定的值。内核对这两个系统调用的实现是通过<code>sys_getpriority</code>和<code>sys_setpriority</code>完成的。<br><code>which</code> ：指定进程组的值。</p>
<blockquote>
<p>a. <code>PRIO_PROCESS</code><br>根据进程的<code>ID</code>选择进程<br>b. <code>PRIO_PGRP</code><br>根据组<code>ID</code>选择进程<br>c. <code>PRIO_USER</code><br>根据用户<code>ID</code>选择进程<br>d. <code>who</code><br>用<code>pid，pgrp</code>或<code>uid</code>字段的值（取决于<code>which</code>的值）选择进程。<br>如<code>who</code>是<code>0</code>，把它的值置为<code>current</code>进程相应字段的值。<br>e. <code>niceval</code><br>新的基本优先级值。取值范围在`-20~+19</p>
</blockquote>
<h3 id="sched-getaffinity和sched-setaffinity"><a href="#sched-getaffinity和sched-setaffinity" class="headerlink" title="sched_getaffinity和sched_setaffinity"></a>sched_getaffinity和sched_setaffinity</h3><p>返回和设置<code>CPU</code>进程亲和力掩码、即允许执行进程的<code>CPU</code>的位掩码。该掩码放在进程描述符的<code>cpus_allowed</code>字段。</p>
<h3 id="与实时进程相关的系统调用"><a href="#与实时进程相关的系统调用" class="headerlink" title="与实时进程相关的系统调用"></a>与实时进程相关的系统调用</h3><p>进程为了修改任何进程的描述符的<code>rt_priority</code>和<code>policy</code>，必须具有<code>CAP_SYS_NICE</code>权能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>调用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sched_getscheduler</code></td>
<td>查询由<code>pid</code>所表示的进程当前所用的调度策略。如<code>pid</code>等于<code>0</code>，将检索调用进程的策略。如成功，这个系统调用为进程返回策略：<code>SCHED_FIFO</code>，<code>SCHED_RR</code>或<code>SCHED_NORMAL</code>。相应的<code>sys_sched_getscheduler</code>调<code>find_task_by_pid</code>，后一函数确定给<code>pid</code>所对应的进程描述符，并返回其<code>policy</code>字段值。</td>
</tr>
<tr>
<td><code>sched_setscheduler</code></td>
<td>既设置调度策略，也设置由<code>pid</code>所表示进程的相关参数。如<code>pid</code>等于<code>0</code>，调用进程的调度程序参数将被设置。相应的<code>sys_sched_setscheduler</code>简单地调<code>do_sched_setscheduler</code>。后者检查由<code>policy</code>指定的调度策略和由参数<code>param-&gt;sched_priority</code>指定的新优先级是否有效。还检查进程是否有<code>CAP_SYS_NICE</code>。或进程的拥有者是否有超级用户权限。<br>如每个条件都满足，就把进程从它的运行队列中删除；更新进程的静态优先级，实时优先级，动态优先级；把进程插回到运行队列；在需要的情况下，调<code>resched_task</code>抢占运行队列的当前进程。</td>
</tr>
<tr>
<td><code>sched_getparam</code></td>
<td>系统调用<code>sched_getparam</code>为pid所表示的进程检索调度参数，如果pid是0，则current进程的参数被检索！正如所期望的，相应的<code>sys_sched_getparam()</code>服务例程找到与pid相关的进程描述指针，把它的<code>rt_priority</code>字段放在了字类型为<code>sched_param</code>的局部变量中，并且调用copy to user把它拷贝到进程地址空间由param参数指定的地址</td>
</tr>
<tr>
<td><code>sched_setparam</code></td>
<td>这个系统调用类似于<code>sched_setscheduler</code>，它与后者的不同在于不让调用者设置policy字段的值！相应的sys_sched_set_prama服务例程几乎与<code>do_sched_setscheduler</code>相同的参数调用</td>
</tr>
<tr>
<td><code>sched_yield</code></td>
<td>允许进程在不被挂起的情况下自愿放弃<code>CPU</code>，进程仍处于<code>TASK_RUNNING</code>，但调度程序把它放在运行队列的过期进程集合中，或放在运行队列链表的末尾。随后调<code>schedule</code>。这种方式下，有相同动态优先级的其他进程将有机会运行。</td>
</tr>
<tr>
<td><code>sched_get_priority_min</code></td>
<td><code>current</code>是实时进程，则<code>sys_sched_get_priority_min</code>返回<code>1</code>。否则，返回<code>0</code>；如<code>current</code>是实时进程，则<code>sys_sched_get_priority_max</code>返回<code>99</code>，否则，返回<code>0</code>；</td>
</tr>
<tr>
<td><code>sched_get_priority_max</code></td>
<td><code>current</code>是实时进程，则<code>sys_sched_get_priority_min</code>返回<code>1</code>。否则，返回<code>0</code>；如<code>current</code>是实时进程，则<code>sys_sched_get_priority_max</code>返回<code>99</code>，否则，返回<code>0</code>；</td>
</tr>
<tr>
<td><code>sched_rr_get_interval</code></td>
<td>把参数<code>pid</code>表示的实时进程的轮转时间片写入用户态地址空间的一个结构中。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Reference-5"><a href="#Reference-5" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/x13262608581/article/details/131908901">深入理解Linux内核-进程-进程调度_sched_setscheduler-CSDN博客</a></p>
</blockquote>
<h1 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h1><p>​    RAM中，剩下的自由部分被称为动态内存！因为这不仅是内进程所需要的宝贵资源，也是内核执行本身所需要的宝贵资源！实际上整个系统的性能都高度取决于如何有效的管理动态内存！因此内存管理是操作系统中非常重要的话题之一！</p>
<h2 id="页框管理"><a href="#页框管理" class="headerlink" title="页框管理"></a>页框管理</h2><p>​    <code>Intel</code>的<code>Pentinum</code>处理器可采用两种<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=不同的&amp;spm=1001.2101.3001.7020">不同的</a>页框大小：<code>4KB，4MB</code>（如<code>PAE</code>被激活，则为<code>2MB</code>）。<code>Linux</code>采用<code>4KB</code>页框大小作为标准的内存分配单元。</p>
<ol>
<li>由分页单元引发的缺页异常很容易得到解释，或由于请求的页存在但不允许进程对其访问，或由于请求的页不存在。第二种情况下，内存分配器必须找到一个4KB的空闲页框，并将其分配给进程。</li>
<li>虽然<code>4KB，4MB</code>都是磁盘块大小的倍数，但绝大多数情况下，当主存和磁盘之间传输小块数据时更高效。</li>
</ol>
<h3 id="页描述符"><a href="#页描述符" class="headerlink" title="页描述符"></a>页描述符</h3><p>​    内核必须记录每个页框当前的状态。<strong>内核必须能区分哪些页框包含的是属于进程的页，哪些页框包含的是内核代码或内核数据。类似地，内核还必须能确定动态内存中的页框是否空闲。</strong>页框的状态信息保存在一个类型为<code>page</code>的页描述符中，其中的字段如表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned long</td>
<td>flags</td>
<td>一组标志。对页框所在的管理区进行编号。</td>
</tr>
<tr>
<td>atomic_t</td>
<td>_count</td>
<td>页框的引用计数器</td>
</tr>
<tr>
<td>atomic_t</td>
<td>_mapcount</td>
<td>页框中的页表项数量（没有则为-1）</td>
</tr>
<tr>
<td>unsigned long</td>
<td>private</td>
<td>可用于正使用页的内核成分</td>
</tr>
<tr>
<td>struct address_space*</td>
<td>mapping</td>
<td>当页被插入页高速缓存时使用。或当页属于匿名区时使用。</td>
</tr>
<tr>
<td>unsigned long</td>
<td>index</td>
<td>作为不同的含义被几种内核成分使用。</td>
</tr>
<tr>
<td>struct list_head</td>
<td>lru</td>
<td>包含页的最近最少使用双向链表的指针</td>
</tr>
</tbody>
</table>
</div>
<p>所有的页描述符存放在<code>mem_map</code>数组中。<code>mem_map</code>所需要的空间略小于整个<code>RAM</code>的<code>1%</code>。</p>
<blockquote>
<p><code>virt_to_page(addr)</code>宏产生线性地址addr对应的页描述符地址。<br><code>pfn_to_page(pfn)</code>宏产生与页框号pfn对应的页描述符地址。</p>
</blockquote>
<p>​    上述转换可行是因为内核知道页描述符数组起始线性地址，<strong>通过线性地址得到物理地址，通过物理地址得到页框在数组索引。进而定位到页描述符地址</strong>。</p>
<p>让我们较详细地描述以下两个字段：</p>
<blockquote>
<p><code>_count</code>：<strong>页的引用计数器。如字段为<code>-1</code>，则相应页框空闲</strong>，并可被分配给任一进程或内核本身。如该字段值大于或等于<code>0</code>，则说明页框被分配给了一个或多个进程，或用于存放一些内核数据结构。<code>page_count</code>返回<code>__count</code>加<code>1</code>后的值，即该页的使用者的数目。<br><code>flags</code>：包含多达<code>32</code>个用来描述页框状态的标志。对每个<code>PG_xyz</code>标志，内核都定义了操纵其值的一些宏。通常，<code>PageXyz</code>宏返回标志的值，<code>SetPageXyz</code>和<code>ClearPageXyz</code>宏分别设置和清除相应的位。</p>
</blockquote>
<p>​    下表正是常见的页框状态的标签：可以一览：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>PG_locked</td>
<td>页被锁住。如，在磁盘I/O操作中涉及的页</td>
</tr>
<tr>
<td>PG_error</td>
<td>在传输页时发生I/O错误</td>
</tr>
<tr>
<td>PG_referenced</td>
<td>刚刚访问过的页</td>
</tr>
<tr>
<td>PG_uptodate</td>
<td>在完成读操作后置位，除非发生磁盘I/O错误</td>
</tr>
<tr>
<td>PG_dirty</td>
<td>页已经被修改</td>
</tr>
<tr>
<td>PG_lru</td>
<td>页在活动或非活动页链表中</td>
</tr>
<tr>
<td>PG_active</td>
<td>页在活动页链表中</td>
</tr>
<tr>
<td>PG_highmem</td>
<td>页框属于ZONE_HIGHMEM管理区</td>
</tr>
<tr>
<td>PG_checked</td>
<td>由一些文件系统使用的标志</td>
</tr>
<tr>
<td>PG_arch_1</td>
<td>在80x86体系结构上没有使用</td>
</tr>
<tr>
<td>PG_reserved</td>
<td>页框留给内核代码或没有使用</td>
</tr>
<tr>
<td>PG_private</td>
<td>页描述符的private字段存放了有意义的数据</td>
</tr>
<tr>
<td>PG_writeback</td>
<td>正使用writeback方法将页写到磁盘上</td>
</tr>
<tr>
<td>PG_nosave</td>
<td>系统挂起、唤醒时使用</td>
</tr>
<tr>
<td>PG_compound</td>
<td>通过扩展分页机制处理页框</td>
</tr>
<tr>
<td>PG_swapcache</td>
<td>页属于对换高速缓存</td>
</tr>
<tr>
<td>PG_mappedtodisk</td>
<td>页框中的所有数据对应于磁盘上分配的块</td>
</tr>
<tr>
<td>PG_reclaim</td>
<td>为回收内存对页已经做了写入磁盘的标记</td>
</tr>
<tr>
<td>PG_nosave_free</td>
<td>系统挂起、恢复时使用</td>
</tr>
</tbody>
</table>
</div>
<h2 id="UMA和NUMA"><a href="#UMA和NUMA" class="headerlink" title="UMA和NUMA"></a>UMA和NUMA</h2><p>​    习惯上，认为计算机内存是一种均匀，共享的资源。在忽略硬件高速缓存作用的情况下，期望不管内存单元处于何处，<code>CPU</code>处于何处，<code>CPU</code>对内存单元的访问都需相同的时间（UMA）。可惜，这些假设在某些体系结构上并不总是成立。如，对某些多处理器<code>Alpha</code>或<code>MIPS</code>计算机，就不成立。<code>Linux2.6</code>支持非一致内存访问模型，在这种模型中，给定<code>CPU</code>对不同内存单元的访问时间可能不一样。系统的物理内存被划分为几个节点（<code>node</code>）。节点既封装了内存资源，也封装了<code>CPU</code>资源。在一个单独的节点内，任一给定<code>CPU</code>访问页面所需的时间都是相同的。然而， 对不同<code>CPU</code>，这个时间可能就不同。这就是NUMA的特性！</p>
<p>​    对每个<code>CPU</code>而言，内核都试图把耗时节点的访问次数减到最少，这就要小心地选择<code>CPU</code>最常引用的内核数据结构的存放位置。每个节点中的物理内存又可分为几个管理区。每个节点都有一个类型为<code>pg_data_t</code>的描述符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct zone[]</td>
<td>node_zones</td>
<td>节点中管理区描述符的数组</td>
</tr>
<tr>
<td>struct zonelist[]</td>
<td>node_zonelists</td>
<td>页分配器使用的zonelist数据结构的数组</td>
</tr>
<tr>
<td>int</td>
<td>nr_zones</td>
<td>节点中管理区的个数</td>
</tr>
<tr>
<td>struct page*</td>
<td>node_mem_map</td>
<td>节点中页描述符的数组</td>
</tr>
<tr>
<td>struct bootmem_data*</td>
<td>bdata</td>
<td>用在内核初始化阶段</td>
</tr>
<tr>
<td>unsigned long</td>
<td>node_start_pfn</td>
<td>节点中第一个页框的下标</td>
</tr>
<tr>
<td>unsigned long</td>
<td>node_present_pages</td>
<td>内存节点的大小，不包含洞（以页框为单位）</td>
</tr>
<tr>
<td>unsigned long</td>
<td>node_spanned_pages</td>
<td>节点的大小，包括洞（以页框为单位）</td>
</tr>
<tr>
<td>int</td>
<td>node_id</td>
<td>节点标识符</td>
</tr>
<tr>
<td>pg_data_t*</td>
<td>pgdat_next</td>
<td>节点内存链表中的下一项</td>
</tr>
<tr>
<td>wait_queue_head_t</td>
<td>kswapd_wait</td>
<td>kswapd页换出守护进程使用的等待队列</td>
</tr>
<tr>
<td>struct task_struct*</td>
<td>kswapd</td>
<td>指针指向kswapd内核线程的进程描述符</td>
</tr>
<tr>
<td>int</td>
<td>kswapd_max_order</td>
<td>kswapd将要创建的空闲块大小取对数的值</td>
</tr>
</tbody>
</table>
</div>
<p>​    同样，我们只关注<code>80x86</code>。<code>IBM</code>兼容<code>PC</code>使用一致内存访问模型，因此，并不真正需要<code>NUMA</code>的支持。然而，即使<code>NUMA</code>的支持没有编译进内核，<code>Linux</code>还是使用节点。不过，这是一个单独的节点，它包含了系统中所有的物理内存。此时，<code>pgdat_list</code>指向一个链表，此链表是由一个元素组成的。这个元素就是节点<code>0</code>描述符，它被存放在<code>config_page_data</code>。在<code>80x86</code>结构中，把物理内存分组在一个单独的节点中可能显得没用处；但这种方式有助于内核代码的处理具有可移植性。</p>
<h3 id="内存管理区"><a href="#内存管理区" class="headerlink" title="内存管理区"></a>内存管理区</h3><p>​    在一个理想的计算机体系结构中，一个页框就是一个内存存储单元，可用于任何事情：存放内核数据和用户数据，缓冲磁盘数据等等。任何种类的数据页都可存放在任何页框中。但实际的计算机体系结构有硬件的制约，这限制了页框可使用的方式。尤其是，<code>Linux</code>内核必须处理<code>80x86</code>体系结构的两种硬件约束：</p>
<ol>
<li><code>ISA</code>总线的直接内存存取（<code>DMA</code>）处理器有一个严格的限制：它们只能对<code>RAM</code>的前<code>16MB</code>寻址、</li>
<li>在具有大容量<code>RAM</code>的现代<code>32</code>位计算机中，<code>CPU</code>不能直接访问所有的物理内存，因为线性地址空间太小。</li>
</ol>
<p>为应对这两种限制，<code>Linux2.6</code>把每个内存节点的物理内存划分为三个管理区。在<code>80x86UMA</code>体系结构中的管理区为：</p>
<blockquote>
<p><code>ZONE_DMA</code>：包含低于<code>16MB</code>的内存页框<br><code>ZONE_NORMAL</code>：包含高于<code>16MB</code>且低于<code>896MB</code>的内存页框<br><code>ZONE_HIGHMEM</code>：包含从<code>896MB</code>开始高于<code>896MB</code>的内存页框</p>
</blockquote>
<p><code>ZONE_DMA</code>区包含的页框可由老式基于<code>ISA</code>的设备通过<code>DMA</code>使用。<code>ZONE_DMA</code>和<code>ZONE_NORMAL</code>区包含内存的”常规”页框，通过把它们直接映射到线性地址空间的第4个GB，内核就可直接进行访问。相反，<code>ZONE_HIGHMEM</code>区包含的内存页不能由内核直接访问，尽管它们页线性地映射到了线性地址空间的第4个GB。在64位体系结构上，<code>ZONE_HIGHMEM</code>区总是空的。</p>
<p>每个内存管理区都有自己的描述符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned long</td>
<td>free_pages</td>
<td>管理区中空闲页的数目</td>
</tr>
<tr>
<td>unsigned long</td>
<td>pages_min</td>
<td>管理区中保留页的数目</td>
</tr>
<tr>
<td>unsigned long</td>
<td>pages_low</td>
<td>回收页框使用的下界；同时也被管理区分配器作为阀值使用</td>
</tr>
<tr>
<td>unsigned long</td>
<td>pages_high</td>
<td>回收页框使用的上届；同时也被管理区分配器作为阀值使用</td>
</tr>
<tr>
<td>unsigned long[]</td>
<td>lowmem_reserve</td>
<td>指明在处理内存不足的临界情况下每个管理区必须保留的页框数目</td>
</tr>
<tr>
<td>struct per_cpu_pageset[]</td>
<td>pageset</td>
<td>用于实现单一页框的特殊高速缓存</td>
</tr>
<tr>
<td>spinlock_t</td>
<td>lock</td>
<td>保护该描述符的自旋锁</td>
</tr>
<tr>
<td>struct free_area[]</td>
<td>free_area</td>
<td>标识出管理区的空闲页框块</td>
</tr>
<tr>
<td>spinlock_t</td>
<td>lru_lock</td>
<td>活动以及非活动链表使用的自旋锁</td>
</tr>
<tr>
<td>struct list_head</td>
<td>active_list</td>
<td>管理区中的活动页链表</td>
</tr>
<tr>
<td>struct list_head</td>
<td>inactive_list</td>
<td>管理区中的非活动页链表</td>
</tr>
<tr>
<td>unsigned long</td>
<td>nr_scan_active</td>
<td>回收内存时需扫描的活动页数目</td>
</tr>
<tr>
<td>unsigned long</td>
<td>nr_scan_inactive</td>
<td>回收内存时需扫描的非活动页数目</td>
</tr>
<tr>
<td>unsigned long</td>
<td>nr_active</td>
<td>管理区的活动链表上的页数目</td>
</tr>
<tr>
<td>unsigned long</td>
<td>nr_inactive</td>
<td>管理区的非活动链表上的页数目</td>
</tr>
<tr>
<td>unsigned long</td>
<td>pages_scanned</td>
<td>管理区内回收页框时使用的计数器</td>
</tr>
<tr>
<td>int</td>
<td>all_unreclaimable</td>
<td>在管理区中填满不可回收页时此标志被置位</td>
</tr>
<tr>
<td>int</td>
<td>temp_priority</td>
<td>临时管理区的优先级</td>
</tr>
<tr>
<td>int</td>
<td>prev_priority</td>
<td>管理区优先级，范围在12和0之间</td>
</tr>
<tr>
<td>wait_queue_head_t*</td>
<td>wait_table</td>
<td>进等待队列的散列表，这些进程正在等待管理区中的某页</td>
</tr>
<tr>
<td>unsigned long</td>
<td>wait_table_size</td>
<td>等待队列散列表的大小</td>
</tr>
<tr>
<td>unsigned long</td>
<td>wait_table_bits</td>
<td>等待队列散列表数组大小，值为2^order</td>
</tr>
<tr>
<td>struct pglist_data*</td>
<td>zone_pgdat</td>
<td>内存节点</td>
</tr>
<tr>
<td>struct page*</td>
<td>zone_mem_map</td>
<td>指向管理区的第一个页描述符的指针</td>
</tr>
<tr>
<td>unsigned long</td>
<td>zone_start_pfn</td>
<td>管理区第一个页框的下标</td>
</tr>
<tr>
<td>unsigned long</td>
<td>spanned_pages</td>
<td>以页为单位的管理区的总大小，包括洞</td>
</tr>
<tr>
<td>unsigned long</td>
<td>present_pages</td>
<td>以页为单位的管理区的总大小，不包括洞</td>
</tr>
<tr>
<td>char*</td>
<td>name</td>
<td>指针指向管理区的传统名称：“DMA”，“NORMAL”，“HighMem”</td>
</tr>
</tbody>
</table>
</div>
<p>​    每个页描述符都有到内存节点和节点内管理区的链接。为节省空间，这些链接被编码成索引存放在<code>flags</code>字段的高位。实际上，刻画页框的标志的数目是有限的。保留flags字段的最高位来编码特定内存节点和管理区号总是可能的。<code>page_zone</code>接收一个页描述符的地址作为它的参数，它读取页描述符中<code>flags</code>字段的最高位，然后通过查看<code>zone_table</code>数组来确定相应管理区描述符的地址。在启动时用所有内存节点的所有管理区描述符的地址初始化这个数组。</p>
<p>​    当内核调一个内存分配函数时，必须指明请求页框所在的管理区。内核通常指明它愿意使用哪个管理区。为了在内存分配请求中指定首选管理区，内核使用<code>zonelist</code>数据结构，这就是管理区描述符指针数组。</p>
<h3 id="保留的页框池"><a href="#保留的页框池" class="headerlink" title="保留的页框池"></a>保留的页框池</h3><p>​    可用两种不同的方法来满足内存分配请求。如有足够的空闲内存可用，请求就会被立刻满足。否则，必须回收一些内存，且将发出请求的内核控制路径阻塞，直到内存被释放。（<code>NUMA</code>下默认策略是本地节点内内存不足，从本地节点回收内存后再次尝试分配。若选择本地节点内存不足时，优先查看其他节点是否存在足量内存时，若存在从其他节点完成剩余部分分配的方案，在应用需要大内存场景下可能更高效）</p>
<p>​    <strong>当请求内存时</strong>，一些内核控制路径不能被阻塞。比如，这种情况发生在处理中断或执行临界区内的代码时。此时，一条内核控制路径应产生原子内存分配请求。原子请求从不被阻塞：如没有足够的空闲页，则仅仅是分配失败而已。尽管无法保证一个原子内存分配请求决不失败，但内核会设法尽量减少这种不幸事件发生的可能性。为做到这一点，内核为原子内存分配请求保留了一个页框池，只有在内存不足时才使用。</p>
<p>​    保留内存的数量（以<code>KB</code>为单位）存放在<code>min_free_kbytes</code>中。它的初始值在内核初始化时设置，并取决于直接映射到内核线性地址空间的第4个<code>GB</code>的物理内存的数量。即，取决于包含在<code>ZONE_DMA</code>和<code>ZONE_NORMAL</code>内存管理区内的页框数目。这是其公式：</p>
<script type="math/tex; mode=display">
保留池的大小=\sqrt{16*直接映射内存}(KB)</script><p>但<code>min_free_kbytes</code>的初始值不能小于<code>128</code>也不能大于<code>65536</code>。</p>
<p>​    <code>ZONE_DMA</code>和<code>ZONE_NORMAL</code>内存管理区将一定数量的页框贡献给保留内存，这个数目与两个管理区的相对大小成比例。<br>例，如<code>ZONE_NORMAL</code>管理区比<code>ZONE_DMA</code>大<code>8</code>倍，则页框的<code>7/8</code>从<code>ZONE_NORMAL</code>获得。<code>1/8</code>从<code>ZONE_DMA</code>获得。</p>
<p>​    管理区描述符的<code>pages_min</code>存储了管理区内保留页框的数目。这个字段和<code>pages_low，pages_high</code>一起还在页框回收算法中起作用。<code>pages_low</code>总是设为<code>pages_min</code>的值的<code>5/4</code>，<code>pages_high</code>总是被设为<code>pages_min</code>的<code>3/2</code>。</p>
<h3 id="分区页框分配器"><a href="#分区页框分配器" class="headerlink" title="分区页框分配器"></a>分区页框分配器</h3><p>​    分区页框分配器被称作分区页框分配器的内核子系统，处理对连续页框组的内存分配请求。它的主要组成如下：</p>
<p>​    管理区分配器下分给ZONE_DMA内存管理区，ZONE_NORMAL内存管理区，ZONE_HIGHMEM内存管理区。为了更加很合适的分配内存，每一个个管理区又有伙伴系统和Per-CPU页框高速缓存</p>
<p>​    其中，<strong>名为”管理区分配器”部分接受动态内存分配和释放的请求。在请求分配的情况下，该部分搜索一个能满足所请求的一组连续页框内存的管理区。</strong>在每个管理区内，页框被名为”伙伴系统”的部分来处理。为达到更好的系统性能，一小部分页框保留在高速缓存中用于快速地满足对单个页框的分配请求。</p>
<h3 id="请求和释放页框"><a href="#请求和释放页框" class="headerlink" title="请求和释放页框"></a>请求和释放页框</h3><div class="table-container">
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc_pages(gfp_mask, order)</td>
<td>用这个函数请求<code>2^order</code>个连续的页框。它返回第一个所分配页框描述符的地址，或，如分配失败，则返回<code>NULL</code>。</td>
</tr>
<tr>
<td>alloc_page(gfp_mask)</td>
<td>用于获得一个单独页框的宏；扩展为：<code>alloc_pages(gfp_mask, 0)</code>。</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask, order)</td>
<td>类似<code>alloc_pages</code>，返回第一个所分配页的线性地址。</td>
</tr>
<tr>
<td>__get_free_page(gfp_mask)</td>
<td>用于获得一个单独页框的宏；扩展为：__get_free_pages(gfp_mask, 0)</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td>
<td>获取填满0的页框；它调用：`alloc_pages(gfp_mask</td>
<td>__GFP_ZERO, 0);`</td>
</tr>
<tr>
<td>__get_dma_pages(gfp_mask, order)</td>
<td>获得适用于DMA的页框，它扩展为：`__get_free_pages(gfp_mask</td>
<td>__GFP_DMA, order);`</td>
</tr>
</tbody>
</table>
</div>
<p>​    参数<code>gfp_mask</code>是一组标志，指明了如何寻找空闲的页框。能在<code>gfp_mask</code>中使用的标志如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>__GFP_DMA</td>
<td>所请求的页框必须处于ZONE_DMA管理区。等价于GFP_DMA</td>
</tr>
<tr>
<td>__GFP_HIGHMEM</td>
<td>所请求的页框处于ZONE_HIGHMEM管理区。</td>
</tr>
<tr>
<td>__GFP_WAIT</td>
<td>允许内核对等待空闲页框的当前进程进行阻塞</td>
</tr>
<tr>
<td>__GFP_HIGH</td>
<td>允许内核访问保留的页框池</td>
</tr>
<tr>
<td>__GFP_IO</td>
<td>允许内核在低端内存页上执行I/O传输以释放页框</td>
</tr>
<tr>
<td>__GFP_FS</td>
<td>如清0，则不允许内核执行依赖文件系统的操作</td>
</tr>
<tr>
<td>__GFP_COLD</td>
<td>所请求的页框可能为”冷的”</td>
</tr>
<tr>
<td>__GFP_NOWARN</td>
<td>一次内存分配失败将不会产生警告信息</td>
</tr>
<tr>
<td>__GFP_REPEAT</td>
<td>内核重试内存分配直到成功</td>
</tr>
<tr>
<td>__GFP_NOFAIL</td>
<td>与__GFP_REPEAT相同</td>
</tr>
<tr>
<td>__GFP_NORETRY</td>
<td>一次内存分配失败后不再重试</td>
</tr>
<tr>
<td>__GFP_NO_GROW</td>
<td>slab分配器不允许增大slab高速缓存</td>
</tr>
<tr>
<td>__GFP_COMP</td>
<td>属于扩展页的页框</td>
</tr>
<tr>
<td>__GFP_ZERO</td>
<td>任何返回的页框必须被填满0</td>
</tr>
</tbody>
</table>
</div>
<p>​    实际上，<code>Linux</code>使用预定义标志值的组合。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组名</th>
<th>相应标志</th>
</tr>
</thead>
<tbody>
<tr>
<td>GFP_ATOMIC</td>
<td>__GFP_HIGH</td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td>__GFP_WAIT</td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td>__GFP_WAIT</td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td>__GFP_WAIT</td>
</tr>
<tr>
<td>GFP_USER</td>
<td>__GFP_WAIT</td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td>__GFP_WAIT</td>
</tr>
</tbody>
</table>
</div>
<p><code>__GFP_DMA</code>和_<code>_GFP_HIGHMEM</code>被称作管理区修饰符；它们标示寻找空闲页框时内核所搜索的管理区。<code>contig_page_data</code>节点描述符的<code>node_zonelists</code>是一个管理区描述符链表的数组，它代表后备管理区：对管理区修饰符的每一个设置，相应的链表包含的内存管理区能在原来的管理区缺少页框的情况下被用于满足内存分配请求。在<code>80x86 UMA</code>体系结构中，后备管理区如下：</p>
<ol>
<li>如<code>__GFP_DMA</code>被置位，则只能从<code>ZONE_DMA</code>内存管理区获取页框</li>
<li>如<code>__GFP_HIGHMEM</code>没被置位，按优先次序从<code>ZONE_NORMAL</code>，<code>ZONE_DMA</code>内存管理区获取页框</li>
<li><code>__GFP_HIGHMEM</code>被置位，按优先次序从<code>ZONE_HIGHMEM</code>，<code>ZONE_NORMAL</code>，<code>ZONE_DMA</code>内存管理区获取页框</li>
</ol>
<h4 id="释放页框"><a href="#释放页框" class="headerlink" title="释放页框"></a>释放页框</h4><p>下面4个函数和宏中的任一个都可释放页框</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>API</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>__free_pages(page, order)</td>
<td>先检查page指向的页描述符；如该页框未被保留，就把描述符的count字段减1。如<code>count</code>变为0，就假定从与<code>page</code>对应的页框开始的<code>2^order</code>个连续页框不再被使用。此时，函数释放页框。</td>
</tr>
<tr>
<td>free_pages(addr, order)</td>
<td>类似于<code>__free_pages(page, order)</code>，它接收的参数为要释放的第一个页框的线性地址<code>addr</code></td>
</tr>
<tr>
<td>__free_page(page)</td>
<td>释放<code>page</code>所指描述符对应的页框；扩展为：<code>__free_pages(page, 0)</code></td>
</tr>
<tr>
<td>free_page(addr)</td>
<td>释放线性地址为<code>addr</code>的页框；扩展为：<code>free_pages(addr, 0)</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="高端内存页框的内核映射"><a href="#高端内存页框的内核映射" class="headerlink" title="高端内存页框的内核映射"></a>高端内存页框的内核映射</h3><p>​    与直接映射的物理内存末端，高端内存的始端所对应的线性地址存放在<code>high_memory</code>变量。被设置为<code>896MB</code>。<code>896MB</code>边界以上的页框并不会采用直接映射方式对应到内核线性地址空间的第4个GB中相应位置，因此，内核不能直接访问它们。意味着，返回所分配页框线性地址的页分配器函数不适用于高端内存。即不适用于<code>ZONE_HIGHMEM</code>内存管理区内的页框。如，假定内核调<code>__get_free_pages(GFP_HIGHMEM, 0)</code>在高端内存分配一个页框，如分配器在高端内存确实分配了一个页框，则<code>__get_free_pages</code>不能返回它的线性地址。依次类推，内核不能使用这个页框；甚至更坏情况下，也不能释放该页框。</p>
<p>​    <strong>在64位硬件平台上不存在这个问题，因为可使用的线性地址空间远大于能按照的RAM大小。</strong>简言之，这些体系结构的<code>ZONE_HIGHMEM</code>管理区总是空的。但在32位平台上，如80x86体系结构，Linux设计者不得不找到某种方法来允许内核使用所有可使用的RAM，达到PAE所支持的64GB。</p>
<p>采用的方法如下：</p>
<ol>
<li>高端内存页框的分配只能通过<code>alloc_pages</code>和它的快捷函数<code>alloc_page</code>。这些函数不返回第一个被分配页框的线性地址，因为如该页框属于高端内存，则这样的线性地址根本不存在。这些函数返回第一个被分配页框的页描述符的线性地址。这些线性地址总是存在的，因为所有页描述符被分配在低端内存，它们在内核初始化阶段完成后就不会改变。</li>
<li>没有线性地址的高端内存中的页框不能被内核访问。故，内核线性地址空间的最后<code>128MB</code>中的一部分专门用于映射高端内存页框。这种映射是暂时的。通过重复使用线性地址，使得整个高端内存能在不同的时间被访问。</li>
</ol>
<p>​    内核可采用三种不同的机制将页框映射到高端内存（线性地址）：分别叫永久内核映射，临时内核映射，非连续内存分配。<br>建立永久内核映射可能阻塞当前进程；这发生在空闲页表项不存在时，即在高端内存上没有页表项可用作页框的”窗口”时。永久内核映射不能用于中断处理程序和可延迟函数。<br>​    建立临时内核映射不会要求阻塞当前进程；它的缺点是只有很少的临时内核映射可同时建立起来。使用临时内核映射的内核控制路径必须保证当前没其他的内核控制路径在使用同样的映射。意味着内核控制路径永不能被阻塞，否则其他内核控制路径很可能使用同一个窗口来映射其他的高端内存页。永久内核映射在64位体系下高端内存区不存在，自然也无永久内核映射</p>
<p>​    永久内核映射允许内核建立高端页框到内核地址空间（线性地址）的长期映射。它们使用主内核页表中一个专门的页表。地址存放在<code>pkmap_page_table</code>。页表中的表项数由<code>LAST_PKMAP</code>宏产生。页表照样含512或1024项，这取决于PAE是否被激活；因此，内核一次最多访问2MB或4MB的高端内存。该页表映射的线性地址从<code>PKMAP_BASE</code>开始。<code>pkmap_count</code>数组包含<code>LAST_PKMAP</code>个计数器，<code>pkmap_page_table</code>页表中的每一项都有一个。</p>
<blockquote>
<ul>
<li>计数器为0：对应的页表项没映射任何高端内存页框，且是可用的</li>
<li>计数器为1：对应的页表项没映射任何高端内存页框，但它不能使用，因为自从它最后一次使用以来，其相应的TLB表项还未被刷新。</li>
<li>计数器为n：相应的页表项映射一个高端内存页框，意味着正好有n-1个内核成分在使用这个页框。</li>
</ul>
</blockquote>
<p>​    <strong>为记录高端内存页框与永久内核映射包含的线性地址之间的关系，内核使用了<code>page_address_htable</code>散列表。</strong>该表包含一个<code>page_address_map</code>数据结构，用于为高端内存中的每一页框进行当前映射，该数据结构还包含一个指向页描述符的指针和分配给该页框的线性地址。</p>
<ol>
<li><p><strong>page_address–传入页框描述符线性地址，返回对应页框的线性地址</strong><br><code>page_address</code>返回页框（物理地址）对应的线性地址，如页框在高端内存（线性地址）中且没被映射，则返回<code>NULL</code>。这个函数接受一个页描述符指针<code>page</code>（描述一个页框）作为参数，区分以下两种情况：<br>(1).如页框不在高端内存（PG_highmem为0），则采用直接映射。则线性地址总是存在且是通过计算页框下标，然后将其转换成物理地址，最后根据相应的物理地址得到线性地址。<br>(2).如页框在高端内存（PG_highmem为1），该函数就到<code>page_address_htable</code>散列表中查找。如在散列表中找到页框，<code>page_address</code>就返回它的线性地址，否则返回<code>NULL</code>。</p>
</li>
<li><p><strong>kmap–建立永久内核映射。</strong></p>
</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">kmap</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token operator">*</span> page<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">PageHighMem</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">kmap_high</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如页框确实属于高端内存，则调kmap_high</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kamp_high</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token operator">*</span> page<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vaddr<span class="token punctuation">;</span>
	<span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 永久内核映射对所有处理器可见。防止多核并发，需加锁保护。</span>
	vaddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 查找哈希表</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>vaddr<span class="token punctuation">)</span>
		vaddr <span class="token operator">=</span> <span class="token function">map_new_virtual</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 向哈希表插入，并返回线性地址</span>
	pkmap_count<span class="token punctuation">[</span><span class="token punctuation">(</span>vaddr<span class="token operator">-</span>PKMAP_BASE<span class="token punctuation">)</span> <span class="token operator">>></span> PAGE_SHIFT<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 通过线性地址找到索引</span>
	<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>vaddr<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>中断处理程序和可延迟函数不能调<code>kmap</code>。</strong><code>kmap_high</code>通过调<code>page_address</code>检查页框是否已经被映射。如不是，调<code>map_new_virtual</code>把页框的物理地址插入到<code>pkmap_page_table</code>的一个项，并在<code>page_address_htable</code>中加入一个元素。然后，<code>kmap_high</code>使页框的线性地址所对应的计数器加1来将调用该函数的新内核成分考虑在内。最后，<code>kmap_high</code>释放<code>kmap_lock</code>并返回对该页框进行映射的线性地址。</p>
<ol>
<li><strong>map_new_virtual–完成页表注册，完成哈希表注册</strong><br>本质上执行两个嵌套循环：</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> count<span class="token punctuation">;</span>
	<span class="token function">DECLARE_WAITQUEUE</span><span class="token punctuation">(</span>wait<span class="token punctuation">,</span> current<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>count <span class="token operator">=</span> LAST_PKMAP<span class="token punctuation">;</span> count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>count<span class="token punctuation">)</span><span class="token comment">// 遍历所有表项</span>
	<span class="token punctuation">&#123;</span>
		last_pkmap_nr <span class="token operator">=</span> <span class="token punctuation">(</span>last_pkmap_nr<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>LAST_PKMAP<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 后半部分搜索没找到可用表项时。先刷新，再从开始位置再搜索一遍</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>last_pkmap_nr<span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token function">flush_all_zero_pkmaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将使用者不存在的槽位清理腾出多余位置</span>
			count <span class="token operator">=</span> LAST_PKMAP<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		
		<span class="token comment">// 找到可用槽位</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>pkmap_count<span class="token punctuation">[</span>last_pkmap_nr<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			<span class="token keyword">unsigned</span> <span class="token keyword">long</span> vaddr <span class="token operator">=</span> PKMAP_BASE<span class="token operator">+</span><span class="token punctuation">(</span>last_pkmap_nr<span class="token operator">&lt;&lt;</span>PAGE_SHIFT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 计算此位置对应线性地址</span>
			<span class="token function">set_pte</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>pkmap_page_table<span class="token punctuation">[</span>last_pkmap_nr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mk_pte</span><span class="token punctuation">(</span>page<span class="token comment">/*页框物理地址*/</span><span class="token punctuation">,</span> <span class="token function">__pgprot</span><span class="token punctuation">(</span><span class="token number">0x63</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 设置页表。完成页表注册。</span>
			pkmap_count<span class="token punctuation">[</span>last_pkmap_nr<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 表示页表映射建立了。但此页表项映射的页框并没有使用者。</span>
			<span class="token function">set_page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 哈希表注册</span>
			<span class="token keyword">return</span> vaddr<span class="token punctuation">;</span><span class="token comment">// 返回线性地址</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token comment">// 执行到这里，表示后半部分没搜索到可用表项，且刷新从头搜依然没搜到</span>
	current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">;</span>
	<span class="token function">add_wait_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pkmap_map_wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 向完成队列加入新的等待项</span>
	<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 放弃cpu之前先释放锁。</span>
	<span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 主动放弃cpu，让内核选择另一进程运行。</span>
	<span class="token comment">// 走到这里，一定是其他进程腾出表项后，发现有人在等待空闲表项。所以，让等待者变为就绪，将进程重新加入cpu的可调度队列。</span>
	<span class="token comment">// 某次调度，等待者被调度恢复后继续执行这里</span>
	<span class="token function">remove_wait_queue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pkmap_map_wait<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将自己从等待队列移除</span>
	<span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 重新加锁</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 再次尝试页表注册，哈希表注册前，先检查，是否其他内核线程已经完成了注册工作。</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 其他内核线程已经完成注册后，可以直接返回。</span>
<span class="token punctuation">&#125;</span>	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    内循环中，函数扫描<code>pkmap_count</code>中所有计数器直到找到一个空值。当在<code>pkmap_count</code>中找到一个未使用项时，大的if代码块运行。这段代码确定该项对应的线性地址，为它在<code>pkmap_page_table</code>页表中创建一个项，将<code>count</code>置1，调<code>set_page_address</code>插入一个新元素到<code>page_address_htable</code>散列表，返回线性地址。</p>
<p>​    搜索从上次因调<code>map_new_virtual</code>而跳出的地方开始。在<code>pkmap_count</code>中搜索完最后一个计数器尚未找到空闲槽位时，又从下标为0计数器开始搜索。继续之前，<code>map_new_virtual</code>调<code>flush_all_zero_pkmaps</code>开始寻址计数器为1的另一趟扫描。每个值为1的计数器都表示在<code>pkmap_page_table</code>中表项是空闲的，但不能使用，因为相应的<code>TLB</code>表项还没被刷新。<code>flush_all_zero_pkmaps</code>把它们的计数器重置为0，删除<code>page_address_htable</code>散列表中对应的元素，并对<code>pkmap_page_table</code>里的所有项上进行<code>TLB</code>刷新。</p>
<p>​    如内循环在<code>pkmap_count</code>中没找到空的计数器，<code>map_new_virtual</code>就阻塞当前进程，直到某个进程释放了<code>pkmap_page_table</code>页表中的一个表项，通过把<code>current</code>插入到<code>pkmap_map_wait</code>等待队列，把<code>current</code>设置为<code>TASK_UNINTERRUPTIBLE</code>，并调<code>schedule</code>放弃CPU来达到此目的。一旦进程被唤醒，函数就调<code>page_address</code>检查是否存在另一个进程已映射了该页。如还没其他进程映射该页，则内循环重新开始。</p>
<ol>
<li><strong>kunmap撤销先前由kmap建立的永久内核映射。如页确实在高端内存中，则调kunmap_high。</strong></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kunmap_high</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token operator">*</span> page<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 这是检测此高端内存内页框释放后，此页框占据的页表表项是否没了使用者，进而可被清理后复用（用来服务于另一个页框）</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">--</span>pkmap_count<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">page_address</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token operator">-</span>PKMAP_BASE<span class="token punctuation">)</span><span class="token operator">>></span>PAGE_SHIFT<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">waitqueue_active</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pkmap_map_wait<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 检测等待队列上是否有等待对象</span>
			<span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pkmap_map_wait<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//唤醒首个等待对象</span>
		<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kmap_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    上述括号内的表达式从页的线性地址计算出<code>pkmap_count</code>数组的索引。计数器被减1并与1相比。匹配成功表明没进程在使用页了。函数最终能唤醒由<code>map_new_virtual</code>添加在等待队列中的进程。</p>
<p>​    在高端内存的任一页框都可通过一个”窗口”映射到内核地址空间。留给临时内核映射的窗口数是非常少的。</p>
<p>​    每个CPU有它自己的包含13个窗口的集合，它们用<code>enum km_type</code>数据结构表示。该数据结构中定义的每个符号，如<code>KM_BOUNCE_READ</code>，<code>KM_USER0</code>或<code>KM_PTE0</code>，标识了窗口的线性地址。内核必须确保同一窗口永不会被两个不同的控制路径同时使用。故，<code>km_type</code>中的每个符号只能由一种内核成分使用，并以该成分命名。最后一个符号<code>KM_TYPE_NR</code>本身并不表示一个线性地址，但由每个<code>CPU</code>用来产生不同的可用窗口数。</p>
<p>在<code>km_type</code>中的每个符号（除了最后一个）都是固定映射的线性地址的一个下标。<code>enum fixed_address</code>数据结构包含符号<code>FIX_KMAP_BEGIN</code>和<code>FIX_KMAP_END</code>；把后者的值赋成下标<code>FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1</code>。这种方式下，系统中的每个<code>CPU</code>都有<code>KM_TYPE_NR</code>个固定映射的线性地址。此外，内核用<code>fix_to_virt(FIX_KMAP_BEGIN)</code>线性地址对应的页表项的地址初始化<code>kmap_pte</code>变量。</p>
<p>1.<strong>kmap_atomic–建立临时内核映射。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">void* kmap_atomic(struct page* page, enum km_type type)
&#123;
	enum fixed_address idx;
	unsigned long vaddr;
	current_thread_info()-&gt;preempt_count++;&#x2F;&#x2F; 这样就禁止了内核抢占
	if(!PageHighMem(page))
		return page_address(page);
	idx &#x3D; type + KM_TYPE_NR * smp_processor_id();&#x2F;&#x2F; 取得正确索引
	vaddr &#x3D; fix_to_virt(FIX_KMAP_BEGIN+idx);&#x2F;&#x2F; 取得对应线性地址
	set_pte(kmap_pte-idx&#x2F;* pte表项地址 *&#x2F;, mk_pte(page&#x2F;* 页框描述符线性地址 *&#x2F;, 0x63));&#x2F;&#x2F; 页表注册
	__flush_tlb_single(vaddr);&#x2F;&#x2F; TLB刷新
	return (void*)vaddr;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>type</code>参数和<code>CPU</code>标识符指定必须用哪个固定映射的线性地址映射请求页。如页框不属于高端内存，则该函数返回页框的线性地址；否则，用页的物理地址及<code>Present，Accessed，Read/Write</code>和<code>Dirty</code>位建立该固定映射的线性地址对应的页表项。最后，该函数刷新适当的<code>TLB</code>项并返回线性地址。</p>
<p>2.<strong>kunmap_atomic–撤销临时内核映射。</strong><br>在80x86结构中，这个函数减少当前进程的<code>preempt_count</code>。因此，如在请求临时内核映射之前能抢占内核控制路径， 则在同一个映射被撤销后可再次抢占。此外，<code>kunmap_atomic</code>检查当前进程的<code>TIF_NEED_RESCHED</code>标志是否被置位。如是，就调<code>schedule</code>。</p>
<h2 id="伙伴系统算法"><a href="#伙伴系统算法" class="headerlink" title="伙伴系统算法"></a>伙伴系统算法</h2><p>​    内核应为分配<strong>一组连续的页框建立一种健壮，高效的分配策略。频繁地请求和释放不同大小的一组连续页框</strong>，必然导致在已分配页框的块内分散了许多小块的空闲页框。</p>
<p>本质上，避免外碎片的方法有两种：</p>
<ol>
<li>利用分页单元把一组非连续的空闲页框映射到连续的线性地址区间。 </li>
<li>开发一种适当的技术来记录现存的空闲连续页框块的情况，以尽量避免为满足对小块的请求而分割大的空闲块。</li>
</ol>
<p>基于以下三种原因，内核首选第二种方法：</p>
<ol>
<li>某些情况下，<strong>连续的页框确实是必要的。因为仅连续的线性地址不足以满足请求。典型例子就是给DMA处理器分配缓存区的内存请求。因为当在一次单独的I/O操作中传送几个磁盘扇区的数据时，DMA忽略分页机制而直接访问地址总线（直接采用物理地址），故，所请求的缓冲区必须位于连续的页框中。</strong></li>
<li>即使连续页框的分配并不是很必要，但它在保持内核页表不变方面所起的作用也不容忽视。在内核页表中，只需要为这些连续的页框创建一个条目，而不是为每个页框创建一个单独的条目。这可以减少内核页表的大小，并降低内存管理的开销。在查找页表时，操作系统只需要查找一个条目，而不是多个条目。操作系统只需要查找一个页表条目，就可以确定该虚拟地址对应的物理地址。连续页框的分配可以使得内存块更加连续和紧凑。这有助于提高内存利用率，因为操作系统可以更有效地管理和调度内存。修改页表会怎样？频繁修改页表势必导致平均访问内存次数增加，因为这会使CPU频繁刷新TLB（TLB不命中率提高）的内容。</li>
<li>内核通过4MB的页可访问大块连续的物理内存。这样减少了TLB失效率（TLB命中率提高），提高了访问内存的平均速度。</li>
</ol>
<p>​    Linux采用著名的伙伴系统算法来解决外碎片。它把所有的空闲页框分组为11个块链表，每个块链表分别包含大小为<code>1，2，4，8，16，32，64，128，256，512，1024</code>个连续的页框的块的集合。对1024个页框的最大请求对应着4MB大小的连续RAM块。伙伴系统保证每个块的第一个页框的物理地址是该块大小的整数倍。例如，大小为16个页框的块，其起始地址是$16 \times 2^{12}$的倍数</p>
<p>通过举例来说明算法的工作原理：<strong>连续页框块申请–假设申请256个连续页框</strong></p>
<ul>
<li>先在256个页框的链表中检查是否有一个空闲块。如存在，分配此块。</li>
<li>如没有，算法会查找下一个更大的页块。即在512个页框的链表中找一个空闲块。<br>如存在，内核把空闲块分为两部分。一半用作满足请求。另一半作为新块插入到256个页框的链表。</li>
<li>如在512个页框的块链表没找到空闲块，就继续在1024找。<br>如找到，内核把1024个页框块的划分为一个256个页框的块用于满足需求。剩余部分划分为一个256页框的新快，一个512页框的新快分别插入对应的链表。</li>
<li>如1024页框链表还没找到，算法就放弃并发出错误信号。（意味着连续页框分配最大只能一次分配4MB内存）、</li>
</ul>
<h3 id="连续页框块释放："><a href="#连续页框块释放：" class="headerlink" title="连续页框块释放："></a><strong>连续页框块释放：</strong></h3><p>连续页框块释放时，内核会检查释放块是否可以现有空闲块合并成更大的空闲块。允许合并时，将参与合并的空闲块从链表移除，组成一个新块。对新的块持续如此迭代，直到迭代到无法合并时，块加入链表。</p>
<p>合并成立条件：</p>
<ul>
<li>两个块有相同的大小，记作<code>b</code>。</li>
<li>它们的物理地址是连续的。</li>
<li>第一个块的第一个页框的物理地址是$2 \times b \times 2^{12}$的倍数。</li>
</ul>
<h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h4><p>Linux 2.6为每个管理区使用不同的伙伴系统。因此，在80x86结构中，有三种伙伴系统：</p>
<ul>
<li>第一种处理适合<code>ISA DMA</code>的页框。</li>
<li>第二种处理”常规”页框。</li>
<li>第三种处理高端内存页框。</li>
</ul>
<p>每个伙伴系统使用的主要数据结构如下：</p>
<ol>
<li>前面介绍过的<code>mem_map</code>数组。实际上，每个管理区都关系到<code>mem_map</code>元素的子集。子集中的第一个元素和元素的个数分别由管理区描述符的<code>zone_mem_map</code>和<code>size</code>字段指定。</li>
<li>包含有<code>11</code>个元素，元素类型为<code>free_area</code>的一个数组，每个元素对应一种特定块大小的链表。该数组存放在管理区描述符的<code>free_area</code>字段中。</li>
</ol>
<p>​    考虑管理区描述符中<code>free_area</code>数组的第<code>k</code>个元素，它标识所有大小为$2^k$个页框的空闲块。这个元素的<code>free_list</code>字段是双向循环链表的头，这个双向循环链表集中了大小为$2^k$个页框的空闲块对应的页描述符。更精确地说，是空闲块中起始页框的页描述符；指向链表中相邻元素的指针存放在页描述符的<code>lru</code>字段中。除了链表头外，<code>free_area</code>数组的第<code>k</code>个元素同样包含字段<code>nr_free</code>，它指定了大小为$2^k$个页框的空闲块的个数。如没大小为$2^k$个页框的空闲块，则<code>nr_free</code>等于<code>0</code>且<code>free_list</code>为空。</p>
<p>​    一个大小为$2^k$个页框的空闲块的第一个页框的描述符的private字段存放了块的<code>order</code>，即<code>k</code>。正是由于此字段，页块被释放时，内核可确定这个块的伙伴是否也空闲。如是，它可以把两个块结合成大小为$2^{k + 1}$页框的新块。</p>
<h4 id="2-分配块"><a href="#2-分配块" class="headerlink" title="2.分配块"></a>2.分配块</h4><p><strong><code>__rmqueue</code>–用来在管理区找到一个空闲块</strong></p>
<ul>
<li>参数：管理区描述符地址，<code>order</code>。<code>order</code>表示请求的空闲页块大小的对数值。</li>
<li>返回值：如页框被成功分配，<code>__rmqueue</code>就返回第一个被分配页框的页描述符。否则， 返回NULL。</li>
</ul>
<p><code>__rmqueue</code>假设调用者已经禁止了本地中断，并获得了保护伙伴系统数据结构的<code>zone-&gt;lock</code>自旋锁。<br>从所请求<code>order</code>的链表开始，它扫描每个可用块链表进行循环搜索，如需要搜索更大的<code>order</code>，就继续搜索。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">free_area</span><span class="token operator">*</span> area<span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> current_order<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>current_order <span class="token operator">=</span> order<span class="token punctuation">;</span> current_order <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token operator">++</span>current_order<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	area <span class="token operator">=</span> zone<span class="token operator">-></span>free_area <span class="token operator">+</span> current_order<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>area<span class="token operator">-></span>free_list<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">goto</span> block_found<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如直到循环结束还没找到合适的空闲块，则<code>__rmqueue</code>就返回<code>NULL</code>。否则，找到了一个合适的空闲块，这种情况下，从链表中删除它的第一个页框描述符，并减少管理区描述符中的<code>free_pages</code>的值。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">block_found<span class="token operator">:</span>
	<span class="token comment">// 1.定位到链表首个有效元素</span>
	<span class="token comment">// 2.链表首个有效元素是一个struct page对象的lru字段。</span>
	<span class="token comment">// 3.从lru字段地址导出隶属的struct page对象起始地址</span>
	page <span class="token operator">=</span> <span class="token function">list_entry</span><span class="token punctuation">(</span>area<span class="token operator">-></span>free_list<span class="token punctuation">.</span>next<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token punctuation">,</span> lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 从隶属的双向链表中移除该节点</span>
	<span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>page<span class="token operator">-></span>lru<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 清理page的private字段</span>
	<span class="token function">ClearPagePrivate</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 暂时被设置为0</span>
	page<span class="token operator">-></span>private <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">// 更新有效块数</span>
	area<span class="token operator">-></span>nr_free<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token comment">// 更新隶属管理区内空闲页框数</span>
	zone<span class="token operator">-></span>free_pages <span class="token operator">-=</span> <span class="token number">1UL</span> <span class="token operator">&lt;&lt;</span> order<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    当为了满足$2^h$个页框的请求而有必要使用$2^k$个页框的块时（<code>h&lt;k</code>），<br>程序就分配前面的$2^h$个页框，把后面$2^k - 2^h$个页框循环再分配给<code>free_area</code>链表中下标在<code>h</code>到<code>k</code>之间的元素：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 这是获得得到块尺寸</span>
size <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> curr_order<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>curr_order <span class="token operator">></span> order<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">// 规模小一级空闲块</span>
	area<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token comment">// 规模</span>
	curr_order<span class="token operator">--</span><span class="token punctuation">;</span>
	<span class="token comment">// 页数</span>
	size <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">// page是分配出去的块的首个页框。page+size得到剩余可放入当前规模块链表的起始页框</span>
	buddy <span class="token operator">=</span> page <span class="token operator">+</span> size<span class="token punctuation">;</span>
	<span class="token comment">// 将该页框放入当前规模块链表</span>
	<span class="token function">list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buddy<span class="token operator">-></span>lru<span class="token punctuation">,</span> <span class="token operator">&amp;</span>area<span class="token operator">-></span>free_list<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 规模块中可用块数量更新</span>
	area<span class="token operator">-></span>nr_free<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token comment">// 设置该page的private以记录其隶属的块的规模</span>
	buddy<span class="token operator">-></span>private <span class="token operator">=</span> curr_order<span class="token punctuation">;</span>
	<span class="token comment">// 设置page的标志。来表示其private字段有效。</span>
	<span class="token function">SetPagePrivate</span><span class="token punctuation">(</span>buddy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">return</span> page<span class="token punctuation">;</span><span class="token comment">// 被分配出去的块的首个page的private字段无效</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为<code>__rmqueue</code>已经找到了合适的空闲块，所以它返回所分配的第一个页框对应的页描述符的地址<code>page</code>。<br>上述分配过程看，每次分配页框会被规整到2的幂次后再执行页框分配（造成分配时内部碎片，牺牲容量，换取性能优化）。</p>
<h4 id="3-释放块"><a href="#3-释放块" class="headerlink" title="3.释放块"></a>3.释放块</h4><p><strong>__free_pages_bulk–按伙伴系统的策略释放页框</strong></p>
<p>参数：</p>
<ul>
<li>page：被释放块中所包含的第一个页框描述符的地址</li>
<li>zone：管理区描述符的地址</li>
<li>order：块大小的对数</li>
</ul>
<p>​    函数假设调用者已禁止本地中断（防止外部中断打断执行流程）并获得了保护伙伴系统数据结构的<code>zone-&gt;lock</code>（防止其他处理器打断执行流程）自旋锁。<code>__free_pages_bulk</code>先声明和初始化一些局部变量：</p>
<pre class="line-numbers language-none"><code class="language-none">struct page* base &#x3D; zone-&gt;zone_mem_map;
unsigned long buddy_idx, page_idx &#x3D; page - base;
struct page* buddy, *coalesced;
int order_size &#x3D; 1 &lt;&lt; order;&#x2F;&#x2F; 页数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>page_idx</code>包含块中第一个页框的下标，这是相对于管理区中第一个页框而言的。<code>order_size</code>用于增加管理区中空闲页框的计数器：</p>
<pre class="line-numbers language-none"><code class="language-none">zone-&gt;free_pages +&#x3D; order_size;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>现在函数开始执行循环，最多循环(<code>10-order</code>)次，每次都尽量把一个块和它的伙伴进行合并。函数以最小块开始，然后向上移动到顶部：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span><span class="token punctuation">(</span>order <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">// order是当前规模</span>
	<span class="token comment">// 这里的意思是将page_idx的二进制下第order位取反。</span>
	<span class="token comment">// 若此位之前是1，buddy_idx此位是0。这样取得前一个buddy。因为只有前一个buddy才能作为合并后buddy的起始部分。对齐要求。</span>
	<span class="token comment">// 若此位之前是0，buddy_idx此位是1。这样取得后一个buddy。此时只有自己才能作为合并后buddy的起始部分。对齐要求。</span>
	buddy_idx <span class="token operator">=</span> page_idx <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> order<span class="token punctuation">)</span><span class="token punctuation">;</span>
	buddy <span class="token operator">=</span> base <span class="token operator">+</span> buddy_idx<span class="token punctuation">;</span>
	<span class="token comment">// 验证此page是否符合作为规模为order的buddy块首个page的条件</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">page_is_buddy</span><span class="token punctuation">(</span>buddy<span class="token punctuation">,</span> order<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buddy<span class="token operator">-></span>lru<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将此buddy块从隶属的双向链表移除</span>
	zone<span class="token operator">-></span>free_area<span class="token punctuation">[</span>order<span class="token punctuation">]</span><span class="token punctuation">.</span>nr_free<span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">// 更新本来隶属的规模中可有块数量</span>
	<span class="token comment">// 清理此块首个page的private</span>
	<span class="token function">ClearPagePrivate</span><span class="token punctuation">(</span>buddy<span class="token punctuation">)</span><span class="token punctuation">;</span>
	buddy<span class="token operator">-></span>private <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">// 确定合并块的首个page的索引。</span>
	<span class="token comment">// page_idx的二进制下第order位</span>
	<span class="token comment">// 若此位之前是1，buddy_idx此位是0。</span>
	<span class="token comment">// 这样合并后块内首个page索引，取buddy_idx</span>
	<span class="token comment">// 若此位之前是0，buddy_idx此位是1。</span>
	<span class="token comment">// 这样合并后块内首个page索引，取page_idx</span>
	<span class="token comment">// page_idx &amp;= buddy_idx得到的结果其余位和page_idx一致。但第order位固定为0。符合上述要求。 </span>
	page_idx <span class="token operator">&amp;=</span> buddy_idx<span class="token punctuation">;</span>
	<span class="token comment">// 这样我们得到了规模为order+1的块及块内首个page。继续迭代。</span>
	order<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在循环体内，函数寻找块的下标<code>buddy_idx</code>，它是拥有<code>page_idx</code>页描述符下标的块的伙伴。结果这个下标可被简单地如下计算：</p>
<pre class="line-numbers language-none"><code class="language-none">buddy_idx &#x3D; page_idx ^ (1 &lt;&lt; order);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>实际上，使用(<code>1&lt;&lt;order</code>)掩码的异或转换<code>page_idx</code>第<code>order</code>位的值。<br>因此，如这个位原先是<code>0</code>，<code>buddy_idx</code>就等于<code>page_idx+order_size</code>；如这个位原先是<code>1</code>，<code>buddy_idx</code>就等于<code>page_idx - order_size</code>。<br>一旦知道了伙伴块下标，就可通过下式很容易获得伙伴块的页描述符：</p>
<pre class="line-numbers language-none"><code class="language-none">buddy &#x3D; base + buddy_idx;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>现在调<code>page_is_buddy</code>来检查buddy是否描述了大小为<code>order_size</code>的空闲页框块的第一个页。</p>
<pre class="line-numbers language-none"><code class="language-none">int page_is_buddy(struct page* page, int order)
&#123;
	if(PagePrivate(buddy) &amp;&amp; page-&gt;private &#x3D;&#x3D; order &amp;&amp; !PageReserved(buddy) &amp;&amp; page_count(page) &#x3D;&#x3D; 0)
		return 1;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>buddy</code>的第一个页必须为空闲（<code>_count</code>等于<code>-1</code>），它必须属于动态内存，它的<code>private</code>字段必须有意义，最后<code>private</code>字段必须存放将要被释放的块的<code>order</code>。如所有这些条件都符合，伙伴块就被释放，且函数将它从以<code>order</code>排序的空闲块链表上删除，并再执行一次循环以寻找两倍大小的伙伴块。如<code>page_is_buddy</code>中至少有一个条件没被满足，则该函数跳出循环，因为获得的空闲块不能再和其他空闲块合并。函数将它插入适当的链表并以块大小的<code>order</code>更新第一个页框的<code>private</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 得到最终合并块的首个page
coalesced &#x3D; base + page_idx;
&#x2F;&#x2F; 设置其private
coalesced-&gt;private &#x3D; order;
SetPagePrivate(coalesced);
&#x2F;&#x2F; 将page加入对应规模块的双向链表
list_add(&amp;coalesced-&gt;lru, &amp;zone-&gt;free_area[order].free_list);
zone-&gt;free_area[order].nr_free++;&#x2F;&#x2F; 更新对应规模内有效块数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="每CPU页框高速缓存"><a href="#每CPU页框高速缓存" class="headerlink" title="每CPU页框高速缓存"></a>每CPU页框高速缓存</h2><p>​    内核经常请求和释放单个页框。为提升系统性能，每个内存管理区定义了一个”每CPU”页框高速缓存。所有”每CPU”高速缓存包含一些预先分配的页框，它们被用于满足本地CPU发出的单一内存请求。</p>
<p>​    实际上，这里为每个内存管理区和每个CPU提供了两个高速缓存： <strong>一个热高速缓存，它存放的页框中所包含的内容很可能就在CPU硬件高速缓存中；还有一个冷高速缓存。</strong></p>
<p>​    如内核或用户态进程在刚分配到页框后就立即向页框写，那么从热高速缓存中获得页框就对系统性能有利。实际上，每次对页框存储单元的访问都会导致从页框中给硬件高速缓存”窃取”一行。当然，除非硬件高速缓存包含有一行：它映射刚被访问的”热”页框单元。反过来，如页框将要被DMA操作填充，则从冷高速缓存中获得页框是方便的。在这种情况下，不会涉及到CPU，且硬件高速缓存的行不会被修改。</p>
<p>​    实现每CPU页框高速缓存的主要数据结构是存放在内存管理区描述符的<code>pageset</code>字段中的一个<code>per_cpu_pageset</code>数组数据结构。该数组包含为每个CPU提供的一个元素；这个元素依次由两个<code>per_cpu_pages</code>描述符组成，一个留给热高速缓存，另一个留给冷高速缓存。</p>
<p><code>per_cpu_pages</code>描述符的字段</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>count</td>
<td>高速缓存中的页框个数</td>
</tr>
<tr>
<td>int</td>
<td>low</td>
<td>下界，表示高速缓存需要补充</td>
</tr>
<tr>
<td>int</td>
<td>high</td>
<td>上界</td>
</tr>
<tr>
<td>int</td>
<td>batch</td>
<td>在高速缓存中将要添加或被删去的页框个数</td>
</tr>
<tr>
<td>struct list_head</td>
<td>list</td>
<td>高速缓存中包含的页框描述符链表</td>
</tr>
</tbody>
</table>
</div>
<p>​    内核使用两个位来监视热高速缓存和冷高速缓存的大小：如页框个数低于下界low，内核通过从伙伴系统中分配batch个单一页框来补充对应的高速缓存。否则，如页框个数高于上界high，内核从高速缓存中释放batch个页框到伙伴系统。值batch，low，high本质上取决于内存管理区中包含的页框个数。</p>
<h4 id="1-通过每CPU页框高速缓存分配页框"><a href="#1-通过每CPU页框高速缓存分配页框" class="headerlink" title="1.通过每CPU页框高速缓存分配页框"></a>1.通过每CPU页框高速缓存分配页框</h4><p><strong>buffered_rmqueue–在指定的内存管理区中分配页框</strong>，它使用每<code>CPU</code>页框高速缓存来处理单一页框请求。<br>参数：</p>
<ul>
<li>内存管理区描述符的地址，</li>
<li>请求分配的内存大小的对数<code>order</code>，</li>
<li>分配标志<code>gfp_flags</code>。</li>
</ul>
<p>如<code>pfp_flags</code>中的<code>__GFP_COLD</code>标志被置位，则页框应当从冷高速缓存中获取，否则，它应从热高速缓存中获取。（此标志只对单一页框分配有意义）</p>
<p>函数操作：</p>
<ol>
<li><p>如<code>order</code>不等于<code>0</code>，每<code>CPU</code>页框高速缓存就不能被使用；跳到4</p>
</li>
<li><p>检查由<code>__GFP_COLD</code>标志所标识的内存管理区本地每<code>CPU</code>高速缓存是否需补充。这种情况下，它执行：</p>
<blockquote>
<ol>
<li>通过反复调<code>__rmqueue</code>从伙伴系统中分配<code>batch</code>个单一页框</li>
<li>将已分配页框的描述符插入高速缓存链表</li>
<li>通过给<code>count</code>增加实际被分配页框来更新它</li>
</ol>
</blockquote>
</li>
<li><p>如<code>coun</code>t为正，则函数从高速缓存链表获得一个页框，<code>count</code>减1跳到5。</p>
</li>
<li><p>这里，内存请求还没被满足，或是因为请求跨越了几个连续页框，或是因为被选中的页框高速缓存为空，调<code>__rmqueue</code>从伙伴系统分配所请求的页框。</p>
</li>
<li><p>如内存请求得到满足，初始化第一个页框的页描述符：清除一些标志，将<code>private</code>置为0，将页框引用计数器置1。如<code>gfp_flags</code>中<code>__GPF_ZERO</code>被置位，则函数将被分配的内存区域填充0。返回（第一个）页框的页描述符地址。</p>
</li>
<li><p>如内存分配请求失败，则返回NULL。</p>
</li>
</ol>
<h4 id="2-释放页框到每CPU页框高速缓存–位于伙伴系统和页框使用者的中间层"><a href="#2-释放页框到每CPU页框高速缓存–位于伙伴系统和页框使用者的中间层" class="headerlink" title="2.释放页框到每CPU页框高速缓存–位于伙伴系统和页框使用者的中间层"></a>2.释放页框到每CPU页框高速缓存–位于伙伴系统和页框使用者的中间层</h4><p><strong>free_hot_page–释放单个页框到每CPU页框热高速缓存</strong><br><strong>free_cold_page–释放单个页框到每CPU页框冷高速缓存</strong></p>
<p>它们都是<code>free_hot_cold_page</code>的封装。<br>参数：</p>
<ul>
<li>将要释放的页框的描述符地址<code>page</code>，</li>
<li><code>cold</code>标志；</li>
</ul>
<p><code>free_hot_cold_page</code>操作：</p>
<ol>
<li>从<code>page-&gt;flags</code>获取包含该页框的内存管理区描述符地址</li>
<li>获取由<code>cold</code>标志选择的管理区高速缓存的<code>per_cpu_pages</code>描述符地址</li>
<li>检查高速缓存是否应被清空：如<code>count</code>高于或等于<code>high</code>，则调<code>free_pages_bulk</code>，将管理区描述符，将被释放的页框个数（<code>batch</code>），高速缓存链表的地址及数字 0 传递给该函数。<code>free_pages_bulkl</code>依次反复调<code>__free_pages_bulk</code>来释放指定数量的页框到内存管理区的伙伴系统中。</li>
<li>把释放的页框添加到高速缓存链表上，增加<code>count</code>。</li>
</ol>
<p><strong>热高速缓存中页框，适合供cpu使用。冷高速缓存中页框，适合供<code>DMA</code>使用。</strong></p>
<h3 id="管理区分配器"><a href="#管理区分配器" class="headerlink" title="管理区分配器"></a>管理区分配器</h3><p>​    管理区分配器是内核页框分配器的前端。该构建必须分配一个包含足够多空闲页框的内存区，使它能满足内存请求。</p>
<ul>
<li><p>管理区分配器必须满足几个目标：</p>
</li>
<li><p>应当保护保留的页框池</p>
</li>
<li>当内存不足且允许阻塞当前进程时它应触发页框回收算法。一旦某些页框被释放，管理区分配器将再次尝试分配。</li>
<li>如可能，它应保存小而珍贵的<code>ZONE_DMA</code>内存管理区。例如，如是对<code>ZONE_NORMAL</code>或<code>ZONE_HIGHMEM</code>页框的请求，则管理区分配器会不太愿意分配<code>ZONE_DMA</code>内存管理区中的页框。对一组连续页框的每次请求实质上是通过执行<code>alloc_pages</code>宏来处理的。接着，这个宏又依次调<code>__alloc_pages</code>，该函数是管理区分配器的核心。</li>
</ul>
<p><strong>1.__alloc_pages–通过内存管理区执行页框分配</strong><br><code>__alloc_pages</code>参数：</p>
<ul>
<li>gfp_mask–在内存分配请求中指定的标志。</li>
<li>order–将要分配的一组连续页框数量的对数。</li>
<li>zonelist–指向zonelist数据结构的指针，该数据结构按优先次序描述了适用于内存分配的内存管理区。</li>
</ul>
<p><code>__alloc_pages</code>扫描包含在<code>zonelist</code>数据结构中的每个内存管理区。</p>
<pre class="line-numbers language-none"><code class="language-none">for(i &#x3D; 0; (z &#x3D; zonelist-&gt;zones[i]) !&#x3D; NULL; i++)
&#123;
	if(zone_watermark_ok(z, order, ...))
	&#123;
		page &#x3D; buffered_rmqueue(z, order, gfp_mask);
		if(page)
			return page;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对每个内存管理区，该函数将空闲页框的个数与一个阈值作比较，该阈值取决于内存分配标志、当前进程的类型、管理区被函数检查过的次数。实际上， 如空闲内存不足，则每个内存管理区一般会被检查几遍，每一遍在所请求的空闲内存最低量的基础上使用更低的阈值扫描。</p>
<p><code>zone_watermark_ok</code>接收几个参数，它们决定内存管理区中空闲页框个数的阈值min。特别是，如满足下列两个条件则函数返回1。</p>
<ul>
<li>除被分配的页框外，在内存管理区中至少还有<code>min</code>个空闲页框。不包括为内存不足保留的页框。</li>
<li>除了被分配的页框外，这里在<code>order</code>至少为<code>k</code>的块中起码还有$min/2^{k}$个空闲页框，对于<code>k</code>，取值在1和分配的<code>order</code>之间。</li>
</ul>
<p>阈值<code>min</code>的值由<code>zone_watermark_ok</code>确定：</p>
<ol>
<li>作为参数传递的基本值可是内存管理区界值<code>pages_min</code>，<code>pages_low</code>和<code>pages_high</code>中的任意一个。</li>
<li>作为参数传递的<code>gfp_high</code>标志被置位，则<code>base</code>值被<code>2</code>除。通常，如<code>gfp_mask</code>中的<code>__GFP_WAIT</code>标志被置位（即能从高端内存中分配页框），则这个标志等于1。</li>
<li>如作为参数传递的<code>can_try_harder</code>被置位，则阈值将会再减少四分之一。如<code>gfp_mask</code>中的<code>__GFP_WAIT</code>被置位，或如当前进程是一个实时进程且在进程上下文中（在中断处理程序和可延迟函数之外）已经完成了内存分配，则<code>can_try_harder</code>标志等于1。</li>
</ol>
<p><code>__alloc_pages</code>执行：</p>
<ol>
<li><p>执行对内存管理区的第一次扫描<br>第一次扫描中，阈值<code>min</code>被设为<code>z-&gt;pages_low</code>其中z指向正被分析的管理区描述符。</p>
</li>
<li><p>如函数在上一步没终止，则没剩下多少空闲内存：函数唤醒<code>kswapd</code>内核线程来异步地开始回收页框。</p>
</li>
<li><p>执行对内存管理区的第二次扫描，将值<code>z-&gt;pages_min</code>作为阈值<code>base</code>传递。实际阈值由<code>can_try_harder</code>和<code>gfp_high</code>决定。</p>
</li>
<li><p>如函数在上一步没终止，则系统内存肯定不足。如产生内存分配请求的内核控制路径不是一个中断处理程序或一个可延迟函数，且它试图回收页框（或是<code>current</code>的<code>PF_MEMALLOC</code>被置位，或它的<code>PF_MEMDIE</code>被置位），则函数随即执行对内存管理区的第三次扫描，试图分配页框并忽略内存的阈值。即不调<code>zone_watermark_ok</code>。唯有这种情况下才允许内核控制路径耗用为内存不足预留的页。这种情况下，产生内存请求的内核控制路径最终将试图释放页框，因此只要有可能它就应得到它所请求的。如没有任何内存管理区包含足够的页框，函数返回<code>NULL</code>来提示调用者发生了错误。</p>
</li>
<li><p>这里，正调用的内核控制路径并没试图回收内存。如<code>gfp_mask</code>的<code>__GFP_WAIT</code>没被置位，函数就返回<code>NULL</code>来提示该内核控制路径内存分配失败：此时，如不阻塞当前进程就没办法满足请求。</p>
</li>
<li><p>在这里当前进程能被阻塞：调<code>cond_resched</code>检查是否有其他的进程需<code>CPU</code>。</p>
</li>
<li><p>设置<code>current</code>的<code>PF_MEMALLOC</code>来表示进程已经准备好执行内存回收</p>
</li>
<li><p>将一个执行<code>reclaim_state</code>数据结构的指针存入<code>current-&gt;reclaim_state</code>。这个数据结构只包含一个字段<code>reclaimed_slab</code>。</p>
</li>
<li><p>调<code>try_to_free_pages</code>寻找一些页框来回收。函数可能阻塞当前进程。一旦函数返回，<code>__alloc_pages</code>就重设<code>current</code>的<code>PF_MEMALLOC</code>并再次调<code>cond_resched</code>。</p>
</li>
<li><p>如上一步已释放了一些页框，则函数还要执行一次与3步相同的内存管理区扫描。如内存分配请求不能被满足，则函数决定是否应继续扫描内存管理区；如<code>__GFP_NORETRY</code>被清除，且内存分配请求跨越了多达<code>8</code>个页框或<code>__GFP_REPEAT</code>和<code>__GFP_NOFAIL</code>其中之一被置位，则函数就调<code>blk_congestion_wait</code>使进程休眠一会儿，跳回<code>6</code>。否则，返回<code>NULL</code>。</p>
</li>
<li><p>如<code>9</code>没释放任何页框，就意味着内核遇到很大的麻烦。如允许内核控制路径依赖于文件系统的操作来杀死一个进程且<code>__GFP_NORETRY</code>为<code>0</code>，则执行：</p>
<blockquote>
<ol>
<li>使用等于<code>z-&gt;pages_high</code>的阈值再一次扫描内存管理区</li>
<li>调<code>out_of_memory</code>通过杀死一个进程开始释放一些内存</li>
<li>跳回<code>1</code>。</li>
</ol>
</blockquote>
</li>
</ol>
<p><strong>2.__free_pages–通过内存管理区执行释放页框</strong><br>参数：</p>
<ul>
<li>将要释放的第一个页框的页描述符的地址，</li>
<li>将要释放的一组连续页框的数量的对数。</li>
</ul>
<p>步骤：</p>
<ol>
<li>检查第一个页框是否真正属于动态内存（<code>PG_reserved</code>清0）；如不是，终止。</li>
<li>减少<code>page-&gt;count</code>；如仍大于或等于<code>0</code>，终止。</li>
<li>如<code>order</code>等于<code>0</code>，则调<code>free_hot_base</code>来释放页框给适当内存管理区的每<code>CPU</code>热高速缓存。</li>
<li>如<code>order</code>大于<code>0</code>，则它将页框加入到本地链表中，调<code>free_pages_bulk</code>把它们释放到适当的内存管理区的伙伴系统中。</li>
</ol>
<h3 id="内存高速缓存"><a href="#内存高速缓存" class="headerlink" title="内存高速缓存"></a>内存高速缓存</h3><p>伙伴系统算法采用页框作为基本内存区，这适合于对大块内存的请求，如何处理对小内存区的请求？<br>引入一种新的数据结构来描述在同一个页框中如何分配小内存区。</p>
<p>内核建立了13个按几何分布的空闲内存区链表，它们的大小从32字节到131072字节。</p>
<h4 id="1-内存高速缓存层次"><a href="#1-内存高速缓存层次" class="headerlink" title="1.内存高速缓存层次"></a>1.内存高速缓存层次</h4><p>内存高速高速缓存包含多个slab，每个slab由一个或多个连续的页框组成。这些页框中既包含已分配的对象，也包含空闲的对象。内核周期性地扫描高速缓存并释放空slab对应的页框。</p>
<h4 id="2-内存高速缓存描述符"><a href="#2-内存高速缓存描述符" class="headerlink" title="2.内存高速缓存描述符"></a>2.内存高速缓存描述符</h4><p>每个内存高速缓存由<code>kmem_cache_t</code>类型的数据结构来描述。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct array_cache*[]</td>
<td>array</td>
<td>每CPU指针数组指向包含空闲对象的本地高速缓存</td>
</tr>
<tr>
<td>unsigned int</td>
<td>batchcount</td>
<td>要转移进本地高速缓存或从本地高速缓存中转出的大批对象的数量</td>
</tr>
<tr>
<td>unsigned int</td>
<td>limit</td>
<td>本地高速缓存中空闲对象的最大数目。</td>
</tr>
<tr>
<td>struct kmem_list3</td>
<td>lists</td>
<td>参见下一个表</td>
</tr>
<tr>
<td>unsigned int</td>
<td>objsize</td>
<td>高速缓存中包含的对象的大小</td>
</tr>
<tr>
<td>unsigned int</td>
<td>flags</td>
<td>描述高速缓存永久属性的一组标志</td>
</tr>
<tr>
<td>unsigned int</td>
<td>num</td>
<td>封装在一个单独slab中的对象个数</td>
</tr>
<tr>
<td>unsigned int</td>
<td>free_limit</td>
<td>整个slab高速缓存中空闲对象的上限</td>
</tr>
<tr>
<td>spinlock_t</td>
<td>spinlock</td>
<td>高速缓存自旋锁</td>
</tr>
<tr>
<td>unsigned int</td>
<td>gfporder</td>
<td>一个单独slab中包含的连续页框数目的对数</td>
</tr>
<tr>
<td>unsigned int</td>
<td>gfpflags</td>
<td>分配页框时传递给伙伴系统函数的一组标志</td>
</tr>
<tr>
<td>size_t</td>
<td>colour</td>
<td>slab使用的颜色个数</td>
</tr>
<tr>
<td>unsigned int</td>
<td>colour_off</td>
<td>slab中的基本对齐偏移</td>
</tr>
<tr>
<td>unsigned int</td>
<td>colour_next</td>
<td>下一个被分配的slab使用的颜色</td>
</tr>
<tr>
<td>kmem_cache_t*</td>
<td>slabp_cache</td>
<td>指针指向包含slab描述符的普通slab高速缓存</td>
</tr>
<tr>
<td>unsigned int</td>
<td>slab_size</td>
<td>单个slab的大小</td>
</tr>
<tr>
<td>unsigned int</td>
<td>dflags</td>
<td>描述高速缓存动态属性的一组标志</td>
</tr>
<tr>
<td>void*</td>
<td>ctor</td>
<td>指向与高速缓存相关的构造方法的指针</td>
</tr>
<tr>
<td>void*</td>
<td>dtor</td>
<td>指向与高速缓存相关的析构方法的指针</td>
</tr>
<tr>
<td>const char*</td>
<td>name</td>
<td>存放高速缓存名字的字符数组</td>
</tr>
<tr>
<td>struct list_head</td>
<td>next</td>
<td>高速缓存描述符双向链表使用的指针</td>
</tr>
</tbody>
</table>
</div>
<p><code>kmem_cache_t</code>描述符的<code>lists</code>是一个结构体</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct list_head</td>
<td>slabs_partial</td>
<td>包含空闲和非空闲对象的slab描述符双向循环链表</td>
</tr>
<tr>
<td>struct list_head</td>
<td>slabs_full</td>
<td>不包含空闲对象的slab描述符双向循环链表</td>
</tr>
<tr>
<td>struct list_head</td>
<td>slabs_free</td>
<td>只包含空闲对象的slab描述符双向循环链表</td>
</tr>
<tr>
<td>unsigned long</td>
<td>free_objects</td>
<td>高速缓存中空闲对象的个数</td>
</tr>
<tr>
<td>int</td>
<td>free_touched</td>
<td>由slab分配器的页回收算法使用</td>
</tr>
<tr>
<td>unsigned long</td>
<td>next_reap</td>
<td>由slab分配器的页回收算法使用</td>
</tr>
<tr>
<td>struct array_cache*</td>
<td>shared</td>
<td>指向所有CPU共享的一个本地高速缓存的指针</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-slab描述符"><a href="#3-slab描述符" class="headerlink" title="3.slab描述符"></a>3.slab描述符</h4><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct list_head</td>
<td>list</td>
<td>slab描述符的三个双向循环链表中的一个</td>
</tr>
<tr>
<td>unsigned long</td>
<td>colouroff</td>
<td>slab中第一个对象的偏移</td>
</tr>
<tr>
<td>void*</td>
<td>s_mem</td>
<td>slab中第一个对象的地址</td>
</tr>
<tr>
<td>unsigned int</td>
<td>inuse</td>
<td>当前正使用的slab中的对象个数</td>
</tr>
<tr>
<td>unsigned int</td>
<td>free</td>
<td>slab中下一个空闲对象的下标，如没剩下空闲对象则为BUFCTL_END</td>
</tr>
</tbody>
</table>
</div>
<p><code>slab</code>描述符可存放在两个可能的地方：<br>外部<code>slab</code>描述符–存放在<code>slab</code>外部，位于<code>cache_sizes</code>指向的一个不适合<code>ISA DMA</code>的普通高速缓存中。<br>内部<code>slab</code>描述符–存放在<code>slab</code>内部，位于分配给<code>slab</code>的第一个页框的起始位置</p>
<p>当对象小于<code>512MB</code>，或当内部碎片为<code>slab</code>描述符和对象描述符在<code>slab</code>中留下足够的空间时，<code>slab</code>分配器选第二种方案。<br>如<code>slab</code>描述符存放在<code>slab</code>外部，则高速缓存描述符的<code>flags</code>中<code>CFLAGS_OFF_SLAB</code>置<code>1</code>。</p>
<h4 id="4-普通和专用高速缓存"><a href="#4-普通和专用高速缓存" class="headerlink" title="4.普通和专用高速缓存"></a>4.普通和专用高速缓存</h4><p>高速缓存被分为两种类型：普通和专用。<br>普通高速缓存只由slab分配器用于自己的目的，专用高速缓存由内核的其余部分使用。</p>
<p>普通高速缓存是：<br>1.第一个高速缓存叫<code>kmem_cache</code>，包括由内核使用的其余高速缓存的高速缓存描述符。<code>cache_cache</code>变量包含第一个高速缓存的描述符。<br>2.另外一些高速缓存包含用作普通用途的内存区。</p>
<p>内存区大小的范围一般包括<code>13</code>个几何分布的内存区。一个叫<code>malloc_sizes</code>的表分分别指向<code>26</code>个高速缓存描述符，与其相关的内存区大小为<code>32，64，128，256，512，1024，2048，4096，8192，16384，32768，65536</code>和<code>131072</code>字节。对每种大小，都有两个高速缓存：一个适用于<code>ISA DMA</code>分配，另一个适用于常规分配。</p>
<p>在系统初始化期间调<code>kmem_cache_init</code>来建立普通高速缓存。<br>专用高速缓存由<code>kmem_cache_create</code>创建。函数从<code>cache_cache</code>普通高速缓存中为新的高速缓存分配一个高速缓存描述符，插入到高速缓存描述符的<code>cache_chain</code>。<br><code>kmem_cache_destroy</code>撤销一个高速缓存，并将它从cache_chain链表上删除。</p>
<p><code>kmem_cache_shrink</code>通过反复调<code>slab_destroy</code>来撤销高速缓存中所有的<code>slab</code>。<br>所有普通和专用高速缓存的名字都可在运行期间通过读<code>/proc/slabinfo</code>得到。这个文件也指明每个高速缓存中空闲对象的个数和已分配对象的个数。</p>
<h4 id="5-为slab分配页框，释放页框"><a href="#5-为slab分配页框，释放页框" class="headerlink" title="5.为slab分配页框，释放页框"></a>5.为slab分配页框，释放页框</h4><p><strong>kmem_getpages–slab的页框获取</strong><br>参数：<br><code>cachep</code>–指向需额外页框的高速缓存的高速缓存描述符，请求页框的个数由存放在<code>cache-&gt;gfporder</code>中的<code>order</code>决定。<br><code>flags</code>–说明如何请求页框。这组标志与存放在高速缓存描述符的<code>gfpflags</code>中的专用高速缓存分配标志相结合。</p>
<p>在UMA系统上该函数本质上等价于</p>
<pre class="line-numbers language-none"><code class="language-none">void* kmem_getpages(kmem_cache_t* cachep, int flags)
&#123;
	struct page* page;
	int i;
	flags |&#x3D; cachep-&gt;gfpflags;
	page &#x3D; alloc_pages(flags, cachep-&gt;gfporder);
	if(!page)
		return NULL;
	i &#x3D; (1 &lt;&lt; cache-&gt;gfporder);
	if(cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)
		atomic_add(i, &amp;slab_reclaim_pages);
	while(i--)
		SetPageSlab(page++);
	return page_address(page);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如已创建了<code>slab</code>高速缓存且<code>SLAB_RECLARM_ACCOUNT</code>标志已经置位，则内核检查是否有足够的内存来满足一些用户态请求时，分配给<code>slab</code>的页框将被记录为可回收的页。函数还将所分配页框的页描述符中的<code>PG_slab</code>标志置位。</p>
<p><strong>kmem_freepages–释放分配给slab的页框</strong></p>
<pre class="line-numbers language-none"><code class="language-none">void kmem_freepages(kmem_cache_t* cachep, void* addr)
&#123;
	unsigned long i &#x3D; (1 &lt;&lt; cachep-&gt;gfporder);
	struct page* page &#x3D; virt_to_page(addr);
	if(current-&gt;reclaim_state)
		current-&gt;reclaim_state-&gt;reclaimed_slab +&#x3D; i;
	while(i--)
		ClearPageSlab(page++);
	free_pages((unsigned long)addr, cachep-&gt;gfporder);
	if(cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)
		atomic_sub(1 &lt;&lt; cachep-&gt;gfporder, &amp;slab_reclaim_pages);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数从线性地址<code>addr</code>开始释放页框，这些页框曾分配给由<code>cachep</code>标识的高速缓存中的<code>slab</code>。如当前进程正在执行内存回收，<code>reclaim_state</code>结构的<code>reclaimed_slab</code>就被适当地增加，于是刚被释放的页就能通过页框回收算法被记录下来。此外，如<code>SLAB_RECLAIM_ACCOUNT</code>标志置位，<code>slab_reclaim_pages</code>则被适当地减少。</p>
<h4 id="6-内存给高速缓存分配slab"><a href="#6-内存给高速缓存分配slab" class="headerlink" title="6.内存给高速缓存分配slab"></a>6.内存给高速缓存分配slab</h4><p>一个新创建的高速缓存没有包含任何<code>slab</code>，因此也没空闲的对象。只有当以下两个条件都为真时，才给高速缓存分配<code>slab</code>。</p>
<ul>
<li>已发出一个分配新对象的请求</li>
<li>高速缓存不包含任何空闲对象</li>
</ul>
<p>这些情况发生时，通过调<code>cache_grow</code>给高速缓存分配一个新的<code>slab</code>。这个函数调<code>kmem_getpages</code>从分区页框分配器获得一组页框来存放一个单独的<code>slab</code>，然后又调<code>alloc_slabmgmt</code>获得一个新的<code>slab</code>描述符。如高速缓存描述符的<code>CFLGS_OFF_SLAB</code>置位，则从高速缓存描述符的<code>slabp_cache</code>字段指向的普通高速缓存中分配这个<code>slab</code>描述符，否则，从<code>slab</code>的第一个页框中分配这个<code>slab</code>描述符。</p>
<p>给定一个页框，内核需确定它是否被<code>slab</code>分配器使用。如是， 迅速得到相应高速缓存和<code>slab</code>描述符地址。故，<code>cache_grow</code>扫描分配给新<code>slab</code>的页框的所有页描述符，将高速缓存描述符和<code>slab</code>描述符的地址分别赋给页描述符中<code>lru</code>的<code>next</code>和<code>prev</code>。只有当页框空闲时伙伴系统的函数才会使用<code>lru</code>。所以，<code>lru</code>不会误用。分配给<code>slab</code>的页框设置<code>PG_slab</code>标志。</p>
<p>在高速缓存中给定一个<code>slab</code>，可通过使用<code>slab</code>描述符的<code>s_mem</code>和高速缓存描述符的<code>gfporder</code>来找到依赖的页框描述符。接着，<code>cache_grow</code>调<code>cache_init_objs</code>，将构造方法应用到新<code>slab</code>包含的所有对象上。最后，<code>cache_grow</code>调<code>list_add_tail</code>将新的<code>slab</code>描述符添加到高速缓存描述符<code>*cachep</code>的<code>slab</code>链表末端，并更新高速缓存中的空闲对象计数器</p>
<pre class="line-numbers language-none"><code class="language-none">list_add_tail(&amp;slab-&gt;list, &amp;cachep-&gt;lists-&gt;slabs_free);
cachep-&gt;lists-&gt;free_objects +&#x3D; cachep-&gt;num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="7-从高速缓存中释放slab"><a href="#7-从高速缓存中释放slab" class="headerlink" title="7.从高速缓存中释放slab"></a>7.从高速缓存中释放slab</h4><p>在两种条件下才能撤销slab：</p>
<ul>
<li>内存高速缓存中有太多的空闲对象</li>
<li>被周期性调用的定时器函数确定是否有完全未使用的slab能被释放。</li>
</ul>
<p>在两种情况下，调<code>slab_destroy</code>撤销一个<code>slab</code>，并释放相应的页框到分区页框分配器。</p>
<pre class="line-numbers language-none"><code class="language-none">void slab_destroy(kmem_cache_t *cachep, slab_t *slabp)
&#123;
	if(cachep-&gt;dtor)
	&#123;
		int i;
		for(i &#x3D; 0; i &lt; cachep-&gt;num; i++)
		&#123;
			void* objp &#x3D; slabp-&gt;s_mem + cachep-&gt;objsize * i;
			(cachep-&gt;dtor)(objp, cachep, 0);
		&#125;
	&#125;
	kmem_freepages(cachep, slabp-&gt;s_mem - slabp-&gt;colouroff);
	if(cachep-&gt;flags &amp; CFLAGS_OFF_SLAB)
		kmem_cache_free(cachep-&gt;slabp_cache, slabp);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>检查高速缓存是否为它的对象提供了析构，如是，使用析构方法释放<code>slab</code>中所有对象。<code>objp</code>记录当前已检查的对象。<code>kmem_freepages</code>把<code>slab</code>使用的所有连续页框返回给伙伴系统。如<code>slab</code>描述符存放在<code>slab</code>外面，就从<code>slab</code>描述符的高速缓存释放这个<code>slab</code>描述符。实际上，该函数稍微复杂些。如，可使用<code>SLAB_DESTROY_BY_RCU</code>来创建<code>slab</code>高速缓存，这意味着应使用<code>call_rcu</code>注册一个回调来延期释放<code>slab</code>。回调函数接着调<code>kmem_freepages</code>，也可能调<code>kmem_cache_free</code>。</p>
<h4 id="8-对象描述符"><a href="#8-对象描述符" class="headerlink" title="8.对象描述符"></a>8.对象描述符</h4><p>每个对象有类型为<code>kmem_bufctl_t</code>的一个描述符，对象描述符存放在一个数组中，位于相应的<code>slab</code>描述符后。类似<code>slab</code>描述符，<code>slab</code>的对象描述符也可用两种可能的方式来存放：</p>
<ol>
<li>外部对象描述符–存放在<code>slab</code>的外面，位于高速缓存描述符的<code>slabp_cache</code>字段指向的一个普通高速缓存中。内存区的大小取决于在<code>slab</code>中所存放的对象个数。</li>
<li>内部对象描述符–存放在<code>slab</code>内部，正好位于描述符所描述的对象前</li>
</ol>
<p>对象描述符只不过是一个无符号整数，只有在对象空闲时才有意义。它包含的是下一个空闲对象在slab中的下标。因此实现了slab内部空闲对象的一个简单链表。空闲对象链表中的最后一个元素的对象描述符用常规值<code>BUFCTL_END</code>标记。</p>
<h4 id="9-对齐内存中的对象"><a href="#9-对齐内存中的对象" class="headerlink" title="9.对齐内存中的对象"></a>9.对齐内存中的对象</h4><p><code>slab</code>分配器所管理的<strong>对象可在内存中进行对齐</strong>。即存放它们的内存单元的起始物理地址是一个给定常量的倍数。通常是<code>2</code>的倍数，这个常量就叫对齐因子。<strong><code>slab</code>分配器所允许的最大对齐因子是<code>4096</code>，即页框大小</strong>。</p>
<p>通常，如内存单元的物理地址是字大小（即计算机内部内存总线宽度）对齐的，则微机对内存单元的存取会非常快。因此，缺省下，<code>kmem_cache_create</code>根据<code>BYTES_PER_WORD</code>宏所指定的字大小来对齐对象。对于，<code>80x86</code>处理器，这个宏产生值<code>4</code>。当创建一个新的<code>slab</code>高速缓存时，就可让它所包含的对象在第一级高速缓存中对齐。为做到这点，设置<code>SLAB_HWCACHE_ALIGN</code>标志。</p>
<p><code>kmem_cache_create</code>按如下方式处理请求：</p>
<ol>
<li>如对象的大小大于高速缓存行的一半，就在<code>RAM</code>中根据<code>L1_CACHE_BYTES</code>的倍数对齐对象</li>
<li>否则，对象的大小就是<code>L1_CACHE_BYTES</code>的因子取整。这可保证一个小对象不会横跨两个高速缓存行。</li>
</ol>
<h4 id="10-slab着色"><a href="#10-slab着色" class="headerlink" title="10.slab着色"></a>10.slab着色</h4><p>同一硬件高速缓存行可映射<code>RAM</code>中很多不同的块。相同大小的对象倾向于存放在高速缓存内相同的偏移量处。在不同<code>slab</code>内具有相同偏移量的对象最终很可能映射在同一高速缓存行中。高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与<code>RAM</code>内存单元之间来来往往传送两个对象，而其他的高速缓存行并未充分使用。</p>
<p><code>slab</code>分配器通过一种叫<code>slab</code>着色的策略，尽量降低高速缓存的这种不愉快行为：把叫做颜色的不同随机数分配给<code>slab</code>。我们考虑某个高速缓存，它的对象在<code>RAM</code>中被对齐。意味着对象的地址肯定是某个给定正数值的倍数。连对齐的约束也考虑在内，在<code>slab</code>内放置对象就有很多种可能的方式。方式的选择取决于对下列变量所作的决定：</p>
<ul>
<li><code>num</code>–可在slab中存放的对象个数</li>
<li><code>osize</code>–对象的大小。包括对齐的字节。</li>
<li><code>dsize</code>–slap描述符的大小加上所有对象描述符的大小，就等于硬件高速缓存行大小的最小倍数。如slab描述符和对象描述符都放在slap外部，这个值等于0。</li>
<li><code>free</code>–在slab内未用字节个数</li>
</ul>
<p>​    一个<code>slab</code>中的总字节长度=<code>(num*osize)+dsize+free</code>。<code>free</code>总是小于<code>osize</code>，不过可大于<code>aln</code>。<code>slab</code>分配器利用空闲未用的字节<code>free</code>来对<code>slab</code>着色。术语着色只是用来再细分<code>slab</code>，并允许内存分配器把对象展开在不同的线性地址中。这样的话，内核从微处理器的硬件高速缓存中可获得最好性能。具有不同颜色的<code>slab</code>把<code>slab</code>的第一个对象存放在不同的内存单元，同时满足对齐约束。</p>
<p>​    可用颜色的个数是<code>free/aln</code>（这个值存放在高速缓存描述符的<code>colour</code>字段）。故，第一个颜色表示<code>0</code>，最后一个颜色表示为<code>(free/aln)-1</code>。一种特殊的情况是，如<code>free</code>比<code>aln</code>小，则<code>colour</code>被设为<code>0</code>，不过所有<code>slab</code>都使用颜色<code>0</code>，故颜色的真正个数是<code>1</code>。</p>
<p>​    如用颜色<code>col</code>对一个<code>slab</code>着色，则，第一个对象的偏移量（相对于<code>slab</code>的起始地址）就等于<code>col*aln+dsize</code>。着色本质上导致把<code>slab</code>中的一些空闲区域从末尾移到开始。只有当<code>free</code>足够大时，着色才起作用。显然，如对象没请求对齐，或如果<code>slab</code>内的未使用字节数小于所请求的对齐（<code>free&lt;=aln</code>），则唯一可能着色的<code>slab</code>就是具有颜色<code>0</code>的<code>slab</code>，即，把这个<code>slab</code>的第一个对象的偏移量赋为<code>0</code>。</p>
<p>​    通过把当前颜色存放在高速缓存描述符的<code>colour_next</code>字段，就可在一个给定对象类型的<code>slab</code>之间平等地发布各种颜色。 <code>cache_grow</code>把<code>colour_next</code>所表示的颜色赋给一个新的<code>slab</code>，并递增这个字段的值。当<code>colour_next</code>的值变为<code>colour</code>后，又从<code>0</code>开始。这样，每个新创建的<code>slab</code>都与前一个<code>slab</code>具有不同的颜色，直到最大可用颜色。此外，<code>cache_grow</code>从高速缓存描述符的<code>colour_off</code>字段获得值<code>aln</code>，根据<code>slab</code>内对象的个数计算<code>dsize</code>，最后把<code>col*aln+dsize</code>的值存放到<code>slab</code>描述符的<code>colouroff</code>字段中。</p>
<h4 id="11-空闲Slab对象的本地高速缓存–slab分配器和内存申请使用者的中间层"><a href="#11-空闲Slab对象的本地高速缓存–slab分配器和内存申请使用者的中间层" class="headerlink" title="11.空闲Slab对象的本地高速缓存–slab分配器和内存申请使用者的中间层"></a>11.空闲Slab对象的本地高速缓存–slab分配器和内存申请使用者的中间层</h4><p><code>Linux 2.6</code>对多处理器系统上<code>slab</code>分配器的实现不同于<code>Solaris 2.4</code>最初实现。为减少处理器之间对自旋锁的竞争并更好利用硬件高速缓存，<code>slab</code>分配器的每个高速缓存包含一个被称作<code>slab</code>本地高速缓存的每<code>CPU</code>数据结构，该结构由一个指向被释放对象的小指针数组组成。<code>slab</code>对象的大多数分配和释放只影响本地数组，只有在本地数组下溢或上溢时才涉及<code>slab</code>数据结构。类似前面的每<code>CPU</code>页框高速缓存。高速缓存描述符的<code>array</code>字段是一组指向<code>array_cache</code>数据结构的指针，系统中的每个<code>CPU</code>对应于一个元素。每个<code>array_cache</code>数据结构是空闲对象的本地高速缓存的一个描述符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unsigned int</td>
<td>avail</td>
<td>指向本地高速缓存中可使用对象的指针的个数。同时作为高速缓存中第一个空槽的下标</td>
</tr>
<tr>
<td>unsigned int</td>
<td>limit</td>
<td>本地高速缓存的大小。即本地高速缓存中指针的最大个数</td>
</tr>
<tr>
<td>unsigned int</td>
<td>batchcount</td>
<td>本地高速缓存重新填充或腾空时使用的块大小</td>
</tr>
<tr>
<td>unsigned int</td>
<td>touched</td>
<td>如本地高速缓存最近已被使用过，则该标志设为1</td>
</tr>
</tbody>
</table>
</div>
<p>本地高速缓存描述符并不包含本地高速缓存本身的地址；事实上，它正好位于描述符之后。当然，本地高速缓存存放的是指向已释放对象的指针。对象本身总是位于高速缓存的<code>slab</code>中。</p>
<p>当创建一个新的<code>slab</code>高速缓存时，<code>kmem_cache_create</code>决定本地高速缓存的大小（将这个值存放在高速缓存描述符的<code>Limit</code>字段），分配本地高速缓存，将它们的指针存放在高速缓存描述符的<code>array</code>字段。<code>batchcount</code>字段的初始值，即从一个本地高速缓存的块里添加或删除的对象的个数，被初始化为本地高速缓存大小的一半。</p>
<p>在多处理器系统中，<code>slab</code>高速缓存含一个附加的本地高速缓存，它的地址被存放在高速缓存描述符的<code>lists.shared</code>中。共享的本地高速缓存正如它的名字暗示那样，被所有<code>CPU</code>共享，它使得将空闲对象从一个本地高速缓存移动到另一个高速缓存的任务更容易。它的初始大小等于<code>batchcount</code>字段值的<code>8</code>倍。</p>
<h4 id="12-分配slab对象"><a href="#12-分配slab对象" class="headerlink" title="12.分配slab对象"></a>12.分配slab对象</h4><p>通过调<code>kmem_cache_alloc</code>可获得新对象。参数<code>cachep</code>指向高速缓存描述符，新空闲对象必须从该高速缓存描述符获得，参数<code>flag</code>表示传递给分区页框分配器函数的标志。该高速缓存的所有<code>slab</code>应是满的</p>
<pre class="line-numbers language-none"><code class="language-none">void* kmem_cache_alloc(kmem_cache_t* cachep, int flags)
&#123;
	unsigned long save_flags;
	void* objp;
	struct array_cache* ac;
	local_irq_save(save_flags);&#x2F;&#x2F; 禁止本cpu上外部中断，保存标志信息
	ac &#x3D; cache_p-&gt;array[smp_processor_id()];&#x2F;&#x2F; 从内存高速缓存中取得当前cpu的本地高速缓存
	if(ac-&gt;avail)
	&#123;
		ac-&gt;touched &#x3D; 1;
		objp &#x3D; ((void**)(ac+1))[--ac-&gt;avail];
	&#125;
	else
		objp &#x3D; cache_alloc_refill(cache_p, flags);
	local_irq_restore(save_flags);&#x2F;&#x2F; 恢复中断设置，恢复标志信息
	return objp;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    先试图从本地高速缓存获得一个空闲对象。如有，<code>avail</code>就包含指向最后被释放的对象的项在本地高速缓存中的下标。<br>因为本地高速缓存数组正好存放在<code>ac</code>描述符后面。故， <code>((void**)(ac+1))[--ac-&gt;avail];</code>获得空闲对象地址，递减<code>ac-&gt;avail</code>。<br>​    当本地高速缓存没空闲对象时，<code>cache_alloc_refill</code>重新填充本地高速缓存并获得一个空闲对象。</p>
<p><strong>cache_alloc_refill:</strong></p>
<ol>
<li><p>将本地高速缓存描述符地址放在<code>ac</code>局部变量<code>ac = cachep-&gt;array[smp_processor_id()]</code></p>
</li>
<li><p>获得<code>cachep-&gt;spinlock</code></p>
</li>
<li><p>如<code>slab</code>高速缓存包含共享本地高速缓存，且该共享本地高速缓存包含一些空闲对象，就通过从共享本地高速缓存中上移<code>ac-&gt;batchcount</code>个指针来重新填充<code>CPU</code>的本地高速缓存。跳<code>6</code>。</p>
</li>
<li><p>试图填充本地高速缓存，填充值为高速缓存的<code>slab</code>中包含的多达<code>ac-&gt;batchcount</code>个空闲对象的指针</p>
<blockquote>
<ol>
<li><p>查看高速缓存描述符的<code>slabs_partial</code>和<code>slabs_free</code>，获得<code>slab</code>描述符的地址<code>slabp</code>，该<code>slab</code>描述符的相应<code>slab</code>或部分被填充，或为空。如不存在这样的描述符，跳<code>5</code>。</p>
</li>
<li><p>对<code>slab</code>中的每个空闲对象，增加<code>slab</code>描述符的<code>inuse</code>，将对象的地址插入本地高速缓存，更新<code>free</code>使得它存放了<code>slab</code>中下一空闲对象下标</p>
</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">slabp-&gt;inuse++;
((void**)(ac+1))[ac-&gt;avail++] &#x3D; slabp-&gt;s_mem + slabp-&gt;free * cachep-&gt;obj_size;
slabp-&gt;free &#x3D; ((kmem_bufctl_t*)(slabp+1))[slabp-&gt;free];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol>
<li>如必要，将清空的<code>slab</code>插入到适当的链表上，可以是<code>slab_full</code>，也可是<code>slab_partial</code>。</li>
</ol>
</blockquote>
</li>
<li><p>这里，被加到本地高速缓存上的指针个数被存放在<code>ac-&gt;avail</code>，函数递减同样数量的<code>kmem_list3</code>结构的<code>free_objects</code>来说明这些对象不再空闲</p>
</li>
<li><p>释放<code>cachep-&gt;spinlock</code></p>
</li>
<li><p>如现在<code>ac-&gt;avail</code>字段大于<code>0</code>（一些高速缓存再填充的情况发生了），函数将<code>ac-&gt;touched</code>设为<code>1</code>，返回最后插入到本地高速缓存的空闲对象指针：<code>return ((void**)(ac+1))[--ac-&gt;avail];</code></p>
</li>
<li><p>否则，没发生高速缓存缓存再填充情况，调<code>cache_grow</code>获得一个新<code>slab</code>。从而获得新的空闲对象。</p>
</li>
<li><p>如<code>cache_grow</code>失败了，函数返回<code>NULL</code>。否则，返回<code>1</code>。</p>
</li>
</ol>
<h4 id="13-释放slab对象"><a href="#13-释放slab对象" class="headerlink" title="13. 释放slab对象"></a>13. 释放slab对象</h4><pre class="line-numbers language-none"><code class="language-none">void kmem_cache_free(kmem_cache_t* cachep, void *objp)
&#123;
	unsigned long flags;
	struct array_cache* ac;
	local_irq_save(flags);&#x2F;&#x2F; 禁止本地中断，保存标志信息
	ac &#x3D; cachep-&gt;array[smp_procesor_id()];&#x2F;&#x2F; 获取本地CPU高速缓存
	if(ac-&gt;avail &#x3D;&#x3D; ac-&gt;limit)&#x2F;&#x2F; 本地cpu高速缓存满了
		cache_flusharray(cachep, ac);
	((void**)(ac+1))[ac-&gt;avail++] &#x3D; objp;&#x2F;&#x2F; 没满，直接放入
	local_irq_restore(flags);&#x2F;&#x2F; 恢复本地中断，恢复标志信息
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    先检查本地高速缓存是否有空间给指向一个空闲对象的额外指针，如有，该指针就被加到本地高速缓存然后返回。否则，它首选调<code>cache_flusharray</code>清空本地高速缓存，然后将指针加到本地高速缓存。</p>
<p><strong>cache_flusharray：</strong></p>
<ol>
<li><p>获得<code>cachep-&gt;spinlock</code></p>
</li>
<li><p>如<code>slab</code>高速缓存包含一个共享本地高速缓存，且如该共享本地缓存还没满，函数就通过从<code>CPU</code>的本地高速缓存中上移<code>ac-&gt;batchcount</code>个指针来重新填充共享本地高速缓存</p>
</li>
<li><p>调<code>free_block</code>将当前包含在本地高速缓存中的<code>ac-&gt;batchcount</code>个对象归还给<code>slab</code>分配器。<br>对在地址<code>objp</code>处的每个对象，执行如下：</p>
<blockquote>
<ol>
<li><p>增加高速缓存描述符的<code>lists.free_objects</code></p>
</li>
<li><p>确定包含对象的<code>slab</code>描述符的地址</p>
<pre class="line-numbers language-none"><code class="language-none">slabp &#x3D; (struct slab*)(virt_to_page(objp)-&gt;lru.prev);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>记住，<code>slab</code>页的描述符的<code>lru.prev</code>指向相应的<code>slab</code>描述符</p>
</li>
<li><p>从它的<code>slab</code>高速缓存链表(<code>cachep-&gt;lists.slabs_partial</code>或<code>cachep-&gt;lists.slabs_full</code>)上删除<code>slab</code>描述符。</p>
</li>
<li><p>计算<code>slab</code>内对象的下标</p>
<pre class="line-numbers language-none"><code class="language-none">objnr &#x3D; (objp - slabp-&gt;s_mem) &#x2F; cachep-&gt;objsize;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>将<code>slabp-&gt;free</code>的当前值存放在对象描述符中，并将对象的下标放入<code>slabp-&gt;free</code>（最后被释放的对象将再次成为首先被分配的对象，提升硬件高速缓存命中率）</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">kmem_bufctl_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>slabp<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>objnr<span class="token punctuation">]</span> <span class="token operator">=</span> slabp<span class="token operator">-></span>free<span class="token punctuation">;</span><span class="token comment">// 利用对象内存（空闲对象）作为单向链表的索引值</span>
slabp<span class="token operator">-></span>free <span class="token operator">=</span> objnr<span class="token punctuation">;</span><span class="token comment">// 下次分配将从上次释放对象开始分配（提升硬件高速缓存命中率）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>递减<code>slabp-&gt;inuse</code></p>
</li>
<li><p>如<code>slabp-&gt;inuse</code>等于<code>0</code>（即<code>slab</code>中所有对象空闲）且整个<code>slab</code>高速缓存中空闲对象的个数（<code>cachep-&gt;lists.free_objects</code>）大于<code>cachep-&gt;free_limit</code>字段中存放的限制，则函数将<code>slab</code>的页框释放到分区页框分配器</p>
<pre class="line-numbers language-none"><code class="language-none">cachep-&gt;lists.free_objects -&#x3D; cachep-&gt;num;
slab_destroy(cachep, slabp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>存放在<code>cachep-&gt;free_limit</code>字段中的值通常等于<code>cachep-&gt;num+(1+N)*cachep-&gt;batchcount</code>，其中<code>N</code>代表系统中<code>CPU</code>的个数</p>
</li>
<li><p>否则，如<code>slab-&gt;inuse</code>等于<code>0</code>，但整个<code>slab</code>高速缓存中空闲对象的个数小于<code>cachep-&gt;free_limit</code>，函数就将<code>slab</code>描述符插入到<code>cachep-&gt;lists.slab_free</code>链表中</p>
</li>
<li><p>最后，如<code>slab-&gt;inuse</code>大于<code>0</code>，<code>slab</code>被部分填充，则函数将<code>slab</code>描述符插入到<code>cachep-&gt;lists.slabs_partial</code>链表</p>
</li>
</ol>
</blockquote>
</li>
<li><p>释放<code>cachep-&gt;spinlock</code></p>
</li>
<li><p>通过减去被移到共享本地高速缓存或被释放到<code>slab</code>分配器的对象的个数来更新本地高速缓存描述符的<code>avail</code></p>
</li>
<li><p>移动本地高速缓存数组起始处的那个本地高速缓存中的所有指针。因为，已经把第一个对象指针从本地高速缓存上删除，故剩下的指针必须上移。</p>
</li>
</ol>
<h4 id="14-通用对象"><a href="#14-通用对象" class="headerlink" title="14.通用对象"></a>14.通用对象</h4><p>如对存储器的请求不频繁，就用一组普通高速缓存来处理。普通高速缓存中的对象具有几何分布的大小，范围为<code>32~131072</code>字节。</p>
<pre class="line-numbers language-none"><code class="language-none">void* kmalloc(size_t size, int flags)
&#123;
	struct cache_sizes *csizep &#x3D; malloc_sizes;
	kmem_cache_t* cachep;
	for(; csizep-&gt;cs_size; csizep++)
	&#123;
		if(size &gt; csizep-&gt;cs_size)
			continue;
		if(flag &amp; __GFP_DMA)
			cachep &#x3D; csizep-&gt;cs_dmacachep;
		else
			cachep &#x3D; csizep-&gt;cs_cachep;
		return kmem_cache_alloc(cachep, flags);
	&#125;
	return NULL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数用<code>malloc_sizes</code>表为所请求的大小分配最近的<code>2</code>的幂次方大小内存。然后，调<code>kmem_cache_alloc</code>分配对象。<br>依据flag，决定是采用适用于<code>ISA DMA</code>页框的高速缓存描述符，还是适用于”常规”页框的高速缓存描述符。</p>
<pre class="line-numbers language-none"><code class="language-none">void kfree(const void* objp)
&#123;
	kmem_cache_t* c;
	unsigned long flags;
	if(!objp)
		return;
	local_irq_save(flags);
	c &#x3D; (kmem_cache_t*)(virt_to_page(objp)-&gt;lru.next);
	kmem_cache_free(c, (void*)objp);
	local_irq_restore(flags);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过读取内存区所在的第一个页框描述符的<code>lru.next</code>子字段，就可确定出合适的高速缓存描述符。<br>通过调<code>kmem_cache_free</code>来释放相应的内存区。</p>
<h4 id="15-内存池–使用者可以直接与kmem-cache交互，也可与mempool-t交互"><a href="#15-内存池–使用者可以直接与kmem-cache交互，也可与mempool-t交互" class="headerlink" title="15.内存池–使用者可以直接与kmem_cache交互，也可与mempool_t交互"></a>15.内存池–使用者可以直接与kmem_cache交互，也可与mempool_t交互</h4><p>是<code>Linux2.6</code>的一个新特性。<strong>基本上讲，一个内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。不应该将内存池与前面”保留的页框池”一节描述的保留页框混淆。实际上，这些页框只能用于满足中断处理程序或内部临界区发出的原子内存分配请求。</strong>而内存池是动态内存的储备，只能被特定的内核成分（即池的”拥有者”）使用。拥有者通常不使用储备；但，如动态内存变得极其稀有以至于所有普通内存分配请求都将失败的话，那么作为最后的解决手段， 内核成分就能调特定的内存池函数提取储备得到所需的内存。因此，创建一个内存池就像手头存放一些罐装食物作为储备，当没有新鲜食物时就使用开罐器。</p>
<p>一个内存池常常叠加在slab分配器之上–即，它用来保存slab对象的储备。但，一般而言，内存池能被用来分配任何一种类型的动态内存，从整个页框到使用kmalloc分配的小内存区。故，我们一般将内存池处理的内存单元看作”内存元素”。</p>
<p>内存池由<code>mempool_t</code>描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>spinlock_t</td>
<td>lock</td>
<td>用来保护对象字段的自旋锁</td>
</tr>
<tr>
<td>int</td>
<td>min_nr</td>
<td>内存池中元素的最大个数</td>
</tr>
<tr>
<td>int</td>
<td>curr_nr</td>
<td>当前内存池中元素的个数</td>
</tr>
<tr>
<td>void**</td>
<td>elements</td>
<td>指向一个数组的指针，该数组由指向保留元素的指针组成</td>
</tr>
<tr>
<td>void*</td>
<td>pool_data</td>
<td>池的拥有者可获得的私有数据</td>
</tr>
<tr>
<td>mempool_alloc_t*</td>
<td>alloc</td>
<td>分配一个元素的方法</td>
</tr>
<tr>
<td>mempool_free_t*</td>
<td>free</td>
<td>释放一个元素的方法</td>
</tr>
<tr>
<td>wait_queue_head_t</td>
<td>wait</td>
<td>当内存池为空时使用的等待队列</td>
</tr>
</tbody>
</table>
</div>
<p><code>min_nr</code>字段存放了内存池中元素的初始个数。即，存放在该字段的值代表了内存元素的个数。内存池拥有者确信能从内存分配器得到这个数目。<code>curr_nr</code>字段总是低于或等于<code>min_nr</code>，它存放了内存池中当前包含的内存元素个数。内存元素自身被一个指针数组引用，指针数组地址存放在<code>elements</code>。</p>
<p><code>alloc，free</code>与基本的内存分配器交互，分别用于获得和释放一个内存元素，两个方法可是拥有内存池的内核成分提供的定制函数。当内存元素是<code>slab</code>对象时，<code>alloc，free</code>一般由<code>mempool_alloc_slab</code>和<code>mempool_free_slab</code>实现，它们只是分别调<code>kmem_cache_alloc</code>和<code>kmem_cache_free</code>。这种情况下，<code>mempool_t</code>对象的<code>pool_data</code>字段存放了<code>slab</code>高速缓存描述符的地址。</p>
<p><strong>mempool_create创建一个新的内存池；</strong><br>它接收的参数为：内存元素的个数<code>min_nr</code>，实现<code>alloc，free</code>方法的函数的地址，赋给<code>pool_data</code>字段的值。<br>函数分别为<code>mempool_t</code>对象和指向内存元素的指针数组分配内存，然后反复调<code>alloc</code>方法来得到<code>min_nr</code>个内存元素。<br>相反地，<code>mempool_destroy</code>释放池中所有内存元素，然后释放元素数组和<code>mempool_t</code>对象自己。</p>
<p><strong>mempool_alloc–从内存池分配一个元素：</strong><br>内核调<code>mempool_alloc</code>，将<code>mempool_t</code>对象的地址和内存分配标志传递给它。<br>函数本质上依据参数所指定的内存分配标志，试图通过调<code>alloc</code>从基本内存分配器分配一个内存元素。<br>如成功，函数返回获得的内存元素而不触及内存池。否则，如分配失败，就从内存池获得内存元素。<br>当然，内存不足情况下过多的分配会用尽内存池：这种情况下，如<code>__GFP_WAIT</code>标志置位，则<code>mempool_alloc</code>阻塞当前进程直到有一个内存元素被释放到内存池中。</p>
<p><strong>mempool_free–释放一个元素到内存池</strong><br>内核调<code>mempool_free</code>。如内存池未满，则函数将元素加到内存池。否则，<code>mempool_free</code>调<code>free</code>方法来释放元素到基本内存分配器。</p>
<h2 id="非连续内存区管理"><a href="#非连续内存区管理" class="headerlink" title="非连续内存区管理"></a>非连续内存区管理</h2><p>把内存区映射到一组连续的页框是最好的选择，会充分利用高速缓存并获得较低的平均访问时间。<br>如对内存区的请求不频繁，则通过连续的线性地址来访问非连续的页框这样一种分配模式会很有意义。这种模式优点是避免了外碎片，缺点是打乱内核页表。显然，非连续内存区大小必须是4096倍数。</p>
<p>Linux在几个方面使用非连续内存区，如：为活动的交换区分配数据结构，为模块分配空间，或者给某些I/O驱动程序分配缓冲区。此外，非连续内存区还提供了另一种使用高端内存页框的方法。</p>
<h4 id="1-非连续内存区的线性地址"><a href="#1-非连续内存区的线性地址" class="headerlink" title="1.非连续内存区的线性地址"></a>1.非连续内存区的线性地址</h4><p>要查找线性地址的一个空闲区，可从<code>PAGE_OFFSET</code>开始查找。</p>
<ol>
<li>线性内存区的开始部分包含的是对前<code>896MB RAM</code>进行映射的线性地址。直接映射的物理内存末尾所对应的线性地址保存在<code>high_memory</code></li>
<li>线性内存区的结尾部分包含的是固定映射的线性地址。</li>
<li>从<code>PKMAP_BASE</code>开始，查找用于高端内存页框的永久内核映射的线性地址</li>
<li>其余的线性地址可用于非连续内存区。</li>
</ol>
<p>在直接内存映射的末尾与第一个内存区之间插入一个大小为<code>8MB</code>的安全区，目的是为了”捕获”对内存的越界访问。<br>出于同样的理由，插入其他<code>4KB</code>大小的安全区来隔离非连续的内存区。</p>
<p>以下针对<code>32</code>位处理器：</p>
<ul>
<li>直接映射线性地址区域：<code>[PAGE_OFFSET, high_memory]</code></li>
<li><code>vmalloc</code>线性地址空间：<code>[VMALLOC_START,VMALLOC_END]</code></li>
<li>永久内核映射的线性地址空间：<code>[PKMAP_BASE,FIXADDRSTART]</code></li>
<li>固定映射的线性地址空间：<code>[FIXADDR_START,4GB]</code></li>
</ul>
<p>为非连续内存区保留的线性地址空间的起始地址由<code>VMALLOC_START</code>定义，末尾地址由<code>VMALLOC_END</code>定义。<br><img src=".\6bc065855c54476abee5dc63454efe03.png" alt="在这里插入图片描述"></p>
<h4 id="2-非连续内存区的描述符"><a href="#2-非连续内存区的描述符" class="headerlink" title="2.非连续内存区的描述符"></a>2.非连续内存区的描述符</h4><p>每个非连续内存区都对应着一个类型为<code>vm_struct</code>的描述符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void*</td>
<td>addr</td>
<td>内存区内第一个内存单元的线性地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>size</td>
<td>内存区的大小加4096</td>
</tr>
<tr>
<td>unsigned long</td>
<td>flags</td>
<td>非连续内存区映射的内存的类型</td>
</tr>
<tr>
<td>struct page**</td>
<td>pages</td>
<td>指向nr_pages数组的指针，该数组由指向页描述符的指针组成</td>
</tr>
<tr>
<td>unsigned int</td>
<td>nr_pages</td>
<td>内存区填充的页的个数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>phys_addr</td>
<td>该字段设为0，除非内存已被创建来映射一个硬件设备的I/O共享内存</td>
</tr>
<tr>
<td>struct vm_struct*</td>
<td>next</td>
<td>指向下一个vm_struct结构的指针</td>
</tr>
</tbody>
</table>
</div>
<p>通过<code>next</code>，这些描述符被插入到一个简单的链表中，链表的第一个元素的地址存放在<code>vmlist</code>变量中。对这个链表的访问依靠<code>vmlist_lock</code>读写自旋锁来保护。</p>
<ul>
<li><code>flags</code>字段标识了非连续区映射的内存的类型：</li>
<li><code>VM_ALLOC</code>表示使用<code>vmalloc</code>得到的页，</li>
<li><code>VM_MAP</code>表示使用<code>vmap</code>映射的已经被分配的页，</li>
<li><code>VM_IOREMAP</code>表示使用<code>ioremap</code>映射的硬件设备的板上内存。</li>
</ul>
<p><strong>get_vm_area–在线性地址VMALLOC_START和VMALLOC_END之间查找一个空闲区域</strong><br>参数：</p>
<ul>
<li>将被创建的内存区的字节大小，</li>
<li>指定空闲区类型的标志</li>
</ul>
<p>步骤：</p>
<ol>
<li>调<code>kmalloc</code>为<code>vm_struct</code>类型的新描述符获得一个内存区</li>
<li>为写得到<code>vmlist_lock</code>锁，并扫描类型为<code>vm_struct</code>的描述符链表来查找线性地址一个空闲区域，至少覆盖<code>size+4096</code>个地址（<code>4096</code>是内存区之间的安全区间大小）</li>
<li>如存在这样一个区间，函数就初始化描述符的字段，释放<code>vmlist_lock</code>，并以返回非连续内存区描述符的起始地址而结束</li>
<li>否则，<code>get_vm_area</code>释放先前得到的描述符，释放<code>vmlist_lock</code>，返回<code>NULL</code></li>
</ol>
<h4 id="3-分配非连续内存区"><a href="#3-分配非连续内存区" class="headerlink" title="3.分配非连续内存区"></a>3.分配非连续内存区</h4><p><strong>vmalloc–给内核分配一个非连续内存区</strong></p>
<p>参数：</p>
<ul>
<li>size–表示所请求内存区的大小</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">vmalloc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> size<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">vm_struct</span> <span class="token operator">*</span>area<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span><span class="token operator">*</span>pages<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> array_size<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
	size <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">+</span> PAGE_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> PAGE_MASK<span class="token punctuation">;</span>
	area <span class="token operator">=</span> <span class="token function">get_vm_area</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> VM_ALLOC<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>area<span class="token punctuation">)</span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	area<span class="token operator">-></span>nr_pages <span class="token operator">=</span> size <span class="token operator">>></span> PAGE_SHIFT<span class="token punctuation">;</span>
	array_size <span class="token operator">=</span> <span class="token punctuation">(</span>area<span class="token operator">-></span>nr_pages <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">page</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	area<span class="token operator">-></span>pages <span class="token operator">=</span> pages <span class="token operator">=</span> <span class="token function">kmalloc</span><span class="token punctuation">(</span>array_size<span class="token punctuation">,</span> GFP_KERNEL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>area<span class="token operator">-></span>pages<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">remove_vm_area</span><span class="token punctuation">(</span>area<span class="token operator">-></span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">kfree</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>area<span class="token operator">-></span>pages<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> array_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> area<span class="token operator">-></span>nr_pages<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		area<span class="token operator">-></span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">alloc_page</span><span class="token punctuation">(</span>GFP_KERNEL <span class="token operator">|</span> __GFP_HIGHMEM<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>area<span class="token operator">-></span>pages<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token punctuation">&#123;</span>
			area<span class="token operator">-></span>nr_pages <span class="token operator">=</span> i<span class="token punctuation">;</span>
		fail<span class="token operator">:</span>
			<span class="token function">vfree</span><span class="token punctuation">(</span>area<span class="token operator">-></span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 通过页表表项逐个处理构建连续线性地址和离散物理地址之间的映射</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">map_vm_area</span><span class="token punctuation">(</span>area<span class="token punctuation">,</span> <span class="token function">__pgprot</span><span class="token punctuation">(</span><span class="token number">0x63</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pages<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">goto</span> fail<span class="token punctuation">;</span>
	<span class="token keyword">return</span> area<span class="token operator">-></span>addr<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>函数首先将<code>size</code>设为<code>4096</code>的整数倍，然后，<code>vmalloc</code>调<code>get_vm_area</code>来创建一个新的描述符，并返回分配给这个内存区的线性地址。描述符的<code>flags</code>字段被初始化为<code>VM_ALLOC</code>标志，该标志意味着通过使用<code>vmalloc</code>函数，非连续的物理页框将被映射到一个线性地址空间。</li>
<li>然后，<code>vmalloc</code>调<code>kmalloc</code>来请求一组连续页框，这组页框足够包含一个页描述符指针数组。调<code>memset</code>将所有这些指针设为<code>NULL</code>。接着重复调<code>alloc_page</code>，每一次为区间中<code>nr_pages</code>个页的每一个分配一个页框，并把对应页描述符的地址存放在<code>area-&gt;pages</code>中。</li>
<li>到这里，已经得到一个新的连续线性地址空间，且已分配了一组非连续页框来映射这些线性地址。<br>最后重要的步骤是修改内核使用的页表项，以此表明分配给非连续内存区的每个页框现在对应着一个线性地址，这个线性地址被包含在<code>vmalloc</code>产生的连续线性地址空间中。</li>
</ul>
<p><strong>map_vm_area</strong><br>参数：</p>
<ul>
<li><code>area</code>–指向内存区的<code>vm_struct</code>描述符的指针</li>
<li><code>prot</code>–已分配页框的保护位。它总是被置为<code>0x63</code>，对应着<code>Present，Accessed，Read/Write，Dirty</code></li>
<li><code>pages</code>–指向一个指针数组的变量的地址，该指针数组的指针指向页描述符</li>
</ul>
<p>过程：</p>
<ul>
<li>函数首先把内存区的开始和末尾的线性地址分别分配给局部变量<code>address</code>和<code>end</code>：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">address &#x3D; area-&gt;addr;
end &#x3D; address + (area-&gt;size - PAGE_SIZE);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>记住，<code>area-&gt;size</code>存放的是内存区的实际地址加上<code>4KB</code>的安全区间。<br>函数使用<code>pgd_offset_k</code>宏来得到在主内核页全局目录中的目录项，该项对应于内存区起始线性地址，然后获得内核页表自旋锁：</p>
<pre class="line-numbers language-none"><code class="language-none">pgd &#x3D; pgd_offset_k(address);
spin_lock(&amp;init_mm.page_table_lock);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>然后，函数执行下列循环</p>
<pre class="line-numbers language-none"><code class="language-none">int ret &#x3D; 0;
for(i &#x3D; pgd_index(address); i &lt; pgd_index(end-1); i++)
&#123;
	pud_t* pud &#x3D; pud_alloc(&amp;init_mm, pgd, address);
	ret &#x3D; -ENOMEM;
	if(!pud)
		break;
	next &#x3D; (address + PGDIR_SIZE) &amp; PGDIR_MASK;
	if(next &lt; address || next &gt; end)
		next &#x3D; end;
	if(map_area_pud(pud, address, next, prot, pages))
		break;
	address &#x3D; next;
	pgd++;
	ret  &#x3D; 0;
&#125;

spin_unlock(&amp;init_mm.page_table_lock);
flush_cache_vmap((unsigned long)area-&gt;addr, end);
return ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>每次循环都首先调<code>pub_alloc</code>来为新内存区创建一个页上级目录，并把它的物理地址写入内核页全局目录的合适表项。<br>调<code>alloc_area_pud</code>为新的页上级目录分配所有相关的页表。接下来，把常量<code>2</code>的<code>30</code>幂次（在PAE被激活的情况下，否则为<code>2</code>的<code>22</code>幂次）与<code>address</code>的当前值相加（<code>2</code>的<code>30</code>幂次就是一个页上级目录所跨越的线性地址范围的大小）。<br>最后增加指向页全局目录的指针<code>pgd</code>。<br>循环结束的条件是：指向非连续内存区的所有页表项全被建立。</p>
</li>
<li><p><code>map_area_pud</code>为页上级目录所指向的所有页表执行一个类似的循环：</p>
<pre class="line-numbers language-none"><code class="language-none">do&#123;
	pmd_t* pmd &#x3D; pmd_alloc(&amp;init_mm, pud, address);
	if(!pmd)
		return -ENOMEM;
	if(map_area_pmd(pmd, address, end-address, prot, pages))
		return -ENOMEM;
	address &#x3D; (address + PUD_SIZE) &amp; PUD_MASK;
	pud++;
&#125; while(address &lt; end);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>map_area_pmd</code>为页中间目录所指向的所有页表执行一个类似的循环</p>
<pre class="line-numbers language-none"><code class="language-none">do&#123;
	pre_t* pte &#x3D; pte_alloc_kernel(&amp;init_mm, pmd, address);
	if(!pte)
		return -ENOMEM;
	if(map_area_pte(pte, address, end-address, prot, pages))
		return -ENOMEM;
	address &#x3D; (address + PMD_SIZE) &amp; PMD_MASK;
	pmd++;
&#125; while(address &lt; end);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>pte_alloc_kernel</code>分配一个新的页表，并更新页中间目录中相应的目录项。<br>接下来，<code>map_area_pte</code>为页表中相应的表项分配所有的页框。<br><code>address</code>值增加$2^{22}$（$2^{22}$就是一个页表所跨越的线性地址区间的大小），且循环反复执行<code>map_area_pte</code>主循环为：</p>
<pre class="line-numbers language-none"><code class="language-none">do&#123;
	struct page* page &#x3D; **pages;
	set_pte(pte, mk_pte(page, prot));
	address +&#x3D; PAGE_SIZE;
	pte++;
	(*pages)++;
&#125; while(address &lt; end);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>将被映射的页框的页描述符地址<code>page</code>从地址<code>pages</code>处的变量指向的数组项读得的。<br>通过<code>set_pte</code>和<code>mk_pte</code>宏，把新页框的物理地址写进页表。把常量<code>4096</code>（即一个页框的长度）加到<code>address</code>上之后，循环又重复执行。</p>
</li>
</ul>
<p>​    注意，<code>map_vm_area</code>并不触及当前进程的页表。故，当内核态的进程访问非连续内存区时，缺页发生。<br>因为该线性内存区所对应的进程页表的表项为空。然而，缺页处理程序要检查这个缺页线性地址是否在主内核页表中（即<code>init_mm.pgd</code>页全局目录和它的子页表）一旦处理程序发现一个主内核页表含有这个线性地址的非空项，就把它的值拷贝到相应的进程页表项中，并恢复进程的正常执行。</p>
<p>​    除了<code>vmalloc</code>外，非连续内存区还能由<code>vmalloc_32</code>分配，该函数与<code>vmalloc</code>相似，但它只从<code>ZONE_NORMAL</code>和<code>ZONE_DMA</code>管理区分配页框。</p>
<h4 id="4-释放非连续内存区"><a href="#4-释放非连续内存区" class="headerlink" title="4.释放非连续内存区"></a>4.释放非连续内存区</h4><p><strong>vfree–释放vmalloc和vmalloc_32创建的非连续内存区</strong></p>
<p><strong>vunmap–释放vmap创建的内存区</strong></p>
<p>两个函数都使用同一个参数,它们都依赖于<code>__vunmap</code>来作实质性的工作。：</p>
<ul>
<li>将要释放的内存区的起始线性地址address，</li>
</ul>
<p><strong>__vunmap</strong><br>参数：</p>
<p>将要释放的内存区的起始地址的地址addr，</p>
<p>标志deallocate_pages，如被映射到内存区的页框应当被释放到分区页框分配器，则这个标志被置位，否则被清除。</p>
<p>过程：</p>
<ol>
<li>调<code>remove_vm_area</code>得到<code>vm_struct</code>描述符的地址<code>area</code>，清除非连续内存区中的线性地址对应的内核的页表项</li>
<li>如<code>deallocate_pages</code>被置位，函数扫描指向页描述符的<code>area-&gt;pages</code>指针数组；<br>对数组的每一个元素，调<code>__free_page</code>释放页框到分区页框分配器。执行<code>kfree(area-&gt;pages)</code>来释放数组自身。</li>
<li>调<code>kfree(area)</code>来释放<code>vm_struct</code></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">write_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vmlist_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>vmlist<span class="token punctuation">;</span> <span class="token punctuation">(</span>tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>tmp<span class="token operator">-></span>next<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span>tmp<span class="token operator">-></span>addr <span class="token operator">==</span> addr<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
		<span class="token function">unmap_vm_area</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">*</span>p <span class="token operator">=</span> tmp<span class="token operator">-></span>next<span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">write_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vmlist_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> tmp<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内存区本身通过调<code>unmap_vm_area</code>来释放。</p>
<p><strong>unmap_vm_area</strong></p>
<p>参数：</p>
<ul>
<li>指向内存区的vm_struct描述符的指针area。</li>
</ul>
<p>过程：</p>
<pre class="line-numbers language-none"><code class="language-none">address &#x3D; area-&gt;addr;
end &#x3D; address + area-&gt;size;
pgd &#x3D; pgd_offset_k(address);
for(i &#x3D; pgd_index(address); i &lt;&#x3D; pgd_index(end-1); i++)
&#123;
	next &#x3D; (address + PGDIR_SIZE) &amp; PGDIR_MASK;
	if(next &lt;&#x3D; address || next &gt; end)
		next &#x3D; end;
	unmap_area_pud(pgd, address, next - address);
	address &#x3D; next;
	pgd++;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>unmap_area_pud</code>依次在循环中执行<code>map_area_pud</code>的反操作：</p>
<pre class="line-numbers language-none"><code class="language-none">do &#123;
	unmap_area_pmd(pud, address, end - address);
	address &#x3D; (address + PUD_SIZE) &amp; PUD_MASK;
	pud++;
&#125; while(address &amp;&amp; (address &lt; end));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>unmap_area_pmd</code>函数在循环体中执行<code>map_area_pmd</code>的反操作</p>
<pre class="line-numbers language-none"><code class="language-none">do &#123;
	unmap_area_pte(pmd, address, end - address);
	address &#x3D; (address + PMD_SIZE) &amp; PMD_MASK;
	pmd++;
&#125; while(address &lt; end);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，<code>unmap_area_pte</code>在循环中执行<code>map_area_ate</code>的反操作</p>
<pre class="line-numbers language-none"><code class="language-none">do &#123;
	pte_t page &#x3D; ptep_get_and_clear(pte);
	address +&#x3D; PAGE_SIZE;
	pte++;
	if(!pte_none(page) &amp;&amp; !pte_present(page))
		printk(&quot;Whee ... Swapped out page in kernel page table\n&quot;);
&#125; while(address &lt; end);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    在每次循环过程中，<code>ptep_get_and_clear</code>将<code>pte</code>指向的页表项设为<code>0</code>。与<code>vmalloc</code>一样，内核修改主内核页全局目录和它的子页表中的相应项，但映射第4个GB的进程页表的项保持不变。因为内核永远不会回收扎根于主内核页全局目录中的页上级目录，页中间目录，页表。如，假定内核态的进程访问一个随后要释放的非连续内存区。进程的页全局目录项等于主内核页全局目录中的相应项。这些目录项指向相同的页上级目录，页中间目录，页表。</p>
<p><code>unmap_area_pte</code>只清除页表中的项（不回收页表本身）。进程对已释放非连续内存区的进一步访问必将由于空的页表项而触发缺页异常。缺页异常处理程序会认为这样的访问是一个错误，因为主内核页表不包含有效的表项。</p>
<h1 id="进程地址空间-1"><a href="#进程地址空间-1" class="headerlink" title="进程地址空间"></a>进程地址空间</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我们在之前更加底层的层面看到了：内核中通过这些函数获得<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=动态内存&amp;spm=1001.2101.3001.7020">动态内存</a>：<br><code>__get_free_pages</code>，<code>alloc_pages</code>，<code>kmem_cache_alloc</code>，<code>kmalloc</code>，<code>vmalloc</code>，<code>vmalloc_32</code>。</p>
<p>使用上述简单方法基于以下两个原因：</p>
<ul>
<li>内核是操作系统中优先级最高的成分。如某个内核函数请求动态内存，则必定有正当的理由发出请求，因此，没道理试图推迟这个请求。</li>
<li>内核信任自己。所有的内核函数都假定没错误，故内核函数不必插入针对编程错误的任何保护措施。</li>
</ul>
<p>给用户态进程分配内存时，情况完全不同：</p>
<ul>
<li>进程对动态内存的请求被认为是不紧迫的。如进程的可执行文件被装入时，进程不一定立即对所有的代码页进行访问。如进程调<code>malloc</code>获得请求的动态内存时，不意味着进程很快会访问所有所获得的内存。故一般来说，内核总是尽量推迟给用户态进程分配动态内存。</li>
<li>由于用户进程是不可信任的，故内核必须能随时准备捕获用户态进程引起的所有寻址错误。</li>
</ul>
<p>​    当用户态进程请求动态内存时，并没有获得请求的页框，<strong>而仅仅获得对一个新的线性地址区间的使用权，而这一线性地址区间就成为进程地址空间的一部分。这一区间叫”线性区”。</strong></p>
<h2 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h2><p>​    进程的地址空间由<strong>允许进程使用的全部线性地址组成</strong>。每个进程所看到的线性地址集合是不同的，<strong>一个进程所使用的地址与另外一个进程所使用的地址之间没什么关系。内核可通过增加或删除某些线性地址区间来动态地修改进程的地址空间</strong>。</p>
<p>​    内核通过所谓线性区的资源来表示线性地址区间，线性区是由起始线性地址，长度和一些访问权限来描述的。<br>为效率起见，起始地址和线性区的长度必须是<code>4096</code>的倍数，以便每个线性区所识别的数据完全填满分配给它的页框。<br>下面是进程获得新线性区的一些典型情况：</p>
<ul>
<li>当用户在控制台输入一条命令时，<code>shell</code>进程创建一个新的进程去执行这个命令。结果是，一个全新的地址空间（一组线性区）分配给了新进程。</li>
<li>正在运行的进程有可能决定装入一个完全不同的程序。这种情况下，进程标识符仍保持不变，可是在装入这个程序以前所使用的线性区却被释放，并有一组新的线性区被分配给这个进程</li>
<li>正在运行的进程可能对一个文件（或它的一部分）执行”内存映射”。这种情况下，内核给这个进程分配一个新的线性区来映射这个文件。</li>
<li>进程可能持续向它的用户态堆栈增加数据，直到映射这个堆栈的线性区用完。这种情况下，内核也许会决定扩展这个线性区的大小。</li>
<li>进程可能创建一个IPC共享线性区来与其他合作进程共享数据。此情况下，内核给这个进程分配一个新的线性区以实现这个方案</li>
<li>进程可能通过调类似<code>malloc</code>这样的函数扩展自己的动态区。结果是，内核可能决定扩展给这个堆所分配的线性区。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统调用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>brk</td>
<td>改变进程堆的大小</td>
</tr>
<tr>
<td>execve</td>
<td>装入一个新的可执行文件，从而改变进程的地址空间</td>
</tr>
<tr>
<td>_exit</td>
<td>结束当前进程并撤销它的地址空间</td>
</tr>
<tr>
<td>fork</td>
<td>创建一个新进程，并为它创建新的地址空间</td>
</tr>
<tr>
<td>map,map2</td>
<td>为文件创建一个内存映射，从而扩大进程的地址空间</td>
</tr>
<tr>
<td>mremap</td>
<td>扩大或缩小线性区</td>
</tr>
<tr>
<td>remap_file_pages</td>
<td>为文件创建非线性映射</td>
</tr>
<tr>
<td>munmap</td>
<td>撤销对文件的内存映射，从而缩小进程的地址空间</td>
</tr>
<tr>
<td>shmat</td>
<td>创建一个共享线性区</td>
</tr>
<tr>
<td>shmdt</td>
<td>撤销一个共享线性区</td>
</tr>
</tbody>
</table>
</div>
<p>确定一个进程当前所拥有的线性区（即进程的地址空间）是内核的基本任务，因为这可以让缺页异常处理程序有效地区分引发这个异常处理程序的两种不同类型的无效线性地址：</p>
<ul>
<li>由编程错误引发的无效线性地址</li>
<li>由缺页引发的无效线性地址；</li>
</ul>
<p>即使这个线性地址属于进程的地址空间，但对应于这个地址的页框仍有待分配。<strong>从进程观点看，后一种地址不是无效的。内核要利用这种缺页以实现请求调页：内核通过提供页框来处理这种缺页，并让进程继续运行</strong>。（也就是说我们需要区分这两种情况才是！）</p>
<h3 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h3><p>​    与进程地址空间有关的全部信息都包含在一个叫内存描述符的数据结构中，这个结构的类型为<code>mm_struct</code>，进程描述符的<code>mm</code>字段就指向这个结构。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类似</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct vm_area_struct*</td>
<td>mmap</td>
<td>指向线性区对象的链表头</td>
</tr>
<tr>
<td>struct rb_root</td>
<td>mm_rb</td>
<td>指向线性区对象的红黑树的根</td>
</tr>
<tr>
<td>struct vm_area_struct*</td>
<td>mmap_cache</td>
<td>指向最后一个引用的线性区对象</td>
</tr>
<tr>
<td>unsigned long(*)()</td>
<td>get_unmapped_area</td>
<td>在进程地址空间中搜索有效线性地址区间的方法</td>
</tr>
<tr>
<td>void (*)()</td>
<td>unmap_area</td>
<td>释放线性地址区间时调用的方法</td>
</tr>
<tr>
<td>unsigned long</td>
<td>mmap_base</td>
<td>标识第一个分配的匿名线性区或文件内存映射的线性地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>free_area_cache</td>
<td>内核从这个地址开始搜索进程地址空间中线性地址的空闲区间</td>
</tr>
<tr>
<td>pdt_t*</td>
<td>pgd</td>
<td>指向页全局目录</td>
</tr>
<tr>
<td>atomic_t</td>
<td>mm_users</td>
<td>次使用计数器</td>
</tr>
<tr>
<td>atomic_t</td>
<td>mm_count</td>
<td>主使用计数器</td>
</tr>
<tr>
<td>int</td>
<td>map_count</td>
<td>线性区的个数</td>
</tr>
<tr>
<td>struct rw_semaphore</td>
<td>mmap_sem</td>
<td>线性区的读/写信号量</td>
</tr>
<tr>
<td>spinlock_t</td>
<td>page_table_lock</td>
<td>线性区的自旋锁和页表的自旋锁</td>
</tr>
<tr>
<td>struct list_head</td>
<td>mmlist</td>
<td>指向内存描述符链表中的相邻元素</td>
</tr>
<tr>
<td>unsigned long</td>
<td>start_code</td>
<td>可执行代码的起始地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>end_data</td>
<td>可执行代码的最后地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>start_brk</td>
<td>堆的起始地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>brk</td>
<td>堆的当前最后地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>start_stack</td>
<td>用户态堆栈的起始地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>arg_start</td>
<td>命令行参数的起始地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>arg_end</td>
<td>命令行参数的最后地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>env_start</td>
<td>环境变量的起始地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>env_end</td>
<td>环境变量的最后地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>rss</td>
<td>分配给进程的页框数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>anon_rss</td>
<td>分配给匿名内存映射的页框数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>total_vm</td>
<td>进程地址空间的大小</td>
</tr>
<tr>
<td>unsigned long</td>
<td>locked_vm</td>
<td>“锁住”而不能换出的页的个数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>shared_vm</td>
<td>共享文件内存映射中的页数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>exec_vm</td>
<td>可执行内存映射中的页数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>stack_vm</td>
<td>用户态堆栈中的页数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>reserved_vm</td>
<td>在保留区中的页数或在特殊线性区中的页数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>def_flags</td>
<td>线性区默认的访问标志</td>
</tr>
<tr>
<td>unsigned long</td>
<td>nr_ptes</td>
<td>进程的页表数</td>
</tr>
<tr>
<td>unsigned long[]</td>
<td>saved_auxv</td>
<td>开始执行ELF程序时使用</td>
</tr>
<tr>
<td>unsigned int</td>
<td>dumpable</td>
<td>表示是否可产生内存信息转储的标志</td>
</tr>
<tr>
<td>cpumask_t</td>
<td>cpu_vm_mask</td>
<td>用于懒惰TLB交换的位掩码</td>
</tr>
<tr>
<td>mm_context_t</td>
<td>context</td>
<td>指向有关特定体系结构信息的表（如x86上的LDT地址）</td>
</tr>
<tr>
<td>unsigned long</td>
<td>swap_token_time</td>
<td>进程在这个时间将有资格获得交换标记</td>
</tr>
<tr>
<td>char</td>
<td>recent_pagein</td>
<td>如最近发生了主缺页，设置该标志</td>
</tr>
<tr>
<td>int</td>
<td>core_waiters</td>
<td>正在把进程地址空间的内存转储到core文件中的轻量级进程的数量</td>
</tr>
<tr>
<td>struct completion*</td>
<td>core_startup_done</td>
<td>指向创建内存转储文件时的补充原语</td>
</tr>
<tr>
<td>struct completion</td>
<td>core_done</td>
<td>创建内存转储文件时使用的补充原语</td>
</tr>
<tr>
<td>rwlock_t</td>
<td>ioctx_list_lock</td>
<td>用于保护异步I/O上下文链表的锁</td>
</tr>
<tr>
<td>struct kioctx*</td>
<td>ioctx_list</td>
<td>异步I/O上下文链表</td>
</tr>
<tr>
<td>struct kioctx</td>
<td>default_kioctx</td>
<td>默认的异步I/O上下文</td>
</tr>
<tr>
<td>unsigned long</td>
<td>hiwater_rss</td>
<td>进程所拥有的最大页框数</td>
</tr>
<tr>
<td>unsigned long</td>
<td>hiwater_vm</td>
<td>进程线性区中的最大页数</td>
</tr>
</tbody>
</table>
</div>
<p>​    所有的内存描述符存放在一个双向链表中，每个描述符在<code>mmlist</code>字段存放链表相邻元素的地址。链表的第一个元素是<code>init_mm</code>的<code>mmlist</code>，<code>init_mm</code>是初始化阶段进程<code>0</code>所使用的内存描述符。<code>mmlist_lock</code>保护多处理器系统对链表的同时访问。</p>
<p>​    <code>mm_users</code>字段存放共享<code>mm_struct</code>数据结构的轻量级进程的个数，叫做次使用计数器。<code>mm_count</code>字段是内存描述符的主使用计数器，在<code>mm_users</code>次使用计数器中的所有用户在<code>mm_count</code>中只作为一个单位。每当<code>mm_count</code>递减时，内核要检查它是否变为<code>0</code>，如是就解除这个内存描述符。</p>
<p>​    考虑一个内存描述符由两个轻量级进程共享。它的<code>mm_users</code>字段通常是<code>2</code>，而<code>mm_count</code>字段通常是<code>1</code>。如把内存描述符暂时借给一个内核线程，则，内核就增加<code>mm_count</code>。这样，即使两个轻量级进程都死亡，且<code>mm_users</code>变为<code>0</code>，则个内存描述符也不被释放，直到内核线程使用完。因为<code>mm_count</code>仍大于<code>0</code>。</p>
<p>​    如内核想确保内存描述符在一个长操作的中间不被释放，则应增加<code>mm_users</code>，而非<code>mm_count</code>字段的值。最终的结果是相同的，因为<code>mm_users</code>的增加确保了<code>mm_count</code>不变为<code>0</code>，即使拥有这个内存描述符的所有轻量级进程全部死亡。</p>
<p>​    <code>mm_alloc</code>用来获得一个新的内存描述符。由于这些描述符被保存在<code>slab</code>分配器高速缓存中。故<code>mm_alloc</code>调<code>kmem_cache_alloc</code>来初始化新的内存描述符，并把<code>mm_count</code>和<code>mm_users</code>字段都置为<code>1</code>。</p>
<p>​    <code>mmput</code>递减内存描述符的<code>mm_users</code>字段。如该字段变为<code>0</code>，这个函数就释放局部描述符表，线性区描述符，由内存描述符所引用的页表，并调<code>mmdrop</code>。后者把<code>mm_count</code>减<code>1</code>，如该字段变为<code>0</code>，就释放<code>mm_struct</code>。</p>
<h4 id="内核线程的内存描述符"><a href="#内核线程的内存描述符" class="headerlink" title="内核线程的内存描述符"></a>内核线程的内存描述符</h4><p><strong>内核线程仅仅运行在内核态，它们永不会访问低于<code>TASK_SIZE</code>的线性地址。大于<code>TASK_SIZE</code>线性地址的相应页表项都应该总是相同的</strong>，因此，一个内核线程到底用什么样的页表集根本没关系。为避免无用的<code>TLB</code>和高速缓存刷新，内核线程使用一组最近运行的普通进程的页表。结果，在每个进程描述符中包含<code>mm</code>和<code>active_mm</code>。</p>
<p>进程描述符中的<code>mm</code>指向进程所拥有的内存描述符，<code>active_mm</code>指向进程运行时所使用的内存描述符。</p>
<p>对普通进程，两者值相同。对内核线程，<code>mm</code>总是<code>NULL</code>。<code>active_mm</code>为前一运行线程的<code>active_mm</code>。只要处于内核态的一个进程为”高端”线性地址（高于<code>TASK_SIZE</code>）修改了页表项，那么它就也应当更新系统中所有进程页表集合中的相应表项。一旦内核态的一个进程进行了设置，则映射应对内核态的所有其他进程都有效。触及所有进程的页表集合是相当费时的操作，因此，<code>Linux</code>才有一种延迟方式。每当一个高端地址被重新映射时（一般通过<code>vmalloc，vfree</code>），内核就更新被定位在<code>swapper_pg_dir</code>主内核页全局目录中的常规页表集合。这个页全局目录由主内存描述符的<code>pgd</code>字段指向，而主内存描述符存放于<code>init_mm</code>变量。</p>
<h3 id="线性区"><a href="#线性区" class="headerlink" title="线性区"></a>线性区</h3><p><code>Linux</code>通过类型为<code>vm_area_struct</code>的对象实现线性区</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct mm_struct*</td>
<td>vm_mm</td>
<td>指向线性区所在的内存描述符</td>
</tr>
<tr>
<td>unsigned long</td>
<td>vm_start</td>
<td>线性区内的第一个线性地址</td>
</tr>
<tr>
<td>unsigned long</td>
<td>vm_end</td>
<td>线性区之后的第一个线性地址</td>
</tr>
<tr>
<td>struct vm_area_struct*</td>
<td>vm_next</td>
<td>进程拥有的线性区链表中的下一个线性区</td>
</tr>
<tr>
<td>pgprot_t</td>
<td>vm_page_prot</td>
<td>线性区中页框的访问许可权</td>
</tr>
<tr>
<td>unsigned long</td>
<td>vm_flags</td>
<td>线性区的标志</td>
</tr>
<tr>
<td>struct rb_node</td>
<td>vm_rb</td>
<td>用于红-黑树的数据</td>
</tr>
<tr>
<td>union</td>
<td>shared</td>
<td>链接到反映射所使用的数据结构</td>
</tr>
<tr>
<td>struct list_head</td>
<td>anon_vma_node</td>
<td>指向匿名线性区链表的指针</td>
</tr>
<tr>
<td>struct anon_vma*</td>
<td>anon_vma</td>
<td>指向anon_vma数据结构的指针</td>
</tr>
<tr>
<td>struct vm_operations_struct*</td>
<td>vm_ops</td>
<td>指向线性区的方法</td>
</tr>
<tr>
<td>unsigned long</td>
<td>vm_pgoff</td>
<td>在映射文件中的偏移量。对匿名页，它等于0或vm_start/PAGE_SIZE</td>
</tr>
<tr>
<td>struct file*</td>
<td>vm_file</td>
<td>指向映射文件的文件对象</td>
</tr>
<tr>
<td>void*</td>
<td>vm_private_data</td>
<td>指向内存区的私有数据</td>
</tr>
<tr>
<td>unsigned long</td>
<td>vm_truncate_count</td>
<td>释放非线性文件内存映射中的一个线性地址区间时使用</td>
</tr>
</tbody>
</table>
</div>
<p>​    每个线性区描述符表示一个线性地址区间。<code>vm_start</code>字段包含区间的第一个线性地址，<code>vm_end</code>字段包含区间之外的第一个线性地址。<code>vm_end - vm_start</code>表示线性区的长度。<code>vm_mm</code>字段指向拥有这个区间的进程的<code>mm_struct</code>。</p>
<p>​    进程所拥有的线性区从不重叠，且内核尽力把新分配的线性区与紧邻的现有线性区合并。如两个相邻区的访问权限匹配，就能合并在一起。<code>vm_ops</code>字段指向<code>vm_operations_struct</code>数据结构，该结构中存放的是线性区的方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>当把线性区增加到进程所拥有的线性区集合时调用</td>
</tr>
<tr>
<td>close</td>
<td>当从进程所拥有的线性区集合删除线性区时调用</td>
</tr>
<tr>
<td>nopage</td>
<td>当进程试图访问RAM中不存在的一个页，但该页的线性地址属于线性区时，由缺页异常处理程序调用</td>
</tr>
<tr>
<td>populate</td>
<td>设置线性区的线性地址（预缺页）所对应的页表项时调用。主要用于非线性文件内存映射</td>
</tr>
</tbody>
</table>
</div>
<h4 id="线性区数据结构"><a href="#线性区数据结构" class="headerlink" title="线性区数据结构"></a>线性区数据结构</h4><p>进程所拥有的所有线性区是通过一个简单链表链接在一起。链表中的线性区是按内存地址升序排列的；每两个线性区可由未用的内存地址隔开。每个<code>vm_area_struct</code>元素的<code>vm_next</code>字段指向链表的下一个元素。</p>
<p>内核通过进程的内存描述符的<code>mmap</code>字段来查找线性区，其中<code>mmap</code>字段指向链表中的第一个线性区描述符。内存描述符的<code>map_count</code>字段存放进程所拥有的线性区数目。默认下，一个进程可最多拥有<code>65536</code>个不同的线性区，系统管理员可通过写<code>/proc/sys/vm/max_map_count</code>文件来修改这个限定值。</p>
<p>内核频繁执行的一个操作就是查找包含指定线性地址的线性区。由于，链表是经过排序的。故只要在指定线性地址之后找到一个线性区，搜索就可结束。仅当进程线性区非常少时，使用这种链表才是方便的。比如说，只有一二十个线性区。在链表中查找元素，插入元素，删除元素涉及许多操作，这些操作所花费的时间与链表的长度成线性比例。</p>
<p>尽管多数的<code>Linux</code>进程使用的线性区非常少，但诸如面向对象的数据库，或<code>malloc</code>的专用调试器那样过于庞大的大型应用程序可能由成百上千的线性区。此情况下，线性区链表的管理变得非常低效。与内存相关的系统调用的性能就降低到令人无法忍受的地步。故<code>Linux 2.6</code>把内存描述符存放在叫红-黑树的数据结构中。</p>
<h4 id="红黑树小论"><a href="#红黑树小论" class="headerlink" title="红黑树小论"></a>红黑树小论</h4><p>在红-黑树中，每个元素（或节点）通常有两个孩子：左孩子，右孩子。树中的元素被排序，对每个节点<code>N</code>，<code>N</code>的左子树上的所有元素都排在<code>N</code>之前。相反，<code>N</code>的右子树上的所有元素都排在<code>N</code>之后；节点的关键字被写入节点内部。此外，红-黑树必须满足下列规则：</p>
<ul>
<li>每个节点必须或为黑或为红</li>
<li>树的根必须为黑</li>
<li>红节点的孩子必须为黑</li>
<li>从一个节点到后代叶子节点的每个路径都包含相同数量的黑节点。</li>
</ul>
<p>​    统计黑节点个数时，空指针也算作黑节点。这<code>4</code>条规则确保有<code>n</code>个内部节点的任何红-黑树其高度最多为<code>2*log(n+1)</code>。</p>
<p>​    在红-黑树中搜索一个元素因此变得非常高效，因为其操作的执行时间与树大小的对数成线性比例。即，双倍的线性区个数只多增加一次循环。在红-黑树中插入和删除一个元素也是高效的，算法可很快便利树以确定插入元素的位置或删除元素的位置。任何新节点必须作为一个叶子插入并着成红色。如操作违背了上述规则，就需移动或重新着色。</p>
<p>​    <strong>为了存放进程的线性区，<code>Linux</code>既使用了链表，也使用了红-黑树。这两种数据结构包含指向同一线性区描述符的指针，插入或删除一个线性区描述符时，内核通过红-黑树搜索前后元素，用搜索结果快速更新链表而不用扫描链表。</strong></p>
<p>​    链表的头由内存描述符的<code>mmap</code>字段所指向。任何线性区对象都在<code>vm_next</code>字段存放指向链表下一元素的指针。红-黑树首部由内存描述符的<code>mm_rb</code>字段所指向。任何线性区对象都在类型为<code>rb_node</code>的<code>vm_rb</code>字段中。存放节点颜色及指向双亲，左孩子，右孩子的指针。<strong>一般，红-黑树用来确定含有指定地址的线性区，链表通常在扫描整个线性区集合时来使用。红黑树可以和链表同时服务于存储一类元素的容器。插入，删除时，先在红黑树搜索前后元素。前后元素已知下链表插入，删除复杂度为<code>O(1)</code>。整体遍历元素时，链表比红黑树更有优势。</strong></p>
<h3 id="线性区访问权限"><a href="#线性区访问权限" class="headerlink" title="线性区访问权限"></a>线性区访问权限</h3><p>​    用页这个术语既表示一组线性地址，又表示这组地址中所存放的数据。我们把介于<code>0~4095</code>之间的线性地址区间称为第<code>0</code>页，介于<code>4096~8191</code>之间的线性地址区间称为第<code>1</code>页，以此类推。因此，每个线性区都由一组号码连续的页构成。注意，用页表示线性区域的刻度，用页框表示物理内存区域的刻度。</p>
<p>几类访问标志：</p>
<ol>
<li>每个页表项中存放的标志，如：<code>Read/Write</code>，<code>Present</code>或<code>User/Supervisor</code>。<br>由<code>80x86</code>硬件用来检查能否执行所请求的寻址类型；</li>
<li>页框描述符<code>flags</code>字段中的一组标志由<code>Linux</code>用于许多不同的目的。</li>
<li><code>vm_area_struct</code>描述符的<code>vm_flags</code>用于为线性区内的页提供标志信息。<br>一些标志给内核提供有关这个线性区全部页的信息，如它们含什么内容，进程访问每个页的权限。<br>另外的标志描述线性区自身，如它应如何增长。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志名</th>
<th>收纳</th>
</tr>
</thead>
<tbody>
<tr>
<td>VM_READ</td>
<td>页是可读的</td>
</tr>
<tr>
<td>VM_WRITE</td>
<td>页是可写的</td>
</tr>
<tr>
<td>VM_EXEC</td>
<td>页是可执行的</td>
</tr>
<tr>
<td>VM_SHARED</td>
<td>页可由几个进程共享</td>
</tr>
<tr>
<td>VM_MAYREAD</td>
<td>可设置VM_READ标志</td>
</tr>
<tr>
<td>VM_MAYWRITE</td>
<td>可设置VM_WRITE标志</td>
</tr>
<tr>
<td>VM_MAYEXEC</td>
<td>可设置VM_EXEC标志</td>
</tr>
<tr>
<td>VM_MAYSHARE</td>
<td>可设置VM_SHARE标志</td>
</tr>
<tr>
<td>VM_GROWSDOWN</td>
<td>线性区可向低地址扩展</td>
</tr>
<tr>
<td>VM_GROWSUP</td>
<td>线性区可向高地址扩展</td>
</tr>
<tr>
<td>VM_SHM</td>
<td>线性区用于IPC的共享内存</td>
</tr>
<tr>
<td>VM_DENYWRITE</td>
<td>线性区映射一个不能打开用于写的文件</td>
</tr>
<tr>
<td>VM_EXECUTABLE</td>
<td>线性区映射一个可执行文件</td>
</tr>
<tr>
<td>VM_LOCKED</td>
<td>线性区中的页被锁住，且不能换出</td>
</tr>
<tr>
<td>VM_IO</td>
<td>线性区映射设备的I/O地址空间</td>
</tr>
<tr>
<td>VM_SEQ_READ</td>
<td>应用程序顺序地访问页</td>
</tr>
<tr>
<td>VM_RAND_READ</td>
<td>应用程序以真正的随机顺序访问页</td>
</tr>
<tr>
<td>VM_DONTCOPY</td>
<td>当创建一个新进程时不拷贝线性区</td>
</tr>
<tr>
<td>VM_DONTEXPAND</td>
<td>通过mremap禁止线性区扩展</td>
</tr>
<tr>
<td>VM_RESERVED</td>
<td>线性区是特殊的，因此它的页不能被交换出去</td>
</tr>
<tr>
<td>VM_ACCOUNT</td>
<td>创建IPC共享线性区时检查是否有足够的空闲内存用于映射</td>
</tr>
<tr>
<td>VM_HUGETLB</td>
<td>通过扩展分页机制处理线性区中的页</td>
</tr>
<tr>
<td>VM_NONLINEAR</td>
<td>线性区实现非线性文件映射</td>
</tr>
</tbody>
</table>
</div>
<p>​    线性区描述符所包含的页访问权限可以任意组合。如，存在这样一种可能性，允许一个线性区中的页可执行但不可以读取。为了有效地实现这种保护方案，与线性区的页相关的访问权限（读，写，执行）必须被复制到相应的所有表项中，以便由分页单元直接执行检查。即，页访问权限表示何种类型的访问应产生一个缺页异常。<code>Linux</code>委派缺页处理程序查找导致缺页的原因。因为，缺页处理程序实现了许多页处理策略。</p>
<p>​    页表标志的值存放在<code>vm_area_struct</code>描述符的<code>vm_page_prot</code>字段。当增加一个页时，内核根据<code>vm_page_prot</code>字段的值设置相应页表项中的标志。然而，不能把线性区的访问权限直接转换成页保护位：</p>
<ol>
<li><p>某些情况下，即使由相应线性区描述符的<code>vm_flags</code>所指定的某个页的访问权限允许对该页进行访问，但，对该页的访问还是应产生一个缺页异常。如，本章后面”写时复制”。内核可能决定把属于两个不同进程的两个完全一样的可写私有页存入同一页框；这种情况下，无论哪一个进程试图改动这个页都应当产生一个异常。</p>
</li>
<li><p><code>80x86</code>处理器的页表仅有两个保护位，即<code>Read/Write</code>和<code>User/Supervisor</code>。一个线性区所包含的任何一个页的<code>User/Supervisor</code>需总是置为<code>1</code>，因为用户态进程需总能访问其中的页。</p>
</li>
<li><p>启用<code>PAE</code>的新近<code>Intel Pentium 4</code>，在所有<code>64</code>位页表项中支持<code>NX</code>标志。</p>
</li>
<li><p>如内核没被继续编译成支持<code>PAE</code>，则<code>Linux</code>采取如下规则以克服<code>80x86</code>微处理器的硬件限制：</p>
<blockquote>
<ol>
<li>读访问权限总是隐含着执行访问权限，反之亦然。</li>
<li>写访问权限总是隐含着读访问权限。反之，如内核编程成支持<code>PAE</code>，且<code>CPU</code>有<code>NX</code>标志（<code>No Execute</code>）。</li>
</ol>
</blockquote>
<p><code>Linux</code>就采取不同的规则：</p>
<blockquote>
<ol>
<li>执行访问权限总是隐含着读访问权限</li>
<li>写访问权限总是隐含着读访问权限</li>
</ol>
</blockquote>
</li>
</ol>
<p>为做到在”写时复制”(<code>Copy on Write</code>)中适当地推迟页框的分配，只要相应的页不是由多个进程所共享，则这种页框应是写保护的。故要根据以下规则精简由读，写，执行，共享访问的<code>16</code>中可能组合</p>
<ol>
<li>如页有写，共享。则<code>Read/Write</code>设置为<code>1</code>。</li>
<li>如页有读或执行，但既没写，也没共享访问权限。则，<code>Read/Write</code>置为<code>0</code>。</li>
<li>如支持<code>NX</code>，且也没执行访问权限，则<code>NX</code>置为<code>1</code>。</li>
<li>如页没任何访问权限，则<code>Present</code>置为<code>0</code>。以便每次访问都产生一个缺页异常。为了把这种情况与真正的页框不存在情况区分，<code>Linux</code>还把<code>Pagesize</code>置为<code>1</code>。</li>
<li>访问权限的每种组合对应的精简后的保护位存放在<code>protection_map</code>。</li>
</ol>
<h3 id="线性区的处理"><a href="#线性区的处理" class="headerlink" title="线性区的处理"></a>线性区的处理</h3><p>​    对控制内存处理所用的数据结构和状态信息有基本理解后，看一组对线性区描述符进行操作的底层函数。这些函数应被看作简化了<code>do_map</code>和<code>do_unmap</code>实现的辅助函数。这两个函数将在后面”分配线性地址区间”，”释放线性地址区间”中描述。它们分别扩大或缩小进程的地址空间。它们并不接受线性区描述符作为参数，而是用一个线性地址区间的起始地址，长度，访问权限作为参数。</p>
<h4 id="查找给定地址的最近邻区：find-vma"><a href="#查找给定地址的最近邻区：find-vma" class="headerlink" title="查找给定地址的最近邻区：find_vma"></a>查找给定地址的最近邻区：find_vma</h4><p>参数：</p>
<ul>
<li>进程内存描述符的地址<code>mm</code>，</li>
<li>线性地址<code>addr</code>。</li>
</ul>
<p>​    它查找线性区的<code>vm_end</code>大于<code>addr</code>的第一个线性区的位置，并返回这个线性区描述符的地址。如没这样的线性区存在，就返回一个<code>NULL</code>。<strong>注意， 由<code>find_vma</code>所选择的线性区并不一定要包含<code>addr</code>，因为<code>addr</code>可能位于任何线性区之外。</strong></p>
<p>​    每个内存描述符包含一个<code>mmap_cache</code>字段，这个字段保存进程最后一次引用线性区的描述符地址。引进这个附加字段是为了减少查找一个给定线性地址所在线性区而花费的时间。程序中引用地址的局部性使下面这种情况出现的可能性很大：如检查的最后一个地址属于某一给定的线性区，则下一个要检查的线性地址也属于这一个线性区。故该函数一开始就检查由<code>mmap_cache</code>所指定的线性区是否包含<code>addr</code>。如是，就返回这个线性区描述符的指针</p>
<pre class="line-numbers language-none"><code class="language-none">vma &#x3D; mm-&gt;mmap_cache;
if(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;&#x3D; addr)
	return vma;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>否则，必须扫描进程的线性区，并在红-黑树中查找线性区</p>
<pre class="line-numbers language-none"><code class="language-none">rb_node &#x3D; mm-&gt;mm_rb.rb_node;
vma &#x3D; NULL;
while(rb_node)
&#123;
	vma_tmp &#x3D; rb_entry(rb_node, struct vm_area_struct, vm_rb);
	if(vma_tmp-&gt;vm_end &gt; addr)
	&#123;
		vma &#x3D; vma_tmp;
		if(vma_tmp-&gt;vm_start &lt;&#x3D; addr)
			break;
		rb_node &#x3D; rb_node-&gt;rb_left;
	&#125;
	else
		rb_node &#x3D; rb_node-&gt;rb_right;
&#125;

if(vma)
	mm-&gt;mmap_cache &#x3D; vma;
return vma;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    函数用红<code>rb_entry</code>从指向红黑树的一个节点的指针导出相应线性区描述符的地址。</p>
<p>​    <code>find_vma_prev</code>，把函数中选中的前一个线性区描述符的指针赋给附加参数<code>ppre</code>。<br><code>find_vma_prepare</code>确定新叶子节点在与给定线性地址对应的红-黑树中的位置，返回前一个线性区的地址和要插入的叶子节点的父节点的地址。</p>
<h3 id="查找一个与给定的地址区间相重叠的线性区：find-vma-intersection"><a href="#查找一个与给定的地址区间相重叠的线性区：find-vma-intersection" class="headerlink" title="查找一个与给定的地址区间相重叠的线性区：find_vma_intersection"></a>查找一个与给定的地址区间相重叠的线性区：find_vma_intersection</h3><p>参数：</p>
<ul>
<li><code>mm</code>指向进程的内存描述符，</li>
<li>线性地址<code>start_addr</code>和<code>end_addr</code>指定这个区间</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">vma &#x3D; find_vma(mm, start_addr);
if(vma &amp;&amp; end_addr &lt;&#x3D; vma-&gt;vm_start)
	vma &#x3D; NULL;
return vma;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如没这样的线性区存在，就返回一个<code>NULL</code>。如<code>find_vma</code>返回一个有效的地址，但所找到的线性区是从这个线性地址区间的末尾开始的，<code>vma</code>就置为<code>NULL</code>。</p>
<h3 id="查找一个空闲的地址区间：get-unmapped-area"><a href="#查找一个空闲的地址区间：get-unmapped-area" class="headerlink" title="查找一个空闲的地址区间：get_unmapped_area"></a>查找一个空闲的地址区间：get_unmapped_area</h3><p>参数：</p>
<ul>
<li><code>len</code>，指定区间的长度，</li>
<li><code>addr</code>，非空的<code>addr</code>指定必须从哪个地址开始查找。</li>
</ul>
<p>返回值：如查找成功，返回这个新区间的起始地址；否则，返回错误码<code>-ENOMEM</code>。</p>
<p>​    如<code>addr</code>不等于<code>NULL</code>，就检查所指定的地址是否在用户态空间并与页边界对齐。函数根据线性地址区间是否应用于文件内存映射或匿名内存映射，调两个方法（<code>get_unmapped_area</code>文件操作和内存描述符的<code>get_unmapped_area</code>）中的一个。前一种情况下，函数执行<code>get_unmapped_area</code>文件操作。第二种情况下，函数执行内存描述符的<code>get_unmapped_area</code>。根据进程的线性区类型，由函数<code>arch_get_unmapped_area</code>或<code>arch_get_unmapped_area_topdown</code>实现<code>get_unmapped_area</code>。</p>
<p>通过系统调用<code>map</code>，每个进程可获得两种不同形式的线区：<strong>一种从线性地址<code>0x40000000</code>开始并向高端地址增长，另一种正好从用户态堆栈开始并向低端地址增长。</strong></p>
<p>在分配从低端地址向高端地址移动的线性区时使用<code>arch_get_unmapped_area</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">if(len &gt; TASK_SIEZ)
	return -ENOMEM;
addr &#x3D; (addr + 0xfff) &amp; 0xfffff000;
if(addr &amp; addr + len &lt;&#x3D; TASK_SIZE)
&#123;
	vma &#x3D; find_vma(current-&gt;mm, addr);
	if(!vma || addr + len &lt;&#x3D; vma-&gt;vm_start)
		return addr;
&#125;

start_addr &#x3D; addr &#x3D; mm-&gt;free_area_cache;
for(vma &#x3D; find_vma(current-&gt;mm, addr); ; vma &#x3D; vma-&gt;vm_next)
&#123;
	if(addr + len &gt; TASK_SIZE)
	&#123;
		if(start_addr &#x3D;&#x3D; (TASK_SIZE&#x2F;3 + 0xfff) &amp; 0xfffff000)
			return -ENOMEM;
		start_addr &#x3D; addr &#x3D; (TASK_SIZE&#x2F;3 + 0xfff) &amp; 0xfffff000;&#x2F;&#x2F; 这是允许的最低起始线性地址
		vma &#x3D; find_vma(current-&gt;mm, addr);
	&#125;
	
	if(!vma || addr + len &lt;&#x3D; vma-&gt;vm_start)
	&#123;
		mm-&gt;free_area_cache &#x3D; addr + len;
		return addr;&#x2F;&#x2F; 返回线性地址是满足分配要求线性区（尚未分配）的起始地址
	&#125;
	
	addr &#x3D; vma-&gt;vm_end;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数先检查区间的长度是否在用户态下线性地址区间的限长<code>TASK_SIZE</code>之内。</p>
<blockquote>
<p>如<code>addr</code>不为0，函数就试图从<code>addr</code>开始分配区间。为安全，函数把<code>addr</code>值调整为<code>4KB</code>倍数。<br>如<code>addr</code>等于<code>0</code>或前面的搜索失败，<code>arch_get_unmapped_area</code>就扫描用户态线性地址空间以查找一个可包含新区的足够大的线性地址范围。但任何已有的线性区都不包括这个地址范围。</p>
</blockquote>
<p>​    为提高搜索速度，让搜索从最近被分配的线性区后面的线性地址开始，把内存描述符的字段<code>mm-&gt;free_area_cache</code>初始化为用户态线性地址空间的三分之一，并在以后创建新线性区时对它更新。如找不到一个合适的线性地址范围，就从用户态线性地址空间的三分之一的开始处重新开始搜索。其实，用户态线性地址空间的三分之一是为有预定义起始线性地址的线性区（典型的是可执行文件的正文段，数据段，bss段）而保留的。</p>
<p>函数调<code>find_vma</code>以确定搜索起点后第一个线性区终点的位置。三种情况：</p>
<ul>
<li>如所请求的区间大于正待扫描的线性地址空间部分（<code>addr+len&gt;TASK_SIZE</code>），函数就从用户态地址空间的三分之一处重新开始搜索，如已完成第二次搜索，就返回<code>-ENOMEM</code>。</li>
<li>刚扫描过的线性区后面的空闲区没足够的大小，<code>vma != NULL &amp;&amp; vma-&gt;vm_start &lt; addr + len</code>此时，继续考虑下一个线性区。</li>
<li>如以上两情况都没发生，则找到一个足够大的空闲区。函数返回<code>addr</code>。</li>
</ul>
<h3 id="向内存描述符链表中插入一个线性区：insert-vm-struct"><a href="#向内存描述符链表中插入一个线性区：insert-vm-struct" class="headerlink" title="向内存描述符链表中插入一个线性区：insert_vm_struct"></a>向内存描述符链表中插入一个线性区：insert_vm_struct</h3><p>参数：</p>
<ul>
<li><code>mm</code>，指定进程内存描述符的地址，</li>
<li><code>vmp</code>指定要插入的<code>vm_area_struct</code>对象的地址，线性区对象的<code>vm_start</code>和<code>vm_end</code>必须已经初始化过。</li>
</ul>
<p>函数调<code>find_vma_prepare</code>在红-黑树<code>mm-&gt;mm_rb</code>中查找<code>vma</code>应位于何处。然后，<code>insert_vm_struct</code>又调<code>vma_link</code>。</p>
<p><strong>vma_link</strong>：</p>
<ol>
<li>在<code>mm-&gt;mmap</code>所指向的链表中插入线性区。</li>
<li>在红-黑树<code>mm-&gt;mm_rb</code>中插入线性区。</li>
<li>如线性区是匿名的，就把它插入以相应的<code>anon_vma</code>数据结构作为头节点的链表中。</li>
<li>如线性区包含一个内存映射文件，则执行相关任务。</li>
<li>递增<code>mm-&gt;map_count</code>。</li>
</ol>
<p><strong>__vma_unlink</strong>：<br>参数：</p>
<ul>
<li>为一个内存描述符地址<code>mm</code>，</li>
<li>两个线性区对象地址<code>vma</code>和<code>prev</code>。两个线性区都应属于<code>mm</code>，<code>prev</code>应在线性区的排序中位于<code>vma</code>之前。</li>
</ul>
<p>过程：<br>该函数从内存描述符链表和红-黑树中删除<code>vma</code>，<br>如<code>mm-&gt;mmap_cache</code>（存放刚被引用的线性区）字段指向刚被删除的线性区，则还要对<code>mm-&gt;mmap_cache</code>进行更新。</p>
<h3 id="分配线性地址区间"><a href="#分配线性地址区间" class="headerlink" title="分配线性地址区间"></a>分配线性地址区间</h3><p><strong>do_mmap</strong>：</p>
<p>功能：</p>
<ul>
<li>为当前进程创建并初始化一个新的线性区</li>
</ul>
<p>参数：</p>
<ul>
<li><code>file</code>和<code>offser</code>，如新的线性区把一个文件映射到内存，则使用文件描述符指针<code>file</code>和文件偏移量<code>offset</code>。</li>
<li><code>addr</code>，这个线性地址指定从何处开始查找一个空闲的区间。</li>
<li><code>len</code>，线性地址区间的长度。</li>
<li><code>prot</code>，这个线性区所包含页的访问权限。可能的标志有<code>PROT_READ</code>，<code>PROT_WRITE</code>，<code>PROT_EXEC</code>和<code>PROT_NONE</code>。前三个标志与标志<code>VM_READ</code>，<code>WM_WRITE</code>及<code>VM_EXEC</code>意义一样。<code>PROT_NONE</code>表示进程没以上三个访问权限中任意一个。</li>
<li><code>flag</code>，指定线性区的其他标志<code>MAP_GROWSDOWN</code>，<code>MAP_LOCKED</code>，<code>MAP_DENYWRITE</code>和<code>MAP_EXECUTEABLE</code>，<code>MAP_SHARED</code>和<code>MAP_PRIVATE</code>，<code>MAP_FIXED</code>，<code>MAP_ANONYMOUS</code>，<code>MAP_NORESERVE</code>，<code>MAP_POPULATE</code>，<code>MAP_NONBLOCK</code>。</li>
</ul>
<p>一些标志的解释：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>flag</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MAP_FIXED</code></td>
<td>区间的起始地址必须由参数<code>addr</code>指定。</td>
</tr>
<tr>
<td><code>MAP_ANONYMOUS</code></td>
<td>没有文件与这个线性区相关联。</td>
</tr>
<tr>
<td><code>MAP_POPULATE</code></td>
<td>函数应为线性区建立的映射提前分配需要的页框，该标志对映射文件的线性区和<code>IPC</code>共享的线性区有意义。</td>
</tr>
<tr>
<td><code>MAP_NONBLOCK</code></td>
<td>只在<code>MAP_POPULATE</code>置位时才有意义，提前分配页框时，函数肯定不阻塞。</td>
</tr>
</tbody>
</table>
</div>
<p><code>do_mmap</code>对<code>offset</code>的值进行一些初步检查，然后执行<code>do_mmap_pgoff</code>。本节假设新的线性地址区间映射的不是磁盘文件，这里仅对实现匿名线性区的<code>do_mmap_pgoff</code>进行说明。</p>
<ol>
<li><p>检查参数的值是否正确，所提的请求是否能被满足。尤其检查：</p>
<blockquote>
<ol>
<li>线性地址区间的长度为<code>0</code>或包含的地址大于<code>TASK_SIZE</code>。</li>
<li>进程已映射了过多的线性区，即，<code>mm</code>内存描述符的<code>map_count</code>字段的值超过了允许的最大值。</li>
<li>flag参数指定新线性地址区间的页必须被锁在<code>RAM</code>中，但不允许进程创建上锁的线性区，或进程加锁页的总数超过了保存在进程描述符<code>signal-&gt;rlim[RLIMIT_MEMLOCK].rlim_cur</code>字段的阈值。</li>
</ol>
<p>以上任一情况成立，则<code>do_mmap_pgoff</code>终止并返回一个负值、如线性地址区间的长度为<code>0</code>，则函数不执行任何操作就返回。</p>
</blockquote>
</li>
<li><p>调<code>get_unmapped_area</code>获得新线性区的线性地址区间</p>
</li>
<li><p>通过把存放在<code>prot</code>和<code>flags</code>参数中的值进行组合来计算新线性区描述符的标志</p>
<blockquote>
<pre class="line-numbers language-none"><code class="language-none">  &gt;vm_flags &#x3D; calc_vm_prot_bits(prot, flags) | calc_vm_flag_bits(prot, flags) | mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
  &gt;if(flags &amp; MAP_SHARED)
vm_flags |&#x3D; VM_SHARED | VM_MAYSHARE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>只有在<code>prot</code>中设置了相应的<code>PROT_READ</code>，<code>PROT_WRITE</code>和<code>PROT_EXEC</code>标志，<code>calc_vm_prot_bits</code>才在<code>vm_flags</code>中设置<code>VM_READ</code>，<code>VM_WRITE</code>，<code>VM_EXEC</code>；只有在flags设置了相应的<code>MAP_GROWSDOWN</code>，<code>MAP_DENYWRITE</code>，<code>MAP_EXECUTABLE</code>和<code>MAP_LOCKED</code>，<code>calc_vm_flag_bits</code>才在<code>vm_flags</code>中设置<code>VM_GROWSDOWN</code>，<code>VN_DENYWRITE</code>，<code>VM_EXECUTABLE</code>和<code>VM_LOCKED</code>。<br>在<code>vm_flags</code>中还有几个标志被置为<code>1</code>：<code>VM_MAYREAD</code>，<code>VM_MAYWRITE</code>，<code>VM_MAYEXEC</code>。在<code>mm_def_flags</code>中所有线性区的默认标志，及如线性区的页与其他进程共享时的<code>VM_SHARED</code>和<code>VM_MAYSHARE</code>。</p>
</blockquote>
</li>
<li><p>调<code>find_vma_prepare</code>确定处于新区间之前的线性区对象的位置，及在红-黑树中新线性区的位置</p>
<blockquote>
<pre class="line-numbers language-none"><code class="language-none">  &gt;for(;;)
  &gt;&#123;
vma &#x3D; find_vma_prepare(mm, addr, &amp;prev, &amp;rb_link, &amp;rb_parent);
if(!vma || vma-&gt;vm_start &gt;&#x3D; addr + len)
	break;
if(do_munmap(mm, addr, len))&#x2F;&#x2F; 返回非0表示操作执行失败
	return -ENOMEM;
  &gt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>find_vma_prepare</code>也检查是否还存在与新区间重叠的线性区。这情况发生在函数返回一个非空的地址，这个地址指向一个线性区，该区的起始位置位于新区间结束地址之前的时候。此情况下，<code>do_mmap_pgoff</code>调<code>do_munmap</code>删除新的区间，然后重复整个步骤。</p>
</blockquote>
</li>
<li><p>检查插入新的线性区是否引起进程地址空间的大小超过存放在进程描述符<code>signal-&gt;rlim[RLIMIT_AS].rlim_cur</code>字段中的阈值。如是，就返回错误码<code>-ENOMEM</code>。这个检查只在这里进行，不在第一步与其他检查一起进行。</p>
</li>
<li><p>若在<code>flags</code>参数中没设置<code>MAP_NORESERVE</code>，新的线性区包含私有可写页，且没足够的空闲页框，则返回出错码<code>-ENOMEM</code>；这最后一个检查由<code>security_vm_enough_memory</code>实现。</p>
</li>
<li><p>如新区间是私有的，且映射的不是磁盘上的一个文件，则调<code>vma_merge</code>检查前一个线性区是否可以这样的方式进行扩展来包含新的区间。前一个线性区须与在<code>vm_flags</code>中存放标志的那些线性区有相同的标志。如前一个线性区可扩展，则<code>vma_merge</code>试图把它与随后的线性区合并。一旦扩展前一线性区成功，跳<code>12</code>。</p>
</li>
<li><p>调<code>slab</code>分配函数<code>kmem_cache_alloc</code>为新线性区分配一个<code>vm_area_struct</code></p>
</li>
<li><p>初始化新的线性区对象</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">vma<span class="token operator">-></span>vm_mm <span class="token operator">=</span> mm<span class="token punctuation">;</span>
vma<span class="token operator">-></span>vm_start <span class="token operator">=</span> addr<span class="token punctuation">;</span>
vma<span class="token operator">-></span>vm_end <span class="token operator">=</span> addr <span class="token operator">+</span> len<span class="token punctuation">;</span>
vma<span class="token operator">-></span>vm_flags <span class="token operator">=</span> vm_flags<span class="token punctuation">;</span>
vma<span class="token operator">-></span>vm_page_prot <span class="token operator">=</span> protection_map<span class="token punctuation">[</span>vm_flags <span class="token operator">&amp;</span> <span class="token number">0x0f</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
vma<span class="token operator">-></span>vm_ops <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
vma<span class="token operator">-></span>vm_pgoff <span class="token operator">=</span> pgoff<span class="token punctuation">;</span>
vma<span class="token operator">-></span>vm_file <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
vma<span class="token operator">-></span>vm_private_data <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
vma<span class="token operator">-></span>vm_next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token function">INIT_LIST_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>vma<span class="token operator">-></span>shared<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如<code>MAP_SHARED</code>被设置，则该线性区是一个共享匿名区：调<code>shmem_zero_setup</code>对它进行初始化，共享匿名区主要用于进程间通信</p>
</li>
<li><p>调<code>vma_link</code>把新线性区插入到线性区链表和红-黑树</p>
</li>
<li><p>增加存放在内存描述符<code>total_vm</code>字段中的进程地址空间大小</p>
</li>
<li><p>如设置了<code>VM_LOCKED</code>，就调<code>make_pages_present</code>连续分配线性区 的所有页，并把它们锁在<code>RAM</code>中</p>
<blockquote>
<pre class="line-numbers language-none"><code class="language-none">   &gt;if(vm_flags &amp; VM_LOCKED)
   &gt;&#123;
mm-&gt;locked_vm +&#x3D; len &gt;&gt; PAGE_SHIFT;
make_pages_present(addr, addr + len);
   &gt;&#125;
   &gt;12345
   &gt;make_pages_present&#96;按如下方式调&#96;get_user_pages
   &gt;write &#x3D; (vma-&gt;vm_flags &amp; VM_WRITE) !&#x3D; 0;
   &gt;get_user_pages(current, current-&gt;mm, addr, len, write, 0, NULL, NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>get_user_pages</code>在<code>addr</code>和<code>addr+len</code>之间页的所有起始线性地址上循环；对其中的每个页，该函数调<code>follow_page</code>检查在当前页表中是否有物理页的映射。如没这样的物理页存在，则<code>get_user_pages</code>调<code>handle_mm_fault</code>，后一个函数分配一个页框并根据内存描述符的<code>vm_flags</code>设置它的页表项。</p>
</blockquote>
</li>
<li><p>函数通过返回新线性区的线性地址而终止</p>
</li>
</ol>
<h3 id="释放线性地址区间"><a href="#释放线性地址区间" class="headerlink" title="释放线性地址区间"></a>释放线性地址区间</h3><p><strong>do_munmap</strong>：<br>功能：</p>
<ul>
<li>释放线性地址区间</li>
</ul>
<p>参数：</p>
<ul>
<li>进程描述符的地址<code>mm</code>，</li>
<li>地址区间的起始地址<code>start</code>，</li>
<li>它的长度<code>len</code>。</li>
</ul>
<p><strong>split_vma</strong>：<br>功能：</p>
<ul>
<li>把与线性地址区间交叉的线性区划分成两个较小的区，一个在线性地址区间外部，另一个在区间的内部。</li>
</ul>
<p>参数：</p>
<ul>
<li>内存描述符指针<code>mm</code>，</li>
<li>线性区描述符指针<code>vma</code>，</li>
<li>表示区间与线性区之间交叉点的地址<code>addr</code>，</li>
<li>表示区间与线性区之间交叉点在区间起始处还是结束处的标志<code>new_below</code>。</li>
</ul>
<p>步骤：</p>
<ol>
<li>调<code>kmem_cache_alloc</code>获得线性区描述符<code>vm_area_struct</code>。把它的地址存在新的局部变量中，如没可用的空闲空间，就返回<code>-ENOMEM</code>。</li>
<li>用<code>vma</code>描述符的字段值初始化新描述符的字段</li>
<li>如标志<code>new_below</code>为<code>0</code>，说明线性地址区间的起始地址在<code>vma</code>线性区的内部。因此须把新线性区放在<code>vma</code>线性区之后，函数把<code>new-&gt;vm_start</code>和<code>vma-&gt;vm_end</code>赋值为<code>addr</code>。</li>
<li>如<code>new_below</code>等于<code>1</code>，说明线性地址区间的结束地址在<code>vma</code>线性区的内部。故需把新线性区放在<code>vma</code>线性区的前面，所以，函数把字段<code>new-&gt;vm_end</code>和<code>vm-&gt;vm_start</code>都赋值为<code>addr</code>。</li>
<li>如定义了新线性区的<code>open</code>，执行它</li>
<li>把新线性区描述符链接到线性区链表<code>mm-&gt;mmap</code>和红黑树<code>mm-&gt;mm_rb</code>，函数还要根据线性区<code>vma</code>的最新大小对红-黑树进行调整</li>
<li>返回0</li>
</ol>
<p><strong>unmap_region</strong>：</p>
<p>作用：</p>
<ul>
<li>遍历线性区链表并释放它们的页框</li>
</ul>
<p>参数：</p>
<ul>
<li>内存描述符指针<code>mm</code>，</li>
<li>指向第一个被删除线性区描述符的指针<code>vma</code>，</li>
<li>指向进程链表中vma前面的线性区的指针<code>prev</code>，</li>
<li>地址<code>start</code>，</li>
<li>地址<code>end</code>。</li>
</ul>
<p>步骤：</p>
<ol>
<li>调<code>lru_add_drain</code></li>
<li>调<code>tlb_gather_mmu</code>初始化每<code>CPU</code>变量<code>mmu_gathers</code>。<code>mmu_gathers</code>依赖于体系结构：通常该变量应存放成功更新进程页表项所需的所有信息。在<code>80x86</code>体系结构中，<code>tlb_gather_mmu</code>只是简单地把内存描述符指针<code>mm</code>的值赋给本地<code>CPU</code>的<code>mmu_gathers</code></li>
<li>把<code>mmu_gathers</code>变量的地址存在局部变量<code>tlb</code></li>
<li>调<code>unmap_vmas</code>扫描线性地址空间的所有页表项：如只有一个有效<code>CPU</code>，函数就调<code>free_swap_and_cache</code>反复释放相应页框。否则， 函数就把相应页描述符的指针保存在局部变量<code>mmu_gathers</code></li>
<li>调<code>free_pgtables(tlb, prev, start, end)</code>回收上一步已清空的进程页表</li>
<li>调<code>tlb_finish_mmu(tlb, start, end)</code>结束<code>unmap_region</code>的工作。</li>
</ol>
<p><strong>tlb_finish_mmu(tlb, start, end)</strong>：</p>
<ol>
<li>调<code>flush_tlb_mm</code>刷新<code>TLB</code></li>
<li>在多处理器系统中，调<code>free_pages_and_swap_cache</code>释放页框，这些页框的指针已经集中存放在<code>mmu_gather</code>中了。</li>
</ol>
<p><strong>do_munmap</strong>：<br>第一阶段，扫描进程所拥有的线性区链表，把包含在进程地址空间的线性地址区间中的所有线性区从链表中解除链接；<br>第二阶段，更新进程的页表，把第一阶段找到并标识出的线性区删除。</p>
<p>步骤如下：</p>
<ol>
<li>对参数值检查。</li>
<li>确定要删除的线性地址区间之后第一个线性区<code>mpnt</code>位置，如有这样的线性区</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">mpnt &#x3D; find_vma_prev(mm, start, &amp;prev);
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li>如没这样的线性区，也没与线性区间重叠的线性区，就什么都不做</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">end &#x3D; start + len;
if(!mpnt || mpnt-&gt;vm_start &gt;&#x3D; end)
	return 0;
123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>如线性区的起始地址在线性区<code>mpnt</code>内，就调<code>split_vma</code>把线性区<code>mpnt</code>分成两个较小的区：一个区在线性地址区间外，另一个在区间内</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">if(start &gt; mpnt-&gt;vm_start)
&#123;
	if(split_vma(mm, mpnt, start, 0))
		return -ENOMEM;
	prev &#x3D; mpnt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>更新局部变量<code>prev</code>，以前它存储的是指向线性区<code>mpnt</code>前面一个线性区的指针，现在让它指向<code>mpnt</code>，即指向线性地址区间外部的那个新线性区。这样<code>prev</code>仍指向要删除的第一个线性区前面的那个线性区</p>
<ol>
<li>如线性区的结束地址在一个线性区内部，就再次调<code>split_vma</code>把最后重叠的那个线性区划分成两个较小的区：一个在线性地址区间内，另一个在区间外</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">last &#x3D; find_vma(mm, end);
if(last &amp;&amp; end &gt; last-&gt;vm_start)
&#123;
	if(split_vma(mm, last, start, end, 1))
		return -ENOMEM;
&#125;
123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>更新<code>mpnt</code>值，使它指向线性地址区间的第一个线性区。如prev为NULL，就从<code>mm-&gt;mmap</code>获得第一个线性区的地址</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">mpnt &#x3D; prev ? prev-&gt;vm_next : mm-&gt;mmap;
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li>调<code>detach_vmas_to_be_unmapped</code>从进程的线性地址空间中删除位于线性地址区间中的线性区。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">vma &#x3D; mpnt;
insertion_point &#x3D; (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap);
do
&#123;
	rb_erase(&amp;vma-&gt;vm_rb, &amp;mm-&gt;mm_rb);
	mm-&gt;map_count--;
	tail_vma &#x3D; vma;
	vma &#x3D; vma-&gt;next;
&#125; while(vma &amp;&amp; vma-&gt;start &lt; end);
*insertion_point &#x3D; vma;
tail_vma-&gt;vm_next &#x3D; NULL;
mm-&gt;map_cache &#x3D; NULL;
123456789101112<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要删除的线性区的描述符存放在一个排序好的链表中，局部变量<code>mpnt</code>指向该链表的头</p>
<ol>
<li>获得<code>mm-&gt;page_table_lock</code></li>
<li>调<code>unmap_region</code>清除与线性地址区间对应的页表项并释放相应的页框</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">unmap_region(mm, mpnt, prev, start, end);
1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li>释放<code>mm-&gt;page_table_lock</code></li>
<li>释放<code>7</code>步建立链表时收集的线性区描述符</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">do
&#123;
	struct vm_area_struct* next &#x3D; mpnt-&gt;vm_next;
	unmap_vma(mm, mpnt);
	mpnt &#x3D; next;
&#125; while(mpnt !&#x3D; NULL);
123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对在链表中的所有线性区调<code>unmap_vma</code>，它本质上执行下述：</p>
<ol>
<li>更新<code>mm-&gt;total_vm</code>和<code>mm-&gt;locked_vm</code></li>
<li>执行内存描述符的<code>mm-&gt;unmap_area</code>。根据进程线性区的不同类型可选择<code>arch_unmap_area</code>或<code>arch_unmap_area_topdown</code>中的一个来实现<code>mm-&gt;unmap_area</code>。如必要，在两种情况下都要更新<code>mm-&gt;free_area_cache</code>。</li>
<li>调线性区的<code>close</code></li>
<li>如线性区是匿名的，则函数把它从<code>mm-&gt;anon_vma</code>所指向的匿名线性区链表中删除</li>
<li>调<code>kmem_cache_free</code>释放线性区描述符</li>
<li>返回<code>0</code></li>
</ol>
<h3 id="缺页异常处理程序"><a href="#缺页异常处理程序" class="headerlink" title="缺页异常处理程序"></a>缺页异常处理程序</h3><h4 id="1-处理地址空间以外的错误地址"><a href="#1-处理地址空间以外的错误地址" class="headerlink" title="1.处理地址空间以外的错误地址"></a>1.处理地址空间以外的错误地址</h4><p>如<code>address</code>不属于进程的地址空间，则<code>do_page_fault</code>继续执行<code>bad_area</code>处语句。</p>
<pre class="line-numbers language-none"><code class="language-none">bad_area:
	up_read(&amp;tsk-&gt;mm-&gt;mmap_sem);
bad_area_nosemaphore:
	if(error_code &amp; 4)
	&#123;
		tsk-&gt;thread.cr2 &#x3D; address;
		tsk-&gt;thread.error_code &#x3D; error_code | (address &gt;&#x3D; TASK_SIZE);
		tsk-&gt;thread.trap_no &#x3D; 14;
		info.si_signo &#x3D; SIGSEGV;
		info.si_errno &#x3D; 0;
		info.si_addr &#x3D; (void*)address;
		force_sig_info(SIGSEGV, &amp;info, tsk);
		return;
	&#125;	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如错误发生在用户态，则发送一个<code>SIGSEGV</code>信号给<code>current</code>，<code>force_sig_info</code>确信进程不忽略或阻塞<code>SIGSEGV</code>信号，并通过<code>info</code>局部变量传递附加信息的同时把该信号发送给用户态进程；<code>info.si_code</code>字段已被置为<code>SEGV_MAPERR</code>或置为<code>SEGV_ACCERR</code>；<br>如异常发生在内核态（<code>error_code</code>的第<code>2</code>位被清<code>0</code>），仍有两种可选的情况：</p>
<ul>
<li>异常的引起是由于把某个线性地址作为系统调用的参数传递给内核</li>
<li>异常是因一个真正的内核缺陷所引起</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">no_context:
	if((fixup &#x3D; search_exception_table(regs-&gt;eip)) !&#x3D; 0)
	&#123;
		regs-&gt;eip &#x3D; fixup;
		return;
	&#125;
123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>在第一种情况中，代码跳到一段”修正代码”处。这段代码的典型操作是向当前进程发<code>SIGSEGV</code>信号，或用一个适当的出错码终止系统调用处理程序。</li>
<li>第二种情况中，函数把<code>CPU</code>寄存器和内核态堆栈的全部转储打印到控制台，并输出到一个系统消息缓冲区，然后调<code>do_exit</code>杀死当前进程。这就是所谓按所显示的消息命名的”内核漏洞”错误。这些输出值可由内核编程高手用于推测引发此错误的条件，进而发现并纠正错误。</li>
</ul>
<h4 id="2-处理地址空间内的错误地址"><a href="#2-处理地址空间内的错误地址" class="headerlink" title="2.处理地址空间内的错误地址"></a>2.处理地址空间内的错误地址</h4><p>如<code>addr</code>地址属于进程的地址空间，则<code>do_page_fault</code>转到<code>good_area</code>标记处的语句执行。</p>
<pre class="line-numbers language-none"><code class="language-none">good_area:
	info.si_code &#x3D; SEGV_ACCERR;
	write &#x3D; 0;
	if(error_code &amp; 2)
	&#123;
		if(!(vma-&gt;vm_flags &amp; VM_WRITE))
			goto bad_area;
		write++;
	&#125;
	else
		if((error_code &amp; 1) || !(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC)))
			goto bad_area;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如异常由写访问引起，检查这个线性区是否可写。如不可写，跳到<code>bad_area</code>；如可写，把<code>write</code>局部变量置为<code>1</code>；如异常由读或执行访问引起，函数检查这一页是否已经存在于<code>RAM</code>。（权限引起）在存在的情况下，异常发生是由于进程试图访问用户态下的一个有特权的页框，故函数跳到<code>bad_area</code>。（<code>NotExist</code>引起）在不存在的情况下，函数还将检查这个线性区是否可读或可执行。如这个线性区的访问权限与引起异常的访问类型相匹配，则调<code>handle_mm_fault</code>分配一个新的页框</p>
<pre class="line-numbers language-none"><code class="language-none">survive:
	ret &#x3D; handle_mm_fault(tsk-&gt;mm, vma, address, write);
	if(ret &#x3D;&#x3D; VM_FAULT_MINOR || ret &#x3D;&#x3D; VM_FAULT_MAJOR)
	&#123;
		if(ret &#x3D;&#x3D; VM_FAULT_MINOR)
			tsk-&gt;min_flt++;
		else
			tsk-&gt;maj_flt++;
		up_read(&amp;tsk-&gt;mm-&gt;mmap_sem);
		return;
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>如<code>handle_mm_fault</code>成功给进程分配一个页框，则返回<code>VM_FAULT_MINOR</code>或<code>VM_FAULT_MAJOR</code>；</li>
<li>值<code>VM_FAULT_MINOR</code>表示在没阻塞当前进程的情况下处理了缺页。这种缺页叫次缺页；</li>
<li>值<code>VM_FAULT_MAJOR</code>表示缺页迫使当前进程睡眠，阻塞当前进程的缺页叫主缺页；</li>
</ul>
<p>函数也返回<code>VM_FAULT_OOM</code>（没有足够的内存）或<code>VM_FAULT_SIGBOS</code>（其他任何错误）；如<code>handle_mm_fault</code>返回值<code>VM_FAULT_SIGBUS</code>，则向进程发<code>SIGBUS</code></p>
<pre class="line-numbers language-none"><code class="language-none">if(ret &#x3D;&#x3D; VM_FAULT_SIGBUS)
&#123;
do_sigbus:
	up_read(&amp;tsk-&gt;mm-&gt;mmap_sem);
	if(!(error_code &amp; 4))
		goto no_context;
	tsk-&gt;thread.cr2 &#x3D; address;
	tsk-&gt;thread.error_code &#x3D; error_code;
	tsk-&gt;thread.trap_no &#x3D; 14;
	info.si_signo &#x3D; SIGBUS;
	info.si_errno &#x3D; 0;
	info.si_code &#x3D; BUS_ADRERR;
	info.si_addr &#x3D; (void*)address;
	force_sig_info(SIGBUS, &amp;info, tsk);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>如<code>handle_mm_fault</code>不分配新页框，就返回<code>VM_FAULT_OOM</code>，此时内核通常杀死当前进程。</li>
<li>如当前进程是<code>init</code>进程，则只是把它放在运行队列的末尾并调用调度程序。一旦<code>init</code>恢复执行，则<code>handle_mm_fault</code>又执行。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">if(ret &#x3D;&#x3D; VM_FAULT_OOM)
&#123;
out_of_memory:
	up_read(&amp;tsk-&gt;mm-&gt;mmap_sem);
	if(tsk-&gt;pid !&#x3D; 1)
	&#123;
		if(error_code &amp; 4)
			do_exit(SIGKILL);
		goto no_context;
	&#125;
	yield();
	down_read(&amp;tsk-&gt;mm-&gt;mmap_sem);
	goto survive;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>handle_mm_fault</strong>：<br>参数：</p>
<ul>
<li><code>mm</code>，执行异常发生时在<code>CPU</code>上运行的进程的内存描述符</li>
<li><code>vma</code>，执行引起异常的线性地址所在线性区的描述符</li>
<li><code>address</code>，引起异常的线性地址</li>
<li><code>write_access</code>，如<code>tsk</code>试图向<code>address</code>写，则置为<code>1</code>；如<code>tsk</code>试图在<code>address</code>读或执行，则置为<code>0</code>；</li>
</ul>
<p>​    函数首先检查用来映射<code>address</code>的页中间目录和页表是否存在。即使<code>address</code>属于进程的地址空间，相应的页表也可能还没被分配。故在做别的事情前先执行分配页目录和页表的任务。</p>
<pre class="line-numbers language-none"><code class="language-none">pgd &#x3D; pgd_offset(mm, address);
spin_lock(&amp;mm-&gt;page_table_lock);
pud &#x3D; pud_alloc(mm, pgd, address);
if(pud)
&#123;
	pmd &#x3D; pmd_alloc(mm, pud, address);
	if(pmd)
	&#123;
		pte &#x3D; pte_alloc_map(mm, pmd, address);
		if(pte)
			return handle_pte_fault(mm, vma, address, write_access, pte, pmd);
	&#125;
&#125;
spin_unlock(&amp;mm-&gt;page_table_lock);
return VM_FAULT_OOM;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>pgd</code>局部变量包含引用<code>address</code>的页全局目录项。如需要的话，调<code>pud_alloc</code>和<code>pmd_alloc</code>分别分配一个新的页上级目录和页中间目录；如需要，调<code>pte_alloc_map</code>分配一个新的页表；如这两步都成功， <code>pte</code>局部变量所指向的页表项就是引用<code>address</code>的表项。然后调<code>handle_pte_fault</code>检查<code>address</code>地址所对应的页表项，并决定如何为进程分配一个新页框：</p>
<ul>
<li>如被访问的页不存在，即这个页还没被存放在任何一个页框中，则，内核分配一个新的页框并适当地初始化。这种技术称为请求调页</li>
<li>如被访问的页存在<strong>但标记为只读，即它已经被存放在一个页框中，则内核分配一个新的页框，并把旧页框的数据拷贝到新页框来初始化它的内容。这种技术称为写时复制</strong></li>
</ul>
<h4 id="请求调页："><a href="#请求调页：" class="headerlink" title="请求调页："></a><strong>请求调页</strong>：</h4><p>​    它把页框的分配推迟到不能再推迟为止。即一直推迟到进程要访问的页不在<code>RAM</code>中，由此引起一个缺页异常；<strong>请求调页背后的动机是：进程开始执行时并不访问其地址空间中的全部地址。</strong>事实上，一部分地址也许永远不会被进程使用。</p>
<p>​    此外，程序的局部性原理保证了在程序执行的每个阶段，真正引用的进程页只有一小部分。因此，临时用不着的页所在的页框可由其他进程来使用。故对全局分配来说，请求调页是首选的它增加了系统中空闲页框的平均数，从而更好地利用空闲内存；从另一个观点，在<code>RAM</code>总数保持不变下，请求调页从总体上能使系统有更大的吞吐量</p>
<p>​    为这一切优点付出的代价是系统额外的开销，由请求调页所引发的每个”缺页”异常必须由内核处理，这将浪费<code>CPU</code>的时钟周期。局部性原理保证了一旦进程开始在一组页上运行，在接下来相当长的一段时间内它会一直停留在这些页上而不去访问其他的页这样，就可认为”缺页”异常是一种稀有事件。</p>
<p>​    被访问的页不在主存中，其原因或者是进程从没访问过该页，或是内核已经回收了相应的页框；这两种情况下，缺页处理程序必须为进程分配新的页框；如何初始化这个页框取决于是哪一种页及页以前是否被进程访问过。特殊情况下：</p>
<ol>
<li>这个页从未被进程访问到且没映射磁盘文件，或页属于线性磁盘文件的映射。内核能识别这些情况，因为页表相应的表项被填充为0，即<code>pte_none</code>宏返回<code>1</code>。</li>
<li>页属于非线性磁盘文件的映射。内核能识别这种情况，因为<code>Present</code>标志被清<code>0</code>，且<code>Dirty</code>被置<code>1</code>。即<code>pte_file</code>返回<code>1</code></li>
<li>进程已访问过这个页，但其内容被临时保存在磁盘上。内核能识别这种情况，因为相应的表项没被填充为<code>0</code>，但<code>Present</code>，<code>Dirty</code>被清<code>0</code>。</li>
</ol>
<p>故<code>handle_pte_fault</code>通过检查<code>address</code>对应的页表项能区分三种情况</p>
<pre class="line-numbers language-none"><code class="language-none">entry &#x3D; *pte;
if(!pte_present(entry))&#x2F;&#x2F; P是0
&#123;
	if(pte_none(entry))&#x2F;&#x2F; 其余位也是0--no_page
		return do_no_page(mm, vma, address, write_access, pte, pmd);
	if(pte_file(entry))&#x2F;&#x2F; Dirty是1-file_page
		return do_file_page(mm, vma, address, write_access, pte, pmd);
	return do_swap_page(mm, vma, address, pte, pmd, entry, write_access);&#x2F;&#x2F; Dirty是0。swap_page
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在情况<code>1</code>下，当页从未被访问或页线性地映射磁盘文件时则调<code>do_no_page</code>；有两种方法装入所缺的页。这取决于这个页是否被映射到一个磁盘文件。该函数通过检查<code>vma</code>线性区描述符的<code>nopage</code>字段来确认。如页被映射到一个文件，<code>nopage</code>就指向一个函数，该函数把所缺的页从磁盘装入<code>RAM</code>。因此，可能的情况是：</p>
<ol>
<li><code>vma-&gt;vm_ops-&gt;nopage</code>字段不为<code>NULL</code>。此情况下，线性区连续映射磁盘文件。<code>nopage</code>指向装入页的函数。（用磁盘文件内容填充页框。）</li>
<li><code>vma-&gt;vm_ops</code>为<code>NULL</code>或<code>vma-&gt;vm_ops-&gt;nopage</code>为<code>NULL</code>。这情况下，线性区没映射磁盘文件，即它是一个匿名映射。故<code>do_no_page</code>调<code>do_anonymous_page</code>获得一个新的页框。（仅仅分配页框，不填充，或填充0）</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">if(!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage)
	return do_anonymous_page(mm, vma, page_table, pmd, write_access, address);
12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>do_anonymous_page</code>分别处理写请求，读请求</p>
<pre class="line-numbers language-none"><code class="language-none">if(write_access)
&#123;
	pte_unmap(page_table);&#x2F;&#x2F; 这里的page_table是pte_t表示一个页表项
	spin_unlock(&amp;mm-&gt;page_table_lock);
	page &#x3D; alloc_page(GFP_HIGHUSER | __GFP_ZERO);
	spin_lock(&amp;mm-&gt;page_table_lock);
	
	page_table &#x3D; pte_offset_map(pmd, addr);
	mm-&gt;rss++;
	entry &#x3D; maybe_mkwrite(pte_mkdirty(mk_pte(page, vma-&gt;vm_page_prot)), vma);
	lru_cache_add_active(page);
	SetPageReferenced(page);
	set_pte(page_table, entry);
	pte_unmap(page_table);
	
	spin_unlock(&amp;mm-&gt;page_table_lock);
	return VM_FAULT_MINOR;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>pte_unmap</code>的第一次执行释放一种临时内核映射，它映射了在调<code>handle_pte_fault</code>之前由<code>pte_offset_map</code>所建立页表项的高端内存物理地址；<code>pte_offset_map</code>和<code>pte_unmap</code>对获取和释放同一个临时内核映射。</p>
<p>临时内核映射需在调<code>alloc_page</code>之前释放，因为这个函数可能阻塞当前进程。函数递增内存描述符的<code>rss</code>字段以记录分配给进程的页框总数，相应的页表项设置为页框的物理地址；页表框被标记为既脏又可写的。<code>lru_cache_add_active</code>把新页框插入与交换相关的数据结构中。（匿名页框是可以被交换到磁盘的）</p>
<p>当处理读访问时，页的内容是无关紧要的，因为进程第一次对它访问。给进程一个填充为<code>0</code>的页要比给它一个由其他进程填充了信息的旧页更安全。<code>Linux</code>在请求调页方面做的更深入些。没必要立即给进程分配一个填充为<code>0</code>的新页框。我们可给它一个现有的称为零页的页，这样可进一步推迟页框的分配；零页在内核初始化期间被静态分配，并存放在<code>empty_zero_page</code>。因此，用零页的物理地址设置页表项。</p>
<pre class="line-numbers language-none"><code class="language-none">entry &#x3D; pte_wrprotect(mk_pte(virt_to_page(empty_zero_page), vma-&gt;vm_page_prot));
set_pte(page_table, entry);
spin_unlock(&amp;mm-&gt;page_table_lock);
return VM_FAULT_MINOR:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于这个页被标记为不可写，故如进程试图写这个页，则写时复制被激活。当且仅当此时，进程才获得一个属于自己的页并对它进行写操作。</p>
<h4 id="写时复制："><a href="#写时复制：" class="headerlink" title="写时复制："></a><strong>写时复制</strong>：</h4><p>第一代<code>Unix</code>发出<code>fork</code>系统调用时，内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程。这种行为非常耗时，它需要：</p>
<ul>
<li>为子进程的页表分配页框</li>
<li>为子进程的页分配页框</li>
<li>初始化子进程的页表</li>
<li>把父进程的页复制到子进程相应的页中</li>
</ul>
<p>现在的<code>Unix</code>内核（包括<code>Linux</code>）采用一种更有效的方法：写时复制；</p>
<p>​    <strong>父进程和子进程共享页框而不是复制页框。只要页框被共享，它们就不能被修改；无论父进程还是子进程何时试图写一个共享的页框，就产生一个异常；这时内核就把这个页复制到一个新的页框并标记为可写，原来的页框仍是写保护的；当其他进程试图写入时，内核检查写进程是否是这个页框的唯一属主。如是，就把这个页框标记为对这个进程是可写的</strong></p>
<p>​    页描述符的<code>_count</code>用于跟踪共享相应页框的进程数目，只要进程释放一个页框或在它上面执行写时复制。它的<code>_count</code>就减小，只有当<code>_count</code>变为<code>-1</code>时，这个页框才被释放。</p>
<p>我们讲述<code>Linux</code>如何实现写时复制。</p>
<p><strong>handle_pte_fault</strong>:<br>当<code>handle_pte_fault</code>确定缺页异常由访问内存中现有的一个页而引起时，它执行</p>
<pre class="line-numbers language-none"><code class="language-none">if(pte_present(entry))
&#123;
	if(write_access)
	&#123;
		if(!pte_write(entry))
			return do_wp_page(mm, vma, address, pte, pmd, entry);
		entry &#x3D; pte_mkdirty(entry);
	&#125;
	entry &#x3D; pte_mkyong(entry);
	set_pte(pte, entry);
	flush_tbl_page(vma, address);
	pte_unmap(pte);
	spin_unlock(&amp;mm-&gt;page_table_lock);
	return VM_FAULT_MINOR;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    <code>handle_pte_fault</code>与体系结构无关，它考虑任何违背页访问权限的可能。</p>
<p>在<code>80x86</code>体系结构上，如页是存在的，则访问权限是写允许的而页框是写保护的。故总是要调<code>do_wp_page</code>。<code>do_wp_page</code>先获取与缺页异常相关的页框描述符。接下来，确定页的复制是否真正必要。如仅有一个进程拥有这个页，则写时复制不必应用，进程应自由写该页。具体说，函数读取页描述符的<code>_count</code>，如它等于<code>0</code>，写时复制就不必。实际上，检查稍微复杂些，因为当页插入到交换高速缓存且设置了页描述符的<code>PG_private</code>时，<code>_count</code>也增加。不过，写时复制不进行时，就把该页框标记为可写的</p>
<pre class="line-numbers language-none"><code class="language-none">set_pte(page_table, maybe_mkwrite(pte_mkyong(pte_mkdirty(pte)), vma));
flush_tlb_page(vma, address);
pte_unmap(page_table);
spin_unlock(&amp;mm-&gt;page_table_lock);
return VM_FAULT_MINOR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如两个或多个进程通过写时复制共享页框，则函数就把旧页框的内容复制到新分配的页框。为避免竞争条件，在开始复制操作前调<code>get_page</code>把<code>old_page</code>使用计数加<code>1</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">old_page &#x3D; pte_page(pte);
pte_unmap(page_table);
get_page(old_page);
spin_unlock(&amp;mm-&gt;page_table_lock);
if(old_page &#x3D;&#x3D; virt_to_page(empty_zero_page))
	new_page &#x3D; alloc_page(GFP_HIGUUSER | __GFP_ZERO);
else
&#123;
	new_page &#x3D; alloc_page(GFP_HIGHUSER);
	vfrom &#x3D; kmap_atomic(old_page, KM_USER0);
	vto &#x3D; kmap_atomic(new_page, KM_USER1);
	copy_page(vto, vfrom);
	kunmap_atomic(vfrom, KM_USER0);
	kunmap_atomic(vto, KM_USER0)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如旧页框是零页，就在分配新的页框时（<code>__GFP_ZERO</code>）把它填充为<code>0</code>。否则，使用<code>copy_page</code>复制页框内容。因为页框的分配可能阻塞进程，故函数检查自从函数开始执行以来是否已修改了页表项。如是，新的页框被释放。<code>old_page</code>的使用计数器减少，结束。如所有事情进展顺利， 则新页框的物理地址最终被写进页表项，且相应的<code>tlb</code>寄存器无效</p>
<pre class="line-numbers language-none"><code class="language-none">spin_lock(&amp;mm-&gt;page_table_lock);
entry &#x3D; maybe_mkwrite(pte_mkdirty(mk_pte(new_page, vma-&gt;vm_page_prot)), vma);
set_pte(page_table, entry);
flush_tlb_page(vma, address);
lru_cache_add_active(new_page);
pte_unmap(page_table);
spin_unlock(&amp;mm-&gt;page_table_lock);
1234567<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>lru_cache_add_active</code>把新页框插入到与交换相关的数据结构中。最后，<code>do_wp_page</code>把<code>old_page</code>的使用计数器减少两次。第一次减少是取消复制页框内容之前进行的安全性增加，第二次的减少是反映当前进程不再拥有该页框这一事实</p>
<h4 id="处理非连续内存区访问"><a href="#处理非连续内存区访问" class="headerlink" title="处理非连续内存区访问:"></a><strong>处理非连续内存区访问</strong>:</h4><p>​    内核在更新非连续内存区对应的页表项时是非常懒惰的。事实上，<code>vmalloc</code>和<code>vfree</code>只把自己限制在更新主内核页表。一旦内核初始化阶段结束，任何进程或内核线程便都不直接使用主内核页表。因此，考虑内核态进程对非连续内存区的第一次访问，当把线性地址转换为物理地址时，<code>CPU</code>的内存管理单元遇到空的页表项并产生一个缺页。但缺页异常处理程序认识这种特殊情况，因为异常发生在内核态且产生缺页的线性地址大于<code>TASK_SIZE</code>。故<code>do_page_fault</code>检查相应的主内核页表项</p>
<pre class="line-numbers language-none"><code class="language-none">vmalloc_fault:
	asm(&quot;movl %%cr3,%0&quot;:&quot;&#x3D;r&quot;(pgd_paddr));
	pgd &#x3D; pgd_index(address) + (pgd_t*)__va(pgd_paddr);
	pgd_k &#x3D; init_mm.pgd + pgd_index(address);
	if(!pgd_present(*pgd_k))
		goto no_context;
	pud &#x3D; pud_offset(pgd, address);
	pud_k &#x3D; pud_offset(pgd_k, address);
	if(!pud_present(*pud_k))
		goto no_context;
	pmd &#x3D; pmd_offset(pud, offset);
	pmd_k &#x3D; pmd_offset(pud_k, address);
	if(!pmd_present(*pmd_k))
		goto no_context;
	set_pmd(pmd, *pmd_k);
	pte_k &#x3D; pte_offset_kernel(pmd_k, address);
	if(!pte_present(*pte_k))
		goto no_context;
	return;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    把存放在<code>cr3</code>寄存器中的当前进程页全局目录的物理地址赋给局部变量<code>pgd_paddr</code>，把与<code>pgd_paddr</code>相应的线性地址赋给局部变量<code>pgd</code>，且把主内核页全局目录的线性地址赋给<code>pgd_k</code>局部变量。如产生缺页的线性地址所对应的主内核页全局目录项为空，则函数跳到标号为<code>no_context</code>代码处。否则，函数检查与错误线性地址相对应的主内核页上级目录项和主内核页中间目录项。如它们中有一个为空，就再次跳到<code>no_contex</code>t处。否则，就把主目录项复制到进程页中间目录的相应项中。随后，对主页表项重复上述整个操作</p>
<h4 id="缺页异常主程序"><a href="#缺页异常主程序" class="headerlink" title="缺页异常主程序"></a>缺页异常主程序</h4><p>如前，Linux的缺页异常处理程序必须区分以下两种情况：<br>由编程错误所引起的异常，<br>由引用属于进程地址空间但还尚未分配物理页框的页所引起的异常。</p>
<p>线性区描述符可让缺页异常处理程序非常有效的完成它的工作。<code>do_page_fault</code>是<code>80x86</code>上的缺页异常中断服务程序，它把引起缺页的线性地址和当前进程的线性区相比较，从而能选择适当方法处理这个异常。</p>
<pre class="line-numbers language-none"><code class="language-none">if(地址属于进程的地址空间)
	if(访问类型与线性区的访问权限匹配)
		合法访问。分配一个新的页面
	else
		非法访问。发送一个SIGSEGV信号
else
	if(异常发生在用户态)
		非法访问，发送一个SIGSEGV信号
	else
		内核错误，杀死进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    实际中，情况更复杂。因为缺页处理程序必须处理多种分得更细的特殊情况，它们不宜在总体方案中列出来，还必须区分许多种合理的访问。标识符<code>vmalloc_fault</code>，<code>good_area</code>，<code>bad_area</code>和<code>no_context</code>是出现在<code>do_page_fault</code>中的标记，它们有助于你理清流程图中的块与代码中特定行之间的关系。</p>
<p><code>do_page_fault</code>接收参数：</p>
<ol>
<li><p><code>pt_regs</code>结构的地址<code>regs</code>，结构包含当异常发生时的微处理器寄存器的值</p>
</li>
<li><p>三位的<code>error_code</code>，当异常发生时由控制单元压入栈中。这些位有以下含义：</p>
<blockquote>
<ol>
<li>如第<code>0</code>位被清<code>0</code>，则异常由访问一个不存在的页引起，否则，如第<code>0</code>位被设置，则异常由无效的访问权限引起</li>
<li>如第<code>1</code>位被清<code>0</code>，则异常由读访问或执行访问所引起；如该位被设置，则异常由写访问所引起</li>
<li>如第<code>2</code>位被清<code>0</code>，则异常发生在处理器处于内核态时，否则， 异常发生在处理器处于用户态时。</li>
</ol>
</blockquote>
</li>
</ol>
<p><code>do_page_fault</code>的第一步操作是读取引起缺页的线性地址。异常发生时，<code>CPU</code>控制单元把这个值存放在cr2控制寄存器中</p>
<pre class="line-numbers language-none"><code class="language-none">asm(&quot;movl %%cr2, %0&quot;:&quot;&#x3D;r&quot;(address));
if(regs-&gt;eflags &amp; 0x00020200)
	local_irq_enable();
tsk &#x3D; current;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个线性地址保存在<code>address</code>。如缺页发生之前或<code>CPU</code>运行在虚拟<code>8086</code>模式时，打开了本地中断，则该函数还要确保本地中断打开，并把指向<code>current</code>进程描述符的指针保存在<code>tsk</code>局部变量中。</p>
<p><code>do_page_fault</code>首先检查引起缺页的线性地址是否属于第<code>4</code>个<code>GB</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">info.si_code &#x3D; SEGV_MAPERR;
if(address &gt;&#x3D; TASK_SIZE)
&#123;
	if(!(error_code &amp; 5))
		goto vmalloc_fault;
	goto bad_area_nosemaphore;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如发生了由于内核试图访问不存在的页框引起的异常，就跳转去执行<code>vmalloc_fault</code>。该部分代码处理可能由于在内核态访问非连续内存区而引起的缺页。否则，就跳转去执行<code>bad_area_nosemaphore</code>。接下来，缺页处理程序检查异常发生时是否内核正在执行一些关键例程或正在运行内核线程</p>
<pre class="line-numbers language-none"><code class="language-none">if(in_atomic() || !tsk-&gt;mm)
	goto bad_area_nosemaphore;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如缺页发生在下面任何一种情况下，则<code>in_atomic</code>产生等于<code>1</code>的值</p>
<ol>
<li>内核正在执行中断处理程序或可延迟函数</li>
<li>内核正在禁用内核抢占的情况下执行临界区代码，如缺页的确发生在中断处理程序，可延迟函数，临界区，或内核线程中。<code>do_page_fault</code>就不会试图把这个线性地址与<code>current</code>的线性区做比较。内核线程从来不使用小于<code>TASK_SIZE</code>的地址。<br>同样，中断处理程序，可延迟函数，临界区代码（这三者也在内核代码段）也不应使用小于<code>TASK_SIZE</code>的地址，因为这可能导致当前进程的阻塞。</li>
</ol>
<p>​    我们假定缺页没发生在中断处理程序，可延迟函数，临界区或内核线程中。于是，函数必须检查进程所拥有的线性区以决定引起缺页的线性地址是否包含在进程的地址空间中，为此，必须获得进程的<code>mmap_sem</code>读写信号量。</p>
<pre class="line-numbers language-none"><code class="language-none">if(!down_read_trylock(&amp;tsk-&gt;mm-&gt;mmap_sem))
&#123;
	if((error_code &amp; 4) &#x3D;&#x3D; 0 &amp;&amp; !search_exception_table(regs-&gt;eip))
		goto bad_area_nosemaphore;
	down_read(&amp;tsk-&gt;mm-&gt;mmap_sem);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如内核<code>bug</code>和硬件故障有可能被排除，则<strong>当缺页发生时，当前进程就还没为写而获得信号量<code>mmap_sem</code>。尽管如此，<code>do_page_fault</code>还是想确定的确没获得这个信号量。因为如果不是这样就会发生死锁</strong>。<br>​    所以，函数用<code>down_read_trylock</code>而不是<code>down_read</code>。如这个信号量被关闭且缺页发生在内核态，<code>do_page_fault</code>就要确定异常发生的时候，是否正使用作为系统调用参数被传递给内核的线性地址。此时，因为每个系统调用服务例程都小心地避免在访问用户态地址空间以前为写而获得<code>mmap_sem</code>信号量，故<code>do_page_fault</code>确信<code>mmap_sem</code>信号量由另外一个进程占有了，从而<code>do_page_fault</code>一直等到该信号量被释放。否则，如缺页是由于内核<code>bug</code>或严重的硬件故障引起的，就跳到<code>bad_area_nosemaphore</code>标记处。假设已为读而获得了<code>mmap_sem</code>信号量。现在，<code>do_page_fault</code>开始搜索错误线性地址所在的线性区</p>
<pre class="line-numbers language-none"><code class="language-none">vma &#x3D; find_vma(tsk-&gt;mm, address);
if(!vma)
	goto bad_area;
if(vma-&gt;vm_start &lt;&#x3D; address)
	goto good_area;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如<code>vma</code>为<code>NULL</code>，说明<code>address</code>之后没线性区，因此这个错误的地址肯定是无效的，另一方面，如在<code>address</code>之后结束的第一个线性区包含<code>address</code>，则函数跳到标记为<code>good_area</code>的代码处。</p>
<p>如两个<code>if</code>都不满足，函数已确定<code>address</code>没包含在任何线性区中。可它还必须执行进一步的检查，由于这个错误地址可能是由<code>push</code>或<code>pusha</code>指令在进程的用户态堆栈上的操作所引起的。解释下栈如何映射到线性区上的。<br>每个向低地址扩展的栈所在的区，它的<code>VM_GROWSDOWN</code>标志被设置，这样，当<code>vm_start</code>字段的值可能被减小的时候，而<code>vm_end</code>保持不变。这种线性区的边界包括，但不严格限定用户态堆栈当前的大小。这种细微差别主要基于：</p>
<ol>
<li>线性区的大小是4KB的倍数，栈的大小是任意的</li>
<li>分配给一个线性区的页框在这个线性区被删除前永远不被释放。尤其是，一个栈所在线性区的<code>vm_start</code>字段的值只能减少，永远不能增加。甚至进程执行一系列<code>pop</code>指令时，这个线性区的大小仍保持不变</li>
</ol>
<p>​    当进程填满分配给它的堆栈的最后一个页框后，进程如何引起一个”缺页”异常。push引用了这个线性区以外的一个地址（即引用一个不存在的页框）。这种异常不是由程序错误引起， 它必须由缺页处理程序单独处理</p>
<pre class="line-numbers language-none"><code class="language-none">if(!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))
	goto bad_area;
if(error_code &amp; 4 &amp;&amp; address + 32 &lt; regs-&gt;esp)
	goto bad_area;
if(expand_stack(vma, address))
	goto bad_area;
goto good_area;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如线性区的VM_GROWSDOWN被设置，且异常发生在用户态，函数就检查address是否小于regs-&gt;esp栈指针。几个与栈相关的汇编语言指令只有在访问内存之后才执行减esp寄存器的操作，所以允许进程有32字节的后备区间。如这个地址足够高，则代码调expand_stack函数检查是否允许进程既扩展它的栈也扩展它的地址空间。如一切都可以，就把vma的vm_start设为address，且返回0。否则，返回-ENOMEM</p>
<p>​    只要线性区的VM_GROWSDOWN标志被设置，但异常不是发生在用户态，上述代码就跳过容错检查。这些条件意味着内核正访问用户态的栈，意味着这段代码总是应运行expand_stack–缺页异常能看懂每处处理，但整理的显得杂乱。应该由自己结合源码进行更好的整理输出。</p>
<h3 id="创建和删除进程的地址空间"><a href="#创建和删除进程的地址空间" class="headerlink" title="创建和删除进程的地址空间"></a>创建和删除进程的地址空间</h3><h4 id="1-创建进程的地址空间"><a href="#1-创建进程的地址空间" class="headerlink" title="1.创建进程的地址空间"></a>1.创建进程的地址空间</h4><p>​    之前的<code>clone</code>，<code>fork</code>，<code>vfork</code>已经提到，当创建一个新的进程时内核调<code>copy_mm</code>，这个函数通过建立新进程的所有页表和内存描述符来创建进程的地址空间。通常，每个进程有自己的地址空间，但轻量级进程可通过调<code>clone</code>来创建。这些轻量级进程共享同一地址空间，即允许它们对同一组页进行寻址。</p>
<p>​    按前面写时复制，传统的进程继承父进程的地址空间，只要页是只读的，就依然共享它们，当其中一个进程试图对某个页写时，这个页就被复制一份。一段时间后，所创建的进程通常获得与父进程不一样的完全属于自己的地址空间。    </p>
<p>​    轻量级进程使用父进程的地址空间，<code>Linux</code>实现轻量级进程很简单，即不复制父进程地址空间，创建轻量级进程比创建普通进程相应快的多，且只要父进程和子进程谨慎地协调它们的访问，就认为页的共享是有益的。如通过<code>clone</code>已经创建了新进程且<code>flag</code>参数的<code>CLONE_VM</code>被设置，则<code>copy_mm</code>把父进程地址空间给子进程</p>
<pre class="line-numbers language-none"><code class="language-none">if(clone_flags &amp; CLONE_VM)
&#123;
	atomic_inc(&amp;current-&gt;mm-&gt;mm_users);
	spin_unlock_wait(&amp;current-&gt;mm-&gt;page_table_lock);
	tsk-&gt;mm &#x3D; current-&gt;mm;
	tsk-&gt;active_mm &#x3D; current-&gt;mm;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如其他<code>CPU</code>持有进程页表自旋锁，就调<code>spin_unlock_wait</code>保证在释放锁前，缺页处理程序不会结束。</p>
<p>​    实际上，这个自旋锁除了保护页表外，还需禁止创建新的轻量级进程，因为它共享<code>current-&gt;mm</code>描述符。</p>
<p>​    如没设置<code>CLONE_VM</code>，<code>copy_mm</code>就需创建一个新的地址空间，这个函数分配一个新的内存描述符，把它的地址存放在新进程描述符<code>tsk</code>的<code>mm</code>中，并把<code>current-&gt;mm</code>的内容复制到<code>tsk-&gt;mm</code>。然后，改变新进程描述符的一些字段</p>
<pre class="line-numbers language-none"><code class="language-none">tsk-&gt;mm &#x3D; kmem_cache_alloc(mm_cachep, SLAB_KERNEL);
memcpy(tsk-&gt;mm, current-&gt;mm, sizeof(*tsk-&gt;mm));
atomic_set(&amp;tsk-&gt;mm-&gt;mm_users, 1);
atomic_set(&amp;tsk-&gt;mm-&gt;mm_count, 1);
init_rwsem(&amp;tsk-&gt;mm-&gt;mmap_sem);
tsk-&gt;mm-&gt;core_waiters &#x3D; 0;
tsk-&gt;mm-&gt;page_table_lock &#x3D; SPIN_LOCK_UNLOCKED;
tsk-&gt;mm-&gt;ioctx_list_lock &#x3D; RW_LOCK_UNLOCKED;
tsk-&gt;mm-&gt;ioctx_list &#x3D; NULL;
tsk-&gt;mm-&gt;default_kioctx &#x3D; INIT_KIOCTX(tsk-&gt;mm-&gt;default_kioctx, *tsk-&gt;mm);
tsk-&gt;mm-&gt;free_area_cache &#x3D; (TASK_SIZE&#x2F;3 + 0xfff) &amp; 0xfffff000;
tsk-&gt;mm-&gt;pgd &#x3D; pgd_alloc(tsk-&gt;mm);
tsk-&gt;mm-&gt;def_flags &#x3D; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    <code>pgd_alloc</code>为新进程分配页全局目录。然后，调依赖于体系结构的<code>init_new_context</code>。对<code>80x86</code>，函数检查当前进程是否拥有定制的局部描述符表。如是，<code>init_new_context</code>复制一份<code>current</code>的局部描述符表并把它插入<code>tsk</code>的地址空间。最后，调<code>dup_mmap</code>既复制父进程的线性区，也复制父进程的页。<code>dup_mmap</code>把新内存描述符<code>tsk-&gt;mm</code>插入到内存描述符的全局链表中。然后，从<code>current-&gt;mm-&gt;mmap</code>所指向的线性区开始扫描父进程的线性区链表。它复制遇到的每个<code>vm_area_struc</code>t线性区描述符，把复制品插入到子进程的线性区链表和红-黑树</p>
<p>​    在插入一个新的线性区描述符后，如需要，<code>dup_mmap</code>立即调<code>copy_area_range</code>创建必要的页表来映射这个线性区所包含的一组页且初始化新页表的表项，尤其是，与私有的，可写的页（<code>VM_SHARED</code>关闭，<code>VM_MAYWRITE</code>打开）所对应的任一页框都标记为对父子进程是只读的，以便这种页框能用写时复制机制进行处理。</p>
<h4 id="2-删除进程的地址空间"><a href="#2-删除进程的地址空间" class="headerlink" title="2.删除进程的地址空间"></a>2.删除进程的地址空间</h4><p>进程结束时，调<code>exit_mm</code>释放进程的地址空间</p>
<pre class="line-numbers language-none"><code class="language-none">mm_release(tsk, tsk-&gt;mm);
if(!(mm !&#x3D; tsk-&gt;mm))
	return;
down_read(&amp;mm-&gt;mmap_sem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    <code>mm_release</code>唤醒在<code>tsk-&gt;vfork_done</code>补充原语上睡眠的任一进程。典型地，只当现有进程通过<code>vfork</code>被创建时，相应的等待队列才为非空，如正被终止的进程不是内核线程，<code>exit_mm</code>就需释放内存描述符和所有相关的数据结构。首先，它检查<code>mm-&gt;core_waiters</code>是否被置位。如是，进程把内存的所有内存转储到一个转储文件。为避免转储文件混乱，用<code>mm-&gt;core_done</code>和<code>mm-&gt;core_startup_done</code>补充原语使共享同一个内存描述符<code>mm</code>的轻量级进程的执行串行化。</p>
<p>​    函数递增内存描述符的主使用计数器，重新设置进程描述符的<code>mm</code>，使处理器处于懒惰<code>TLB</code>模式</p>
<pre class="line-numbers language-none"><code class="language-none">atomic_inc(&amp;mm-&gt;mm_count);
spin_lock(tsk-&gt;alloc_lock);
tsk-&gt;mm &#x3D; NULL;
up_read(&amp;mm-&gt;map_sem);
enter_lazy_tlb(mm, current);
spin_unlock(tsk-&gt;alloc_lock);
mmput(mm);
1234567<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    最后，调<code>mmput</code>释放局部描述符表，线性区描述符，页表。因为，<code>exit_mm</code>已经递增了主使用计数器，所以并不释放内存描述符本身。当要把正在被终止的进程从本地<code>CPU</code>撤销时，将由<code>finish_task_switch</code>释放内存描述符</p>
<h3 id="堆的管理"><a href="#堆的管理" class="headerlink" title="堆的管理"></a>堆的管理</h3><p>每个<code>Unix</code>进程都有一个特殊的线性区，这个线性区就是堆，堆用于满足进程的动态内存请求。内存描述符的<code>start_brk</code>和<code>brk</code>分别限定了这个区的开始地址，结束地址。</p>
<p>进程可用下面API来请求和释放动态内存：<br><code>malloc(size)</code>，分配成功时，返回所分配内存单元第一个字节的线性地址<br><code>calloc(n, size)</code>，请求含<code>n</code>个大小为<code>size</code>的元素的一个数组。分配成功时，数组元素初始化为<code>0</code>，返回首个元素线性地址<br><code>realloc(pte, size)</code>，分配新线性区域，将pte老区域内容拷贝到新区域起始部分<br><code>free(addr)</code>，释放由<code>malloc</code>或<code>calloc</code>分配的起始地址为<code>addr</code>的线性区<br><code>brk(addr)</code>，直接修改堆的大小，<code>addr</code>指定<code>current-&gt;mm-&gt;brk</code>新值，返回值是线性区新的结束地址<br><code>sbrk(incr)</code>，incr指定是增加还是减少以字节为单位的堆大小</p>
<p><code>brk</code>是唯一以系统调用的方式实现的函数。<br>其他所有函数都是使用<code>brk</code>和<code>mmap</code>系统调用实现的<code>c</code>语言库函数。<br>用户态进程调<code>brk</code>时，内核执行<code>sys_brk(addr)</code>。<br>函数先验证<code>addr</code>参数是否位于进程代码所在的线性区，如是，立即返回。因为堆不能与进程代码所在的线性区重叠。</p>
<pre class="line-numbers language-none"><code class="language-none">mm &#x3D; current-&gt;mm;
down_write(&amp;mm-&gt;mmap_sem);
if(addr &lt; mm-&gt;end_code)
&#123;
out:
	up_write(&amp;mm-&gt;mmap_sem);
	return mm-&gt;brk;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于<code>brk</code>系统调用作用于某一个线性区，它分配和释放完整的页；<br>故函数把<code>addr</code>值调整为<code>PAGE_SIZE</code>的倍数。然后，把调整的结果与内存描述符的<code>brk</code>字段值比较：</p>
<pre class="line-numbers language-none"><code class="language-none">newbrk &#x3D; (addr + 0xfff) &amp; 0xfffff000;
oldbrk &#x3D; (mm-&gt;brk + 0xfff) &amp; 0xfffff000;
if(oldbrk &#x3D;&#x3D; newbrk)
&#123;
	mm-&gt;brk &#x3D; addr;
	goto out;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如进程请求缩小堆，则<code>sys_brk</code>调<code>do_munmap</code>完成这项任务，然后返回</p>
<pre class="line-numbers language-none"><code class="language-none">if(addr &lt;&#x3D; mm-&gt;brk)
&#123;
	if(!do_munmap(mm, newbrk, oldbrk-newbrk))&#x2F;&#x2F; 撤销内存映射允许在大的映射内撤销局部
		mm-&gt;brk &#x3D; addr;
	goto out;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如进程请求扩大堆，则<code>sys_brk</code>先检查是否允许进程这样做。<br>如进程企图分配在其限制范围外的内存，函数并不多分配内存，只简单返回<code>mm-&gt;brk</code>原有值</p>
<pre class="line-numbers language-none"><code class="language-none">rlim &#x3D; current-&gt;signal-&gt;rlim[RLIMIT_DATA].rlim_cur;
if(rlim &lt; RLIM_INFINITY &amp;&amp; addr - mm-&gt;start_data &gt; rlim)
	goto out;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>函数检查扩大后的堆是否和进程的其他线性区重叠。如是，不做任何事情就返回</p>
<pre class="line-numbers language-none"><code class="language-none">if(find_vma_intersection(mm, oldbrk, newbrk + PAGE_SIZE))
	goto out;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如一切都顺序，则调<code>do_brk</code>，如它返回<code>oldbrk</code>，则分配成功且<code>sys_brk</code>返回<code>addr</code>的值。否则，返回旧的<code>mm-&gt;brk</code>值</p>
<pre class="line-numbers language-none"><code class="language-none">if(do_brk(oldbrk, newbrk-oldbrk) &#x3D;&#x3D; oldbrk)&#x2F;&#x2F; 执行扩展现有映射区域。在现有线性区随后，再次申请线性区。并触发合并。
	mm-&gt;brk &#x3D; addr;
goto out;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>do_brk</code>实际上仅处理匿名线性区的<code>do_mmap</code>的简化版。可认为它的调用等价于</p>
<pre class="line-numbers language-none"><code class="language-none">do_mmap(NULL, oldbrk, newbrk-oldbrk, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_PRIVATE, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>do_brk</code>比<code>do_mmap</code>稍快，因为前者假定线性区不映射磁盘上的文件，从而避免了检查线性区对象的几个字段</p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>​    欸！回想起来我们用户层是如何与内核层进行交流的呢？或者说是如何请求服务的呢？那正是使用系统调用这个概念！使得用户层同下方的内核层架起交流的大桥！</p>
<p>​    回顾一下优点：</p>
<ul>
<li>使得编程更加容易，把用户从学习硬件设备的低级编程特性中解放出来．（你真的不需要看手册写程序！）</li>
<li>极大提高了系统的安全性，内核在试图满足某个请求前在接口级就可检查这种请求的正确性．</li>
<li>接口使得程序更具有可移植性．接口使得程序更具有可移植性．</li>
</ul>
<p><code>Unix</code>系统通过向内核发出系统调用实现了用户态进程和硬件设备间的大部分接口．</p>
<h3 id="POSIX-API和系统调用"><a href="#POSIX-API和系统调用" class="headerlink" title="POSIX API和系统调用"></a>POSIX API和系统调用</h3><blockquote>
<p><code>API</code>：一个函数定义，说明了如何获得一个给定的服务．<br>系统调用：通过软中断向内核态发出一个明确的请求．</p>
</blockquote>
<p>​    <code>Unix</code>系统给程序员提供了很多<code>API</code>的库函数。<code>libc</code>的标准<code>C</code>库所定义的一些<code>API</code>引用了封装例程。通常下，每个系统调用应对应一个封装例程，而封装例程定义了应用程序使用的<code>API</code>．</p>
<p>​    一个<code>API</code>没必要对应一个特定的系统调用。</p>
<ul>
<li>首先，<code>API</code>可能直接提供用户态的服务。</li>
<li>其次，一个单独的<code>API</code>函数可能调几个系统调用。<code>Posix</code>标准针对<code>API</code>而不针对系统调用，判断一个系统是否与<code>POSIX</code>兼容要看它是否提供了一组合适的应用程序接口，而不管对应的函数是如何实现的。</li>
</ul>
<p>​    事实上，一些非<code>Unix</code>系统被认为是与<code>POSIX</code>兼容的。因为它们在用户态的库函数中提供了传统<code>Unix</code>能提供的所有服务．</p>
<p>​    从编程者观点看，<code>API</code>和系统调用间的差别没关系：唯一相关的事情就是函数名，参数类型，返回代码的含义。从内核设计者观点看，这种差别确实有关系，因为系统调用属于内核，用户态的库函数不属于内核．</p>
<p>​    大部分封装例程返回一个整数，其值的含义依赖于相应的系统调用。返回值<code>-1</code>通常表示内核不能满足进程的要求。在<code>libc</code>库中定义的<code>errno</code>变量包含特定的出错码。</p>
<h3 id="系统调用处理程序及服务例程"><a href="#系统调用处理程序及服务例程" class="headerlink" title="系统调用处理程序及服务例程"></a>系统调用处理程序及服务例程</h3><p>​    当用户态的进程调一个系统调用时，<code>CPU</code>切换到内核态并开始执行一个内核函数。在<code>80x86</code>体系结构中，可用两种不同的方式调<code>Linux</code>的系统调用。两种方式的最终结果都是跳转到所谓系统调用处理程序的汇编语言函数．</p>
<p>​    因为内核实现了很多不同的系统调用，故进程必须传递一个名为系统调用号的参数来识别所需的系统调用，<code>eax</code>寄存器就用作此目的。当调用一个系统调用时通常还要传递另外的参数．</p>
<p>​    所有的系统调用都返回一个整数值，这些返回值与封装例程返回值的约定不同，在内核中，正数或<code>0</code>表示系统调用成功结束，负数表示一个出错条件。后一种情况下，这个值就是存放在<code>errno</code>中必须返回给应用的负出错码。内核没设置或使用<code>errno</code>变量，而封装例程从系统调用返回后设置这个变量。</p>
<p>​    系统调用处理程序与其他异常处理程序结构类似，执行：</p>
<blockquote>
<ol>
<li>在内核态保存大多数寄存器的内容．</li>
<li>调名为系统调用服务例程的相应<code>C</code>函数来处理系统调用．</li>
<li>退出系统调用处理程序：用保存在内核栈中的值加载寄存器，<code>CPU</code>从内核态切换回用户态．</li>
</ol>
</blockquote>
<p><img src=".\image-20240503101639841.png" alt="image-20240503101639841"></p>
<p>​    上面这个图深切的说明了我们的架构是如何搭建的——另外，图来自《深入理解Linux内核》</p>
<p>​    为了把系统调用号与相应的服务例程关联起来，内核利用了一个系统调用分派表。这个表存放在<code>sys_call_table</code>数组，有<code>NR_syscalls</code>个表项，第<code>n</code>个表项包含系统调用号为<code>n</code>的服务例程的地址。<code>NR_syscalls</code>只是对可实现的系统调用最大个数的静态限制，并不表示实际已实现的系统调用个数。实际上，分派表中的任意一个表项也可包含<code>sys_ni_syscall</code>函数的地址。这个函数是<code>&quot;未实现&quot;</code>系统调用的服务例程，它仅仅返回出错码<code>-ENOSYS</code>．</p>
<h3 id="进入和退出系统调用"><a href="#进入和退出系统调用" class="headerlink" title="进入和退出系统调用"></a>进入和退出系统调用</h3><p>本地应用可通过两种不同方式调系统调用：</p>
<blockquote>
<ol>
<li>执行<code>int $0x80</code>，在<code>Linux</code>内核老版本，这是从用户态切换到内核态的唯一方式。<code>(手写过OS的都知道)</code></li>
<li>执行<code>sysenter</code>，在<code>Intel Pentium 2</code>中引入了这条指令，<code>Linux 2.6</code>内核支持此指令。</li>
</ol>
</blockquote>
<p>同样，内核可通过两种方式从系统调用退出，从而使<code>CPU</code>切换回用户态</p>
<blockquote>
<ol>
<li>执行<code>iret</code></li>
<li>执行<code>sysexit</code></li>
</ol>
</blockquote>
<p>但支持进入内核的两种不同方式不像看起来那么简单：</p>
<blockquote>
<ul>
<li>内核必须既支持只使用<code>int $0x80;</code>也支持<code>sysenter</code>．</li>
<li>使用<code>sysenter</code>的标准库必须能处理仅支持<code>int $0x80</code>的旧内核．</li>
<li>内核和标准库必须既能运行在不包含<code>sysenter</code>指令的旧处理器上；也能运行在包含它的新处理器上．</li>
</ul>
</blockquote>
<h2 id="通过int-0x80发出系统调用"><a href="#通过int-0x80发出系统调用" class="headerlink" title="通过int $0x80发出系统调用"></a>通过int $0x80发出系统调用</h2><p>中断向量<code>128</code>对应于内核入口点，在内核初始化期间调的函数<code>trap_init</code>用下面的方式建立对应于向量<code>128</code>的中断描述符表项：</p>
<pre class="line-numbers language-none"><code class="language-none">set_system_gate(0x80, &amp;system_call);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该调用把下列值存入这个门描述符的相应字段</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Segment Selector</code></td>
<td>内核代码段<code>__KERNEL_CS</code>的段选择符．</td>
</tr>
<tr>
<td><code>Offset</code></td>
<td>指向<code>system_call</code>系统调用处理程序的指针．</td>
</tr>
<tr>
<td><code>Type</code></td>
<td><code>15</code>，表示这个异常是一个陷阱。相应的处理程序不禁止可屏蔽中断．</td>
</tr>
<tr>
<td><code>DPL</code></td>
<td><code>3</code>，允许用户态进程调这个异常处理程序．</td>
</tr>
</tbody>
</table>
</div>
<p>​    当用户态进程发出<code>int $0x80</code>时，<code>CPU</code>切换到内核态并开始从地址<code>system_call</code>处开始执行指令．</p>
<h3 id="system-call"><a href="#system-call" class="headerlink" title="system_call"></a>system_call</h3><p>​    首先把系统调用号和这个异常处理程序可用到的所有<code>CPU</code>寄存器保存到相应栈，不包含由控制单元已自动保存的<code>eflags，cs，eip，ss</code>和<code>esp</code>。在第<code>4</code>章已经讨论的<code>SAVE_ALL</code>，也在<code>ds</code>和<code>es</code>中装入内核数据段的段选择符．</p>
<pre class="line-numbers language-none"><code class="language-none">system_call:
	pushl %eax
	SAVE_ALL
	movl $0xffffe000, %ebx
	andl %esp, %ebx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    随后，这个函数在<code>ebx</code>中存放当前进程的<code>thread_info</code>的地址。这是通过获得内核栈指针的值并把它取整到<code>4KB</code>或<code>8KB</code>的倍数而完成的</p>
<p>​    接下来，<code>system_call</code>检查<code>thread_info</code>结构<code>flag</code>字段的<code>TIF_SYSCALL_TRACE</code>和<code>TIF_SYSCALL_AUDIT</code>之一是否被设置为<code>1</code>，即检查是否有某一调试程序正在跟踪执行程序对系统调用的调用。如是，则<code>system_call</code>两次调<code>do_syscall_trace</code>：一次正好在这个系统调用服务例程执行前，一次在其之后，这个函数停止<code>current</code>，并因此允许调试进程收集关于<code>current</code>的信息。然后， 对用户进程传递来的系统调用号进行有效性检查。如这个号大于或等于系统调用分派表中的表项数，系统调用处理程序就终止</p>
<pre class="line-numbers language-none"><code class="language-none">	cmpl $NR_syscalls, %eax
	jb nobadsys
	movl $(-ENOSYS), 24(%esp)
	jmp resume_userspace
nobadsys:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    如系统调用号无效，该函数就把<code>-ENOSYS</code>值存放在栈中曾保存<code>eax</code>寄存器的单元中（从当前栈顶开始偏移量为<code>24</code>的单元），然后跳到<code>resume_userspace</code>。这样，当进程恢复它在用户态的执行时，会在<code>eax</code>中发现一个负的返回码。最后，调与<code>eax</code>中所包含的系统调用号对应的特定服务例程．</p>
<pre class="line-numbers language-none"><code class="language-none">call *sys_call_table(0, %eax, 4)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    因为分派表中的每个表项占<code>4</code>个字节，故首先把系统调用号乘以<code>4</code>，再加上<code>sys_call_table</code>分派表的起始地址。然后从这个地址单元获取指向服务例程的指针，内核就找到了要调用的服务例程．</p>
<h3 id="从系统调用退出"><a href="#从系统调用退出" class="headerlink" title="从系统调用退出"></a>从系统调用退出</h3><p>当系统调用服务例程结束时，<code>system_call</code>从<code>eax</code>获得它的返回值，把这个返回值存放在曾保存用户态<code>eax</code>寄存器值的那个栈单元的位置上．</p>
<pre class="line-numbers language-none"><code class="language-none">movl %eax, 24(%esp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    故用户态进程将在<code>eax</code>中找到系统调用的返回码。然后，<code>system_call</code>关闭本地中断并检查当前进程的<code>thread_info</code>结构中的标志．</p>
<pre class="line-numbers language-none"><code class="language-none">cli
movl 8(%ebp), %ecx
testw $0xffff, %cx
je restore_all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    <code>flags</code>字段在<code>thread_info</code>结构中的偏移量为<code>8</code>，所有标志都没设置，函数就跳到<code>restore_all</code>。<code>restore_all</code>恢复保存在内核栈中的寄存器的值，并执行<code>iret</code>以重新开始执行用户态进程．</p>
<p>​    只要任何一种标志被设置，则就要在返回用户态之前完成一些工作。如<code>TIF_SYSCALL_TRACE</code>被设置，<code>system_call</code>就第二次调<code>do_syscall_trace</code>，然后跳到<code>resume_userspace</code>；否则，如<code>TIF_SYSCALL_TRACE</code>没被设置，就跳到<code>work_pending</code>。在<code>resume_userspace</code>和<code>work_pending</code>处的代码检查重新调度请求，虚拟<code>8086</code>模式，挂起信号，单步执行，最终跳到<code>restore_all</code>处以恢复用户态进程的运行．</p>
<h2 id="通过sysenter发出系统调用"><a href="#通过sysenter发出系统调用" class="headerlink" title="通过sysenter发出系统调用"></a>通过sysenter发出系统调用</h2><p><code>int</code>由于要执行几个一致性检查和安全性检查，故速度慢。在<code>Intel</code>文档中被称为”快速系统调用”的<code>sysenter</code>指令，提供了一种从用户态到内核态的快速切换方法．</p>
<h3 id="sysenter"><a href="#sysenter" class="headerlink" title="sysenter"></a>sysenter</h3><p>使用三种特殊的寄存器，它们需装入以下信息</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SYSENTER_CS_MSR</code></td>
<td>内核代码段的段选择符．</td>
</tr>
<tr>
<td><code>SYSENTER_EIP_MSR</code></td>
<td>内核入口点的线性地址．</td>
</tr>
<tr>
<td><code>SYSENTER_ESP_MSR</code></td>
<td>内核堆栈指针．</td>
</tr>
</tbody>
</table>
</div>
<p>执行<code>sysenter</code>指令时，<code>CPU</code>控制单元：</p>
<ol>
<li>把<code>SYSENTER_CS_MSR</code>内容拷贝到<code>cs</code>．</li>
<li>把<code>SYSENTER_EIP_MSR</code>内容拷贝到<code>eip</code>．</li>
<li>把<code>SYSENTER_ESP_MSR</code>内容拷贝到<code>esp</code>．</li>
<li>把<code>SYSENTER_CS_MSR</code>加<code>8</code>值装入<code>ss</code>．</li>
</ol>
<p>故<code>CPU</code>切换到内核态并开始执行内核入口点的第一条指令．</p>
<p>在内核初始化期间，一旦系统中的每个<code>CPU</code>执行<code>enable_sep_cpu</code>，三个特定于模型的寄存器就由该函数初始化。<br><code>enable_sep_cpu</code>执行：</p>
<ol>
<li>把内核代码<code>__KERNEL_CS</code>的段选择符写入<code>SYSENTER_CS_MSR</code>．</li>
<li>把下面要说明的函数<code>sysenter_entry</code>的线性地址写入<code>SYSENTER_CS_EIP</code>．</li>
<li>计算本地<code>TSS</code>末端的线性地址，把这个值写入<code>SYSENTER_CS_ESP</code>，对<code>SYSENTER_CS_ESP</code>的设置有必要进行一些说明。</li>
</ol>
<p>​    系统调用开始的时候，内核堆栈是空的。故<code>esp</code>寄存器应指向<code>4KB</code>或<code>8KB</code>内存区域的末端。该内存区域包括内核堆栈和当前进程的描述符，因为用户态的封装例程不知这个内存区域的地址，所以它不能正确设置此寄存器。另一方面，必须在切换到内核态前设置该寄存器的值。故内核初始化这个寄存器以便为本地<code>CPU</code>的任务状态段编址。</p>
<p>​    每次进程切换时，内核把当前进程的内核栈指针保存到本地<code>TSS</code>的<code>esp0</code>。这样，系统调用处理程序读<code>esp</code>，计算本地<code>TSS</code>的<code>esp0</code>，把正确的内核堆栈指针装入<code>esp</code>．</p>
<h3 id="vsyscall页"><a href="#vsyscall页" class="headerlink" title="vsyscall页"></a>vsyscall页</h3><p>只要<code>CPU</code>和<code>Linux</code>都支持<code>sysenter</code>，标准库<code>libc</code>中的封装函数就可使用。这个兼容性问题需要复杂的解决方案。本质上，初始化阶段<code>sysenter_setup</code>建立一个称为<code>vsyscall</code>页的页框。其中包括一个小的<code>EFL</code>共享对象（一个小的<code>EFL</code>动态链接库），当进程发出<code>execve</code>开始执行一个<code>ELF</code>程序时，<code>vsyscall</code>页中的代码会自动被链接到进程的地址空间，<code>vsyscall</code>页中的代码使用最有用的指令发出系统调用．</p>
<p><code>sysenter_setup</code>为<code>vsyscall</code>页分配一个新页框，把它的物理地址与<code>FIX_VSYSCALL</code>固定映射的线性地址相关联。函数<code>sysenter_setup</code>把预先定义好的一个或两个<code>EFL</code>共享对象拷贝到该页．<br>如<code>CPU</code>不支持<code>sysenter</code>，<code>sysenter_setup</code>建立一个包含下列代码的<code>vsyscall</code>页</p>
<pre class="line-numbers language-none"><code class="language-none">__kernel_vsyscall:
	int $0x80
	ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>否则，如<code>CPU</code>的确支持<code>sysenter</code>，<code>sysenter_setup</code>建立一个包括下列代码的<code>vsyscall</code>页</p>
<pre class="line-numbers language-none"><code class="language-none">__kernel_vsyscall:
	pushl %ecx
	pushl %edx
	pushl %ebp
	movl %esp, %ebp
	sysenter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当标准库中的封装例程必须调系统调用时，调<code>__kernel_vsyscall</code>，不管它的实现代码是什么，最后一个兼容问题是由于老版本<code>Linux</code>内核不支持<code>sysenter</code>。此情况下，内核当然不建立<code>vsyscall</code>页，且函数<code>__kernel_vsyscall</code>不会被链接到用户态进程的地址空间，当新近的标准库识别这种状况后，简单执行<code>int $0x80调</code>系统调用</p>
<h3 id="进入系统调用"><a href="#进入系统调用" class="headerlink" title="进入系统调用"></a>进入系统调用</h3><p>当用<code>sysenter</code>发出系统调用时，依次执行下述：</p>
<ol>
<li><p>标准库的封装例程把系统调用号装入<code>eax</code>寄存器调<code>__kernel_vsyscall</code></p>
</li>
<li><p><code>__kernel_vsyscall</code>把<code>ebp，edx，ecx</code>的内容保存到用户态堆栈（系统调用处理程序将使用这些寄存器），把用户栈指针拷贝到<code>ebp</code>，执行<code>sysenter</code></p>
</li>
<li><p><code>CPU</code>从用户态切换到内核态，内核开始执行<code>sysenter_entry</code>（由<code>SYSENTER_EIP_MSR</code>指向）</p>
</li>
<li><p><code>sysenter_enter</code>执行下述：</p>
<blockquote>
<ol>
<li><p>建立内核堆栈指针，<code>movl -508(%esp), %esp</code>，开始时，<code>esp</code>寄存器指向本地<code>TSS</code>的第一个位置，本地<code>TSS</code>的大小为<code>512</code>字节。故<code>sysenter</code>把本地<code>TSS</code>中偏移量为<code>4</code>处的字段的内容（<code>esp0</code>）装入<code>esp</code>。<code>esp0</code>总是存放当前进程的内核堆栈指针</p>
</li>
<li><p>打开本地中断，<code>sti</code>。</p>
</li>
<li><p>把用户数据段的段选择符，当前用户栈指针，<code>eflags</code>，用户代码段的段选择符及从系统调用退出时要执行的指令的地址保存到内核堆栈</p>
<pre class="line-numbers language-none"><code class="language-none">pushl $(__USER_DS)
pushl %ebp
pushfl
pushl $(__USER_CS)
pushl $SYSENTER_RETURN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这些指令仿效<code>int</code>所执行的一些操作</p>
</li>
<li><p>把原来由封装例程传递的寄存器的值恢复到<code>ebp</code>，<code>movl (%ebp), %ebp</code>，上面这指令完成恢复工作，因为<code>__kernel_vsyscall</code>把<code>ebp</code>原始值存入用户态堆栈，在随后把用户堆栈指针的当前值装入<code>ebp</code></p>
</li>
<li><p>通过执行一系列指令调用系统调用处理程序，这些指令与前面通过<code>int $0x80</code>指令发出系统调用。一节描述的在<code>system_call</code>处开始的指令是一样的</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="退出系统调用"><a href="#退出系统调用" class="headerlink" title="退出系统调用"></a>退出系统调用</h2><p>​    系统调用服务例程结束时，<code>sysenter_entry</code>本质上执行与<code>system_call</code>相同的操作<br>首先，它从<code>eax</code>获得系统调用服务例程的返回码，将返回码存入内核栈中保存用户态<code>eax</code>寄存器值的位置。然后，函数禁止本地中断，检查<code>current</code>的<code>thread_info</code>结构中的标志</p>
<p>​    如有任何标志被设置，则在返回到用户态前需完成一些工作，为避免代码复制，函数跳到<code>resume_userspace</code>或<code>work_pending</code>处。最后，汇编语言指令<code>iret</code>从内核堆栈中取五个参数，这样<code>CPU</code>切换到用户态并开始执行<code>SYSENTER_RETURN</code>标记处代码</p>
<p>如<code>sysenter_entry</code>确定标志被清<code>0</code>，它就快速返回到用户态</p>
<pre class="line-numbers language-none"><code class="language-none">movl 40(%esp), %edx
movl 52(%esp), %ecx
xorl %ebp, %ebp
sti
sysexit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把在上一节由<code>sysenter_entry</code>函数在第<code>4c</code>步保存的一对堆栈值加载到<code>edx</code>和<code>ecx</code>，<code>edx</code>获得<code>SYSENTER_RETURN</code>标记处地址，而<code>ecx</code>获得当前用户数据栈的指针</p>
<h3 id="sysexit"><a href="#sysexit" class="headerlink" title="sysexit"></a>sysexit</h3><p><code>sysexit</code>是与<code>sysenter</code>配对的指令，它允许从内核态快速切换到用户态，执行此指令时，<code>CPU</code>控制单元执行下述：</p>
<ol>
<li>把<code>SYSENTER_CS_MSR</code>的值加<code>16</code>结果加载到<code>cs</code></li>
<li>把<code>edx</code>寄存器的内容拷贝到<code>eip</code></li>
<li>把<code>SYSENTER_CS_MSR</code>中的值加<code>24</code>得到的结果加载到<code>ss</code></li>
<li>把<code>ecx</code>的内容拷贝到<code>esp</code>，因为<code>SYSENTER_CS_MSR</code>加载的是内核代码的选择符，<code>cs</code>加载的是用户代码的选择符，<code>ss</code>加载的用户数据段的选择符。结果，<code>CPU</code>从内核态切换到用户态，开始执行其地址存放在<code>edx</code>中的那条指令</li>
</ol>
<h3 id="SYSENTER-RETURN"><a href="#SYSENTER-RETURN" class="headerlink" title="SYSENTER_RETURN"></a>SYSENTER_RETURN</h3><p>存放在<code>vsyscall</code>页，当通过<code>sysenter</code>进入的系统调用被<code>iret</code>或<code>sysexit</code>终止时，该页框中的代码被执行。该代码恢复保存在用户态堆栈中的<code>ebp,edx,ecx</code>寄存器的原始内容，并把控制权返回给标准库中的封装例程</p>
<pre class="line-numbers language-none"><code class="language-none">SYSENTER_RETURN:
	popl %ebp
	popl %edx
	popl %ecx
	ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>​    系统调用通常也许输入/输出参数，这些参数可能是实际的值。也可能是用户态进程地址空间的变量，甚至是指向用户态函数的指针的数据结构地址，因为<code>system_call</code>和<code>sysenter_entry</code>是<code>Linux</code>中所有系统调用的公共入口点。故每个系统调用至少有一个参数，即通过<code>eax</code>寄存器传递来的系统调用号。如，如一个应用程序调<code>fork</code>，则在执行<code>int $0x80</code>或<code>sysenter</code>之前就把<code>eax</code>置为<code>2</code>。因为这个寄存器的值由<code>libc</code>中的封装例程进行，故程序员通常不关系系统调用号。<code>fork</code>系统调用并不需其他的参数。不过，很多系统调用确实需由应用程序明确传递另外的参数，如<code>mmap</code>可能需多达<code>6</code>个额外参数。</p>
<p>​    普通<code>c</code>函数参数传递通过把参数值写入活动的程序栈，系统调用是横跨用户和内核的特殊函数。故既不能用用户态栈也不能用内核态栈。发出系统调用前，系统调用的参数被写入<code>CPU</code>寄存器。在调用系统调用服务例程前，内核再把存放在<code>CPU</code>中的参数拷贝到内核态堆栈。因为，系统调用服务例程是普通的<code>c</code>函数。</p>
<p>为何内核不直接把用户态的栈拷贝到内核态的栈？</p>
<blockquote>
<ul>
<li>同时操作两个栈比较复杂</li>
<li>寄存器的使用使系统调用处理程序的结构与其他异常处理程序的结构类似</li>
</ul>
</blockquote>
<p>然而，为了用寄存器传递参数，需满足：</p>
<ul>
<li>每个参数的长度不能超过寄存器的长度， 即<code>32</code>位</li>
<li>参数的个数不能超过<code>6</code>个（除<code>eax</code>中传递的系统调用号），因为<code>80x86</code>处理器的寄存器数量有限</li>
</ul>
<p>​    确实存在多于<code>6</code>个参数的系统调用，在此情况下，用一个单独的寄存器指向进程地址空间中这些参数值所在的一个内存区，编程者不用关心此工作区。调封装例程时，参数被自动保存在栈。封装例程将找到合适的方式把参数传递给内核，用于存放系统调用号和系统调用参数的寄存器是：</p>
<p><code>eax</code>：系统调用号，<code>ebx，ecx，edx，esi，edi，ebp</code></p>
<p>​    <code>system_call</code>和<code>sysenter_entry</code>使用<code>SAVE_ALL</code>把这些寄存器保存在内核态堆栈。故系统调用服务例程转到内核堆栈时，会找到<code>system_call</code>或<code>sysenter_entry</code>的返回地址，接着是存放在<code>ebx</code>中的参数，存放在<code>ecx</code>中的参数等。系统调用服务例程容易通过用c语言结构来引用它的参数，例</p>
<pre class="line-numbers language-none"><code class="language-none">int sys_write(unsigned int fd, const char * buf, unsigned int count)
int sys_fork(struct pt_regs regs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>服务例程的返回值必须写入<code>eax</code>寄存器中。这是在执行<code>“return n;”</code>指令时由<code>C</code>编译程序自动完成的。</p>
<h2 id="验证参数"><a href="#验证参数" class="headerlink" title="验证参数"></a>验证参数</h2><h3 id="访问进程地址空间"><a href="#访问进程地址空间" class="headerlink" title="访问进程地址空间"></a>访问进程地址空间</h3><p>​    系统调用服务例程需要非常频繁地读写进程地址空间的数据。<code>Linux</code>包含的一组宏使这种访问更加容易。我们将描述其中的两个名为<code>get_user()</code>和<code>put_user()</code>的宏。<br>​    第一个宏用来从一个地址读取<code>1、2</code>或<code>4</code>个连续字节，而第二个宏用来把这几种大小的内容写入一个地址中。这两个函数都接收两个参数，一个要传送的值<code>x</code>和一个变量<code>ptr</code>。第二变量还决定有多少个字节要传送。因此，在<code>get_user(x, ptr)</code>中，由<code>ptr</code>指向的变量大小使该函数展开为<code>__get_user_1()、__get_user_2()</code>或<code>__get_user_4()</code>汇编语言函数。让我们看一下其中一个，比如，<code>__get_user_2()</code>:</p>
<pre class="line-numbers language-none"><code class="language-none">__get_user_2:
	addl $1,%eax
	jc bad_get_user
	movl $0xffffe000, %edx &#x2F;*or xxfffff000 for 4-kb stacks *&#x2F;
	andl %esp,%edx
    cmpl 24(%edx), %eax
    jae bad_get_user
2: movzwl -1(%eax), %edx 
   	xorl %eax, %eax
	ret
bad_get_user:
	xorl %edx, %edx
	movl $-EFAULT, %eax
	ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>eax</code>寄存器包含要读取的第一个字节的地址<code>ptr</code>。前<code>6</code>个指令所执行的检查事实上与<code>access_ok()</code>宏相同，即确保要读取的两个字节的地址小于<code>4GB</code>并小于<code>current</code>进程的<code>addr_limit.seg</code>字段(这个字段位于<code>current</code>的<code>thread_info</code>结构中偏移量为<code>24</code>处，出现在<code>cmpl</code>指令的第一个操作数中)。如果这个地址有效，函数就执行<code>movzwl</code>指令，把要读的数据存到<code>edx</code>寄存器的两个低字节，而把两个高字节置为<code>0</code>，然后在<code>eax</code>中设置返回码<code>0</code>并终止。如果这个地址无效，函数清<code>edx</code>，将<code>eax</code>置为<code>-EFAULT</code>并终止。<code>put_user(x,ptr)</code>宏类似于前边讨论的<code>get_user</code>，但它把值<code>x</code>写入以地址<code>ptr</code>为起始地址的进程地址空间。</p>
<p>根据<code>x</code>的大小，它使用<code>__put_user_asm()</code>宏(大小为<code>1、2</code>或<code>4</code>字节)，或<code>__put_user_u64()</code>宏(大小为<code>8</code>字节)。这两个宏如果成功地写入了值那它们在<code>eax</code>寄存器中返回<code>0</code>，否则返回<code>-EFAULT</code>。在表<code>10-1</code>中列出了内核态下用来访问进程地址空间的另外几个函数或宏。注意，许多函数或宏的名字前缀有两个下划线(<code>__</code>)。首部没有下划线的函数或宏要用额外的时间对所请求的线性地址区间进行有效性检查，而有下划线的则会跳过检查。当内核必须重复访问进程地址空间的同一块线性区时，比较高效的办法是开始时只对该地址检查一次，以后就不用再对该进程区进行检查了。</p>
<p>​    下面是一些交互的宏：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>get_user ,__get_user</code></td>
<td>从用户空间读取一个整数</td>
</tr>
<tr>
<td><code>put_user, __put_user</code></td>
<td>给用户空间写一个整数</td>
</tr>
<tr>
<td><code>copy_from_user, __copy_from_user</code></td>
<td>从用户空间复制任意大小的块</td>
</tr>
<tr>
<td><code>copy_to_user, copy_to_user</code></td>
<td>把任意大小的块复制到用户空间</td>
</tr>
<tr>
<td><code>strncpy_from_user, __strncpy_from_user</code></td>
<td>从用户空间复制一个以空结束的字符串</td>
</tr>
<tr>
<td><code>strlen_user, __strlen_user</code></td>
<td>返回用户空间以空结束的字符串的长度</td>
</tr>
<tr>
<td><code>clear_user, __clear_user</code></td>
<td>用零填充用户空间的一个内存区域</td>
</tr>
</tbody>
</table>
</div>
<h3 id="动态地址检查：修正代码"><a href="#动态地址检查：修正代码" class="headerlink" title="动态地址检查：修正代码"></a>动态地址检查：修正代码</h3><p>我们先说明一下在内核态引起缺页异常的四种情况。这些情况必须由缺页异常处理程序来区分，因为不同情况采取的操作很不相同：</p>
<blockquote>
<ul>
<li>内核试图访问属于进程地址空间的页，但是，或者是相应的页框不存在，或者是内核试图去写一个只读页（写时复制）。在这些情况下，处理程序必须分配和初始化一个新的页框</li>
<li>内核寻址到属于其地址空间的页，但是相应的页表项还没有被初始化(参见第九章“处理非连续内存区访问”一节)。在这种情况下，内核必须在当前进程页表中适当地建立一些表项。也会分配页框。</li>
<li>某一内核函数包含编程错误，当这个函数运行时就引起异常；或者，可能由于瞬时的硬件错误引起异常。当这种情况发生时，处理程序必须执行一个内核漏洞(参见第九章的“处理地址空间以外的错误地址”一节)。</li>
<li>本章所讨论的一种情况：系统调用服务例程试图读写一个内存区，而该内存区的地址是通过系统调用参数传递来的，但却不属于进程的地址空间。</li>
</ul>
</blockquote>
<h3 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h3><p>​    把访问进程地址空间的每条内核指令的地址放到一个叫异常表(<code>exception table</code>)的结构中并不用费太多功夫。当在内核态发生缺页异常时，<code>do_page_fault()</code>处理程序检查异常表：如果表中包含产生异常的指令地址，那么这个错误就是由非法的系统调用参数引起的，否则，就是由某一更严重的<code>bug</code>引起的。</p>
<p><code>Linux</code>定义了几个异常表。主要的异常表在建立内核程序映像时由<code>C</code>编译器自动生成。它存放在内核代码段的<code>__ex_table</code>节，其起始与终止地址由<code>C</code>编译器产生的两个符号<code>__start__ex_table</code>和<code>__stop__ex_table</code>来标识。每个动态装载的内核模块(参看附录二)都包含有自己的局部异常表。这个表是在建立模块映像时由<code>C</code>编译器自动产生的，当把模块插入到运行中的内核时把这个表装入内存。每一个异常表的表项是一个<code>exception_table_entry</code>结构，它有两个字段：<br><code>insn:</code>访问进程地址空间的指令的线性地址。<br><code>fixup:</code>当存放在<code>insn</code>单元中的指令所触发的缺页异常发生时，<code>fixup</code>就是要调用的汇编语言代码的地址。</p>
<p>修正代码由几条汇编指令组成，用以解决由缺页异常所引起的问题。在后面我们将会看到，修正通常由插入的一个指令序列组成，这个指令序列强制服务例程返回一个出错码给用户态进程。这些指令通常在访问进程地址空间的同一函数或宏中定义；由<code>C</code>编译器把它们放置在内核代码段的一个叫作<code>.fixup</code>的独立部分。<code>search_exception_tables()</code>函数用来在所有异常表中查找一个指定地址：若这个地址在某一个表中，则返回指向相应<code>exception_table_entry</code>结构的指针；否则，返回<code>NULL</code>。因此，缺页处理程序<code>do_page_fault()</code>执行下列语句：</p>
<pre class="line-numbers language-none"><code class="language-none">if((fixup &#x3D; search_exception_tables(regs-&gt;eip)))&#123;
	regs-&gt;eip &#x3D; fixup-&gt;fixup;
	return 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>regs-&gt;eip</code>字段包含异常发生时保存到内核态栈<code>eip</code>寄存器中的值。如果<code>eip</code>寄存器(指令指针)中的这个值在某个异常表中，<code>do_page_fault()</code>就把所保存的值替换为<code>search_exception_tables()</code>的返回地址。然后缺页处理程序终止，被中断的程序以修正代码的执行而恢复运行。</p>
<h3 id="生成异常表和修正代码"><a href="#生成异常表和修正代码" class="headerlink" title="生成异常表和修正代码"></a>生成异常表和修正代码</h3><p><code>GNU</code>汇编程序(<code>Assembler</code>)伪指令<code>.section</code>允许程序员指定可执行文件的哪部分包含紧接着要执行的代码。可执行文件包括一个代码段，这个代码段可能又依次被划分为节。因此，下面的汇编指令在异常表中加入一个表项；<code>“a”</code>属性指定必须把这一节与内核映像的剩余部分一块加载到内存中。</p>
<pre class="line-numbers language-none"><code class="language-none">.section _ex_table, &quot;a&quot;
	.long faulty_instruction_address, fixup_code_address
.previous<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>.previous</code>伪指令强制汇编程序把紧接着的代码插入到遇到上一个<code>.section</code>伪指令时激活的节。让我们再看一下前面论及过的<code>__get_user_1()、__get_user_2()</code>和<code>__get_user_4()</code>函数。访问进程地址空间的指令用<code>1、2</code>和<code>3</code>标记。<img src=".\image-20240503102918399.png" alt="image-20240503102918399"><br>    每个异常表项由两个标号组成。第一个是一个数字标号，其前缀<code>b</code>表示标号是“向后的”；换句话说，标号出现在程序的前一行。修正代码对这三个函数是公用的，且被标记为<code>bad_get_user</code>。如果缺页异常是由标号<code>1、2</code>或<code>3</code>处的指令产生的，那么修正代码就执行。在<code>bad_get_user</code>处的修正代码给发出系统调用的进程只简单地返回一个出错码<code>-EFAULT</code>。</p>
<h3 id="内核封装例程"><a href="#内核封装例程" class="headerlink" title="内核封装例程"></a>内核封装例程</h3><p>​    尽管系统调用主要由用户态进程使用，但也可以被内核线程调用，内核线程不能使用库函数。为了简化相应封装例程的声明，<code>Linux</code>定义了<code>7</code>个从<code>_syscal10</code>到<code>_syscall6</code>的一组宏。</p>
<p>​    每个宏名字中的数字<code>0~6</code>对应着系统调用所用的参数个数(系统调用号除外)。也可以用这些宏来声明没有包含在<code>libc</code>标准库中的封装例程(例如，因为<code>Linux</code>系统调用还未受到库的支持)。然而，不能用这些宏来为超过<code>6</code>个参数(系统调用号除外)的系统调用或产生非标准返回值的系统调用定义封装例程。每个宏严格地需要<code>2+2×n</code>个参数，<code>n</code>是系统调用的参数个数。前两个参数指明系统调用的返回值类型和名字；每一对附加参数指明相应的系统调用参数的类型和名字。因此，以<code>fork()</code>系统调用为例，其封装例程可以通过如下语句产生：<code>_syscall0(int, fork)</code>。而<code>write()</code>系统调用的封装例程可以通过如下语句产生：<code>_syscall3(int, write, int, fd, const char *, buf, unsigned int, count)</code>．</p>
<pre class="line-numbers language-none"><code class="language-none">#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
type name(type1 arg1,type2 arg2,type3 arg3) \
&#123; \
long __res; \
__asm__ volatile (&quot;int $0x80&quot; \
	: &quot;&#x3D;a&quot; (__res) \
	: &quot;0&quot; (__NR_##name),&quot;b&quot; ((long)(arg1)),&quot;c&quot; ((long)(arg2)), \
		  &quot;d&quot; ((long)(arg3))); \
__syscall_return(type,__res); \
&#125;

#define __syscall_return(type, res) \
do &#123; \
	if ((unsigned long)(res) &gt;&#x3D; (unsigned long)(-(128 + 1))) &#123; \
		errno &#x3D; -(res); \
		res &#x3D; -1; \
	&#125; \
	return (type) (res); \
&#125; while (0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在后一种情况下，可以把这个宏展开成如下的代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">long</span> __res<span class="token punctuation">;</span>
    <span class="token function">__asm__</span> <span class="token punctuation">(</span><span class="token string">"int $0x80"</span> 
	<span class="token operator">:</span> <span class="token string">"=a"</span> <span class="token punctuation">(</span>__res<span class="token punctuation">)</span>
	<span class="token operator">:</span> <span class="token string">"0"</span> <span class="token punctuation">(</span>__NR_write<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"b"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"c"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		  <span class="token string">"d"</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">128</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		errno <span class="token operator">=</span> <span class="token operator">-</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
		__res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> 
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>__res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>__NR_write</code>宏来自<code>_syscal13</code>的第二个参数；它可以展开成<code>write()</code>的系统调用号。当编译前面的函数时，生成下面的汇编代码：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">write:
	pushl %eax				; ebx入栈
	movl 8(%esp), %ebx		 ;把第一个参数放入ebx
	movl 12(%esp), %ecx		;把第二个参数放入ecx
	movl 16(%esp), %edx		; 把第三个参数放入edx
	movl $4, %eax			; __NR_write放入eax中
	int $0x80				;调用系统调用
	cmpl $-125, %eax		;检查返回码
	jbe .L1					;如无出错则跳转
	negl %eax				;求EAX的补码
	moovl %%eax, errno		;将结果放入errno
	movl $-1, %eax			;把eax置为-1
.L1: pop1 %ebx				;从堆栈弹出EBX
	ret						;返回调用程序 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h5><p>​    代码段中插入了<code>.section xxx</code>这样的段定义，代码段顺序执行时，是否会接着执行<code>.section xxx</code>中的指令？不会。可以理解为<code>.section xxx</code>这样的定义会使得编译器编译可执行文件时，将<code>.section xx</code>x中的内容放在额外的节中。这样，实际的可执行文件中，<code>.section xxx</code>前面的可执行指令，和<code>.section xxx</code>中的可执行指令并不是相邻的。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xxx1
.section yyy1
<span class="token punctuation">..</span>.
.previous
.section yyy2
<span class="token punctuation">..</span>.
.previous
xxx2
<span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述指令序列，编译出的可执行文件中</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">section yy1
	<span class="token punctuation">..</span>.
	xxx1
	xxx2
	<span class="token punctuation">..</span>.
section yyy1
	<span class="token punctuation">..</span>.
section yyy2
	<span class="token punctuation">..</span>.
<span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以，<code>xxx1</code>指令执行后，接着执行的是<code>xxx2</code>代表的指令</p>
<pre class="line-numbers language-none"><code class="language-none">#define __put_user_asm(x, addr, err, itype, rtype, ltype, errret)	\
	__asm__ __volatile__(						\
		&quot;1:	mov&quot;itype&quot; %&quot;rtype&quot;1,%2\n&quot;			\
		&quot;2:\n&quot;							\
		&quot;.section .fixup,\&quot;ax\&quot;\n&quot;				\
		&quot;3:	movl %3,%0\n&quot;					\
		&quot;	jmp 2b\n&quot;					\
		&quot;.previous\n&quot;						\
		&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\
		&quot;	.align 4\n&quot;					\
		&quot;	.long 1b,3b\n&quot;					\
		&quot;.previous&quot;						\
		: &quot;&#x3D;r&quot;(err)						\
		: ltype (x), &quot;m&quot;(__m(addr)), &quot;i&quot;(errret), &quot;0&quot;(err))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="信号的作用"><a href="#信号的作用" class="headerlink" title="信号的作用"></a>信号的作用</h2><p>信号(<code>signal</code>)是很短的消息，可以被发送到一个进程或一组进程。使用信号的两个主要目的是：</p>
<ol>
<li>让进程知道已经发生了一个特定的事件。</li>
<li>强迫进程执行它自己代码中的信号处理程序。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>取值</th>
<th>名称</th>
<th>解释</th>
<th>默认动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIGHUP</td>
<td>挂起（在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联）</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>中断（程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程）</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>退出（和SIGINT类似, 但由QUIT字符(通常是Ctrl-/)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号）</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>非法指令（执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>断点或陷阱指令（由断点指令或其它trap指令产生. 由debugger使用）</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>abort发出的信号（调用abort函数生成的信号）</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>非法内存访问（非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)）</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>浮点异常（在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误）</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>kill信号（用来立即结束程序的运行）</td>
<td>不能被忽略、处理和阻塞</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSR1</td>
<td>用户信号1（留给用户使用）</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>无效内存访问（试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据）</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>用户信号2（留给用户使用）</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>管道破损，没有读端的管道写数据（这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止还往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止，也会产生这个信号）</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>alarm发出的信号（时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号）</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>终止信号（程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号）</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>栈溢出</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>子进程退出（子进程结束时, 父进程会收到这个信号）</td>
<td>默认忽略</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>进程继续</td>
<td>不能被阻塞</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>进程停止（停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行）</td>
<td>不能被忽略、处理和阻塞</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>进程停止（停止进程的运行, 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号）</td>
<td>该信号可以被处理和忽略</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>进程停止，后台进程从终端读数据时</td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>进程停止，后台进程想终端写数据时</td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>SIGURG</td>
<td>I/O有紧急数据到达当前进程</td>
<td>默认忽略</td>
</tr>
<tr>
<td>24</td>
<td>SIGXCPU</td>
<td>进程的CPU时间片到期</td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>SIGXFSZ</td>
<td>文件大小的超出上限</td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>SIGVTALRM</td>
<td>虚拟时钟超时</td>
<td></td>
</tr>
<tr>
<td>27</td>
<td>SIGPROF</td>
<td>profile时钟超时</td>
<td></td>
</tr>
<tr>
<td>28</td>
<td>SIGWINCH</td>
<td>窗口大小改变</td>
<td>默认忽略</td>
</tr>
<tr>
<td>29</td>
<td>SIGIO</td>
<td>I/O相关</td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>SIGPWR</td>
<td>关机</td>
<td>默认忽略</td>
</tr>
<tr>
<td>31</td>
<td>SIGSYS</td>
<td>系统调用异常</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>这个可以在<a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man7/signal.7.html">signal(7) - Linux manual page (man7.org)</a>中查看！</p>
</blockquote>
<p>​    <code>POSIX</code>标准还引入了一类新的信号，叫做实时信号(<code>real-time signal</code>)；在<code>Linux</code>中它们的编码范围为<code>32～64</code>。它们与常规信号有很大的不同，因为它们必须排队以便发送的多个信号能被接收到。另一方面，同种类型的常规信号并不排队：如果一个常规信号被连续发送多次，那么，只有其中的一个发送到接收进程。尽管<code>Linux</code>内核并不使用实时信号，它还是通过几个特定的系统调用完全实现了<code>POSIX</code>标准。</p>
<p>信号的一个重要特点是它们可以随时被发送给状态经常不可预知的进程。 发送给非运行进程的信号必须由内核保存，直到进程恢复执行。阻塞一个信号(后面描述)，要求信号的传递拖延，直到随后解除阻塞，这使得信号产生一段时间之后才能对其传递这一问题变得更加严重。因此，内核区分信号传递的两个不同阶段：</p>
<ul>
<li>信号产生，内核更新目标进程的数据结构以表示一个信号已经被发送．</li>
<li>信号传递，内核强迫目标进程通过以下方式对信号做出反应： 或改变目标进程的执行状态，或开始执行一个特定的信号处理程序，或两者都是</li>
</ul>
<p>​    信号一旦已传递出去，进程描述符中有关这个信号的所有信息都被取消。已经产生但还没有传递的信号称为挂起信号(<code>pending signal</code>)。</p>
<p>​    任何时候，一个进程仅存在给定类型的一个挂起信号，同一进程同种类型的其他信号不被排队，只被简单地丢弃。</p>
<p>​    但是，实时信号是不同的：同种类型的挂起信号可以有好几个。 一般来说，信号可以保留不可预知的挂起时间。必须考虑下列因素：</p>
<ul>
<li>信号通常只被当前正运行的进程传递(即由<code>current</code>进程传递)。</li>
<li>给定类型的信号可以由进程选择性地阻塞(<code>blocked</code>)．</li>
<li>当进程执行一个信号处理程序的函数时，通常“屏蔽”相应的信号，即自动阻塞这个信号直到处理程序结束。因此，所处理的信号的另一次出现不能中断信号处理程序，所以，信号处理函数不必是可重入的。</li>
</ul>
<p>所以，内核必须要做出以下工作！</p>
<ul>
<li>记住每个进程阻塞哪些信号。</li>
<li>当从内核态切换到用户态时，对任何一个进程都要检查是否有一个信号已到达。</li>
<li>确定是否可以忽略信号。这发生在下列所有的条件都满足时：<ul>
<li>目标进程没有被另一个进程跟踪(进程描述符中<code>ptrace</code>字段的<code>PT_PTRACED</code>标志等于<code>0</code>)。</li>
<li>信号没有被目标进程阻塞。</li>
<li>信号被目标进程忽略</li>
</ul>
</li>
<li>处理这样的信号，即信号可能在进程运行期间的任一时刻请求把进程切换到一个信号处理函数，并在这个函数返回以后恢复原来执行的上下文。</li>
</ul>
<h2 id="传递信号之前所执行的操作"><a href="#传递信号之前所执行的操作" class="headerlink" title="传递信号之前所执行的操作"></a>传递信号之前所执行的操作</h2><p>进程以三种方式对一个信号做出应答：</p>
<ol>
<li>显式地忽略信号。</li>
<li>执行与信号相关的缺省操作．<br>a. <code>Terminate</code><br>进程被终止。<br>b. <code>Dump</code><br>进程被终止，并且，如果可能，创建包含进程执行上下文的核心转储文件；<br>c. <code>lgnore</code><br>信号被忽略。<br>d. <code>Stop</code><br>进程被停止，即把进程置为<code>TASK_STOPPED</code>状态．<br>e. <code>Continue</code><br>如果进程被停止(<code>TASK_STOPPED</code>)，<code>continue</code>处理中就把它置为<code>TASK_RUNNING</code>状态。</li>
<li>通过调用相应的信号处理函数捕获信号。</li>
</ol>
<p>​    如果一个进程正在被跟踪时接收到一个信号，内核就停止这个进程，并向跟踪进程发送一个<code>SIGCHLD</code>信号以通知它一下。跟踪进程又可以使用<code>SIGCOUNT</code>信号重新恢复被跟踪进程的执行。 <code>SIGKILL</code>和<code>SIGSTOP</code>信号不可以被显式地忽略、捕获或阻塞， 因此，通常必须执行它们的缺省操作。</p>
<h3 id="POSIX信号和多线程应用"><a href="#POSIX信号和多线程应用" class="headerlink" title="POSIX信号和多线程应用"></a>POSIX信号和多线程应用</h3><p><code>POSIX 1003.1</code>标准对多线程应用的信号处理有一些严格的要求：</p>
<ol>
<li>信号处理程序必须在多线程应用的所有线程之间共享；不过，每个线程必须有自己的挂起信号掩码和阻塞信号掩码。挂起是信号已经产生，等待处理中。阻塞是即使信号已经产生，也不会进行实际处理。</li>
<li><code>POSIX</code>库函数<code>kill()</code>和<code>sigqueue()</code>必须向所有的多线程应用而不是某个特殊的线程发送信号。 所有由内核产生的信号同样如此(如：<code>SIGCHLD、SIGINT</code>或<code>SIGQUIT</code>)。</li>
<li>每个发送给多线程应用的信号仅传送给一个线程，这个线程是由内核在从不会阻塞该信号的线程中随意选择出来的。</li>
<li>如果向多线程应用发送了一个致命的信号，那么内核将杀死该应用的所有线程，而不仅仅是杀死接收信号的那个线程。</li>
</ol>
<p>​    有两个例外：不可能给进程<code>0</code>(<code>swapper</code>)发送信号，而发送给进程<code>1</code>(<code>init</code>)的信号在捕获到它们之前也总被丢弃。因此，进程<code>0</code>永不死亡，而进程<code>1</code>只有当<code>init</code>程序终止时才死亡。如果一个挂起信号被发送给了某个特定线程，那么这个信号是私有的；如果被发送给了整个线程组，它就是共享的。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src=".\be8dc3994fb840feb9820630b2e2df65.png" alt="在这里插入图片描述"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>struct signal_struct*</code></td>
<td><code>signal</code></td>
<td></td>
</tr>
<tr>
<td><code>struct sighand_struct*</code></td>
<td><code>sighand</code></td>
<td></td>
</tr>
<tr>
<td><code>sigset_t</code></td>
<td><code>blocked</code></td>
<td></td>
</tr>
<tr>
<td><code>sigset_t</code></td>
<td><code>real_blocked</code></td>
<td></td>
</tr>
<tr>
<td><code>struct sigpending</code></td>
<td><code>pending</code></td>
<td></td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td><code>sas_ss_sp</code></td>
<td></td>
</tr>
<tr>
<td><code>size_t</code></td>
<td><code>sas_ss_size</code></td>
<td></td>
</tr>
<tr>
<td><code>int(*)(void*)</code></td>
<td><code>notifier</code></td>
<td></td>
</tr>
<tr>
<td><code>void*</code></td>
<td><code>notifier_data</code></td>
<td></td>
</tr>
<tr>
<td><code>sigset_t*</code></td>
<td><code>notifier_mask</code></td>
</tr>
</tbody>
</table>
</div>
<p>​    <code>blocked</code>字段存放进程当前所屏蔽的信号。它是一个<code>sigset_t</code>位数组，每种信号类型对应一个元素： 信号的编号对应于<code>sigset_t</code>类型变量中的相应位下标加<code>1</code>。</p>
<h3 id="信号描述符和信号处理程序描述符"><a href="#信号描述符和信号处理程序描述符" class="headerlink" title="信号描述符和信号处理程序描述符"></a>信号描述符和信号处理程序描述符</h3><p>信号描述符被属于同一线程组的所有进程共享，信号描述符中与信号处理有关的字段如表<code>11-4</code>所示：</p>
<p><img src=".\image-20240503111537059.png" alt="image-20240503111537059"></p>
<h3 id="sigaction数据结构"><a href="#sigaction数据结构" class="headerlink" title="sigaction数据结构"></a>sigaction数据结构</h3><p>(1). <code>sa_handler</code>：指向信号处理程序的一个指针/<code>SIG_DFL</code>/<code>SIG_IGN</code>．<br>(2). <code>sa_flags</code>：这是一个标志集．<br>(3). <code>sa_mask</code>：当运行信号处理程序时要屏蔽的信号。</p>
<h3 id="挂起信号队列"><a href="#挂起信号队列" class="headerlink" title="挂起信号队列"></a>挂起信号队列</h3><p>有几个系统调用能产生发送给整个线程组的信号，如<code>kill()</code>和<code>rt_sigqueueinfo()</code>，而其他的一些则产生发送给特定进程的信号，如<code>tkill()</code>和<code>tgkill()</code>。内核把两个挂起信号队列与每个进程相关联：<br>(1). 共享挂起信号队列，存放整个线程组的挂起信号。<br>(2). 私有挂起信号队列，存放特定进程(轻量级进程)的挂起信号。</p>
<p>挂起信号队列由<code>sigpending</code>数据结构组成，它的定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">siigpending</span><span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span>
    <span class="token class-name">sigset_t</span>	signal<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct list_head</td>
<td>list</td>
<td>链接挂起信号对应的链表</td>
</tr>
<tr>
<td>spinlock_t*</td>
<td>lock</td>
<td>指向与挂起信号相应的信号处理程序描述符中siglock字段的指针</td>
</tr>
<tr>
<td>int</td>
<td>flags</td>
<td>sigqueue数据结构的标志</td>
</tr>
<tr>
<td>siginfo_t</td>
<td>info</td>
<td>描述产生信号的事件</td>
</tr>
<tr>
<td>struct user_struct</td>
<td>user</td>
<td>指向进程拥有者的每用户数据结构的指针</td>
</tr>
</tbody>
</table>
</div>
<p><code>siginfo_t</code>是一个<code>128</code>字节的数据结构，其中存放有关出现特定信号的信息。它包含下列字段：<br>a. <code>si_signo</code><br>信号编号。<br>b. <code>si_errno</code><br>引起信号产生的指令的出错码，或者如果没有错误则为<code>0</code>。<br>c. <code>si_code</code><br>发送信号者的代码(参见表<code>11-8</code>)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>代码名</th>
<th>发送者</th>
</tr>
</thead>
<tbody>
<tr>
<td>SI_USER</td>
<td>kill, raise</td>
</tr>
<tr>
<td>SI_KERNEL</td>
<td>一般内核函数</td>
</tr>
<tr>
<td>SI_QUEUE</td>
<td>sigqueue</td>
</tr>
<tr>
<td>SI_TIMER</td>
<td>定时器到期</td>
</tr>
<tr>
<td>SI_ASYNC</td>
<td>异步IO完成</td>
</tr>
<tr>
<td>SI_TKILL</td>
<td>tkill和tgkill</td>
</tr>
</tbody>
</table>
</div>
<h3 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h3><p>很多内核函数都会产生信号：即根据需要更新一个或多个进程的描述符。它们不直接执行第二步的信号传递操作，而是可能根据信号的类型和目标进程的状态唤醒一些进程，并促使这些进程接收信号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>send_sig</td>
<td>向单一进程发送信号</td>
</tr>
<tr>
<td>send_sig_info</td>
<td>与上类似，还使用<code>siginfo_t</code>扩展信息</td>
</tr>
<tr>
<td>force_sig</td>
<td>发送不能被进程显示忽略，也不能被进程阻塞的信号</td>
</tr>
<tr>
<td>force_sig_info</td>
<td>与上类似，还使用<code>siginfo_t</code>扩展信息</td>
</tr>
<tr>
<td>force_sig_specific</td>
<td>与上类似，优化了SIGSTOP和SIGKILL信号的处理</td>
</tr>
<tr>
<td>sys_tkill</td>
<td>tkill系统调用的处理函数</td>
</tr>
<tr>
<td>sys_tgkill</td>
<td>tgkill系统调用的处理函数</td>
</tr>
</tbody>
</table>
</div>
<p>所有函数在结束时都调用<code>specific_send_sig_info()</code>函数．</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>send_group_sig_info</td>
<td>向某一个进线程组发送信号，该线程组由它的一个成员进程的描述符来标识。</td>
</tr>
<tr>
<td>kill_pg</td>
<td>向一个进程组中所有的进程组发送信号！</td>
</tr>
<tr>
<td>kill_pg_info</td>
<td>与上一个类似只是，还使用<code>siginfo_t</code>扩展信息</td>
</tr>
<tr>
<td>kill_proc</td>
<td>向某一个线程组发送信号该线程组，有它的一个成员进程的pid来标识</td>
</tr>
<tr>
<td>kill_proc_info</td>
<td>与上一个类似只是，还使用<code>siginfo_t</code>扩展信息</td>
</tr>
<tr>
<td>sys_kill</td>
<td>kill系统调用处理函数</td>
</tr>
<tr>
<td>sus_rt_sigqueueinfo</td>
<td>rt_sigqueueinfo系统调用处理函数</td>
</tr>
</tbody>
</table>
</div>
<p>所有函数在结束时都调用<code>group_send_sig_info()</code>函数．</p>
<h3 id="specific-send-sig-info-函数"><a href="#specific-send-sig-info-函数" class="headerlink" title="specific_send_sig_info()函数"></a>specific_send_sig_info()函数</h3><p><code>specific_send_sig_info()</code>函数向指定进程发送信号，它作用于三个参数：</p>
<blockquote>
<p>sig：信号编号</p>
<p>info：或者是<code>siginfo_t</code>表的地址，或者是三个特殊值中的一个。零意味着信号是由用户态进程发送的，一意味着是由内核发送的，二意味着是由内核发送的信号</p>
<p>t:指向目标进程描述符的指针 </p>
</blockquote>
<p>必须在关本地中断和已经获得<code>t-&gt;sighand-&gt;siglock</code>自旋锁的情况下调用<code>specific_send_sig_info()</code>函数。函数执行下面的步骤：</p>
<blockquote>
<ol>
<li><p>检查进程是否忽略信号，如果是就返回<code>0</code>(不产生信号)。当下面的三个忽略信号的条件全部满足时，信号就被忽略：</p>
<blockquote>
<ol>
<li>进程没有被跟踪（<code>t-&gt;ptrace</code>中的<code>PT_PTRACED</code>标志被清<code>0</code>）．</li>
<li>信号没有被阻塞（<code>sigismember(&amp;t-&gt;blocked,sig)</code>返回<code>0</code>）．</li>
<li>或者显式地忽略信号（<code>t-&gt;sighand-&gt;action[sig-1]</code>的<code>sa_handler</code>字段等于<code>SIG_IGN</code>），或者隐含地忽略信号(<code>sa_handler</code>字段等于<code>SIG_DFL</code>而且信号是<code>SIGCONT、SIGCHLD、SIGWINCH</code>或<code>SIGURG</code>)．</li>
</ol>
</blockquote>
</li>
<li><p>检查信号是否是非实时的（<code>sig&lt;32</code>），而且是否在进程的私有挂起信号队列上已经有另外一个相同的挂起信号。如果是，就什么都不需要做，因此返回<code>0</code>。</p>
</li>
<li><p>调用<code>send_signal( sig,info,t,&amp;t-&gt;pending)</code>，把信号添加到进程的挂起信号集合中．</p>
</li>
<li><p>如果<code>send_signal()</code>成功地结束，而且信号不被阻塞（<code>sigismember(&amp;t-&gt;blocked,sig)</code>返回<code>0</code>)，就调用<code>signal_wake_up()</code>函数通知进程有新的挂起信号。</p>
</li>
</ol>
</blockquote>
<h4 id="signal-wake-up"><a href="#signal-wake-up" class="headerlink" title="signal_wake_up"></a>signal_wake_up</h4><p>a. 把<code>t-&gt;thread_info-&gt;flags</code>中的<code>TIF_SIGPENDING</code>标志置位。<br>b. 如果进程处于<code>TASK_INTERRUPTIBLE</code>或<code>TASK_STOPPED</code>状态，而且信号是<code>SIGKILL</code>，就调用<code>try_to_wake_up()</code>唤醒进程。<br>c. 如果<code>try_to_wake_up()</code>返回<code>0</code>，那么说明进程已经是可运行的：这种情况下，它检查进程是否已经在另外一个<code>CPU</code>上运行，如果是就向那个<code>CPU</code>发送一个处理器间中断，以强制当前进程的重新调度。因为在从调度函数返回时，每个进程都检查是否存在挂起信号，因此，处理器间中断保证了目标进程能很快注意到新的挂起信号。<br>d. 返回<code>1</code>(已经成功地产生信号)。</p>
<h3 id="send-signal-函数"><a href="#send-signal-函数" class="headerlink" title="send_signal()函数"></a>send_signal()函数</h3><p><code>send_sigmal()</code>函数在挂起信号队列中插入一个新元素，</p>
<pre class="line-numbers language-none"><code class="language-none">static int send_signal(int sig, struct siginfo *info, struct task_struct *t, struct sigpending *signals)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将信号加入到进程挂起信号掩码。需要时，分配并构造<code>sigqueue</code>，加入<code>sigqueue</code>链表。<code>sigqueue</code>链表使得掩码中指定的一个信号，可以存在多个链表节。<code>sigqueue</code>可以使得进一步存储信号关联的数据信息。</p>
<h3 id="group-send-sig-info-函数"><a href="#group-send-sig-info-函数" class="headerlink" title="group_send_sig_info()函数"></a>group_send_sig_info()函数</h3><p><code>group_send_sig_info()</code>函数向整个线程组发送信号。它作用于三个参数：信号编号<code>sig</code>、<code>siginfo_t</code>表的地址<code>info</code>(可选的值为<code>0、1</code>或<code>2</code>，如前面“<code>specific_send_sig_info()</code>函数“一节中所描述的)以及进程描述符的地址<code>p</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">int group_send_sig_info(int sig, struct siginfo *info, struct task_struct *p)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该函数主要执行下面的步骤：</p>
<ol>
<li>检查参数<code>sig</code>是否正确：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">if(sig&lt;0 Il sig&gt;64)
	return -EINVAL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li><p>如果信号是由用户态进程发送的，则该函数确定是否允许这个操作。下列条件中至少有一个成立时信号才能被传递：</p>
<blockquote>
<ol>
<li>发送进程的拥有者具有适当的权能(这通常意味着通过系统管理员发布信号)。</li>
<li>信号为<code>SIGCONT</code>且目标进程与发送进程处于同一个注册会话中。</li>
<li>两个进程属于同一个用户。如果不允许用户态进程发送信号，函数就返回值<code>-EPERM</code>。</li>
<li>如果参数<code>sig</code>的值为<code>0</code>,则函数不产生任何信号，立即返回：</li>
</ol>
</blockquote>
</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">if(!sig ll !p-&gt;sighand)
	return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li>因为<code>0</code>是无效的信号编码，用于让发送进程检查它是否有向目标线程组发送信号所必需的特权。如果目标进程正在被杀死（通过检查它的信号处理程序描述符是否已经被释放来获知），那么函数也返回。</li>
<li>获取<code>p-&gt;sighand-&gt;siglock</code>自旋锁并关闭本地中断。</li>
<li>调用<code>handle_stop_signal()</code>函数，该函数检查信号的某些类型，这些类型可能使目标线程组的其他挂起信号无效。</li>
</ol>
<h4 id="handle-stop-signal-函数执行下面的步骤："><a href="#handle-stop-signal-函数执行下面的步骤：" class="headerlink" title="handle_stop_signal()函数执行下面的步骤："></a>handle_stop_signal()函数执行下面的步骤：</h4><ol>
<li>如果线程组正在被杀死（信号描述符的<code>flags</code>字段的<code>SIGNAL_GROUP_EXIT</code>标志被设置），则函数返回。</li>
<li>如果<code>sig</code>是<code>SIGSTOP、SIGTSTP、SIGTTIN</code>或<code>SIGTTOU</code>信号，就调用<code>rm_from_queue()</code>函数从共享挂起信号队列<code>p-&gt;signal-&gt;shared_pending</code>和线程组所有成员的私有信号队列中删除<code>SIGCONT</code>信号。</li>
<li>如果<code>sig</code>是<code>SIGCONT</code>信号，就调用<code>rm_from_queue()</code>函数从共享挂起信号队列<code>p-&gt;signal-&gt;shared_pending</code>中删除所有的<code>SIGSTOP、 SIGTSTP、SIGTTIN和SIGTTOU</code>信号，然后从属于线程组的进程的私有挂起信号队列中删除上述信号，并唤醒进程：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">rm_from_queue(0x003c0000,&amp;p-&gt;signal-&gt;shared_pending);
t &#x3D; p;
do &#123;
	rm_from_queue(0x003c0000,&amp;t-&gt;pending);
	try_to_wake_up(t,TASK_STOPPED,0);
	t &#x3D; next_thread(t);
&#125; while(t !&#x3D; p);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>掩码<code>0x003c0000</code>选择以上四种停止信号。宏<code>next_thread</code>每次循环都返回线程组中不同轻量级进程的描述符地址．</p>
<ol>
<li>检查线程组是否忽略信号，如果是就返回<code>0</code>值（成功）。如果在前面<code>“信号的作用”</code>一节中所提到的忽略信号的三个条件都满足(也可参见前面“<code>specific-send-sig.info()</code>函数”一节中的第<code>1</code>步)，就忽略信号。</li>
<li>检查信号是否是非实时的，并且在线程组的共享挂起信号队列中已经有另外一个相同的信号，如果是，就什么都不需要做，因此返回<code>0</code>值（成功）。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">if(sig&lt;32 &amp;&amp; sigismember(&amp;p-&gt;signal-&gt;shared_pending.signal,sig))
	return 0;
12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>调用<code>send_signal()</code>函数把信号添加到共享挂起信号队列中。如果<code>send_signal()</code>返回非<code>0</code>的错误代码，则函数终止并返回相同的值。</p>
<ol>
<li>调用<code>__group_complete_signal()</code>函数唤醒线程组中的一个轻量级进程．</li>
<li>释放<code>p-&gt;sighand-&gt;siglock</code>自旋锁并打开本地中断。</li>
<li>返回<code>0</code>(成功)。</li>
</ol>
<h4 id="group-complete-sigmal"><a href="#group-complete-sigmal" class="headerlink" title="__group_complete_sigmal"></a>__group_complete_sigmal</h4><p>函数<code>__group_complete_sigmal()</code>扫描线程组中的进程，查找能接收新信号的进程。满足下述所有条件的进程可能被选中：</p>
<ul>
<li>进程不阻塞信号。</li>
<li>进程的状态不是<code>EXIT_ZOMBIE、EXIT_DEAD、TASK_TRACED</code>或<code>TASK_STOPPED</code>（作为一种异常情况，如果信号是<code>SIGKILL</code>，那么进程可能处于<code>TASK_TRACED</code>或者<code>TASK_STOPPED</code>状态）。</li>
<li>进程没有正在被杀死，即它的<code>PF_EXITING</code>标志没有置位。</li>
<li>进程或者当前正在<code>CPU</code>上运行，或者它的<code>TIF_SIGPENDING</code>标志还没有设置。</li>
<li>(实际上，唤醒一个有挂起信号的进程是毫无意义的：通常，唤醒操作已经由设置了<code>TIF_SIGPENDING</code>标志的内核控制路径执行；另一方面，如果进程正在执行，则应该向它通报有新的挂起信号。)</li>
</ul>
<p>​    一个线程组可能有很多满足上述条件的进程，函数按照下面的规则选择其中的一个进程：</p>
<ol>
<li><p>如果<code>p</code>标识的进程(由<code>group_send_sig_info()</code>的参数传递的描述符地址)满足所有的优先准则， 并因此而能接收信号，函数就选择该进程。</p>
</li>
<li><p>否则，函数通过扫描线程组的成员搜索一个适当的进程，搜索从接收线程组最后一个信号的进程（<code>p-&gt;signal-&gt;curr_target</code>）开始。</p>
</li>
<li><p>如果函数<code>__group_complete_signal()</code>成功地找到一个适当的进程，就开始向被选中的进程传递信号。</p>
<blockquote>
<p>首先，函数检查信号是否是致命的:</p>
<p>如果是，通过向线程组中的所有轻量级进程发送<code>SIGKILL</code>信号杀死整个线程组。</p>
<p>否则，函数调用<code>signal_wake_up()</code>函数通知被选中的进程：有新的挂起信号到来。</p>
</blockquote>
</li>
</ol>
<h3 id="传递信号"><a href="#传递信号" class="headerlink" title="传递信号"></a>传递信号</h3><p>​    确保进程的挂起信号得到处理内核所执行的操作。内核在允许进程恢复用户态下的执行之前，检查进程<code>TIF_SIGPENDING</code>标志的值。每当内核处理完一个中断或异常时，就检查是否存在挂起信号。</p>
<h4 id="do-signal"><a href="#do-signal" class="headerlink" title="do_signal"></a>do_signal</h4><p>为了处理非阻塞的挂起信号，内核调用<code>do_signal()</code>函数，它接收两个参数：</p>
<blockquote>
<p>regs: 栈区的地址，当前进程在用户态下的寄存器内容存放在这个栈中 </p>
<p>oldset:变量的地址，假设函数把阻塞信号的位掩码数组存放在这个变量中！如果没有必要保存为掩码数组，则把它设为空<br>如果中断处理程序调用<code>do_signal()</code>，则该函数立刻返回：</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">if((regs-&gt;xcs &amp; 3)  !&#x3D; 3)
	return l;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果<code>oldset</code>参数为<code>NULL</code>，函数就用<code>current-&gt;blocked</code>字段的地址对它初始化：</p>
<pre class="line-numbers language-none"><code class="language-none">if  (!oldset)
	oldset &#x3D;&amp;current-&gt;blocked;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>do_signal()</code>函数的核心由重复调用<code>dequeue_signal()</code>函数的循环组成，直到在私有挂起信号队列和共享挂起信号队列中都没有非阻塞的挂起信号时，循环才结束。<code>dequeue_signal()</code>的返回码存放在<code>signr</code>局部变量中。如果值为<code>0</code>，意味着所有挂起的信号已全部被处理，并且<code>do_signal()</code>可以结束。只要返回一个非<code>0</code>值，就意味着挂起的信号正等待被处理，并且<code>do_signal()</code>处理了当前信号后又调用了<code>dequeue_sigmal()</code>。</p>
<h4 id="dequeue-signal"><a href="#dequeue-signal" class="headerlink" title="dequeue_signal"></a>dequeue_signal</h4><p><code>dequeue_signal()</code>函数首先考虑私有挂起信号队列中的所有信号，并从最低编号的挂起信号开始。然后考虑共享队列中的信号。它更新数据结构以表示信号不再是挂起的，并返回它的编号。看<code>do_signal()</code>函数如何处理每一个挂起的信号，其编号由<code>dequeue_signal()</code>返回。首先，它检查<code>current</code>接收进程是否正受到其他一些进程的监控；在肯定的情况下，<code>do_signal()</code>调用<code>do_notify_parent_cldstop()</code>和<code>schedule()</code>让监控进程知道进程的信号处理。然后，<code>do_signal()</code>把要处理信号的<code>k_sigaction</code>数据结构的地址赋给局部变量<code>ka</code>：<code>ka =¤t-&gt;sig-&gt;action[signr-1];</code>．根据<code>ka</code>的内容可以执行三种操作：忽略信号、执行缺省操作或执行信号处理程序。如果显式忽略被传递的信号，那么<code>do_signal()</code>函数仅仅继续执行循环，并由此考虑另一个挂起信号．</p>
<h3 id="执行信号的缺省操作"><a href="#执行信号的缺省操作" class="headerlink" title="执行信号的缺省操作"></a>执行信号的缺省操作</h3><p>​    如果<code>ka-&gt;sa.sa_handler</code>等于<code>SIG_DFL</code>，<code>do_signal()</code>就必须执行信号的缺省操作。唯一的例外是当接收进程是<code>init</code>时，在这种情况下，这个信号被丢弃：</p>
<pre class="line-numbers language-none"><code class="language-none">if(current-&gt;pid &#x3D;&#x3D; 1)
	continue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​    如果接收进程是其他进程，对缺省操作是<code>Ignore</code>的信号进行处理也很简单：</p>
<pre class="line-numbers language-none"><code class="language-none">if(signr&#x3D;&#x3D;SIGCONT ll signr&#x3D;&#x3D;SIGCHLD II signr&#x3D;&#x3D;SIGWINCH || signr&#x3D;&#x3D;SIGURG)
	continue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​    缺省操作是<code>Stop</code>的信号可能停止线程组中的所有进程。为此，<code>do_signal()</code>把进程的状态都置为<code>TASK_STOPPED</code>，并在随后调用<code>schedule()</code>函数</p>
<pre class="line-numbers language-none"><code class="language-none">if(signr&#x3D;&#x3D;SIGSTOP ll signr&#x3D;&#x3D;SIGTSTP || signr&#x3D;&#x3D;SIGTTIN II signr&#x3D;&#x3D;SIGTTOU) &#123;
	if(signr !&#x3D; SIGSTOP &amp;&amp; is_orphaned_pgrp(current-&gt;signal-&gt;pgrp))
		continue;
	do_signal_stop(signr);
&#125;
12345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    <code>SIGSTOP</code>与其他信号的差异比较微妙：<code>SIGSTOP</code>总是停止线程组，而其他信号只停止不在“孤儿进程组”中的线程组。</p>
<h4 id="do-signal-stop"><a href="#do-signal-stop" class="headerlink" title="do_signal_stop"></a>do_signal_stop</h4><p><code>do_signal_stop()</code>函数检查<code>current</code>是否是线程组中第一个被停止的进程，如果是，它激活”组停止”：本质上，该函数把一个正数值赋给信号描述符中的<code>group_stop_count</code>字段，并唤醒线程组中的所有进程。所有这样的进程都检查该字段以确认正在进行“组停止”操作，然后把进程的状态置为<code>TASK_STOPPED</code>，并调用<code>schedule()</code>。如果线程组领头进程的父进程没有设置<code>SIGCHLD</code>的<code>SA_NOCLDSTOP</code>标志，那么<code>do_signal_stop()</code>函数还要向它发送<code>SIGCHLD</code>信号。</p>
<p>缺省操作为<code>Dump</code>的信号可以在进程的工作目录中创建一个“转储”文件，这个文件列出进程地址空间和<code>CPU</code>寄存器的全部内容。<code>do_signal()</code>创建了转储文件后，就杀死这个线程组。</p>
<p>剩余<code>18</code>个信号的缺省操作是<code>Terminate</code>, 它仅仅是杀死线程组。为了杀死整个线程组，函数调用<code>do_group_exit()</code>执行彻底的“组退出”过程。</p>
<h3 id="捕获信号"><a href="#捕获信号" class="headerlink" title="捕获信号"></a>捕获信号</h3><p>​    如果信号有一个专门的处理程序，<code>do_signal()</code>就函数必须强迫该处理程序执行。这是通过调用<code>handle_signal()</code>进行的：</p>
<pre class="line-numbers language-none"><code class="language-none">handle_signal(signr,&amp;info,aka,oldset,regs);
if(ka-&gt;sa.sa_flags&amp; SA_ONESHOT)
	ka-&gt;sa.sa_handler &#x3D; SIG_DFL;
return 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    执行一个信号处理程序是件相当复杂的任务，因为在用户态和内核态之间切换时需要谨慎地处理栈中的内容。我们将正确地解释这里所承担的任务。</p>
<p>​    信号处理程序是用户态进程所定义的函数，并包含在用户态的代码段中。<code>handle_signal()</code>函数运行在内核态，而信号处理程序运行在用户态，这就意味着在当前进程恢复<code>“正常”</code>执行之前，它必须首先执行用户态的信号处理程序。此外，当内核打算恢复进程的正常执行时，内核态堆栈不再包含被中断程序的硬件上下文，因为每当从内核态向用户态转换时，内核态堆栈都被清空。而另外一个复杂性是因为信号处理程序可以调用系统调用，在这种情况下，执行了系统调用的服务例程以后，控制权必须返回到信号处理程序而不是到被中断程序的正常代码流。</p>
<p>​    <code>Linux</code>所采用的解决方法是把保存在内核态堆栈中的硬件上下文拷贝到当前进程的用户态堆栈中。用户态堆栈也以这样的方式被修改，即当信号处理程序终止时，自动调用<code>sigreturn()</code>系统调用把这个硬件上下文拷贝回到内核态堆栈中，并恢复用户态堆栈中原来的内容。</p>
<p>图<code>11-2</code>说明了有关捕获一个信号的函数的执行流。</p>
<ol>
<li>一个非阻塞的信号发送给一个进程。</li>
<li>当中断或异常发生时，进程切换到内核态。正要返回到用户态前，内核执行<code>do_signal()</code>函数，</li>
<li>这个函数又依次处理信号(通过调用<code>handle_signal()</code>)和建立用户态堆栈(通过调用<code>setup_frame()</code>或<code>setup_rt_frame()</code>)。当进程又切换到用户态时，因为信号处理程序的起始地址被强制放进程序计数器中，因此开始执行信号处理程序。</li>
</ol>
<p>​    当处理程序终止时，<code>setup_frame()</code>或<code>setup_rt_frame()</code>函数放在用户态堆栈中的返回代码就被执行。这个代码调用<code>sigreturn()</code>或<code>rt_sigreturn()</code>系统调用，相应的服务例程把正常程序的用户态堆栈硬件上下文拷贝到内核态堆栈，并把用户态堆栈恢复到它原来的状态(通过调用<code>restore_sigcontext()</code>)。当这个系统调用结束时，普通进程就因此能恢复自己的执行。</p>
<p><img src=".\image-20240503113655595.png" alt="image-20240503113655595"></p>
<h3 id="setup-frame"><a href="#setup-frame" class="headerlink" title="setup_frame"></a>setup_frame</h3><p>为了适当地建立进程的用户态堆栈，<code>handle_signal()</code>函数或者调用<code>setup_frame()</code>(对不需要<code>siginfo_t</code>表的信号；或者调用<code>setup_rt_frame()</code>。为了在这两个函数之间进行选择，内核检查与信号相关的<code>sigaction</code>表<code>sa_flags</code>字段的<code>SA_SIGINFO</code>标志值。<code>setup_frame()</code>函数接收四个参数，它们具有下列含义：</p>
<p>sig: 信号编号</p>
<p>ka: 与信号相关的k_sigaction表地址</p>
<p>oldset:掩码数组</p>
<p>regs: 栈区的地址</p>
<p>oldset:变量的地址，假设函数把阻塞信号的位掩码数组存放在这个变量中！如果没有必要保存为掩码数组，则把它设为空<br>如果中断处理程序调用<code>do_signal()</code>，则该函数立刻返回：<br><code>setup_frame()</code>函数把一个叫做帧(<code>frame</code>)的数据结构推进用户态堆栈中，这个帧含有处理信号所需要的信息，并确保正确返回到<code>handle_signal()</code>函数。一个帧就是包含下列字段的<code>sigframe</code>表(见图<code>11-3</code>):</p>
<blockquote>
<p>pretcode:信号处理函数的返回地址 </p>
<p>sig: 信号编号</p>
<p>sc:包含正好切换到内核态前用户态进程的硬件上下文</p>
<p>fpstate:可以用来存放用户态进程的浮点寄存器内容</p>
<p>被阻塞的实时信号的位数组</p>
<p>retcode:发出sig return系统调用的八字节代码 </p>
</blockquote>
<p><img src=".\image-20240503113001424.png" alt="image-20240503113001424"></p>
<p><code>setup_frame()</code>函数首先调用<code>get_sigframe()</code>计算帧的第一个内存单元，这个内存单元通常是在用户态堆栈中，因此函数返回值：<code>(regs-&gt;esp - sizeof(struct sigframe))&amp; 0xfffffff8</code>。因为栈朝低地址方向延伸，所以通过把当前栈顶的地址减去它的大小，使其结果与<code>8</code>的倍数对齐，就获得了帧的起始地址。然后用<code>access_ok</code>宏对返回地址进行验证。如果地址有效，<code>setup_frame()</code>就反复调用<code>__put_user()</code>填充帧的所有字段。帧的<code>pretcode</code>字段初始化<code>&amp;__kernel_sigreturn</code>，一些粘合代码的地址放在<code>vsyscall</code>页中。一旦完成了这个操作，就修改内核态堆栈的<code>regs</code>区，这就保证了当<code>current</code>恢复它在用户态的执行时，控制权将传递给信号处理程序。</p>
<pre class="line-numbers language-none"><code class="language-none">regs-&gt;esp &#x3D;(unsigned long)frame;
regs-&gt;eip &#x3D;(unsigned long)ka-&gt;sa.sa_handler;
regs-&gt;eax &#x3D;(unsigned long)sig;
regs-&gt;edx &#x3D;regs-&gt;ecx &#x3D; 0;
regs-&gt;xds &#x3D; regs-&gt;xes &#x3D; regs-&gt;xss&#x3D;__USER_DS;
regs-&gt;xcs &#x3D;__USER_CS;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>setup_frame()</code>函数把保存在内核态堆栈的段寄存器内容重新设置成它们的缺省值以后才结束。现在，信号处理程序所需的信息就在用户态堆栈的顶部。<code>setup_rt_frame()</code>函数与<code>setup_frame()</code>非常相似，但它把用户态堆栈存放在一个扩展的帧中(保存在<code>rt_sigframe</code>数据结构中)，这个帧也包含了与信号相关的<code>siginfo_t</code>表的内容。此外，该函数设置<code>pretcode</code>字段以使它指向<code>vsyscall</code>页中的<code>__kernel_rt_sigreturm</code>代码。</p>
<h3 id="检查信号标志"><a href="#检查信号标志" class="headerlink" title="检查信号标志"></a>检查信号标志</h3><p>建立了用户态堆栈以后，<code>handle_signal()</code>函数检查与信号相关的标志值。如果信号没有设置<code>SA_NODEFER</code>标志，在<code>sigaction</code>表中<code>sa_mask</code>字段对应的信号就必须在信号处理程序执行期间被阻塞：</p>
<pre class="line-numbers language-none"><code class="language-none">if(!(ka-&gt;sa.sa_flags&amp; SA_NODEFER))&#123;
	spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);
	sigorsets(&amp;current-&gt;blocked,&amp;current-&gt;blocked,&amp;ka-&gt;sa.sa_mask);
	sigaddset(&amp;current-&gt;blocked,sig);
	recalc_sigpending(current);
	spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如前所述，<code>recalc_sigpending()</code>函数检查进程是否有非阻塞的挂起信号，并因此而设置它的<code>TIF_SIGPENDING</code>标志。然后，<code>handle_signal()</code>返回到<code>do_signal()</code>，<code>do_signal()</code>也立即返回。</p>
<h3 id="开始执行信号处理程序"><a href="#开始执行信号处理程序" class="headerlink" title="开始执行信号处理程序"></a>开始执行信号处理程序</h3><p><code>do_signal()</code>返回时，当前进程恢复它在用户态的执行。由于如前所述<code>setup_frame()</code>的准备，<code>eip</code>寄存器指向信号处理程序的第一条指令，而<code>esp</code>指向已推进用户态堆栈顶的帧的第一个内存单元。因此，信号处理程序被执行。</p>
<h3 id="终止信号处理程序"><a href="#终止信号处理程序" class="headerlink" title="终止信号处理程序"></a>终止信号处理程序</h3><p>信号处理程序结束时，返回栈顶地址，该地址指向帧的<code>pretcode</code>字段所引用的<code>vsyscall</code> 页中的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">__kernel_sigreturn:
	popl %eax
	movl $__NR_sigreturn,%eax
	int $0x80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>因此，信号编号(即帧的<code>sig</code>字段)被从栈中丢弃，然后调用<code>sigreturn()</code>系统调用。<code>sys_sigreturn()</code>函数计算类型为<code>pt_regs</code>的数据结构<code>regs</code>的地址，其中<code>pt_regs</code>包含用户态进程的硬件上下文。从存放在<code>esp</code>字段中的值，由此而导出并检查帧在用户态堆栈内的地址：</p>
<pre class="line-numbers language-none"><code class="language-none">frame &#x3D;(struct sigframe *)(regs.esp - 8);
if(verify_area(VERIFY_READ,frame,sizeof(*frame))&#123;
	force_sig(SIGSEGV,current);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后，函数把调用信号处理程序前所阻塞的信号的位数组从帧的<code>sc</code>字段拷贝到<code>current</code> 的<code>blocked</code>字段。结果，为信号处理函数的执行而屏蔽的所有信号解除阻塞。然后调用<code>recalc_sigpending()</code>函数。此时，<code>sys_sigreturn()</code>函数必须把来自帧的<code>sc</code>字段的进程硬件上下文拷贝到内核态堆栈中，并从用户态堆栈中删除帧，这两个任务是通过调用<code>restore_sigcontext()</code>函数完成的。</p>
<p>像<code>rt_sigqueueinfo()</code>这样的系统调用需要与信号相关的<code>siginfo_t</code>表，如果信号是这种系统调用发送的，则其实现机制非常相似。扩展帧的<code>pretcode</code>字段指向<code>vsyscall</code>页面中的<code>__kernel_rt_sigreturn</code>代码，它依次调用<code>rt_sigreturn()</code>系统调用，其相应的<code>sys_rt_sigreturn()</code>服务例程把来自扩展帧的进程硬件上下文拷贝到内核态堆栈，并通过从用户态堆栈删除扩展帧以恢复用户态堆栈原来的内容。</p>
<h3 id="系统调用的重新执行"><a href="#系统调用的重新执行" class="headerlink" title="系统调用的重新执行"></a>系统调用的重新执行</h3><p>内核并不总是能立即满足系统调用发出的请求，在这种情况发生时，把发出系统调用的进程置为<code>TASK_INTERRUPTIBLE</code>或<code>TASK_UNINTERRUPTIBLE</code>状态。如果进程处于<code>TASK_INTERRUPTIBLE</code>状态，并且某个进程向它发送了一个信号，<br>那么，内核不完成系统调用就把进程置成<code>TASK_RUNNING</code>状态。当切换回用户态时信号被传递给进程。当这种情况发生时，系统调用服务例程没有完成它的工作，但返回<code>EINTR、ERESTARTNOHAND、ERESTART_RESTARTBLOCK、ERESTARTSYS</code>或<code>ERESTARTNOINTR</code>错误码。</p>
<p>实际上，这种情况下用户态进程获得的唯一错误码是<code>EINTR</code>，这个错误码表示系统调用还没有执行完(应用程序的编写者可以测试这个错误码并决定是否重新发出系统调用)。内核内部使用剩余的错误码来指定信号处理程序结束后是否自动重新执行系统调用。表<code>11-11</code>列出了与未完成的系统调用相关的出错码及这些出错码对信号三种可能的操作产生的影响。在表项中出现的几个术语的含义如下：<br><img src=".\image-20240503113023269.png" alt="image-20240503113023269"><br>当传递信号时，内核在试图重新执行一个系统调用前必须确定进程确实发出过这个系统调用。这就是<code>regs</code>硬件上下文的<code>orig_eax</code>字段起重要作用之处。让我们回顾一下中断或异常处理程序开始时是如何初始化这个字段的：</p>
<ul>
<li>中断：这个字段包含了只与中断相关的IRQ号减去256 </li>
<li>0X80异常：这个字段包含系统调用号</li>
<li>其他异常：这个字段包含的值为-1</li>
</ul>
<p>​    因此，<code>orig_eax</code>字段中的非负数意味着信号已经唤醒了在系统调用上睡眠的<code>TASK_INTERRUPTIBLE</code>进程。服务例程认识到系统调用曾被中断，并返回前面提到的某个错误码。</p>
<h3 id="重新执行被未捕获信号中断的系统调用"><a href="#重新执行被未捕获信号中断的系统调用" class="headerlink" title="重新执行被未捕获信号中断的系统调用"></a>重新执行被未捕获信号中断的系统调用</h3><p>如果信号被显式地忽略，或者如果它的缺省操作已被强制执行，<code>do_signal()</code>就分析系统调用的出错码，并如表<code>11-11</code>中所说明的那样决定是否重新自动执行未完成的系统调用。如果必须重新开始执行系统调用，那么<code>do_signal()</code>就修改<code>regs</code>硬件上下文，以便在进程返回到用户态时，<code>eip</code>指向<code>int $0x80</code>指令或<code>sysenter</code>指令，且<code>eax</code>包含系统调用号：</p>
<pre class="line-numbers language-none"><code class="language-none">if(regs-&gt;orig_eax &gt;&#x3D; 0)&#123;
	if(regs-&gt;eax &#x3D;&#x3D;-ERESTARTNOHAND ll regs-&gt;eax &#x3D;&#x3D;-ERESTARTSYS II regs-&gt;eax &#x3D;&#x3D;-ERESTARTNOINTR)&#123;
		regs-&gt;eax &#x3D; regs-&gt;orig_eax;
		regs-&gt;eip -&#x3D; 2;
	&#125;
	if(regs-&gt;eax &#x3D;&#x3D;-ERESTART_RESTARTBLOCK)&#123;
		regs-&gt;eax &#x3D;__NR_restart_syscall;
		regs-&gt;eip -&#x3D; 2;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把系统调用服务例程的返回代码赋给<code>regs-&gt;eax</code>字段。注意，<code>int $0x80</code>和<code>sysreturn</code>的长度都是两个字节，因此该函数从<code>eip</code> 中减去<code>2</code>，使<code>eip</code>指向引起系统调用的指令。</p>
<p><code>ERESTART_RESTARTBLOCK</code>错误代码是特殊的，因为<code>eax</code>寄存器中存放了<code>restart_syscall()</code>的系统调用号，因此，用户态进程不会重新执行被信号中断的同一个系统调用。这个错误代码仅用于与时间相关的系统调用，当重新执行这些系统调用时，应该调整它们的用户态参数。一个典型的例子是<code>nanosleep()</code>系统调用。假设进程为了暂停执行<code>20ms</code>而调用了<code>nanosleep()</code>，而在<code>10ms</code>后出现了一个信号。如果像通常那样重新执行该系统调用(不调整其用户态参数)，那么总的时间延迟会超过<code>30ms</code>。可以采用另一种方式，<code>nanosleep()</code>系统调用的服务例程把重新执行时所使用的特定服务例程的地址赋给<code>current</code>的<code>thread_info</code>结构中的<code>restart_block</code>字段，并在被中断时返回<code>-ERESTART_RESTARTBLOCK</code>。<br><code>sys_restart_syscall()</code>服务例程只执行特定的<code>nanosleep()</code>的服务例程，考虑到原始系统调用的调用到重新执行之间有时间间隔，该服务例程调整这种延迟。</p>
<h3 id="为所捕获的信号重新执行系统调用"><a href="#为所捕获的信号重新执行系统调用" class="headerlink" title="为所捕获的信号重新执行系统调用"></a>为所捕获的信号重新执行系统调用</h3><p>如果信号被捕获，那么<code>handle_signal()</code>分析出错码，也可能分析<code>sigaction</code>表的<code>SA_RESTART</code>标志来决定是否必须重新执行未完成的系统调用：</p>
<pre class="line-numbers language-none"><code class="language-none">if(regs-&gt;orig_eax &gt;&#x3D; 0)&#123;
	switch(regs-&gt;eax)&#123;
	case -ERESTART_RESTARTBLOCK:
	case -ERESTARTNOHAND:
		regs-&gt;eax &#x3D;-EINTR;
		break;
	case -ERESTARTSYS:
		if(!(ka-&gt;sa.sa_flags &amp; SA_RESTART))&#123;
			regs-&gt;eax &#x3D;-EINTR;
			break;
		&#125;
	&#x2F;* fallthrough *&#x2F;
	case -ERESTARTNOINTR:
		regs-&gt;eax &#x3D; regs-&gt;orig_eax;
		regs-&gt;eip -&#x3D; 2;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果系统调用必须被重新开始执行，<code>handle_signal()</code>就与<code>do_signal()</code>完全一样地继续执行；否则，它向用户态进程返回一个出错码<code>-EINTR</code>。</p>
<h3 id="与信号处理相关的系统调用"><a href="#与信号处理相关的系统调用" class="headerlink" title="与信号处理相关的系统调用"></a>与信号处理相关的系统调用</h3><h4 id="kill-系统调用"><a href="#kill-系统调用" class="headerlink" title="kill()系统调用"></a>kill()系统调用</h4><p>一般用<code>kill(pid,sig)</code>系统调用向普通进程或多线程应用发送信号，其相应的服务例程是<code>sys_kill()</code>函数。整数参数<code>pid</code>的几个含义取决于它的值：</p>
<ol>
<li><p>pid &gt; 0 :把sig信号发送器pid等于pid的进程所属进程组</p>
</li>
<li><p>pid = 0: 把sig信号发送到与调用进程同组的进程的所有进程组</p>
</li>
<li><p>pid = -1: 把信号发送到所有进程除了pid为0，1和当前进程以外的所有进程组</p>
</li>
<li><p>pid &lt; -1:把信号发送到进程组-pid中进程的所有进程组 </p>
<p><code>sys_kill()</code>函数为信号建立最小的<code>siginfo_t</code>表，然后调用<code>kill_something_info()</code>函数：</p>
</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">info.si_signo &#x3D; sig;
info.si_errno &#x3D; 0;
info.si_code &#x3D; SI_USER;
info._sifields._kill._pid &#x3D; current-&gt;tgid;
info._sifields._kill._uid &#x3D; current-&gt;uid;
return kill_something_info(sig,&amp;info,pid);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>kill_something_info</code>还依次调用<code>kill_proc_info()</code>(通过<code>group_send_sig_info()</code>向一个单独的线程组发送信号)，或者调用<code>kill_pg_info()</code>(扫描目标进程组的所有进程，并为目标进程组中的每个进程调用<code>send_sig_info()</code>)，或者为系统中的所有进程反复调用<code>group_send_sig_info()</code>(如果<code>pid</code>等于<code>-1</code>)。</p>
<p><code>kill()</code>系统调用能发送任何信号，即使编号在<code>32~64</code>之间的实时信号。然而，我们在前面“产生信号”一节已看到，<code>kill()</code>系统调用不能确保把一个新的元素加入到目标进程的挂起信号队列，因此，挂起信号的多个实例可能被丢失。实时信号应当通过<code>rt_sigqueueinfo()</code>系统调用进行发送。</p>
<h4 id="tkill-和tgkill-系统调用"><a href="#tkill-和tgkill-系统调用" class="headerlink" title="tkill()和tgkill()系统调用"></a>tkill()和tgkill()系统调用</h4><p><code>tkill()</code>和<code>tgkill()</code>系统调用向线程组中的指定进程发送信号。所有遵循<code>POSIX</code>标准的<code>pthread</code>库的<code>pthread_kill()</code>函数，都是调用这两个函数中的任意一个向指定的轻量级进程发送信号。</p>
<p><code>tkill()</code>系统调用需要两个参数：信号接收进程的<code>pid PID</code>和信号编号<code>sig</code>。<code>sys_tkill()</code>服务例程为<code>siginfo</code>表赋值、获取进程描述符地址、进行许可性检查并调用<code>specific_send_sig_info()</code>发送信号。</p>
<p><code>tgkill()</code>系统调用和<code>tkill()</code>有所不同，<code>tgkill()</code>还需要第三个参数：信号接收进程所在线程组的线程组<code>ID(tgid)</code>。<code>sys_tgkill()</code>服务例程执行的操作与<code>sys_tkill()</code>完全一样，不过还要检查信号接收进程是否确实属于线程组<code>tgid</code>。这个附加的检查解决了在向一个正在被杀死的进程发送消息时出现的竞争条件的问题：如果另外一个多线程应用正以足够快的速度创建轻量级进程，信号就可能被传递给一个错误的进程。因为线程组<code>ID</code>在多线程应用的整个生存期中是不会改变的，所以系统调用<code>tgkill()</code>解决了这个问题。</p>
<h3 id="改变信号的操作"><a href="#改变信号的操作" class="headerlink" title="改变信号的操作"></a>改变信号的操作</h3><p><code>sigaction(sig,act,oact)</code>系统调用允许用户为信号指定一个操作。当然，如果没有自定义的信号操作，那么内核执行与传递的信号相关的缺省操作。相应的<code>sys_sigaction()</code>服务例程作用于两个参数：<code>sig</code>信号编号和类型为<code>old_sigaction</code> 的<code>act</code>表(表示新的操作)。第三个可选的输出参数<code>oact</code>可以用来获得与信号相关的以前的操作。(<code>old_sigaction</code>数据结构包括与<code>sigaction</code>结构相同的字段，只是字段的顺序不同)。这个函数首先检查<code>act</code>地址的有效性。然后用<code>*act</code>相应的字段填充类型为<code>k_sigaction</code> 的<code>new_ka</code>局部变量的<code>sa_handler、sa_flags</code>和<code>sa_mask</code>字段：</p>
<pre class="line-numbers language-none"><code class="language-none">_get_user(new_ka.sa.sa_handler,&amp;act-&gt;sa_handler);
__get_user(new_ka.sa.sa_flags,&amp;act-&gt;sa_flags);
-_get_user(mask,&amp;act-&gt;sa_mask);
siginitset(&amp;new_ka.sa.sa_mask,mask);
1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数还调用<code>do_sigaction()</code>把新的<code>new_ka</code>表拷贝到<code>current-&gt;sig-&gt;action</code>的在<code>sig-1</code>位置的表项中(信号的编号大于在数组中的位置，因为没有<code>0</code>信号)：</p>
<pre class="line-numbers language-none"><code class="language-none">k &#x3D;&amp;current-&gt;sig-&gt;action[sig-1];
if(act)&#123;
	*k &#x3D;*act;
	sigdelsetmask(&amp;k-&gt;sa.sa_mask, sigmask(SIGKILL)I sigmask(SIGSTOP));
	if(k-&gt;sa.sa_handler&#x3D;&#x3D; SIG_IGN  II (k-&gt;sa.sa_handler &#x3D;&#x3D; SIG_DFL &amp;&amp; (sig&#x3D;&#x3D;SIGCONT lI sig&#x3D;&#x3D;SIGCHLD lI sig&#x3D;&#x3D;SIGWINCH II sig&#x3D;&#x3D;SIGURG)))&#123;
		rm_from_queue(sigmask(sig),&amp;current-&gt;signal-&gt;shared_pending);
		t &#x3D; current;
		do &#123;
			rm_from_queue(sigmask(sig),&amp;current-&gt;pending);
			recalc_sigpending_tsk(t);
			t &#x3D; next_thread(t);
		&#125; while(t !&#x3D; current〉;
	&#125;
&#125;
1234567891011121314<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>POSIX</code>标准规定，当缺省操作是<code>“Ignore”</code>时，把信号操作设置成<code>SIG_IGN</code>或<code>SIG_DFL</code> 将引起同类型的的任一挂起信号被丢弃。此外还要注意，对信号处理程序来说，不论请求屏蔽的信号是什么，<code>SIGKILL</code>和<code>SIGSTOP</code>从不被屏蔽。<code>sigaction()</code>系统调用还允许用户初始化表<code>sigaction</code>的<code>sa_flags</code>字段。在表<code>11-6</code> (本章前面)中，我们列出了这个字段的可能取值及其相关的含义。</p>
<h3 id="检查挂起的阻塞信号"><a href="#检查挂起的阻塞信号" class="headerlink" title="检查挂起的阻塞信号"></a>检查挂起的阻塞信号</h3><p><code>sigpending()</code>系统调用允许进程检查挂起的阻塞信号的集合，也就是说，检查信号被阻塞时已产生的那些信号。相应的服务例程<code>sys_sigpending()</code>只作用于一个参数<code>set</code>，即用户变量的地址，必须将位数组拷贝到这个变量中：</p>
<pre class="line-numbers language-none"><code class="language-none">sigorsets(&amp;pending, &amp;current-&gt;pending.signal, &amp;current-&gt;signal-&gt;shared_pending.signal);
sigandsets(&amp;pending, &amp;current-&gt;blocked, &amp;pending);
copy_to_user(set, &amp;pending, 4);
123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="修改阻塞信号的集合"><a href="#修改阻塞信号的集合" class="headerlink" title="修改阻塞信号的集合"></a>修改阻塞信号的集合</h3><p><code>sigprocmask()</code>系统调用允许进程修改阻塞信号的集合。这个系统调用只应用于常规信号(非实时信号)。相应的<code>sys_sigprocmask()</code>服务例程作用于三个参数：</p>
<ul>
<li><p>oset:进程地址空间的一个指针，指向存放以前为掩码的一个位数组</p>
</li>
<li><p>set: 进程地址空间的一个指针指向包含新位掩码的位数组</p>
</li>
<li><p>how: 一个标志可以有以下列的一个值</p>
<blockquote>
<ul>
<li>SIG_BLOCK:*set位掩码数组中的信号，指定必须加到阻塞信号的位掩码</li>
<li>SIG_UNBLOCK:*set位掩码数组中的信号，指定必须从阻塞信号的位掩码数组中删除的信号</li>
<li>SIGG_SETMASK:*set位掩码数组中的信号，指定阻塞信号新的位掩码数组 </li>
</ul>
</blockquote>
</li>
</ul>
<p><code>sys_sigprocmask()</code>调用<code>copy_from_user()</code>把<code>set</code>参数所指向的值拷贝到局部变量<code>new_set</code>中，并把<code>current</code>标准阻塞信号的位掩码数组拷贝到<code>old_set</code>局部变量中。然后根据<code>how</code>标志来指定这两个变量的值：</p>
<pre class="line-numbers language-none"><code class="language-none">if(copy_from_user(&amp;new_set, set, sizeof(*set)))
	return -EFAULT;
new_set &amp;&#x3D;~(sigmask(SIGKILL) I sigmask(SIGSTOP));
old_set &#x3D; current-&gt;blocked.sig[0];
if(how &#x3D;&#x3D; SIG_BLOCK)
	sigaddsetmask(&amp;current-&gt;blocked, new_set);
else if(how &#x3D;&#x3D; SIG_UNBLOCK)
	sigdelsetmask(&amp;current -&gt;blocked, new_set);
else if(how &#x3D;&#x3D; SIG_SETMASK)
	current-&gt;blocked.sig[0]&#x3D; new_set;
else
	return -EINVAL;
recalc_sigpending(current);
if(oset &amp;&amp; copy_to_user(oset, &amp;old_set, sizeof(*oset)))
	return -EFAULT;
return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="挂起进程"><a href="#挂起进程" class="headerlink" title="挂起进程"></a>挂起进程</h3><p><code>sigsuspend()</code>系统调用把进程置为<code>TASK_INTERRUPTIBLE</code>状态，当然这是把<code>mask</code> 参数指向的位掩码数组所指定的标准信号阻塞以后设置的。只有当一个非忽略、非阻塞的信号发送到进程以后，进程才被唤醒。相应的<code>sys_sigsuspend()</code>服务例程执行下列这些语句：</p>
<pre class="line-numbers language-none"><code class="language-none">mask &amp;&#x3D;~(sigmask(SIGKILL) | sigmask(SIGSTOP));
saveset &#x3D; current-&gt;blocked;
siginitset(&amp;current-&gt;blocked, mask);
recalc_sigpending(current);
regs-&gt;eax &#x3D;-EINTR;
while (1)(
	current-&gt;state &#x3D; TASK_INTERRUPTIBLE;
	schedule(   );
	if(do_signal(regs, &amp;saveset))
		return -EINTR;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>schedule()</code>函数选择另一个进程运行。当发出<code>sigsuspend()</code>系统调用的进程又开始执行时，<code>sys_sigsuspend()</code>调用<code>do_signal()</code>函数来传递唤醒了该进程的信号。如果<code>do_signal()</code>的返回值为<code>1</code>，则不忽略这个信号。因此，这个系统调用返回<code>-EINTR</code>出错码后终止。<code>sigsuspend()</code>系统调用可能看似多余，因为<code>sigprocmask()</code>和<code>sleep()</code>的组合执行显然能产生同样的效果。但这并不正确：这是因为进程可能在任何时候交错执行，你必须意识到调用一个系统调用执行操作<code>A</code>，紧接着又调用另一个系统调用执行操作<code>B</code>，并不等于调用一个单独的系统调用执行操作<code>A</code>，然后执行操作<code>B</code>。</p>
<p>在这种特殊情况中，<code>sigprocmask()</code>可以在调用<code>sleep()</code>之前解除对所传递信号的阻塞。如果这种情况发生，进程就可以一直停留在<code>TASK_INTERRUPTIBLE</code>状态，等待已被传递的信号。另一方面，在解除阻塞之后、<code>schedule()</code>调用之前，因为其他进程在这个时间间隔内无法获得<code>CPU</code>，因此，<code>sigsuspend()</code>系统调用不允许信号被发送。</p>
<h3 id="实时信号的系统调用"><a href="#实时信号的系统调用" class="headerlink" title="实时信号的系统调用"></a>实时信号的系统调用</h3><p>因为前面所提到的系统调用只应用到标准信号，因此，必须引入另外的系统调用来允许用户态进程处理实时信号。实时信号的几个系统调用(<code>rt_sigaction()、rt_sigpending()、rt_sigprocmask()</code>及<code>rt_sigsuspend()</code>)与前面描述的类似，因此不再进一步讨论。</p>
<h1 id="VFS-虚拟文件系统"><a href="#VFS-虚拟文件系统" class="headerlink" title="VFS 虚拟文件系统"></a>VFS 虚拟文件系统</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​    虚拟文件系统(Virtual Filesystem)也可以称之为<strong>虚拟文件系统转换</strong>(Virtual Filesystem Switch)，是一个内核软件层，用来处理与Unix标准文件系统相关的所有系统调用。其健壮性表现在能为各种文件系统提供一个通用的接口。可以认为它屏蔽了不同文件系统之间的实现细节转而依赖它们的接口。<br><img src=".\5da40e939e9b4df9837a38e7215cc105.png" alt="在这里插入图片描述"></p>
<p>VFS支持的文件系统可以划分为三种主要类型：</p>
<ol>
<li>磁盘文件系统<br>这些文件系统管理在本地磁盘分区中可用的存储空间或者其他可以起到磁盘作用的设备(比如说一个USB闪存)。VFS支持的基于磁盘的某些著名文件系统有：Disk-based 文件系统：Ext2, ext3, ReiserFS，Sysv, UFS, MINIX, VxFS，VFAT, NTFS，ISO9660 CD-ROM, UDF DVD，HPFS, HFS, AFFS, ADFS等等</li>
<li>网络文件系统<br>这些文件系统允许轻易地访问属于其他网络计算机的文件系统所包含的文件。虚拟文件系统所支持的一些著名的网络文件系统有：NFS、Coda、AFS(Andrew文件系统)、CIFS(用于Microsoft Windows的通用网络文件系统)以及NCP(Novell 公司的NetWare Core Protocol)。</li>
<li>特殊文件系统<br>这些文件系统不管理本地或者远程磁盘空间。/proc文件系统是特殊文件系统的一个典型范例(参见稍后“特殊文件系统“一节)。</li>
</ol>
<p>​    根目录包含在根文件系统(root filesystem)中，在Linux中这个根文件系统通常就是Ext2或Ext3类型。其他所有的文件系统都可以被“安装“在根文件系统的子目录中基于磁盘的文件系统通常存放在硬件块设备中，如硬盘、软盘或者CD-ROM。Linux VFS 的一个有用特点是能够处理如/dev/loop0这样的虚拟块设备，这种设备可以用来安装普通文件所在的文件系统。作为一种可能的应用，用户可以保护自己的私有文件系统，这可以通过把自己文件系统的加密版本存放在一个普通文件中来实现。</p>
<h2 id="通用文件模型"><a href="#通用文件模型" class="headerlink" title="通用文件模型"></a>通用文件模型</h2><p>​    <strong>VFS所隐含的主要思想在于引入了一个通用的文件模型(common file model)，这个模型能够表示所有支持的文件系统。该模型严格反映传统Unix文件系统提供的文件模型。</strong></p>
<p>​    例如，在通用文件模型中，每个目录被看作一个文件，可以包含若干文件和其他的子目录。但是，存在几个非Unix的基于磁盘的文件系统，它们利用文件分配表(File Allocation Table，FAT)存放每个文件在目录树中的位置，在这些文件系统中，存放的是目录而不是文件。<strong>为了符合VFS的通用文件模型，对上述基于FAT的文件系统的实现，Linux必须在必要时能够快速建立对应于目录的文件。这样的文件只作为内核内存的对象而存在。</strong></p>
<p>​    从本质上说，Linux内核不能对一个特定的函数进行硬编码来执行诸如read()或ioctl()这样的操作，<strong>而是对每个操作都必须使用一个指针，指向要访问的具体文件系统的适当函数为了进一步说明这一概念</strong>，参见图12-1，其中显示了内核如何把read()转换为专对MS-DOS文件系统的一个调用。应用程序对read()的调用引起内核调用相应的sys_read()服务例程，这与其他系统调用完全类似。</p>
<p>​    文件在内核内存中是由一个file数据结构来表示的。这种数据结构中包含一个称为f_op的字段，该字段中包含一个指向专对MS-DOS文件的函数指针，当然还包括读文件的函数。sys_read()查找到指向该函数的指针，并调用它。这样一来，应用程序的read()就被转化为相对间接的调用：file-&gt;f_op-&gt;read(…);与之类似，write()操作也会引发一个与输出文件相关的Ext2写函数的执行。简而言之，内核负责把一组合适的指针分配给与每个打开文件相关的file变量，然后负责调用针对每个具体文件系统的函数(由f_op字段指向)。（人话，调用具体的函数指针，想想虚函数表）</p>
<p>通用文件模型有下列对象组成：</p>
<ul>
<li>超级块对象存放在已安装文件系统的有关信息，对基于磁盘的文件系统，，它们通常对应于存放在磁盘上的文件控制块</li>
<li>索引节点对象：也就是Iinode存放关于具体文件的一般信息</li>
<li>文件对象：存放打开文件与进程之间进行交互的有关信息，这类信息仅当进程访问文件期间存在于内核内存中！</li>
<li>目录项对象：存放目录项与对应文件进行链接的有关信息 </li>
</ul>
<p>​    如图12-2所示是一个简单的示例，说明进程怎样与文件进行交互。三个不同进程已经打开同一个文件，其中两个进程使用同一个硬链接。在这种情况下，其中的每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引节点对象，该索引节点对象标识超级块对象，以及随后的普通磁盘文件。<br><img src=".\a7c47690ee4b414daa8e655b0080e301.png" alt="在这里插入图片描述"><br>​    VFS除了能为所有文件系统的实现提供一个通用接口外，还具有另一个与系统性能相关的重要作用。最近最常使用的目录项对象被放在所谓目录项高速缓存(dentrycache)的磁盘高速缓存中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。</p>
<p>​    一般说来，磁盘高速缓存(diskcache)属于软件机制，它允许内核将原本存在磁盘上的某些信息保存在RAM中，以便对这些数据的进一步访问能快速进行，而不必慢速访问磁盘本身。</p>
<p>​    注意，磁盘高速缓存不同于硬件高速缓存（硬件高速缓存）或内存高速缓存（动态内存分配器），后两者都与磁盘或其他设备无关。硬件高速缓存是一个快速静态RAM，它加快了直接对慢速动态RAM的请求。内存高速缓存是一种软件机制，引入它是为了绕过内核内存分配器。除了目录项高速缓存和索引结点高速缓存之外，Linux还使用其他磁盘高速缓存。其中最重要的一种就是所谓的页高速缓存。</p>
<h3 id="VFS所处理的系统调用"><a href="#VFS所处理的系统调用" class="headerlink" title="VFS所处理的系统调用"></a>VFS所处理的系统调用</h3><p>​    表12-1列出了VFS的系统调用，这些系统调用涉及文件系统、普通文件、目录文件以及符号链接文件。另外还有少数几个由VFS处理的其他系统调用，诸如ioperm()、ioctl()、pipe()和mknod()，涉及设备文件和管道文件，这些将在后续章节中讨论。最后一组由VFS处理的系统调用，诸如socket()、connect()和bind()属于套接字系统调用，并用于实现网络功能。与表12-1列出的系统调用对应的一些内核服务例程，我们会在本章或第十八章中陆续进行讨论。</p>
<ul>
<li>文件系统相关：mount, umount, umount2, sysfs,  statfs,  fstatfs,  fstatfs64, ustat</li>
<li>目录相关：chroot，pivot_root，chdir，fchdir，getcwd，mkdir，rmdir，getdents，getdents64，readdir，link，unlink，rename，lookup_dcookie</li>
<li>链接相关：readlink，symlink</li>
<li>文件相关：chown， fchown，lchown，chown16，fchown16，lchown16，hmod，fchmod，utime，stat，fstat，lstat，acess，oldstat，oldfstat，oldlstat，stat64，lstat64，lstat64，open，close，creat，umask，dup，dup2，fcntl， fcntl64，select，poll，truncate，ftruncate，truncate64，ftruncate64，lseek，llseek，read，write，readv，writev，sendfile，sendfile64，readahead</li>
</ul>
<p>前面我们已经提到，VFS是应用程序和具体文件系统之间的一层。不过，在某些情况下，一个文件操作可能由VFS本身去执行，无需调用低层函数。例如，当某个进程关闭一个打开的文件时，并不需要涉及磁盘上的相应文件，因此VFS只需释放对应的文件对象。类似地，当系统调用lseek()修改一个文件指针，而这个文件指针是打开文件与进程交互所涉及的一个属性时，VFS就只需修改对应的文件对象，而不必访问磁盘上的文件，因此，无需调用具体文件系统的函数。从某种意义上说，可以把VFS看成“通用“文件系统，它在必要时依赖某种具体文件系统。</p>
<h3 id="VFS的数据结构"><a href="#VFS的数据结构" class="headerlink" title="VFS的数据结构"></a>VFS的数据结构</h3><p>每个VFS对象都存放在一个适当的数据结构中，其中包括对象的属性和指向对象方法表的指针。内核可以动态地修改对象的方法，因此可以为对象建立专用的行为。下面几节详细介绍VFS的对象及其内在关系。</p>
<h3 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h3><p>超级块对象由super_block结构组成，表12-2列举了其中的字段。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s_list</td>
<td>指向超级块链表的指针，这个struct list_head是很熟悉的结构了，里面其实就是用于连接关系的prev和next字段。内核中的结构处理都是有讲究的(内核协议栈中也说过)，内核单独使用一个简单的结构体将所有的super_block都链接起来，但是这个结构不是super_block本身，因为本身数据结构太大，效率不高，所有仅仅使用<br>`struct{list_head prev;list_head next;}这样的结构来将super_block中的s_list链接起来，那么遍历到s_list之后，直接读取super_block这么长的一个内存块，就可以将这个这个块读取进来</td>
</tr>
<tr>
<td>s_dev</td>
<td>包含该具体文件系统的块设备标识符。例如，对于 /dev/hda1，其设备标识符为 0x301</td>
</tr>
<tr>
<td>s_blocksize</td>
<td>文件系统中数据块大小，以字节单位</td>
</tr>
<tr>
<td>s_blocksize_bits</td>
<td>上面的size大小占用位数，例如512字节就是9 bits</td>
</tr>
<tr>
<td>s_dirt</td>
<td>脏位，标识是否超级块被修改</td>
</tr>
<tr>
<td>s_maxbytes</td>
<td>允许的最大的文件大小(字节数)</td>
</tr>
<tr>
<td>struct file_system_type *s_type</td>
<td>文件系统类型(也就是当前这个文件系统属于哪个类型？ext2还是fat32)要区分“文件系统”和“文件系统类型”不一样！一个文件系统类型下可以包括很多文件系统即很多的super_block，后面会说！</td>
</tr>
<tr>
<td>struct super_operations *s_op</td>
<td>指向某个特定的具体文件系统的用于超级块操作的函数集合</td>
</tr>
<tr>
<td>struct dquot_operations *dq_op</td>
<td>指向某个特定的具体文件系统用于限额操作的函数集合</td>
</tr>
<tr>
<td>struct quotactl_ops   *s_qcop</td>
<td>用于配置磁盘限额的的方法，处理来自用户空间的请求</td>
</tr>
<tr>
<td>s_magic</td>
<td>区别于其他文件系统的标识</td>
</tr>
<tr>
<td>s_root</td>
<td>指向该具体文件系统安装目录的目录项</td>
</tr>
<tr>
<td>s_flags</td>
<td>安装标识</td>
</tr>
<tr>
<td>s_umount：</td>
<td>对超级块读写时进行同步</td>
</tr>
<tr>
<td>s_lock：</td>
<td>锁标志位，若置该位，则其它进程不能对该超级块操作</td>
</tr>
<tr>
<td>s_count：</td>
<td>对超级块的使用计数</td>
</tr>
<tr>
<td>s_active：</td>
<td>引用计数</td>
</tr>
<tr>
<td>s_dirty：</td>
<td>已修改的索引节点inode形成的链表，一个文件系统中有很多的inode，有些inode节点的内容会被修改，那么会先被记录，然后写回磁盘。</td>
</tr>
<tr>
<td>s_locked_inodes：</td>
<td>要进行同步的索引节点形成的链表</td>
</tr>
<tr>
<td>s_files：</td>
<td>所有的已经打开文件的链表，这个file和实实在在的进程相关的</td>
</tr>
<tr>
<td>s_bdev：</td>
<td>指向文件系统被安装的块设备</td>
</tr>
<tr>
<td>u：</td>
<td><em>u</em> 联合体域包括属于具体文件系统的超级块信息</td>
</tr>
<tr>
<td>s_instances：</td>
<td>具体的意义后来会说的！(同一类型的文件系统通过这个子墩将所有的super_block连接起来)</td>
</tr>
<tr>
<td>s_dquot：</td>
<td>磁盘限额相关选项</td>
</tr>
</tbody>
</table>
</div>
<p>​    所有超级块对象都以双向循环链表的形式链接在一起。链表中第一个元素用super_blocks变量来表示，而超级块对象的s_list字段存放指向链表相邻元素的指针。sb_lock自旋锁保护链表免受多处理器系统上的同时访问。</p>
<p>​    s_fs_info字段指向属于具体文件系统的超级块信息；例如，假如超级块对象指的是Ext2文件系统，该字段就指向ext2_sb_info数据结构，该结构包括磁盘分配位掩码和其他与VFS的通用文件模型无关的数据。通常，为了效率起见，由s_fs_info字段所指向的数据被复制到内存。任何基于磁盘的文件系统都需要访问和更改自己的磁盘分配位图，以便分配或释放磁盘块。VFS允许这些文件系统直接对内存超级块的s_fs_info字段进行操作，而无需访问磁盘。但是，这种方法带来一个新问题：有可能VFS超级块最终不再与磁盘上相应的超级块同步。<br>​    </p>
<p>​    因此，有必要引入一个s_dirt标志来表示该超级块是否是脏的——那磁盘上的数据是否必须要更新。缺乏同步还会导致产生我们熟悉的一个问题：当一台机器的电源突然断开而用户来不及正常关闭系统时，就会出现文件系统崩溃。Linux是通过周期性地将所有“脏“的超级块写回磁盘来减少该问题带来的危害。</p>
<p>​    与超级块关联的方法就是所谓的超级块操作。这些操作是由数据结构super_operations 来描述的，该结构的起始地址存放在超级块的s_op字段中。每个具体的文件系统都可以定义自己的超级块操作。当VFS需要调用其中一个操作时，比如说read_inode()，它执行下列操作：sb-&gt;s_op-&gt;read_inode(inode);这里sb存放所涉及超级块对象的地址。super_operations表的read_inode字段存放这一函数的地址，因此，这一函数被直接调用。让我们简要描述一下超级块操作，其中实现了一些高级操作，比如删除文件或安装磁盘。下面这些操作按照它们在super_operation表中出现的顺序来排列：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc_inode</td>
<td>被inode_alloc()函数调用用于分配inode内存并进行inode结构初始化。如果函数未定义，则简单的分配一个’struct inode’。通常<em>alloc_inode</em>用于底层文件系统分配一个包含inode结构体的更大的结构体（特定的inode结构，如：fuse_inode）。</td>
</tr>
<tr>
<td><em>destroy_inode</em>：</td>
<td>被destroy_inode()函数调用用于释放inode相关申请的资源。只有<em>alloc_inode</em>定义了才需要定义<em>destroy_inode</em>，并且释放的也是<em>alloc_inode</em>里申请的相关资源。</td>
</tr>
<tr>
<td><em>dirty_inode</em>：</td>
<td>由VFS调用标记inode dirty（元数据信息被修改过并且没有同步到磁盘或服务器）。</td>
</tr>
<tr>
<td><em>write_inode</em>：</td>
<td>由VFS调用用于将inode同步到磁盘。第二个参数用于标识是否同步写盘</td>
</tr>
<tr>
<td><em>drop_inode</em>：</td>
<td>VFS在当inode的引用计数减为0时，调用该函数。调用者已经持有了inode-&gt;i_lock。该函数返回0，则inode将可能被丢到LRU链表里，返回1则会由调用者继续调用<em>evict_inode</em>和<em>destroy_inode</em>。如果文件系统不需要缓存inode，则该函数可以设置为NULL或者generic_delete_inode（函数里直接return 1）</td>
</tr>
<tr>
<td><em>delete_inode</em>：</td>
<td>VFS删除inode时直接调用该函数。由于查看的Linux文档版本是2.6.39，所以有该函数指针，在3.10版本已经没有了<em>detele_inode</em>。</td>
</tr>
<tr>
<td><em>put_super</em>：</td>
<td>VFS想要释放sb时调用（如umount操作）。调用者已经持有sb的lock。</td>
</tr>
<tr>
<td><em>sync_fs</em>：</td>
<td>VFS想要把该文件系统所有的脏数据刷盘时调用。</td>
</tr>
<tr>
<td><em>freeze_fs</em>：</td>
<td>目前只有LVM使用。用于冻结文件系统，不能进行写入操作</td>
</tr>
<tr>
<td><em>unfreeze_fs</em>：</td>
<td>解冻文件系统，使其可以写入。</td>
</tr>
<tr>
<td><em>statfs</em>：</td>
<td>用于获取文件系统的统计信息。</td>
</tr>
<tr>
<td><em>remount_fs</em>：</td>
<td>用于重新挂载文件系统，调用者持有kernel lock。</td>
</tr>
<tr>
<td><em>clear_inode</em>：</td>
<td>同样在3.10版本没有了。</td>
</tr>
<tr>
<td><em>umount_begin</em>：</td>
<td>用于umount文件系统。</td>
</tr>
<tr>
<td><em>show_options</em>：</td>
<td>用于/proc/mounts里显示文件系统的mount选项。</td>
</tr>
<tr>
<td><em>quota_read</em>和<em>quota_write</em>：</td>
<td>用于读写文件系统的quota文件。</td>
</tr>
<tr>
<td><em>nr_cached_objects</em>和<em>free_cache_objects</em></td>
<td>用于返回可以释放的cache对象个数，以及进行实际的释放对象操作。</td>
</tr>
</tbody>
</table>
</div>
<p>​    前述的方法对所有可能的文件系统类型均是可用的。但是，只有其中的一个子集应用到每个具体的文件系统；未实现的方法对应的字段置为NULL。注意，系统没有定义get_super方法来读超级块，那么，内核如何能够调用一个对象的方法而从磁盘读出该对象？我们将在描述文件系统类型的另一个对象中找到等价的get_sb方法。</p>
<h3 id="索引节点对象（inode）"><a href="#索引节点对象（inode）" class="headerlink" title="索引节点对象（inode）"></a>索引节点对象（inode）</h3><p>文件系统处理文件所需要的所有信息都放在一个名为索引节点的数据结构中。文件名可以随时更改，但是索引节点对文件是唯一的，并且随文件的存在而存在。内存中的索引节点对象由一个inode数据结构组成，其字段如表12-3所示。</p>
<pre class="line-numbers language-none"><code class="language-none">struct inode &#123;
	umode_t			i_mode;   &#x2F;* 访问权限 *&#x2F;
	unsigned short		i_opflags; 
	kuid_t			i_uid; &#x2F;* 使用者id *&#x2F;
	kgid_t			i_gid; &#x2F;* 使用组id *&#x2F;
	unsigned int		i_flags; &#x2F;* 文件系统标志 *&#x2F;
#ifdef CONFIG_FS_POSIX_ACL
	struct posix_acl	*i_acl; &#x2F;* 访问控制列表相关 *&#x2F;
	struct posix_acl	*i_default_acl;
#endif
	const struct inode_operations	*i_op; &#x2F;* 索引节点操作函数 *&#x2F;
	struct super_block	*i_sb; &#x2F;* 所属的超级块 *&#x2F;
	struct address_space	*i_mapping; &#x2F;* 地址映射 *&#x2F;
#ifdef CONFIG_SECURITY
	void			*i_security; &#x2F;* 安全模块 *&#x2F;
#endif
	&#x2F;* Stat data, not accessed from path walking *&#x2F;
	unsigned long		i_ino; &#x2F;* 节点号 *&#x2F;
	&#x2F;*
	 * Filesystems may only read i_nlink directly.  They shall use the
	 * following functions for modification:
	 *
	 *    (set|clear|inc|drop)_nlink
	 *    inode_(inc|dec)_link_count
	 *&#x2F;
	union &#123;
		const unsigned int i_nlink;
		unsigned int __i_nlink; &#x2F;*硬链接数，对于目录来说，是子目录数目*&#x2F;
	&#125;;
	dev_t			i_rdev; &#x2F;* 实际设备标识符 *&#x2F;
	loff_t			i_size; &#x2F;* 以字节为单位的文件大小 *&#x2F;
	struct timespec		i_atime; &#x2F;* 最后访问时间 *&#x2F;
	struct timespec		i_mtime; &#x2F;* 最后修改时间 *&#x2F;
	struct timespec		i_ctime; &#x2F;* 最后改变时间 *&#x2F;
	spinlock_t		i_lock;	&#x2F;* i_blocks, i_bytes, maybe i_size *&#x2F;
	unsigned short          i_bytes;
	unsigned int		i_blkbits;
	blkcnt_t		i_blocks;
#ifdef __NEED_I_SIZE_ORDERED
	seqcount_t		i_size_seqcount; &#x2F;* 对i_size进行串行计数 *&#x2F;
#endif
	&#x2F;* Misc *&#x2F;
	unsigned long		i_state; &#x2F;* 状态标志 *&#x2F;
	struct rw_semaphore	i_rwsem;
	unsigned long		dirtied_when;	&#x2F;* jiffies of first dirtying *&#x2F;
	unsigned long		dirtied_time_when; 
	struct hlist_node	i_hash;  &#x2F;*散列表，用于快速查找inode *&#x2F;
	struct list_head	i_io_list;	&#x2F;* backing dev IO list *&#x2F;
#ifdef CONFIG_CGROUP_WRITEBACK
	struct bdi_writeback	*i_wb;		&#x2F;* the associated cgroup wb *&#x2F;
	&#x2F;* foreign inode detection, see wbc_detach_inode() *&#x2F;
	int			i_wb_frn_winner;
	u16			i_wb_frn_avg_time;
	u16			i_wb_frn_history;
#endif
	struct list_head	i_lru;		&#x2F;* inode LRU list *&#x2F;
	struct list_head	i_sb_list; &#x2F;* 超级块链表 *&#x2F;
	struct list_head	i_wb_list;	&#x2F;* backing dev writeback list *&#x2F;
	union &#123;
		struct hlist_head	i_dentry; &#x2F;* 目录项链表 *&#x2F;
		struct rcu_head		i_rcu;
	&#125;;
	u64			i_version;
	atomic_t		i_count; &#x2F;* 引用计数 *&#x2F;
	atomic_t		i_dio_count;
	atomic_t		i_writecount; &#x2F;* 写者计数 *&#x2F;
#ifdef CONFIG_IMA
	atomic_t		i_readcount; &#x2F;* struct files open RO *&#x2F;
#endif
	const struct file_operations	*i_fop;	&#x2F;* 缺省的索引节点操作 former -&gt;i_op-&gt;default_file_ops *&#x2F;
	struct file_lock_context	*i_flctx;
	struct address_space	i_data; &#x2F;* 设备地址映射 *&#x2F;
	struct list_head	i_devices; &#x2F;* 块设备链表 *&#x2F;
	union &#123;
		struct pipe_inode_info	*i_pipe; &#x2F;* 管道信息 *&#x2F;
		struct block_device	*i_bdev;  &#x2F;* 块设备信息 *&#x2F;
		struct cdev		*i_cdev; &#x2F;* 字符设备信息 *&#x2F;
		char			*i_link; 
		unsigned		i_dir_seq;
	&#125;;
	__u32			i_generation;
#ifdef CONFIG_FSNOTIFY
	__u32			i_fsnotify_mask; &#x2F;* all events this inode cares about *&#x2F;
	struct hlist_head	i_fsnotify_marks; 
#endif
#if IS_ENABLED(CONFIG_FS_ENCRYPTION)
	struct fscrypt_info	*i_crypt_info;
#endif
	void			*i_private; &#x2F;* fs or device private pointer *&#x2F;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_hash：</td>
<td>指向hash链表指针，用于inode的hash表</td>
</tr>
<tr>
<td>i_list：</td>
<td>指向索引节点链表指针，用于inode之间的连接</td>
</tr>
<tr>
<td>i_dentry：</td>
<td>指向目录项链表指针，注意一个inodes可以对应多个dentry，因为一个实际的文件可能被链接到其他的文件，那么就会有另一个dentry，这个链表就是将所有的与本inode有关的dentry都连在一起。</td>
</tr>
<tr>
<td>i_dirty_buffers和i_dirty_data_buffers：</td>
<td>脏数据缓冲区</td>
</tr>
<tr>
<td>i_ino：</td>
<td>索引节点号，每个inode都是唯一的</td>
</tr>
<tr>
<td>i_count：</td>
<td>引用计数</td>
</tr>
<tr>
<td>i_dev：</td>
<td>如果inode代表设备，那么就是设备号</td>
</tr>
<tr>
<td>i_mode：</td>
<td>文件的类型和访问权限</td>
</tr>
<tr>
<td>i_nlink：</td>
<td>与该节点建立链接的文件数(硬链接数)</td>
</tr>
<tr>
<td>i_uid：</td>
<td>文件拥有者标号</td>
</tr>
<tr>
<td>i_gid：</td>
<td>文件所在组标号</td>
</tr>
<tr>
<td>i_rdev：</td>
<td>实际的设备标识（注意i_dev和i_rdev之间区别：如果是普通的文件，例如磁盘文件，存储在某块磁盘上，那么i_dev代表的就是保存这个文件的磁盘号，但是如果此处是特殊文件例如就是磁盘本身(因为所有的设备也看做文件处理)，那么i_rdev就代表这个磁盘实际的磁盘号。）</td>
</tr>
<tr>
<td>i_size：</td>
<td>inode所代表的的文件的大小，以字节为单位</td>
</tr>
<tr>
<td>i_atime：</td>
<td>文件最后一次访问时间</td>
</tr>
<tr>
<td>i_mtime：</td>
<td>文件最后一次修改时间</td>
</tr>
<tr>
<td>i_ctime：</td>
<td>inode最后一次修改时间</td>
</tr>
<tr>
<td>i_blkbits：</td>
<td>单位块大小，字节</td>
</tr>
<tr>
<td>i_blksize：</td>
<td>块大小，bit单位</td>
</tr>
<tr>
<td>i_blocks：</td>
<td>文件所占块数</td>
</tr>
<tr>
<td>i_version：</td>
<td>版本号</td>
</tr>
<tr>
<td>i_bytes：</td>
<td>文件中最后一个块的字节数</td>
</tr>
<tr>
<td>i_sem：</td>
<td>指向用于同步操作的信号量结构</td>
</tr>
<tr>
<td>i_alloc_sem：</td>
<td>保护inode上的IO操作不被另一个打断</td>
</tr>
<tr>
<td>i_zombie：</td>
<td>僵尸inode信号量</td>
</tr>
<tr>
<td>i_op：</td>
<td>索引节点操作</td>
</tr>
<tr>
<td>i_fop：</td>
<td>文件操作</td>
</tr>
<tr>
<td>i_sb：</td>
<td>inode所属文件系统的超级块指针</td>
</tr>
<tr>
<td>i_wait：</td>
<td>指向索引节点等待队列指针</td>
</tr>
<tr>
<td>i_flock：</td>
<td>文件锁链表（注意：address_space不是代表某个地址空间，而是用于描述页高速缓存中的页面的。一个文件对应一个address_space，一个address_space和一个偏移量可以确定一个页高速缓存中的页面。）</td>
</tr>
<tr>
<td>i_mapping：</td>
<td>表示向谁请求页面</td>
</tr>
<tr>
<td>i_data：</td>
<td>表示被inode读写的页面</td>
</tr>
<tr>
<td>i_dquot：</td>
<td>inode的磁盘限额（关于磁盘限额：在多任务环境下，对于每个用户的磁盘使用限制是必须的，起到一个公平性作用。磁盘限额分为两种：block限额和inode限额，而且对于一个特文件系统来说，使用的限额机制都是一样的，所以限额的操作函数放在super_block中就OK！）</td>
</tr>
<tr>
<td>i_devices：</td>
<td>设备链表。共用同一个驱动程序的设备形成的链表</td>
</tr>
<tr>
<td>i_pipe：</td>
<td>指向管道文件（如果文件是管道文件时使用）</td>
</tr>
<tr>
<td>i_bdev：</td>
<td>指向块设备文件指针（如果文件是块设备文件时使用）</td>
</tr>
<tr>
<td>i_cdev：</td>
<td>指向字符设备文件指针（如果文件是字符设备时使用）</td>
</tr>
<tr>
<td>i_dnotify_mask：</td>
<td>目录通知事件掩码</td>
</tr>
<tr>
<td>i_dnotify：</td>
<td>用于目录通知</td>
</tr>
<tr>
<td>i_state：</td>
<td>索引节点的状态标识：I_NEW，I_LOCK，I_FREEING</td>
</tr>
<tr>
<td>i_flags：</td>
<td>索引节点的安装标识</td>
</tr>
<tr>
<td>i_sock：</td>
<td>如果是套接字文件则为True</td>
</tr>
<tr>
<td>i_write_count：</td>
<td>记录多少进程以刻写模式打开此文件</td>
</tr>
<tr>
<td>i_attr_flags：</td>
<td>文件创建标识</td>
</tr>
<tr>
<td>i_generation：</td>
<td>保留</td>
</tr>
<tr>
<td>u：</td>
<td>具体的inode信息</td>
</tr>
</tbody>
</table>
</div>
<p>​    每个索引节点对象都会复制磁盘索引节点包含的一些数据，比如分配给文件的磁盘块数。如果i_state字段的值等于I_DIRTY_SYNC、I_DIRTY_DATASYNC或I_DIRTY_PAGES，该索引节点就是“脏“的，也就是说，对应的磁盘索引节点必须被更新。I_DIRTY宏可以用来立即检查这三个标志的值。i_state字段的其他值有I_LOCK(涉及的索引节点对象处于I/O传送中)、I_FREEING(索引节点对象正在被释放)、I_CLEAR(索引节点对象的内容不再有意义)以及I_NEW(索引节点对象已经分配但还没有用从磁盘索引节点读取来的数据填充)。</p>
<p>每个索引节点对象总是出现在下列双向循环链表的某个链表中(所有情况下，指向相邻元素的指针存放在i_list字段中):</p>
<ol>
<li>有效未使用的索引节点链表，典型的如那些镜像有效的磁盘索引节点，且当前未被任何进程使用。这些索引节点不为脏，且它们的i_count字段置为0。链表中的首元素和尾元素是由变量inode_unused的next字段和prev字段分别指向的。这个链表用作磁盘高速缓存。</li>
<li>正在使用的索引节点链表，也就是那些镜像有效的磁盘索引节点，且当前被某些进程使用。这些索引节点不为脏，但它们的i_count字段为正数。链表中的首元素和尾元素是由变量inode_in_use引用的。</li>
<li>脏索引节点的链表。链表中的首元素和尾元素是由相应超级块对象的s_dirty字段引用的。这些链表都是通过适当的索引节点对象的i_list字段链接在一起的。</li>
</ol>
<p>​    此外，每个索引节点对象也包含在每文件系统(per-filesystem)的双向循环链表中，链表的头存放在超级块对象的s_inodes字段中；索引节点对象的i_sb_list字段存放了指向链表相邻元素的指针。</p>
<p>​    最后，索引节点对象也存放在一个称为inode_hashtable的散列表中。散列表加快了对索引节点对象的搜索，前提是系统内核要知道索引节点号及文件所在文件系统对应的超级块对象的地址。由于散列技术可能引发冲突，所以索引节点对象包含一个i_hash字段，该字段中包含向前和向后的两个指针，分别指向散列到同一地址的前一个索引节点和后一个索引节点；该字段因此创建了由这些索引节点组成的一个双向链表。</p>
<p>​    与索引节点对象关联的方法也叫索引节点操作。它们由inode_operations结构来描述，该结构的地址存放在i_op字段中。以下是索引节点的操作，以它们在inode_operations表中出现的次序来排列：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>create(dir, dentry, mode, nameidata)</td>
<td>在某一目录下，为与目录项对象相关的普通文件创建一个新的磁盘索引节点。</td>
</tr>
<tr>
<td>lookup(dir, dentry, nameidata)</td>
<td>为包含在一个目录项对象中的文件名对应的索引节点查找目录。</td>
</tr>
<tr>
<td>link(old_dentry, dir, new_dentry)</td>
<td>创建一个新的名为new＿dentry的硬链接，它指向dir目录下名为old＿dentry的文件。</td>
</tr>
<tr>
<td>unlink(dir, dentry)</td>
<td>从一个目录中删除目录项对象所指定文件的硬链接。</td>
</tr>
<tr>
<td>symlink(dir, dentry, symname)</td>
<td>在某个目录下，为与目录项对象相关的符号链接创建一个新的索引节点。</td>
</tr>
<tr>
<td>mkdir(dir, dentry, mode)</td>
<td>在某个目录下，为与目录项对象相关的目录创建一个新的索引节点。</td>
</tr>
<tr>
<td>rmdir(dir, dentry)</td>
<td>从一个目录删除子目录，子目录的名称包含在目录项对象中。</td>
</tr>
<tr>
<td>mknod(dir, dentry, mode, rdev)</td>
<td>在某个目录中位于目录项对象相关的特定文件创建一个新的磁盘索引节点！其中参数mode和rdev分别表示文件的类型和设备的</td>
</tr>
<tr>
<td>rename(old_dir, old_dentry, new_dir, new_dentry)</td>
<td>将old＿dir目录下由old＿entry标识的文件移到new＿dir目录下。新文件名包含在new＿dentry指向的目录项对象中。</td>
</tr>
<tr>
<td>readlink(dentry, buffer, buflen)</td>
<td>将目录项所指定的符号链接中对应的文件路径名拷贝到buffer所指定的用户态内存区。</td>
</tr>
<tr>
<td>follow_link(inode, nameidata)</td>
<td>解析索引节点对象所指定的符号链接；如果该符号链接是一个相对路径名，则从第二个参数所指定的目录开始进行查找。</td>
</tr>
<tr>
<td>put_link(dentry, nameidata)</td>
<td>释放由 follow＿link方法分配的用于解析符号链接的所有临时数据结构。</td>
</tr>
<tr>
<td>truncate(inode)</td>
<td>修改与索引节点相关的文件长度。在调用该方法之前，必须将inode对象的i＿size字段设置为需要的新长度值。</td>
</tr>
<tr>
<td>permission(inode, mask, nameidata)</td>
<td>检查是否允许对与索引节点所指的文件进行指定模式的访问。</td>
</tr>
<tr>
<td>setattr(dentry, iattr)</td>
<td>在触及索引节点属性后通知一个“修改事件“。</td>
</tr>
<tr>
<td>getattr(mnt, dentry, kstat)</td>
<td>由一些文件系统用于读取索引节点属性。</td>
</tr>
<tr>
<td>setxattr(dentry, name, value, size, flags)</td>
<td>为索引节点设置“扩展属性“（扩展属性存放在任何索引节点之外的磁盘块中）。</td>
</tr>
<tr>
<td>getxattr(dentry, name, buffer, size)</td>
<td>获取索引节点的扩展属性。</td>
</tr>
<tr>
<td>listxattr(dentry, buffer, size)</td>
<td>获取扩展属性名称的整个链表。</td>
</tr>
<tr>
<td>removexattr(dentry, name)</td>
<td>删除索引节点的扩展属性。上述列举的方法对所有可能的索引节点和文件系统类型都是可用的。不过，只有其中的一个子集应用到某一特定的索引节点和文件系统；未实现的方法对应的字段被置为NULL。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><p>​    文件对象描述进程怎样与一个打开的文件进行交互。文件对象是在文件被打开时创建的，由一个file结构组成，其中包含的字段如表12-4所示。注意，文件对象在磁盘上没有对应的映像，因此file结构中没有设置“脏“字段来表示文件对象是否已被修改。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>f_list</td>
<td>用于通用文件对象链表的指针</td>
</tr>
<tr>
<td>f_dentry</td>
<td>与文件相关的目录项对象</td>
</tr>
<tr>
<td>f_vfsmnt</td>
<td>含有该文件的已安装文件系统</td>
</tr>
<tr>
<td>f_op</td>
<td>指向文件操作表的指针</td>
</tr>
<tr>
<td>f_count</td>
<td>文件对象的引用计数器</td>
</tr>
<tr>
<td>f_flags</td>
<td>当打开文件时所指定的标志</td>
</tr>
<tr>
<td>f_mode</td>
<td>进程的访问模式</td>
</tr>
<tr>
<td>f_error</td>
<td>网络写操作的错误码</td>
</tr>
<tr>
<td>f_pos</td>
<td>当前的文件位移量（文件指针）</td>
</tr>
<tr>
<td>f_version</td>
<td>版本号，每次使用后自动递增</td>
</tr>
<tr>
<td>f_security</td>
<td>指向文件对象的安全结构的指针</td>
</tr>
<tr>
<td>private_data</td>
<td>指向特定文件系统或设备驱动程序所需的数据 的指针</td>
</tr>
<tr>
<td>f_ep_links</td>
<td>文件的事件轮询等待者链表的头</td>
</tr>
<tr>
<td>f_ep_lock</td>
<td>保护f_ep_links链表的自旋锁</td>
</tr>
<tr>
<td>f_mapping</td>
<td>指向文件地址空间对象的指针</td>
</tr>
</tbody>
</table>
</div>
<p>​    存放在文件对象中的主要信息是文件指针，即文件中当前的位置，下一个操作将在该位置发生。由于几个进程可能同时访问同一文件，因此文件指针必须存放在文件对象而不是索引节点对象中。</p>
<p>​    文件对象通过一个名为filp的slab高速缓存分配，filp描述符地址存放在filp_cachep 变量中。由于分配的文件对象数目是有限的，因此files_stat变量在其max_files字段中指定了可分配文件对象的最大数目，也就是系统可同时访问的最大文件数(注4)。</p>
<p>​    在使用“文件对象包含在由具体文件系统的超级块所确立的几个链表中。每个超级块对象把文件对象链表的头存放在s_files字段中；因此，属于不同文件系统的文件对象就包含在不同的链表中。链表中分别指向前一个元素和后一个元素的指针都存放在文件对象的f_list字段中。files_lock自旋锁保护超级块的s_files链表免受多处理器系统上的同时访问。</p>
<p>​    文件对象的f_count字段是一个引用计数器：它记录使用文件对象的进程数(记住，以CLONE_FILES标志创建的轻量级进程共享打开文件表，因此它们可以使用相同的文件对象)。当内核本身使用该文件对象时也要增加计数器的值——例如，把对象插入链表中或发出dup()系统调用时。</p>
<p>​    当VFS代表进程必须打开一个文件时，它调用get_empty_filp()函数来分配一个新的文件对象。该函数调用kmem_cache_alloc()从filp高速缓存中获得一个空闲的文件对象，然后初始化这个对象的字段，如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 重置
memset(f, 0, sizeof(*f));
&#x2F;&#x2F; 初始化
INIT_LIST_HEAD(&amp;f-&gt;f_ep_links);
spin_lock_init(&amp;f-&gt;f_ep_lock);
atomic_set(&amp;f-&gt;f_count, 1);
f-&gt;f_uid &#x3D; current-&gt;fsuid;
f-&gt;f_gid &#x3D; current-&gt;fsgid;
f-&gt;f_owmer.lock &#x3D; RW_LOCK_UNLOCKED;
INIT_LIST_HEAD(&amp;f-&gt;f_list〉;
f-&gt;f_maxcount &#x3D; INT_MAX;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    正如在“通用文件模型“一节中讨论过的那样，每个文件系统都有其自己的文件操作集合，执行诸如读写文件这样的操作。当内核将一个索引节点从磁盘装入内存时，就会把指向这些文件操作的指针存放在file_operations结构中，而该结构的地址存放在该索引节点对象的i_fop字段中。</p>
<p>​    当进程打开这个文件时，VFS就用存放在索引节点中的这个地址初始化新文件对象的f_op字段，使得对文件操作的后续调用能够使用这些函数。如果需要，VFS随后也可以通过在f_op字段存放一个新值而修改文件操作的集合。下面的列表描述了文件的操作，以它们在file_operations表中出现的次序来排列：</p>
<ol>
<li>loff_t (<em>llseek) (struct file </em> filp , loff_t p, int orig);<br>(指针参数filp为进行读取信息的目标文件结构体指针；参数 p 为文件定位的目标偏移量；参数orig为对文件定位的起始地址，这个值可以为文件开头（SEEK_SET，0,当前位置(SEEK_CUR,1)，文件末尾(SEEK_END,2)）</li>
</ol>
<blockquote>
<p>llseek 方法用作改变文件中的当前读/写位置, 并且新位置作为(正的)返回值.</p>
</blockquote>
<p>loff_t 参数是一个”long offset”, 并且就算在 32位平台上也至少 64 位宽. 错误由一个负返回值指示；如果这个函数指针是 NULL, seek 调用会以潜在地无法预知的方式修改 file 结构中的位置计数器( 在”file 结构” 一节中描述). </p>
<ol>
<li><p>ssize_t (<em>read) (struct file </em> filp, char __user <em> buffer, size_t    size , loff_t </em> p);</p>
<pre><code>(指针参数 filp 为进行读取信息的目标文件，指针参数buffer 为对应放置信息的缓冲区（即用户空间内存地址），参数size为要读取的信息长度，参数 p 为读的位置相对于文件开头的偏移，在读取信息后，这个指针一般都会移动，移动的值为要读取信息的长度值）
</code></pre><p>  这个函数用来从设备中获取数据。在这个位置的一个空指针导致 read 系统调用以 -EINVAL(“Invalid argument”) 失败。一个非负返回值代表了成功读取的字节数( 返回值是一个 “signed size” 类型, 常常是目标平台本地的整数类型). </p>
</li>
<li><p>ssize_t (<em>aio_read)(struct kiocb </em> , char __user * buffer, size_t size , loff_t   p);</p>
<pre><code>可以看出，这个函数的第一、三个参数和本结构体中的read()函数的第一、三个参数是不同 的，异步读写的第三个参数直接传递值，而同步读写的第三个参数传递的是指针，因为AIO从来不需要改变文件的位置。异步读写的第一个参数为指向kiocb结构体的指针，而同步读写的第一参数为指向file结构体的指针，每一个I/O请求都对应一个kiocb结构体);初始化一个异步读 -- 可能在函数返回前不结束的读操作.如果这个方法是 NULL, 所有的操作会由 read 代替进行(同步地
</code></pre></li>
<li><p>ssize_t (<em>write) (struct file </em> filp, const char __user <em>   buffer, size_t count, loff_t </em> ppos);</p>
<pre><code>(参数filp为目标文件结构体指针，buffer为要写入文件的信息缓冲区，count为要写入信息的长度，ppos为当前的偏移位置，这个值通常是用来判断写文件是否越界）
</code></pre></li>
</ol>
<blockquote>
<p>发送数据给设备.。如果 NULL, -EINVAL 返回给调用 write 系统调用的程序. 如果非负, 返回值代表成功写的字节数。<br>(注：这个操作和上面的对文件进行读的操作均为阻塞操作） </p>
</blockquote>
<ol>
<li>ssize_t (<em>aio_write)(struct kiocb </em>, const char __user <em> buffer, size_t count, loff_t </em> ppos);<pre><code>初始化设备上的一个异步写.参数类型同aio_read()函数; 
</code></pre></li>
<li>int (<em>readdir) (struct file </em> filp, void *, filldir_t);<pre><code>对于设备文件这个成员应当为 NULL; 它用来读取目录, 并且仅对文件系统有用.
</code></pre></li>
<li>unsigned int (<em>poll) (struct file </em>, struct poll_table_struct *);<pre><code>(这是一个设备驱动中的轮询函数，第一个参数为file结构指针，第二个为轮询表指针）
</code></pre></li>
</ol>
<blockquote>
<p>这个函数返回设备资源的可获取状态，即POLLIN，POLLOUT，POLLPRI，POLLERR，POLLNVAL等宏的位“或”结果。每个宏都表明设备的一种状态，如：POLLIN（定义为0x0001）意味着设备可以无阻塞的读，POLLOUT（定义为0x0004）意味着设备可以无阻塞的写。</p>
<p>(poll 方法是 3 个系统调用的后端: poll, epoll, 和 select, 都用作查询对一个或多个文件描述符的读或写是否会阻塞.poll 方法应当返回一个位掩码指示是否非阻塞的读或写是可能的, 并且, 可能地, 提供给内核信息用来使调用进程睡眠直到 I/O 变为可能. 如果一个驱动的 poll 方法为 NULL, 设备假定为不阻塞地可读可写.</p>
<p>(这里通常将设备看作一个文件进行相关的操作，而轮询操作的取值直接关系到设备的响应情况，可以是阻塞操作结果，同时也可以是非阻塞操作结果） </p>
</blockquote>
<ol>
<li><p>int (<em>ioctl) (struct inode </em>inode, struct file *filp, unsigned int cmd, unsigned long arg);</p>
<pre><code>(inode 和 filp 指针是对应应用程序传递的文件描述符 fd 的值, 和传递给 open 方法的相同参数.cmd 参数从用户那里不改变地传下来, 并且可选的参数 arg 参数以一个 unsigned long 的形式传递, 不管它是否由用户给定为一个整数或一个指针.如果调用程序不传递第 3 个参数, 被驱动操作收到的 arg 值是无定义的.因为类型检查在这个额外参数上被关闭, 编译器不能警告你如果一个无效的参数被传递给 ioctl, 并且任何关联的错误将难以查找.）
</code></pre><p>ioctl 系统调用提供了发出设备特定命令的方法(例如格式化软盘的一个磁道, 这不是读也不是写). 另外, 几个 ioctl 命令被内核识别而不必引用 fops 表.如果设备不提供 ioctl 方法, 对于任何未事先定义的请求(-ENOTTY, “设备无这样的 ioctl”), 系统调用返回一个错误. </p>
</li>
<li><p>int (<em>mmap) (struct file </em>, struct vm_area_struct *);</p>
<pre><code>mmap 用来请求将设备内存映射到进程的地址空间。 如果这个方法是 NULL, mmap 系统调用返回 -ENODEV.
</code></pre></li>
<li><p>int (<em>open) (struct inode </em> inode , struct file * filp ) ;</p>
<blockquote>
<p>(inode 为文件节点,这个节点只有一个，无论用户打开多少个文件，都只是对应着一个inode结构；但是filp就不同，只要打开一个文件，就对应着一个file结构体，file结构体通常用来追踪文件在运行时的状态信息）</p>
<p>尽管这常常是对设备文件进行的第一个操作, 不要求驱动声明一个对应的方法. 如果这个项是 NULL, 设备打开一直成功, 但是你的驱动不会得到通知.与open()函数对应的是release()函数。    </p>
</blockquote>
</li>
<li><p>int (<em>flush) (struct file </em>);</p>
<blockquote>
<p>flush 操作在进程关闭它的设备文件描述符的拷贝时调用</p>
<p>它应当执行(并且等待)设备的任何未完成的操作.这个必须不要和用户查询请求的 fsync 操作混淆了. 当前, flush 在很少驱动中使用;SCSI 磁带驱动使用它, 例如, 为确保所有写的数据在设备关闭前写到磁带上. 如果 flush 为 NULL, 内核简单地忽略用户应用程序的请求.</p>
</blockquote>
</li>
<li><p>int (<em>release) (struct inode </em>, struct file *);</p>
</li>
</ol>
<blockquote>
<p>release ()函数当最后一个打开设备的用户进程执行close()系统调用的时候，内核将调用驱动程序release()函数：</p>
</blockquote>
<ol>
<li>void release(struct inode inode,struct file *file)</li>
</ol>
<blockquote>
<p>release函数的主要任务是清理未结束的输入输出操作，释放资源，用户自定义排他标志的复位等。在文件结构被释放时引用这个操作. 如同 open, release 可以为 NULL. </p>
</blockquote>
<ol>
<li><p>int(<em>synch)(struct file </em>,struct dentry *,int datasync);</p>
<pre><code>   刷新待处理的数据,允许进程把所有的脏缓冲区刷新到磁盘。 
</code></pre></li>
<li><p>int (<em>aio_fsync)(struct kiocb </em>, int);</p>
<pre><code>    这是 fsync 方法的异步版本.所谓的fsync方法是一个系统调用函数。系统调用fsync把文件所指定的文件的所有脏缓冲区写到磁盘中（如果需要，还包括存有索引节点的缓冲区）。相应的服务例程获得文件对象的地址，并随后调用fsync方法。通常这个方法以调用函数__writeback_single_inode()结束，这个函数把与被选中的索引节点相关的脏页和索引节点本身都写回磁盘 
</code></pre></li>
<li><p>int (<em>fasync) (int, struct file </em>, int);</p>
<pre><code>    这个函数是系统支持异步通知的设备驱动，
</code></pre></li>
<li><p>int (<em>lock) (struct file </em>, int, struct file_lock *); </p>
<pre><code>    lock 方法用来实现文件加锁; 加锁对常规文件是必不可少的特性, 但是设备驱动几乎从不实现它.
</code></pre></li>
<li><p>ssize_t (*readv) (struct file *, const struct iovec *, unsigned long, loff_t \*);<br>ssize_t (*writev) (struct file <em>, const struct iovec </em>, unsigned long, loff_t *);</p>
</li>
</ol>
<p>​    这些方法实现发散/汇聚读和写操作. 应用程序偶尔需要做一个包含多个内存区的单个读或写操作;这些系统调用允许它们这样做而不必对数据进行额外拷贝. 如果这些函数指针为 NULL, read 和 write 方法被调用( 可能多于一次 ). </p>
<ol>
<li><p>ssize_t (<em>sendfile)(struct file </em>, loff_t <em>, size_t, read_actor_t, void </em>);</p>
<pre><code>   这个方法实现 sendfile 系统调用的读, 使用最少的拷贝从一个文件描述符搬移数据到另一个.例如, 它被一个需要发送文件内容到一个网络连接的 web 服务器使用. 设备驱动常常使 sendfile 为 NULL.
</code></pre></li>
<li><p>ssize_t (<em>sendpage) (struct file </em>, struct page <em>, int, size_t, loff_t </em>, int);</p>
<pre><code>    sendpage 是 sendfile 的另一半; 它由内核调用来发送数据, 一次一页, 到对应的文件. 设备驱动实际上不实现 sendpage.
</code></pre></li>
<li><p>unsigned long (<em>get_unmapped_area)(struct file </em>, unsigned long, unsigned long, unsigned long, unsigned long);</p>
<pre><code>     这个方法的目的是在进程的地址空间找一个合适的位置来映射在底层设备上的内存段中。这个任务通常由内存管理代码进行; 这个方法存在为了使驱动能强制特殊设备可能有的任何的对齐请求. 大部分驱动可以置这个方法为 NULL.[10]
</code></pre></li>
<li><p>int (*check_flags)(int)</p>
<pre><code>   这个方法允许模块检查传递给 fnctl(F_SETFL...) 调用的标志.
</code></pre></li>
<li><p>int (<em>dir_notify)(struct file </em>, unsigned long);</p>
<pre><code>    这个方法在应用程序使用 fcntl 来请求目录改变通知时调用. 只对文件系统有用; 驱动不需要实现 dir_notify. 
</code></pre></li>
</ol>
<p>以上描述的方法对所有可能的文件类型都是可用的。不过，对于一个具体的文件类型，只使用其中的一个子集；那些未实现的方法对应的字段被置为NULL。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chen-farsight/p/6181341.html">Linux字符设备驱动file_operations - GreenHand# - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h3 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h3><p>​    在“通用文件模型“一节中我们曾提到，VFS把每个目录看作由若干子目录和文件组成的一个普通文件。然而，一旦目录项被读入内存，VFS就把它转换成基于dentry结构的一个目录项对象，该结构的字段如表12-5所示。对于进程查找的路径名中的每个分量，内核都为其创建一个目录项对象；目录项对象将每个分量与其对应的索引节点相联系。例如，在查找路径名/tmp/test时，内核为根目录“/“创建一个目录项对象，为根目录下的tmp项创建一个第二级目录项对象，为/tmp目录下的test项创建一个第三级目录项对象。</p>
<p>​    请注意，目录项对象在磁盘上并没有对应的映像，因此在dentry结构中不包含指出该对象已被修改的字段。目录项对象存放在名为dentry_cache的slab分配器高速缓存中。因此，目录项对象的创建和删除是通过调用kmem_cache_alloc()和kmem_cache_free()实现的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>d_revalidate</em>：</td>
<td>VFS用于检查在dcache里找到的dentry是否有效。通常设置为NULL，则只要在dcache找到即认为是有效的。但对网络文件系统如NFS来说，dentry可能在一段时间之后就会失效，因此需要实现该函数用于检查是否有效。如果有效，函数需要返回一个正数。</td>
</tr>
<tr>
<td><em>d_weak_revalidate</em>：</td>
<td>用于检查’jumped’的dentry，即那些不是通过lookup获取的dentry，如’’, ‘.’或者’..’。这种场景只需要检查dentry对应inode是否OK即可。该函数不会在rcu-walk模式下调用，所以可以放心的使用inode。</td>
</tr>
<tr>
<td><em>d_hash</em>：</td>
<td>用于VFS将dentry放入HASH列表。并不清楚HASH表用来做啥，通常不需要设置它，使用VFS默认的即可。</td>
</tr>
<tr>
<td><em>d_compare</em>：</td>
<td>用于比较dentry name和指定的name。该函数必须是可重入的，即每次的返回结果一样。</td>
</tr>
<tr>
<td><em>d_revalidate</em></td>
<td>可能在rcu-walk模式（flags &amp; LOOKUP_RCU）下被调用。此时该函数里不能阻塞也不能写入数据到dentry，并且d_parent和d_inode不能使用，因为他们可能瞬间就可能被修改。如果在rcu-walk模式遇到困难，则返回-ECHILD，将在ref-walk模式下重新调用。</td>
</tr>
<tr>
<td><em>d_release</em>：</td>
<td>用于释放dentry资源。</td>
</tr>
<tr>
<td><em>d_delete</em>：</td>
<td>用于引用计数递减为0时调用，返回1则dcache立即删除dentry，返回0则继续缓存该dentry。默认为NULL，则总是将dentry进行缓存。该函数必须是可重入的，即每次的返回结果一样。</td>
</tr>
<tr>
<td><em>d_iput</em>：</td>
<td>用于释放dentry对应inode引用计数。该函数在释放dentry之前调用。如果为NULL，则VFS默认调用iput()。</td>
</tr>
<tr>
<td><em>d_dname</em>：</td>
<td>用于生成dentry的pathname，主要是一些伪文件系统（sockfs, pipefs等）用于延迟生成pathname。一般文件系统不实现该函数，因为其dentry存在于dcache的hash表里（通过pathname做hash），所以并不希望pathname变化。</td>
</tr>
<tr>
<td><em>d_automount</em>：</td>
<td>可选函数，用于穿越到一个自动挂载的dentry。它会创建一个新的vfsmount记录，并将其返回，成功后调用者将根据vfsmount去尝试mount它到挂载点。</td>
</tr>
<tr>
<td><em>d_manage</em>：</td>
<td>可选函数，用于管理从dentry进行transition。</td>
</tr>
</tbody>
</table>
</div>
<p>每个目录项对象可以处于以下四种状态之一：</p>
<ul>
<li>空闲状态(free)<br>处于该状态的目录项对象不包括有效的信息，且还没有被VFS使用。对应的内存区由slab分配器进行处理。</li>
<li>未使用状态(unused)<br>处于该状态的目录项对象当前还没有被内核使用。该对象的引用计数器d_count的值为0，但其d_inode字段仍然指向关联的索引节点。该目录项对象包含有效的信息，但为了在必要时回收内存，它的内容可能被丢弃。</li>
<li>正在使用状态(in use)<br>处于该状态的目录项对象当前正在被内核使用。该对象的引用计数器d_count的值为正数，其d_inode字段指向关联的索引节点对象。该目录项对象包含有效的信息，并且不能被丢弃。</li>
<li>负状态(negative)<br>与目录项关联的索引节点不复存在，那是因为相应的磁盘索引节点已被删除，或者因为目录项对象是通过解析一个不存在文件的路径名创建的。目录项对象的d_inode字段被置为NULL，但该对象仍然被保存在目录项高速缓存中，以便后续对同一文件目录名的查找操作能够快速完成。术语“负状态“容易使人误解，因为根本不涉及任何负值。</li>
</ul>
<p>​    与目录项对象关联的方法称为目录项操作。这些方法由dentry_operations结构加以描述，该结构的地址存放在目录项对象的d_op字段中。尽管一些文件系统定义了它们自己的目录项方法，但是这些字段通常为NULL，而VFS使用缺省函数代替这些方法。以下按照其在dentry_operations表中出现的顺序来列举一些方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>d_revalidate(dentry,nameidata)</td>
<td>在把目录项对象转换为一个文件路径名之前，判定该目录项对象是否仍然有效。缺 省的VFS函数什么也不做，而网络文件系统可以指定自已的函数。</td>
</tr>
<tr>
<td>d_hash(dentry, name)</td>
<td>生成一个散列值，这是用于目录项散列表的、特定于具体文件系统的散列函数。参  数dentry标识包含路径分量的自录。参数name指向一个结构，该结构包含要查找 的路径名分量以及由散列函数生成的散列值。</td>
</tr>
<tr>
<td>d_compare(dir,namel,name2)</td>
<td>比较两个文件名。name1应该属于dir所指的目录。缺省的VFS函数是常用的字 符串匹配函数。不过，每个文件系统可用自已的方式实现这一方法。例如，MS-DOS  文件系统不区分大写和小写字母。</td>
</tr>
<tr>
<td>d_delete(dentry)</td>
<td>当对自录项对象的最后一个引用被删除（dcount变为“0“）时，调用该方法。缺省的VFS函数什么也不做。</td>
</tr>
<tr>
<td>d_release(dentry)</td>
<td>当要释放一个目录项对象时（放人slab分配器），调用该方法。缺省的VFS函数什 么也不做。</td>
</tr>
<tr>
<td>d_iput(dentry,ino)</td>
<td>当一个自录项对象变为“负“状态（即丢弃它的索引节点）时，调用该方法。缺省 的VFS函数调用iput（）释放索引节点对象。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="目录项高速缓存"><a href="#目录项高速缓存" class="headerlink" title="目录项高速缓存"></a>目录项高速缓存</h4><p>​    由于从磁盘读入一个目录项并构造相应的目录项对象需要花费大量的时间，所以，在完成对目录项对象的操作后，可能后面还要使用它，因此仍在内存中保留它有重要的意义。例如，我们经常需要编辑文件，随后编译它，或者编辑并打印它，或者复制它并编辑这个拷贝，在诸如此类的情况中，同一个文件需要被反复访问。为了最大限度地提高处理这些目录项对象的效率，Linux使用目录项高速缓存，它由两种类型的数据结构组成：</p>
<blockquote>
<p>一个处于正在使用未使用或负状态的目录项对象的集合</p>
<p>一个散列表，其中能够快速获取与给定的文件和目录名对应的目录项对象！同样如果访问的对象不在目录项高速缓存中，该散列函数会返回一个空值 </p>
</blockquote>
<p>​    目录项高速缓存的作用还相当于索引节点高速缓存(inode cache)的控制器。在内核内存中，并不丢弃与未用目录项相关的索引节点，这是由于目录项高速缓存仍在使用它们。因此，这些索引节点对象保存在RAM中，并能够借助相应的目录项快速引用它们。</p>
<p>​    所有“未使用“目录项对象都存放在一个“最近最少使用(Least Recently used,LRU)“的双向链表中，该链表按照插入的时间排序。换句话说，最后释放的目录项对象放在链表的首部，所以最近最少使用的目录项对象总是靠近链表的尾部。一旦目录项高速缓存的空间开始变小，内核就从链表的尾部删除元素，使得最近最常使用的对象得以保留。</p>
<p>​    LRU链表的首元素和尾元素的地址存放在list_head类型的dentry_unused变量的next字段和prev字段中。目录项对象的d_1ru字段包含指向链表中相邻目录项的指针。</p>
<p>​    每个“正在使用“的目录项对象都被插入一个双向链表中，该链表由相应索引节点对象的i_dentry字段所指向(由于每个索引节点可能与若干硬链接关联，所以需要一个链表)。目录项对象的d_alias字段存放链表中相邻元素的地址。这两个字段的类型都是struct list_head。</p>
<p>​    当指向相应文件的最后一个硬链接被删除后，一个“正在使用“的目录项对象可能变成“负“状态。在这种情况下，该目录项对象被移到“未使用“目录项对象组成的LRU链表中。每当内核缩减目录项高速缓存时，“负“状态目录项对象就朝着LRU链表的尾部移动，这样一来，这些对象就逐渐被释放。</p>
<p>​    <strong>散列表是由dentry_hashtable数组实现的。</strong>数组中的每个元素是一个指向链表的指针，这种链表就是把具有相同散列表值的目录项进行散列而形成的。该数组的长度取决于系统已安装RAM的数量；缺省值是每兆字节RAM包含256个元素。目录项对象的d_hash 字段包含指向具有相同散列值的链表中的相邻元素。散列函数产生的值是由目录的目录项对象及文件名计算出来的。</p>
<p>​    dcache_lock自旋锁保护目录项高速缓存数据结构免受多处理器系统上的同时访问。d_lookup()函数在散列表中查找给定的父目录项对象和文件名；为了避免发生竞争，使用顺序锁(seqlock)。__d_lookup()函数与之类似，不过它假定不会发生竞争，因此不使用顺序锁。</p>
<h3 id="与进程相关的文件"><a href="#与进程相关的文件" class="headerlink" title="与进程相关的文件"></a>与进程相关的文件</h3><p>每个进程都有它自己当前的工作目录和它自己的根目录。这仅仅是内核用来表示进程与文件系统相互作用所必须维护的数据中的两个例子。类型为fs_struc的整个数据结构就用于此目的(参见表12-6)，且每个进程描述符的fs字段就指向进程的fs_struc结构。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>count：</td>
<td>共享这个表的进程个数</td>
</tr>
<tr>
<td>lock：</td>
<td>用于表中字段的读/写自旋锁</td>
</tr>
<tr>
<td>umask：</td>
<td>当打开文件设置文件权限时所使用的位掩码</td>
</tr>
<tr>
<td>root：</td>
<td>根目录的目录项</td>
</tr>
<tr>
<td>pwd：</td>
<td>当前工作目录的目录项</td>
</tr>
<tr>
<td>altroot：</td>
<td>模拟根目录的目录项（在80x86结构上始终为NULL）</td>
</tr>
<tr>
<td>rootmnt：</td>
<td>根目录所安装的文件系统对象</td>
</tr>
<tr>
<td>pwdmnt：</td>
<td>当前工作目录所安装的文件系统对象</td>
</tr>
<tr>
<td>altrootmnt：</td>
<td>模拟根目录所安装的文件系统对象（在80x86结构上始终为NULL）</td>
</tr>
</tbody>
</table>
</div>
<p>​    第二个表表示进程当前打开的文件表的地址存放于进程描述符的files字段。该表的类型为files_struct结构，它的各个字段如表12-7所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>共享该表的进程数目</td>
</tr>
<tr>
<td>file_lock</td>
<td>于表中字段的读/写自旋锁</td>
</tr>
<tr>
<td>max_fds</td>
<td>用文件对象的当前最大数目</td>
</tr>
<tr>
<td>max_fdset</td>
<td>文件描述符的当前最大数目</td>
</tr>
<tr>
<td>next_fd</td>
<td>所分配的最大文件描述符加1</td>
</tr>
<tr>
<td>close_on_exec</td>
<td>指向执行exec()时需要关闭的文件描述符的 指针</td>
</tr>
<tr>
<td>fd</td>
<td>指向文件对象指针数组的指针</td>
</tr>
<tr>
<td>open_fds</td>
<td>指向打开文件描述符的指针</td>
</tr>
<tr>
<td>close_on_exec_init</td>
<td>执行exec()时需要关闭的文件描述符的初始集合</td>
</tr>
<tr>
<td>open_fds_init</td>
<td>文件描述符的初始集合</td>
</tr>
<tr>
<td>fd_array</td>
<td>文件对象指针的初始化数组</td>
</tr>
</tbody>
</table>
</div>
<p>​    fd字段指向文件对象的指针数组。该数组的长度存放在max_fds字段中。通常，fd字段指向files_struct结构的fd_array字段，该字段包括32个文件对象指针。如果进程打开的文件数目多于32，内核就分配一个新的、更大的文件指针数组，并将其地址存放在fd字段中，内核同时也更新max_fds字段的值。</p>
<p>​    对于在fd数组中有元素的每个文件来说，数组的索引就是文件描述符(file descriptor)。通常，数组的第一个元素(索引0)是进程的标准输入文件，数组的第二个元素(索引1)是进程的标准输出文件，数组的第三个元素(索引2)是进程的标准错误文件。</p>
<p>​    Unix进程将文件描述符作为主文件标识符。请注意，借助于dup()、dup2()和fcntl()系统调用，两个文件描述符可以指向同一个打开的文件，也就是说，数组的两个元素可能指向同一个文件对象。当用户使用shell结构(如2&gt;&amp;1)将标准错误文件重定向到标准输出文件上时，用户总能看到这一点。</p>
<p>​    进程不能使用多于NR_OPEN(通常为1048576)个文件描述符。内核也在进程描述符的signal-&gt;rlim[RLIMIT_NOFILE]结构上强制限制文件描述符的最大数；这个值通常为1024，但是如果进程具有超级用户特权，就可以增大这个值。</p>
<p>​    open_fds字段最初包含open_fds_init字段的地址，open_fds_init字段表示当前已打开文件的文件描述符的位图。max_fdset字段存放位图中的位数。由于fd_set数据结构有1024位，所以通常不需要扩大位图的大小。但，如果确有必要的话，内核仍能动态增加位图的大小，这非常类似于文件对象的数组的情形。</p>
<p>​    当内核开始使用一个文件对象时，内核提供fget()函数以供调用。函数接收fd作为参数，返回在current-&gt;files-&gt;fd[fd]中的地址，即对应文件对象的地址，如果没有任何文件与fd对应，则返回NULL。在第一种情况下，fget()使文件对象引用计数器f_count的值增1。<br><img src=".\76a205ac93b344dcbc406da707583325.png" alt="在这里插入图片描述"></p>
<p>​    当内核控制路径完成对文件对象的使用时，调用内核提供的fput()函数。该函数将文件对象的地址作为参数，并减少文件对象引用计数器f_count的值。另外，如果这个字段变为0，该函数就调用文件操作的release方法(如果已定义)：</p>
<ol>
<li>减少索引节点对象的i_write count字段的值(如果该文件是可写的)。</li>
<li>将文件对象从超级块链表中移走。</li>
<li>释放文件对象给slab分配器。</li>
<li>最后减少相关的文件系统描述符的目录项对象的引用计数器的值。</li>
</ol>
<p>fget_light()和fget_light()函数是fget()和fput()的快速版本：内核要使用它们，前提是能够安全地假设当前进程已经拥有文件对象，即进程先前已经增加了文件对象引用计数器的值。例如，它们由接收一个文件描述符作为参数的系统调用服务例程使用，这是由于先前的open()系统调用已经增加了文件对象引用计数器的值。</p>
<h3 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h3><p>Linux内核支持很多不同的文件系统类型。在下面的内容中，我们介绍一些特殊的文件系统类型，它们在Linux内核的内部设计中具有非常重要的作用。接下来，我们将讨论文件系统注册——也就是通常在系统初始化期间并且在使用文件系统类型之前必须执行的基本操作。一旦文件系统被注册，其特定的函数对内核就是可用的，因此文件系统类型可以安装在系统的目录树上。</p>
<h3 id="特殊文件系统"><a href="#特殊文件系统" class="headerlink" title="特殊文件系统"></a>特殊文件系统</h3><p>当网络和磁盘文件系统能够使用户处理存放在内核之外的信息时，特殊文件系统可以为系统程序员和管理员提供一种容易的方式来操作内核的数据结构并实现操作系统的特殊特征。表12-8列出了Linux中所用的最常用的特殊文件系统；对于其中的每个文件系统，表中给出了它的安装点和简短描述。注意，有几个文件系统没有固定的安装点(表中的关键词“任意”)。这些文件系统可以由用户自由地安装和使用。一些特殊文件系统根本没有安装点(表中的“无”)，它们不是用于与用户交互，但是内核可以用它们来很容易地重新使用VFS层的某些代码.</p>
<p>特殊文件系统不限于物理块设备，然而，内核给每个安装的特殊文件系统分配一个虚拟的块设备，让其主设备号为0而次设备号具有任意值(每个特殊文件系统有不同的值)。set_anon_super()函数用于初始化特殊文件系统的超级块；函数获得一个未使用的次设备号dev，然后用主设备号0和次设备号dev设置新超级块的s_dev字段。</p>
<p>而另一个kill_anon_super()函数移走特殊文件系统的超级块。unnamed_dev_idr变量包含指向一个辅助结构(记录当前在用的次设备号)的指针。尽管有些内核设计者不喜欢虚拟块设备标识符，但是这些标识符有助于内核以统一的方式处理特殊文件系统和普通文件系统。</p>
<h3 id="文件系统类型注册"><a href="#文件系统类型注册" class="headerlink" title="文件系统类型注册"></a>文件系统类型注册</h3><p>通常，用户在为自己的系统编译内核时可以把Linux配置为能够识别所有需要的文件系统。但是，文件系统的源代码实际上要么包含在内核映像中，要么作为一个模块被动态装入。VFS必须对代码目前已在内核中的所有文件系统的类型进行跟踪。这就是通过进行文件系统类型注册来实现的。每个注册的文件系统都用一个类型为file_system_type的对象来表示，该对象的所有字段在表12-9中列出。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">struct file_system_type &#123;
115         const char *name;
116         int fs_flags;
117         struct dentry *(*mount) (struct file_system_type *, int,
118                        const char *, void *);
119         void (*kill_sb) (struct super_block *);
120         struct module *owner;
121         struct file_system_type * next;
122         struct list_head fs_supers;
123         struct lock_class_key s_lock_key;
124         struct lock_class_key s_umount_key;
125 &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    其中，name是文件系统名称，如ext4, xfs等等。fs_flags为各种标识，如FS_REQUIRES_DEV, FS_NO_DCACHE等。mount()函数指针用于挂载一个新的文件系统实例。kill_sb()函数指针用于关闭文件系统实例。owner是VFS内部使用，通常设置为THIS_MODULE。next也是VFS内部使用，初始化时设置为NULL即可。s_lock_key和s_umount_key是lockdep相关的结构。</p>
<p>​    mount()函数有几个参数：fs_type为对应的file_sytem_type结构指针。flags为挂载的标识。dev_name为挂载的设备名，对于网络文件系统通常是一个网络路径。data为挂载的选项，通常为一组ASCII字符串。</p>
<p>​    mount()必须返回文件系统目录树的root dentry。文件系统的super block增加一个引用计数并处于locked状态。mount失败时返回ERR_PTR(err)。mount()函数可以选择返回一个已经存在的文件系统的一个子树，而不是创建一个新的文件系统实例，这种情况返回的是子树的root dentry。</p>
<p>​    底层文件系统实现mount，可以直接调用通用的mount实现：mount_bdev（在块设备上挂载文件系统）、mount_nodev（挂载没有设备的文件系统）和mount_single（挂载在不同的mounts间共享实例的文件系统），并提供一个fill_super()的回调函数用于创建root dentry和inode。比如FUSE就通过调用mount_nodev来实现mount操作。<br>其中file_super()回调函数的参数包括：struct super_block sb（文件系统sb，需要在fill_super()里进行初始化）、void data（文件系统挂载的选项字符串）、int silent（是否忽略error）。</p>
<p>​    当然也可以参考通用的mount实现自己的mount操作，比如Ceph就直接调用了<em>sget()</em>函数创建sb并通过<em>set()</em>回调函数初始化sb。所有文件系统类型的对象都插入到一个单向链表中。由变量file_systems指向链表的第一个元素，而结构中的next字段指向链表的下一个元素。file_systems_lock读/写自旋锁保护整个链表免受同时访问。</p>
<p>​    fs_supers字段表示给定类型的已安装文件系统所对应的超级块链表的头(第一个伪元素)。链表元素的向后和向前链接存放在超级块对象的s_instances字段中。get_sb字段指向依赖于文件系统类型的函数，该函数分配一个新的超级块对象并初始化它(如果需要，可读磁盘)。而kill_sb字段指向删除超级块的函数。fs_flags字段存放几个标志，如表12-10所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FS_REQUIRES_DEV</td>
<td>这种类型的任何文件系统必须位于物理磁盘设备上</td>
</tr>
<tr>
<td>FS_BINARY_MOUNTDATA</td>
<td>文件系统使用的二进制安装数据</td>
</tr>
<tr>
<td>FS_REVAL_DOT</td>
<td>始终在目录项高速缓存中时.和..路径重新生效</td>
</tr>
<tr>
<td>FS_ODD_RENAME</td>
<td>重命名操作就是移动操作</td>
</tr>
</tbody>
</table>
</div>
<p>​    在系统初始化期间，调用register_filesystem()函数来注册编译时指定的每个文件系统；该函数把相应的file_system_type对象插入到文件系统类型的链表中。当实现了文件系统的模块被装入时，也要调用register_filesystem()函数。在这种情况下，当该模块被卸载时，对应的文件系统也可以被注销(调用unregister_filesystem()函数)。</p>
<p>​    get_fs_type()函数(参数为文件系统名)扫描已注册的文件系统链表以查找文件系统类型的name字段，并返回指向相应的file_system_type对象(如果存在)的指针。</p>
<h3 id="文件系统处理"><a href="#文件系统处理" class="headerlink" title="文件系统处理"></a>文件系统处理</h3><p>​    就像每个传统的Unix系统一样，Linux也使用系统的根文件系统(system’s rootfilesystem)：它由内核在引导阶段直接安装，并拥有系统初始化脚本以及最基本的系统程序。其他文件系统要么由初始化脚本安装，要么由用户直接安装在已安装文件系统的目录上。</p>
<p>​    作为一个目录树，每个文件系统都拥有自己的根目录(root directory)。安装文件系统的这个目录称之为安装点(mount point)。已安装文件系统属于安装点目录的一个子文件系统。例如，/proc虚拟文件系统是系统的根文件系统的孩子(且系统的根文件系统是/proc的父亲)。已安装文件系统的根目录隐藏了父文件系统的安装点目录原来的内容，而且父文件系统的整个子树位于安装点之下。</p>
<p>​    文件系统的根目录有可能不同于进程的根目录：进程的根目录是与“/“路径对应的目录。缺省情况下，进程的根目录与系统的根文件系统的根目录一致(更准确地说是与进程的命名空间中的根文件系统的根目录一致，这一点将在下一节描述)，但是可以通过调用chroot()系统调用改变进程的根目录。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>​    在传统的Unix系统中，只有一个已安装文件系统树：从系统的根文件系统开始，每个进程通过指定合适的路径名可以访问已安装文件系统中的任何文件。从这个方面考虑，Linux 2.6更加的精确：每个进程可拥有自己的已安装文件系统树——叫做进程的命名空间(namespace)。</p>
<p>​    通常大多数进程共享同一个命名空间，即位于系统的根文件系统且被init进程使用的已安装文件系统树。不过，如果clone()系统调用以CLONE_NEWNS标志创建一个新进程，那么进程将获取一个新的命名空间。这个新的命名空间随后由子进程继承(如果父进程没有以CLONE_NEWNS标志创建这些子进程)。当进程安装或卸载一个文件系统时，仅修改它的命名空间。因此，所做的修改对共享同一命名空间的所有进程都是可见的，并且也只对它们可见。</p>
<p>​    进程甚至可通过使用Linux 特有的pivot_root()系统调用来改变它的命名空间的根文件系统。进程的命名空间由进程描述符的namespace字段指向的namespace结构描述。该结构的字段如表12-11所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>count</td>
<td>引用计数器（共享命名空间的进程数）</td>
</tr>
<tr>
<td>root</td>
<td>命名空间根目录的已安装文件系统描述符</td>
</tr>
<tr>
<td>list</td>
<td>所有已安装文件系统描述符链表的头</td>
</tr>
<tr>
<td>sem</td>
<td>保护这个结构的读/写信号量</td>
</tr>
</tbody>
</table>
</div>
<p>​    list字段是双向循环链表的头，该表聚集了属于命名空间的所有已安装文件系统。root 字段表示已安装文件系统，它是这个命名空间的已安装文件系统树的根。</p>
<h2 id="文件系统安装"><a href="#文件系统安装" class="headerlink" title="文件系统安装"></a>文件系统安装</h2><p>​    在大多数传统的类Unix内核中，每个文件系统只能安装一次。假定存放在/dev/fd0软磁盘上的Ext2文件系统通过如下命令安装在/flp：mount -t ext2 /dev/fd0 /flp在用umount命令卸载该文件系统前，所有其他作用于/dev/fd0的安装命令都会失败。然而，Linux有所不同：同一个文件系统被安装多次是可能的。当然，如果一个文件系统被安装了n次，那么它的根目录就可通过n个安装点来访问。尽管同一文件系统可以通过不同的安装点来访问，但是文件系统的的确确是唯一的。因此，不管一个文件系统被安装了多少次，都仅有一个超级块对象。</p>
<p>​    安装的文件系统形成一个层次：一个文件系统的安装点可能成为第二个文件系统的目录，第二个文件系统又安装在第三个文件系统之上等。把多个安装堆叠在一个单独的安装点上也是可能的。尽管已经使用先前安装下的文件和目录的进程可以继续使用，但在同一安装点上的新安装隐藏前一个安装的文件系统。当最顶层（最后一个）的安装被删除时，下一层的安装再一次变为可见的。你可以想像，跟踪已安装的文件系统很快会变为一场恶梦。对于每个安装操作，内核必须在内存中保存安装点和安装标志，以及要安装文件系统与其他已安装文件系统之间的关系。信息保存在已安装文件系统描述符中；每个描述符是一个具有vfsmount 类型的数据结构，其字段如表12-12所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>mnt_hash</td>
<td>用于散列表链表的指针</td>
</tr>
<tr>
<td>mntparent</td>
<td>指向父文件系统，这个文件系统安装在其上</td>
</tr>
<tr>
<td>mnt_mountpoint</td>
<td>指向这个文件系统安装点目录的dentry</td>
</tr>
<tr>
<td>mnt_root</td>
<td>指向这个文件系统根目录的dentry</td>
</tr>
<tr>
<td>mnt_sb</td>
<td>指向这个文件系统的超级块对象</td>
</tr>
<tr>
<td>mnt_mounts</td>
<td>包含所有文件系统描述符链表的头（相对于这  个文件系统）</td>
</tr>
<tr>
<td>mnt_child</td>
<td>用于已安装文件系统链表mnt_mounts的指针</td>
</tr>
<tr>
<td>mnt_mounts</td>
<td>已安装文件系统链表的指针</td>
</tr>
<tr>
<td>mnt_count</td>
<td>引用计数器（增加该值以禁止文件系统被卸载）</td>
</tr>
<tr>
<td>mnt_flags</td>
<td>标志</td>
</tr>
<tr>
<td>mnt_expiry_mark</td>
<td>如果文件系统标记为到期，那么就设置该标志 为true（如果设置了该标志，并且没有任何人 使用它，那么就可以自动卸载这个文件系统</td>
</tr>
<tr>
<td>mnt_devmame</td>
<td>设备文件名</td>
</tr>
<tr>
<td>mnt_list</td>
<td>已安装文件系统描述符的namespace链表的指针</td>
</tr>
<tr>
<td>mnt fslink</td>
<td>具体文件系统到期链表的指针</td>
</tr>
<tr>
<td>mnt_namespace</td>
<td>指向安装了文件系统的进程命名空间的指针</td>
</tr>
</tbody>
</table>
</div>
<p>vfsmount数据结构保存在几个双向循环链表中：</p>
<ol>
<li>由父文件系统vfsmount描述符的地址和安装点目录的目录项对象的地址索引的散列表。散列表存放在mount_hashtable数组中，其大小取决于系统中RAM的容量。表中每一项是具有同一散列值的所有描述符形成的双向循环链表的头。描述符的mnt_hash字段包含指向链表中相邻元素的指针。</li>
<li>对于每一个命名空间，所有属于此命名空间的已安装的文件系统描述符形成了一个双向循环链表。namespace结构的list字段存放链表的头，vfsmount描述符的mnt_list字段包含链表中指向相邻元素的指针。</li>
<li>对于每一个已安装的文件系统，所有已安装的子文件系统形成了一个双向循环链表。每个链表的头存放在已安装的文件系统描述符的mnt_mounts字段；此外，描述符的mnt_child字段存放指向链表中相邻元素的指针</li>
</ol>
<p>vfsmount_lock自旋锁保护已安装文件系统对象的链表免受同时访问。描述符的mnt_flags字段存放几个标志的值，用以指定如何处理已安装文件系统中的某些种类的文件。可通过mount命令的选项进行设置，其标志如表12-13所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>MNT_NOSUID</td>
<td>在已安装文件系统中禁止标志setuid和setgid</td>
</tr>
<tr>
<td>MNT_NODEV</td>
<td>在已安装文件系统中禁止访问设备</td>
</tr>
<tr>
<td>MNT_NOEXEC</td>
<td>在已安装新文件系统中不允许程序的执行</td>
</tr>
</tbody>
</table>
</div>
<p>下列函数处理已安装文件系统描述符：</p>
<ul>
<li>alloc_vfsmnt(name): 分配和初始化一个已安装文件系统的描述服务</li>
<li>free_vfsmnt(mnt): 释放已有以mnt指向的已安装文件系统描述符</li>
<li>lookup_mnt(mnt, dentry):在散列表中查找一个描述符并且返回它的地址 </li>
</ul>
<h3 id="安装普通文件系统"><a href="#安装普通文件系统" class="headerlink" title="安装普通文件系统"></a>安装普通文件系统</h3><p>我们现在描述安装一个文件系统时内核所要执行的操作。我们首先考虑一个文件系统将被安装在一个已安装文件系统之上的情形(在这里我们把这种新文件系统看作“普通的”)。mount()系统调用被用来安装一个普通文件系统；它的服务例程sys_mount()作用于以下参数：</p>
<blockquote>
<ul>
<li>文件系统所在的设备文件的路径名，或者如果不需要的话就为空</li>
<li>文件系统被安装器上的某个目录的目录路径</li>
<li>文件系统的类型，必须是已注册文件系统的名称</li>
<li>安装标志</li>
<li>指向一个与文件系统相关的数据结构的指针 </li>
</ul>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 
 * These are the fs-independent mount-flags: up to 32 flags are supported 
 *&#x2F;  
#define MS_RDONLY        1         &#x2F;* 对应-o ro&#x2F;rw *&#x2F;  
#define MS_NOSUID        2         &#x2F;* 对应-o suid&#x2F;nosuid *&#x2F;  
#define MS_NODEV         4         &#x2F;* 对应-o dev&#x2F;nodev *&#x2F;  
#define MS_NOEXEC        8         &#x2F;* 对应-o exec&#x2F;noexec *&#x2F;  
#define MS_SYNCHRONOUS  16         &#x2F;* 对应-o sync&#x2F;async *&#x2F;  
#define MS_REMOUNT      32         &#x2F;* 对应-o remount，告诉mount这是一次remount操作 *&#x2F;  
#define MS_MANDLOCK     64         &#x2F;* 对应-o mand&#x2F;nomand *&#x2F;  
#define MS_DIRSYNC      128        &#x2F;* 对应-o dirsync *&#x2F;  
#define MS_NOATIME      1024       &#x2F;* 对应-o atime&#x2F;noatime *&#x2F;  
#define MS_NODIRATIME   2048       &#x2F;* 对应-o diratime&#x2F;nodiratime *&#x2F;  
#define MS_BIND         4096       &#x2F;* 对应-B&#x2F;--bind选项，告诉mount这是一次bind操作 *&#x2F;  
#define MS_MOVE         8192       &#x2F;* 对应-M&#x2F;--move，告诉mount这是一次move操作 *&#x2F;  
#define MS_REC          16384      &#x2F;* rec是recursive的意思，这个flag一般不单独出现，都是伴随这其它flag，表示递归的进行操作 *&#x2F;  
#define MS_VERBOSE      32768      &#x2F;* 对应-v&#x2F;--verbose *&#x2F;  
#define MS_SILENT       32768      &#x2F;* 对应-o silent&#x2F;loud *&#x2F;  
#define MS_POSIXACL     (1&lt;&lt;16)    &#x2F;* 让VFS不应用umask，如NFS *&#x2F;  
#define MS_UNBINDABLE   (1&lt;&lt;17)    &#x2F;* 对应--make-unbindable *&#x2F;  
#define MS_PRIVATE      (1&lt;&lt;18)    &#x2F;* 对应--make-private *&#x2F;  
#define MS_SLAVE        (1&lt;&lt;19)    &#x2F;* 对应--make-slave *&#x2F;  
#define MS_SHARED       (1&lt;&lt;20)    &#x2F;* 对应--make-shared *&#x2F;  
#define MS_RELATIME     (1&lt;&lt;21)    &#x2F;* 对应-o relatime&#x2F;norelatime *&#x2F;  
#define MS_KERNMOUNT    (1&lt;&lt;22)    &#x2F;* 这个一般不在应用层使用，一般内核挂载的文件系统如sysfs使用，表示使用kern_mount()进行挂载 *&#x2F;  
#define MS_I_VERSION    (1&lt;&lt;23)    &#x2F;* 对应-o iversion&#x2F;noiversion *&#x2F;  
#define MS_STRICTATIME  (1&lt;&lt;24)    &#x2F;* 对应-o strictatime&#x2F;nostrictatime *&#x2F;  
#define MS_LAZYTIME     (1&lt;&lt;25)    &#x2F;* 对应 -o lazytime&#x2F;nolazytime*&#x2F;

&#x2F;* 下面这几个flags都是内核内部使用的，不由mount系统调用传递 *&#x2F;
#define MS_SUBMOUNT     (1&lt;&lt;26)
#define MS_NOREMOTELOCK (1&lt;&lt;27)
#define MS_NOSEC        (1&lt;&lt;28)
#define MS_BORN         (1&lt;&lt;29)
#define MS_ACTIVE       (1&lt;&lt;30)
#define MS_NOUSER       (1&lt;&lt;31)
&#x2F;* 
 * Superblock flags that can be altered by MS_REMOUNT 
 *&#x2F;  
#define MS_RMT_MASK     (MS_RDONLY|MS_SYNCHRONOUS|MS_MANDLOCK|MS_I_VERSION|\                   
                         MS_LAZYTIME)  &#x2F;&#x2F; 可以在remount时改变的flags  
  
&#x2F;* 
 * Old magic mount flag and mask 
 *&#x2F;  
#define MS_MGC_VAL 0xC0ED0000      &#x2F;* magic number *&#x2F;  
#define MS_MGC_MSK 0xffff0000      &#x2F;* flags mask *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    sys_mount()函数把参数的值拷贝到临时内核缓冲区，获取大内核锁，并调用do_mount()函数。一旦do_mount()返回，则这个服务例程释放大内核锁并释放临时内核缓冲区。do_mount()函数通过执行下列操作处理真正的安装操作：</p>
<ol>
<li><p>如果安装标志MS_NOSUID、MS_NODEV或MS_NOEXEC中任一个被设置，则清除它们，并在已安装文件系统对象中设置相应的标志(MNT_NOSUID、MNT_NODEV、MNT_NOEXEC)。</p>
</li>
<li><p>调用path_lookup()查找安装点的路径名，该函数把路径名查找的结果存放在nameidata类型的局部变量nd中。</p>
</li>
<li><p>检查安装标志以决定必须做什么。尤其是：</p>
<blockquote>
<ol>
<li>如果MS_REMOUNT标志被指定，其目的通常是改变超级块对象s_flags字段的安装标志，以及已安装文件系统对象mnt_flags字段的安装文件系统标志。do_remount()函数执行这些改变。</li>
<li>否则，检查MS_BIND标志。如果它被指定，则用户要求在在系统目录树的另一个安装点上的文件或目录能够可见。</li>
<li>否则，检查MS_MOVE标志。如果它被指定，则用户要求改变已安装文件系统的安装点。do_move_mount()函数原子地完成这一任务。</li>
<li>否则，调用do_new_mount()。这是最普通的情况。当用户要求安装一个特殊文件系统或存放在磁盘分区中的普通文件系统时，触发该函数。它调用do_kern_mount()函数，给它传递的参数为文件系统类型、安装标志以及块设备名。</li>
</ol>
</blockquote>
</li>
</ol>
<p>​    do_kern_mount()处理实际的安装操作并返回一个新安装文件系统描述符的地址(如下描述)。然后，do_new_mount()调用do_add_mount()，后者本质上执行下列操作；</p>
<blockquote>
<ol>
<li>获得当前进程的写信号量namespace-&gt;sem，因为函数要更改namespace结构。</li>
<li>do_kern_mount()函数可能让当前进程睡眠；同时，另一个进程可能在完全相同的安装点上安装文件系统或者甚至更改根文件系统(current-&gt;namespace-&gt;root)。验证在该安装点上最近安装的文件系统是否仍指向当前的namespace；如果不是，则释放读/写信号量并返回一个错误码。</li>
<li>如果要安装的文件系统已经被安装在由系统调用的参数所指定的安装点上，或该安装点是一个符号链接，则释放读/写信号量并返回一个错误码。</li>
<li>初始化由do_kern_mount()分配的新安装文件系统对象的mnt_flags字段的标志。</li>
<li>调用graft_tree()把新安装的文件系统对象插入到namespace链表、散列表及父文件系统的子链表中。</li>
<li>释放namespace-&gt;sem读/写信号量并返回。</li>
</ol>
</blockquote>
<ol>
<li>调用path_release()终止安装点的路径名查找并返回0。</li>
</ol>
<h3 id="do-kern-mount-函数"><a href="#do-kern-mount-函数" class="headerlink" title="do_kern_mount()函数"></a>do_kern_mount()函数</h3><p>安装操作的核心是do_kern_mount()函数，它检查文件系统类型标志以决定安装操作是如何完成的。该函数接收下列参数：</p>
<blockquote>
<p>fstype: 要安装的文件系统的类型名</p>
<p>flags:安装标志</p>
<p>name: 存放文件系统的块设备的路径名</p>
<p>data: 指向传递给文件系统的readsuper方法的附加数据的指针</p>
</blockquote>
<p>本质上，该函数通过执行下列操作实现实际的安装操作：</p>
<ol>
<li>调用get_fs_type()在文件系统类型链表中搜索并确定存放在fstype参数中的名字的位置；返回局部变量type中对应file_system_type描述符的地址。</li>
<li>调用alloc_vfsmnt()分配一个新的已安装文件系统的描述符，并将它的地址存放在mnt局部变量中。</li>
<li>调用依赖于文件系统的type-&gt;get_sb()函数分配，并初始化一个新的超级块。</li>
<li>用新超级块对象的地址初始化mnt-&gt;mnt_sb字段。</li>
<li>将mnt-&gt;mnt_root字段初始化为与文件系统根目录对应的目录项对象的地址，并增加该目录项对象的引用计数器值。</li>
<li>用mnt中的值初始化mnt-&gt;mnt_parent字段(对于普通文件系统，当graft_tree()把已安装文件系统的描述符插入到合适的链表中时，要把mnt_parent字段置为合适的值)。</li>
<li>用current-&gt;namespace中的值初始化mnt-&gt;mnt_namespace字段。</li>
<li>释放超级块对象的读/写信号量s_umount(在第3步中分配对象时获得)。</li>
<li>返回已安装文件系统对象的地址mnt。</li>
</ol>
<h3 id="分配超级块对象"><a href="#分配超级块对象" class="headerlink" title="分配超级块对象"></a>分配超级块对象</h3><p>文件系统对象的get_sb方法通常是由单行函数实现的。例如，在Ext2文件系统中该方法的实现如下：</p>
<pre class="line-numbers language-none"><code class="language-none">struct super_block * ext2_get_sb(struct file_system_type *type, int flags, const char *dev_name, void *data)
&#123;
	return get_sb_bdev(type, flags, dev_name, data, ext2_fill_super);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>get_sb_bdev() VFS函数分配并初始化一个新的适合于磁盘文件系统的超级块；它接收ext2_fill_super()函数的地址，该函数从Ext2磁盘分区读取磁盘超级块。为了分配适合于特殊文件系统的超级块，VFS也提供get_sb_pseudo()函数(对于没有安装点的特殊文件系统，例如pipefs)、get_sb_single()函数(对于具有唯一安装点的特殊文件系统，例如sysfs)以及get_sb_nodev()函数(对于可以安装多次的特殊文件系统，例如tmpfs)。</p>
<p>get_sb_bdev()执行的最重要的操作如下：</p>
<ol>
<li>调用open_bdev_excl()打开设备文件名为dev_name的块设备。</li>
<li>调用sget()搜索文件系统的超级块对象链表(type-&gt;fs_supers)。如果找到一个与块设备相关的超级块，则返回它的地址。否则，分配并初始化一个新的超级块对象，把它插入到文件系统链表和超级块全局链表中，并返回其地址。</li>
<li>如果不是新的超级块(它不是上一步分配的，因为文件系统已经被安装)，则跳到第6步。</li>
<li>把参数flags中的值拷贝到超级块的s_flags字段，并将s_id、s_old_blocksize以及s_blocksize字段设置为块设备的合适值。</li>
<li>调用依赖文件系统的函数(该函数作为传递给get_sb_bdev()的最后一个参数)访问磁盘上的超级块信息，并填充新超级块对象的其他字段。</li>
<li>返回新超级块对象的地址。</li>
</ol>
<h2 id="安装根文件系统"><a href="#安装根文件系统" class="headerlink" title="安装根文件系统"></a>安装根文件系统</h2><p>安装根文件系统是系统初始化的关键部分。这是一个相当复杂的过程，因为Linux内核允许根文件系统存放在很多不同的地方，比如硬盘分区、软盘、通过NFS共享的远程文件系统，甚至保存在ramdisk中(RAM中的虚拟块设备)。为了使叙述变得简单，让我们假定根文件系统存放在硬盘分区(毕竟这是最常见的情况)。当系统启动时，内核就要在变量ROOT_DEV中寻找包含根文件系统的磁盘主设备号。当编译内核时，或者向最初的启动装入程序传递一个合适的“root”选项时，根文件系统可以被指定为/dev目录下的一个设备文件。类似地，根文件系统的安装标志存放在root_mountflags变量中。用户可以指定这些标志，或者通过对已编译的内核映像使用rdev外部程序，或者向最初的启动装入程序传递一个合适的rootflags选项来达到(参见附录一)。</p>
<p>安装根文件系统分两个阶段，如下所示：</p>
<ol>
<li>内核安装特殊rootfs文件系统，该文件系统仅提供一个作为初始安装点的空目录。</li>
<li>内核在空目录上安装实际根文件系统。<br>为什么内核不怕麻烦，要在安装实际根文件系统之前安装rootfs文件系统呢？我们知道，rootfs文件系统允许内核容易地改变实际根文件系统。事实上，在某些情况下，内核逐个地安装和卸载几个根文件系统。例如，一个发布版的初始启动光盘可能把具有一组最小驱动程序的内核装入RAM中，内核把存放在ramdisk中的一个最小的文件系统作为根安装。接下来，在这个初始根文件系统中的程序探测系统的硬件(例如，它们判断硬盘是否是EIDE、SCSI等等)，装入所有必需的内核模块，并从物理块设备重新安装根文件系统。</li>
</ol>
<h3 id="阶段1-安装rootfs文件系统"><a href="#阶段1-安装rootfs文件系统" class="headerlink" title="阶段1:安装rootfs文件系统"></a>阶段1:安装rootfs文件系统</h3><p>第一阶段是由init_rootfs()和init_mount_tree()函数完成的，它们在系统初始化过程中执行。</p>
<h4 id="init-rootfs"><a href="#init-rootfs" class="headerlink" title="init_rootfs"></a>init_rootfs</h4><p>init_rootfs()函数注册特殊文件系统类型rootfs;</p>
<pre class="line-numbers language-none"><code class="language-none">struct file_system_type rootfs_fs_type &#x3D;&#123;
	.name &#x3D;&quot;rootfs“;
	·get_sb &#x3D; rootfs_get_sb;
	.kill_sb&#x3D; kill_litter_super;
&#125;;
register_filesystem(&amp;rootfs_fs_type);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="init-mount-tree"><a href="#init-mount-tree" class="headerlink" title="init_mount_tree"></a>init_mount_tree</h4><p>init_mount_tree()函数执行如下操作：</p>
<ol>
<li>调用do_kern_mount()函数，把字符串“rootfs”作为文件系统类型参数传递给它，并把该函数返回的新安装文件系统描述符的地址保存在mnt局部变量中。正如前一节所介绍的，do_kern_mount()最终调用rootfs文件系统的get_sb方法，也即rootfs_get_sb()函数：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">struct superblock *rootfs_get_sb(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)
&#123;
	return get_sb_nodev(fs_type, flags I MS_NOUSER, data, ramfs_fill_super);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>get_sb_nodev()函数执行如下步骤：</p>
<blockquote>
<ol>
<li>调用sget()函数分配新的超级块，传递set_anon_super()函数的地址作为参数。接下来，用合适的方式设置超级块的s_dev字段：主设备号为0，次设备号不同于其他已安装的特殊文件系统的次设备号。</li>
<li>将flags参数的值拷贝到超级块的s_flags字段中。</li>
<li>调用ramfs_fill_super()函数分配索引节点对象和对应的目录项对象，并填充超级块字段值。由于rootfs是一种特殊文件系统，没有磁盘超级块，因此只需执行两个超级块操作。</li>
<li>返回新超级块的地址。</li>
</ol>
</blockquote>
<ol>
<li>为进程0的命名空间分配一个namespace对象，并将它插入到由do_kern_mount()函数返回的已安装文件系统描述符中：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">namespace &#x3D; kmalloc(sizeof(*namespace, GFP_KERNEL);
list_add(&amp;mnt-&gt;mnt_list, &amp;namespace-&gt;list);
namespace-&gt;root &#x3D; mnt;
mnt-&gt;mnt_namespace &#x3D; init_task.namespace &#x3D; namespace;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>将系统中其他每个进程的namespace字段设置为namespace对象的地址；同时初始化引用计数器namespace-&gt;count(缺省情况下，所有的进程共享同一个初始namespace)。</li>
<li>将进程0的根目录和当前工作目录设置为根文件系统。</li>
</ol>
<h3 id="阶段2-安装实际根文件系统"><a href="#阶段2-安装实际根文件系统" class="headerlink" title="阶段2:安装实际根文件系统"></a>阶段2:安装实际根文件系统</h3><p>根文件系统安装操作的第二阶段是由内核在系统初始化即将结束时进行的。根据内核被编译时所选择的选项，和内核装入程序所传递的启动选项，可以有几种方法安装实际根文件系统。为了简单起见，我们只考虑磁盘文件系统的情况，它的设备文件名已通过“root”启动参数传递给内核。同时我们假定除了rootfs文件系统外，没有使用其他初始特殊文件系统。<br>prepare_namespace()函数执行如下操作：</p>
<ol>
<li><p>把root_device_name变量置为从启动参数“root”中获取的设备文件名。同样，把ROOT_DEV变量置为同一设备文件的主设备号和次设备号。</p>
</li>
<li><p>调用mount_root()函数，依次执行如下操作：</p>
<blockquote>
<ol>
<li>调用sys_mknod()在rootfs初始根文件系统中创建设备文件/dev/root，其主、次设备号与存放在ROOT_DEV中的一样。</li>
<li>分配一个缓冲区并用文件系统类型名链表填充它。该链表要么通过启动参数“rootfstype”传送给内核，要么通过扫描文件系统类型单向链表中的元素建立。</li>
<li>扫描上一步建立的文件系统类型名链表。对每个名字，调用sys_mount()试图在根设备上安装给定的文件系统类型。由于每个特定于文件系统的方法使用不同的魔数，因此，对get_sb()的调用大都会失败，但有一个例外，那就是用根设备上实际使用过的文件系统的函数来填充超级块的那个调用，该文件系统被安装在rootfs文件系统的/root目录上。</li>
<li>调用sys_chdir(“/root”)改变进程的当前目录。此目录项通过目录项所在的文件系统挂载点，路径对应的目录项对象唯一确定。</li>
</ol>
</blockquote>
</li>
<li><p>移动rootfs文件系统根目录上的已安装文件系统的安装点。</p>
</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; param1:dev_path---&#x2F;root
&#x2F;&#x2F; param2:mount_path---上一级文件系统根目录
&#x2F;&#x2F; 这样新安装的文件系统成为全局根文件系统
sys_mount(&quot;.”, “&#x2F;&quot;, NULL, MS_MOVE, NULL);
sys_chroot(&quot;.&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，rootfs特殊文件系统没有被卸载：它只是隐藏在基于磁盘的根文件系统下了。</p>
<h2 id="卸载文件系统"><a href="#卸载文件系统" class="headerlink" title="卸载文件系统"></a>卸载文件系统</h2><p>umount()系统调用用来卸载一个文件系统。相应的sys_umount()服务例程作用于两个参数：文件名(多是安装点目录或是块设备文件名)和一组标志。该函数执行下列操作：</p>
<ol>
<li><p>调用path_lookup()查找安装点路径名；该函数把返回的查找操作结果存放在nameidata类型的局部变量nd中。</p>
</li>
<li><p>如果查找的最终目录不是文件系统的安装点，则设置retval返回码为-EINVAL并跳到第6步。这种检查是通过验证nd-&gt;mnt-&gt;mnt_root(它包含由nd.dentry指向的目录项对象地址)进行的。</p>
</li>
<li><p>如果要卸载的文件系统还没有安装在命名空间中，则设置retval返回码为-EINVAL并跳到第6步(回想一下，某些特殊文件系统没有安装点)。这种检查是通过在nd-&gt;mnt上调用check_mnt()函数进行的。</p>
</li>
<li><p>如果用户不具有卸载文件系统的特权，则设置retval返回码为-EPERM并跳到第6步。</p>
</li>
<li><p>调用do_umount()，传递给它的参数为nd.mnt(已安装文件系统对象)和flags(一组标志)。该函数执行下列操作：</p>
<blockquote>
<ol>
<li>从已安装文件系统对象的mnt_sb字段检索超级块对象sb的地址。</li>
<li>如果用户要求强制卸载操作，则调用umount_begin超级块操作中断任何正在进行的安装操作。</li>
<li>如果要卸载的文件系统是根文件系统，且用户并不要求真正地把它卸载下来，则调用do_remount_sb()重新安装根文件系统为只读并终止。</li>
<li>为进行写操作而获取当前进程的namespace-&gt;sem读/写信号量和vfsmount_lock自旋锁。</li>
<li>如果已安装文件系统不包含任何子安装文件系统的安装点，或者用户要求强制卸载文件系统，则调用umount_tree()卸载文件系统(及其所有子文件系统)。</li>
<li>释放vfsmount_lock自旋锁和当前进程的namespace-&gt;sem读/写信号量。</li>
</ol>
</blockquote>
</li>
<li><p>减少相应文件系统根目录的目录项对象和已安装文件系统描述符的引用计数器值；这些计数器值由path_lookup()增加。</p>
</li>
<li><p>返回retval的值。</p>
</li>
</ol>
<h2 id="路径名查找"><a href="#路径名查找" class="headerlink" title="路径名查找"></a>路径名查找</h2><p>当进程必须识别一个文件时，就把它的文件路径名传递给某个VFS系统调用，如open()、mkdir()、rename()或stat()。本节我们要说明VFS如何实现路径名查找，也就是说如何从文件路径名导出相应的索引节点。执行这一任务的标准过程就是分析路径名并把它拆分成一个文件名序列。除了最后一个文件名以外，所有的文件名都必定是目录。如果路径名的第一个字符是“/”，那么这个路径名是绝对路径，因此从current-&gt;fs-&gt;root(进程的根目录)所标识的目录开始搜索。否则，路径名是相对路径，因此从current-&gt;fs-&gt;pwd(进程的当前目录)所标识的目录开始搜索。</p>
<p>在对初始目录的索引节点进行处理的过程中，代码要检查与第一个名字匹配的目录项，以获得相应的索引节点。然后，从磁盘读出包含那个索引节点的目录文件，并检查与第二个名字匹配的目录项，以获得相应的索引节点。对于包含在路径中的每个名字，这个过程反复执行。</p>
<p>目录项高速缓存极大地加速了这一过程，因为它把最近最常使用的目录项对象保留在内存中。正如我们以前看到的，每个这样的对象使特定目录中的一个文件名与它相应的索引节点相联系。因此在很多情况下，路径名的分析可以避免从磁盘读取中间目录。但是，事情并不像看起来那么简单，因为必须考虑如下的Unix和VFS文件系统的特点：</p>
<ol>
<li>对每个目录的访问权必须进行检查，以验证是否允许进程读取这一目录的内容。</li>
<li>文件名可能是与任意一个路径名对应的符号链接；在这种情况下，分析必须扩展到那个路径名的所有分量。</li>
<li>符号链接可能导致循环引用；内核必须考虑这个可能性，并能在出现这种情况时将循环终止。</li>
<li>文件名可能是一个已安装文件系统的安装点。这种情况必须检测到，这样，查找操作必须延伸到新的文件系统。</li>
<li>路径名查找应该在发出系统调用的进程的命名空间中完成。由具有不同命名空间的两个进程使用的相同路径名，可能指定了不同的文件。</li>
</ol>
<p>路径名查找是由path_lookup()函数执行的，它接收三个参数：</p>
<blockquote>
<p>name<br>指向要解析的文件路径名的指针。<br>flags<br>标志的值，表示将会怎样访问查找的文件。在后面的表12-16中列出了所允许的标志。<br>nd<br>nameidata数据结构的地址，这个结构存放了查找操作的结果，其字段如表12-15 所示。</p>
</blockquote>
<p>当path_lookup()返回时，nd指向的nameidata结构用与路径名查找操作有关的数据来填充。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>dentry</td>
<td>自录项对象的地址</td>
</tr>
<tr>
<td>mnt</td>
<td>已安装文件系统对象的地址</td>
</tr>
<tr>
<td>last</td>
<td>路径名的最后一个分量（当LOOKUP PARENT标志被设置时使用）</td>
</tr>
<tr>
<td>flags</td>
<td>查找标志</td>
</tr>
<tr>
<td>last_type</td>
<td>径名最后一个分量的类型（当LOOKUP PARENT标志被设置时使用）</td>
</tr>
<tr>
<td>depth</td>
<td>号链接嵌套的当前级别,它必须小于6</td>
</tr>
<tr>
<td>saved_names</td>
<td>与嵌套的符号链接关联的路径名数组</td>
</tr>
<tr>
<td>intent</td>
<td>单个成员联合体指定如何访问文件</td>
</tr>
</tbody>
</table>
</div>
<p>​        dentry和mnt字段分别指向所解析的最后一个路径分量的目录项对象和已安装文件系统对象。这两个字段“描述“由给定路径名表示的文件。由于path_lookup()函数返回的nameidata结构中的目录项对象和已安装文件系统对象代表了查找操作的结果，因此在path_lookup()的调用者完成使用查找结果之前，这两个对象都不能被释放。因此，path_lookup()增加两个对象引用计数器的值。如果调用者想释放这些对象，则调用path_release()函数，传递给它的参数为nameidata结构的地址。flags字段存放查找操作中使用的某些标志的值；它们在表12-16中列出。这些标志中的大部分可由调用者在path_lookup()的flags参数中进行设置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOOKUP_FOLLOW</td>
<td>如果最后一个分量是符号链接，则解释（追踪）它</td>
</tr>
<tr>
<td>LOOKUP_DIRECTORY</td>
<td>最后一个分量必须是自录</td>
</tr>
<tr>
<td>LOOKUP_CONTINUE</td>
<td>在路径名中还有文件名要检查</td>
</tr>
<tr>
<td>LOOKUPPARENT</td>
<td>查找最后一个分量名所在的目录</td>
</tr>
<tr>
<td>LOOKUP_NOALT</td>
<td>不考虑模拟根目录</td>
</tr>
<tr>
<td>LOOKUP_OPEN</td>
<td>试图打开一个文件</td>
</tr>
<tr>
<td>LOOKUP_CREATE</td>
<td>试图创建一个文件（如果不存在）</td>
</tr>
<tr>
<td>LOOKUP_ACCESS</td>
<td>试图为一个文件检查用户的权限</td>
</tr>
</tbody>
</table>
</div>
<p>path_lookup()函数执行下列步骤：</p>
<ol>
<li><p>如下初始化nd参数的某些字段：</p>
<blockquote>
<ol>
<li>把last_type字段置为LAST_ROOT(如果路径名是一个“/”或“/”序列，那么这是必需的)。</li>
<li>把flags字段置为参数flags的值。</li>
<li>把depth字段置为0。</li>
</ol>
</blockquote>
</li>
<li><p>为进行读操作而获取当前进程的current-&gt;fs-&gt;lock读/写信号量。</p>
</li>
<li><p>如果路径名的第一个字符是“/“，那么查找操作必须从当前根目录开始：获取相应已安装文件对象(current-&gt;fs-&gt;rootmnt)和目录项对象(current-&gt;fs-&gt;root)的地址，增加引用计数器的值，并把它们的地址分别存放在nd-&gt;mnt和nd-&gt;dentry中。</p>
</li>
<li><p>否则，如果路径名的第一个字符不是“/“，则查找操作必须从当前工作目录开始：获得相应已安装文件系统对象(current-&gt;fs-&gt;pwdmmt)和目录项对象(current-&gt;fs-&gt;pwd)的地址，增加引用计数器的值，并把它们的地址分别存放在nd-&gt;mnt和nd-&gt;dentry中。</p>
</li>
<li><p>释放当前进程的current-&gt;fs-&gt;lock读/写信号量。</p>
</li>
<li><p>把当前进程描述符中的total_link_count字段置为0。</p>
</li>
<li><p>调用link_path_walk()函数处理正在进行的查找操作：return link_path_walk(name,nd);</p>
</li>
</ol>
<p>我们现在准备描述路径名查找操作的核心，也就是link_path_walk()函数。它接收的参数为要解析的路径名指针name和nameidata数据结构的地址nd。为了简单起见，我们首先描述当LOOKUP_PARENT未被设置且路径名不包含符号链接时，link_path_walk()做些什么(标准路径名查找)。接下来，我们讨论LOOKUP_PARENT 被设置的情况：这种类型的查找在创建、删除或更名一个目录项时是需要的，也就是在父目录名查找过程中是需要的。最后，我们阐明该函数如何解析符号链接。</p>
<h3 id="标准路径名查找"><a href="#标准路径名查找" class="headerlink" title="标准路径名查找"></a>标准路径名查找</h3><p>​    嗯，很长！</p>
<p>当LOOKUP_PARENT标志被清零时，link_path_walk()执行下列步骤：</p>
<ol>
<li><p>用nd-&gt;flags初始化lookup_flags局部变量。</p>
</li>
<li><p>跳过路径名第一个分量前的任何斜杠(/)。</p>
</li>
<li><p>如果剩余的路径名为空，则返回0。在nameidata数据结构中，dentry和mnt字段指向原路径名最后一个所解析分量对应的对象。</p>
</li>
<li><p>如果nd描述符中的depth字段的值为正，则把lookup_flags局部变量置为LOOKUP_FOLLOW标志。</p>
</li>
<li><p>执行一个循环，把name参数中传递的路径名分解为分量(中间的“/”被当作文件名分隔符对待)；对于每个找到的分量，该函数：</p>
<blockquote>
<p>a. 从nd-&gt;dentry-&gt;d_inode检索最近一个所解析分量的索引节点对象的地址(在第一次循环中，索引节点指向开始路径名查找的目录)。<br>b. 检查存放到索引节点中的最近那个所解析分量的许可权是否允许执行(在Unix中，只有目录是可执行的，它才可以被遍历)。如果索引节点有自定义的permission方法，则执行它；否则，执行exec_permission_lite()函数，该函数检查存放在索引节点i_mode字段的访问模式和运行进程的特权。在两种情况中，如果最近所解析分量不允许执行，那么link_path_walk()跳出循环并返回一个错误码。<br>c. 考虑要解析的下一个分量。从它的名字，函数为目录项高速缓存散列表计算一个32位的散列值。<br>d. 如果“/”终止了要解析的分量名，则跳过“/”之后的任何尾部“/”。<br>e. 如果要解析的分量是原路径名中的最后一个分量，则跳到第6步。<br>f. 如果分量名是一个“.“(单个圆点)，则继续下一个分量(“.“指的是当前目录，因此，这个点在目录内没有什么效果)。<br>g. 如果分量名是“…“(两个圆点)，则尝试回到父目录：</p>
<blockquote>
<p>(1) 如果最近解析的目录是进程的根目录(nd-&gt;dentry等于current-&gt;fs-&gt;root，而nd-&gt;mnt等于current-&gt;fs-&gt;rootmnt)，那么再向上追踪是不允许的：在最近解析的分量上调用follow_mount()，继续下一个分量。<br>(2) 如果最近解析的目录是nd-&gt;mnt文件系统的根目录(nd-&gt;dentry等于nd-&gt;mnt-&gt;mnt_root)，并且这个文件系统也没有被安装在其他文件系统之上(nd-&gt;mnt等于nd-&gt;mnt-&gt;mnt_parent)，那么nd-&gt;mnt文件系统通常就是命名空间的根文件系统：在这种情况下，再向上追踪是不可能的，因此在最近解析的分量上调用follow_mount()，继续下一个分量。<br>(3) 如果最近解析的目录是nd-&gt;mnt文件系统的根目录，而这个文件系统被安装在其他文件系统之上，那么就需要文件系统交换。因此，把nd-&gt;dentry置为nd-&gt;mnt-&gt;mnt_mountpoint（这个是在上一级文件系统下的路径），且把nd-&gt;mnt置为nd-&gt;mnt-&gt;mnt_parent，然后重新开始第5g步(回想一下，几个文件系统可以安装在同一个安装点上)。这样进入一个新的文件系统，在此系统中执行…逻辑。<br>(4) 如果最近解析的目录不是已安装文件系统的根目录，那么必须回到父目录：把nd-&gt;dentry置为nd-&gt;dentry-&gt;d_parent，在父目录上调用follow_mount()，继续下一个分量。</p>
<p>follow_mount()函数检查nd-&gt;dentry是否是某文件系统的安装点(nd-&gt;dentry-&gt;d_mounted的值大于0)；如果是，则调用lookup_mnt()搜索目录项高速缓存中已安装文件系统的根目录，并把nd-&gt;dentry和nd-&gt;mnt更新为相应已安装文件系统的对象地址；然后重复整个操作(几个文件系统可以安装在同一个安装点上)。从本质上说，由于进程可能从某个文件系统的目录开始路径名的查找，而该目录被另一个安装在其父目录上的文件系统所隐藏，那么当需要回到父目录时，则调用follow_mount()函数。</p>
</blockquote>
<p>h. 分量名既不是“.”，也不是“…”，因此函数必须在目录项高速缓存中查找它。如果低级文件系统有一个自定义的d_hash目录项方法，则调用它来修改已在第5c步计算出的散列值。<br>i. 把nd-&gt;flags字段中LOOKUP_CONTINUE标志对应的位置位，这表示还有下一个分量要分析。<br>j. 调用do_lookup()，得到与给定的父目录(nd-&gt;dentry)和文件名(要解析的路径名分量)相关的目录项对象。该函数本质上首先调用__d_lookup()在目录项高速缓存中搜索分量的目录项对象。如果没有找到这样的目录项对象，则调用real_lookup()。而real_lookup()执行索引节点的lookup方法从磁盘读取目录，创建一个新的目录项对象并把它插入到目录项高速缓存中，然后创建一个新的索引节点对象并把它插入到索引节点高速缓存中。在这一步结束时，next局部变量中的dentry和mnt字段将分别指向这次循环要解析的分量名的目录项对象和已安装文件系统对象。<br>k. 调用follow_mount()函数检查刚解析的分量(next.dentry)是否指向某个文件系统安装点的一个目录(next.dentry-&gt;d_mounted值大于0)。follow_mount()更新next.dentry和next.mnt的值，以使它们指向由这个路径名分量所表示的目录上安装的最上层文件系统的目录项对象和已安装文件系统对象。<br>l. 检查刚解析的分量是否指向一个符号链接(next.dentry-&gt;d_inode具有一个自定义的follow_link方法)。<br>m. 检查刚解析的分量是否指向一个目录(next.dentry-&gt;d_inode具有一个自定义的lookup方法)。如果没有，返回一个错误码-ENOTDIR，因为这个分量位于原路径名的中间。<br>n. 把nd-&gt;dentry和nd-&gt;mnt分别置为next.dentry和next.mnt，然后继续路径名的下一个分量。</p>
</blockquote>
</li>
<li><p>现在，除了最后一个分量，原路径名的所有分量都被解析。清除nd-&gt;flags中的LOOKUP_CONTINUE标志。</p>
</li>
<li><p>如果路径名尾部有一个“/”，则把lookup_flags局部变量中LOOKUP_FOLLOW和LOOKUP_DIRECTORY标志对应的位置位，以强制由后面的函数来解释最后一个作为目录名的分量。</p>
</li>
<li><p>检查lookup_flags变量中LOOKUP_PARENT标志的值。下面假定这个标志被置为0，并把相反的情况推迟到下一节介绍。</p>
</li>
<li><p>如果最后一个分量名是“.”(单个圆点)，则终止执行并返回值0(无错误)。在nd指向的nameidata数据结构中，dentry和mnt字段指向路径名中倒数第二个分量对应的对象(任何分量“.”在路径名中没有效果)。</p>
</li>
<li><p>如果最后一个分量名是“…”(两个圆点)，则尝试回到父目录：</p>
</li>
</ol>
<blockquote>
<p>a. 如果最后解析的目录是进程的根目录(nd-&gt;dentry等于current-&gt;fs-&gt;root，nd-&gt;mnt等于current-&gt;fs-&gt;rootmnt)，则在倒数第二个分量上调用follow_mount()，终止执行并返回值0(无错误)。nd-&gt;dentry和nd-&gt;mnt指向路径名的倒数第二个分量对应的对象，也就是进程的根目录。<br>b. 如果最后解析的目录是nd-&gt;mnt文件系统的根目录(nd-&gt;dentry等于nd-&gt;mnt-&gt;mnt_root)，并且该文件系统没有被安装在另一个文件系统之上(nd-&gt;mnt等于nd-&gt;mnt-&gt;mnt_parent)，那么再向上搜索是不可能的，因此在倒数第二个分量上调用follow_mount()，终止执行并返回值0(无错误)。<br>c. 如果最后解析的目录是nd-&gt;mnt文件系统的根目录，并且该文件系统被安装在其他文件系统之上，那么把nd-&gt;dentry和nd-&gt;mnt分别置为nd-&gt;mnt-&gt;mnt_mountpoint和nd-&gt;mnt-&gt;mnt_parent，然后重新执行第10步。<br>d. 如果最后解析的目录不是已安装文件系统的根目录，则把nd-&gt;dentry置为nd-&gt;dentry-&gt;d_parent，在父目录上调用follow_mount()，终止执行并返回值0(无错误)。nd-&gt;dentry和nd-&gt;mnt指向前一个分量(即路径名倒数第二个分量)对应的对象。</p>
</blockquote>
<ol>
<li>路径名的最后分量名既不是“.”也不是“…”，因此，必须在高速缓存中查找它。如果低级文件系统有自定义的d_hash目录项方法，则该函数调用它来修改在第5c步已经计算出的散列值。</li>
<li>调用do_lookup()，得到与父目录和文件名相关的目录项对象（在这一步结束时，next局部变量存放的是指向最后分量名对应的目录项和已安装文件系统描述符的指针。）</li>
<li>调用follow_mount()检查最后一个分量名是否是某个文件系统的一个安装点，如果是，则把next局部变量更新为最上层已安装文件系统根目录对应的目录项对象和已安装文件系统对象的地址。</li>
<li>检查在lookup_flags中是否设置了LOOKUP_FOLLOW标志，且索引节点对象next.dentry-&gt;d_inode是否有一个自定义的follow_link方法。如果是，分量就是一个必须进行解释的符号链接。</li>
<li>要解析的分量不是一个符号链接或符号链接不该被解释。把nd-&gt;mnt和nd-&gt;dentry字段分别置为next.mnt和next.dentry的值。最后的目录项对象就是整个查找操作的结果。</li>
<li>检查nd-&gt;dentry-&gt;d_inode是否为NULL。这发生在没有索引节点与目录项对象关联时，通常是因为路径名指向一个不存在的文件。在这种情况下，返回一个错误码-ENOENT。</li>
<li>路径名的最后一个分量有一个关联的索引节点。如果在lookup_flags中设置了LOOKUP_DIRECTORY标志，则检查索引节点是否有一个自定义的lookup方法，也就是说它是一个目录。如果没有，则返回一个错误码-ENOTDIR。</li>
<li>返回值0(无错误)。nd-&gt;dentry和nd-&gt;mnt指向路径名的最后分量。</li>
</ol>
<h3 id="父路径名查找"><a href="#父路径名查找" class="headerlink" title="父路径名查找"></a>父路径名查找</h3><p>在很多情况下，查找操作的真正目的并不是路径名的最后一个分量，而是最后一个分量的前一个分量。例如，当文件被创建时，最后一个分量表示还不存在的文件的文件名，而路径名中的其余路径指定新链接必须插入的目录。因此，查找操作应当取回最后分量的前一个分量的目录项对象。另举一个例子，把路径名/foo/bar表示的文件bar拆分出来就包含从目录foo中移去bar。因此，内核真正的兴趣在于访问文件目录foo而不是bar。当查找操作必须解析的是包含路径名最后一个分量的目录而不是最后一个分量本身时，使用LOOKUP_PARENT标志。当LOOKUP_PARENT标志被设置时，link_path_walk()函数也在nameidata数据结构中建立last和last_type字段。last字段存放路径名中的最后一个分量名。last_type 字段标识最后一个分量的类型；可以把它置为如表12-17所示的值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LAST_NORM</td>
<td>最后一个分量是普通文件名</td>
</tr>
<tr>
<td>LAST_ROOT</td>
<td>最后一个分量是“/”（也就是整个路径名为“/”）</td>
</tr>
<tr>
<td>LAST_DOT</td>
<td>最后一个分量是“.”</td>
</tr>
<tr>
<td>LAST_DOTDOT</td>
<td>最后一个分量是“..”</td>
</tr>
<tr>
<td>LAST_BIND</td>
<td>最后一个分量是链接到特殊文件系统的符号链接</td>
</tr>
</tbody>
</table>
</div>
<p>​    当整个路径名的查找操作开始时，LAST_ROOT标志是由path_lookup()设置的缺省值。如果路径名正好是“/”，则内核不改变last_type字段的初始值。last_type字段的其他值在LOOKUP_PARENT标志置位时由link_path_walk()设置；<br>在这种情况下，函数执行前一节描述的步骤，直到第8步。不过，从第8步往后，路径名中最后一个分量的查找操作是不同的：</p>
<ol>
<li>把nd-&gt;last置为最后一个分量名。</li>
<li>把nd-&gt;last_type初始化为LAST_NORM。</li>
<li>如果最后一个分量名为“.”(一个圆点)，则把nd-&gt;last_type置为LAST_DOT。</li>
<li>如果最后一个分量名为“…”(两个圆点)，则把nd-&gt;last_type置为LAST_DOTDOT。</li>
<li>通过返回值0(无错误)终止。<br>你可以看到，最后一个分量根本就没有被解释。因此，当函数终止时，nameidata数据结构的dentry和mnt字段指向最后一个分量所在目录对应的对象。</li>
</ol>
<h3 id="符号链接的查找"><a href="#符号链接的查找" class="headerlink" title="符号链接的查找"></a>符号链接的查找</h3><p>回想一下，符号链接是一个普通文件，其中存放的是另一个文件的路径名。路径名可以包含符号链接，且必须由内核来解析。例如，如果/foo/bar是指向(包含路径名)…/dir的一个符号链接，那么，/foo/bar/file 路径名必须由内核解析为对/dir/file文件的引用。在这个例子中，内核必须执行两个不同的查找操作。第一个操作解析/foo/bar，当内核发现bar是一个符号链接名时，就必须提取它的内容并把它解释为另一个路径名。第二个路径名操作从第一个操作所达到的目录开始，继续到符号链接路径名的最后一个分量被解析。接下来，原来的查找操作从第二个操作所达到的目录项恢复，且有了原目录名中紧随符号链接的分量。</p>
<p>对于更复杂的情景，含有符号链接的路径名可能包含其他的符号链接。你可能认为解析这类符号链接的内核代码是相当难理解的，但并非如此；代码实际上是相当简单的，因为它是递归的。</p>
<p>然而，难以驾驭的递归本质上是危险的。例如，假定一个符号链接指向自己。当然，解析含有这样符号链接的路径名可能导致无休止的递归调用流，这又依次引发内核栈的溢出。当前进程的描述符中的link_count字段用来避免这种问题：每次递归执行前增加这个字段的值，执行之后减少其值。如果该字段的值达到6，整个循环操作就以错误码结束。因此，符号链接嵌套的层数不超过5。</p>
<p>此外，当前进程的描述符中的total_link_count字段记录在原查找操作中有多少符号链接(甚至非嵌套的)被跟踪。如果这个计数器的值到40，则查找操作中止。没有这个计数器，怀有恶意的用户就可能创建一个病态的路径名，让其中包含很多连续的符号链接，使内核在无休止的查找操作中冻结。</p>
<p>这就是代码基本工作的方式：一旦link_path_walk()函数检索到与路径名分量相关的目录项对象，就检查相应的索引节点对象是否有自定义的follow_link方法。如果是，索引节点就是一个符号链接，在原路径名的查找操作进行之前就必须先对这个符号链接进行解释。</p>
<p>在这种情况下，link_path_walk()函数调用do_follow_link()，前者传递给后者的参数为符号链接目录项对象的地址dentry和nameidata数据结构的地址nd。</p>
<p>do_follow_link()依次执行下列步骤：</p>
<ol>
<li>检查current-&gt;link_count小于5；否则，返回错误码-ELOOP。</li>
<li>检查current-&gt;total_link_count小于40；否则，返回错误码-ELOOP。</li>
<li>如果当前进程需要，则调用cond_resched()进行进程交换(设置当前进程描述符thread_info中的TIF_NEED_RESCHED标志)。</li>
<li>递增current-&gt;link_count、current-&gt;total_link_count和nd-&gt;depth的值。</li>
<li>更新与要解析的符号链接关联的索引节点的访问时间。</li>
<li>调用与具体文件系统相关的函数来实现follow_link方法，给它传递的参数为dentry和nd。它读取存放在符号链接索引节点中的路径名，并把这个路径名保存在nd-&gt;saved_names数组的合适项中。</li>
<li>调用__vfs_follow_link()函数，给它传递的参数为地址nd和nd-&gt;saved_names数组中路径名的地址。</li>
<li>如果定义了索引节点对象的put_link方法，就执行它，释放由follow_link方法分配的临时数据结构。</li>
<li>减少current-&gt;link_count和nd-&gt;depth字段的值。</li>
<li>返回由__vfs_follow_link()函数返回的错误码(0表示无错误)。</li>
</ol>
<p>__vfs_follow_link()函数本质上依次执行下列操作：</p>
<blockquote>
<p>a. 检查符号链接路径名的第一个字符是否是“/“：在这种情况下，已经找到一个绝对路径名，因此没有必要在内存中保留前一个路径的任何信息。 如果是，对nameidata数据结构调用path_release()，因此释放由前一个查找步骤产生的对象； 然后，设置nameidata数据结构的dentry和mnt字段，以使它们指向当前进程的根目录。<br>b. 调用link_path_walk()解析符号链的路径名，传递给它的参数为路径名和nd。<br>c. 返回从link_path_walk()取回的值。</p>
</blockquote>
<p>​    当do_follow_link()最后终止时，它把局部变量next的dentry字段设置为目录项对象的地址，而这个地址由符号链接传递给原先就执行的link_path_walk()。link_path_walk()函数然后进行下一步 。</p>
<h2 id="VFS系统调用的实现"><a href="#VFS系统调用的实现" class="headerlink" title="VFS系统调用的实现"></a>VFS系统调用的实现</h2><p>​    为了简短起见，我们不打算对表12-1中列出的所有VFS系统调用的实现进行讨论。不过，概略叙述几个系统调用的实现还是有用的，这里仅仅说明VFS的数据结构怎样互相作用。让我们重新考虑一下在本章开始所提到的例子，用户发出了一条shell命令：把/floppy/TEST中的MS-DOS文件拷贝到/tmp/test中的Ext2文件中。命令shell调用一个外部程序(如cp)，我们假定cp执行下列代码片段：</p>
<pre class="line-numbers language-none"><code class="language-none">inf &#x3D; open(“&#x2F;floppy&#x2F;TEST“, O_RDONLY, 0);
outf &#x3D; open(“&#x2F;tmp&#x2F;test“, 0_WRONLY I O_CREATIO_TRUNC, 0600);
do &#123;
	len &#x3D;read(inf, buf, 4096);
	write(outf, buf, len);
&#125; while(len);
close(outf);
close(inf);
12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    实际上，真正的cp程序的代码要更复杂些，因为它还必须检查由每个系统调用返回的可能的出错码。在我们的例子中，我们只把注意力集中在拷贝操作的“正常“行为上。</p>
<h3 id="open-系统调用"><a href="#open-系统调用" class="headerlink" title="open()系统调用"></a>open()系统调用</h3><p>open()系统调用的服务例程为sys_open()函数，该函数接收的参数为：要打开文件的路径名filename、访问模式的一些标志flags，以及如果该文件被创建所需要的许可权位掩码mode。如果该系统调用成功，就返回一个文件描述符，也就是指向文件对象的指针数组current-&gt;files-&gt;fd中分配给新文件的索引；否则，返回-1。</p>
<p>在我们的例子中，open()被调用两次；第一次是为读(O_RDONLY标志)而打开/floppy/TEST，第二次是为写(O_WRONLY标志)而打开/mp/test。如果/mp/test不存在，则该文件被创建(0_CREAT标志)，文件主对该文件具有独占的读写访问权限(在第三个参数中的八进制数0600)。</p>
<p>相反，如果该文件已经存在，则从头开始重写它(0_TRUNC标志)。表12-18列出了open()系统调用的所有标志。</p>
<ul>
<li>O_RDONLY ：以只读方式打开文件</li>
<li>O_WRONLY ：以只写方式打开文件</li>
<li>O_RDWR ：以可读可写方式打开文件</li>
<li>O_APPEND：每次进行写操作时，内核都会先定位到文件尾，再执行写操作。</li>
<li>O_ASYNC：使用异步 I/O 模式。</li>
<li>O_CLOEXEC ：在打开文件的时候，就为文件描述符设置 FD_CLOEXEC 标志。这是一个新的选项，用于解决在多线程下 fork 与用 fcntl 设置 FD_CLOEXEC 的竞争问题。某些应用使用 fork 来执行第三方的业务，为了避免泄露已打开文件的内容， 那些文件会设置 FD_CLOEXEC 标志。但是 fork 与 fcntl 是两次调用，在多线程下， 可能会在 fcntl 调用前，就已经 fork 出子进程了，从而导致该文件句柄暴露给子进程。关于 O_CLOEXEC 的用途。</li>
<li>O_CREAT：当文件不存在时，就创建文件。</li>
<li>O_DIRECT：对该文件进行直接 I/O，不使用 VFS Cache。</li>
<li>O_DIRECTORY：要求打开的路径必须是目录。</li>
<li>O_EXCL：该标志用于确保是此次调用创建的文件，需要与 O_CREAT 同时使用； 当文件已经存在时，open 函数会返回失败。</li>
<li>O_LARGEFILE：表明文件为大文件。</li>
<li>O_NOATIME：读取文件时，不更新文件最后的访问时间。</li>
<li>O_NONBLOCK、O_NDELAY：将该文件描述符设置为非阻塞的（默认都是阻塞的）。</li>
<li>O_SYNC ：设置为 I/O 同步模式，每次进行写操作时都会将数据同步到磁盘，然后write 才能返回。</li>
<li>O_TRUNC：在打开文件的时候，将文件长度截断为0，需要与O_RDWR或O_WRONLY同时使用。在写文件时，如果是作为新文件重新写入，一定要使用O_TRUNC标志，否则可能会造成旧内容依然存在于文件中的错误，如生成配置文件、pid文件等。</li>
</ul>
<p>下面来描述一下sys_open()函数的操作。它执行如下操作：</p>
<ol>
<li>调用getname()从进程地址空间读取该文件的路径名。</li>
<li>调用get_unused_fd()在current-&gt;files-&gt;fd中查找一个空的位置。相应的索引(新文件描述符)存放在fd局部变量中。</li>
<li>调用filp_open()函数，传递给它的参数为路径名、访问模式标志以及许可权位掩码。这个函数依次执行下列步骤：<br>a. 把访问模式标志拷贝到namei_flags标志中，但是，用特殊的格式对访问模式标志O_RDONLY、O_WRONLY和O_RDWR进行编码：如果文件访问需要读特权，那么只设置namei_flags标志的下标为0的位(最低位)；类似地，如果文件访问需要写特权，就只设置下标为1的位。注意，不可能在open()系统调用中不指定文件访问的读或写特权；不过，这种情况在涉及符号链接的路径名查找中则是有意义的。<br>b. 调用open_namei()，传递给它的参数为路径名、修改的访问模式标志以及局部nameidata数据结构的地址。该函数以下列方式执行查找操作：<br>b.1. 如果访问模式标志中没有设置O_CREAT，则不设置LOOKUP_PARENT标志而设置LOOKUP_OPEN标志后开始查找操作。<br>b.2. 只有O_NOFOLLOW被清零，才设置LOOKUP_FOLLOW标志。<br>b.3. 只有设置了O_DIRECTORY标志，才设置LOOKUP_DIRECTORY标志。<br>b.4. 如果在访问模式标志中设置了O_CREAT，则以LOOKUP_PARENT、LOOKUP_OPEN和LOOKUP_CREATE标志的设置开始查找操作。一旦path_lookup()函数成功返回，则检查请求的文件是否已存在。如果不存在，则调用父索引节点的create方法分配一个新的磁盘索引节点。open_namei()函数也在查找操作确定的文件上执行几个安全检查。例如，该函数检查与已找到的目录项对象关联的索引节点是否存在、它是否是一个普通文件，以及是否允许当前进程根据访问模式标志访问它。如果文件也是为写打开的，则该函数检查文件是否被其他进程加锁。</li>
</ol>
<p>c. 调用dentry_open()函数，传递给它的参数为访问模式标志、目录项对象的地址以及由查找操作确定的已安装文件系统对象。该函数依次执行下列操作：<br>(1). 分配一个新的文件对象。<br>(2). 根据传递给open()系统调用的访问模式标志初始化文件对象的f_flags和f_mode字段。<br>(3). 根据作为参数传递来的目录项对象的地址和已安装文件系统对象的地址初始化文件对象的f_fentry和f_vfsmnt字段。<br>(4). 把f_op字段设置为相应索引节点对象i_fop字段的内容。这就为进一步的文件操作建立起所有的方法。<br>(5). 把文件对象插入到文件系统超级块的s_files字段所指向的打开文件的链表。<br>(6). 如果文件操作的open方法被定义，则调用它。<br>(7). 调用file_ra_state_init()初始化预读的数据结构。<br>(8). 如果O_DIRECT标志被设置，则检查直接I/O操作是否可以作用于文件。<br>(9). 返回文件对象的地址。<br>d… 返回文件对象的地址。</p>
<ol>
<li>把current-&gt;files-&gt;fd[fd]置为由dentry_open()返回的文件对象的地址。</li>
<li>返回fd。</li>
</ol>
<h3 id="read-和write-系统调用"><a href="#read-和write-系统调用" class="headerlink" title="read()和write()系统调用"></a>read()和write()系统调用</h3><p>让我们再回到cp例子的代码。open()系统调用返回两个文件描述符，分别存放在inf 和outf变量中。然后，程序开始循环。在每次循环中，/floppy/TEST文件的一部分被拷贝到本地缓冲区(read()系统调用)中，然后，这个本地缓冲区中的数据又被拷贝到/tmp/test文件(write()系统调用)。read()和write()系统调用非常相似。它们都需要三个参数：一个文件描述符fd、一个内存区的地址buf(该缓冲区包含要传送的数据)，以及一个数count(指定应该传送多少字节)。当然，read()把数据从文件传送到缓冲区，而write()执行相反的操作。两个系统调用都返回所成功传送的字节数，或者发送一个错误条件的信号并返回-1。</p>
<p>返回值小于count并不意味着发生了错误。即使请求的字节没有都被传送，也总是允许内核终止系统调用，因此用户应用程序必须检查返回值并重新发出系统调用(如果必要)。在以下几种典型情况下返回小的值：当从管道或终端设备读取时，当读到文件的末尾时，或者当系统调用被信号中断时。文件结束条件(EOF)很容易从read()的空返回值中判断出来。这个条件不会与因信号引起的异常终止混淆在一起，因为如果读取数据之前read()被一个信号中断，则发生一个错误。</p>
<p>读或写操作总是发生在由当前文件指针所指定的文件偏移处(文件对象的f_pos字段)。两个系统调用都通过把所传送的字节数加到文件指针上而更新文件指针。简而言之，sys_read()(read()的服务例程)和sys_write()(write()的服务例程)几乎都执行相同的步骤：</p>
<ol>
<li>调用fget_light()从fd获取相应文件对象的地址file。</li>
<li>如果file-&gt;f_mode中的标志不允许所请求的访问(读或写操作)，则返回一个错误码-EBADF。</li>
<li>如果文件对象没有read()或aio_read()(write()或aio_write())文件操作，则返回一个错误码-EINVAL。</li>
<li>调用access_ok()粗略地检查buf和count参数。</li>
<li>调用rw_verify_area()对要访问的文件部分检查是否有冲突的强制锁。如果有，则返回一个错误码，如果该锁已经被F_SETLKW命令请求，那么就挂起当前进程。</li>
<li>调用file-&gt;f_op-&gt;read或file-&gt;f_op-&gt;write方法(如果已定义)来传送数据；否则，调用file-&gt;f_op-&gt;aio_read或file-&gt;f_op-&gt;aio_write方法。所有这些方法都返回实际传送的字节数。另一方面的作用是，文件指针被适当地更新。</li>
<li>调用fput_light()释放文件对象。</li>
<li>返回实际传送的字节数。</li>
</ol>
<h3 id="close-系统调用"><a href="#close-系统调用" class="headerlink" title="close()系统调用"></a>close()系统调用</h3><p>在我们例子的代码中，循环结束发生在read()系统调用返回0时，也就是说，发生在/floppy/TEST中的所有字节被拷贝到/tmp/test中时。然后，程序关闭打开的文件，这是因为拷贝操作已经完成。close()系统调用接收的参数为要关闭文件的文件描述符fd。sys_close()服务例程执行下列操作：</p>
<ol>
<li>获得存放在current-&gt;files-&gt;fd[fd]中的文件对象的地址；如果它为NULL，则返回一个出错码。</li>
<li>把current-&gt;files-&gt;fd[fd]置为NULL。释放文件描述符fd，这是通过清除current-&gt;files中的open_fds和close_on_exec字段的相应位来进行的。</li>
<li>调用filp_close()，该函数执行下列操作：<br>a. 调用文件操作的flush方法(如果已定义)。<br>b. 释放文件上的任何强制锁。<br>c. 调用fput()释放文件对象。</li>
<li>返回0或一个出错码。出错码可由flush方法或文件中的前一个写操作错误产生。</li>
</ol>
<h3 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h3><p>当一个文件可以被多个进程访问时，就会出现同步问题。如果两个进程试图对文件的同一位置进行写会出现什么情况？或者，如果一个进程从文件的某个位置进行读而另一个进程正在对同一位置进行写会出现什么情况?</p>
<p>在传统的Unix系统中，对文件同一位置的同时访问会产生不可预料的结果。但是，Unix 系统提供了一种允许进程对一个文件区进行加锁的机制，以使同时访问可以很容易地被避免。POSIX标准规定了基于fcntl()系统调用的文件加锁机制。这样就有可能对文件的任意一部分(甚至一个字节)加锁或对整个文件(包含以后要追加的数据)加锁。因为进程可以选择仅仅对文件的一部分加锁，因此，它也可以在文件的不同部分保持多个锁。</p>
<p>这种锁并不把不知道加锁的其他进程关在外面。与用于保护代码中临界区的信号量类似，可以认为这种锁起“劝告“的作用，因为只有在访问文件之前其他进程合作检查锁的存在时，锁才起作用。因此，POSIX的锁被称为劝告锁(advisory lock)。</p>
<p>传统的BSD变体通过flock()系统调用来实现劝告锁。这个调用不允许进程对文件的一个区字段进行加锁，而只能对整个文件进行加锁。传统的System V变体提供了lockf()库函数，它仅仅是fcntl()的一个接口。</p>
<p>更重要的是，System V Release3引入了强制加锁(mandatory locking)；内核检查open()、read()和write()系统调用的每次调用都不违背在所访问文件上的强制锁。因此，强制锁甚至在非合作的进程之间也被强制加上。</p>
<p>不管进程是使用劝告锁还是强制锁，它们都可以使用共享读锁和独占写锁。在文件的某个区字段上，可以有任意多个进程进行读，但在同一时刻只能有一个进程进行写。此外，当其他进程对同一个文件都拥有自己的读锁时，就不可能获得一个写锁，反之亦然。</p>
<h3 id="Linux文件加锁"><a href="#Linux文件加锁" class="headerlink" title="Linux文件加锁"></a>Linux文件加锁</h3><p>Linux支持所有的文件加锁方式：劝告锁和强制锁，以及fcntl()、flock(〉和lockf()系统调用。不过，lockf()系统调用仅仅是一个标准的库函数。flock()系统调用不管MS_MANDLOCK安装标志如何设置，只产生劝告锁。这是任何类Unix操作系统所期望的系统调用行为。在Linux中，增加了一种特殊的flock()强制锁，以允许对专有的网络文件系统的实现提供适当的支持。这就是所谓的共享模式强制锁；当这个锁被设置时，其他任何进程都不能打开与锁访问模式冲突的文件。不鼓励本地Unix应用程序中使用这个特征，因为这样加锁的源代码是不可移植的。</p>
<p>在Linux中还引入了另一种基于fcntl()的强制锁，叫做租借锁(lease)。当一个进程试图打开由租借锁保护的文件时，它照样被阻塞。然而，拥有锁的进程接收到一个信号。一旦该进程得到通知，它应当首先更新文件，以使文件的内容保持一致，然后释放锁。如果拥有者不在预定的时间间隔(可以通过在/proc/sys/fs/lease-break-time文件中写入秒数来进行调整，通常为45s)内这么做，则租借锁由内核自动删除，且允许阻塞的进程继续执行。</p>
<p>进程可以采用以下两种方式获得或释放一个文件劝告锁：<br>· 发出flock()系统调用。传递给它的两个参数为文件描述符fd和指定锁操作的命令。该锁应用于整个文件。<br>· 使用fcntl()系统调用。传递给它的三个参数为文件描述符fd、指定锁操作的命令以及指向flock结构的指针(参见表12-20)。flock结构中的几个字段允许进程指定要加锁的文件部分。因此进程可以在同一文件的不同部分保持几个锁。</p>
<p>fcntl()和flock()系统调用可以在同一文件上同时使用，但是通过fcntl()加锁的文件看起来与通过flock()加锁的文件不一样，反之亦然。这样当应用程序使用一种依赖于某个库的锁，而该库同时使用另一种类型的锁时，可以避免发生死锁。</p>
<p>处理强制文件锁要更复杂些。步骤如下：</p>
<ol>
<li>安装文件系统时强制锁是必需的，可使用mount命令的-o mand选项在mount()系统调用中设置MS_MANDLOCK标志。缺省操作是不使用强制锁。</li>
<li>通过设置文件的set-group位(SGID)和清除group-execute许可权位将它们标记为强制锁的候选者。因为当group-execute位为0时，set-group位也没有任何意义，因此内核将这种合并解释成使用强制锁而不是劝告锁。</li>
<li>使用fcntl()系统调用获得或释放一个文件锁。</li>
</ol>
<p>处理租借锁比处理强制锁要容易得多：<br>调用具有F_SETLEASE或F_GETLEASE命令的系统调用fcntl()就足够了。使用另一个带有F_SETSIG命令的fcntl()系统调用可以改变传送给租借锁进程拥有者的信号类型。</p>
<p>当维护所有可以修改文件内容的系统调用时，除了read()和write()系统调用中的检查以外，内核还需要考虑强制锁的存在性。例如，如果文件中存在任何强制锁，那么带有O_TRUNC标志的open()系统调用就会失效。下一节描述内核使用的主要数据结构，它们用于处理由flock()(FL_FLOCK锁)和fcntl()系统调用(FL_POSIX锁)实现的文件锁。</p>
<h3 id="文件锁的数据结构"><a href="#文件锁的数据结构" class="headerlink" title="文件锁的数据结构"></a>文件锁的数据结构</h3><p>Linux中所有类型的锁都是由相同的file_lock数据结构描述的，它的字段如表12-19 所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>struct file_lock*</th>
<th>fl_next</th>
<th>与索引节点相关的锁列表中下一个元素</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct list_head</td>
<td>fl_link</td>
<td>指向活跃列表或者被阻塞列表</td>
</tr>
<tr>
<td>struct list_head</td>
<td>fl_block</td>
<td>指向锁等待列表</td>
</tr>
<tr>
<td>struct files_struct *</td>
<td>fl_owner</td>
<td>锁拥有者的 files_struct</td>
</tr>
<tr>
<td>unsigned char</td>
<td>fl_flags</td>
<td>锁标识</td>
</tr>
<tr>
<td>unsigned char</td>
<td>fl_type</td>
<td>锁类型</td>
</tr>
<tr>
<td>unsigned int</td>
<td>fl_pid</td>
<td>进程拥有者的 pid</td>
</tr>
<tr>
<td>wait_queue_head_t</td>
<td>fl_wait</td>
<td>被阻塞进程的等待队列</td>
</tr>
<tr>
<td>struct file *</td>
<td>fl_file</td>
<td>指向文件对象</td>
</tr>
<tr>
<td>loff_t</td>
<td>fl_start</td>
<td>被锁区域的开始位移</td>
</tr>
<tr>
<td>loff_t</td>
<td>fl_end</td>
<td>被锁区域的结束位移</td>
</tr>
<tr>
<td>struct fasync_struct *</td>
<td>fl_fasync</td>
<td>用于租借暂停通知</td>
</tr>
<tr>
<td>unsigned long</td>
<td>fl_break_time</td>
<td>租借的剩余时间</td>
</tr>
<tr>
<td>struct file_lock_operations *</td>
<td>fl_ops</td>
<td>指向文件锁操作</td>
</tr>
<tr>
<td>struct lock_manager_operations *</td>
<td>fl_mops</td>
<td>指向锁管理操作</td>
</tr>
<tr>
<td>union</td>
<td>fl_u</td>
<td>文件系统特定信息</td>
</tr>
</tbody>
</table>
</div>
<p>指向磁盘上同一文件的所有lock_file结构都被收集在一个单向链表中，其第一个元素由索引节点对象的i_flock字段所指向。file_lock结构的fl_next字段指向链表中的下一个元素。</p>
<p>当发出阻塞系统调用的进程请求一个独占锁而同一文件也存在共享锁时，该请求不能立即得到满足，并且进程必须被挂起。因此该进程被插入到由阻塞锁file_lock结构的fl_wait字段指向的等待队列中。</p>
<p>使用两个链表区分已满足的锁请求(活动锁)和那些不能立刻得到满足的锁请求(阻塞锁)。所有的活动锁被链接在“全局文件锁链表”中，该表的首元素被存放在file_lock_list 变量中。类似地，所有的阻塞锁被链接在“阻塞链表“中，该表的首元素被存放在blocked_list变量中。使用fl_link字段可把lock_file结构插入到上述任何一个链表中。</p>
<p>最后的一项要点是，内核必须跟踪所有与给定活动锁(“blocker”)关联的阻塞锁(“waiters”)；这就是为什么要使用链表根据给定的blocker把所有的waiter链接在一起的原因。blocker的fl_block字段是链表的伪首部，而waiter的fl_block字段存放了指向链表中相邻元素的指针。</p>
<h3 id="FL-FLOCK锁"><a href="#FL-FLOCK锁" class="headerlink" title="FL_FLOCK锁"></a>FL_FLOCK锁</h3><p>​    FL_LOCK锁总是与一个文件对象相关联，因此由一个打开该文件的进程(或共享同一打开文件的子进程)来维护。当一个锁被请求或允许时，内核就把进程保持在同一文件对象上的任何其他锁都替换掉。这只发生在进程想把一个已经拥有的读锁改变为一个写锁，或把一个写锁改变为一个读锁时。此外，当fput()函数正在释放一个文件对象时，对这个文件对象加的所有FL_LOCK锁都被撤销。不过，也有可能由其他进程对这同一文件(索引节点)设置了其他FL_LOCK读锁，它们依然是有效的。</p>
<p>flock()系统调用允许进程在打开文件上申请或删除劝告锁。它作用于两个参数：要加锁文件的文件描述符fd和指定锁操作的参数cmd。如果cmd参数为LOCK_SH，则请求一个共享的读锁；为LOCK_EX，则请求一个互斥的写锁；为LOCK_UN，则释放一个锁。</p>
<p>如果请求不能立即得到满足，系统调用通常阻塞当前进程，例如，如果进程请求一个独占锁而其他某个进程已获得了该锁。不过，如果LOCK_NB标记与LOCK_SH或LOCK_EX 操作进行“或“，则这个系统调用不阻塞；换句话说，如果不能立即获得该锁，则该系统调用就返回一个错误码。</p>
<p>当sys_flock()服务例程被调用时，则执行下列步骤：</p>
<ol>
<li>检查fd是否是一个有效的文件描述符；如果不是，就返回一个错误码。否则，获得相应文件对象filp的地址。</li>
<li>检查进程在打开文件上是否有读和/或写权限；如果没有，就返回一个错误码。</li>
<li>获得一个新的file_lock对象锁并用适当的锁操作初始化它：根据参数cmd的值设置fl_type字段，把fl_file字段设为文件对象filp的地址，fl_flags字段设为FL_FLOCK，fl_pid字段设为current-&gt;tgid，并把fl_end字段设为-1，这表示对整个文件(而不是文件的一部分)加锁的事实。</li>
<li>如果参数cmd不包含LOCK_NB位，则把FL_SLEEP标志加入fl_flags字段。</li>
<li>如果文件具有一个flock文件操作，则调用它，传递给它的参数为文件对象指针filp、一个标志(F_SETLKW或F_SETLK，取决于LOCK_NB位的值)以及新的file_lock对象锁的地址。</li>
<li>否则，如果没有定义flock文件操作(通常情况下)，则调用flock_lock_file_wait()试图执行请求的锁操作。传递给它的两个参数为：文件对象指针filp和在第3步创建的新的file_lock对象的地址lock。</li>
<li>如果上一步中还没有把file_lock描述符插入活动或阻塞链表中，则释放它。</li>
<li>返回0(成功)。</li>
</ol>
<p>flock_lock_file_wait()函数执行下列循环操作：</p>
<ol>
<li><p>调用flock_lock_file()，传递给它的参数为文件对象指针filp和新的file_lock对象锁的地址lock。 这个函数依次执行下列操作：</p>
<blockquote>
<ol>
<li>搜索filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock指向的链表。如果在同一文件对象中找到FL_FLOCK锁，则检查它的类型(LOCK_SH或LOCK_EX)：如果该锁的类型与新锁相同，则返回0(什么也没有做)。 否则，从索引节点锁链表和全局文件锁链表中删除这个file_lock元素，唤醒fl_block链表中在该锁的等待队列上睡眠的所有进程，并释放file_lock结构。</li>
<li>如果进程正在执行开锁(LOCK_UN)，则什么事情都不需要做：该锁已不存在或已被释放，因此返回0。</li>
<li>如果已经找到同一个文件对象的FL_FLOCK锁——表明进程想把一个已经拥有的读锁改变为一个写锁(反之亦然)，那么调用cond_resched()给予其他更高优先级进程(特别是先前在原文件锁上阻塞的任何进程)一个运行的机会。</li>
<li>再次搜索索引节点锁链表以验证现有的FL_FLOCK锁并不与所请求的锁冲突。<br>在索引节点链表中，肯定没有FL_FLOCK写锁，此外，如果进程正在请求一个写锁，那么根本就没有FL_FLOCK锁。</li>
<li>如果不存在冲突锁，则把新的file_lock结构插入索引节点锁链表和全局文件锁链表中，然后返回0(成功)。</li>
<li>发现一个冲突锁：如果fl_flags字段中FL_SLEEP对应的标志位置位，则把新锁(waiter锁)插入到blocker锁循环链表和全局阻塞链表中。返回一个错误码-EAGAIN。</li>
</ol>
</blockquote>
</li>
<li><p>检查flock_lock_file()的返回码：<br>a. 如果返回码为0(没有冲突迹象)，则返回0(成功)。<br>b. 不相容的情况。如果fl_flags字段中的FL_SLEEP标志被清除，就释放file_lock锁描述符，并返回一个错误码-EAGAIN。<br>c. 否则，不相容但进程能够睡眠的情况：调用wait_event_interruptible()把当前进程插入到lock-&gt;fl_wait等待队列中并挂起它。当进程被唤醒时(正好在释放blocker锁后)，跳转到第1步再次执行这个操作。</p>
</li>
</ol>
<h3 id="FL-POSIX锁"><a href="#FL-POSIX锁" class="headerlink" title="FL_POSIX锁"></a>FL_POSIX锁</h3><p>FL_POSIX锁总是与一个进程和一个索引节点相关联。当进程死亡或一个文件描述符被关闭时(即使该进程对同一文件打开了两次或复制了一个文件描述符)，这种锁会被自动地释放。此外，FL_POSIX锁绝不会被子进程通过fork()继承。</p>
<p>当使用fcntl()系统调用对文件加锁时，该系统调用作用于三个参数：要加锁文件的文件描述符fd、指向锁操作的参数cmd，以及指向存放在用户态进程地址空间中的flock 数据结构的指针f1。</p>
<p>sys_fcntl()服务例程执行的操作取决于在cmd参数中所设置的标志值：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">F_GETLK
	确定由flock结构描述的锁是否与另一个进程已获得的某个FL_POSIX锁互相冲突。在冲突的情况下，用现有锁的有关信息重写flock结构。
F_SETLK
	设置由flock结构描述的锁。如果不能获得该锁，则这个系统调用返回一个错误码。
F_SETLKW
	设置由flock结构描述的锁。如果不能获得该锁，则这个系统调用阻塞，也就是说，调用进程进入睡眠状态直到该锁可用时为止。
F_GETLK64，F_SETLK64，F_SETLKW64
	与前面描述的几个标志相同，但是使用的是flock64结构而不是flock结构。
<span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>sys_fcntl()服务例程首先获取与参数fd对应的文件对象，然后调用fcntl_getlk()或fcntl_setlk()函数(这取决于传递的参数：F_GETLK表示前一个函数，F_SETLK 或F_SETLKW表示后一个函数)。我们仅仅考虑第二种情况。fcntl_setlk()函数作用于三个参数：指向文件对象的指针filp、cmd命令(F_SETLK 或F_SETLKW)，以及指向flock数据结构的指针。该函数执行下列操作：</p>
<ol>
<li><p>读取局部变量中的参数f1所指向的flock结构。</p>
</li>
<li><p>检查这个锁是否应该是一个强制锁，且文件是否有一个共享内存映射。在肯定的情况下，该函数拒绝创建锁并返回-EAGAIN出错码，说明文件正在被另一个进程访问。</p>
</li>
<li><p>根据用户flock结构的内容和存放在文件索引节点中的文件大小，初始化一个新的file_lock结构。</p>
</li>
<li><p>如果命令cmd为F_SETLKW，则该函数把file_lock结构的fl_flags字段设为FL_SLEEP标志对应的位置位。</p>
</li>
<li><p>如果flock结构中的l_type字段为F_RDLCK，则检查是否允许进程从文件读取；类似地，如果l_type为F_WRLCK，则检查是否允许进程写入文件。如果都不是，则返回一个出错码。</p>
</li>
<li><p>调用文件操作的lock方法(如果已定义)。对于磁盘文件系统，通常不定义该方法。</p>
</li>
<li><p>调用__posix_lock_file()函数，传递给它的参数为文件的索引节点对象地址以及file_lock对象地址。该函数依次执行下列操作：</p>
<blockquote>
<ol>
<li>对于索引节点的锁链表中的每个FL_POSIX锁，调用posix_locks_conflict()。<br>该函数检查这个锁是否与所请求的锁互相冲突。从本质上说，在索引节点的链表中，必定没有用于同一区的FL_POSIX写锁，并且，如果进程正在请求一个写锁，那么同一个区字段也可能根本没有FL_POSIX锁。但是，同一个进程所拥有的锁从不会冲突；这就允许进程改变它已经拥有的锁的特性。</li>
<li>如果找到一个冲突锁，则检查是否以F_SETLKW标志调用fcntl()。如果是，当前进程应当被挂起：这种情况下，调用posix_locks_deadlock()来检查在等待FL_POSIX锁的进程之间没有产生死锁条件，然后把新锁(waiter锁)插入到冲突锁(blocker锁)blocker链表和阻塞链表中，最后返回一个出错码。否则，如果以F_SETLK标志调用fcntl()，则返回一个出错码。</li>
<li>只要索引节点的锁链表中不包含冲突的锁，就检查把文件区重叠起来的当前进程的所有FL_POSIX锁，当前进程想按需要对文件区中相邻的区字段进行锁定、组合及拆分。例如，如果进程为某个文件区请求一个写锁，而这个文件区落在一个较宽的读锁区字段内，那么，以前的读锁就会被拆分为两部分，这两部分覆盖非重叠区域，而中间区域由新的写锁进行保护。在重叠的情况下，新锁总是代替旧锁。</li>
<li>把新的file_lock结构插入到全局锁链表和索引节点链表中。</li>
<li>返回值0(成功)。</li>
</ol>
</blockquote>
</li>
<li><p>检查__posix_lock_file()的返回码</p>
<blockquote>
<ol>
<li>如果返回码为0(没有冲突迹象)，则返回0(成功)。</li>
<li>不相容的情况。如果fl_flags字段的FL_SLEEP标志被清除，就释放新的file_lock描述符，并返回一个错误码-EAGAIN。</li>
<li>否则，如果不相容但进程能够睡眠时，调用wait_event_interruptible()把当前进程插入到lock-&gt;fl_wait等待队列中并挂起它。当进程被唤醒时(正好在释放blocker锁后)，跳转到第7步再次执行这个操作。</li>
</ol>
</blockquote>
</li>
</ol>
<h1 id="Reference-6"><a href="#Reference-6" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39278265/article/details/88839027">[高级操作系统] VFS详解（虚拟文件系统）_操作系统vfs层-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jimbo17/p/10107318.html">Linux VFS机制简析（一） - 舰队 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.hongxiaolong.com/posts/flock-and-lockf.html">狼烟 / Linux内核源码分析：文件锁 (hongxiaolong.com)</a></p>
</blockquote>
<h1 id="一般的文件系统样板"><a href="#一般的文件系统样板" class="headerlink" title="一般的文件系统样板"></a>一般的文件系统样板</h1><h2 id="Ext2"><a href="#Ext2" class="headerlink" title="Ext2"></a>Ext2</h2><h3 id="Ext2的一般特征"><a href="#Ext2的一般特征" class="headerlink" title="Ext2的一般特征"></a>Ext2的一般特征</h3><p>​    类Unix操作系统使用多种文件系统。尽管所有这些文件系统都有少数POSIX API(如state())所需的共同的属性子集，但每种文件系统的实现方式是不同的。Linux的第一个版本是基于MINIX文件系统的。</p>
<p>​    当Linux成熟时，引入了扩展文件系统(Extended Filesystem，Ext FS)。它包含了几个重要的扩展但提供的性能不令人满意。在1994年引入了第二扩展文件系统(Ext2)；它除了包含几个新的特点外，还相当高效和稳定，Ext2及它的下代文件系统Ext3已成为广泛使用的Linux文件系统。</p>
<p>下列特点有助于Ext2的效率：</p>
<ol>
<li>当创建Ext2文件系统时，系统管理员可以根据预期的文件平均长度来选择最佳块大小(从1024B～4096B)。例如，当文件的平均长度小于几千字节时，块的大小为1024B是最佳的，因为这会产生较少的内部碎片——也就是文件长度与存放它的磁盘分区有较少的不匹配。另一方面，大的块对于大于几千字节的文件通常比较合适，因为这样的磁盘传送较少，因而减轻了系统的开销。</li>
<li>当创建Ext2文件系统时，系统管理员可以根据在给定大小的分区上预计存放的文件数来选择给该分区分配多少个索引节点。这可以有效地利用磁盘的空间。文件系统把磁盘块分为组。每组包含存放在相邻磁道上的数据块和索引节点。正是这种结构，使得可以用较少的磁盘平均寻道时间对存放在一个单独块组中的文件进行访问。在磁盘数据块被实际使用之前，文件系统就把这些块预分配给普通文件。因此，当文件的大小增加时，因为物理上相邻的几个块已被保留，这就减少了文件的碎片。</li>
<li>支持快速符号链接。如果符号链接表示一个短路径名(小于或等于60个字符)，就把它存放在索引节点中而不用通过读一个数据块进行转换。</li>
</ol>
<p>此外，Ext2还包含了一些使它既健壮又灵活的特点：</p>
<ol>
<li><strong>文件更新策略的谨慎实现将系统崩溃的影响减到最少。</strong></li>
<li>在启动时支持对文件系统的状态进行自动的一致性检查。这种检查是由外部程序e2fsck完成的，这个外部程序不仅可以在系统崩溃之后被激活，也可以在一个预定义的文件系统安装数(每次安装操作之后对计数器加1)之后被激活，或者在自从最近检查以来所花的预定义时间之后被激活。</li>
<li>支持不可变(immutable)的文件(不能修改、删除和更名)和仅追加(append-only)的文件(只能把数据追加在文件尾)。</li>
<li>既与Unix System VRelease4(SVR4)相兼容，也与新文件的用户组ID的BSD 语义相兼容。在SVR4中，新文件采用创建它的进程的用户组ID；而在BSD中，新文件继承包含它的目录的用户组ID。Ext2包含一个安装选项，由你指定采用哪种语义。</li>
</ol>
<p>​    即使Ext2文件系统是如此成熟、稳定的程序，也还要考虑引入另外几个特性。一些特性已被实现并以外部补丁的形式来使用。另外一些还仅仅处于计划阶段，但在一些情况下，已经在Ext2的索引节点中为这些特性引入新的字段。最重要的一些特点如下：</p>
<ul>
<li>块片(block fragmentation)：系统管理员对磁盘的访问通常选择较大的块，因为计算机应用程序常常处理大文件。因此，在大块上存放小文件就会浪费很多磁盘空间。这个问题可以通过把几个文件存放在同一块的不同片上来解决。</li>
<li>透明地处理压缩和加密文件：这些新的选项(创建一个文件时必须指定)将允许用户透明地在磁盘上存放压缩和(或)加密的文件版本。</li>
<li>逻辑删除：一个undelete选项将允许用户在必要时很容易恢复以前已删除的文件内容。</li>
<li>日志：日志避免文件系统在被突然卸载(例如，作为系统崩溃的后果)时对其自动进行的耗时检查。</li>
</ul>
<p>​    Ext2中缺少的最突出的功能就是日志，日志是高可用服务器必需的功能。为了平顺过渡，日志没有引入到Ext2文件系统；但是，我们在后面“Ext3文件系统”一节会讨论，完全与Ext2兼容的一种新文件系统已经创建，这种文件系统提供了日志。不真正需要日志的用户可以继续使用良好而老式的Ext2文件系统，而其他用户可能采用这种新的文件系统。现在发行的大部分系统采用Ext3作为标准的文件系统。</p>
<h3 id="Ext2磁盘数据结构"><a href="#Ext2磁盘数据结构" class="headerlink" title="Ext2磁盘数据结构"></a>Ext2磁盘数据结构</h3><p>​    任何Ext2分区中的第一个块从不受Ext2文件系统的管理，因为这一块是为分区的引导扇区所保留的。Ext2分区的其余部分分成块组(block group)，每个块组的分布图如图18-1所示。正如你从图中所看到的，一些数据结构正好可以放在一块中，而另一些可能需要更多的块。在Ext2文件系统中的所有块组大小相同并被顺序存放，因此，内核可以从块组的整数索引很容易地得到磁盘中一个块组的位置。</p>
<p><img src=".\image-20240503135519537.png" alt="在这里插入图片描述"><br>纠正：<br>上图中，组描述符占据的块数n，索引节点表占据的块数n，数据块占据的块数n，块数数n之间没有关联。</p>
<ul>
<li>组描述符占据块数=(文件系统快组数<em>组描述符尺寸) / 块尺寸+(文件系统快组数</em>组描述符尺寸) % 块尺寸 ? 1 : 0;</li>
<li>索引节点位置占据块数=(每个快组索引节点数<em>索引节点尺寸) / 块尺寸+(每个快组索引节点数</em>索引节点尺寸) % 块尺寸 ? 1 : 0;</li>
<li>数据块数= 快组占据块数-1-组描述符占据块数-1-1-索引节点占据块数</li>
<li>文件系统快组数，每个快组索引节点数，快组占据块数在磁盘格式化为文件系统时确定</li>
</ul>
<p>由于内核尽可能地把属于一个文件的数据块存放在同一块组中，所以块组减少了文件的碎片。块组中的每个块包含下列信息之一：</p>
<ol>
<li>文件系统的超级块的一个拷贝</li>
<li>一组块组描述符的拷贝</li>
<li>一个数据块位图</li>
<li>一个索引节点位图</li>
<li>一个索引节点表</li>
<li>属于文件的一大块数据，即数据块。如果一个块中不包含任何有意义的信息，就说这个块是空闲的。<br>只有块组0中所包含的超级块和组描述符才由内核使用，而其余的超级块和组描述符保持不变；事实上，内核甚至不考虑它们。<br>当e2fsck程序对Ext2文件系统的状态执行一致性检查时，就引用存放在块组0中的超级块和组描述符，然后把它们拷贝到其他所有的块组中。如果出现数据损坏，并且块组0中的主超级块和主描述符变为无效，那么，系统管理员就可以命令e2fsck 引用存放在某个块组(除了第一个块组)中的超级块和组描述符的旧拷贝。</li>
</ol>
<p>通常情况下，这些多余的拷贝所存放的信息足以让e2fsck把Ext2分区带回到一个一致的状态。有多少块组呢？<strong>这取决于分区的大小和块的大小。</strong>其主要限制在于块位图，因为块位图必须存放在一个单独的块中。块位图用来标识一个组中块的占用和空闲状况。所以，每组中至多可以有8×b个块，b是以字节为单位的块大小。因此，块组的总数大约是s/(8×b)，这里s是分区所包含的总块数。</p>
<p>举例说明，让我们考虑一下32GB的Ext2分区，块的大小为4KB。在这种情况下，每个4KB的块位图描述32K个数据块，即128MB。因此，最多需要256个块组。显然，块的大小越小，块组数越大。</p>
<h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>Ext2在磁盘上的超级块存放在一个ext2_super_block结构中，它的字段在表18-1中列出。<strong>u8、</strong>u16及<strong>u32数据类型分别表示长度为8、16及32位的无符号数，而</strong>s8、<strong>s16及</strong>s32数据类型表示长度为8、16及32位的有符号数。</p>
<p>为清晰地表示磁盘上字或双字中字节的存放顺序，内核又使用了<strong>le16、</strong>le32、<strong>be16和</strong>be32数据类型，前两种类型分别表示字或双字的“小尾(little-endian)”排序方式(低阶字节在高位地址)，而后两种类型分别表示字或双字的“大尾(big-endian)”排序方式(高阶字节在高位地址)。每个块组都有自己的组描述符</p>
<p>当分配新索引节点和数据块时，会用到bg_free_blocks_count、bg_free_inodes_count 和bg_used_dirs_count字段。这些字段确定在最合适的块中给每个数据结构进行分配。位图是位的序列，其中值0表示对应的索引节点块或数据块是空闲的，1表示占用。因为每个位图必须存放在一个单独的块中，又因为块的大小可以是1024、2048或4096字节，因此，一个单独的位图描述8192、16384或32768个块的状态。</p>
<h3 id="索引节点表"><a href="#索引节点表" class="headerlink" title="索引节点表"></a>索引节点表</h3><p>​    索引节点表由一连串连续的块组成，其中每一块包含索引节点的一个预定义号。索引节点表第一个块的块号存放在组描述符的bg_inode_table字段中。所有索引节点的大小相同，即128字节。一个1024字节的块可以包含8个索引节点，一个4096字节的块可以包含32个索引节点。为了计算出索引节点表占用了多少块，用一个组中的索引节点总数(存放在超级块的s_inodes_per_group字段中)除以每块中的索引节点数。<br>​    与<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=POSIX&amp;spm=1001.2101.3001.7020">POSIX</a>规范相关的很多字段类似于VFS索引节点对象的相应字段。其余的字段与Ext2的特殊实现相关，主要处理块的分配。特别地，i_size字段存放以字节为单位的文件的有效长度，而i_blocks字段存放已分配给文件的数据块数(以512字节为单位)。i_size和i_blocks的值没有必然的联系。因为一个文件总是存放在整数块中，一个非空文件至少接受一个数据块(因为还没实现片)且i_size可能小于512× i_blocks。</p>
<p>​    一个文件可能包含有洞。在那种情况下，i_size可能大于512×i_blocks。i_block字段是具有EXT2_N_BLOCKS(通常是15)个指针元素的一个数组，每个元素指向分配给文件的数据块。</p>
<p>留给i_size字段的32位把文件的大小限制到4GB。事实上，i_size字段的最高位没有使用，因此，文件的最大长度限制为2GB。然而，Ext2文件系统包含一种“脏技巧”，允许像AMD的Opteron和IBM的PowerPC G5这样的64位体系结构使用大型文件。从本质上说，索引节点的i_dir_acl字段(普通文件没有使用)表示i_size字段的32位扩展。因此，文件的大小作为64位整数存放在索引节点中。</p>
<p>Ext2文件系统的64位版本与32位版本在某种程度上兼容，因为在64位体系结构上创建的Ext2文件系统可以安装在32位体系结构上，反之亦然。但是，在32位体系结构上不能访问大型文件，除非以O_LARGEFILE标志打开文件。回忆一下，VFS模型要求每个文件有不同的索引节点号。在Ext2中，没有必要在磁盘上存放文件的索引节点号与相应块号之间的转换，因为后者的值可以从块组号和它在索引节点表中的相对位置而得出。</p>
<p>例如，假设每个块组包含4096个索引节点，我们想知道索引节点13021在磁盘上的地址。在这种情况下，这个索引节点属于第三个块组，它的磁盘地址存放在相应索引节点表的第733个表项中。正如你看到的，索引节点号是Ext2例程用来快速搜索磁盘上合适的索引节点描述符的一个关键字。</p>
<h3 id="索引节点的增强属性"><a href="#索引节点的增强属性" class="headerlink" title="索引节点的增强属性"></a>索引节点的增强属性</h3><p>Ext2索引节点的格式对于文件系统设计者就好像一件紧身衣，索引节点的长度必须是2 的幂，以免造成存放索引节点表的块内碎片。实际上，一个Ext2索引节点的128个字符空间中充满了信息，只有少许空间可以增加新的字段。另一方面，将索引节点的长度增加至256不仅相当浪费，而且使用不同索引节点长度的Ext2文件系统之间还会造成兼容问题。</p>
<p>引入增强属性(extended attribute)就是要克服上面的问题。这些属性存放在索引节点之外的磁盘块中。索引节点的i_file_acl字段指向一个存放增强属性的块。具用同样增强属性的不同索引节点可以共享同一个块。每个增强属性有一个名称和值。两者都编码为变长字符数组，并由ext2_xattr_entry 描述符来确定。</p>
<p>图18-2表示Ext2中增强属性块的结构。每个属性分成两部分：在块首部的是ext2_xattr_entry描述符与属性名，而属性值则在块尾部。块前面的表项按照属性名称排序，而值的位置是固定的，因为它们是由属性的分配次序决定的。</p>
<p><img src=".\image-20240503135529427.png" alt="在这里插入图片描述"><br>有很多系统调用用来设置、取得、列表和删除一个文件的增强属性。系统调用setxattr()、lsetxattr()和fsetxattr()设置文件的增强属性，它们在符号链接的处理与文件限定的方式(或者传递路径名或者是文件描述符)上根本不同。类似地，系统调用getxattr()、lgetxattr()和fgetxattr()返回增强属性的值。系统调用listxattr()、llistxattr()和flistxattr()则列出一个文件的所有增强属性。最后，系统调用removexattr()、lremovexattr()和fremovexattr()从文件删除一个增强属性。</p>
<h3 id="访问控制列表"><a href="#访问控制列表" class="headerlink" title="访问控制列表"></a>访问控制列表</h3><p>很早以前访问控制列表就被建议用来改善Unix文件系统的保护机制。不是将文件的用户分成三类：拥有者、组和其他，访问控制列表(access controllist，ACL)可以与每个文件关联。有了这种列表，用户可以为他的文件限定可以访问的用户(或用户组)名称以及相应的权限。Linux 2.6通过索引节点的增强属性完整实现ACL。实际上，增强属性主要就是为了支持ACL才引入的。因此，能让你处理文件ACL的库函数chacl()、setfacl()和getfacl()就是通过上一节中介绍的setxattr()和getxattr()系统调用实现的。</p>
<p>不幸的是，在POSIX 1003.1系列标准内，定义安全增强属性的工作组所完成的成果从没有正式成为新的POSIX标准。因此现在，不同的类Unix文件系统都支持ACL，但不同的实现之间有一些微小的差别。</p>
<h3 id="各种文件类型如何使用磁盘块"><a href="#各种文件类型如何使用磁盘块" class="headerlink" title="各种文件类型如何使用磁盘块"></a>各种文件类型如何使用磁盘块</h3><p>Ext2所认可的文件类型(普通文件、管道文件等)以不同的方式使用数据块。有些文件不存放数据，因此根本就不需要数据块。本节讨论每种文件类型的存储要求，如表18-4所示。</p>
<ul>
<li>未知 0</li>
<li>普通文件 1</li>
<li>目录 2</li>
<li>字符设备 3</li>
<li>块设备 4</li>
<li>命名管道 5</li>
<li>套接字 6</li>
<li>符号链接 7 </li>
</ul>
<h3 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h3><p>普通文件是最常见的情况，本章主要关注它。但普通文件只有在开始有数据时才需要数据块。普通文件在刚创建时是空的，并不需要数据块；也可以用truncate()或open()系统调用清空它。这两种情况是相同的，例如，当你发出一个包含字符串&gt;filename的shell命令时，shell创建一个空文件或截断一个现有文件。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>Ext2以一种特殊的文件实现了目录，这种文件的数据块把文件名和相应的索引节点号存放在一起。特别说明的是，这样的数据块包含了类型为ext2_dir_entry_2的结构。表18-5列出了这个结构的字段。因为该结构最后一个name字段是最大为EXT2_NAME_LEN (通常是255)个字符的变长数组，因此这个结构的长度是可变的。此外，因为效率的原因，目录项的长度总是4的倍数，并在必要时用null字符(\0)填充文件名的末尾。name_len字段存放实际的文件名长度(参见图18-3)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>inode</td>
<td>inode节点号</td>
</tr>
<tr>
<td>rec_len</td>
<td>目录项长度</td>
</tr>
<tr>
<td>name_len</td>
<td>文件名长度</td>
</tr>
<tr>
<td>file_type</td>
<td>文件类型</td>
</tr>
<tr>
<td>name</td>
<td>文件名</td>
</tr>
</tbody>
</table>
</div>
<p>file_type字段存放指定文件类型的值(见表18-4)。rec_len字段可以被解释为指向下一个有效目录项的指针：它是偏移量，与目录项的起始地址相加就得到下一个有效目录项的起始地址。为了删除一个目录项，把它的inode字段置为0并适当地增加前一个有效目录项rec_len字段的值就足够了。仔细看一下图18-3的rec_len字段，你会发现oldfile 项已被删除，因为usr的rec_len字段被置为12+16(usr和oldfile目录项的长度)。</p>
<p><img src=".\image-20240503135536840.png" alt="在这里插入图片描述"></p>
<h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>如前所述，如果符号链接的路径名小于等于60个字符，就把它存放在索引节点的i_blocks字段，该字段是由15个4字节整数组成的数组，因此无需数据块。但是，如果路径名大于60个字符，就需要一个单独的数据块。</p>
<h3 id="设备文件、管道和套接字"><a href="#设备文件、管道和套接字" class="headerlink" title="设备文件、管道和套接字"></a>设备文件、管道和套接字</h3><p>这些类型的文件不需要数据块。所有必要的信息都存放在索引节点中。</p>
<h3 id="Ext2的内存数据结构"><a href="#Ext2的内存数据结构" class="headerlink" title="Ext2的内存数据结构"></a>Ext2的内存数据结构</h3><p>为了提高效率，当安装Ext2文件系统时，存放在Ext2分区的磁盘数据结构中的大部分信息被拷贝到RAM中，从而使内核避免了后来的很多读操作。那么一些数据结构如何经常更新呢？让我们考虑一些基本的操作：</p>
<ol>
<li>当一个新文件被创建时，必须减少Ext2超级块中s_free_inodes_count字段的值和相应的组描述符中bg_free_inodes_count字段的值。</li>
<li>如果内核给一个现有的文件追加一些数据，以使分配给它的数据块数因此也增加，那么就必须修改Ext2超级块中s_free_blocks_count字段的值和组描述符中bg_free_blocks_count字段的值。</li>
<li>即使仅仅重写一个现有文件的部分内容，也要对Ext2超级块的s_wtime字段进行更新。因为所有的Ext2磁盘数据结构都存放在Ext2分区的块中，因此，内核利用页高速缓存来保持它们最新。</li>
</ol>
<p>​    对于与Ext2文件系统以及文件相关的每种数据类型，表18-6详细说明了在磁盘上用来表示数据的数据结构、在内存中内核所使用的数据结构以及决定使用多大容量高速缓存的经验方法。频繁更新的数据总是存放在高速缓存，也就是说，这些数据一直存放在内存并包含在页高速缓存中，直到相应的Ext2分区被卸载。内核通过让缓冲区的引用计数器一直大于0来达到此目的。<br>​    在任何高速缓存中不保存“从不缓存”的数据，因为这种数据表示无意义的信息。相反，“总是缓存”的数据也总在RAM中，这样就不必从磁盘读数据了(但是，数据必须周期性地写回磁盘)。除了这两种极端模式外，还有一种动态模式。在动态模式下，只要相应的对象(索引节点、数据块或位图)还在使用，它就保存在高速缓存中；而当文件关闭或数据块被删除后，页框回收算法会从高速缓存中删除有关数据。有意思的是，索引节点与块位图并不永久保存在内存里，而是需要时从磁盘读。有了页高速缓存，最近使用的磁盘块保存在内存里，这样可以避免很多磁盘读。</p>
<h3 id="Ext2的超级块对象"><a href="#Ext2的超级块对象" class="headerlink" title="Ext2的超级块对象"></a>Ext2的超级块对象</h3><p>VFS超级块的s_fs_info字段指向一个包含文件系统信息的数据结构。对于Ext2，该字段指向ext2_sb_info类型的结构，它包含如下信息：</p>
<ol>
<li>磁盘超级块中的大部分字段</li>
<li>s_sbh指针，指向包含磁盘超级块的缓冲区的缓冲区首部</li>
<li>s_es指针，指向磁盘超级块所在的缓冲区</li>
<li>s_desc_per_block，可以放在一个块中的组描述符的个数</li>
<li>s_group_desc指针，指向一个缓冲区(包含组描述符的缓冲区)首部数组(通常一项就够)</li>
<li>其他与安装状态、安装选项等有关的数据<br>图18-4表示的是与Ext2超级块和组描述符有关的缓冲区与缓冲区首部和ext2_sb_info 数据结构之间的关系。<br><img src=".\image-20240503135543423.png" alt=""><br>当内核安装Ext2文件系统时，它调用ext2_fill_super()函数来为数据结构分配空间，并写入从磁盘读取的数据。这里是对该函数的一个简要说明，只强调缓冲区与描述符的内存分配。<br>ext2_fill_super：</li>
<li>分配一个ext2_sb_info描述符，将其地址当作参数传递并存放在超级块的s_fs_info字段。</li>
<li>调用__bread()在缓冲区页中分配一个缓冲区和缓冲区首部。然后从磁盘读入超级块存放在缓冲区中。如果一个块已在页高速缓存的缓冲区页而且是最新的，那么无需再分配。将缓冲区首部地址存放在Ext2超级块对象的s_sbh字段。</li>
<li>分配一个字节数组，每组一个字节，把它的地址存放在ext2_sb_info描述符的s_debts字段。</li>
<li>分配一个数组用于存放缓冲区首部指针，每个组描述符一个，把该数组地址存放在ext2_sb_info的s_group_desc字段。</li>
<li>重复调用__bread()分配缓冲区，从磁盘读入包含Ext2组描述符的块。把缓冲区首部地址存放在上一步得到的s_group_desc数组中。</li>
<li>为根目录分配一个索引节点和目录项对象，为超级块建立相应的字段，从而能够从磁盘读入根索引节点对象（超级块包含根目录文件索引节点的编号）。</li>
</ol>
<p>很显然，ext2_fill_super()函数返回后，分配的所有数据结构都保存在内存里，只有当Ext2文件系统卸载时才会被释放。当内核必须修改Ext2超级块的字段时，它只要把新值写入相应缓冲区内的相应位置然后将该缓冲区标记为脏即可。</p>
<h3 id="Ext2的索引节点对象"><a href="#Ext2的索引节点对象" class="headerlink" title="Ext2的索引节点对象"></a>Ext2的索引节点对象</h3><p>在打开文件时，要执行路径名查找。对于不在目录项高速缓存内的路径名元素，会创建一个新的目录项对象和索引节点对象。当VFS 访问一个Ext2磁盘索引节点时，它会创建一个ext2_inode_info类型的索引节点描述符。该描述符包含下列信息：</p>
<ol>
<li>存放在vfs_inode字段的整个VFS索引节点对象</li>
<li>磁盘索引节点对象结构中的大部分字段(不保存在VFS索引节点中)</li>
<li>索引节点对应的i_block_group块组索引</li>
<li>i_next_alloc_block和i_next_alloc_goal字段，分别存放着最近为文件分配的磁盘块的逻辑块号与物理块号</li>
<li>i_prealloc_block和i_prealloc_count字段，用于数据块预分配</li>
<li>xattr_sem字段，一个读写信号量，允许增强属性与文件数据同时读入</li>
<li>i_acl和i_default_acl字段，指向文件的ACL。</li>
</ol>
<p>当处理Ext2文件时，alloc_inode超级块方法是由ext2_alloc_inode()函数实现的。它首先从ext2_inode_cachep slab分配器高速缓存得到一个ext2_inode_info描述符，然后返回在这个ext2_inode_info描述符中的索引节点对象的地址。</p>
<h3 id="创建Ext2文件系统"><a href="#创建Ext2文件系统" class="headerlink" title="创建Ext2文件系统"></a>创建Ext2文件系统</h3><p>在磁盘上创建一个文件系统通常有两个阶段。第一步格式化磁盘，以使磁盘驱动程序可以读和写磁盘上的块。现在的硬磁盘已经由厂家预先格式化，因此不需要重新格式化；在Linux上可以使用superformat或fdformat等实用程序对软盘进行格式化。第二步才涉及创建文件系统，这意味着建立本章前面详细描述的结构。</p>
<p>Ext2文件系统是由实用程序mke2fs创建的。mke2fs采用下列缺省选项，用户可以用命令行的标志修改这些选项：</p>
<ol>
<li>块大小：1024字节(小文件系统的缺省值)</li>
<li>片大小：块的大小(块的分片还没有实现)</li>
<li>所分配的索引节点个数：每8192字节的组分配一个索引节点·</li>
<li>保留块的百分比：5%</li>
</ol>
<p>mke2fs程序执行下列操作：</p>
<ol>
<li>初始化超级块和组描述符。</li>
<li>作为选择，检查分区是否包含有缺陷的块；如果有，就创建一个有缺陷块的链表。</li>
<li>对于每个块组，保留存放超级块、组描述符、索引节点表及两个位图所需要的所有磁盘块。</li>
<li>把索引节点位图和每个块组的数据映射位图都初始化为0。</li>
<li>初始化每个块组的索引节点表。</li>
<li>创建/root目录。</li>
<li>创建lost+found目录，由e2fsck使用这个目录把丢失和找到的缺陷块连接起来。</li>
<li>在前两个已经创建的目录所在的块组中，更新块组中的索引节点位图和数据块位图。</li>
<li>把有缺陷的块(如果存在)组织起来放在lost+found目录中。</li>
</ol>
<p>让我们看一下mke2fs是如何以缺省选项初始化Ext2的1.44 MB软盘的。软盘一旦被安装，VFS就把它看作由1412个块组成的一个卷，每块大小为1024字节。为了查看磁盘的内容，我们可以执行如下Unix命令：<br>dd if=/dev/fd0 bs=1k count=1440 l od -tx1 -Ax &gt; /tmp/dump_hex<br>从而获得了/tmp目录下的一个文件，这个文件包含十六进制的软盘内容的转储。</p>
<p>通过查看dump_hex文件我们可以看到，由于软盘有限的容量，一个单独的块组描述符就足够了。我们还注意到保留的块数为72(1440块的5%)，并且根据缺省选项，索引节点表必须为每8192个字节设置一个索引节点，也就是有184个索引节点存放在23个块中。表18-7总结了按缺省选项如何在软盘上建立Ext2文件系统。</p>
<p><img src=".\image-20240503135554624.png" alt="在这里插入图片描述"></p>
<h3 id="Ext2的方法"><a href="#Ext2的方法" class="headerlink" title="Ext2的方法"></a>Ext2的方法</h3><p>在第十二章所描述的关于VFS的很多方法在Ext2都有相应的实现。因为对所有的方法都进行描述将需要整整一本书，因此我们仅仅简单地回顾一下在Ext2中所实现的方法。一旦你真正搞明白了磁盘和内存数据结构，你就应当能理解实现这些方法的Ext2函数的代码。</p>
<h3 id="Ext2超级块的操作"><a href="#Ext2超级块的操作" class="headerlink" title="Ext2超级块的操作"></a>Ext2超级块的操作</h3><p>很多VFS超级块操作在Ext2中都有具体的实现，这些方法为alloc_inode、destroy_inode、readinode、write_inode、delete_inode、put_super、write_super、statfs、remount_fs和clear_inode。超级块方法的地址存放在ext2_sops指针数组中。</p>
<h3 id="Ext2索引节点的操作"><a href="#Ext2索引节点的操作" class="headerlink" title="Ext2索引节点的操作"></a>Ext2索引节点的操作</h3><p>一些VFS索引节点的操作在Ext2中都有具体的实现，这取决于索引节点所指的文件类型。Ext2的普通文件和目录文件的索引节点操作见表18-8。每个方法的目的在第十二章的“索引节点对象”一节有介绍。表中没有列出普通文件和目录中未定义的方法(NULL指针)。回忆一下，如果方法未定义，VFS要么调用通用函数，要么什么也不做。普通文件与目录的Ext2方法地址分别存放在ext2_file_inode_operations和ext2_dir_inode_operations 表中。<br><img src=".\image-20240503135605239.png" alt="image-20240503135605239"><br>Ext2的符号链接的索引节点操作见表18-9(省略未定义的方法)。实际上有两种符号链接：快速符号链接(路径名全部存放在索引节点内)与普通符号链接(较长的路径名)。因此，有两套索引节点操作，分别存放在ext2_fast_symlink_inode_operations和ext2_symlink_inode_operations表中</p>
<p><img src=".\image-20240503135615110.png" alt="在这里插入图片描述"><br><img src=".\image-20240503135619075.png" alt=""><br>如果索引节点指的是一个字符设备文件、块设备文件或命名管道，那么这种索引节点的操作不依赖于文件系统，其操作分别位于chrdev_inode_operations、blkdev_inode_operations和fifo_inode_operations 表中。</p>
<h3 id="Ext2的文件操作"><a href="#Ext2的文件操作" class="headerlink" title="Ext2的文件操作"></a>Ext2的文件操作</h3><p>表18-10列出了Ext2文件系统特定的文件操作。正如你看到的，一些VFS方法是由很多文件系统共用的通用函数实现的。这些方法的地址存放在ext2_file_operations表中。<br><img src=".\image-20240503135623475.png" alt=""><br>注意，Ext2的read和write方法是分别通过generic_file_read()和generic_file_write()函数实现的。</p>
<h3 id="管理Ext2磁盘空间"><a href="#管理Ext2磁盘空间" class="headerlink" title="管理Ext2磁盘空间"></a>管理Ext2磁盘空间</h3><p>文件在磁盘的存储不同于程序员所看到的文件，这表现在两个方面：块可以分散在磁盘上(尽管文件系统尽力保持块连续存放以提高访问速度)，以及程序员看到的文件似乎比实际的文件大，这是因为程序可以把洞引入文件(通过lseek()系统调用)。</p>
<p>在本节，我们将介绍Ext2文件系统如何管理磁盘空间，也就是说，如何分配和释放索引节点和数据块。有两个主要的问题必须考虑：</p>
<ol>
<li>空间管理必须尽力避免文件碎片，也就是说，避免文件在物理上存放于几个小的、不相邻的盘块上。</li>
<li>文件碎片增加了对文件的连续读操作的平均时间，因为在读操作期间，磁头必须频繁地重新定位。</li>
<li>空间管理必须考虑效率，也就是说，内核应该能从文件的偏移量快速地导出Ext2 分区上相应的逻辑块号。为了达到此目的，内核应该尽可能地限制对磁盘上寻址表的访问次数，因为对该表的访问会极大地增加文件的平均访问时间。</li>
</ol>
<h3 id="创建索引节点"><a href="#创建索引节点" class="headerlink" title="创建索引节点"></a>创建索引节点</h3><p>ext2_new_inode()函数创建Ext2磁盘的索引节点，返回相应的索引节点对象的地址(或失败时为NULL)。该函数谨慎地选择存放该新索引节点的块组；它将无联系的目录散放在不同的组，而且同时把文件存放在父目录的同一组。为了平衡普通文件数与块组中的目录数，Ext2为每一个块组引入“债(debt)”参数。</p>
<p>ext2_new_inode作用于两个参数：</p>
<ol>
<li><p>dir，一个目录对应的索引节点对象的地址，新创建的索引节点必须插入到这个目录中；</p>
</li>
<li><p>mode，要创建的索引节点的类型。mode还包含一个MS_SYNCHRONOUS标志，该标志请求当前进程一直挂起，直到索引节点被分配。<br>该函数执行如下操作：</p>
</li>
<li><p>调用new_inode()分配一个新的VFS索引节点对象，并把它的i_sb字段初始化为存放在dir-&gt;i_sb中的超级块地址。然后把它追加到正在用的索引节点链表与超级块链表中。</p>
</li>
<li><p>如果新的索引节点是一个目录，函数就调用find_group_orlov()为目录找到一个合适的块组。该函数执行如下试探法：</p>
<blockquote>
<ol>
<li><p>以文件系统根root为父目录的目录应该分散在各个组。这样，函数在这些块组去查找一个组，它的空闲索引节点数和空闲块数比平均值高。如果没有这样的组则跳到第2c步。</p>
</li>
<li><p>如果满足下列条件，嵌套目录(父目录不是文件系统根root)就应被存放到父目录组：</p>
</li>
</ol>
<blockquote>
<ol>
<li>该组没有包含太多的目录</li>
<li>该组有足够多的空闲索引节点</li>
<li>该组有一点小“债”。(块组的债存放在一个ext2_sb_info描述符的s_debts字段所指向的计数器数组中。每当一个新目录加入，债加一；每当其他类型的文件加入，债减一)；如果父目录组不满足这些条件，那么选择第一个满足条件的组。如果没有满足条件的组，则跳到第2c步。</li>
</ol>
</blockquote>
<ol>
<li>这是一个“退一步”原则，当找不到合适的组时使用。函数从包含父目录的块组开始选择第一个满足条件的块组，这个条件是：它的空闲索引节点数比每块组空闲索引节点数的平均值大。</li>
</ol>
</blockquote>
</li>
<li><p>如果新索引节点不是个目录，则调用find_group_other()，在有空闲索引节点的块组中给它分配一个。该函数从包含父目录的组开始往下找。具体如下：</p>
<blockquote>
<ol>
<li>从包含父目录dir的块组开始，执行快速的对数查找。这种算法要查找log(n)个块组，这里n是块组总数。该算法一直向前查找直到找到一个可用的块组，具体如下：如果我们把开始的块组称为i，那么，该算法要查找的块组为i mod(n)，i+1 mod(n)，i+1+2 mod(n)，i+l+2+4 mod(n)，等等。</li>
<li>如果该算法没有找到含有空闲索引节点的块组，就从包含父目录dir的块组开始执行彻底的线性查找。</li>
</ol>
</blockquote>
</li>
<li><p>调用read_inode_bitmap()得到所选块组的索引节点位图，并从中寻找第一个空位，这样就得到了第一个空闲磁盘索引节点号。</p>
</li>
<li><p>分配磁盘索引节点：把索引节点位图中的相应位置位，并把含有这个位图的缓冲区标记为脏。此外，如果文件系统安装时指定了MS_SYNCHRONOUS标志，则调用sync_dirty_buffer()开始I/O写操作并等待，直到写操作终止。</p>
</li>
<li><p>减小组描述符的bg_free_inodes_count字段。如果新的索引节点是一个目录，则增加bg_used_dirs_count字段，并把含有这个组描述符的缓冲区标记为脏。</p>
</li>
<li><p>依据索引节点指向的是普通文件或目录，相应增减超级块内s_debts数组中的组计数器。</p>
</li>
<li><p>减小ext2_sb_info数据结构中的s_freeinodes_counter字段；而且如果新索引节点是目录，则增大ext2_sb_info数据结构的s_dirs_counter字段。</p>
</li>
<li><p>将超级块的s_dirt标志置1，并把包含它的缓冲区标记为脏。</p>
</li>
<li><p>把VFS超级块对象的s_dirt字段置1。</p>
</li>
<li><p>初始化这个索引节点对象的字段。特别是，设置索引节点号i_no，并把xtime.tv_sec的值拷贝到i_atime、i_mtime及i_ctime。把这个块组的索引赋给ext2_inode_info结构的i_block_group字段。关于这些字段的含义请参考表18-3。</p>
</li>
<li><p>初始化这个索引节点对象的访问控制列表(ACL)。</p>
</li>
<li><p>将新索引节点对象插入散列表inode_hashtable，调用mark_inode_dirty()把该索引节点对象移进超级块脏索引节点链表。</p>
</li>
<li><p>调用ext2_preread_inode()从磁盘读入包含该索引节点的块，将它存入页高速缓存。进行这种预读是因为最近创建的索引节点可能会被很快写入。(在执行索引节点刷新时，先刷新到磁盘高速缓存，磁盘高速缓存再刷新到磁盘)</p>
</li>
<li><p>返回新索引节点对象的地址。</p>
</li>
</ol>
<h3 id="删除索引节点"><a href="#删除索引节点" class="headerlink" title="删除索引节点"></a>删除索引节点</h3><p>用ext2_free_inode()函数删除一个磁盘索引节点，把磁盘索引节点表示为索引节点对象，其地址作为参数来传递。内核在进行一系列的清除操作(包括清除内部数据结构和文件中的数据)之后调用这个函数。具体来说，它在下列操作完成之后才执行：</p>
<ol>
<li><p>索引节点对象已经从散列表中删除，</p>
</li>
<li><p>指向这个索引节点的最后一个硬链接已经从适当的目录中删除，</p>
</li>
<li><p>文件的长度截为0以回收它的所有数据块。<br>函数执行下列操作：</p>
</li>
<li><p>调用clear_inode()，它依次执行如下步骤</p>
<blockquote>
<ol>
<li>删除与索引节点关联的“间接”脏缓冲区。它们都存放在一个链表中，该链表的首部在address_space对象inode-&gt;i_data的private_list字段。</li>
<li>如果索引节点的I_LOCK标志置位，则说明索引节点中的某些缓冲区正处于I/O数据传送中；于是，函数挂起当前进程，直到这些I/O数据传送结束。</li>
<li>调用超级块对象的clear_inode方法(如果已定义)，但Ext2文件系统没有定义这个方法。</li>
<li>如果索引节点指向一个设备文件，则从设备的索引节点链表中删除索引节点对象，这个链表要么在cdev字符设备描述符的cdev字段，要么在block_device块设备描述符的bd_inodes字段。</li>
<li>把索引节点的状态置为I_CLEAR(索引节点对象的内容不再有意义)。</li>
</ol>
</blockquote>
</li>
<li><p>从每个块组的索引节点号和索引节点数计算包含这个磁盘索引节点的块组的索引。</p>
</li>
<li><p>调用read_inode_bitmap()得到索引节点位图。</p>
</li>
<li><p>增加组描述符的bg_free_inodes_count字段。如果删除的索引节点是一个目录，那么也要减小bg_used_dirs_count字段。把这个组描述符所在的缓冲区标记为脏。</p>
</li>
<li><p>如果删除的索引节点是一个目录，就减小ext2_sb_info结构的s_dirs_counter字段，把超级块的s_dirt标志置1，并把它所在的缓冲区标记为脏。</p>
</li>
<li><p>清除索引节点位图中这个磁盘索引节点对应的位，并把包含这个位图的缓冲区标记为脏。此外，如果文件系统以MS_SYNCHRONIZE标志安装，则调用sync_dirty_buffer()并等待，直到在位图缓冲区上的写操作终止。</p>
</li>
</ol>
<h3 id="数据块寻址"><a href="#数据块寻址" class="headerlink" title="数据块寻址"></a>数据块寻址</h3><p>每个非空的普通文件都由一组数据块组成。这些块或者由文件内的相对位置(它们的文件块号)来标识，或者由磁盘分区内的位置(它们的逻辑块号)来标识。</p>
<p>从文件内的偏移量f导出相应数据块的逻辑块号需要两个步骤：</p>
<ol>
<li>从偏移量f导出文件的块号，即在偏移量f处的字符所在的块索引。</li>
<li>把文件的块号转化为相应的逻辑块号。因为Unix文件不包含任何控制字符，因此，导出文件的第f个字符所在的文件块号是相当容易的，只是用f除以文件系统块的大小，并取整即可。</li>
</ol>
<p>例如，让我们假定块的大小为4KB。如果f小于4096，那么这个字符就在文件的第一个数据块中，其文件的块号为0。如果f等于或大于4096而小于8192，则这个字符就在文件块号为1的数据块中，以此类推。只用关注文件的块号确实不错。但是，由于Ext2文件的数据块在磁盘上不必是相邻的，因此把文件的块号转化为相应的逻辑块号可不是这么直截了当的。因此，Ext2文件系统必须提供一种方法，用这种方法可以在磁盘上建立每个文件块号与相应逻辑块号之间的关系。</p>
<p>在索引节点内部部分实现了这种映射(回到了AT&amp;T Unix 的早期版本)。这种映射也涉及一些包含额外指针的专用块，这些块用来处理大型文件的索引节点的扩展。磁盘索引节点的i_block字段是一个有EXT2_N_BLOCKS个元素且包含逻辑块号的数组。在下面的讨论中，我们假定EXT2_N_BLOCKS的默认值为15。如图18-5所示，这个数组表示一个大型数据结构的初始化部分。正如从图中所看到的，数组的15个元素有4种不同的类型：<br><img src=".\image-20240503135631198.png" alt=""></p>
<ol>
<li>最初的12个元素产生的逻辑块号与文件最初的12个块对应，即对应的文件块号从0～11。</li>
<li>下标12中的元素包含一个块的逻辑块号(叫做间接块)，这个块表示逻辑块号的一个二级数组。这个数组的元素对应的文件块号从12～b/4+11，这里b是文件系统的块大小(每个逻辑块号占4个字节，因此我们在式子中用4作除数)。因此，内核为了查找指向一个块的指针必须先访问这个元素，然后，在这个块中找到另一个指向最终块(包含文件内容)的指针。</li>
<li>下标13中的元素包含一个间接块的逻辑块号，而这个块包含逻辑块号的一个二级数组，这个二级数组的数组项依次指向三级数组，这个三级数组存放的才是文件块号对应的逻辑块号，范围从b/4+12~(b/4)²+(b/4)+11。</li>
<li>最后，下标14中的元素使用三级间接索引，第四级数组中存放的才是文件块号对应的逻辑块号，范围从(b/4)²+(b/4)+12~(b/4)³+(b/4)²+(b14)+11。</li>
</ol>
<p>在图18-5中，块内的数字表示相应的文件块号。箭头(表示存放在数组元素中的逻辑块号)指示了内核如何通过间接块找到包含文件实际内容的块。注意这种机制是如何支持小文件的。如果文件需要的数据块小于12，那么两次磁盘访问就可以检索到任何数据：一次是读磁盘索引节点i_block数组的一个元素，另一次是读所需要的数据块。对于大文件来说，可能需要三四次的磁盘访问才能找到需要的块。实际上，这是一种最坏的估计，因为目录项、索引节点、页高速缓存都有助于极大地减少实际访问磁盘的次数。还要注意文件系统的块大小是如何影响寻址机制的，因为大的块允许Ext2把更多的逻辑块号存放在一个单独的块中。</p>
<p>表18-11显示了对每种块大小和每种寻址方式所存放文件大小的上限。例如，如果块的大小是1024字节，并且文件包含的数据最多为268KB，那么，通过直接映射可以访问文件最初的12KB数据，通过简单的间接映射可以访问剩余的13～268KB的数据。大于2GB的大型文件通过指定O_LARGEFILE打开标志必须在32 位体系结构上进行打开。<br><img src=".\image-20240503135643560.png" alt=""></p>
<h3 id="文件的洞"><a href="#文件的洞" class="headerlink" title="文件的洞"></a>文件的洞</h3><p>文件的洞(file hole)是普通文件的一部分，它是一些空字符但没有存放在磁盘的任何数据块中。洞是Unix文件一直存在的一个特点。例如，下列的Unix命令创建了第一个字节是洞的文件。<br>$ echo -n “X” l dd of=/tmp/hole bs=1024 seek=6<br>现在，/tmp/hole有6145个字符(6144个空字符加一个X字符)，然而，这个文件在磁盘上只占一个数据块。引入文件的洞是为了避免磁盘空间的浪费。它们被广泛地用在数据库应用中，更一般地说，用于在文件上进行散列的所有应用。文件洞在Ext2中的实现是基于动态数据块的分配的：只有当进程需要向一个块写数据时，才真正把这个块分配给文件。每个索引节点的i_size字段定义程序所看到的文件大小，包括洞，而i_blocks字段存放分配给文件有效的数据块数(以512字节为单位)。</p>
<p>在前面dd命令的例子中，假定/tmp/hole文件创建在块大小为4096的Ext2分区上。其相应磁盘索引节点的i_size字段存放的数为6145，而i_blocks字段存放的数为8(因为每4096字节的块包含8个512字节的块)。i_block数组的第二个元素(对应块的文件块号为1)存放已分配块的逻辑块号，而数组中的其他元素都为空(参看图18-6)。</p>
<h3 id="分配数据块"><a href="#分配数据块" class="headerlink" title="分配数据块"></a>分配数据块</h3><p>当内核要分配一个数据块来保存Ext2普通文件的数据时，就调用ext2_get_block()函数。<br>如果块不存在，该函数就自动为文件分配块。请记住，每当内核在Ext2普通文件上执行读或写操作时就调用这个函数；显然，这个函数只在页高速缓存内没有相应的块时才被调用。<br>ext2_get_block()函数处理在“数据块寻址”一节描述的数据结构，并在必要时调用ext2_alloc_block()函数在Ext2分区真正搜索一个空闲块。如果需要，该函数还为间接寻址分配相应的块(参见图18-5)。<br><img src=".\image-20240503135648664.png" alt=""><br>为了减少文件的碎片，Ext2文件系统尽力在已分配给文件的最后一个块附近找一个新块分配给该文件。如果失败，Ext2文件系统又在包含这个文件索引节点的块组中搜寻一个新的块。作为最后一个办法，可以从其他一个块组中获得空闲块。Ext2文件系统使用数据块的预分配策略。文件并不仅仅获得所需要的块，而是获得一组多达8个邻接的块。<br>ext2_inode_info结构的i_prealloc_count字段存放预分配给某一文件但还没有使用的数据块数，而i_prealloc_block字段存放下一次要使用的预分配块的逻辑块号。当下列情况发生时，释放预分配而一直没有使用的块；当文件被关闭时，当文件被缩短时，或者当一个写操作相对于引发块预分配的写操作不是顺序的时。</p>
<p>ext2_getblk()函数根据下列的试探法设置目标参数：</p>
<ol>
<li>如果正被分配的块与前面已分配的块有连续的文件块号，则目标就是前一块的逻辑块号加1。这很有意义，因为程序所看到的连续的块在磁盘上将会是相邻的。</li>
<li>如果第一条规则不适用，并且至少给文件已分配了一个块，那么目标就是这些块的逻辑块号中的一个。更确切地说，目标是已分配块的逻辑块号，位于文件中待分配块之前。</li>
<li>如果前面的规则都不适用，那么目标就是文件索引节点所在的块组中第一个块的逻辑块号(不必空闲)。</li>
</ol>
<p>ext2_alloc_block()函数接收的参数为</p>
<ol>
<li>指向索引节点对象的指针、</li>
<li>目标(goal)，目标是一个逻辑块号，表示新块的首选位置。</li>
<li>存放错误码的变量地址。<br>ext2_alloc_block()函数检查目标是否指向文件的预分配块中的一块。如果是，就分配相应的块并返回它的逻辑块号；否则，丢弃所有剩余的预分配块并调用ext2_new_block()。</li>
</ol>
<p>ext2_new_block()函数用下列策略在Ext2分区内搜寻一个空闲块：</p>
<ol>
<li>如果传递给ext2_alloc_block()的首选块(目标块)是空闲的，就分配它。</li>
<li>如果目标为忙，就检查首选块后的其余块之中是否有空闲的块。</li>
<li>如果在首选块附近没有找到空闲块，就从包含目标的块组开始，查找所有的块组。对每个块组：<br>a. 寻找至少有8个相邻空闲块的一个组块。<br>b. 如果没有找到这样的一组块，就寻找一个单独的空闲块。只要找到一个空闲块，搜索就结束。在结束前，ext2_new_block()函数还尽力在找到的空闲块附近的块中找8个空闲块进行预分配，并把磁盘索引节点的i_prealloc_block 和i_prealloc_count字段置为适当的块位置及块数。</li>
</ol>
<h3 id="释放数据块"><a href="#释放数据块" class="headerlink" title="释放数据块"></a>释放数据块</h3><p>当进程删除一个文件或把它的长度截为0时，其所有数据块必须回收。这是通过调用ext2_truncate()函数(其参数是这个文件的索引节点对象的地址)来完成的。实际上，这个函数扫描磁盘索引节点的i_block数组，以确定所有数据块的位置和间接寻址用的块的位置。然后反复调用ext2_free_blocks()函数释放这些块。</p>
<p>ext2_free_blocks()函数释放一组含有一个或多个相邻块的数据块。除ext2_truncate()调用它外，当丢弃文件的预分配块时也主要调用它。函数参数如下：</p>
<ul>
<li>inode: 文件的索引节点对象的地址。</li>
<li>block: 要释放的第一个块的逻辑块号。</li>
<li>count: 要释放的相邻块数。</li>
</ul>
<p>这个函数对每个要释放的块执行下列操作：</p>
<ol>
<li>获得要释放块所在块组的块位图。</li>
<li>把块位图中要释放的块的对应位清0，并把位图所在的缓冲区标记为脏。</li>
<li>增加块组描述符的bg_free_blocks_count字段，并把相应的缓冲区标记为脏。</li>
<li>增加磁盘超级块的s_free_blocks_count字段，并把相应的缓冲区标记为脏，把超级块对象的s_dirt标记置位。</li>
<li>如果Ext2文件系统安装时设置了MS_SYNCHRONOUS标志，则调用sync_dirty_buffer()并等待，直到对这个位图缓冲区的写操作终止。</li>
</ol>
<h2 id="Ext3文件系统"><a href="#Ext3文件系统" class="headerlink" title="Ext3文件系统"></a>Ext3文件系统</h2><p>在本节我们将简单描述从Ext2发展而来的增强型文件系统，即Ext3。这个新的文件系统在设计时曾秉持两个简单的概念：</p>
<ol>
<li>成为一个日志文件系统</li>
<li>尽可能与原来的Ext2文件系统兼容<br>Ext3完全达到了这两个目标。尤其是，它很大程度上是基于Ext2的，因此，它在磁盘上的数据结构从本质上与Ext2文件系统的数据结构是相同的。事实上，如果Ext3文件系统已经被彻底卸载，那么就可以把它作为Ext2文件系统来重新安装；反之，创建Ext2 文件系统的日志并把它作为Ext3文件系统来重新安装，也是一种简单、快速的操作。<br>由于Ext3与Ext2之间的兼容性，本章前面几节的很多描述也适用于Ext3。因此，本节我们集中于Ext3所提供的新特点——“日志”。</li>
</ol>
<h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>随着磁盘变得越来越大，传统Unix文件系统(像Ext2)的一种设计选择证明是不相称的。<br>对文件系统块的更新可能在内存保留相当长的时间后才刷新到磁盘。因此，像断电故障或系统崩溃这样不可预测的事件可能导致文件系统处于不一致状态。</p>
<p>为了克服这个问题，每个传统的Unix文件系统在安装之前都要进行检查；如果它没有被正常卸载，那么，就有一个特定的程序执行彻底、耗时的检查，并修正磁盘上文件系统的所有数据结构。</p>
<p>例如，Ext2文件系统的状态存放在磁盘上超级块的s_mount_state字段中。由启动脚本调用e2fsck实用程序检查存放在这个字段中的值；如果它不等于EXT2_VALID_FS，说明文件系统没有正常卸载，因此，e2fsck开始检查文件系统的所有磁盘数据结构。</p>
<p>显然，检查文件系统一致性所花费的时间主要取决于要检查的文件数和目录数；因此，它也取决于磁盘的大小。如今，随着文件系统达到几百个GB，一次一致性检查就可能花费数个小时。造成的停机时间对任何生产环境和高可用服务器都是无法接受的。</p>
<p>日志文件系统的目标就是避免对整个文件系统进行耗时的一致性检查，这是通过查看一个特殊的磁盘区达到的，因为这种磁盘区包含所谓日志(journal)的最新磁盘写操作。系统出现故障后，安装日志文件系统只不过是几秒钟的事。</p>
<h3 id="Ext3日志文件系统"><a href="#Ext3日志文件系统" class="headerlink" title="Ext3日志文件系统"></a>Ext3日志文件系统</h3><p>Ext3日志所隐含的思想就是对文件系统进行的任何高级修改都分两步进行。</p>
<ol>
<li>首先，把待写块的一个副本存放在日志中；</li>
<li>其次，当发往日志的I/O数据传送完成时(简而言之，把数据提交到日志)，块就被写入文件系统。当发往文件系统的I/O数据传送终止时(把数据提交给文件系统)，日志中的块副本就被丢弃。（先写磁盘日志，再写磁盘文件系统）</li>
</ol>
<p>当从系统故障中恢复时，e2fsck程序区分下列两种情况：</p>
<ol>
<li>提交到日志之前系统故障发生。<br>与高级修改相关的块副本或者从日志中丢失，或者是不完整的；在这两种情况下，e2fsck都忽略它们。</li>
<li>提交到日志之后系统故障发生。<br>块的副本是有效的，且e2fsck把它们写入文件系统。</li>
</ol>
<ul>
<li>在第一种情况下，对文件系统的高级修改被丢失，但文件系统的状态还是一致的。</li>
<li>在第二种情况下，e2fsck应用于整个高级修改，因此，修正由于把未完成的I/O数据传送到文件系统而造成的任何不一致。</li>
</ul>
<p>​    不要对日志文件系统有太多的期望。它只能确保系统调用级的一致性。</p>
<p>​    例如，当你正在发出几个write()系统调用拷贝一个大型文件时发生了系统故障，这将会使拷贝操作中断，因此，复制的文件就会比原来的文件短。因此，日志文件系统通常不把所有的块都拷贝到日志中。</p>
<p>​    事实上，每个文件系统都由两种块组成：包含所谓元数据(metadata)的块和包含普通数据的块。</p>
<p>​    在Ext2和Ext3的情形中，有六种元数据：超级块、块组描述符、索引节点、用于间接寻址的块(间接块)，数据位图块和索引节点位图块。其他的文件系统可能使用不同的元数据。</p>
<p>​    很多日志文件系统(如SGI的XFS以及IBM的JFS)都限定自己把影响元数据的操作记入日志。<br>​    事实上，元数据的日志记录足以恢复磁盘文件系统数据结构的一致性。然而，因为文件的数据块不记入日志，因此就无法防止系统故障造成的文件内容的损坏。不过，可以把Ext3文件系统配置为把影响文件系统元数据的操作和影响文件数据块的操作都记入日志。因为把每种写操作都记入日志会导致极大的性能损失，因此，Ext3让系统管理员决定应当把什么记入日志；具体来说，它提供三种不同的日志模式：</p>
<ul>
<li>日志(Journal): 文件系统所有数据和元数据的改变都被记入日志。这种模式减少了丢失每个文件修改的机会，但是它需要很多额外的磁盘访问。例如，当一个新文件被创建时，它的所有数据块都必须复制一份作为日志记录。这是最安全和最慢的Ext3日志模式。</li>
<li>预定(Ordered): 只有对文件系统元数据的改变才被记入日志。然而，Ext3文件系统把元数据和相关的数据块进行分组，以便在元数据之前把数据块写入磁盘。这样，就可以减少文件内数据损坏的机会；例如，确保增大文件的任何写访问都完全受日志的保护。这是缺省的Ext3日志模式。<br>写回(Writeback): 只有对文件系统元数据的改变才被记入日志；这是在其他日志文件系统中发现的方法，也是最快的模式。</li>
<li>Ext3文件系统的日志模式由mount系统命令的一个选项来指定。例如，为了在/jdisk安装点对存放在/dev/sda2分区上的Ext3文件系统以“写回”模式进行安装，系统管理员可以键入如下命令.</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">mount -t ext3 -o data&#x3D;writeback &#x2F;dev&#x2F;sda2 &#x2F;jdisk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="日志块设备层"><a href="#日志块设备层" class="headerlink" title="日志块设备层"></a>日志块设备层</h3><p>Ext3日志通常存放在名为.journal的隐藏文件中，该文件位于文件系统的根目录。Ext3文件系统本身不处理日志，而是利用所谓日志块设备(Journaling Block Device，JBD)的通用内核层。现在，只有Ext3使用JDB层，而其他文件系统可能在将来才使用它。</p>
<p>JDB层是相当复杂的软件部分。Ext3文件系统调用JDB例程，以确保在系统万一出现故障时它的后续操作不会损坏磁盘数据结构。然而，JDB典型地使用同一磁盘来把Ext3文件系统所做的改变记入日志，因此，它与Ext3一样易受系统故障的影响。换言之，JDB 也必须保护自己免受任何系统故障引起的日志损环。因此，Ext3与JDB之间的交互本质上基于三个基本单元：</p>
<ul>
<li>日志记录: 描述日志文件系统一个磁盘块的一次更新。</li>
<li>原子操作处理: 包括文件系统的一次高级修改对应的日志记录；一般来说，修改文件系统的每个系统调用都引起一次单独的原子操作处理。</li>
<li>事务: 包括几个原子操作处理，同时，原子操作处理的日志记录对e2fsck标记为有效。</li>
</ul>
<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>日志记录(log record)本质上是文件系统将要发出的一个低级操作的描述。在某些日志文件系统中，日志记录只包括操作所修改的字节范围及字节在文件系统中的起始位置。然而，JDB层使用的日志记录由低级操作所修改的整个缓冲区组成。</p>
<p>这种方式可能浪费很多日志空间(例如，当低级操作仅仅改变位图的一个位时)，但是，它还是相当快的，因为JBD层直接对缓冲区和缓冲区首部进行操作。因此，日志记录在日志内部表示为普通的数据块(或元数据)。但是，每个这样的块都是与类型为journal_block_tag_t的小标签相关联的，这种小标签存放块在文件系统中的逻辑块号和几个状态标志。随后，只要一个缓冲区得到JBD的关注，或者因为它属于日志记录，或者因为它是一个数据块，该数据块应当在相应的元数据之前刷新到磁盘(处于“预定”模式)，那么，内核把journal_head数据结构加入到缓冲区首部。在这种情况下，缓冲区首部的b_private 字段存放journal_head数据结构的地址，并把BH_JBD标志置位。</p>
<h3 id="原子操作处理"><a href="#原子操作处理" class="headerlink" title="原子操作处理"></a>原子操作处理</h3><p>修改文件系统的任一系统调用通常都被划分为操纵磁盘数据结构的一系列低级操作。<br>例如，假定Ext3必须满足用户把一个数据块追加到普通文件的请求。文件系统层必须确定文件的最后一个块，定位文件系统中的一个空闲块，更新适当块组内的数据块位图，存放新块的逻辑块号在文件的索引节点或间接寻址块中，写新块的内容，并在最后更新索引节点的几个字段。你可以看到，追加操作转换为对文件系统数据块和元数据块很多低级的操作。现在，仅仅想象一下，如果在追加操作的中间一些低级操作已经执行，另一些还没有执行，而系统出现了故障会发生什么事情。当然，对于影响两个或多个文件的高级操作(例如，把文件从一个目录移到另一个目录)，情况会更糟。为了防止数据损坏，Ext3文件系统必须确保每个系统调用以原子的方式进行处理。原子操作处理(atomic operation handle)是对磁盘数据结构的一组低级操作，这组低级操作对应一个单独的高级操作。当从系统故障中恢复时，文件系统确保要么整个高级操作起作用，要么没有一个低级操作起作用。</p>
<p>任何原子操作处理都用类型为handle_t的描述符来表示。为了开始一个原子操作，Ext3 文件系统调用journal_start() JBD函数，该函数在必要时分配一个新的原子操作处理并把它插入到当前的事务中。因为对磁盘的任何低级操作都可能挂起进程，因此，活动原子操作处理的地址存放在进程描述符的journal_info字段中。为了通知原子操作已经完成，Ext3文件系统调用journal_stop()函数。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>出于效率的原因，JBD层对日志的处理采用分组的方法，即把属于几个原子操作处理的日志记录分组放在一个单独的事务(transaction)中。此外，与一个处理相关的所有日志记录都必须包含在同一个事务中。一个事务的所有日志记录存放在日志的连续块中。JBD层把每个事务作为整体来处理。</p>
<p>例如，只有当包含在一个事务的日志记录中的所有数据都提交给文件系统时才回收该事务所使用的块。事务一旦被创建，它就能接受新处理的日志记录。当下列情况之一发生时，事务就停止接受新处理：</p>
<ol>
<li>固定的时间已经过去，典型情况下为5s。</li>
<li>日志中没有空闲块留给新处理</li>
<li>事务是由类型为transaction_t的描述符来表示的。其最重要的字段为t_state，该字段描述事务的当前状态。<br>从本质上说，事务可以是：</li>
</ol>
<ul>
<li><p>完成的: 包含在事务中的所有日志记录都已经从物理上写入日志。当从系统故障中恢复时，e2fsck考虑日志中每个完成的事务，并把相应的块写入文件系统。在这种情况下，t_state字段存放值T_FINISHED。</p>
</li>
<li><p>未完成的: 包含在事务中的日志记录至少还有一个没有从物理上写入日志，或者新的日志记录还正在追加到事务中。在系统故障的情况下，存放在日志中的事务映像很可能不是最新的。因此，当从系统故障中恢复时，e2fsck不信任日志中未完成的事务，并跳过它们。在这种情况下，i_state存放下列值之一：</p>
</li>
</ul>
<blockquote>
<ul>
<li>T_RUNNING: 还在接受新的原子操作处理。</li>
<li>T_LOCKED: 不接受新的原子操作处理，但其中的一些还没有完成。</li>
<li>T_FLUSH: 所有的原子操作处理都已完成，但一些日志记录还正在写入日志。</li>
<li>T_COMMIT: 原子操作处理的所有日志记录都已经写入磁盘，但在日志中，事务仍然被标记为完成。</li>
</ul>
</blockquote>
<p>​    在任何时刻，日志可能包含多个事务，但其中只有一个处于T_RUNNING状态，即它是活动事务(active transaction)。所谓活动事务就是正在接受由Ext3文件系统发出的新原子操作处理的请求。日志中的几个事务可能是未完成的，因为包含相关日志记录的缓冲区还没有写入日志。如果事务完成，说明所有日志记录已被写入日志，但是一部分相应的缓冲区还没有写入文件系统。只有当JDB层确认日志记录描述的所有缓冲区都已成功写入Ext3文件系统时，一个完成的事务才能从日志中删除。</p>
<h3 id="日志如何工作"><a href="#日志如何工作" class="headerlink" title="日志如何工作"></a>日志如何工作</h3><p>让我们用一个例子来试图解释日志如何工作：Ext3文件系统层接受向普通文件写一些数据块的请求。你可能很容易猜到，我们不打算详细描述Ext3文件系统层和JDB层的每个单独操作。那将会涉及太多问题！但是，我们描述本质的操作：</p>
<ol>
<li>write()系统调用服务例程触发与Ext3普通文件相关的文件对象的write方法。对于Ext3来说，这个方法是由generic_file_write()函数实现的。</li>
<li>generic_file_write()函数几次调用address_space对象的prepare_write方法，写方法涉及的每个数据页都调用一次。对Ext3来说，这个方法是由ext3_prepare_write()函数实现的。</li>
<li>ext3_prepare_write()函数调用journal_start() JBD函数开始一个新的原子操作。这个原子操作处理被加到活动事务中。实际上，原子操作处理是在第一次调用journal_start()函数时创建的。后续的调用确认进程描述符的journal_info字段已经被置位，并使用这个处理。</li>
<li>ext3_prepare_write()函数调用第十六章已描述过的block_prepare_write()函数，传递给它的参数为ext3_get_block()函数的地址。回想一下，block_prepare_write()负责准备文件页的缓冲区和缓冲区首部。</li>
<li>当内核必须确定Ext3文件系统的逻辑块号时，就执行ext3_get_block()函数。这个函数实际上类似于ext2_get_block()，后者在前面“分配数据块”一节已经描述。但是，有一个主要的差异在于Ext3文件系统调用JDB层的函来确保低级操作记入日志：在对Ext3文件系统的元数据块发出低级写操作之前，该函数调用journal_get_write_access()。后一个函数主要把元数据缓冲区加入到活动事务的链表中。但是，它也必须检查元数据是否包含在日志的一个较老的未完成的事务中；在这种情况下，它把缓冲区复制一份以确保老的事务以老的内容提交。在更新元数据块所在的缓冲区之后，Ext3文件系统调用journal_dirty_metadata()把元数据缓冲区移到活动事务的适当脏链表中，并在日志中记录这一操作。注意，由JDB层处理的元数据缓冲区通常并不包含在索引节点的缓冲区的脏链表中，因此，这些缓冲区并不由第十五章描述的正常磁盘高速缓存的刷新机制写入磁盘。</li>
<li>如果Ext3文件系统已经以“日志”模式安装，则ext3_prepare_write()函数在写操作触及的每个缓冲区上也调用journal_get_write_access()。</li>
<li>控制权回到generic_file_write()函数，该函数用存放在用户态地址空间的数据更新页，并调用address_space对象的commit_write方法。对于Ext3，函数如何实现这个方法取决于Ext3文件系统的安装方式：</li>
</ol>
<p>​    如果Ext3文件系统已经以“日志”模式安装，那么commit_write方法是由ext3_journalled_commit_write()函数实现的，它对页中的每个数据(不是元数据)缓冲区调用journal_dirty_metadata()。这样，缓冲区就包含在活动事务的适当脏链表中，但不包含在拥有者索引节点的脏链表中；此外，相应的日志记录写入日志。最后，ext3_journalled_commit_write()调用journal_stop通知JBD层原子操作处理已关闭。</p>
<p>​    如果Ext3文件系统已经以“预定”模式安装，那么commit_write方法是由ext3_ordered_commit_write()函数实现的，它对页中的每个数据缓冲区调用journal_dirty_data()函数以把缓冲区插入到活动事务的适当链表中。JDB层确保在事务中的元数据缓冲区写入之前这个链表中的所有缓冲区写入磁盘。没有日志记录写入日志。然后，ext3_ordered_commit_write()函数执行第十五章描述的常规generic_commit_write()函数，该函数把数据缓冲区插入拥有者索引节点的脏缓冲区链表中。最后，ext3_ordered_commit_write()调用journal_stop()通知JBD层原子操作处理已关闭。</p>
<p>如果Ext3文件系统已经以“写回”模式安装，那么commit_write方法是由ext3_writeback_commit_write()函数实现的，它执行第十五章描述的常规generic_commit_write()函数，该函数把数据缓冲区插入拥有者索引节点的脏缓冲区链表中。然后，ext3_writeback_commit_write()调用journal_stop()通知JBD层原子操作处理已关闭。</p>
<ol>
<li>write()系统调用的服务例程到此结束。但是，JDB层还没有完成它的工作。终于，当事务的所有日志记录都物理地写入日志时，我们的事务才完成。然后，执行journal_commit_transaction()。</li>
<li>如果Ext3文件系统已经以“预定”模式安装，则journal_commit_transaction()函数为事务链表包含的所有数据缓冲区激活I/O数据传送，并等待直到数据传送终止。</li>
<li>journal_commit_transaction()函数为包含在事务中的所有元数据缓冲区激活I/O数据传送(如果Ext3以“日志”模式安装，则也为所有的数据缓冲区激活I/O数据传送)。</li>
<li>内核周期性地为日志中每个完成的事务激活检查点活动。检查点主要验证由journal_commit_transaction()触发的I/O数据传送是否已经成功结束。如果是，则从日志中删除事务。当然，除非发生系统故障，否则日志中的日志记录根本就没有什么积极作用。事实上，只有在系统发生故障时，e2fsck实用程序才扫描存放在文件系统中的日志，并重新安排完成的事务中的日志记录所描述的所有写操作。</li>
</ol>
<h1 id="I-O体系结构和设备驱动程序"><a href="#I-O体系结构和设备驱动程序" class="headerlink" title="I/O体系结构和设备驱动程序"></a>I/O体系结构和设备驱动程序</h1><h3 id="I-O体系结构"><a href="#I-O体系结构" class="headerlink" title="I/O体系结构"></a>I/O体系结构</h3><p>​    为了确保计算机能够正常工作，必须提供数据通路，让信息在连接到个人计算机的CPU、RAM和I/O设备之间流动。这些数据通路总称为总线，担当计算机内部主通信通道的作用。</p>
<p>​    所有计算机都拥有一条系统总线，它连接大部分内部硬件设备。一种典型的系统总线是PCl(Peripheral Component Interconnect)总线。目前使用其他类型的总线也很多，例如ISA、EISA、MCA、SCSI和USB。典型的情况是，一台计算机包括几种不同类型的总线，它们通过被称作“桥”的硬件设备连接在一起。两条高速总线用于在内存芯片上来回传送数据：<br>前端总线将CPU连接到RAM控制器上，而后端总线将CPU直接连接到外部硬件的高速缓存上。主机上的桥将系统总线和前端总线连接在一起。</p>
<p>​    任何I/O设备有且仅能连接一条总线。总线的类型影响I/O设备的内部设计，也影响着内核如何处理设备。本节我们将讨论所有PC体系结构共有的功能性特点，而不具体介绍特定总线类型的技术细节。</p>
<p>​    CPU和I/O设备之间的数据通路通常称为I/O总线。</p>
<p><img src=".\image-20240503140329641.png" alt="image-20240503140329641"></p>
<h3 id="I-O端口"><a href="#I-O端口" class="headerlink" title="I/O端口"></a>I/O端口</h3><p>​    每个连接到I/O总线上的设备都有自己的I/O地址集，通常称为I/O端口(1/O port)。在IBM PC体系结构中，I/O地址空间一共提供了65536个8位的I/O端口。可以把两个连续的8位端口看成一个16位端口，但是这必须从偶数地址开始。同理，也可以把两个连续的I6位端口看成一个32位端口，但是这必须是从4的整数倍地址开始。</p>
<p>​    有四条专用的汇编语言指令可以允许CPU对I/O端口进行读写，它们是in、ins、out.和outs。在执行其中的一条指令时，CPU使用地址总线选择所请求的I/O端口，使用数据总线在CPU寄存器和端口之间传送数据。</p>
<p>I/O端口还可以被映射到物理地址空间。因此，处理器和I/O设备之间的通信就可以使用对内存直接进行操作的汇编语言指令(例如，mov、and、or等等)。现代的硬件设备更倾向于映射的I/O，因为这样处理的速度较快，并可以和DMA结合起来。</p>
<p>系统设计者的主要目的是对I/O编程提供统一的方法，但又不牺牲性能。为了达到这个目的，每个设备的I/O端口都被组织成如图13-2所示的一组专用寄存器。CPU把要发送给设备的命令写入设备控制寄存器(device control register)，并从设备状态寄存器(device status register)中读出表示设备内部状态的值。CPU还可以通过读取设备输入寄存器(device input register)的内容从设备取得数据，也可以通过向设备输出寄存器(device output register)中写入字节而把数据输出到设备。</p>
<p>为了降低成本，通常把同一I/O端口用于不同目的。例如，某些位描述设备的状态，而其他位指定向设备发出的命令。同理，也可以把同一I/O端口用作输入寄存器或输出寄存器。</p>
<h3 id="访问I-O端口"><a href="#访问I-O端口" class="headerlink" title="访问I/O端口"></a>访问I/O端口</h3><p>in、out、ins和outs汇编语言指令都可以访问I/O端口。内核中包含了以下辅助函数来简化这种访问：</p>
<ul>
<li>inb()，inw()，inl()：分别从I/O端口读取1、2或4个连续字节。后缀“b”、“w”、“I”分别代表一个字节(8位)、一个字(16位)以及一个长整型(32位)。</li>
<li>inb_p()，inw_p()，inl_p()：分别从I/O端口读取1、2或4个连续字节，然后执行一条“哑元(dummy，即空指令)”指令使CPU暂停。</li>
<li>outb()，outw()，outl()：分别向一个I/O端口写入1、2或4个连续字节。</li>
<li>outb_p()，outw_p()，outl_p()：分别向一个I/O端口写入1、2或4个连续字节，然后执行一条“哑元”指令使CPU 暂停。</li>
<li>insb()，insw()，insl()：分别从I/O端口读取以1、2或4个字节为一组的连续字节序列。字节序列的长度由该函数的参数给出。</li>
<li>outsb()，outsw()，outsl()：分别向I/O端口写入以1、2或4个字节为一组的连续字节序列。</li>
</ul>
<p>虽然访问I/O端口非常简单，但是检测哪些I/O端口已经分配给I/O设备可能就不这么简单了，对基于ISA总线的系统来说更是如此。通常，I/O设备驱动程序为了探测硬件设备，需要盲目地向某一I/O端口写入数据；但是，如果其他硬件设备已经使用了这个端口，那么系统就会崩溃。为了防止这种情况的发生，内核必须使用“资源”来记录分配给每个硬件设备的I/O端口。</p>
<p>资源(resource)表示某个实体的一部分，这部分被互斥地分配给设备驱动程序。在我们的情况中，一个资源表示I/O端口地址的一个范围。每个资源对应的信息存放在resource数据结构中，其字段如表13-1所示。所有的同种资源都插入到一个树型数据结构中；例如，表示I/O端口地址范围的所有资源都包含在一个根节点为ioport_resource 的树中。</p>
<p>节点的孩子被收集在一个链表中，其第一个元素由child指向。sibling字段指向链表中的下一个节点。为什么使用树?<br>例如，考虑一下IDE硬盘接口所使用的I/O端口地址——比如说从0xf000到0xf00f。然后，start字段为0xf000且end字段为0xf00f的这样一个资源包含在树中，控制器的常规名字存放在name字段中。但是，IDE设备驱动程序需要记住另外的信息，也就是IDE链(IDE chain)的主盘(master disk)使用0xf000～0xf007 的子范围，从盘(slave disk)使用0xf008~0xf00f的子范围。<br>为了做到这点，设备驱动程序把两个子范围对应的孩子插入到0xf000，0xf00f的整个范围对应的资源下。一般来说，树中的每个节点肯定相当于父节点对应范围的一个子范围。I/O端口资源树(ioport_resource)的根节点跨越了整个I/O地址空间(从端口0~65535)。</p>
<p>任何设备驱动程序都可以使用下面三个函数，传递给它们的参数为资源树的根节点和要插入的新资源数据结构的地址：</p>
<ul>
<li>request_resource()：把一个给定范围分配给一个I/O设备。</li>
<li>allocate_resource()：在资源树中寻找一个给定大小和排列方式的可用范围；若存在，就将这个范围分配给一个I/O设备(主要由PCI设备驱动程序使用，这种驱动程序可以配置成使用任意的端口号和主板上的内存地址对其进行配置)。</li>
<li>release_resource()：释放以前分配给I/O设备的给定范围。</li>
</ul>
<p>内核也为以上应用于I/O端口的函数定义了一些快捷函数：request_region()分配I/O 端口的给定范围，release_region()释放以前分配给I/O端口的范围。当前分配给I/O 设备的所有I/O地址的树都可以从/proc/ioports文件中获得。</p>
<h3 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I/O接口"></a>I/O接口</h3><p>​    I/O接口(1/0 interface)是处于一组I/O端口和对应的设备控制器之间的一种硬件电路。它起翻译器的作用，即把I/O端口中的值转换成设备所需要的命令和数据。在相反的方向上，它检测设备状态的变化，并对起状态寄存器作用的I/O端口进行相应的更新。还可以通过一条IRQ线把这种电路连接到可编程中断控制器上，以使它代表相应的设备发出中断请求。有两种类型的接口：</p>
<ul>
<li>专用1/0接口：专门用于一个特定的硬件设备。在一些情况下，设备控制器与这种I/O接口处于同一块卡中。连接到专用I/O接口上的设备可以是内部设备(位于PC机箱内部的设备)，也可以是外部设备(位于PC机箱外部的设备)。</li>
<li>通用I/O接口：用来连接多个不同的硬件设备。连接到通用I/O接口上的设备通常都是外部设备。</li>
</ul>
<p>​    每块卡都要插入PC的一个可用空闲总线插槽中。如果一块卡通过一条外部电缆连接到一个外部设备上，那么在PC后面的面板中就有一个对应的连接器。</p>
<h3 id="专用IO接口"><a href="#专用IO接口" class="headerlink" title="专用IO接口"></a>专用IO接口</h3><p>专用I/O接口的种类很多，因此目前已装在PC上设备的种类也很多，我们无法一一列出，在此只列出一些最通用的接口：</p>
<ul>
<li>键盘接口：连接到一个键盘控制器上，这个控制器包含一个专用微处理器。这个微处理器对按下的组合键进行译码，产生一个中断并把相应的键盘扫描码写入输入寄存器。</li>
<li>图形接口：和图形卡中对应的控制器封装在一起，图形卡有自己的帧缓冲区，还有一个专用处理器以及存放在只读存储器(ROM)芯片中的一些代码。帧缓冲区是显卡上固化的存储器，其中存放的是当前屏幕内容的图形描述。</li>
<li>磁盘接口：由一条电缆连接到磁盘控制器，通常磁盘控制器与磁盘放在一起。例如，IDE接口由一条40线的带形电缆连接到智能磁盘控制器上，在磁盘本身就可以找到这个控制器。</li>
<li>总线鼠标接口：由一条电缆把接口和控制器连接在一起，控制器就包含在鼠标中。</li>
<li>网络接口：与网卡中的相应控制器封装在一起，用以接收或发送网络报文。虽然广泛采用的网络标准很多，但还是以太网(IEEE 802.3)最为通用。</li>
</ul>
<h3 id="通用IO接口"><a href="#通用IO接口" class="headerlink" title="通用IO接口"></a>通用IO接口</h3><p>现代PC都包含连接很多外部设备的几个通用I/O接口。最常用的接口有：</p>
<ul>
<li>并口：传统上用于连接打印机，它还可以用来连接可移动磁盘、扫描仪、备份设备、其他计算机等等。数据的传送以每次1字节(8位)为单位进行。</li>
<li>串口：与并口类似，但数据的传送是逐位进行的。串口包括一个通用异步收发器(UART)芯片，它可以把要发送的字节信息拆分成位序列，也可以把接收到的位流重新组装成字节信息。由于串口本质上速度低于并口，因此主要用于连接那些不需要高速操作的外部设备，如调制解调器、鼠标以及打印机。</li>
<li>CMCIA接口：大多数便携式计算机都包含这种接口。在不重新启动系统的情况下，这种形状类似于信用卡的外部设备可以被插入插槽或从插槽中拔走。最常用的PCMCIA设备是硬盘、调制解调器、网卡和扩展RAM。</li>
<li>SCSI(小型计算机系统接口)接口：是把PC主总线连接到次总线(称为SCSI总线)的电路。SCSI-2总线允许一共8 个PC和外部设备(硬盘、扫描仪、CR-ROM刻录机等等)连接在一起。如果有附加接口，宽带SCSI-2和新的SCSI-3接口可以允许你连接多达16个以上的设备。SCSI标准是通过SCSI总线连接设备的通信协议。</li>
<li>通用串行总线(USB)：高速运转的通用I/O接口，可用于连接外部设备，代替传统的并口、串口以及SCSI接口。</li>
</ul>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>复杂的设备可能需要一个设备控制器(device controller)来驱动。从本质上说，控制器起两个重要作用：</p>
<ol>
<li>对从I/O接口接收到的高级命令进行解释，并通过向设备发送适当的电信号序列强制设备执行特定的操作。</li>
<li>对从设备接收到的电信号进行转换和适当地解释，并修改(通过I/O接口)状态寄存器的值。</li>
</ol>
<p>​    典型的设备控制器是磁盘控制器，它从微处理器(通过I/O接口)接收诸如“写这个数据块”之类的高级命令，并将其转换成诸如“把磁头定位在正确的磁道上”和“把数据写入这个磁道”之类的低级磁盘操作。现代的磁盘控制器相当复杂，因为它们可以把磁盘数据快速保存到内存的高速缓存中，还可以根据实际磁盘的几何结构重新安排CPU的高级请求，使其最优化。</p>
<p>​    比较简单的设备没有设备控制器，可编程中断控制器和可编程间隔定时器就是这样的设备。很多硬件设备都有自己的存储器，通常称之为I/O共享存储器。例如，所有比较新的图形卡在帧缓冲区中都有几MB的RAM，用它来存放要在屏幕上显示的屏幕映像。</p>
<h3 id="设备驱动程序模型"><a href="#设备驱动程序模型" class="headerlink" title="设备驱动程序模型"></a>设备驱动程序模型</h3><p>Linux内核的早期版本为设备驱动程序的开发者提供微不足道的基本功能：分配动态内存，保留I/O地址范围或中断请求(IRQ)，激活一个中断服务例程来响应设备的中断。事实上，在更老的硬件设备上编程棘手而困难重重，还有即使两种不同的硬件设备连在同一条总线上，但二者也很少有共同点。因此，试图为这种硬件设备的驱动程序开发者提供一种统一的模型是难以做到的。</p>
<p>现在的情形大不一样。诸如PCI这样的总线类型对硬件设备的内部设计提出了强烈的要求；因此，新的硬件设备即使类型不同但也有相似的功能。对这种设备的驱动程序应当特别关注：</p>
<ol>
<li>电源管理(控制设备电源线上不同的电压级别)</li>
<li>即插即用(配置设备时透明的资源分配)</li>
<li>热插拔(系统运行时支持设备的插入和移走)</li>
</ol>
<p>​    系统中所有硬件设备由内核全权负责电源管理。而且，硬件设备必须按准确的顺序进人“待机”状态，否则一-些设备可能会处于错误的电源状态。例如，内核必须首先将硬盘置于“待机”状态，然后才是它们的磁盘控制器，因为若按照相反的顺序执行，磁盘控制器就不能向硬盘发送命令。</p>
<p>为了实现这些操作，Linux 2.6提供了一些数据结构和辅助函数，它们为系统中所有的总线、设备以及设备驱动程序提供了一个统一的视图；这个框架被称为设备驱动程序模型。</p>
<h3 id="sysfs文件系统"><a href="#sysfs文件系统" class="headerlink" title="sysfs文件系统"></a>sysfs文件系统</h3><p>sysfs文件系统是一种特殊的文件系统。/proc 文件系统是首次被设计成允许用户态应用程序访问内核内部数据结构的一种文件系统。/sysfs文件系统本质上与/proc有相同的目的，但是它还提供关于内核数据结构的附加信息；此外，/sysfs的组织结构比/proc更有条理。或许，在不远的将来，/proc和/sysfs将会继续共存。sysfs文件系统的目标是要展现设备驱动程序模型组件间的层次关系。该文件系统的相应高层目录是：</p>
<ul>
<li>block：块设备，它们独立于所连接的总线。</li>
<li>devices：所有被内核识别的硬件设备，依照连接它们的总线对其进行组织。</li>
<li>bus：系统中用于连接设备的总线。</li>
<li>drivers：在内核中注册的设备驱动程序。</li>
<li>class：系统中设备的类型(声卡、网卡、显卡等等)；同一类可能包含由不同总线连接的设备，于是由不同的驱动程序驱动。</li>
<li>power：处理一些硬件设备电源状态的文件。</li>
<li>firmware：处理一些硬件设备的固件的文件。</li>
</ul>
<p>sysfs文件系统中所表示的设备驱动程序模型组件之间的关系就像目录和文件之间符号链接的关系一样。例如，文件/sys/block/sda/device可以是一个符号链接，指向在/sys/devices/pci0000:00(表示连接到PCI总线的SCSI控制器)中嵌入的一个子目录。此外，文件/sys/block/sda/device/block是到目录/sys/block/sda的一个符号链接，这表明这个PCI设备是SCSI磁盘的控制器。</p>
<p>sysfs文件系统中普通文件的主要作用是表示驱动程序和设备的属性。例如，位于目录/sys/block/hda下的dev文件含有第一个IDE链主磁盘的主设备号和次设备号。</p>
<h3 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h3><p>设备驱动程序模型的核心数据结构是一个普通的数据结构，叫做kobject，它与sysfs文件系统自然地绑定在一起：每个kobject对应于sysfs文件系统中的一个目录。kobject被嵌入一个叫做“容器”的更大对象中，容器描述设备驱动程序模型中的组件。容器的典型例子有总线、设备以及驱动程序的描述符；例如，第一个IDE磁盘的第一个分区描述符对应于/sys/block/hda/hdal目录。将一个kobject嵌入容器中允许内核：</p>
<ol>
<li>为容器保持一个引用计数器。</li>
<li>维持容器的层次列表或组(例如，与块设备相关的sysfs目录为每个磁盘分区包含一个不同的子目录)。</li>
<li>为容器的属性提供一种用户态查看的视图。</li>
</ol>
<p>kobject、kset和subsystem每个kobject由kobject数据结构描述，其各字段如表13-2所示。</p>
<ul>
<li><p>name: 用来表示内核对象的名称，如果该内核对象加入到系统，那么它的name就会出现在sys目录下。</p>
</li>
<li><p>entry: 用来将一系列的内核对象kobject连接成链表</p>
</li>
<li><p>parent: 用来指向该内核对象的上层节点，从而可以实现内核对象的层次化结构</p>
</li>
<li><p>kset: 用来执行内核对象所属的kset。kset对象用来容纳一系列同类型的kobject</p>
</li>
<li><p>ktype: 用来定义该内核对象的sys文件系统的相关操作函数和属性。</p>
</li>
<li><p>sd: 用来表示该内核对象在sys文件系统中的目录项实例</p>
</li>
<li><p>kref: 其核心是原子操作变量，用来表示该内核对象的引用计数。</p>
</li>
<li><p>state_initialized: 用来表示该内核对象的初始化状态，1表示已经初始化，0表示未初始化。</p>
</li>
<li><p>state_in_sysfs: 用来表示该内核对象是否在sys中已经存在。</p>
</li>
<li><p>state_add_uevent_sent: 用来表示该内核对象是否向用户空间发送了ADD uevent事件</p>
</li>
<li><p>state_remove_uevent_sent:用来表示该内核对象是否向用户空间发送了Remove uevent事件</p>
</li>
<li><p>uevent_suppress: 用来表示该内核对象状态发生改变时，时候向用户空间发送uevent事件，1表示不发送。</p>
</li>
</ul>
<p>​    ktype字段指向kobj_type对象，该对象描述了kobject的“类型” ——本质上，它描述的是包括kobject的容器的类型。kobj_type数据结构包括三个字段：release方法(当kobject被释放时执行)，指向sysfs操作表的sysfs_ops指针以及sysfs文件系统的缺省属性链表。</p>
<p>​    kref字段是一个k_ref类型的结构，它仅包括一个refcount字段。顾名思义，这个字段就是kobject的引用计数器，但它也可以作为kobject容器的引用计数器。kobject_get()和kobject_put()函数分别用于增加和减少引用计数器的值；如果该计数器的值等于0，就会释放kobject使用的资源，并且执行kobject的类型描述符kobj_type对象的release 方法。该方法用于释放容器本身，通常只有在动态地分配kobject容器时才定义该方法。通过kset数据结构可将kobjects组织成一棵层次树。</p>
<p>​    kset是同类型kobject结构的一个集合体——也就是说，相关的kobject包含在同类型的容器中。kset数据结构的字段如表13-3所示。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**
 * struct kset - a set of kobjects of a specific type, belonging to a specific subsystem.
 *
 * A kset defines a group of kobjects.  They can be individually
 * different "types" but overall these kobjects all want to be grouped
 * together and operated on in the same manner.  ksets are used to
 * define the attribute callbacks and other common events that happen to
 * a kobject.
 *
 * list: the list of all kobjects for this kset
 * list_lock: a lock for iterating over the kobjects
 * kobj: the embedded kobject for this kset (recursion, isn't it fun...)
 * uevent_ops: the set of uevent operations for this kset.  These are
 * called whenever a kobject has something happen to it so that the kset
 * can add new environment variables, or filter out the uevents if so
 * desired.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">kset</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> list<span class="token punctuation">;</span><span class="token comment">//该kset上的kobject链表</span>
    <span class="token class-name">spinlock_t</span> list_lock<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">kobject</span> kobj<span class="token punctuation">;</span><span class="token comment">//内嵌的kobject</span>
    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">kset_uevent_ops</span> <span class="token operator">*</span>uevent_ops<span class="token punctuation">;</span><span class="token comment">//该kset的uevent操作函数集。当任何Kobject需要上报uevent时，都要调用它所从属的kset的uevent_ops，添加环境变量，或者过滤event（kset可以决定哪些event可以上报）。因此，如果一个kobject不属于任何kset时，是不允许发送uevent的。</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    kobj字段是嵌入在kset数据结构中的kobject；而位于kset中的kobject，其parent字段指向这个内嵌的kobject结构。因此，一个kset就是kobject集合体，但是它依赖于层次树中用于引用计数和连接的更高层kobject。这种设计编码效率很高，并可获得最大的灵活性。例如，分别用于增加和减少kset引用计数器值的kset_get()函数和kset_put()函数，只需简单地调用内嵌的kobject结构中的kobject_get()函数和kobject_put()函数；因为kset的引用计数器只不过是内嵌在kset中的类型为kobject 的kobj的引用计数器。而且，由于有了内嵌的kobject结构，kset数据结构可以嵌入到“容器”对象中，非常类似于嵌入的kobject数据结构。最后，kset可以作为其他kset的一个成员：它足以将内嵌的kobject插入到更高层次的kset中。还存在所谓subsystem的kset集合。一个subsystem可以包括不同类型的kset，用包含两个字段的subsystem数据结构来描述：</p>
<ul>
<li>kset：内嵌的kset结构，用于存放subsystem中的kset。</li>
<li>rwsem：读写信号量，保护递归地包含于subsystem中的所有kset和kobject。</li>
</ul>
<p>subsystem数据结构甚至也可以嵌入到一个更大的“容器”对象中；因此，容器的引用计数器也是内嵌subsystem的引用计数器——也就是嵌入在subsystem中的kset所嵌的kobject的引用计数器。subsys_get()和subsys_put()函数分别用于增加和减少这个引用计数器的值。</p>
<p>图13-3显示了设备驱动程序模型层次的一个例子。bus子系统包括一个pci子系统，pci 子系统又依次包含驱动程序的一个kset。这个kset包含一个串口kobject(具有唯一new-id属性的串口对应的设备驱动器程序)。<br><img src=".\image-20240503140839231.png" alt="image-20240503140839231"></p>
<h3 id="注册kobject、kset和subsystem"><a href="#注册kobject、kset和subsystem" class="headerlink" title="注册kobject、kset和subsystem"></a>注册kobject、kset和subsystem</h3><p>一般来说，如果想让kobject、kset或subsystem出现在sysfs子树中，就必须首先注册它们。与kobject对应的目录总是出现在其父kobject的目录中。例如，位于同一个kset中的kobject的目录出现在kset本身的目录中。因此，sysfs子树的结构就描述了各种已注册的kobject之间以及各种容器对象之间的层次关系。</p>
<p>通常，sysfs文件系统的上层目录肯定是已注册的subsystem。kobject_register()函数用于初始化kobject，并且将其相应的目录增加到sysfs文件系统中。在调用此函数之前，调用程序应该先设置kobject结构中的kset字段，使它指向其父kset(如果有的话)。kobject_unregister()函数则将kobject的目录从sysfs文件系统中移走。为了更易于内核开发者进行开发，Linux也提供了kset_register()和kset_unregister()函数，以及subsystem_register()subsystem_unregister()函数，但本质上它们是围绕kobject_register()和kobject_unregister()的封装函数。</p>
<p>如前所述，许多kobject目录都包括称作属性(attribute)的普通文件。sysfs_create_file()函数接收kobject的地址和属性描述符作为它的参数，并在合适的目录中创建特殊文件。sysfs文件系统中所描述的对象间的其他关系可以通过符号链接的方式来建立：sysfs_create_link()函数为目录中与其他kobject相关联的特定kobject创建一个符号链接。</p>
<h3 id="设备驱动程序模型的组件"><a href="#设备驱动程序模型的组件" class="headerlink" title="设备驱动程序模型的组件"></a>设备驱动程序模型的组件</h3><p>设备驱动程序模型建立在几个基本数据结构之上，这些结构描述了总线、设备、设备驱动器等等。让我们来考察一下它们。</p>
<h4 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h4><p>设备驱动程序模型中的每个设备是由一个device对象来描述的，其字段如表13-4所示。</p>
<ul>
<li>device 结构体 - 设备驱动模型中的基础结构体之一</li>
<li>parent:    设备所依附的“父设备”。</li>
<li>大多数情况下，这样的父设备是某种总线或主控制器。</li>
<li>如果该成员变量的值为 NULL 表示当前设备是一个最“顶端”设备，</li>
<li>通常这样的设备都不是你想得到的那个。</li>
<li>p:        该成员变量是一个指向设备结构体中驱动内核部分的私有数据的指针。</li>
<li>更详细的信息可以阅读 device_private 结构体的注释。</li>
<li>kobj:    kobj是最“顶层”的抽象类，所有其它的类都继承自它。</li>
<li>init_name:    设备结构体所对应的设备的名称。</li>
<li>type:    设备结构体所对应的设备的类型。</li>
<li>该成员变量用于标识设备类型，并存储着该类型设备特有的信息。</li>
<li>mutex:    用于同步驱动中的函数调用的互斥锁。</li>
<li>bus:    设备所挂接的总线的类型。</li>
<li>driver:    该成员变量指向开辟当前设备结构体空间的设备驱动。</li>
<li>platform_data: 该成员变量用于保存和设备硬件相关的平台数据。</li>
<li>示例：对于自定义电路板上的设备来说，典型的情况譬如嵌入式设备</li>
<li>以及一些基于 SOC 的硬件，Linux 系统通常会使用 platform_data 指针指向</li>
<li>与电路板硬件相关的结构体，这些结构体中的成员描述了它们对应的设备硬件资源</li>
<li>以及电路板的电路连接情况。这些被描述的内容可以包括芯片的哪些端口可用，与</li>
<li>上一代芯片相比有什么改动，哪个 GPIO 引脚有额外的功能等等。</li>
<li>这个成员变量的实现使得 BSP 的工作量减小了许多，</li>
<li>同时也减少了我们为兼容不同的电路板而写的 #ifdefs 语句的数量。</li>
<li>driver_data: 指向驱动特定信息的私有指针。</li>
<li>power:    用于设备的电源管理。</li>
<li>更详细的信息可以阅读 Documentation/power/devices.txt 文档。</li>
<li>pm_domain:    为设备提供当系统被挂起、</li>
<li>休眠、唤醒和电源状态切换时的回调函数，</li>
<li>以及子系统级别和驱动级别的回调函数。</li>
<li>pins:    用于设备引脚管理。</li>
<li>更详细的信息可以阅读 Documentation/pinctrl.txt 文档。</li>
<li>msi_list:    主机 MSI 描述符。</li>
<li>msi_domain: 设备结构体所使用的 MSI 域。</li>
<li>numa_node:    与设备结构体最邻近的 NUMA 节点。</li>
<li>dma_mask:    DMA掩码（前提是当前设备可进行 DMA 操作）。</li>
<li>coherent_dma_mask: 作用和 dma_mask 类似，用于一致性 DMA 地址映射。因为并不是所有</li>
<li>硬件都支持在 64 位地址下开辟连续的内存空间。</li>
<li>dma_pfn_offset: DMA区域范围在内存中的地址偏移量。</li>
<li>dma_parms:    一个低权限级别的驱动会通过这个成员变量告知 IOMMU 代码关于</li>
<li>段操作限制相关的规则。</li>
<li>dma_pools:    指向 DMA池 的指针（前提是当前设备可进行 DMA 操作）。</li>
<li>dma_mem:    一致性 DMA 的可读写区域。</li>
<li>cma_area:    DMA区域中的连续内存空间。</li>
<li>archdata:    芯片架构相关的内容。</li>
<li>of_node:    设备所在设备树的节点。</li>
<li>fwnode:    平台固件对应的设备树节点。</li>
<li>devt:    用于在 sysfs 中创建设备文件。</li>
<li>id:        设备实例（ID 编号）。</li>
<li>devres_lock: 用于保护设备上的资源访问的自旋锁。</li>
<li>devres_head: 设备上的资源列表。</li>
<li>knode_class: 用于将当前设备加入到类列表的节点。</li>
<li>class:    设备所属的类。</li>
<li>groups:    设备的属性集合（可选）。</li>
<li>release:    当设备的引用计数减少为 0 时，使用该成员变量所指向的析构函数</li>
<li>释放当前设备结构体。这个成员变量的值应该由当前设备的创建者进行</li>
<li>设置（比如成功找到设备的总线驱动）。</li>
<li>iommu_group: 设备所属的 IOMMU 集合。</li>
<li>offline_disabled: 如果这个成员变量的值被置 1，则设备将处于永远在线状态。</li>
<li>offline:    如果总线类型所辖的 offline() 函数被成功调用，则该成员变量的值将被置 1。</li>
</ul>
<p>device对象全部收集在devices_subsys子系统中，该子系统对应的目录为/sys/devices 。设备是按照层次关系组织的：一个设备是某个“孩子”的“父亲”，其条件为子设备离开父设备无法正常工作。例如，在基于PCI总线的计算机上，位于PCI总线和USB总线之间的桥就是连接在USB总线上的所有设备的父设备。device对象的parent字段是指向其父设备描述符的指针，children字段是子设备链表的首部，而node字段存放指向children链表中相邻元素的指针。device对象中内嵌的kobject间的亲子关系也反映了设备的层次关系；因此，/sys/devices下的目录结构与硬件设备的物理组织是匹配的。</p>
<p>每个设备驱动程序都保持一个device对象链表，其中链接了所有可被管理的设备；device对象的driver_list字段存放指向相邻对象的指针，而driver字段指向设备驱动程序的描述符。此外，对于任何总线类型来说，都有一个链表存放连接到该类型总线上的所有设备；device对象的bus_list字段存放指向相邻对象的指针，而bus字段指向总线类型描述符。</p>
<p>引用计数器记录device对象的使用情况，它包含在kobject类型的kobj结构中，通过调用get_device()和put_device()函数分别增加和减少该计数器的值。</p>
<p>device_register()函数的功能是往设备驱动程序模型中插入一个新的device对象，并自动地在/sys/devices目录下为其创建一个新的目录。相反地，device_unregister()函数的功能是从设备驱动程序模型中移走一个设备。通常，device对象被静态地嵌入到一个更大的描述符中。例如，PCI设备是由数据结构pci_dev描述；该数据结构的dev字段就是一个device对象，而其他字段则是PCI总线所特有的。在PCI内核层上，当注册或注销设备时就会分别执行device_register()函数和device_unregister()函数。</p>
<h3 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h3><p>设备驱动程序模型中的每个驱动程序都可由device_driver对象描述，其各字段如表13-5所示。</p>
<ul>
<li>name 设备驱动程序的名称</li>
<li>bus     指向总线描述符的指针，总线连接所支持的设备  </li>
<li>unload_sem 禁止卸载设备驱动程序的信号量，当引用计数器的值为0时释放该信号量  </li>
<li>kobj  内嵌的kobject结构</li>
<li>devices   驱动程序支持的所有设备组成的链表的首部</li>
<li>owner   标识实现设备驱动程序的模块，如果有的话</li>
<li>probe     探测设备的方法（检验设备驱动程序是否 可以控制该设备）</li>
<li>remove  移走设备时所调用的方法  </li>
<li>shutdown 设备断电（关闭）时所调用的方法  </li>
<li>suspend  设备置于低功率状态时所调用的方法  </li>
<li>resume  设备恢复正常状态时所调用的方法</li>
</ul>
<p>​    device_driver对象包括四个方法，它们用于处理热插拔、即插即用和电源管理。当总线设备驱动程序发现一个可能由它处理的设备时就会调用probe方法；相应的函数将会探测该硬件，从而对该设备进行更进一步的检查。当移走一个可热插拔的设备时驱动程序会调用remove方法；而驱动程序本身被卸载时，它所处理的每个设备也会调用remove方法。当内核必须改变设备的供电状态时，设备会调用shutdown、suspend和resume三个方法。</p>
<p>​    内嵌在描述符中的kobject类型的kobj所包含的引用计数器用于记录device_driver对象的使用情况。通过调用get_driver()函数和put_driver()函数可分别增加和减少该计数器的值。driver_register()函数的功能是往设备驱动程序模型中插入一个新的device_driver 对象，并自动地在sysfs文件系统下为其创建一个新的目录。相反，driver_unregister()函数的功能则是从设备驱动程序模型中移走一个设备驱动对象。通常，device_driver对象静态地被嵌入到一个更大的描述符中。例如，PCI设备驱动程序是由数据结构pci_driver描述的；该数据结构的driver字段是一个device_driver 对象，而其他字段则是PCI总线所特有的。</p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>内核所支持的每一种总线类型都由一个bus_type对象描述，其各字段如表13-6所示。</p>
<ul>
<li>name总线类型的名称 </li>
<li>subsys与总线类型相关的 kobject 子系统</li>
<li>drivers 驱动程序的kobject 集合 </li>
<li>devices  设备的kobject集合</li>
<li>bus_attrs 指向对象的指针，该对象包含总线属 性和用于导出此属性到 </li>
<li>sysfs 文件系统的方法 </li>
<li>dev_attrs 指向对象的指针，该对象包含设备属 性和用于导出此属性到 sysfs 文件系 统的方法 </li>
<li>drv_ attrs 指问对象的指针，该对象包含设备驱动程序属性和用于导出此属性到 sysfs文件系统的方法 </li>
<li>match  检验给定的设备驱动程序是否支持特定设备的方法</li>
<li>hotplug  注册设备时调用的方法</li>
<li>suspend  保存硬件设备的上下文状态并改变设备供电状态的方法</li>
<li>resume     改变供电状态和恢复硬件设备上下文的方法   </li>
</ul>
<p>​    每个bus_type类型的对象都包含一个内嵌的子系统；存放于bus_subsys变量中的子系统把嵌入在bus_type对象中的所有子系统都集合在一起。bus_subsys子系统与目录/sys/bus是对应的；因此，例如，有一个/sys/bus/pci目录，它与PCI总线类型相对应。每种总线的子系统通常包括两个kset，它们是drivers和devices(分别对应于bus_type 对象中的drivers和devices字段)。</p>
<p>​    名为drivers的kset包含描述符device_driver，它描述与该总线类型相关的所有设备驱动程序，而名为devices的kset包含描述符device，它描述给定总线类型上连接的所有设备。因为设备的kobject目录已经出现在/sys/devices下的sysfs文件系统中，所以每种总线子系统的devices目录存放了指向/sys/devices下目录的符号链接。bus_for_each_drv()和bus_for_each_dev()函数分别用于循环扫描drivers和devices 链表中的所有元素。当内核检查一个给定的设备否可以由给定的驱动程序处理时，就会执行match方法。对于连接设备的总线而言，即使其上每个设备的标识符都拥有一个特定的格式，实现match方法的函数通常也很简单，因为它只需要在所支持标识符的驱动程序表中搜索设备的描述符。在设备驱动程序模型中注册某个设备时会执行hotplug方法；实现函数应该通过环境变量把总线的具体信息传递给用户态程序，以通告一个新的可用设备。最后，当特定类型总线上的设备必须改变其供电状态时，就会执行suspend和resume方法。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>每个类是由一个class对象描述的。所有的类对象都属于与/sys/class目录相对应的class_subsys子系统。此外，每个类对象还包括一个内嵌的子系统；因此，例如有一个/sys/class/input目录，它就与设备驱动程序模型的input类相对应。每个类对象包括一个class_device描述符链表，其中每个描述符描述了一个属于该类的单独逻辑设备。class_device结构中包含一个dev字段，它指向一个设备描述符，因此一个逻辑设备总是对应于设备驱动程序模型中的一个给定的设备。然而，可以存在多个class_device描述符对应同一个设备。事实上，一个硬件设备可能包括几个不同的子设备，每个子设备都需要一个不同的用户态接口。</p>
<p>例如，声卡就是一个硬件设备，它通常包括一个DSP(digital singnal processor，数字信号处理器)、一个混音器、一个游戏端口接口等等；每个子设备需要一个属于自己的用户态接口，因此sysfs文件系统中都有与它们相对应的目录。同一类中的设备驱动程序可以对用户态应用程序提供相同的功能；</p>
<p>例如，声卡上的所有设备驱动程序都提供一个可以向DSP中写入声音样本的方法。设备驱动程序模型中的类本质上是要提供一个标准的方法，从而为向用户态应用程序导出逻辑设备的接口。每个class_device描述符中内嵌一个kobject，这是一个名为dev 的属性(特殊文件)。该属性存放设备文件的主设备号和次设备号，通过它们可以访问相应的逻辑设备。</p>
<h3 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h3><p>正如在第一章中所提到的那样，类Unix操作系统都是基于文件概念的，文件是由字节序列而构成的信息载体。根据这一点，可以把I/O设备当作设备文件(device file)这种所谓的特殊文件来处理；因此，与磁盘上的普通文件进行交互所用的同一系统调用可直接用于I/O设备。</p>
<p>例如，用同一write()系统调用既可以向普通文件中写入数据，也可以通过向/dev/lp0设备文件中写入数据从而把数据发往打印机。根据设备驱动程序的基本特性，设备文件可以分为两种：块和字符。这两种硬件设备之间的差异并不容易划分，但我们至少可以假定以下的差异：</p>
<ol>
<li>块设备的数据可以被随机访问，而且从人类用户的观点看，传送任何数据块所需的时间都是较少且大致相同的。块设备的典型例子是硬盘、软盘、CD-ROM驱动器及DVD播放器。</li>
<li>字符设备的数据或者不可以被随机访问(考虑声卡这样的例子)，或者可以被随机访问，但是访问随机数据所需的时间很大程度上依赖于数据在设备内的位置(考虑磁带驱动器这样的例子)。</li>
</ol>
<p>网卡是这种模式的一种明显的例外，因为网卡是不直接与设备文件相对应的硬件设备。自从Unix操作系统早期版本以来，设备文件就一直在使用。设备文件是存放在文件系统中的实际文件。然而，它的索引节点并不包含指向磁盘上数据块(文件的数据)的指针，因为它们是空的。相反，索引节点必须包含硬件设备的一个标识符，它对应字符或块设备文件。传统上，设备标识符由设备文件的类型(字符或块)和一对参数组成。第一个参数称为主设备号(major number)，它标识了设备的类型。通常，具有相同主设备号和类型的所有设备文件共享相同的文件操作集合，因为它们是由同一个设备驱动程序处理的。第二个参数称为次设备号(minor number)，它标识了主设备号相同的设备组中的一个特定设备。例如，由相同的磁盘控制器管理的一组磁盘具有相同的主设备号和不同的次设备号。</p>
<p>mknod()系统调用用来创建设备文件。其参数有设备文件名、设备类型、主设备号及次设备号。设备文件通常包含在/dev目录中。表13-7显示了一些设备文件的属性。注意字符设备和块设备有独立的编号，因此，块设备(3, 0)不同于字符设备(3, 0)。<br><img src=".\image-20240503141902182.png" alt="image-20240503141902182"><br>设备文件通常与硬件设备(如硬盘/dev/hda)，或硬件设备的某一物理或逻辑分区(如磁盘分区/dev/hda2)相对应。但在某些情况下，设备文件不会和任何实际的硬件对应，而是表示一个虚拟的逻辑设备。例如，/dev/null就是一个和“黑洞”对应的设备文件，所有写入这个文件的数据都被简单地丢弃，因此，该文件看起来总为空。<br>就内核所关心的内容而言，设备文件名是无关紧要的。如果你建立了一个名为/mp/disk 的设备文件，类型为“块”，主设备号是3，次设备号是0，那么这个设备文件就和表13-7 中的/dev)hda等价。另一方面，对某些应用程序来说，设备文件名可能就很有意义。例如，通信程序可能假设第一个串口和/dev/ttyS0设备文件对应。但是，通常可以把大部分应用程序设定为随意地与指定的设备文件进行交互。</p>
<h3 id="设备文件的用户态处理"><a href="#设备文件的用户态处理" class="headerlink" title="设备文件的用户态处理"></a>设备文件的用户态处理</h3><p>传统的Unix系统中(以及Linux的早期版本中)，设备文件的主设备号和次设备号都是8位长。因此，最多只能有65536个块设备文件和65536个字符设备文件。你可能认为这些已经足够了，但遗憾的是它们并不够用。真正的问题是设备文件被分配一次且永远保存在/dev目录中；因此，系统中的每个逻辑设备都应该有一个与其相对应的、明确定义了设备号的设备文件。Documentation/devices.txt文件存放了官方注册的已分配设备号和/dev目录节点；include /linux/major.h文件也可能包含设备的主设备号对应的宏。<br>不幸的是，如今各种不同的硬件设备数量惊人，几乎分配了所有的设备号。官方注册的设备号对于一般的Linux系统还能胜任；然而，它却不能很好地适用于大规模的系统。此外，高端系统可能使用数百或数千的同类型磁盘，因而8位的次设备号是远远不够的。<br>例如，注册表为16个SCSI磁盘保留了设备号，而每个SCS[磁盘拥有15个分区；如果一个高端系统拥有多于16个的SCSI磁盘，那么必须改变原先主设备号和次设备号的标准分配——这是一个非常繁琐的工作，它需要改变内核源代码并且使得系统难以维护。</p>
<p>​    为了解决上述问题，Linux 2.6已经增加了设备号的编码大小：<strong>目前主设备号的编码为12位，次设备号的编码为20位。通常把这两个参数合并成一个32位的dev_t变量MAJOR宏和MINOR宏可以从dev_t中分别提取主设备号和次设备号</strong>，而MKDEV宏可以把主设备号和次设备号合并成一个dev_t值。为了实现向后兼容，内核仍然可以正确地处理设备号编码为16位的老式设备文件。官方注册表不能静态地分配这些附加的可用设备号，只有在处理设备号的特殊要求时才允许使用。事实上，对分配设备号和创建设备文件来说，如今更倾向的做法是高度动态地处理设备文件。</p>
<h3 id="动态分配设备号"><a href="#动态分配设备号" class="headerlink" title="动态分配设备号"></a>动态分配设备号</h3><p>​    每个设备驱动程序在注册阶段都会指定它将要处理的设备号范围。然而，驱动程序可以只指定设备号的分配范围，无需指定精确的值：在这种情形下，内核会分配一个合适的设备号范围给驱动程序。</p>
<p>​    因此，新的硬件设备驱动程序不再需要从官方注册表中分配的一个设备号；它们可以仅仅使用当前系统中空闲的设备号。然而，在这种情形下，就不能永久性地创建设备文件；它只在设备驱动程序初始化一个主设备号和次设备号时才创建。因此，这就需要有一个标准的方法将每个驱动程序所使用的设备号输出到用户态应用程序中。</p>
<h3 id="动态创建设备文件"><a href="#动态创建设备文件" class="headerlink" title="动态创建设备文件"></a>动态创建设备文件</h3><p>​    Linux内核可以动态地创建设备文件：它无需把每一个可能想到的硬件设备的设备文件都填充到/dev目录下，因为设备文件可以按照需要来创建。</p>
<p>​    由于设备驱动程序模型的存在，Linux 2.6内核提供了一个非常简单的方法来处理这个问题。系统中必须安装一组称为udev工具集的用户态程序。当系统启动时，/dev目录是清空的，这时udev程序将扫描/sys/class子目录来寻找dev文件。对每一个这样的文件(主设备号和次设备号的组合表示一个内核所支持的逻辑设备文件)，udev程序都会在/dev目录下为它创建一个相应的设备文件。</p>
<p>​    udev程序也会根据配置文件为其分配一个文件名并创建一个符号链接，该方法类似于Unix设备文件的传统命名模式。最后，/dev目录里只存放了系统中内核所支持的所有设备的设备文件，而没有任何其他的文件。</p>
<p>通常在系统初始化后才创建设备文件。它要么发生在加载设备驱动程序(系统尚未支持该设备)所在的模块时，要么发生在一个热拔插的设备(如USB外围设备)加入系统中时。</p>
<p>​    udev工具集可以自动地创建相应的设备文件，因为设备驱动程序模型支持设备的热插拔。当发现一个新的设备时，内核会产生一个新的进程来执行用户态shell脚本文件/sbin/hotplug，并将新设备上的有用信息作为环境变量传递给shell脚本。用户态脚本文件读取配置文件信息并关注完成新设备初始化所必需的任何操作。如果安装了udev工具集，脚本文件也会在/dev目录下创建适当的设备文件。可以通过写/proc/sys/kernel/hotplug文件改变在发生热插拔事件时所调用的用户态程序的路径名</p>
<h3 id="设备文件的VFS处理"><a href="#设备文件的VFS处理" class="headerlink" title="设备文件的VFS处理"></a>设备文件的VFS处理</h3><p>虽然设备文件也在系统的目录树中，但是它们和普通文件以及目录文件有根本的不同。当进程访问普通文件时，它会通过文件系统访问磁盘分区中的一些数据块；而在进程访问设备文件时，它只要驱动硬件设备就可以了。</p>
<p>例如，进程可以访问一个设备文件以从连接到计算机的温度计读取房间的温度。为应用程序隐藏设备文件与普通文件之间的差异正是VFS的责任。为了做到这点，VFS在设备文件打开时改变其缺省文件操作；因此，可以把设备文件的每个系统调用都转换成与设备相关的函数的调用，而不是对主文件系统相应函数的调用。与设备相关的函数对硬件设备进行操作以完成进程所请求的操作。让我们假定进程在设备文件(块或字符类型)上执行open()系统调用。从本质上说，相应的服务例程解析到设备文件的路径名，并建立相应的索引节点对象、目录项对象和文件对象。通过适当的文件系统函数(通常为ext2_read_inode()或ext3_read_inode()；)读取磁盘上的相应索引节点来对索引节点对象进行初始化。</p>
<p>当这个函数确定磁盘索引节点与设备文件对应时，则调用init_special_inode()，该函数把索引节点对象的i_rdev字段初始化为设备文件的主设备号和次设备号，而把索引节点对象的i_fop字段设置为def_blk_fops或者def_chr_fops文件操作表的地址(根据设备文件的类型)。因此，open()系统调用的服务例程也调用dentry_open()函数，后者分配一个新的文件对象并把其f_op字段设置为i_fop中存放的地址，即再一次指向def_blk_fops或def_chr_fops的地址。正是这两个表的引入，才使得在设备文件上所发出的任何系统调用都将激活设备驱动程序的函数而不是基本文件系统的函数。</p>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>设备驱动程序是内核例程的集合，它使得硬件设备响应控制设备的编程接口，而该接口是一组规范的VFS函数集(open，read，lseek，ioctl等等)。这些函数的实际实现由设备驱动程序全权负责。由于每个设备都有一个唯一的I/O控制器，因此就有唯一的命令和唯一的状态信息，所以大部分IO设备都有自己的驱动程序。设备驱动程序的种类有很多。它们在对用户态应用程序提供支持的级别上有很大的不同，也对来自硬件设备的数据采集有不同的缓冲策略。这些选择极大地影响了设备驱动程序的内部结构，我们将在“直接内存访问(DMA)”和“字符设备的缓冲策略”两节进行讨论。设备驱动程序并不仅仅由实现设备文件操作的函数组成。在使用设备驱动程序之前，有几个活动是肯定要发生的。我们将在下面几节考察它们。</p>
<h3 id="注册设备驱动程序"><a href="#注册设备驱动程序" class="headerlink" title="注册设备驱动程序"></a>注册设备驱动程序</h3><p>我们知道在设备文件上发出的每个系统调用都由内核转化为对相应设备驱动程序的对应函数的调用。为了完成这个操作，设备驱动程序必须注册自己。换句话说，注册一个设备驱动程序意味着分配一个新的device_driver描述符，将其插入到设备驱动程序模型的数据结构中，并把它与对应的设备文件(可能是多个设备文件)连接起来。如果设备文件对应的驱动程序以前没有注册，则对该设备文件的访问会返回错误码-ENODEV。如果设备驱动程序被静态地编译进内核，则它的注册在内核初始化阶段进行。相反，如果驱动程序是作为一个内核模块来编译的，则它的注册在模块装入时进行。在后一种情况下，设备驱动程序也可以在模块卸载时注销自己。</p>
<p>例如，我们考虑一个通用的PCI设备。为了能正确地对其进行处理，其设备驱动程序必须分配一个pci_driver类型的描述符，PCI内核层使用该描述符来处理设备。初始化描述符的一些字段后，设备驱动程序就会调用pci_register_driver()函数。事实上，pci_driver描述符包括一个内嵌的device_driver描述符；pci_register_driver()函数仅仅初始化内嵌的驱动程序描述符中的字段，然后调用driver_register()函数把驱动程序插入设备驱动程序模型的数据结构中。</p>
<p>注册设备驱动程序时，内核会寻找可能由该驱动程序处理但还尚未获得支持的硬件设备。为了做到这点，内核主要依靠相关的总线类型描述符bus_type的match方法，以及device_driver对象的probe方法。如果探测到可被驱动程序处理的硬件设备，内核会分配一个设备对象，然后调用device_register()函数把设备插入设备驱动程序模型中。</p>
<h3 id="初始化设备驱动程序"><a href="#初始化设备驱动程序" class="headerlink" title="初始化设备驱动程序"></a>初始化设备驱动程序</h3><p>对设备驱动程序进行注册和初始化是两件不同的事。设备驱动程序应当尽快被注册，以便用户态应用程序能通过相应的设备文件使用它。相反，设备驱动程序在最后可能的时刻才被初始化。事实上，初始化驱动程序意味着分配宝贵的系统资源，这些资源因此就对其他驱动程序不可用了。我们已经在第四章“I/O中断处理”一节看到一个例子：把IRQ分配给设备通常是自动进行的，这正好发生在使用设备之前，因为多个设备可能共享同一条IRQ线。其他可以在最后时刻被分配的资源是用于DMA传送缓冲区的页框和DMA通道本身(用于像软盘驱动器那样的老式非PCI设备)。</p>
<p>为了确保资源在需要时能够获得，在获得后不再被请求，设备驱动程序通常采用下列模式：</p>
<ol>
<li>引用计数器记录当前访问设备文件的进程数。在设备文件的open方法中计数器被增加，在release方法中被减少。</li>
<li>open方法在增加引用计数器的值之前先检查它。如果计数器为0，则设备驱动程序必须分配资源并激活硬件设备上的中断和DMA。</li>
<li>release方法在减少使用计数器的值之后检查它。如果计数器为0，说明已经没有进程使用这个硬件设备。<br>如果是这样，该方法将禁止I/O控制器上的中断和DMA，然后释放所分配的资源。</li>
</ol>
<h3 id="监控I-O操作"><a href="#监控I-O操作" class="headerlink" title="监控I/O操作"></a>监控I/O操作</h3><p>I/O操作的持续时间通常是不可预知的。这可能和机械装置的情况有关(对于要传送的数据块来说是磁头的当前位置)，和实际的随机事件有关(数据包什么时候到达网卡)，还和人为因素有关(用户在键盘上按下一个键或者发现打印机夹纸了)。在任何情况下，启动I/O操作的设备驱动程序都必须依靠一种监控技术在I/O操作终止或超时时发出信号。</p>
<p>在终止操作的情况下，设备驱动程序读取I/O接口状态寄存器的内容来确定I/O操作是否成功执行。在超时的情况下，驱动程序知道一定出了问题，因为完成操作所允许的最大时间间隔已经用完，但什么也没做。<strong>监控I/O操作结束的两种可用技术分别称为轮询模式(polling mode)和中断模式(interrupt mode)。</strong></p>
<h3 id="轮询模式"><a href="#轮询模式" class="headerlink" title="轮询模式"></a>轮询模式</h3><p>​    CPU依照这种技术重复检查(轮询)设备的状态寄存器，直到寄存器的值表明I/O操作已经完成为止。我们已经在第五章的“自旋锁”一节中提到一种基于轮询的技术：当处理器试图获得一个繁忙的自旋锁时，它就重复地查询变量的值，直到该值变成0为止。但是，应用到I/O操作中的轮询技术更加巧妙，这是因为驱动程序还必须记住检查可能的超时。下面是轮询的一个简单例子：</p>
<pre class="line-numbers language-none"><code class="language-none">for (;;)&#123;
	if(read_status(device)&amp; DEVICE_END_OPERATION) break;
	if(--count &#x3D;&#x3D; 0&#125;break;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    在进入循环之前，count变量已被初始化，每次循环都对count的值减1，因此就可以使用这个变量实现一种粗略的超时机制。另外，更精确的超时机制可以通过这样的方法实现：在每次循环时读取节拍计数器jiffies的值，并将它与开始等待循环之前读取的原值进行比较。</p>
<p>​    如果完成I/O操作需要的时间相对较多，比如说毫秒级，那么这种模式就变得低效，因为CPU花费宝贵的机器周期去等待I/O操作的完成。在这种情况下，在每次轮询操作之后，可以通过把schedule()的调用插入到循环内部来自愿放弃CPU。</p>
<h3 id="中断模式"><a href="#中断模式" class="headerlink" title="中断模式"></a>中断模式</h3><p>​    如果I/O控制器能够通过IRQ线发出I/O操作结束的信号，那么中断模式才能被使用。我们现在通过一个简单的例子说明中断模式如何工作。假定我们想实现一个简单的输入字符设备的驱动程序。当用户在相应的设备文件上发出read()系统调用时，一条输入命令被发往设备的控制寄存器。在一个不可预知的长时间间隔后，设备把一个字节的数据放进输入寄存器。设备驱动程序然后将这个字节作为read()系统调用的结果返回。这是一个用中断模式实现驱动程序的典型例子。实质上，驱动程序包含两个函数：</p>
<ol>
<li>实现文件对象read方法的foo_read()函数。</li>
<li>处理中断的foo_interrupt()函数。只要用户读设备文件，foo_read()函数就被触发:</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">ssize_t foo_read(struct file *filp,char *buf,size_t count, loff_t *ppos)
&#123;
	foo_dev_t* foo_dev &#x3D;filp-&gt;private_data;
	if(dowm_interruptible(&amp;foo_dev-&gt;sem)
		return -ERESTARTSYS;
	foo_dev-&gt;intr &#x3D; 0;
	outb(DEV_FOO_READ, DEV_F0O_CONTROL_PORT);
	wait_event_interruptible(foo_dev-&gt;wait, (foo_dev-&gt;intr &#x3D;&#x3D; 1));
	if(put_user(foo_dev-&gt;data, buf))
		return -EFAULT;
	up(&amp;foo_dev-&gt;sem);
	return 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    设备驱动程序依赖类型为foo_dev_t的自定义描述符；它包含信号量sem(保护硬件设备免受并发访问)、等待队列wait、标志intr(当设备发出一个中断时设置)及单个字节缓冲区data(由中断处理程序写入且由read方法读取)。</p>
<p>​    一般而言，所有使用中断的I/O驱动程序都依赖中断处理程序及read和write方法均访问的数据结构。foo_dev_t描述符的地址通常存放在设备文件的文件对象的private_data字段中或一个全局变量中。foo_read()函数的主要操作如下：</p>
<ol>
<li>获取foo_dev-&gt;sem信号量，因此确保没有其他进程访问该设备。</li>
<li>清intr标志。</li>
<li>对I/O设备发出读命令。</li>
<li>执行wait_event_interruptible以挂起进程，直到intr标志变为1。一定时间后，我们的设备发出中断信号以通知I/O操作已经完成，数据已经放在适当的DEV_FOO_DATA_PORT数据端口。中断处理程序置intr标志并唤醒进程。当调度程序决定重新执行这个进程时，foo_read()的第二部分被执行，步骤如下：</li>
<li>把准备在foo_dev-&gt;data变量中的字符拷贝到用户地址空间。</li>
<li>释放foo_dev-&gt;sem信号量后终止。</li>
</ol>
<p>为了简单起见，我们没有包含任何超时控制。一般来说，超时控制是通过静态或动态定时器实现的；定时器必须设置为启动I/O操作后正确的时间，并在操作结束时删除。让我们来看一下foo_interrupt()函数的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">void foo_interrupt(int irq, void *dev_id, struct pt_regs *regs)
&#123;
	foo-&gt;data &#x3D; inb(DEV_FOO_DATA_PORT);
	foo-&gt;intr &#x3D; 1;
	wake_up_interruptible(&amp;foo-&gt;wait);
	return l;	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>中断处理程序从设备的输入寄存器中读字符，并把它存放在foo全局变量指向的驱动程序描述符foo_dev_t的data字段中。然后设置intr标志，并调用wake_up_interruptible()函数唤醒在foo-&gt;wait等待队列上阻塞的进程。注意，三个参数中没有一个被中断处理程序使用，这是相当普遍的情况。</p>
<h3 id="访问I-O共享存储器"><a href="#访问I-O共享存储器" class="headerlink" title="访问I/O共享存储器"></a>访问I/O共享存储器</h3><p>根据设备和总线的类型，PC体系结构里的I/O共享存储器可以被映射到不同的物理地址范围。主要有：</p>
<pre class="line-numbers language-none"><code class="language-none">对于连接到ISA总线上的大多数设备
	I&#x2F;O共享存储器通常被映射到0xa0000~0xfffff的16位物理地址范围；这就在640 KB和1MB之间留出了一段空间，就是我们在第二章的“物理内存布局”一节中所介绍的那个“空洞”。
对于连接到PCl总线上的设备
	I&#x2F;O共享存储器被映射到接近4 GB的32位物理地址范围。这种类型的设备更加容易处理。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>几年以前，Intel引入了图形加速端口(AGP)标准，该标准是适合于高性能图形卡的PCI 的增强。这种卡除了有自己的I/O共享存储器外，还能够通过图形地址再映像表(GART)这个特殊的硬件电路直接对主板的RAM部分进行寻址。GART电路能够使AGP卡比老式的PCI卡具有更高的数据传输速率。然而，从内核的观点看，物理存储器位于何处根本没有什么关系，GART映射的存储器与其他种类I/O共享存储器的处理方式完全一样。设备驱动程序如何访问一个I/O共享存储器单元？让我们从比较简单的PC体系结构开始入手，之后再扩展到其他体系结构。</p>
<p>不要忘了内核程序作用于线性地址，因此I/O共享存储器单元必须表示成大于PAGE_OFFSET的地址。在后面的讨论中，我们假设PAGE_OFFSET等于0xc0000000，也就是说，内核线性地址是在第4个GB。设备驱动程序必须把I/O共享存储器单元的物理地址转换成内核空间的线性地址。在PC 体系结构中，这可以简单地把32位的物理地址和0xc0000000常量进行或运算得到。</p>
<p>例如，假设内核需要把物理地址为0x000b0fe4的I/O单元的值存放在t1中，把物理地址为0xfc000000的I/O单元的值存放在t2中。你可能认为使用下面的表达式就可以完成这项工作：</p>
<pre class="line-numbers language-none"><code class="language-none">t1&#x3D;*((unsigned char *)(0xc00b0fe4));
t2 &#x3D;*((unsigned char *)(0xfc000000));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​    在初始化阶段，内核已经把可用的RAM物理地址映射到线性地址空间第4个GB的开始部分。因此，分页单元把出现在第一个语句中的线性地址0xc00b0fe4映射回到原来的I/O物理地址0x000b0fe4，这正好落在从640KB到IMB的这段“ISA洞”中。这工作得很好。</p>
<p>​    但是，对于第二个语句来说，这里有一个问题，因为其I/O物理地址超过了系统RAM的最大物理地址。因此，线性地址0xfc000000就不需要与物理地址0xfc000000相对应。在这种情况下，为了在内核页表中包括对这个I/O物理地址进行映射的线性地址，必须对页表进行修改。这可以通过调用ioremap()或ioremap_nocache()函数来实现。第一个函数与vmalloc()函数类似，都调用get_vm_area()为所请求的I/O共享存储器区的大小建立一个新的vm_struct描述符。然后，这两个函数适当地更新常规内核页表中的对应页表项。ioremap_nocache()不同于ioremap()，因为前者在适当地引用再映射的线性地址时还使硬件高速缓存内容失效。因此，第二个语句的正确形式应该为：</p>
<pre class="line-numbers language-none"><code class="language-none">io_mem &#x3D; ioremap(0xfb000000, 0×200000);&#x2F;&#x2F; 起始物理地址，尺寸。返回值区域起始线性地址
t2 &#x3D;*((unsigned char *)(io_mem +0x100000));&#x2F;&#x2F; 目标处线性地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一条语句建立一个2MB的新的线性地址区间，该区间映射了从0xfb000000开始的物理地址；第二条语句读取地址为0xfc000000的内存单元。设备驱动程序以后要取消这种映射，就必须使用iounmap()函数。在其他体系结构(PC之外的体系结构)上，简单地间接引用物理内存单元的线性地址并不能正确访问I/O共享存储器。因此，Linux定义了下列依赖于体系结构的函数，当访问I/O共享存储器时来使用它们：</p>
<pre class="line-numbers language-none"><code class="language-none">readb()，readw()，readl()
	分别从一个I&#x2F;O共享存储器单元读取1、2或者4个字节
writeb()，writew()，writel()
	分别向一个I&#x2F;O共享存储器单元写入1、2或者4个字节
memcpy_fromio()，memcpy_toio()
	把一个数据块从一个I&#x2F;O共享存储器单元拷贝到动态内存中，另一个函数正好相反
memset_io()
	用一个固定的值填充一个I&#x2F;O共享存储器区域<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因此，对于0xfc000000I/O单元的访问推荐使用这样的方法：</p>
<pre class="line-numbers language-none"><code class="language-none">io_mem &#x3D; ioremap(0xfb000000, 0×200000);
t2 &#x3D; readb(io_mem + 0x100000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>正是由于这些函数，就可以隐藏不同平台访问I/O共享存储器所用方法的差异。</p>
<h3 id="直接内存访问-DMA"><a href="#直接内存访问-DMA" class="headerlink" title="直接内存访问(DMA)"></a>直接内存访问(DMA)</h3><p>在最初的PC体系结构中，CPU是系统中唯一的总线主控器，也就是说，为了提取和存储RAM存储单元的值，CPU是唯一可以驱动地址/数据总线的硬件设备。随着更多诸如PCI这样的现代总线体系结构的出现，如果提供合适的电路，每一个外围设备都可以充当总线主控器。因此，现在所有的PC都包含一个辅助的DMA电路，它可以用来控制在RAM和I/O设备之间数据的传送。DMA一旦被CPU激活，就可以自行传送数据；当数据传送完成之后，DMA发出一个中断请求。当CPU和DMA同时访问同一内存单元时，所产生的冲突由一个名为内存仲裁器的硬件电路来解决。使用DMA最多的是磁盘驱动器和其他需要一次传送大量字节的设备。因为DMA的设置时间相当长，所以在传送数量很少的数据时直接使用CPU效率更高。</p>
<p>原来的ISA总线所使用的DMA电路非常复杂，难于对其进行编程，并且限于物理内存的低16MB。PCI和SCSI总线所使用的最新DMA电路依靠总线中的专用硬件电路，这就简化了设备驱动程序开发人员的开发工作。</p>
<h3 id="同步DMA和异步DMA"><a href="#同步DMA和异步DMA" class="headerlink" title="同步DMA和异步DMA"></a>同步DMA和异步DMA</h3><p>设备驱动程序可以采用两种方式使用DMA，分别是同步DMA和异步DMA。第一种方式，数据的传送是由进程触发的；而第二种方式，数据的传送是由硬件设备触发的。</p>
<p>采用同步DMA传送的例子如声卡，它可以播放电影音乐。用户态应用程序将声音数据(称为样本)写入一个与声卡的数字信号处理器(DSP)相对应的设备文件中。声卡的驱动程序把写入的这些样本收集在内核缓冲区中。同时，驱动程序命令声卡把这些样本从内核缓冲区拷贝到预先定时的DSP中。当声卡完成数据传送时，就会引发一个中断，然后驱动程序会检查内核缓冲区是否还有要播放的样本；如果有，驱动程序就再启动一次DMA数据传送。</p>
<p>采用异步DMA传送的例子如网卡，它可以从一个LAN中接收帧(数据包)。网卡将接收到的帧存储在自己的I/O共享存储器中，然后引发一个中断。其驱动程序确认该中断后，命令网卡将接收到的帧从I/O共享存储器拷贝到内核缓冲区。当数据传送完成后，网卡会引发新的中断，然后驱动程序将这个新帧通知给上层内核层。</p>
<h3 id="DMA传送的辅助函数"><a href="#DMA传送的辅助函数" class="headerlink" title="DMA传送的辅助函数"></a>DMA传送的辅助函数</h3><p>当为使用DMA传送方式的设备设计驱动程序时，开发者编写的代码应该与体系结构和总线(就DMA传送方式来说)二者都不相关。由于内核提供了丰富的DMA辅助函数，因而现在上述目标是可以实现的。这些辅助函数隐藏了不同硬件体系结构的DMA实现机制的差异。</p>
<p>这是DMA辅助函数的两个子集：<br>老式的子集为PCI设备提供了与体系结构无关的函数；新的子集则保证了与总线和体系结构两者都无关。我们现在将介绍其中的一些函数，同时指出DMA的一些硬件特性。</p>
<h3 id="总线地址"><a href="#总线地址" class="headerlink" title="总线地址"></a>总线地址</h3><p>DMA的每次数据传送(至少)需要一个内存缓冲区，它包含硬件设备要读出或写入的数据。一般而言，启动一次数据传送前，设备驱动程序必须确保DMA电路可以直接访问RAM内存单元。到现在为止，我们已区分了三类存储器地址：逻辑地址、线性地址以及物理地址，前两个在CPU内部使用，最后一个是CPU从物理上驱动数据总线所用的存储器地址。但是，还有第四种存储器地址，称为总线地址(bus address)，它是除CPU之外的硬件设备驱动数据总线时所用的存储器地址。</p>
<p>从根本上说，内核为什么应该关心总线地址呢?<br>这是因为在DMA操作中，数据传送不需要CPU的参与；I/O设备和DMA电路直接驱动数据总线。因此，当内核开始DMA操作时，必须把所涉及的内存缓冲区总线地址或写入DMA适当的I/O端口，或写入I/O设备适当的I/O端口。</p>
<p>在80x86体系结构中，总线地址与物理地址是一致的。然而，其他的体系结构例如Sun 公司的SPARC和HP的Alpha都包括一个所谓的I/O存储器管理单元(IO-MMU)的硬件电路，它类似于微处理器的分页单元，将物理地址映射为总线地址。使用DMA的所有I/O驱动程序在启动一次数据传送前必须设置好IO-MMU。</p>
<p>不同的总线具有不同的总线地址大小。例如，ISA的总线地址是24位长，因此，在80x86 体系结构中，可以在物理内存的低16 MB中完成DMA传送——这就是为什么DMA 使用的内存缓冲区分配在ZONE_DMA内存区中(设置了GFP_DMA标志)。</p>
<p>原来的PCI标准定义了32位的总线地址；但是，一些PCI硬件设备最初是为ISA总线而设计的，因此它们仍然访问不了物理地址0x00ffffff以上的RAM内存单元。新的PCI-X标准采用64位的总线地址并允许DMA电路可以直接寻址更高的内存。</p>
<p>在Linux中，数据类型dma_addr_t代表一个通用的总线地址。在80x86体系结构中，dma_addr_t对应一个32位长的整数，若内核支持PAE ，在这种情形下，dma_addr_t代表一个64位的整数。<br>pci_set_dma_mask()和dma_set_mask()两个辅助函数用于检查总线是否可以接收给定大小的总线地址(mask)，如果可以，则通知总线层给定的外围设备将使用该大小的总线地址。</p>
<h3 id="高速缓存的一致性"><a href="#高速缓存的一致性" class="headerlink" title="高速缓存的一致性"></a>高速缓存的一致性</h3><p>系统体系结构没有必要在硬件级为硬件高速缓存与DMA电路之间提供一个一致性协议，因此，执行DMA映射操作时，DMA辅助函数必须考虑硬件高速缓存。为了弄清楚这是为什么，假设设备驱动程序把一些数据填充到内存缓冲区中，然后立刻命令硬件设备利用DMA传送方式读取该数据。如果DMA访问这些物理RAM内存单元，而相应的硬件高速缓存行的内容还没有写入RAM中，那么硬件设备所读取的值就是内存缓冲区中的旧值。</p>
<p>设备驱动程序开发人员可以采用两种方法来处理DMA缓冲区，他们分别使用两类不同的辅助函数来完成。用Linux的术语来说，开发人员在下面两种DMA映射类型中进行选择：</p>
<ul>
<li>一致性DMA映射:   使用这种映射方式时，内核必须保证内存与硬件设备间高速缓存一致性不是什么问题；也就是说CPU在RAM内存单元上所执行的每个写操作对硬件设备而言都是立即可见的，反过来也一样。这种映射方式也称为“同步的”或“一致的”。</li>
<li>流式DMA映射:   使用这种映射方式时，设备驱动程序必须了解高速缓存一致性问题，这可以使用适当的同步辅助函数来解决。这种映射方式也称为“异步的”或“非一致性的”。</li>
</ul>
<p>​    在80×86体系结构中使用DMA时，从不存在高速缓存一致性根本不是什么问题，因为硬件设备驱动程序本身会“窥探”所访问的硬件高速缓存。因此，80×86体系结构中为硬件设备所设计的驱动程序会从前述的两种DMA映射方式中选择一个：它们二者在本质上是等价的。另一方面，在诸如MIPS、SPARC以及PowerPC的一些模型等许多其他的体系结构中，硬件设备通常不窥探硬件高速缓存，因而就会产生高速缓存一致性问题。总的来说，为与体系结构无关的驱动程序选择一个合适的DMA映射方式是很重要的。</p>
<p>​    一般来说，如果CPU和DMA处理器以不可预知的方式去访问一个缓冲区，那么必须强制使用一致性DMA映射方式(例如，SCSI适配器的command数据结构的缓冲区)。其他情形下，流式DMA映射方式更可取，因为在一些体系结构中处理一致性DMA映射是很麻烦的，并且可能导致更低的系统性能。</p>
<h3 id="一致性DMA映射的辅助函数"><a href="#一致性DMA映射的辅助函数" class="headerlink" title="一致性DMA映射的辅助函数"></a>一致性DMA映射的辅助函数</h3><p>通常，设备驱动程序在初始化阶段会分配内存缓冲区并建立一致性DMA映射；在卸载时释放映射和缓冲区。为了分配内存缓冲区和建立一致性DMA映射，内核提供了依赖体系结构的pci_alloc_consistent()和dma_alloc_coherent()两个函数。它们均返回新缓冲区的线性地址和总线地址。在80x86体系结构中，它们返回新缓冲区的线性地址和物理地址。为了释放映射和缓冲区，内核提供了pci_free_consistent()和dma_free_coherent()两个函数。</p>
<h3 id="流式DMA映射的辅助函数"><a href="#流式DMA映射的辅助函数" class="headerlink" title="流式DMA映射的辅助函数"></a>流式DMA映射的辅助函数</h3><p>流式DMA映射的内存缓冲区通常在数据传送之前被映射，在传送之后被取消映射。也有可能在几次DMA传送过程中保持相同的映射，但是在这种情况下，设备驱动程序开发人员必须知道位于内存和外围设备之间的硬件高速缓存。</p>
<p>为了启动一次流式DMA数据传送，驱动程序必须首先利用分区页框分配器或通用内存分配器来动态地分配内存缓冲区。然后，驱动程序调用pci_map_single()函数或者dma_map_single()函数建立流式DMA映射，这两个函数接收缓冲区的线性地址作为其参数并返回相应的总线地址。为了释放该映射，驱动程序调用相应的pci_urmap_single()函数或dma_unmap_single()函数。</p>
<p>为了避免高速缓存一致性问题，驱动程序在开始从RAM到设备的DMA数据传送之前，如果有必要，应该调用pci_dma_sync_single_for_device()函数或dma_sync_single_for_device()函数刷新与DMA缓冲区对应的高速缓存行。同样地，从设备到RAM的一次DMA数据传送完成之前设备驱动程序是不可以访问内存缓冲区的：相反，如果有必要，在读缓冲区之前，驱动程序应该调用pci_dma_sync_single_for_cpu()函数或dma_sync_single_for_cpu()函数使相应的硬件高速缓存行无效。</p>
<p>在80x86体系结构中，上述函数几乎不做任何事情，因为硬件高速缓存和DMA之间的一致性是由硬件来维护的。即使是高端内存的缓冲区也可以用于DMA传送；开发人员使用pci_map_page()或dma_map_page()函数，给其传递的参数为缓冲区所在页的描述符地址和页中缓冲区的偏移地址。相应地，为了释放高端内存缓冲区的映射，开发人员使用pci_unmap_page()或dma_unmap_page()函数。</p>
<h3 id="内核支持的级别"><a href="#内核支持的级别" class="headerlink" title="内核支持的级别"></a>内核支持的级别</h3><p>Linux内核并不完全支持所有可能存在的I/O设备。一般来说，事实上有三种可能的方式支持硬件设备：</p>
<ul>
<li>根本不支持:应用程序使用适当的in和out汇编语言指令直接与设备的I/O端口进行交互。</li>
<li>最小支持:内核不识别硬件设备，但能识别它的I/O接口。用户程序把I/O接口视为能够读写字符流的顺序设备。</li>
<li>扩展支持:内核识别硬件设备，并处理I/O接口本身。事实上，这种设备可能就没有对应的设备文件。</li>
</ul>
<p>​    第一种方式与内核设备驱动程序毫无关系，最常见的例子是X Window系统对图形显示的传统处理方式。这种方法效率很高，尽管它限制了X服务器使用I/O设备产生的硬件中断。为了让X服务器访问所请求的I/O端口，这种方法还需要做一些其他努力。正如第三章的“任务状态段”一节中所介绍的那样，iopl()和ioperm()系统调用给进程授权访问I/O端口。只有具有root权限的用户才可以调用这两个系统调用。但是通过设置可执行文件的setuid标志，普通用户也可以使用这些程序。新近的Linux版本支持几种广泛使用的图形卡。/dev/fb设备文件为图形卡的帧缓冲区提供了一种抽象，并允许应用软件无需知道图形接口的I/O端口的任何事情就可以访问它。此外，内核提供了直接绘制基本架构(Direct Rendering Infrastructure，DRI)，DRI允许应用软件充分挖掘3D加速图形卡的硬件特性。不管怎样，传统的“自己动手配置”X Window系统服务器还依然被广泛采用。</p>
<p>​    最小支持方法是用来处理连接到通用I/O接口上的外部硬件设备的。内核通过提供设备文件(由此而提供一个设备驱动程序)来处理I/O接口；应用程序通过读写设备文件来处理外部硬件设备。最小支持优于扩展支持，因为它保持内核尽可能小。但是，在基于PC的通用I/O接口之中，只有串口和并口的处理使用了这种方法。因此，诸如X服务器之类的应用程序可以直接控制串口鼠标，而串口调制解调器通常都需要一个诸如Minicom、Seyon或PPP(点对点协议)守护进程之类的通信程序。最小支持的应用范围是有限的，因为当外部设备必须频繁地与内核内部数据结构进行交互时不能使用这种方法。例如，考虑一个连到通用I/O接口上的可移动硬盘。应用程序不能和所有的内核数据结构进程交互，也不能与识别磁盘所需要的函数和装载文件系统所需要的函数进行交互，因此，这种情况下就必须使用扩展支持。一般情况下，直接连接到I/O总线上的任何硬件设备(如内置硬盘)都要根据扩展支持方法进行处理：内核必须为每个这样的设备提供一个设备驱动程序。通用串行总线(USB)、笔记本电脑上的PCMCIA接口或者SCSI接口——简而言之，除串口和并口之外的所有通用I/O接口之上连接的外部设备都需要扩展支持。</p>
<p>​    值得注意的是，与标准文件相关的系统调用，如open()、read()和write()，并不总让应用程序完全控制底层硬件设备。事实上，VFS的“最小公分母(lowest-common-denominator)”方法没有包含某些设备所需的特殊命令，或不让应用程序检查设备是否处于某一特殊的内部状态。已引入的ioctl()系统调用可以满足这样的需要。这个系统调用除了设备文件的文件描述符和另一个表示请求的32位参数之外，还可以接收任意多个额外的参数。例如，特殊的ioctl()请求可以用来获得CD-ROM的音量或者弹出CD-ROM介质。应用程序可以用这类ioctl()请求提供一个CD播放器的用户接口。</p>
<h3 id="字符设备驱动程序"><a href="#字符设备驱动程序" class="headerlink" title="字符设备驱动程序"></a>字符设备驱动程序</h3><p>处理字符设备相对比较容易，因为通常并不需要复杂的缓冲策略，也不涉及磁盘高速缓存。当然，字符设备在它们的需求方面有所不同：有些必须实现复杂的通信协议以驱动硬件设备，而有些仅仅需要从硬件设备的一对I/O端口读几个值。例如，多端口串口卡设备(一个硬件设备提供多个串口)的驱动程序比总线鼠标的设备驱动程序要复杂得多。另一方面，块设备驱动程序本身就比字符设备驱动程序复杂得多。</p>
<p>事实上，应用程序可以反复地要求读或写同一个数据块。此外，访问这些设备通常是很慢的。这些特性对磁盘驱动程序的结构产生了深刻的影响。然而，就如我们将在下一章看到的，内核提供了诸如页面高速缓存和块I/O子系统这些高级组件去处理驱动程序。在本章剩下的部分中我们把注意力集中于字符设备驱动程序。字符设备驱动程序是由一个cdev结构描述的：</p>
<ul>
<li>kobj 内嵌的kobject  </li>
<li>owner 指向实现驱动程序模块（如果有的话）的指  </li>
<li>ops 指向设备驱动程序文件操作表的指针</li>
<li>list 与字符设备文件对应的索引节点链表的头</li>
<li>dev  给设备驱动程序所分配的初始主设备号和次设备号  </li>
<li>count 给设备驱动程序所分配的设备号范围的大小   </li>
<li>list字段是双向循环链表的首部，该链表用于收集相同字符设备驱动程序所对应的字符设备文件的索引节点。</li>
</ul>
<p>​    可能很多设备文件具有相同的设备号，并对应于相同的字符设备。此外，一个设备驱动程序对应的设备号可以是一个范围，而不仅仅是一个号；设备号位于同一范围内的所有设备文件均由同一个字符设备驱动程序处理。设备号范围的大小存放在count字段中。</p>
<p>cdev_alloc()函数的功能是动态地分配cdev描述符，并初始化内嵌的kobject数据结构，因此在引用计数器的值变为0时会自动释放该描述符。cdev_add()函数的功能是在设备驱动程序模型中注册一个cdev描述符。它初始化cdev 描述符中的dev和count字段，然后调用kobj_map()函数。kobj_map()则依次建立设备驱动程序模型的数据结构，把设备号范围复制到设备驱动程序的描述符中。</p>
<p>设备驱动程序模型为字符设备定义了一个kobject映射域，该映射域由一个kobj_map类型的描述符描述，并由全局变量cdev_map引用。kobj_map描述符包括一个散列表，它有255个表项，并由0～255范围的主设备号进行索引。散列表存放probe类型的对象，每个对象都拥有一个已注册的主设备号和次设备号，其中各字段如表13-9所示。</p>
<ul>
<li>next dev：散列冲突链表中的下一个元素设备号范围的初始设备号（主、次设备号）  </li>
<li>range 设备号范围的大小  </li>
<li>owner 如果有的话，指向实现设备驱动程序模块的指钅 </li>
<li>get  探测谁拥有这个设备号范围  </li>
<li>lock  增加设备号范围内拥有者的引用计数器  </li>
<li>data 设备号范围内拥有者的私有数据 </li>
</ul>
<p>​    调用kobj_map()函数时，把指定的设备号范围加入到散列表中。相应的probe对象的data字段指向设备驱动程序的cdev描述符。执行get和lock方法时把data字段的值传递给它们。在这种情况下，get方法通过一个简捷函数实现，其返回值为cdev描述符中内嵌的kobject数据结构的地址；相反，lock方法本质上用于增加内嵌的kobject数据结构的引用计数器的值。</p>
<p>​    kobj_lookup()函数接收kobject映射域和设备号作为输入参数；它搜索散列表，如果找到，则返回该设备号所在范围的拥有者的kobject的地址。当这个函数应用到字符设备的映射域时，就返回设备驱动程序描述符cdev中所嵌入的kobject的地址。</p>
<h3 id="分配设备号"><a href="#分配设备号" class="headerlink" title="分配设备号"></a>分配设备号</h3><p>为了记录目前已经分配了哪些字符设备号，内核使用散列表chrdevs，表的大小不超过设备号范围。两个不同的设备号范围可能共享同一个主设备号，但是范围不能重叠，因此它们的次设备号应该完全不同。chrdevs包含255个表项，由于散列函数屏蔽了主设备号的高四位——因此，主设备号的个数少于255个，它们被散列到不同的表项中。</p>
<p>每个表项指向冲突链表的第一个元素，而该链表是按主、次设备号的递增顺序进行排序的。冲突链表中的每个元素是一个char_device_struct结构，其各字段如表13-10所示。</p>
<ul>
<li>next major：指向散列冲突链表中下一个元素的指针  设备号范围内的主设备号  </li>
<li>baseminor：设备号范围内的初始次设备号</li>
<li>minorct  设备号范围的大小  </li>
<li>name 处理设备号范围内的设备驱动程序的名称</li>
<li>fops  没有使用</li>
<li>cdev  指向字符设备驱动程序描述符的指针    </li>
</ul>
<p>​    本质上可以采用两种方法为字符设备驱动程序分配一个范围内的设备号。所有新的设备驱动程序使用第一种方法，该方法使用register_chrdev_region()函数和alloc_chrdev_region()函数为驱动程序分配任意范围内的设备号。例如，为了获得从dev(类型为dev_t)开始的大小为size的一个设备号范围：</p>
<pre class="line-numbers language-none"><code class="language-none">register_chrdev_region(dev, size, &quot;foo&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上述函数并不执行cdev_add()，因此设备驱动程序在所要求的设备号范围被成功分配时必须执行cdev_add()函数。第二种方法使用register_chrdev()函数，它分配一个固定的设备号范围，该范围包含唯一一个主设备号以及0~255的次设备号。在这种情形下，设备驱动程序不必调用cdev_add()函数。</p>
<h3 id="register-chrdev-region-函数和alloc-chrdev-region-函数"><a href="#register-chrdev-region-函数和alloc-chrdev-region-函数" class="headerlink" title="register_chrdev_region()函数和alloc_chrdev_region()函数"></a>register_chrdev_region()函数和alloc_chrdev_region()函数</h3><p>register_chrdev_region()函数接收三个参数：初始的设备号(主设备号和次设备号)、请求的设备号范围大小(与次设备号的大小一样)以及这个范围内的设备号对应的设备驱动程序的名称。该函数检查请求的设备号范围是否跨越一些次设备号，如果是，则确定其主设备号以及覆盖整个区间的相应设备号范围；然后，在每个相应设备号范围上调用__register_chrdev_region()函数。</p>
<p>alloc_chrdev_region()函数与register_chrdev_region()相似，但它可以动态地分配一个主设备号；因此，该函数接收的参数为设备号范围内的初始次设备号、范围的大小以及设备驱动程序的名称。结束时它也调用<strong>register_chrdev_region()函数。</strong>register_chrdev_region()函数执行以下步骤：</p>
<ol>
<li>分配一个新的char_device_struct结构，并用0填充。</li>
<li>如果设备号范围内的主设备号为0，那么设备驱动程序请求动态分配一个主设备号。函数从散列表的末尾表项开始继续向后寻找一个与尚未使用的主设备号对应的空冲突链表(NULL指针)。若没有找到空表项，则返回一个错误码。</li>
<li>初始化char_device_struct结构中的初始设备号、范围大小以及设备驱动程序名称。</li>
<li>执行散列函数计算与主设备号对应的散列表索引。</li>
<li>遍历冲突链表，为新的char_device_struct结构寻找正确的位置。同时，如果找到与请求的设备号范围重叠的一个范围，则返回一个错误码。</li>
<li>将新的char_device_struct描述符插入冲突链表中。</li>
<li>返回新的char_device_struct描述符的地址。</li>
</ol>
<h3 id="register-chrdev-函数"><a href="#register-chrdev-函数" class="headerlink" title="register_chrdev()函数"></a>register_chrdev()函数</h3><p>驱动程序使用register_chrdev()函数时需要一个老式的设备号范围：一个单独的主设备号和0~255的次设备号范围。该函数接收的参数为：请求的主设备号major(如果是0则动态分配)、设备驱动程序的名称name和一个指针fops(它指向设备号范围内的特定字符设备文件的文件操作表)。该函数执行下列操作：</p>
<ol>
<li>调用__register_chrdev_region()函数分配请求的设备号范围。如果返回一个错误码(不能分配该范围)，函数将终止运行。</li>
<li>为设备驱动程序分配一个新的cdev结构。</li>
<li>初始化cdev结构：<br>a. 将内嵌的kobject类型设置为ktype_cdev_dynamic类型的描述符。<br>b. 将owner字段设置为fops-&gt;owner的内容。<br>c. 将ops字段设置为文件操作表的地址fops。<br>d. 将设备驱动程序的名称拷贝到内嵌的kobject结构里的name字段中。</li>
<li>调用cdev_add()函数(在前面解释过)。</li>
<li>将__register_chrdev_region()函数在第1步中返回的char_device_struct描述符的cdev字段设置为设备驱动程序的cdev描述符的地址。</li>
<li>返回分配的设备号范围的主设备号。</li>
</ol>
<h3 id="访问字符设备驱动程序"><a href="#访问字符设备驱动程序" class="headerlink" title="访问字符设备驱动程序"></a>访问字符设备驱动程序</h3><p>我们在“设备文件的VFS处理”一节中曾提到，由open()系统调用服务例程触发的dentry_open()函数定制字符设备文件的文件对象的f_op字段，以使它指向def_chr_fops表。这个表几乎为空；它仅仅定义了chrdev_open()函数作为设备文件的打开方法。这个方法由dentry_open()直接调用。chrdev_open()函数接收的参数为索引节点的地址inode、指向所打开文件对象的指针filp。本质上它执行以下操作：</p>
<ol>
<li>检查指向设备驱动程序的cdev描述符的指针inode-&gt;i_cdev。如果该字段不为空，则inode结构已经被访问：增加cdev描述符的引用计数器值并跳转到第6步。</li>
<li>调用kobj_lookup()函数搜索包括该设备号在内的范围。如果该范围不存在，则返回一个错误码；否则，函数计算与该范围相对应的cdev描述符的地址。</li>
<li>将inode对象的inode-&gt;i_cdev字段设置为cdev描述符的地址。</li>
<li>将inode-&gt;i_cindex字段设置为设备驱动程序的设备号范围内的设备号的相关索引(设备号范围内的第一个次设备号的索引值为0，第二个为1，依此类推)。</li>
<li>将inode对象加入到由cdev描述符的list字段所指向的链表中。</li>
<li>将filp-&gt;f_ops文件操作指针初始化为cdev描述符的ops字段的值。</li>
<li>如果定义了filp-&gt;f_ops-&gt;open方法，chrdev_open()函数就会执行该方法。若设备驱动程序处理一个以上的设备号，则chrdev_open()一般会再次设置file对象的文件操作，这样可以为所访问的设备文件安装合适的文件操作。</li>
<li>成功时返回0结束。</li>
</ol>
<h3 id="字符设备的缓冲策略"><a href="#字符设备的缓冲策略" class="headerlink" title="字符设备的缓冲策略"></a>字符设备的缓冲策略</h3><p>传统的类Unix操作系统把硬件设备划分为块设备和字符设备。但是，这种分类并不能说明整个事实。某些设备在一次单独的I/O操作中能够传送大量的数据，而有些设备则只能传送几个字符。</p>
<p>例如，PS/2鼠标驱动程序在每次读操作中获得几个字节——它们对应鼠标按钮的状态和屏幕上鼠标的指针。这种设备是最容易处理的。首先从设备的输入寄存器中一次读一个字符的输入数据，并存放在合适的内核数据结构中；然后，在空闲时把这个数据拷贝到进程的地址空间。同理，把输出数据首先从进程的地址空间拷贝到合适的内核数据结构中，然后，再一次一个字符地写到I/O设备的输出寄存器。显然，这种设备的I/O驱动程序没有使用DMA，因为CPU建立DMA I/O操作所花费的时间跟把数据移到I/O 端口所花费的时间差不多。</p>
<p>另一方面，内核也必须准备处理在每次I/O操作中产生大量字节的设备，这些设备或者是诸如声卡或网卡的顺序设备，或者是诸如各类磁盘(软盘、光盘、SCS1磁盘等)的随机访问设备。例如，假定你已经为自己的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=计算机配置&amp;spm=1001.2101.3001.7020">计算机配置</a>了声卡，以便能够录下来自麦克风的声音。声卡以固定的频率(比如说44.14kHz)对来自麦克风的电信号进行采样，并产生一个16位数的输入数据块的流。声卡驱动程序必须能处理所有可能情况下这种蜂拥而至的数据，即使当CPU暂时忙于运行某个其他进程也不例外。</p>
<p>这可以结合两种不同的技术做到：</p>
<ol>
<li>使用DMA方式传送数据块。</li>
<li>运用两个或多个元素的循环缓冲区，每个元素具有一个数据块的大小。<br>当一个中断(发送一个信号表明新的数据块已被读入)发生时，中断处理程序把指针移到循环缓冲区的下一个元素，以便将来的数据会存放在一个空元素中。相反，只要驱动程序把数据成功地拷贝到用户地址空间，就释放循环缓冲区中的元素，以便用它来保存从硬件设备传送来的新数据。循环缓冲区的作用是消除CPU负载的峰值；即使接收数据的用户态应用程序因为其他高优先级任务而慢下来，DMA也要能够继续填充循环缓冲区中的元素，因为中断处理程序代表当前运行的进程执行。</li>
</ol>
<p>当接收来自网卡的数据包时有类似的情况发生，只是在这种情况下，进入的数据流都是异步的。数据包被互相独立地接收，且两个连续的数据包之间到达的时间间隔是不可预测的。总而言之，顺序设备的缓冲区是容易处理的，因为同一缓冲区从不会被重用：音频应用程序不能要求麦克风重新传送同一数据块。</p>
<h1 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h1><h2 id="块设备的处理"><a href="#块设备的处理" class="headerlink" title="块设备的处理"></a>块设备的处理</h2><p>​    块设备驱动程序上的每个操作都涉及很多内核组件下面是内核对进程请求给予回应的一般步骤：<br><img src=".\image-20240503143200504.png" alt="image-20240503143200504"></p>
<ol>
<li>read()系统调用的服务例程调用一个适当的VFS函数，将文件描述符和文件内的偏移量传递给它。虚拟文件系统位于块设备处理体系结构的上层，它提供一个通用的文件模型，Linux支持的所有文件系统均采用该模型。</li>
<li>VFS函数确定所请求的数据是否已经存在，如果有必要的话，它决定如何执行read操作。有时候没有必要访问磁盘上的数据，因为内核将大多数最近从块设备读出或写入其中的数据保存在RAM中。</li>
<li>我们假设内核从块设备读数据，那么它就必须确定数据的物理位置。为了做到这点，内核依赖映射层(mapping layer)，主要执行下面两步：<ol>
<li>内核确定该文件所在文件系统的块大小，并根据文件块的大小计算所请求数据的长度。本质上，文件被看作拆分成许多块，因此内核确定请求数据所在的块号(文件开始位置的相对索引)。</li>
<li>接下来，映射层调用一个具体文件系统的函数，它访问文件的磁盘节点，然后根据逻辑块号确定所请求数据在磁盘上的位置。事实上，磁盘也被看作拆分成许多块，因此内核必须确定存放所请求数据的块对应的号(磁盘或分区开始位置的相对索引)。由于一个文件可能存储在磁盘上的不连续块中，因此存放在磁盘索引节点中的数据结构将每个文件块号映射为一个逻辑块号。</li>
</ol>
</li>
<li>现在内核可以对块设备发出读请求。内核利用通用块层(generic block Inyer)启动I/O操作来传送所请求的数据。一般而言，每个I/O操作只针对磁盘上一组连续的块。由于请求的数据不必位于相邻的块中，所以通用块层可能启动几次I/O操作。每次I/O操作是由一个“块I/O”(简称“bio”)结构描述，它收集底层组件需要的所有信息以满足所发出的请求。通用块层为所有的块设备提供了一个抽象视图，因而隐藏了硬件块设备间的差异性。几乎所有的块设备都是磁盘，所以通用块层也提供了一些通用数据结构来描述“磁盘”或“磁盘分区”。</li>
<li>通用块层下面的“I/O调度程序”根据预先定义的内核策略将待处理的I/O数据传送请求进行归类。调度程序的作用是把物理介质上相邻的数据请求聚集在一起。</li>
<li>最后，块设备驱动程序向磁盘控制器的硬件接口发送适当的命令，从而进行实际的数据传送。如你所见，块设备中的数据存储涉及了许多内核组件；每个组件采用不同长度的块来管理磁盘数据：<ol>
<li>硬件块设备控制器采用称为“扇区”的固定长度的块来传送数据。因此，I/O调度程序和块设备驱动程序必须管理数据扇区。</li>
<li>虚拟文件系统、映射层和文件系统将磁盘数据存放在称为“块”的逻辑单元中。</li>
<li>一个块对应文件系统中一个最小的磁盘存储单元。<br>我们很快会看到，块设备驱动程序应该能够处理数据的“段”：一个段就是一个内存页或内存页的一部分，它们包含磁盘上物理相邻的数据块。</li>
<li>磁盘高速缓存作用于磁盘数据的“页”上，每页正好装在一个页框中。通用块层将所有的上层和下层的组件组合在一起，因此它了解数据的扇区、块、段以及页。即使有许多不同的数据块，它们通常也是共享相同的物理RAM单元。</li>
</ol>
</li>
</ol>
<p>例如，图14-2显示了一个具有4096字节的页的构造。上层内核组件将页看成是由4个1024字节组成的块缓冲区。块设备驱动程序正在传送页中的后3个块，因此这3块被插入到涵盖了后3072 字节的段中。硬盘<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=控制器&amp;spm=1001.2101.3001.7020">控制器</a>将该段看成是由6个512字节的扇区组成。</p>
<p>本章我们介绍处理块设备的下层内核组件：通用块层、I/O调度程序以及块设备驱动程序，因此我们将<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=注意力&amp;spm=1001.2101.3001.7020">注意力</a>集中在扇区、块和段上。</p>
<p><img src=".\image-20240503143152202.png" alt="image-20240503143152202"></p>
<h3 id="扇区"><a href="#扇区" class="headerlink" title="扇区"></a>扇区</h3><p>​    为了达到可接受的性能，硬盘和类似的设备快速传送几个相邻字节的数据。块设备的每次数据传送操作都作用于一组称为扇区的相邻字节。在下面的讨论中，我们假定字节按相邻的方式记录在磁盘表面，这样一次搜索操作就可以访问到它们。尽管磁盘的物理构造很复杂，但是硬盘控制器接收到的命令将磁盘看成一大组扇区。在大部分磁盘设备中，扇区的大小是512字节，但是一些设备使用更大的扇区(1024和2048字节)。</p>
<p>​    注意，应该把扇区作为数据传送的基本单元；不允许传送少于一个扇区的数据，尽管大部分磁盘设备都可以同时传送几个相邻的扇区。在Linux中，扇区大小按惯例都设为512字节；如果一个块设备使用更大的扇区，那么相应的底层块设备驱动程序将做些必要的变换。因此，对存放在块设备中的一组数据是通过它们在磁盘上的位置来标识，即其首个512字节扇区的下标以及扇区的数目。扇区的下标存放在类型为sector_c的32位或64位的变量中。</p>
<h3 id="块"><a href="#块" class="headerlink" title="块"></a>块</h3><p>扇区是硬件设备传送数据的基本单位，而块是VFS和文件系统传送数据的基本单位。例如，内核访问一个文件的内容时，它必须首先从磁盘上读文件的磁盘索引节点所在的块。该块对应磁盘上一个或多个相邻的扇区，而VFS将其看成是一个单一的数据单元。在Linux中，块大小必须是2的幂，而且不能超过一个页框。此外，它必须是扇区大小的整数倍，因为每个块必须包含整数个扇区。因此，在80×86体系结构中，允许块的大小为512、1024、2048和4096字节。</p>
<p>块设备的块大小不是唯一的。创建一个磁盘文件系统时，管理员可以选择合适的块大小。因此，同一个磁盘上的几个分区可能使用不同的块大小。此外，对块设备文件的每次读或写操作是一种“原始”访问，因为它绕过了磁盘文件系统；内核通过使用最大的块(4096字节)执行该操作。每个块都需要自己的块缓冲区，它是内核用来存放块内容的RAM内存区。当内核从磁盘读出一个块时，就用从硬件设备中所获得的值来填充相应的块缓冲区；同样，当内核向磁盘中写入一个块时，就用相关块缓冲区的实际值来更新硬件设备上相应的一组相邻字节。块缓冲区的大小通常要与相应块的大小相匹配。</p>
<p>缓冲区首部是一个与每个缓冲区相关的buffer_head类型的描述符。它包含内核处理缓冲区需要了解的所有信息；因此，在对每个缓冲区进行操作之前，内核都要首先检查其缓冲区首部。我们将在第十五章中详细介绍缓冲区首部中的所有字段值；但是在本章中我们仅仅介绍其中的一些字段：b_page、b_data、b_blocknr和b_bdev。</p>
<p>b_page字段存放的是块缓冲区所在页框的页描述符地址。如果页框位于高端内存中，那么b_data字段存放页中块缓冲区的偏移量；否则，b_data存放块缓冲区本身的起始线性地址。<br>b_blocknr字段存放的是逻辑块号(例如磁盘分区中的块索引)。<br>最后，b_bdev 字段标识使用缓冲区首部的块设备。</p>
<h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>我们知道对磁盘的每个I/O操作就是在磁盘与一些RAM单元之间相互传送一些相邻扇区的内容。大多数情况下，磁盘控制器直接采用DMA方式进行数据传送。块设备驱动程序只要向磁盘控制器发送一些适当的命令就可以触发一次数据传送；一旦完成数据的传送，控制器就会发出一个中断通知块设备驱动程序。</p>
<p>DMA方式传送的是磁盘上相邻扇区的数据。这是一个物理约束：磁盘控制器允许DMA 传送不相邻的扇区数据，但是这种方式的传送速率很低，因为在磁盘表面上移动读/写磁头是相当慢的。老式的磁盘控制器仅仅支持“简单的”DMA传送方式：在这种传送方式中，磁盘必须与RAM中的连续内存单元相互传送数据。但是，新的磁盘控制器也支持所谓的分散-聚集(scatter-gather)DMA传送方式：此种方式中，磁盘可以与一些非连续的内存区相互传送数据。</p>
<p>启动一次分散-聚集DMA传送，块设备驱动程序需要向磁盘控制器发送：</p>
<ol>
<li>要传送的起始磁盘扇区号和总的扇区数</li>
<li>内存区的描述符链表，其中链表的每项包含一个地址和一个长度。磁盘控制器负责整个数据传送；例如，在读操作中控制器从相邻磁盘扇区中获得数据，然后将它们存放到不同的内存区中。为了使用分散-聚集DMA传送方式，块设备驱动程序必须能够处理称为段的数据存储单元。一个段就是一个内存页或内存页中的一部分，它们包含一些相邻磁盘扇区中的数据。因此，一次分散-聚集DMA操作可能同时传送几个段。注意，块设备驱动程序不需要知道块、块大小以及块缓冲区。因此，即使高层将段看成是由几个块缓冲区组成的页，块设备驱动程序也不用对此给予关注。正如我们所见，如果不同的段在RAM中相应的页框正好是连续的并且在磁盘上相应的数据块也是相邻的，那么通用块层可以合并它们。通过这种合并方式产生的更大的内存区就称为物理段。然而，在多种体系结构上还允许使用另一个合并方式：通过使用一个专门的总线电路[如IO-MMU；参见第十三章中的“直接内存访问(DMA)”一节]来处理总线地址与物理地址间的映射。</li>
</ol>
<p>通过这种合并方式产生的内存区称为硬件段。由于我们将注意力集中在80×86体系结构上，它在总线地址和物理地址之间不存在动态的映射，因此在本章剩余部分我们假定硬件段总是对应物理段。</p>
<h3 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h3><p>通用块层是一个内核组件，它处理来自系统中的所有块设备发出的请求。由于该层所提供的函数，内核可以容易地做到：</p>
<ol>
<li>将数据缓冲区放在高端内存——仅当CPU访问其数据时，才将页框映射为内核中的线性地址空间，并在数据访问完后取消映射。</li>
<li>通过一些附加的手段，实现一个所谓的“零-复制”模式，将磁盘数据直接存放在用户态地址空间而不是首先复制到内核内存区；事实上，内核为I/O数据传送使用的缓冲区所在的页框就映射在进程的用户态线性地址空间中。</li>
<li>管理逻辑卷，例如由LVM(逻辑卷管理器)和RAID(廉价磁盘冗余阵列)使用的逻辑卷：几个磁盘分区，即使位于不同的块设备中，也可以被看作是一个单一的分区。</li>
<li>发挥大部分新磁盘控制器的高级特性，例如大主板磁盘高速缓存、增强的DMA性能、I/O传送请求的相关调度等等。</li>
</ol>
<h3 id="bio结构"><a href="#bio结构" class="headerlink" title="bio结构"></a>bio结构</h3><p>通用块层的核心数据结构是一个称为bio的描述符，它描述了块设备的I/O操作。每个bio结构都包含一个磁盘存储区标识符(存储区中的起始扇区号和扇区数目)和一个或多个描述与I/O操作相关的内存区的段。bio由bio数据结构描述，其各字段如表14-1 所示。</p>
<ul>
<li>bi_sector：块1/0操作的第一个磁盘扇区</li>
<li>bi_next：  链接到请求队列中的下一个bio</li>
<li>bi_bdev ：指向块设备描述符的指针 </li>
<li>bi_flags ： bio 的状态标志</li>
<li>bi_rw 1/0操作标志</li>
<li>bi_vcnt： bio的 bio_vec数组中段的数目  </li>
<li>bi_idx ：bio 的 bio_vec数组中段的当前索引值</li>
<li>bi_phys_segments ：合并之后bio中物理段的数目  </li>
<li>bi_hw_segments 合并之后硬件段的数目</li>
<li>bi_size 需要传送的字节数</li>
<li>bi_hw_front_size      硬件段合并算法使用  </li>
<li>bi_hw_back_size  硬件段合并算法使用  </li>
<li>bi_max_vecs  bio的bio_vec数组中允许的最大段数  </li>
<li>bi_io_vec  指向 bio的 bio_vec数组中的段的指</li>
<li>bi_end_io bio的1/O操作结束时调用的方法</li>
<li>bi_cnt bio的引用计数器</li>
<li>bi_private  通用块层和块设备驱动程序的1/0完成方法使用的指针</li>
<li>bi_destructor  释放bio时调用的析构方法（通常是 bio_destructor（)方法）   </li>
</ul>
<p>​    bio中的每个段是由一个bio_vec数据结构描述的，其中各字段如表14-2所示。bio中的bi_io_vec字段指向bio_vec数据结构的第一个元素，bi_vcnt字段则存放了bio_vec数组中当前的元素个数。</p>
<ul>
<li>bv_page:指向页的页框中页描述符的指针</li>
<li>bv_len段的字节长度</li>
<li>bv_offset:页框中段数据的偏移量</li>
</ul>
<p>​    在块I/O操作期间bio描述符的内容一直保持更新。例如，如果块设备驱动程序在一次分散-聚集DMA操作中不能完成全部的数据传送，那么bio中的bi_idx字段会不断更新来指向待传送的第一个段。为了从索引bi_idx指向的当前段开始不断重复bio中的段，设备驱动程序可以执行宏bio_for_each_segment。当通用块层启动一次新的I/O操作时，调用bio_alloc()函数分配一个新的bio结构。</p>
<p>​    通常，bio结构是由slab分配器分配的，但是，当内存不足时，内核也会使用一个备用的bio小内存池。内核也为bio_vec结构分配内存池——毕竟，分配一个bio结构而不能分配其中的段描述符也是没有什么意义的。相应地，bio_put()函数减少bio中引用计数器(bi_cnt)的值，如果该值等于0，则释放bio结构以及相关的bio_vec结构。</p>
<h3 id="磁盘和磁盘分区的表示"><a href="#磁盘和磁盘分区的表示" class="headerlink" title="磁盘和磁盘分区的表示"></a>磁盘和磁盘分区的表示</h3><p>磁盘是一个由通用块层处理的逻辑块设备。通常一个磁盘对应一个硬件块设备，例如硬盘、软盘或光盘。但是，磁盘也可以是一个虚拟设备，它建立在几个物理磁盘分区之上或一些RAM专用页中的内存区上。在任何情形中，借助通用块层提供的服务，上层内核组件可以以同样的方式工作在所有的磁盘上。磁盘是由gendisk对象描述的，其中各字段如表14-3所示。</p>
<ul>
<li>major 磁盘主设备号  </li>
<li>first_minor  与磁盘关联的第一个次设备号</li>
<li>minors 与磁盘关联的次设备号范围</li>
<li>disk_name   磁盘的标准名称（通常是相应设备文件的规范名称 )</li>
<li>part  磁盘的分区描述符数组</li>
<li>fops  指向块设备操作表的指针</li>
<li>queue     指问磁盘请求队列的指针</li>
<li>private_data  块设备驱动程序的私有数据</li>
<li>capacity 磁盘内存区的大小（扇区数目）</li>
<li>flags     描述磁盘类型的标志（见下文）  </li>
<li><p>devfs_name   devfs特殊文件系统（现在已不赞成 使用）中的设备文件名称</p>
</li>
<li><p>number 不再使用 </p>
</li>
<li>driverfs_dev  指向磁盘的硬件设备的device对象 的指针</li>
<li>kobj    内嵌的kobject结构</li>
<li>random 该指针指向的这个数据结构记录磁盘 中断的定时，由内核内置的随机数发 生器使用</li>
<li>policy   如果磁盘是只读的，则置为1（写操  作禁止），否则为0  </li>
<li>sync_io  写入磁盘的扇区数计数器，仅为 RAID使用  </li>
<li>stamp  统计磁盘队列使用情况的时间戳</li>
<li>stamp_idl 同上</li>
<li>in_flight 正在进行的I/O操作数</li>
<li>dkstats 统计每个CPU使用磁盘的情况</li>
</ul>
<p>Aflags字段存放了关于磁盘的信息。其中最重要的标志是GENHD_FL_UP；如果设置它，那么磁盘将被初始化并可以使用。另一个相关的标志是GENHD_FL_REMOVABLE，如果是诸如软盘或光盘这样可移动的磁盘，那么就要设置该标志。gendisk对象的fops字段指向一个表block_device_operations，该表为块设备的主要操作存放了几个定制的方法(如表14-4所示)。</p>
<ul>
<li>open 打开块设备文件  </li>
<li>release关闭对块设备文件的最后一个引用</li>
<li>ioctl 在块设备文件上发出ioct1（）系统调用（使用大内核锁）</li>
<li>compat_ioctl  在块设备文件上发出ioct1（）系统调用（不使用大内核锁）  </li>
<li>media_changed 检查可移动介质是否已经变化（例如软盘） </li>
<li>revalidate_disk  检查块设备是否持有有效数据 </li>
</ul>
<p>​    通常硬盘被划分成几个逻辑分区。每个块设备文件要么代表整个磁盘，要么代表磁盘中的某一个分区。例如，一个主设备号为3、次设备号为0的设备文件/dev/hda代表的可能是一个主EIDE磁盘；该磁盘中的前两个分区分别由设备文件/dev/hdal和/dev/hda2 代表，它们的主设备号都是3，而次设备号分别为1和2。一般而言，磁盘中的分区是由连续的次设备号来区分的。如果将一个磁盘分成了几个分区，那么其分区表保存在hd_struct结构的数组中，该数组的地址存放在gendisk对象的part字段中。通过磁盘内分区的相对索引对该数组进行索引。<br>当内核发现系统中一个新的磁盘时(在启动阶段，或将一个可移动介质插入一个驱动器中时，或在运行期附加一个外置式磁盘时)，就调用alloc_disk()函数，该函数分配并初始化一个新的gendisk对象，如果新磁盘被分成了几个分区，那么alloc_disk()还会分配并初始化一个适当的hd_struct类型的数组。然后，内核调用add_disk()函数将新的gendisk对象插入到通用块层的数据结构中。</p>
<h3 id="提交请求"><a href="#提交请求" class="headerlink" title="提交请求"></a>提交请求</h3><p>我们介绍一下当向通用块层提交一个I/O操作请求时，内核所执行的步骤顺序。我们假设被请求的数据块在磁盘上是相邻的，并且内核已经知道了它们的物理位置。第一步是执行bio_alloc()函数分配一个新的bio描述符。然后，内核通过设置一些字段值来初始化bio描述符：</p>
<ol>
<li>将bi_sector设为数据的起始扇区号(如果块设备分成了几个分区，那么扇区号是相对于分区的起始位置的)。</li>
<li>将bi_size设为涵盖整个数据的扇区数目。</li>
<li>将bi_bdev设为块设备描述符的地址。</li>
<li>将bi_io_vec设为bio_vec结构数组的起始地址，数组中的每个元素描述了I/0操作中的一个段(内存缓存)；此外，将bi_vcnt设为bio中总的段数。</li>
<li>将bi_rw设为被请求操作的标志。其中最重要的标志指明数据传送的方向：READ (0)或WRITE(1)。</li>
<li>将bi_end_io设为当bio上的I/O操作完成时所执行的完成程序的地址。</li>
</ol>
<p>一旦bio描述符被进行了适当的初始化，内核就调用generic_make_request()函数，它是通用块层的主要入口点。该函数主要执行下列操作：</p>
<ol>
<li>检查bio-&gt;bi_sector没有超过块设备的扇区数。如果超过，则将bio-&gt;bi_flags设置为BIO_EOF标志，然后打印一条内核错误信息，调用bio_endio()函数，并终止。bio_endio()更新bio描述符中的bi_size和bi_sector值，然后调用bio的bi_end_io方法。bi_end_io函数的实现本质上依赖于触发I/O数据传送的内核组件；我们将在下面的章节中看到bi_end_io方法的一些例子。</li>
<li>获取与块设备相关的请求队列q；其地址存放在块设备描述符的bd_disk字段中，其中的每个元素由bio-&gt;bi_bdev指向。</li>
<li>调用block_wait_queue_running()函数检查当前正在使用的I/O调度程序是否可以被动态取代；若可以，则让当前进程睡眠直到启动一个新的I/O调度程序。</li>
<li>调用blk_partition_remap()函数检查块设备是否指的是一个磁盘分区(bio-&gt;bi_bdev不等于bio-&gt;bi_dev-&gt;bd_contains)。如果是，则从bio-&gt;bi_bdev获取分区的hd_struct描述符，从而执行下面的子操作：<br>a. 根据数据传送的方向，更新hd_struct描述符中的read_sectors和reads值，或write_sectors和writes值。<br>b. 调整bio-&gt;bi_sector值使得把相对于分区的起始扇区号转变为相对于整个磁盘的扇区号。<br>c. 将bio-&gt;bi_bdev设置为整个磁盘的块设备描述符(bio-&gt;bd_contains)。从现在开始，通用块层、I/O调度程序以及设备驱动程序将忘记磁盘分区的存在，直接作用于整个磁盘。</li>
<li>调用q-&gt;make_request_fn方法将bio请求插入请求队列q中。</li>
<li>返回。<br>在本章后面的“向I/O调度程序发出请求”一节中我们将讨论make_request_fn方法典型实现。</li>
</ol>
<h2 id="I-O调度程序"><a href="#I-O调度程序" class="headerlink" title="I/O调度程序"></a>I/O调度程序</h2><p>虽然块设备驱动程序一次可以传送一个单独的扇区，但是块I/O层并不会为磁盘上每个被访问的扇区都单独执行一次I/O操作；这会导致磁盘性能的下降，因为确定磁盘表面上扇区的物理位置是相当费时的。取而代之的是，只要可能，内核就试图把几个扇区合并在一起，并作为一个整体来处理，这样就减少了磁头的平均移动时间。当内核组件要读或写一些磁盘数据时，实际上创建一个块设备请求。从本质上说，请求描述的是所请求的扇区以及要对它执行的操作类型(读或写)。然而，并不是请求一发出，内核就满足它——I/O操作仅仅被调度，执行会向后推迟。这种人为的延迟是提高块设备性能的关键机制。</p>
<p>当请求传送一个新的数据块时，内核检查能否通过稍微扩展前一个一直处于等待状态的请求而满足新请求(也就是说，能否不用进一步的寻道操作就能满足新请求)。由于磁盘的访问大都是顺序的，因此这种简单机制就非常高效。延迟请求复杂化了块设备的处理。<br>例如，假设某个进程打开了一个普通文件，然后，文件系统的驱动程序就要从磁盘读取相应的索引节点。块设备驱动程序把这个请求加入一个队列，并把这个进程挂起，直到存放索引节点的块被传送为止。然而，块设备驱动程序本身不会被阻塞，因为试图访问同一磁盘的任何其他进程也可能被阻塞。为了防止块设备驱动程序被挂起，每个I/O操作都是异步处理的。</p>
<p>特别是块设备驱动程序是中断驱动的；通用块层调用I/O调度程序产生一个新的块设备请求或扩展一个已有的块设备请求，然后终止。随后激活的块设备驱动程序会调用一个所谓的策略例程(strategy routine)选择一个待处理的请求，并向磁盘控制器发出一条适当的命令来满足这个请求。</p>
<p>当I/O操作终止时，磁盘控制器就产生一个中断，如果需要，相应的中断处理程序就又调用策略例程去处理队列中的另一个请求。 每个块设备驱动程序都维持着自己的请求队列，它包含设备待处理的请求链表。如果磁盘控制器正在处理几个磁盘，那么通常每个物理块设备都有一个请求队列。在每个请求队列上单独执行I/O调度，这样可以提高磁盘的性能。</p>
<h3 id="请求队列描述符"><a href="#请求队列描述符" class="headerlink" title="请求队列描述符"></a>请求队列描述符</h3><p>​    请求队列是由一个大的数据结构request_queue表示的实质上，请求队列是一个双向链表，其元素就是请求描述符(也就是request数据结构)。请求队列描述符中的queue_head字段存放链表的头(第一个伪元素)，而请求描述符中queuelist字段的指针把任一请求链接到链表的前一个和后一个元素之间。<br>队列链表中元素的排序方式对每个块设备驱动程序是特定的；然而，I/O调度程序提供了几种预先确定好的元素排序方式，这将在后面的“I/O调度算法”一节中讨论。backing_dev_info字段是一个backing_dev_info类型的小对象，它存放了关于基本硬件块设备的I/O数据流量的信息。例如，它保存了关于预读以及关于请求队列拥塞状态的信息。</p>
<h3 id="请求描述符"><a href="#请求描述符" class="headerlink" title="请求描述符"></a>请求描述符</h3><p>每个块设备的待处理请求都是用一个请求描述符来表示的。每个请求包含一个或多个bio结构。最初，通用块层创建一个仅包含一个bio结构的请求。然后，I/O调度程序要么向初始的bio中增加一个新段，要么将另一个bio结构链接到请求中，从而“扩展”该请求。可能存在新数据与请求中已存在的数据物理相邻的情况。请求描述符的bio字段指向请求中的第一个bio结构，而biotail字段则指向最后一个bio结构。rq_for_each_bio宏执行一个循环，从而遍历请求中的所有bio结构。<br>请求描述符中的几个字段值可能是动态变化的。例如，一旦bio中引用的数据块全部传送完毕，bio字段立即更新从而指向请求链表中的下一个bio。在此期间，新的bio可能被加入到请求链表的尾部，所以biotail的值也可能改变。当磁盘数据块正在传送时，请求描述符的其它几个字段的值由I/O调度程序或设备驱动程序修改。</p>
<p>例如，nr_sectors存放整个请求还需传送的扇区数，current_nr_sectors 存放当前bio结构中还需传送的扇区数。flags中存放了很多标志，如表14-8中所示。到目前为止，最重要的一个标志是REQ_RW，它确定数据传送的方向。</p>
<pre class="line-numbers language-none"><code class="language-none">REQ_RW  数据传送的方向：READ（O）或WRITE（1）
REQ_FAILFAST  万一出错请求申明不再重试10操作
REQ_SOFTBARRIER  请求相当于I&#x2F;O调度程序的屏障
REQ_HARDBARRIER  请求相当于I&#x2F;O调度程序和设备驱动程序的屏障——应当在旧请求与新请求之间处理该请求
REQ_CMD  包含一个标准的读或写1&#x2F;0数据传送的请求
REQ_NOMERGE  不允许扩展或与其它请求合并的请求
REQSTARTED   正处理的请求
REQ_DONTPREP  不调用请求队列中的prep_rq_fn方法预先准备把命令发送给 硬件设备
REQ_QUEUED   请求被标记——也就是说，与该请求相关的硬件设备可以同 时管理很多未完成数据的传送  
REQ_PC  请求包含发送给硬件设备的直接命令  
REQ_BLOCK_PC  与前一个标志功能相同，但发送的命令包含在bio结构中 
REQ_SENSE  请求包含一个“sense”请求命令（SCSI和ATAPI设备使用）   
REQ_FAILED 当请求中的sense或direct命令的操作与预期的不一致时设置 该标志
REQ_QUIET  万一I&#x2F;O操作出错请求申明不产生内核消息
REQ_SPECIAL  请求包含对硬件设备的特殊命令（例如，重设驱动器） 
REQ_DRIVE_CMD  请求包含对IDE磁盘的特殊命令  
REQ_DRIVE_TASK 请求包含对IDE磁盘的特殊命令  
REQ_DRIVE_TASKFILE  请求包含对IDE磁盘的特殊命令  
REQ_PREEMPT  请求取代位于请求队列前面的请求（仅对IDE磁盘而言）   
REQ_PM_SUSPEND  请求包含一个挂起硬件设备的电源管理命令  
REQ_PM_RESUME  请求包含一个唤醒硬件设备的电源管理命令  
REQ_PM_SHUTDOWN  请求包含一个切断硬件设备的电源管理命令  
REQ_BAR_PREFLUSH  请求包含一个要发送给磁盘控制器的刷新队列命令 
REQ_BAR_POSTFLUSH  请求包含一个已发送给磁盘控制器的刷新队列命令 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="对请求描述符的分配进行管理"><a href="#对请求描述符的分配进行管理" class="headerlink" title="对请求描述符的分配进行管理"></a>对请求描述符的分配进行管理</h3><p>在重负载和磁盘操作频繁的情况下，固定数目的动态空闲内存将成为进程想要把新请求加入请求队列q的瓶颈。为了解决这种问题，每个request_queue描述符包含一个request_list数据结构，其中包括：</p>
<ol>
<li>一个指针，指向请求描述符的内存池。</li>
<li>两个计数器，分别用于记录分配给READ和WRITE请求的请求描述符数。</li>
<li>两个标志，分别用于标记为读或写请求的分配是否失败。</li>
<li>两个等待队列，分别存放了为获得空闲的读和写请求描述符而睡眠的进程。一个等待队列，存放等待一个请求队列被刷新(清空)的进程。</li>
</ol>
<p>blk_get_request()函数试图从一个特定请求队列的内存池中获得一个空闲的请求描述符；如果内存区不足并且内存池已经用完，则要么挂起当前进程，要么返回NULL(如果不能阻塞内核控制路径)。如果分配成功，则将请求队列的request_list数据结构的地址存放在请求描述符的r1字段中。blk_put_request()函数则释放一个请求描述符；如果该描述符的引用计数器的值为0，则将描述符归还回它原来所在的内存池。</p>
<h3 id="避免请求队列拥塞"><a href="#避免请求队列拥塞" class="headerlink" title="避免请求队列拥塞"></a>避免请求队列拥塞</h3><p>每个请求队列都有一个允许处理的最大请求数。请求队列描述符的nr_requests字段存放了每个数据传送方向所允许处理的最大请求数。缺省情况下，一个队列至多有128个待处理读请求和128个待处理写请求。</p>
<p>如果待处理的读(写)请求数超过了nr_requests 值，那么通过设置请求队列描述符的queue_flags字段的QUEUE_FLAG_READFULL (QUEUE_FLAG_WRITEFULL)标志将该队列标记为已满，试图把请求加入到某个传送方向的可阻塞进程被放置到request_list结构所对应的等待队列中睡眠。一个填满的请求队列对系统性能有负面影响，因为它会强制许多进程去睡眠以等待I/O 数据传送的完成。因此，如果给定传送方向上的待处理请求数超过了存放在请求描述符的nr_congestion_on字段中的值(缺省值为113)，那么内核认为该队列是拥塞的，并试图降低新请求的创建速率。</p>
<p>当待处理请求数小于nr_congestion_off的值(缺省值为111)时，拥塞的请求队列才变为不拥塞。blk_congestion_wait()函数挂起当前进程，直到所有请求队列都变为不拥塞或超时已到。</p>
<h3 id="激活块设备驱动程序"><a href="#激活块设备驱动程序" class="headerlink" title="激活块设备驱动程序"></a>激活块设备驱动程序</h3><p>正如我们在前面已经看到的一样，延迟激活块设备驱动程序有利于把相邻块的请求进行集中。这种延迟是通过所谓的设备插入和设备拔出技术来实现的。在块设备驱动程序被插入时，该驱动程序并不被激活，即使在驱动程序队列中有待处理的请求。blk_plug_device()函数的功能是插入一个块设备——更准确地说，插入到某个块设备驱动程序处理的请求队列中。</p>
<p>本质上，该函数接收一个请求队列描述符的地址q作为其参数。它设置q-&gt;queue_flags字段中的QUEUE_FLAG_PLUGGED位；然后，重新启动q-&gt;unplug_timer字段中的内嵌动态定时器。blk_remove_plug()则拔去一个请求队列q；清除QUEUE_FLAG_PLUGGED标志并取消q-&gt;unplug_timer动态定时器的执行。当“视线中”所有可合并的请求都被加入请求队列时，内核就会显式地调用该函数。此外，如果请求队列中待处理的请求数超过了请求队列描述符的unplug_thresh字段中存放的值(缺省值为4)，那么I/O调度程序也会去掉该请求队列。</p>
<p>如果一个设备保持插入的时间间隔为q-&gt;unplug_delay(通常为3ms)，那么说明由blk_plug_device()函数激活的动态定时器的时间已用完，因此就会执行blk_unplug_timeout()函数。因而，唤醒内核线程kblockd所操作的工作队列kblockd_workqueue。kblockd执行blk-&gt;unplug_work()函数，其地址存放在q-&gt;unplug_work结构中。接着，该函数会调用请求队列中的q-&gt;unplug_fn方法，通常该方法是由generic_unplug_device()函数实现的。</p>
<p>generic_unplug_device()函数的功能是拔出块设备：</p>
<ul>
<li>首先，检查请求队列是否仍然活跃；</li>
<li>然后，调用blk_remove_plug()函数；</li>
<li>最后，执行策略例程request_fn方法来开始处理请求队列中的下一个请求。</li>
</ul>
<h3 id="IO调度算法"><a href="#IO调度算法" class="headerlink" title="IO调度算法"></a>IO调度算法</h3><p>当向请求队列增加一条新的请求时，通用块层会调用I/O调度程序来确定请求队列中新请求的确切位置。I/O调度程序试图通过扇区将请求队列排序。如果顺序地从链表中提取要处理的请求，那么就会明显减少磁头寻道的次数，因为磁头是按照直线的方式从内磁道移向外磁道(反之亦然)，而不是随意地从一个磁道跳跃到另一个磁道。这可以从电梯算法中得到启发，回想一下，电梯算法处理来自不同层的上下请求。电梯是往一个方向移动的；当朝一个方向上的最后一个预定层到达时，电梯就会改变方向而开始向相反的方向移动。因此，I/O调度程序也被称为电梯算法(elevator)。</p>
<p>在重负载情况下，严格遵循扇区号顺序的I/O调度算法运行的并不是很好。在这种情形下，数据传送的完成时间主要取决于磁盘上数据的物理位置。因此，如果设备驱动程序处理的请求位于队列的首部(小扇区号)，并且拥有小扇区号的新请求不断被加入队列中，那么队列末尾的请求就很容易会饿死。因而I/O调度算法会非常复杂。<br>当前，Linux 2.6中提供了四种不同类型的I/O调度程序或电梯算法，分别为“预期(Anticipatory)”算法、“最后期限(Deadline)”算法、“CFQ(Complete Fairness Queueing，完全公平队列)”算法以及“Noop(No Operation)”算法。对大多数块设备而言，内核使用的缺省电梯算法可在引导时通过内核参数elevator=进行再设置，其中值可取下列任何一个：as、deadline、cfq和noop。如果没有给定引导参数，那么内核缺省使用“预期”I/O调度程序。总之，设备驱动程序可以用任何一个调度程序取代缺省的电梯算法；设备驱动程序也可以自己定制I/O调度算法，但是这种情况很少见。此外，系统管理员可以在运行时为一个特定的块设备改变I/O调度程序。例如，为了改变第一个IDE通道的主磁盘所使用的I/O调度程序，管理员可把一个电梯算法的名称写入sysfs特殊文件系统的/sys/block/hda/queue/scheduler文件中。</p>
<p>请求队列中使用的I/O调度算法是由一个elevator_t类型的elevator对象表示的；该对象的地址存放在请求队列描述符的elevator字段中。elevator对象包含了几个方法，它们覆盖了elevator所有可能的操作：链接和断开elevator，增加和合并队列中的请求，从队列中删除请求，获得队列中下一个待处理的请求等等。elevator对象也存放了一个表的地址，表中包含了处理请求队列所需的所有信息。而且，每个请求描述符包含一个elevator_private字段，该字段指向一个由I/O调度程序用来处理请求的附加数据结构。</p>
<p>现在我们从易到难简要地介绍一下四种I/O调度算法。注意，设计一个I/O调度程序与设计一个CPU调度程序很相似：启发算法和采用的常量值是测试和基准外延量的结果。一般而言，所有的算法都使用一个调度队列(dispatch queue)，队列中包含的所有请求按照设备驱动程序应当处理的顺序进行排序——也即设备驱动程序要处理的下一个请求通常是调度队列中的第一个元素。</p>
<p>调度队列实际上是由请求队列描述符的queue_head 字段所确定的请求队列。几乎所有的算法都使用另外的队列对请求进行分类和排序。它们允许设备驱动程序将bio结构增加到已存在请求中，如果需要，还要合并两个“相邻的”请求。</p>
<h4 id="“Noop”算法"><a href="#“Noop”算法" class="headerlink" title="“Noop”算法"></a>“Noop”算法</h4><p>这是最简单的I/O调度算法。它没有排序的队列：新的请求通常被插在调度队列的开头或末尾，下一个要处理的请求总是队列中的第一个请求。</p>
<h4 id="“CFQ”算法"><a href="#“CFQ”算法" class="headerlink" title="“CFQ”算法"></a>“CFQ”算法</h4><p>“CFQ(完全公平队列)”算法的主要目标是在触发I/O请求的所有进程中确保磁盘I/O 带宽的公平分配。为了达到这个目标，算法使用许多个排序队列，它们存放了不同进程发出的请求。</p>
<p>当算法处理一个请求时，内核调用一个散列函数将当前进程的线程组标识符(通常，它对应其PID，参见第三章“标识一个进程”一节)转换为队列的索引值；然后，算法将一个新的请求插入该队列的末尾。因此，同一个进程发出的请求通常被插入相同的队列中。为了再填充调度队列，算法本质上采用轮询方式扫描I/O输入队列，选择第一个非空队列，然后将该队列中的一组请求移动到调度队列的末尾。</p>
<h4 id="“最后期限”算法"><a href="#“最后期限”算法" class="headerlink" title="“最后期限”算法"></a>“最后期限”算法</h4><p>除了调度队列外，“最后期限”算法还使用了四个队列。其中的两个排序队列分别包含读请求和写请求，其中的请求是根据起始扇区数排序的。另外两个最后期限队列包含相同的读和写请求，但这是根据它们的“最后期限”排序的。引入这些队列是为了避免请求饿死，由于电梯策略优先处理与上一个所处理的请求最近的请求，因而就会对某个请求忽略很长一段时间，这时就会发生这种情况。请求的最后期限本质上就是一个超时定时器，当请求被传给电梯算法时开始计时。</p>
<p>缺省情况下，读请求的超时时间是500ms，写请求的超时时间是5s——读请求优先于写请求，因为读请求通常阻塞发出请求的进程。最后期限保证了调度程序照顾等待很长一段时间的那个请求，即使它位于排序队列的末尾。当算法要补充调度队列时，首先确定下一个请求的数据方向。如果同时要调度读和写两个请求，算法会选择“读”方向，除非该“写”方向已经被放弃很多次了(为了避免写请求饿死)。接下来，算法检查与被选择方向相关的最后期限队列：如果队列中的第一个请求的最后期限已用完，那么算法将该请求移到调度队列的末尾；也可以从超时的那个请求开始移动来自排序队列的一组请求。如果将要移动的请求在磁盘上物理相邻，那么组的长度会变长，否则就变短。</p>
<p>最后，如果没有请求超时，算法对来自于排序队列的最后一个请求之后的一组请求进行调度。当指针到达排序队列的末尾时，搜索又从头开始(“单方向算法”)。</p>
<h4 id="“预期”算法"><a href="#“预期”算法" class="headerlink" title="“预期”算法"></a>“预期”算法</h4><p>“预期”算法是Linux提供的最复杂的一种I/O调度算法。基本上，它是“最后期限”算法的一个演变，借用了“最后期限”算法的基本机制：两个最后期限队列和两个排序队列；I/O调度程序在读和写请之间交互扫描排序队列，不过更倾向于读请求。扫描基本上是连续的，除非有某个请求超时。读请求的缺省超时时间是125ms，写请求的缺省超时时间是250ms。但是，该算法还遵循一些附加的启发式准则：</p>
<ol>
<li>有些情况下，算法可能在排序队列当前位置之后选择一个请求，从而强制磁头从后搜索。这种情况通常发生在这个请求之后的搜索距离小于在排序队列当前位置之后对该请求搜索距离的一半时。</li>
<li>算法统计系统中每个进程触发的I/O操作的种类。当刚刚调度了由某个进程p发出的一个读请求之后，算法马上检查排序队列中的下一个请求是否来自同一个进程p。如果是，立即调度下一个请求。否则，查看关于该进程p的统计信息：如果确定进程p可能很快发出另一个读请求，那么就延迟一小段时间(缺省大约为7ms)。<br>因此，算法预测进程p发出的读请求与刚被调度的请求在磁盘上可能是“近邻”。</li>
</ol>
<h2 id="向I-O调度程序发出请求"><a href="#向I-O调度程序发出请求" class="headerlink" title="向I/O调度程序发出请求"></a>向I/O调度程序发出请求</h2><p>正如我们在本章前面的“提交请求”一节中所看到的，generic_make_request()函数调用请求队列描述符的make_request_fn方法向I/O调度程序发送一个请求。通常该方法是由__make_request()函数实现的；该函数接收一个request_queue类型的描述符q和一个bio结构的描述符bio作为其参数，然后执行如下操作：</p>
<ol>
<li><p>如果需要，调用blk_queue_bounce()函数建立一个回弹缓冲区(参见后面)。如果回弹缓冲区被建立，__make_request()函数将对该缓冲区而不是原先的bio结构进行操作。</p>
</li>
<li><p>调用I/O调度程序的elv_queue_empty()函数检查请求队列中是否存在待处理请求。注意，调度队列可能是空的，但是I/O调度程序的其他队列可能包含待处理请求。如果没有待处理请求，那么调用blk_plug_device()函数插入请求队列，然后跳转到第5步。</p>
</li>
<li><p>插入的请求队列包含待处理请求。调用I/O调度程序的elv_merge()函数检查新的bio结构是否可以并入已存在的请求中。该函数将返回三个可能值：</p>
<blockquote>
<ul>
<li>ELEVATOR_NO_MERGE：已经存在的请求中不能包含bio结构；这种情况下，跳转到第5步。</li>
<li>3.2. ELEVATOR_BACK_MERGE：bio结构可作为末尾的bio而插入到某个请求req中；这种情形下，函数调用q-&gt;back_merge_fn方法检查是否可以扩展该请求。如果不行，则跳转到第5步。否则，将bio描述符插入req链表的末尾并更新req的相应字段值。然后，函数试图将该请求与其后面的请求合并(新的bio可能填充在两个请求之间)。</li>
<li>ELEVATOR_FRONT_MERGE：bio结构可作为某个请求req的第一个bio被插入；这种情形下，函数调用q-&gt;front_merge_fn方法检查是否可以扩展该请求。如果不行，则跳转到第5步。否则，将bio描述符插入req链表的首部并更新req的相应字段值。然后，试图将该请求与其前面的请求合并。</li>
</ul>
</blockquote>
</li>
<li><p>bio已经被并入存在的请求中，跳转到第7步终止函数。</p>
</li>
<li><p>bio必须被插入到一个新的请求中。分配一个新的请求描述符。如果没有空闲的内存，那么挂起当前进程，直到设置了bio-&gt;bi_rw中的BIO_RW_AHEAD标志， 该标志表明这个I/O操作是一次预读；在这种情形下，函数调用bio_endio()并终止：此时将不会执行数据传送。</p>
</li>
<li><p>初始化请求描述符中的字段。主要有：</p>
<blockquote>
<ul>
<li>根据bio描述符的内容初始化各个字段，包括扇区数、当前bio以及当前段。</li>
<li>设置flags字段中的REQ_CMD标志(一个标准的读或写操作)。</li>
<li>如果第一个bio段的页框存放在低端内存，则将buffer字段设置为缓冲区的线性地址。</li>
<li>将rq_disk字段设置为bio-&gt;bi_bdev-&gt;bd_disk的地址。</li>
<li>将bio插入请求链表。</li>
<li>将start_time字段设置为jiffies的值。</li>
</ul>
</blockquote>
</li>
<li><p>所有操作全部完成。但是，在终止之前，检查是否设置了bio-&gt;bi_rw中的BIO_RW_SYNC标志。如果是，则对“请求队列”调用generic_unplug_device()函数以卸载设备驱动程序。</p>
</li>
<li><p>函数终止。</p>
</li>
</ol>
<p>​    如果在调用<strong>make_request()函数之前请求队列不是空的，那么说明该请求队列要么已经被拔掉过，要么很快将被拔掉——因为每个拥有待处理请求的插入请求队列q都有一个正在运行的动态定时器q-&gt;unplug_timer。另一方面，如果请求队列是空的，则</strong>make_request()函数插入请求队列。或迟(最坏的情况是当拔出的定时器到期了)或早(从__make_request()中退出时，如果设置了bio的BIO_RW_SYNC标志)，该请求队列都会被拔掉。任何情形下，块设备驱动程序的策略例程最后都将处理调度队列中的请求。</p>
<h3 id="blk-queue-bounce-函数"><a href="#blk-queue-bounce-函数" class="headerlink" title="blk_queue_bounce()函数"></a>blk_queue_bounce()函数</h3><p>blk_queue_bounce()函数的功能是查看q-&gt;bounce_gfp中的标志以及q-&gt;bounce_pfn 中的阈值，从而确定回弹缓冲区(buffer bouncing)是否是必需的。通常当请求中的一些缓冲区位于高端内存而硬件设备不能访问它们时发生这种情况。</p>
<p>ISA总线使用的老式DMA方式只能处理24位的物理地址。因此，回弹缓冲区的上限设为16 MB，也就是说，页框号为4096。然而，当处理老式设备时，块设备驱动程序通常不依赖回弹缓冲区；相反，它们更倾向于直接在ZONE_DMA内存区中分配DMA缓冲区。如果硬件设备不能处理高端内存中的缓冲区，则blk_queue_bounce()函数检查bio中的一些缓冲区是否真的必须是回弹的。</p>
<p>如果是，则将bio描述符复制一份，接着创建一个回弹bio；然后，当段中的页框号等于或大于q-&gt;bounce_pfn的值时，执行下列操作</p>
<ol>
<li>根据分配的标志，在ZONE_NORMAL或ZONE_DMA内存区中分配一个页框。</li>
<li>更新回弹bio中段的bv_page字段的值，使其指向新页框的描述符。</li>
<li>如果bio-&gt;bio_rw代表一个写操作，则调用kmap()临时将高端内存页映射到内核地址空间中，然后将高端内存页复制到低端内存页上，最后调用kunmap()释放该映射。然后blk_queue_bounce()函数设置回弹bio中的BIO_BOUNCED标志，为其初始化一个特定的bi_end_io方法，最后将它存放在回弹bio的bi_private字段中，该字段是指向初始bio的指针。当在回弹bio上的I/O数据传送终止时，函数执行bi_end_io方法将数据复制到高端内存区中(仅适合读操作)，并释放该回弹bio结构。</li>
</ol>
<h3 id="块设备驱动程序"><a href="#块设备驱动程序" class="headerlink" title="块设备驱动程序"></a>块设备驱动程序</h3><p>块设备驱动程序是Linux块子系统中的最底层组件。它们从I/O调度程序中获得请求，然后按要求处理这些请求。当然，块设备驱动程序是设备驱动程序模型的组成部分。因此，每个块设备驱动程序对应一个device_driver类型的描述符；此外，设备驱动程序处理的每个磁盘都与一个device描述符相关联。但是，这些描述符没有什么特别的：块I/O子系统必须为系统中的每个块设备存放附加信息。</p>
<h3 id="块设备-1"><a href="#块设备-1" class="headerlink" title="块设备"></a>块设备</h3><p>一个块设备驱动程序可能处理几个块设备。例如，IDE设备驱动程序可以处理几个IDE 磁盘，其中的每个都是一个单独的块设备。而且，每个磁盘通常是被分区的，每个分区又可以被看作是一个逻辑块设备。很明显，块设备驱动程序必须处理在块设备对应的块设备文件上发出的所有VFS系统调用。每个块设备都是由一个block_device结构的描述符来表示的，其字段如表14-9所示。</p>
<p>所有的块设备描述符被插入一个全局链表中，链表首部是由变量all_bdevs表示的；链表链接所用的指针位于块设备描述符的bd_list字段中。如果块设备描述符对应一个磁盘分区，那么bd_contains字段指向与整个磁盘相关的块设备描述符，而bd_part字段指向hd_struct分区描述符。否则，若块设备描述符对应整个磁盘，那么bd_contains字段指向块设备描述符本身，bd_part_count字段用于记录磁盘上的分区已经被打开了多少次。bd_holder字段存放代表块设备持有者的线性地址。持有者并不是进行I/O数据传送的块设备驱动程序；准确地说，它是一个内核组件，使用设备并拥有独一无二的特权(例如，它可以自由使用块设备描述符的bd_private字段)。</p>
<p>典型地，块设备的持有者是安装在该设备上的文件系统。当块设备文件被打开进行互斥访问时，另一个普遍的问题出现了：持有者就是对应的文件对象。bd_claim()函数将bd_holder字段设置为一个特定的地址；相反，bd_release()函数将该字段重新设置为NULL。然而，值得注意的是，同一个内核组件可以多次调用bd_claim()函数，每调用一次都增加bd_holders的值。为了释放块设备，内核组件必须调用bd_release()函数bd_holders次。图14-3对应的是一个整盘，它说明了块设备描述符是如何被链接到块I/O子系统的其他重要数据结构上的。</p>
<pre class="line-numbers language-none"><code class="language-none">struct block_device &#123;  
    dev_t           bd_dev;  
    struct inode *  bd_inode;   &#x2F;*分区结点*&#x2F;  
    int         bd_openers;  
    struct semaphore    bd_sem; &#x2F;*打开&#x2F;关闭锁*&#x2F;  
    struct semaphore    bd_mount_sem;   &#x2F;* 加载互斥锁*&#x2F;  
    struct list_head    bd_inodes;  
    void *      bd_holder;  
    int         bd_holders;  
    struct block_device *   bd_contains;  
    unsigned        bd_block_size;&#x2F;&#x2F;分区块大小  
    struct hd_struct *  bd_part;  
    unsigned        bd_part_count;&#x2F;&#x2F;打开次数  
    int         bd_invalidated;  
    struct gendisk *    bd_disk;  
    struct list_head    bd_list;  
    struct backing_dev_info *bd_inode_backing_dev_info;  
    unsigned long   bd_private;  
&#125;;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="访问块设备"><a href="#访问块设备" class="headerlink" title="访问块设备"></a>访问块设备</h3><p>当内核接收一个打开块设备文件的请求时，必须首先确定该设备文件是否已经是打开的。事实上，如果文件已经是打开的，内核就没有必要创建并初始化一个新的块设备描述符；相反，内核应该更新这个已经存在的块设备描述符。然而，真正的复杂性在于具有相同主设备号和次设备号但有不同路径名的块设备文件被VFS看作不同的文件，但是它们实际上指向同一个块设备。因此，内核无法通过简单地在一个对象的索引节点高速缓存中检查块设备文件的存在就确定相应的块设备已经在使用。<br><img src=".\image-20240503151133707.png" alt="image-20240503151133707"><br>主、次设备号和相应的块设备描述符之间的关系是通过bdev特殊文件系统来维护的。每个块设备描述符都对应一个bdev特殊文件：块设备描述符的bd_inode字段指向相应的bdev索引节点；而该索引节点则将块设备的主、次设备号和相应描述符的地址进行编码。bdget()接收块设备的主设备号和次设备号作为其参数：在bdev文件系统中查寻相关的索引节点；如果不存在这样的节点，那么就分配一个新索引节点和新块设备描述符。在任何情形下，函数都返回一个与给定主、次设备号对应的块设备描述符的地址。一旦找到了块设备的描述符，那么内核通过检查bd_openers字段的值来确定块设备当前是否在使用：如果值是正的，说明块设备已经在使用(可能通过不同的设备文件)。同时内核也维护一个与已打开的块设备文件对应的索引节点对象的链表。该链表存放在块设备描述符的nd_inodes字段中；索引节点对象的i_devices字段存放用于链接链表中的前后元素的指针。</p>
<h3 id="注册和初始化设备驱动程序"><a href="#注册和初始化设备驱动程序" class="headerlink" title="注册和初始化设备驱动程序"></a>注册和初始化设备驱动程序</h3><p>现在我们来说明一下为一个块设备设计一个新的驱动程序所涉及的基本步骤。显然，其描述是比较简单的，但是理解何时并怎样初始化块I/O子系统使用的主要数据结构是很有用的。我们省略了所有块设备驱动程序需要的但在第十三章中已经讲过的步骤。例如，我们跳过了注册一个驱动程序本身的所有步骤。通常，块设备属于一个诸如PCI或SCSI这样的标准总线体系结构，内核提供了相应的辅助函数，作为一个辅助作用，就是在驱动程序模型中注册驱动程序。</p>
<h2 id="自定义驱动程序描述符"><a href="#自定义驱动程序描述符" class="headerlink" title="自定义驱动程序描述符"></a>自定义驱动程序描述符</h2><p>首先，设备驱动程序需要一个foo_dev_t类型的自定义描述符foo，它拥有驱动硬件设备所需的数据。该描述符存放每个设备的相关信息，例如操作设备时使用的I/O端口、设备发出中断的IRQ线、设备的内部状态等等。同时它也包含块I/O子系统所需的一些字段：</p>
<pre class="line-numbers language-none"><code class="language-none">struct foo_dev_t &#123;
[...]
spinlock_t lock;
struct gendisk *gd;
[...]
&#125; foo;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>lock字段是用来保护foo描述符中字段值的自旋锁；通常将其地址传给内核辅助函数，从而保护对驱动程序而言特定的块I/O子系统的数据结构。gd字段是指向gendisk描述符的指针，该描述符描述由这个驱动程序处理的整个块设备(磁盘)。</p>
<h3 id="预订主设备号"><a href="#预订主设备号" class="headerlink" title="预订主设备号"></a>预订主设备号</h3><p>设备驱动程序必须自己预订一个主设备号。传统上，该操作通过调用register_blkdev()函数完成：</p>
<pre class="line-numbers language-none"><code class="language-none">err &#x3D; register_blkdev(FOO_MAJOR, &quot;foo&quot;);
if(err) goto error_major_is_busy;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>该函数类似于第十三章的“分配设备号”一节中出现的register_chrdev()函数：预订主设备号FOO_MAJOR并将设备名称foo赋给它。注意，这不能分配次设备号范围，因为没有类似的register_chrdev_region()函数；此外，预订的主设备号和驱动程序的数据结构之间也没有建立链接。register_blkdev()函数产生的唯一可见的效果是包含一个新条目，该条目位于/proc/devices特殊文件的已注册主设备号列表中。</p>
<h3 id="初始化自定义描述符"><a href="#初始化自定义描述符" class="headerlink" title="初始化自定义描述符"></a>初始化自定义描述符</h3><p>在使用驱动程序之前必须适当地初始化foo描述符中的所有字段。为了初始化与块I/O子系统相关的字段，设备驱动程序主要执行如下操作：</p>
<pre class="line-numbers language-none"><code class="language-none">spin_lock_init(&amp;foo.lock);
foo.gd &#x3D; alloc_disk(16);
if(!foo.gd) goto error_no_gendisk;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>驱动程序首先初始化自旋锁，然后分配一个磁盘描述符。正如在前面的图14-3中所看到的，gendisk结构是块I/O子系统中最重要的数据结构，因为它涉及许多其他的数据结构。alloc_disk()函数也分配一个存放磁盘分区描述符的数组。该函数所需要的参数是数组中hd_struct结构的元素个数；16表示驱动程序可以支持16个磁盘，而每个磁盘可以包含15个分区(0分区不使用)。</p>
<h3 id="初始化gendisk描述符"><a href="#初始化gendisk描述符" class="headerlink" title="初始化gendisk描述符"></a>初始化gendisk描述符</h3><p>接下来，驱动程序初始化gendisk描述符的一些字段：</p>
<pre class="line-numbers language-none"><code class="language-none">foo.gd-&gt;private_data &#x3D;&amp;foo;
foo.gd-&gt;major &#x3D; FOO_MAJOR;
foo.gd-&gt;first_minor &#x3D; 0;
foo.gd-&gt;minors &#x3D; 16;
set_capacity(foo.gd,foo_disk_capacity_in_sectors);strcpy(foo.gd-&gt;disk_name,“foo”);
foo.gd-&gt;fops &#x3D;&amp;foo_ops;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>foo描述符的地址存放在gendisk结构的private_data字段中，因此被块I/O子系统当作方法调用的低级驱动程序函数可以迅速地查找到驱动程序描述符如果驱动程序可以并发地处理多个磁盘，那么这种方式可以提高效率。set_capacity()函数将capacity字段初始化为以512字节扇区为单位的磁盘大小，这个值也可能在探测硬件并询问磁盘参数时确定</p>
<h3 id="初始化块设备操作表"><a href="#初始化块设备操作表" class="headerlink" title="初始化块设备操作表"></a>初始化块设备操作表</h3><p>gendisk描述符的fops字段被初始化为自定义的块设备方法表的地址。类似地，设备驱动程序的foo_ops表中包含设备驱动程序的特有函数。例如，如果硬件设备支持可移动磁盘，通用块层将调用media_changed方法检查自从最后一次安装或打开该块设备以来磁盘是否被更换。通常通过向硬件控制器发送一些低级命令来完成该检查，因此，每个设备驱动程序所实现的media_changed方法都是不同的。类似地，仅当通用块层不知道如何处理ioctl命令时才调用ioctl方法。例如，当一个ioctl()系统调用询问磁盘构造时，也就是磁盘使用的柱面数、磁道数、扇区数以及磁头数时，通常调用该方法。因此，每个设备驱动程序所实现的ioctl方法也都是不同的。</p>
<h3 id="分配和初始化请求队列"><a href="#分配和初始化请求队列" class="headerlink" title="分配和初始化请求队列"></a>分配和初始化请求队列</h3><p>我们勇敢的设备驱动程序设计者现在将要建立一个请求队列，该队列用于存放等待处理的请求。可以通过如下操作轻松地建立请求队列：</p>
<pre class="line-numbers language-none"><code class="language-none">foo.gd-&gt;rq &#x3D; blk_init_queue(foo_strategy,&amp;foo.lock);
if(!foo.gd-&gt;rq) goto error_no_request_queue;
blk_queue_hardsect_size(foo.gd-&gt;rd, foo_hard_sector_size);
blk_queue_max_sectors(foo.gd-&gt;rd, foo_max_sectors);
blk_queue_max_hw_segments(foo.gd-&gt;rd, foo_max_hw_segments);
blk_queue_max_phys_segments(foo.gd-&gt;rd, foo_max_phys_segments);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>blk_init_queue()函数分配一个请求队列描述符并将其中许多字段初始化为缺省值。它接收的参数为设备描述符的自旋锁的地址(foo.gd-&gt;rq-&gt;queue_lock字段值)和设备驱动程序的策略例程(参见下一节“策略例程”)的地址(foo.gd-&gt;rq-&gt;request_fn字段值)。<br>该函数也初始化foo.gd-&gt;rq-&gt;elevator字段，并强制驱动程序使用缺省的I/O 调度算法。如果设备驱动程序想要使用其他的调度算法，可在稍后覆盖elevator字段的地址。接下来，使用几个辅助函数将请求队列描述符的不同字段设为设备驱动程序的特征值(参考表14-6中的类似字段)。</p>
<h3 id="设置中断处理程序"><a href="#设置中断处理程序" class="headerlink" title="设置中断处理程序"></a>设置中断处理程序</h3><p>正如第四章的“I/O中断处理”一节中所介绍的，设备驱动程序需要为设备注册IRQ线。这可以通过如下操作完成：</p>
<pre class="line-numbers language-none"><code class="language-none">request_irq(foo_irq, foo_interrupt, SA_INTERRUPTISA_SHIRQ, &quot;foo&quot;, NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>foo_interrupt()函数是设备的中断处理程序；</p>
<h3 id="注册磁盘"><a href="#注册磁盘" class="headerlink" title="注册磁盘"></a>注册磁盘</h3><p>最后，设备驱动程序的所有数据结构已经准备好了：初始化阶段的最后一步就是“注册”和激活磁盘。这可以简单地通过执行下面的操作完成：add_disk(foo.gd);<br>add_disk()函数接收gendisk描述符的地址作为其参数，主要执行下列操作：</p>
<ol>
<li>设置gd-&gt;flags的GENHD_FL_UP标志。</li>
<li>调用kobj_map()建立设备驱动程序和设备的主设备号(连同相关范围内的次设备号)之间的连接(注意，在这种情况下，kobject映射域由bdev_map变量表示)。</li>
<li>注册设备驱动程序模型的gendisk描述符中的kobject结构，它作为设备驱动程序处理的一个新设备(例如/sys/block/foo)。</li>
<li>如果需要，扫描磁盘中的分区表；对于查找到的每个分区，适当地初始化foo.gd-&gt;part数组中相应的hd_struct描述符。同时注册设备驱动程序模型中的分区(例如/sys/block/foo/foo1)。</li>
<li>注册设备驱动程序模型的请求队列描述符中内嵌的kobject结构(例如/sys/block/foo/queue)。一旦add_disk()返回，设备驱动程序就可以工作了。进行初始化的函数终止；策略例程和中断处理程序开始处理I/O调度程序传送给设备驱动程序的每个请求。</li>
</ol>
<h3 id="策略例程"><a href="#策略例程" class="headerlink" title="策略例程"></a>策略例程</h3><p>策略例程是块设备驱动程序的一个函数或一组函数，它与硬件块设备之间相互作用以满足调度队列中所汇集的请求。通过请求队列描述符中的request_fn方法可以调用策略例程——例如前面一节介绍的foo_strategy()函数，I/O调度程序层将请求队列描述符q的地址传递给该函数。如前所述，在把新的请求插入到空的请求队列后，策略例程通常才被启动。只要块设备驱动程序被激活，就应该对队列中的所有请求都进行处理，直到队列为空才结束。策略例程的简单实现如下：对于调度队列中的每个元素，与块设备控制器相互作用共同为请求服务，等待直到数据传送完成，然后把已经服务过的请求从队列中删除，继续处理调度队列中的下一个请求。这种实现效率并不高。即使假设可以使用DMA传送数据，策略例程在等待I/O操作完成的过程中也必须自行挂起。也就是说策略例程应该在一个专门的内核线程上执行(我们不想处罚毫不相关的用户进程)。而且，这样的驱动程序也不能支持可以一次处理多个I/O数据传送的现代磁盘控制器。因此，很多块设备驱动程序都采用如下策略：</p>
<ol>
<li>策略例程处理队列中的第一个请求并设置块设备控制器，以便在数据传送完成时可以产生一个中断。然后策略例程就终止。</li>
<li>当磁盘控制器产生中断时，中断控制器重新调用策略例程(通常是直接的，有时也通过激活一个工作队列)。策略例程要么为当前请求再启动一次数据传送，要么当请求的所有数据块已经传送完成时，把该请求从调度队列中删除然后开始处理下一个请求。<br>请求是由几个bio结构组成的，而每个bio结构又是由几个段组成的。基本上，块设备驱动程序以以下两种方式使用DMA：</li>
<li>驱动程序建立不同的DMA传送方式，为请求的每个bio结构中的每个段进行服务。</li>
<li>驱动程序建立一种单独的分散-聚集DMA传送方式，为请求的所有bio中的所有段服务。<br>最后，设备驱动程序策略例程的设计依赖块控制器的特性。每个物理块设备都有不同于其他物理块设备的固有特性(例如，软盘驱动程序把磁道上的块分组为磁道，一次单独的I/O操作传送整个磁道)，因此对设备驱动程序怎样为每个请求进行服务而做一般假设并没有多大意义。</li>
</ol>
<p>在我们的例子中，foo_strategy()策略例程应该执行以下操作：</p>
<ol>
<li>通过调用I/O调度程序的辅助函数elv_next_request()从调度队列中获取当前的请求。如果调度队列为空，就结束这个策略例程：req = elv_next_request(q); if(!req) return;</li>
<li>执行blk_fs_request宏检查是否设置了请求的REQ_CMD标志，也即，请求是否包含一个标准的读或写操作：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">if(!blk_fs_request(req))
	goto handle_special_request;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol>
<li>如果块设备控制器支持分散-聚集DMA，那么对磁盘控制器进行编程，以便为整个请求执行数据传送并在传送完成时产生一个中断。blk_rq_map_sg()辅助函数返回一个可以立即被用来启动数据传送的分散-聚集链表。</li>
<li>否则，设备驱动程序必须一段一段地传送数据。在这种情形下，策略例程执行rq_for_each_bio和bio_for_each_segment两个宏，分别遍历bio链表和每个bio中的段链表。</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">rq_for_each_bio(bio, rq)
bio_for_each_segment(bvec, bio, i) &#123;
	&#x2F;* transfer the i-th segment bvec *&#x2F;
	local_irq_save(flags);
	addr &#x3D; kmap_atomic(bvec-&gt;bv_page, KM_BIO_SRC_IRQ);
	foo_start_dma_transfer(addr + bvec-&gt;bv_offset, bvec-&gt;bv_len);
	kunmap_atomic(bvec-&gt;bv_page, KM_BIO_SRC_IRQ);
	local_irq_restore(flags);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要传送的数据在高端内存中，那么kmap_atomic()和kunmap_atomic()两个函数就是必需的。foo_start_dma_transfer()函数对硬件设备进行编程，以便启动DMA数据传送并在I/O操作完成时产生一个中断。然后返回。</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>块设备驱动程序的中断处理程序是在DMA数据传送结束时被激活的。它检查是否已经传送完请求的所有数据块。如果是，中断处理程序就调用策略例程处理调度队列中的下一个请求。否则，中断处理程序更新请求描述符的相应字段并调用策略例程处理还没有完成的数据传送。我们的设备驱动程序foo的中断处理程序的一个典型片段如下：</p>
<pre class="line-numbers language-none"><code class="language-none">irqreturn_t foo_interrupt(int irq, void *dev_id, struct pt_regs *regs)
&#123;
	struct foo_dev_t *p &#x3D;(struct foo_dev_t *)dev_id;
	struct request_queue *rq&#x3D; p-&gt;gd-&gt;rq;
	[...]
	if(!end_that_request_first(rq,uptodate,nr_sectors))&#123;
		blkdev_dequeue_request(rq);
		end_that_request_last(rq);
	&#125;
	rq-&gt;request_fn(rq);
	[...]
	return IRQ_HANDLED;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>end_that_request_first()和end_that_request_last()两个函数共同承担结束一个请求的任务。end_that_request_first()函数接收的参数为一个请求描述符、一个指示DMA数据传送成功完成的标志以及DMA所传送的扇区数(end_that_request_chunk()函数类似，只不过该函数接收的是传送的字节数而不是扇区数)。本质上，它扫描请求中的bio 结构以及每个bio中的段，然后采用如下方式更新请求描述符的字段值：</p>
<ol>
<li>修改bio字段使其指向请求中的第一个未完成的bio结构。</li>
<li>修改未完成bio结构的bi_idx字段使其指向第一个未完成的段。</li>
<li>修改未完成段的bv_offset和bv_len两个字段使其指定仍需传送的数据。该函数也在每个已经完成数据传送的bio结构上调用bio_endio()函数。如果已经传送完请求中的所有数据块，那么end_that_request_first()返回0；否则返回1。如果返回值是1，则中断处理程序重新调用策略例程，继续处理该请求。否则，中断处理程序把请求从请求队列中删除(主要由blkdev_dequeue_request()完成)，然后调用end_that_request_last()辅助函数，并再次调用策略例程处理调度队列中的下一个请求。end_that_request_last()函数的功能是更新一些磁盘使用统计数，把请求描述符从I/O调度程序rq-&gt;elevator的调度队列中删除，唤醒等待请求描述符完成的任一睡眠进程，并释放删除的那个描述符。</li>
</ol>
<h3 id="打开块设备文件"><a href="#打开块设备文件" class="headerlink" title="打开块设备文件"></a>打开块设备文件</h3><p>通过描述打开一个块设备文件时VFS所执行的操作，我们将总结本章的内容。每当一个文件系统被映射到磁盘或分区上时，每当激活一个交换分区时，每当用户态进程向块设备文件发出一个open()系统调用时，内核都会打开一个块设备文件。在所有情况下，内核本质上执行相同的操作：寻找块设备描述符(如果块设备没有在使用，那么就分配一个新的描述符)，为即将开始的数据传送设置文件操作方法。</p>
<ul>
<li><p><code>open &lt;-&gt; blkdev_open()</code></p>
</li>
<li><p><code>release  &lt;-&gt; blkdev_close()</code></p>
</li>
<li><p><code>llseek &lt;-&gt; block_llseek()</code></p>
</li>
<li><p><code>read &lt;-&gt; generic_ file_read</code></p>
</li>
<li><p><code>write &lt;-&gt;blkdev_file_write()</code></p>
</li>
<li><p><code>aio_read &lt;-&gt; generic_file_aio_ read()</code></p>
</li>
<li><p><code>aio_write  &lt;-&gt; blkdev_file_aio_write()</code></p>
</li>
<li><p><code>mmap &lt;-&gt; generic_file mmap()</code></p>
</li>
<li><p><code>fsync &lt;-&gt; block fsync()</code></p>
</li>
<li><p><code>ioctl  &lt;-&gt;&lt;-&gt; block ioctl()</code></p>
</li>
<li><p><code>compat_ioctl  &lt;-&gt; compat_blkdev_ioctlo()</code></p>
</li>
<li><p><code>readv &lt;-&gt; generic_file_readv()</code></p>
</li>
<li><p><code>writev &lt;-&gt; generic_file_write_no_lock()</code></p>
</li>
<li><p><code>sendfile  &lt;-&gt; generic_file_sendfile()</code></p>
</li>
</ul>
<p>  我们仅仅考虑open方法，它由dentry_open()函数调用。blkdev_open()接收inode和filp作为其参数，它们分别存放了索引节点和文件对象的地址；该函数本质上执行下列操作：</p>
<ol>
<li><p>执行bd_acquire(inode)从而获得块设备描述符bdev的地址。该函数接收索引节点对象的地址并执行下列主要步骤：</p>
<blockquote>
<ol>
<li>检查索引节点对象的inode-&gt;i_bdev字段是否不为NULL；如果是，表明块设备文件已经打开了，该字段存放了相应块描述符的地址。在这种情况下，增加与块设备相关联的bdev特殊文件系统的inode-&gt;i_bdev-&gt;bd_inode索引节点的引用计数器的值，并返回描述符inode-&gt;i_bdev的地址。</li>
<li>块设备文件没有被打开的情况。根据块设备文件的主设备号和次设备号，执行bdget( inode-&gt;i_rdev)获取块设备描述符的地址。如果描述符不存在，bdget()就分配一个；但是，要注意的是描述符可能已经存在，例如其他块设备文件已经访问了该块设备。</li>
<li>将块设备描述符的地址存放在inode-&gt;i_bdev中，以便加速将来对相同块设备文件的打开操作。</li>
<li>将inode-&gt;i_mapping字段设置为bdev索引节点中相应字段的值。该字段指向地址空间对象。</li>
<li>把索引节点插入到由bdev-&gt;bd_inodes确立的块设备描述符的已打开索引节点链表中。</li>
<li>返回描述符bdev的地址。</li>
</ol>
</blockquote>
</li>
<li><p>将filp-&gt;i_mapping字段设置为inode-&gt;i_mapping的值(参见前面的第1d步)。</p>
</li>
<li><p>获取与这个块设备相关的gendisk描述符的地址：disk = get_gendisk(bdev-&gt;bd_dev, &amp;part)；如果被打开的块设备是一个分区，则返回的索引值存放在本地变量part中；否则，part为0。get_gendisk()函数在kobject映射域bdev_map上简单地调用kobj_lookup()来传递设备的主设备号和次设备号。</p>
</li>
<li><p>如果bdev-&gt;bd_openers的值不等于0，表明块设备已经被打开了。检查bdev-&gt;bd_contains字段：</p>
<ol>
<li>如果值等于bdev，那么块设备是一个整盘：调用块设备方法bdev-&gt;bd_disk-&gt;fops-&gt;open(如果定义了)，然后检查bdev-&gt;bd_invalidated字段的，如果需要，调用rescan_partitions()函数。</li>
<li>如果不等于bdev，那么块设备是一个分区：增加bdev-&gt;bd_contains-&gt;bd_part_count计数器的值。然后跳到第8步。</li>
</ol>
</li>
<li><p>这里块设备是第一次被访问。初始化bdev-&gt;bd_disk为gendisk描述符的地址disk。</p>
</li>
<li><p>如果块设备是一个整盘(part等于0)，则执行下列子步骤：</p>
<ol>
<li>如果定义了disk-&gt;fops-&gt;open块设备方法，就执行它：该方法是由块设备驱动程序定义的定制函数，它执行任何特定的最后一分钟初始化。</li>
<li>从disk-&gt;queue请求队列的hardsect_size字段中获取扇区大小(字节数)，使用该值适当地设置bdev-&gt;bd_block_size和bdev-&gt;bd_inode-&gt;i_blkbits两个字段。同时用从disk-&gt;capacity中计算来的磁盘大小设置bdev-&gt;bd_inode-&gt;i_size字段。</li>
<li>如果设置了bdev-&gt;bd_invalidated标志，那么调用rescan_partitions()扫描分区表并更新分区描述符。该标志是由check_disk_change块设备方法设置的，仅适用于可移动设备。</li>
</ol>
</li>
<li><p>否则如果块设备是一个分区，则执行下列子步骤：</p>
<blockquote>
<ol>
<li>再次调用bdget()——这次是传递disk-&gt;first_minor次设备号——获取整盘的块描述符地址whole。</li>
<li>对整盘的块设备描述符重复第3步～第6步，如果需要则初始化该描述符。</li>
<li>将bdev-&gt;bd_contains设置为整盘描述符的地址。</li>
<li>增加whole-&gt;bd_part_count的值从而说明磁盘分区上新的打开操作。</li>
<li>用disk-&gt;part[part - 1]中的值设置bdev-&gt;bd_part；它是分区描述符hd_struct的地址。同样，执行kobject_get(&amp;bdev-&gt;bd_part-&gt;kobj)增加分区引用计数器的值。</li>
<li>与第6.2步中的一样，设置索引节点中表示分区大小和扇区大小的字段。</li>
</ol>
</blockquote>
</li>
<li><p>增加bdev-&gt;bd_openers计数器的值。</p>
</li>
<li><p>如果块设备文件以独占方式被打开(设置了filp-&gt;f_flags中的O_EXCL标志)，那么调用bd_claim( bdev, filp)设置块设备的持有者。万一出错——块设备已经有一个拥有者——释放该块设备描述符并返回一个错误码-EBUSY。</p>
</li>
<li><p>返回0(成功)终止。</p>
</li>
</ol>
<p>blkdev_open()函数一旦终止，open()系统调用如往常一样继续进行。对已打开的文件上将来发出的每个系统调用都将触发一个缺省的块设备文件操作。</p>
<h1 id="访问文件"><a href="#访问文件" class="headerlink" title="访问文件"></a>访问文件</h1><h2 id="五种常见的模式"><a href="#五种常见的模式" class="headerlink" title="五种常见的模式"></a>五种常见的模式</h2><ol>
<li>规范模式<br>规范模式下文件打开后，标志O_SYNC与0_DIRECT清0，而且它的内容是由系统调用read()和write()来存取。系统调用read()将阻塞调用进程，直到数据被拷贝进用户态地址空间(内核允许返回的字节数少于要求的字节数)。但系统调用write()不同，它在数据被拷贝到页高速缓存(延迟写)后就马上结束。这会在“读写文件”这一节详细阐述。</li>
<li>同步模式<br>同步模式下文件打开后，标志0_SYNC置1或稍后由系统调用fcntl()对其置1。这个标志只影响写操作(读操作总是会阻塞)，它将阻塞调用进程，直到数据被有效地写入磁盘。这也会在“读写文件”这一节详细阐述。</li>
<li>内存映射模式<br>内存映射模式下文件打开后，应用程序发出系统调用mmap()将文件映射到内存中。因此，文件就成为RAM中的一个字节数组，应用程序就可以直接访问数组元素，而不需用系统调用read()、write()或lseek()。这将在“内存映射”这一节详细阐述。</li>
<li>直接I/O模式<br>直接I/O模式下文件打开后，标志0_DIRECT置1。任何读写操作都将数据在用户态地址空间与磁盘间直接传送而不通过页高速缓存。这将在“直接I/O传送”这一节详细阐述。(标志O_SYNC和O_DIRECT的值可以有四种组合。)</li>
<li>异步模式<br>异步模式下，文件的访问可以有两种方法，即通过一组POSIX APl或Linux特有的系统调用来实现。所谓异步模式就是数据传输请求并不阻塞调用进程，而是在后台执行，同时应用程序继续它的正常运行。这将在“异步I/O”这一节详细阐述。</li>
</ol>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>​    在第十二章的“read()和write()<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=系统调用&amp;spm=1001.2101.3001.7020">系统调用</a>”一节中已经说明了read()和write()系统调用是如何实现的。相应的服务例程最终会调用文件对象的read和write方法，这两个方法可能依赖文件系统。对磁盘文件系统来说，这些方法能够确定正被访问的数据所在物理块的位置，并激活块设备驱动程序开始数据传送。读文件是基于页的，内核总是一次传送几个完整的数据页。如果进程发出read()系统调用来读取一些字节，而这些数据还不在RAM中，那么，内核就要分配一个新页框，并使用文件的适当部分来填充这个页，把该页加入页高速缓存，最后把所请求的字节拷贝到进程地址空间中。</p>
<p>​    对于大部分<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=文件系统&amp;spm=1001.2101.3001.7020">文件系统</a>来说，从文件中读取一个数据页就等同于在磁盘上查找所请求的数据存放在哪些块上。只要这个过程完成了，内核就可以通过向通用块层提交适当的I/O操作来填充这些页。事实上，大多数磁盘文件系统的read方法是由名为generic_file_read()的通用函数实现的。</p>
<p>​    对基于磁盘的文件来说，写操作的处理相当复杂，因为文件大小可以改变，因此内核可能会分配磁盘上的一些物理块。当然，这个过程到底如何实现要取决于文件系统的类型。不过，很多磁盘文件系统是通过通用函数generic_file_write()实现它们的write方法的。这样的文件系统如Ext2、System V/Coherent/Xenix及Minix。另一方面，还有几个文件系统(如日志文件系统和网络文件系统)通过自定义的函数实现它们的write方法。</p>
<h3 id="从文件中读取数据"><a href="#从文件中读取数据" class="headerlink" title="从文件中读取数据"></a>从文件中读取数据</h3><p>让我们讨论一下generic_file_read()函数，该函数实现了几乎所有磁盘文件系统中的普通文件及任何块设备文件的read方法。该函数作用于以下参数：</p>
<pre class="line-numbers language-none"><code class="language-none">filp：文件对象的地址
buf：用户态线性区的线性地址，从文件中读出的数据必须存放在这里
count：要读取的字符个数
ppos：指向一个变量的指针，该变量存放读操作开始处的文件偏移量(通常为filp文件对象的f_pos字段)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    第一步，函数初始化两个描述符。第一个描述符存放在类型为iovec的局部变量local_iov 中；它包含用户态缓冲区的地址(buf)与长度(count)，该缓冲区用来存放待<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=读文件&amp;spm=1001.2101.3001.7020">读文件</a>中的数据。第二个描述符存放在类型为kiocb的局部变量kiocb中；它用来跟踪正在运行的同步和异步I/O操作的完成状态。函数generic_file_read()通过执行宏init_sync_kiocb来初始化描述符kiocb，并设置一个同步操作对象的有关字段。具体地说就是，该宏设置ki_key字段为KIOCB_SYNC_KEY、ki_filp字段为filp、ki_obj字段为current。然后，generic_file_read()调用__generic_file_aio_read()并将刚填完的iovec 和kiocb描述符地址传给它。后面这个函数返回一个值，这个值通常就是从文件有效读入的字节数。generic_file_read()返回值后结束。</p>
<p>函数_generic_file_aio_read()是所有文件系统实现同步和异步读操作所使用的通用例程。该函数接受四个参数：</p>
<ol>
<li>kiocb描述符的地址iocb，</li>
<li>iovec描述符数组的地址iov、</li>
<li>数组的长度</li>
<li>存放文件当前指针的一个变量的地址ppos。</li>
</ol>
<p>iovec描述符数组被函数generic_file_read()调用时只有一个元素，该元素描述待接收数据的用户态缓冲区。<br>我们现在来说明函数__generic_file_aio_read()的操作。为简单起见，我们只针对最常见的情形，即对页高速缓存文件的系统调用read()所引发的同步操作。本章后面我们会阐述该函数执行的其他情形。同样，我们不讨论如何对错误和异常的处理。</p>
<p>generic_file_read该函数执行的步骤如下：</p>
<ol>
<li>调用access_ok()来检查iovec描述符所描述的用户态缓冲区是否有效。因为起始地址和长度已经从sys_read()服务例程得到，因此在使用前需要对它们进行检查(参见第十章“验证参数”一节)。如果参数无效，则返回错误代码-EFAULT。</li>
<li>建立一个读操作描述符，也就是一个read_descriptor_t类型的数据结构。该结构存放与单个用户态缓冲相关的文件读操作的当前状态。该描述符的字段参见表16-2。</li>
<li>调用函数do_generic_file_read()，传送给它文件对象指针filp、文件偏移量指针ppos、刚分配的读操作描述符的地址和函数file_read_actor()的地址(后面还会阐述)。</li>
<li>返回拷贝到用户态缓冲区的字节数，即read_descriptor_t数据结构中written字段的值。</li>
</ol>
<h3 id="函数do-generic-file-read"><a href="#函数do-generic-file-read" class="headerlink" title="函数do_generic_file_read()"></a>函数do_generic_file_read()</h3><p>​    从磁盘读入所请求的页并把它们拷贝到用户态缓冲区。具体执行如下步骤：</p>
<ol>
<li><p>获得要读取的文件对应的address_space对象；它的地址存放在filp-&gt;f_mapping。</p>
</li>
<li><p>获得地址空间对象的所有者，即索引节点对象，它将拥有填充了文件数据的页面。它的地址存放在address_space对象的host字段中。如果所读文件是块设备文件，那么所有者就不是由filp-&gt;f_dentry-&gt;d_inode所指向的索引节点对象，而是bdev特殊文件系统中的索引节点对象。</p>
</li>
<li><p>把文件看作细分的数据页(每页4096字节)，并从文件指针*ppos导出第一个请求字节所在页的逻辑号，即地址空间中的页索引，并把它存放在index局部变量中。也把第一个请求字节在页内的偏移量存放在offset局部变量中。</p>
</li>
<li><p>开始一个循环来读入包含请求字节的所有页，要读数据的字节数存放在read_descriptor_t描述符的count字段中。在一次单独的循环期间，函数通过执行下列的子步骤来传送一个数据页：</p>
<blockquote>
<ol>
<li>如果index*4096+offset超过存放在索引节点对象的i_size字段中的文件大小，则从循环退出，并跳到第5步。</li>
<li>调用cond_resched()来检查当前进程的标志TIF_NEED_RESCHED。如果该标志置位，则调用函数schedule()。</li>
<li>如果有预读的页，则调用page_cache_readahead()读入这些页面。</li>
<li>调用find_get_page()，并传入指向address_space对象的指针及索引值作为参数；它将查找页高速缓存以找到包含所请求数据的页描述符(如果有的话)。</li>
<li>如果find_get_page()返回NULL指针，则所请求的页不在页高速缓存中。如果这样，它将执行如下步骤：</li>
</ol>
<blockquote>
<ol>
<li>调用handle_ra_miss()来调整预读系统的参数。</li>
<li>分配一个新页。</li>
<li>调用add_to_page_cache()插入该新页描述符到页高速缓存中。记住该函数将新页的PG_locked标志置位。</li>
<li>调用lru_cache_add()插入新页描述符到LRU链表。</li>
<li>跳到第4j步，开始读文件数据。</li>
</ol>
</blockquote>
<ol>
<li><p>如果函数已运行至此，说明页已经位于页高速缓存中。检查标志PG_uptodate；如果置位，则页所存数据是最新的，因此无需从磁盘读数据。跳到第4m步。</p>
</li>
<li><p>页中的数据是无效的，因此必须从磁盘读取。函数通过调用lock-page()函数获取对页的互斥访问。如果PG_locked已经置位，则lock_page()阻塞当前进程直到标志被清0。</p>
</li>
<li><p>现在页已由当前进程锁定。然而，另一个进程也许会在上一步之前已从页高速缓存中删除该页，那么，它就要检查页描述符的mapping字段是否为NULL。在这种情形下，它将调用unlock_page()来解锁页，减少它的引用计数(find get_page()增加计数)，并跳回第4a步来重读同一页。</p>
</li>
<li><p>如果函数已运行至此，说明页已被锁定且在页高速缓存中。再次检查标志PG_uptodate，因为另一个内核控制路径可能已经完成第4f步和第4g步的必要读操作。如果标志置位，则调用unlock_page()并跳至第4m来跳过读操作。</p>
</li>
<li><p>现在真正的I/O操作可以开始了，调用文件的address_spac对象之readpage方法。相应的函数会负责激活磁盘到页之间的I/O数据传输。我们以后再讨论该函数对普通文件与块设备文件都会做些什么。</p>
</li>
<li><p>如果标志PG_uptodate还没有置位，则它会等待直到调用lock_page()函数后页被有效读入。该页在第4g步中锁定，一旦读操作完成就被解锁。因此当前进程在I/O数据传输完成时才停止睡眠。</p>
</li>
</ol>
<ol>
<li><p>如果index超出文件包含的页数(该数是通过将inode对象的i_size字段的值除于4096得到的)，那么它将减少页的引用计数器，并跳出循环至第5步。这种情况发生在这个正被本进程读的文件同时有其他进程正在删减它的时候。</p>
</li>
<li><p>将应被拷入用户态缓冲区的页中的字节数存放在局部变量nr中。这个值应该等于页的大小(4096字节)，除非offset非0(这只发生在读请求书的首尾页时)或请求数据不全在该文件中。</p>
</li>
<li><p>调用mark_page_accessed()将标志PG_referenced或PG_active置位，从而表示该页正被访问并且不应该被换出。如果同一文件(或它的一部分)在do_generic_file_read()的后续执行中要读几次，那么这个步骤只在第一次读时执行。</p>
</li>
<li><p>现在到了把页中的数据拷贝到用户态缓冲区的时候了。为了这么做，o_generic_file_read()调用file_read_actor()函数，该函数的地址作为参数传递。</p>
</li>
</ol>
<p>file_read_actor()执行下列步骤</p>
<blockquote>
<ol>
<li>调用kmap()，该函数为处于高端内存中的页建立永久的内核映射。</li>
<li>调用__copy_to_user()，该函数把页中的数据拷贝到用户态地址空间。注意，这个操作在访问用户态地址空间时如果有缺页异常将会阻塞进程。</li>
<li>调用kunmap()来释放页的任一永久内核映射。</li>
<li>更新read_descriptor_t描述符的count、written和buf字段。</li>
</ol>
</blockquote>
<ol>
<li>根据传入用户态缓冲区的有效字节数来更新局部变量index和count。一般情况下，如果页的最后一个字节已拷贝到用户态缓冲区，那么index的值加1而offset的值清0；否则，index的值不变而offset的值被设为已拷贝到用户态缓冲区的字节数。</li>
<li>减少页描述符的引用计数器。</li>
<li>如果read_descriptor_t描述符的count字段不为0，那么文件中还有其他数据要读，跳至第4a步继续循环来读文件中的下一页数据。</li>
</ol>
</blockquote>
</li>
<li><p>所有请求的或者说可以读到的数据已读完。函数更新预读数据结构filp-&gt;f_ra来标记数据已被顺序从文件读入。</p>
</li>
<li><p>把index<em>4096+offset值赋给</em>ppos，从而保存以后调用read()和write()进行顺序访问的位置。</p>
</li>
<li><p>调用update_atime()把当前时间存放在文件的索引节点对象的i_atime字段中，并把它标记为脏后返回。</p>
</li>
</ol>
<h4 id="普通文件的readpage方法"><a href="#普通文件的readpage方法" class="headerlink" title="普通文件的readpage方法"></a>普通文件的readpage方法</h4><p>​    我们从前一节看到，do_generic_file_read()反复使用readpage方法把一个个页从磁盘读到内存中。address_space对象的readpage方法存放的是函数地址，这种函数有效地激活从物理磁盘到页高速缓存的I/O数据传送。对于普通文件，这个字段通常指向调用mpage_readpage()函数的封装函数。例如，Ext3文件系统的readpage方法由下列函数实现：</p>
<pre class="line-numbers language-none"><code class="language-none">int ext3_readpage(struct file *file,struct page *page)
&#123;
	return mpage_readpage(page,ext3_get_block);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    需要封装函数是因为mpage_readpage()函数接收的参数为待填充页的页描述符page及有助于mpage_readpage()找到正确块的函数的地址get_block。封装函数依赖文件系统并因此能提供适当的函数来得到块。这个函数把相对于文件开始位置的块号转换为相对于磁盘分区中块位置的逻辑块号。当然，后一个参数依赖于普通文件所在文件系统的类型；在前面的例子中，这个参数就是ext3_get_block()函数的地址。</p>
<p>​    所传递的get_block函数总是用缓冲区首部来存放有关重要信息，如块设备(b_dev字段)、设备上请求数据的位置(b_blocknr字段)和块状态(b_state字段)。get_block函数依赖于文件系统，它的一个重要作用就是：确定文件中的下一块在磁盘上是否也是下一块。</p>
<p>函数mpage_readpage()在从磁盘读入一页时可选择两种不同的策略。如果包含请求数据的块在磁盘上是连续的，那么函数就用单个bio描述符向通用块层发出读I/O操作。而如果不连续，函数就对页上的每一块用不同的bio描述符来读。</p>
<p>mpage_readpage()函数执行下列步骤：</p>
<ol>
<li>检查页描述符的PG_private字段：如果置位，则该页是缓冲区页，也就是该页与描述组成该页的块的缓冲区首部链表相关。这意味着该页过去已从磁盘读入过，而且页中的块在磁盘上不是相邻的。跳到第11步，用一次读一块的方式读该页。</li>
<li>得到块的大小(存放在page-&gt;mapping-&gt;host-&gt;i_blkbits索引节点字段)，然后计算出访问该页的所有块所需要的两个值，即页中的块数及页中第一块的文件块号，也就是相对于文件起始位置页中第一块的索引。</li>
<li>对于页中的每一块，调用依赖于文件系统的get_block函数，作为参数传递过去，得到逻辑块号，即相对于磁盘或分区开始位置的块索引。页中所有块的逻辑块号存放在一个本地数组中。</li>
<li>在执行上一步的同时，检查可能发生的异常条件。具体有这几种情况：当一些块在磁盘上不相邻时，或某块落入“文件洞”内时，或一个块缓冲区已经由get_block函数写入时。那么跳到第11步，用一次读一块的方式读该页。</li>
<li>如果函数运行至此，说明页中的所有块在磁盘上是相邻的。然而，它可能是文件中的最后一页，因此页中的一些块可能在磁盘上没有映像。如果这样的话，它将页中相应的块缓冲区填上0；如果不是这样，它将页描述符的标志PG_mappedtodisk置位。</li>
<li>调用bio_alloc()分配包含单一段的一个新bio描述符，并且分别用块设备描述符地址和页中第一个块的逻辑块号来初始化bi_bdev字段和bi_sector字段。这两个信息已在上面的第3步中得到。</li>
<li>用页的起始地址、所读数据的首字节偏移量(0)和所读的字节总数设置bio段的bio_vec描述符。</li>
<li>将mpage_end_io_read()函数的地址赋给bio-&gt;bi_end_io字段。</li>
<li>调用submit_bio()，它将用数据传输的方向设定bi_rw标志，更新每CPU变量page_states来跟踪所读扇区数，并在bio描述符上调用generic_make_request()函数。</li>
<li>返向0(成功)。</li>
<li>如果函数跳至这里，则页中含有的块在磁盘上不连续。如果页是最新的(PG_uptodate置位)，函数就调用unlock_page()来对该页解锁；否则调用block_read_full_page()用一次读一块的方式读该页(见下面)。</li>
<li>返回0(成功)。</li>
</ol>
<p>​    函数mpage_end_io_read()是bio的完成方法，一旦I/O数据传输结束它就开始执行。假定没有I/O错误，该函数将页描述符的标志PC_uptodate置位，调用unlock_page()来对该页解锁并唤醒任何因为该事件而睡眠的进程，然后调用bio_put()来清除bio描述符。</p>
<h4 id="块设备文件的readpage方法"><a href="#块设备文件的readpage方法" class="headerlink" title="块设备文件的readpage方法"></a>块设备文件的readpage方法</h4><p>在第十三章“设备文件的VFS处理”一节和第十四章的“打开块设备文件”一节中，我们讨论了内核如何处理请求以打开块设备文件。我们还看到init_special_inode()函数如何建立设备的索引节点及blkdev_open()如何完成其打开阶段。在bdev特殊文件系统中，块设备使用address_space对象，该对象存放在对应块设备索引节点的i_data字段。不像普通文件(在address_space对象中它的readpage方法依赖于文件所属的文件系统的类型)，块设备文件的readpage方法总是相同的。它是由blkdev_readpage()函数实现的，该函数调用block_read_full_page()：</p>
<pre class="line-numbers language-none"><code class="language-none">int blkdev_readpage(struct file *file,struct * page page)&#123;
	return block_read_full_page(page, blkdev_get_block);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>正如你看到的，这个函数又是一个封装函数，这里是block_read_full_page()函数的封装函数。这一次，第二个参数也指向一个函数，该函数把相对于文件开始处的文件块号转换为相对于块设备开始处的逻辑块号。不过，对于块设备文件来说，这两个数是一致的；因此，blkdev_get_block()函数执行下列步骤：</p>
<ol>
<li><p>检查页中第一个块的块号是否超过块设备的最后一块的索引值(存放在bdev-&gt;bd_inode-&gt;i_size中的块设备大小除以存放在bdev-&gt;bd_block_size中的块大小得到该索引值；bdev指向块设备描述符)。如果超过，那么对于写操作它返回-EIO，而对于读操作它返回0。<br>(超出块设备读也是不允许的，但不返回错误代码。内核可以对块设备的最后数据试着发出读请求，而得到的缓冲区页只被部分映射)。</p>
</li>
<li><p>设置缓冲区首部的b_dev字段为b_dev。</p>
</li>
<li><p>设置缓冲区首部的b_blocknr字段为文件块号，它将被作为参数传给本函数。</p>
</li>
<li><p>把缓冲区首部的BH_Mapped标志置位，以表明缓冲区首部的b_dev和b_blocknr字段是有效的。函数block_read_full_page()以一次读一块的方式读一页数据。正如我们已看到的，当读块设备文件和磁盘上块不相邻的普通文件时都使用该函数。它执行如下步骤：</p>
</li>
<li><p>检查页描述符的标志PG_private，如果置位，则该页与描述组成该页的块的缓冲区首部链表相关；否则，调用create_empty_buffers()来为该页所含所有块缓冲区分配缓冲区首部。页中第一个缓冲区的缓冲区首部地址存放在page-&gt;private字段中。每个缓冲区首部的b_this_page字段指向该页中下一个缓冲区的缓冲区首部。</p>
</li>
<li><p>从相对于页的文件偏移量(page-&gt;index字段)计算出页中第一块的文件块号。</p>
</li>
<li><p>对该页中每个缓冲区的缓冲区首部，执行如下子步骤：</p>
<blockquote>
<ol>
<li>如果标志BH_Uptodate置位，则跳过该缓冲区继续处理该页的下一个缓冲区。</li>
<li>如果标志BH_Mapped未置位，并且该块未超出文件尾，则调用依赖于文件系统的get_block函数，该函数的地址已被作为参数得到。对于普通文件，该函数在文件系统的磁盘数据结构中查找，得到相对于磁盘或分区开始处的缓冲区逻辑块号。对于块设备文件，不同的是该函数把文件块号当作逻辑块号。对这两种情形，函数都将逻辑块号存放在相应缓冲区首部的b_blocknr字段中，并将标志BH_Mapped置位。（BH_Mapped表示内存得块缓存区是否映射到了磁盘某个块缓冲区）</li>
<li>再检查标志BH_Uptodate，因为依赖于文件系统的get_block函数可能已触发块I/O操作而更新了缓冲区。如果BH_Uptodate置位，则继续处理该页的下一个缓冲区。</li>
<li>将缓冲区首部的地址存放在局部数组arr中，继续该页的下一个缓冲区。</li>
</ol>
</blockquote>
</li>
<li><p>假如上一步中没遇到“文件洞”，则将该页的标志PG_mappedtodisk置位。</p>
</li>
<li><p>现在局部变量arr中存放了一些缓冲区首部的地址，与其对应的缓冲区的内容不是最新的。如果数组为空，那么页中的所有缓冲区都是有效的，因此，该函数设置页描述符的PG_uptodate标志，调用unlock_page()对该页解锁并返回。</p>
</li>
<li><p>局部数组arr非空。对数组中的每个缓冲区首部，block_read_full_page()执行下列子步骤：</p>
<blockquote>
<p>将BH_Lock标志置位。该标志一旦置位，函数将一直等到该缓冲区释放。</p>
<p>将缓冲区首部的b_end_io字段设为end_buffer_async_read()函数的地址，并将缓冲区首部的BH_Async_Read标志置位。</p>
</blockquote>
</li>
<li><p>对局部数组arr中的每个缓冲区首部调用submit_bh()，将操作类型设为READ。就像我们在前面看到的那样，该函数触发了相应块的I/O数据传输。</p>
</li>
<li><p>返回0。<br>函数end_buffer_async_read()是缓冲区首部的完成方法。对块缓冲区的I/O数据传输一结束，它就执行。假定没有I/O错误，函数将缓冲区首部的BH_Uptodate标志置位而将BH_Async_Read标志清0。那么，函数就得到包含块缓冲区的缓冲区页描述符(它的地址存放在缓冲区首部的b_page字段中)，同时检查是否页中所有块是最新的；如果是，函数将该页的PG_uptodate标志置位并调用unlock_page()。</p>
</li>
</ol>
<h4 id="文件的预读"><a href="#文件的预读" class="headerlink" title="文件的预读"></a>文件的预读</h4><p>很多磁盘的访问都是顺序的。我们在第十八章会看到，普通文件以相邻扇区成组存放在磁盘上，因此很少移动磁头就可以快速检索到文件。当程序读或拷贝一个文件时，它通常从第一个字节到最后一个字节顺序地访问文件。因此，在处理进程对同一文件的一系列读请求时，可以从磁盘上很多相邻的扇区读取。</p>
<p>预读(read-ahead)是一种技术，这种技术在于在实际请求前读普通文件或块设备文件的几个相邻的数据页。在大多数情况下，预读能极大地提高磁盘的性能，因为预读使磁盘控制器处理较少的命令，其中的每条命令都涉及一大组相邻的扇区。此外，预读还能提高系统的响应能力。顺序读取文件的进程通常不需要等待请求的数据，因为请求的数据已经在RAM中了。但是，预读对于随机访问的文件是没有用的；在这种情况下，预读实际上是有害的，因为它用无用的信息浪费了页高速缓存的空间。因此，当内核确定出最近所进行的I/O访问与前一次I/O访问不是顺序的时就减少或停止预读。</p>
<p>文件的预读需要更复杂的算法，这是由于以下几个原因：</p>
<ul>
<li>由于数据是逐页进行读取的，因此预读算法不必考虑页内偏移量，只要考虑所访问的页在文件内部的位置就可以了。</li>
<li>只要进程持续地顺序访问一个文件，预读就会逐渐增加。</li>
<li>当前的访问与上一次访问不是顺序的时(随机访问)，预读就会逐渐减少乃至禁止。</li>
<li>当一个进程重复地访问同一页(即只使用文件的很小一部分)时，或者当几乎所有的页都已在页高速缓存内时，预读就必须停止。低级I/O设备驱动程序必须在合适的时候激活，这样当将来进程需要时，页已传送完毕。</li>
</ul>
<p>如果请求的第一页紧跟上次访问所请求的最后一页，那么相对于上次的文件访问，内核把文件的这次访问看作是顺序的。当访问给定文件时，预读算法使用两个页面集，各自对应文件的一个连续区域。这两个页面集分别叫做当前窗(current window)和预读窗(ahead window)。</p>
<p>当前窗内的页是进程请求的页和内核预读的页，且位于页高速缓存内(当前窗内的页不必是最新的，因为I/O数据传输仍可能在运行中)。当前窗包含进程顺序访问的最后一页，且可能有内核预读但进程未请求的页。预读窗内的页紧接着当前窗内的页，它们是内核正在预读的页。预读窗内的页都不是进程请求的，但内核假定进程会迟早请求。当内核认为是顺序访问而且第一页在当前窗内时，它就检查是否建立了预读窗。如果没有，内核创建一个预读窗并触发相应页的读操作。理想情况下，进程继续从当前窗请求页，同时预读窗的页则正在传送。当进程请求的页在预读窗，那么预读窗就成为当前窗。预读算法使用的主要数据结构是file_ra_state描述符，它的字段见表16-3。每个文件对象在它的f_ra字段中存放这样的一个描述符。</p>
<ul>
<li>start 当前窗内第一页的索引</li>
<li>size  当前窗内的页数（当临时禁止预读时为一1，0表示当  前窗空）</li>
<li>flags  控制预读的一些标志</li>
<li>cache_hit 连续高速缓存命中数（进程请求的页同时又在页高递 缓存内）</li>
<li>prev_page 预读窗内第一页的索引  </li>
<li>ahead_start 进程请求的最后一页的索引  </li>
<li>ahead_size 预读窗的页数（0表示预读窗口空）  </li>
<li>ra_pages  预读窗的最大页数（0表示预读窗永久禁止）</li>
<li>mmap_hit  预读命中计数器（用于内存映射文件）  </li>
<li>mmap_miss  预读失败计数器  （用于内存映射文件）</li>
</ul>
<p>​    当一个文件被打开时，在它的file_ra_state描述符中，除了prev_page和ra_pages 这两个字段，其他的所有字段都置为0。prev_page字段存放着进程在上一次读操作中所请求页的最后一页的索引，它的初值是-1。ra_pages字段表示当前窗的最大页数，即对该文件允许的最大预读量。该字段的初始值(缺省值)存放在该文件所在块设备的backing_dev_info描述符中。一个应用可以修改一个打开文件的ra_pages字段从而调整预读算法；具体的实现方法是调用posix_fadvise()系统调用，并传给它命令POSIX_FADV_NORMAL(设最大预读量为缺省值，通常是32页)、POSIX_FADV_SEQUENTIAL (设最大预读量为缺省值的两倍)和POSIX_FADV_RANDOM(最大预读量为0，从而永久禁止预读)。</p>
<p>​    flags字段内有两个重要的字段RA_FLAG_MISS和RA_FLAG_INCACHE。如果已被预读的页不在页高速缓存内(可能的原因是内核为了释放内存而加以收回了)，则第一个标志置位，这时候下一个要创建的预读窗大小将被缩小。当内核确定进程请求的最后256页都在页高速缓存内时(连续高速缓存命中数存放在ra-&gt;cache_hit字段中)，第二个标志置位，这时内核认为所有的页都已在页高速缓存内，进而关闭预读。</p>
<p>何时执行预读算法？这有下列几种情形：</p>
<ol>
<li>当内核用用户态请求来读文件数据的页时。这一事件触发page_cache_readahead()函数的调用。</li>
<li>当内核为文件内存映射分配一页时。</li>
<li>当用户态应用执行readahead()系统调用时，它会对某个文件描述符显式触发某预读活动。</li>
<li>当用户态应用使用POSIX_FADV_NOREUSE或POSIX_FADV_WILLNEED命令执行posix_fadvise()系统调用时，它会通知内核，某个范围的文件页不久将要被访问。</li>
<li>当用户态应用使用MADV_WILLNEED命令执行madvise()系统调用时，它会通知内核，某个文件内存映射区域中的给定范围的文件页不久将要被访问。</li>
</ol>
<h4 id="page-cache-readahead-函数"><a href="#page-cache-readahead-函数" class="headerlink" title="page_cache_readahead()函数"></a>page_cache_readahead()函数</h4><p>​    page_cache_readahead()函数处理没有被特殊系统调用显式触发的所有预读操作。它填写当前窗和预读窗，根据预读命中数更新当前窗和预读窗的大小，也就是根据过去对文件访问预读策略的成功程度来调整。当内核必须满足对某个文件一页或多页的读请求时，函数就被调用，该函数有下面五个参数：</p>
<ul>
<li>mapping描述页所有者的address_space对象指针</li>
<li>ra包含该页的文件file_ra_state描述符指针</li>
<li>filp文件对象地址</li>
<li>offset文件内页的偏移量</li>
<li>req_size要完成当前读操作还需要读的页数</li>
</ul>
<p>图16-1是page_cache_readahead()的流程图。该函数基本上作用于file_ra_state 描述符的字段，因此，尽管流程图中的行为描述不很正规，你还是能很容易地确定函数执行的实际步骤。例如，为了检查请求页是否与刚读的页相同，函数检查ra-&gt;prev_page字段的值和offset参数的值是否一致。当进程第一次访问一个文件，并且其第一个请求页是文件中偏移量为0的页时，函数假定进程要进行顺序访问。那么，函数从第一页创建一个新的当前窗。初始当前窗的长度(总是为2的幂)与进程第一个读操作所请求的页数有一定的联系。</p>
<p>请求页数越大，当前窗越大，一直到最大值，最大值存放在ra-&gt;ra_pages字段。反之，当进程第一次访问文件，但其第一个请求页在文件中的偏移量不为0时，函数假定进程不是执行顺序读。那么，函数暂时禁止预读(ra-&gt;size字段设为-1)。但是当预读暂时被禁止而函数又认为需要顺序访问时，将建立一个新的当前窗。如果预读窗不存在，一旦函数认为在当前窗内进程执行了顺序读，则预读窗将被建立。预读窗总是从当前窗的最后一页开始。但它的长度与当前窗的长度相关：如果RA_FLAG_MISS标志置位，则预读窗长度是当前窗长度减2，小于4时设为4；否则，预读窗长度是当前窗长度的4倍或2倍。如果进程继续顺序这样，随着进程顺序地读文件，预读会大大地增强。</p>
<p><img src=".\image-20240503151926889.png" alt="image-20240503151926889"></p>
<p>一旦函数认识到对文件的访问相对于上一次不是顺序的，当前窗与预读窗就被清空，预读被暂时禁止。当进程的读操作相对于上一次文件访问为顺序时，预读将重新开始。每次page_cache_readahead()创建一个新窗，它就开始对所包含页的读操作。 为了读一大组页，函数page_cache_readahead()调用blockable_page_cache_readahead()。</p>
<p>为减少内核开销，后面这个函数采用下面灵活的方法：</p>
<ol>
<li>如果服务于块设备的请求队列是读拥塞的，就不进行读操作。</li>
<li>将要读的页与页高速缓存进行比较，如果该页已在页高速缓存内，跳过即可。</li>
<li>在从磁盘进行读之前，读请求所需的全部页框是一次性分配的。如果不能一次性得到全部页框，预读操作就只在可以得到的页上进行。而且把预读推迟至所有页框都得到时再进行并没有多大意义。</li>
<li>只要可能，通过使用多段bio描述符向通用块层发出读操作。这通过address_space对象专用的readpages方法实现(假如已定义)；如果没有定义，就通过反复调用readpage方法来实现。readpage方法在前面“从文件中读取数据”一节中对于单段情形有详细描述，但稍作修改就可以很容易地将它用于多段情形。</li>
</ol>
<h4 id="handle-ra-miss-函数"><a href="#handle-ra-miss-函数" class="headerlink" title="handle_ra_miss()函数"></a>handle_ra_miss()函数</h4><p>在某些情况下，预读策略似乎不是十分有效，内核就必须修正预读参数。让我们考虑本章前面“从文件中读取数据”一节中描述的do_generic_file_read()函数。在第4c步中调用函数page_cache_readahead()。</p>
<p>图16-1中展示了两种情形：请求页在当前窗或预读窗表明它已经被预先读入了；或者还没有，则调用blockable_page_cache_readahead()来读入。在这两种情形下，函数do_generic_file_read()应该在第4d步中就在页高速缓存中找到了该页，如果没有，就表示该页框已被收回算法从高速缓存中删除。在这种情形下，do_generic_file_read()调用handle_ra_miss()函数，这个函数会通过将RA_FLAG_MISS标志置位与RA_FLAG_INCACHE标志清0来调整预读算法。</p>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>回想一下，write()系统调用涉及把数据从调用进程的用户态地址空间中移动到内核数据结构中，然后再移动到磁盘上。文件对象的write方法允许每种文件类型都定义一个专用的写操作。在Linux 2.6中，每个磁盘文件系统的write方法都是一个过程，该过程主要标识写操作所涉及的磁盘块，把数据从用户态地址空间拷贝到页高速缓存的某些页中，然后把这些页中的缓冲区标记成脏。许多文件系统(包括Ext2或JFS)通过generic_file_write()函数来实现文件对象的write 方法。它有如下参数：</p>
<ol>
<li>file文件对象指针</li>
<li>buf用户态地址空间中的地址，必须从这个地址获取要写入文件的字符</li>
<li>count要写入的字符个数</li>
<li>ppos存放文件偏移量的变量地址，必须从这个偏移量处开始写入</li>
</ol>
<p>该函数执行以下操作：</p>
<ol>
<li>初始化iovec类型的一个局部变量，它包含用户态缓冲区的地址与长度。</li>
<li>确定所写文件索引节点对象的地址inode(file-&gt;f_mapping-&gt;host)和获得信号量(inode-&gt;i_sem)。有了这个信号量，一次只能有一个进程对某个文件发出write()系统调用。</li>
<li>调用宏init_sync_kiocb初始化kiocb类型的局部变量。就像本章前面“从文件读取数据”一节中描述的那样，该宏将ki_key字段设置为KIOCB_SYNC_KEY(同步I/O操作)、ki_filp字段设置为filp、ki_obj字段设置为current。</li>
<li>调用__generic_file_aio_write_nolock()函数(见下面)将涉及的页标记为脏，并传递相应的参数：iovec和kiocb类型的局部变量地址、用户态缓冲区的段数(这里只有一个)和ppos。</li>
<li>释放inode-&gt;i_sem信号量。</li>
<li>检查文件的O_SYNC标志、索引节点的S_SYNC标志及超级块的MS_SYNCHRONOUS标志。如果至少一个标志置位，则调用函数sync_page_range()来强制内核将页高速缓存中第4步涉及的所有页刷新，阻塞当前进程直到I/O数据传输结束。<br>然后依次地，sync_page_range()先执行address_space对象的writepages方法(如果有定义)或mpage_writepages()函数来开始这些脏页的I/O传输，然后调用generic_osync_inode()将索引节点和相关的缓冲区刷新到磁盘，最后调用wait_on_page_bit()挂起当前进程一直到全部所刷新页的PG_writeback标志清0。</li>
<li>将__generic_file_aio_write_nolock()函数的返回值返回，通常是写入的有效字节数。</li>
</ol>
<p>函数<strong>generic_file_aio_write_nolock()接收四个参数：<br>kiocb描述符的地址iocb、iovec描述符数组的地址iov、该数组的长度以及存放文件当前指针的变量的地址ppos。<br>当被generic_file_write()调用时，iovec描述符数组只有一个元素，该元素描述待写数据的用户态缓冲区。我们现在来解释</strong>generic_file_aio_write_nolock()函数的行为。为简单起见，我们只讨论最常见的情形，即对有页高速缓存的文件进行write()系统调用的一般情况。我们在本章后面会讨论该函数在其他情况下的行为。我们不讨论如何处理错误和异常条件。该函数执行如下步骤：</p>
<ol>
<li><p>调用access_ok()确定iovec描述符所描述的用户态缓冲区是有效的(起始地址和长度已从服务例程sys_write()得到，因此使用前必须对其检查。如果参数无效，则返回错误-EFAULT。</p>
</li>
<li><p>确定待写文件(file-&gt;f_mapping-&gt;host)索引节点对象的地址inode。记住：如果文件是一个块设备文件，这就是一个bdev特殊文件系统的索引节点。</p>
</li>
<li><p>将文件(file-&gt;f_mapping-&gt;backing_dev_info)的backing_dev_info描述符的地址设为current-&gt;backing_dev_info。实际上，即使相应请求队列是拥塞的，这个设置也会允许当前进程写回由file-&gt;f_mapping拥有的脏页。</p>
</li>
<li><p>如果file-&gt;flags的O_APPEND标志置位而且文件是普通文件(非块设备文件)，它将*ppos设为文件尾，从而新数据将都追加到文件的后面。</p>
</li>
<li><p>对文件大小进行几次检查。比如，写操作不能把一个普通文件增大到超过每用户的上限或文件系统的上限，每用户上限存放在current-&gt;sigmal-&gt;rlim[RLIMIT_FSIZE]，文件系统上限存放在inode-&gt;i_sb-&gt;s_maxbytes。另外，如果文件不是“大型文件”(当file-&gt;f_flags的O_LARGEFILE标志清0时)，那么它的大小不能超出2GB。如果没有设定所述限制，它就减少待写字节数。</p>
</li>
<li><p>如果设定，则将文件的suid标志清0，而且如果是可执行文件的话就将sgid标志也清0。我们并不要用户能修改setuid文件。</p>
</li>
<li><p>将当前时间存放在inode-&gt;mtime字段(文件写操作的最新时间)中，也存放在inode-&gt;ctime字段(修改索引节点的最新时间)中，而且将索引节点对象标记为脏。</p>
</li>
<li><p>开始循环以更新写操作中涉及的所有文件页。在每次循环期间，执行下列子步骤：</p>
<blockquote>
<ol>
<li>调用find_lock_page()在页高速缓存中搜索该页。如果函数找到了该页，则增加引用计数并将PG_locked标志置位。</li>
<li>如果该页不在页高速缓存中，则分配一个新页框并调用add_to_page_cache()在页高速缓存内插入此页。这个函数也会增加引用计数并将PG_locked标志置位。另外函数还在内存管理区的非活动链表中插入一页。</li>
<li>调用索引节点(file→f-mapping)中address_space对象的prepare_write方法。对应的函数会为该页分配和初始化缓冲区首部。我们在后面的章节中再讨论该函数对于普通文件和块设备文件做些什么。</li>
<li>如果缓冲区在高端内存中，则建立用户态缓冲区的内核映射，然后它调用__copy_from_user()把用户态缓冲区中的字符拷贝到页中，并且释放内核映射。</li>
<li>调用索引节点(file→f-mapping)中address_space对象的commit_write方法。对应的函数把基础缓冲区标记为脏，以便随后把它们写到磁盘。我们在后面两节讨论该函数对于普通文件和块设备文件做些什么。</li>
<li>调用unlock_page()清PG_locked标志，并唤醒等待该页的任何进程。</li>
<li>调用mark_page_accessed()来为内存回收算法更新页状态。</li>
<li>减少页引用计数来撤销第8a或8b步中的增加值。</li>
<li>在这一步，还有另一页被标记为脏，它检查页高速缓存中脏页比例是否超过一个固定的阈值(通常为系统中页的40%)。如果这样，则调用writeback_inodes()来刷新几十页到磁盘。</li>
<li>调用cond_resched()来检查当前进程的TIF_NEED_RESCHED标志。如果该标志置位，则调用schedule()函数。</li>
</ol>
</blockquote>
</li>
<li><p>现在，在写操作中所涉及的文件的所有页都已处理。更新*ppos的值，让它正好指向最后一个被写入的字符之后的位置。</p>
</li>
<li><p>设置current-&gt;backing_dev_info为NULL。</p>
</li>
<li><p>返回写入文件的有效字符数后结束。</p>
</li>
</ol>
<h4 id="普通文件的prepare-write和commit-write方法"><a href="#普通文件的prepare-write和commit-write方法" class="headerlink" title="普通文件的prepare_write和commit_write方法"></a>普通文件的prepare_write和commit_write方法</h4><p>address_space对象的prepare_write和commit_write方法专用于由generic_file_write()实现的通用写操作，这个函数适用于普通文件和块设备文件。对文件的受写操作影响的每一页，调用一次这两个方法。每个磁盘文件系统都定义了自己的prepare_write方法。与读操作类似，这个方法只不过是普通函数的一个封装函数。例如，Ext2文件系统通过下列函数实现prepare_write 方法：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ext2_prepare_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> to<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">block_prepare_write</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> ext2_get_block<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    在前面“从文件读取数据”一节已经提到ext2_get_block()函数；它把相对于文件的块号转换为逻辑块号(表示数据在物理块设备上的位置)。blockprepare_write()函数通过执行下列步骤为文件页的缓冲区和缓冲区首部做准备：</p>
<ol>
<li><p>检查某页是否是一个缓冲区页(如果是则PG_Private标志置位)；如果该标志清0，则调用create_empty_buffers()为页中所有的缓冲区分配缓冲区首部。</p>
</li>
<li><p>对与页中包含的缓冲区对应的每个缓冲区首部，及受写操作影响的每个缓冲区首部，执行下列操作：</p>
<blockquote>
<ol>
<li><p>如果BH_New标志置位，则将它清0。</p>
</li>
<li><p>如果BH_New标志已清0，则函数执行下列子步骤：</p>
<blockquote>
<ol>
<li>调用依赖于文件系统的函数，该函数的地址get_block以参数形式传递过来。查看这个文件系统磁盘数据结构并查找缓冲区的逻辑块号(相对于磁盘分区的起始位置而不是普通文件的起始位置)。与文件系统相关的函数把这个数存放在对应缓冲区首部的b_blocknr字段，并设置它的BH_Mapped 标志。与文件系统相关的函数可能为文件分配一个新的物理块(例如，如果访问的块掉进普通文件的一个“洞”中)。在这种情况下，设置BH_New标志。</li>
<li>检查BH_New标志的值；如果它被置位，则调用unmap_underlying_metadata()来检查页高速缓存内的某个块设备缓冲区页是否包含指向磁盘同一块的一个缓冲区。该函数实际上调用__find_get_block()在页高速缓存内查找一个旧块。如果找到一块，函数将BH_Dirty标志清0并等待直到该缓冲区的I/O数据传输完毕。此外，如果写操作不对整个缓冲区进行重写，则用0填充未写区域。然后考虑页中的下一个缓冲区。</li>
<li>如果写操作不对整个缓冲区进行重写且它的BH_Delay和BH_Uptodate标志未置位(也就是说，已在磁盘文件系统数据结构中分配了块，但是RAM中的缓冲区并没有有效的数据映像)，函数对该块调用ll_rw_block()从磁盘读取它的内容。</li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>阻塞当前进程，直到在第2c步触发的所有读操作全部完成。</p>
</li>
<li><p>返回0。</p>
</li>
</ol>
<p>一旦prepare_write方法返回，generic_file_write()函数就用存放在用户态地址空间中的数据更新页。接下来，调用address_space对象的commit_write方法。这个方法由generic_commit_write()函数实现，几乎适用于所有非日志型磁盘文件系统。 generic_commit_write()函数执行下列步骤：</p>
<ol>
<li><p>调用__block_commit_write()函数，然后依次执行如下步骤：</p>
<blockquote>
<ol>
<li>考虑页中受写操作影响的所有缓冲区；对于其中的每个缓冲区，将对应缓冲区首部的BH_Uptodate和BH_Dirty标志置位。</li>
<li>标记相应索引节点为脏，这需要将索引节点加入超级块脏的索引节点链表。</li>
<li>如果缓冲区页中的所有缓冲区是最新的，则将PG_uptodate标志置位。</li>
<li>将页的PG_dirty标志置位，并在基树中将页标记成脏。</li>
</ol>
</blockquote>
</li>
<li><p>检查写操作是否将文件增大。如果增大，则更新文件索引节点对象的i_size字段。</p>
</li>
<li><p>返回0。</p>
</li>
</ol>
<h4 id="块设备文件的prepare-write和commit-write方法"><a href="#块设备文件的prepare-write和commit-write方法" class="headerlink" title="块设备文件的prepare_write和commit_write方法"></a>块设备文件的prepare_write和commit_write方法</h4><p>写入块设备文件的操作非常类似于对普通文件的相应操作。事实上，块设备文件的address_space对象的prepare_write方法通常是由下列函数实现的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">blkdev_prepare_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> to<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">block_prepare_write</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">,</span> blkdev_get_block<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    你可以看到，这个函数只不过是前一节讨论过的block_prepare_write()函数的封装函数。当然，唯一的差异是第二个参数，它是一个指向函数的指针，该函数必须把相对于文件开始处的文件块号转换为相对于块设备开始处的逻辑块号。回想一下，对于块设备文件来说，这两个数是一致的。用于块设备文件的commit_write方法是由下列简单的封装函数实现的：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">blkdev_commit_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">page</span> <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> from<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> to<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">block_commit_write</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> from<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>正如你所看到的，用于块设备的commit_write方法与用于普通文件的commit_write方法本质上做同样的事情。唯一的差异是这个方法不检查写操作是否扩大了文件；你根本不可能在块设备文件的末尾追加字符来扩大它。</p>
<h4 id="将脏页写到磁盘"><a href="#将脏页写到磁盘" class="headerlink" title="将脏页写到磁盘"></a>将脏页写到磁盘</h4><p>系统调用write()的作用就是修改页高速缓存内一些页的内容，如果页高速缓存内没有所要的页则分配并追加这些页。某些情况下(例如文件带O_SYNC标志打开)，I/O数据传输立即启动。但是通常I/O数据传输是延迟进行的。当内核要有效启动I/O数据传输时，就要调用文件address_space对象的writepages 方法，它在基树中寻找脏页，并把它们刷新到磁盘。例如Ext2文件系统通过下面的函数实现writepages方法：</p>
<pre class="line-numbers language-none"><code class="language-none">int ext2_writepages(struct address_space *mapping, struct writeback_control *wbc)
&#123;
	return mpage_writepages(mapping, wbc, ext2_get_block);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>你可以看到，该函数是通用mpage_writepages()的一个简单的封装函数。事实上，若文件系统没有定义writepages方法，内核则直接调用mpage_writepages()并把NULL 传给第三个参数。ext2_get_block()函数在前面“从文件读取数据”一节中已讲到过，这是一个依赖于文件系统的函数，它将文件块号转换成逻辑块号。writeback_control数据结构是一个描述符，它控制writeback写回操作如何执行。</p>
<p>mpage_writepages()函数执行下列步骤：</p>
<ol>
<li><p>如果请求队列写拥塞，但进程不希望阻塞，则不向磁盘写任何页就返回。</p>
</li>
<li><p>确定文件的首页，如果writeback_control描述符给定一个文件内的初始位置，函数将把它转换成页索引。否则，如果writeback_control描述符指定进程无需等待I/O数据传输结束，它将mapping-&gt;writeback_index的值设为初始页索引(即从上一个写回操作的最后一页开始扫描)。最后，如果进程必须等待I/O数据传输完毕，则从文件的第一页开始扫描。</p>
</li>
<li><p>调用find_get_pages_tag()在页高速缓存中查找脏页描述符。</p>
</li>
<li><p>对上一步得到的每个页描述符，执行如下步骤：</p>
<blockquote>
<ol>
<li>调用lock_page()来锁定该页。</li>
<li>确认页是有效的并在页高速缓存内(因为另一个内核控制路径可能已在第3步与第4a步间作用于该页)。</li>
<li>检查页的PG_writeback标志。如果置位，表明页已被刷新到磁盘。如果进程必须等待I/O数据传输完毕，则调用wait_on_page_bit()在PG_writeback清0之前一直阻塞当前进程；当函数结束时，以前运行的任何writeback操作都被终止。否则，如果进程无需等待，它将检查PG_dirty标志：如果PG_dirty标志现已清0，则正在运行的写回操作将处理该页，将它解锁并跳回第4a步继续下一页。</li>
<li>如果get_block的参数是NULL(没有定义writepages方法)，它将调用文件address_space对象的mapping-&gt;writepage方法将页刷新到磁盘。否则，如果get_block的参数不是NULL，它就调用mpage_writepage()函数。详见第8步。</li>
</ol>
</blockquote>
</li>
<li><p>调用cond_resched()来检查当前进程的TIF_NEED_RESCHED标志，如果该标志置位就调用schedule()函数。</p>
</li>
<li><p>如果函数没有扫描完给定范围内的所有页，或者写到磁盘的有效页数小于writeback_control描述符中原先的给定值，那么跳回第3步。</p>
</li>
<li><p>如果writeback_control描述符没有给定文件内的初始位置，它将最后一个扫描页的索引值赋给mapping-&gt;writeback_index字段。</p>
</li>
<li><p>如果在第4d步中调用了mpage_writepage()函数，而且返回了bio描述符地址，那么调用mpage_bio_submit()。像Ext2这样的典型文件系统所实现的writepage方法是一个通用的block_write_full_page()函数的封装函数，并将依赖于文件系统的get_block函数的地址作为参数传给它。就像本章前面“从文件读取数据”一节描述的block_read_full_page()一样，block_write_full_page()函数也依次执行：分配页缓冲区首部(如果还不在缓冲区页中)，对每页调用submit_bh()函数来指定写操作。</p>
</li>
</ol>
<p>​    就块设备文件而言，就用block_write_full_page()的封装函数blkdev_writepage()实现writepage 方法。许多非日志型文件系统依赖于mpage_writepage()函数而不是自定义的writepage方法。这样能改善性能，因为mpage_writepage()函数进行I/O传输时，在同一个bio描述符中聚集尽可能多的页。这就使得块设备驱动程序能利用现代硬盘控制器的DMA分散-聚集能力。</p>
<p>长话短说，mpage_writepage()函数将检查：待写页包含的块在磁盘上是否不相邻，该页是否包含文件洞，页上的某块是否没有脏或不是最新的。如果以上情况至少一条成立，函数就像上面那样仍然用依赖于文件系统的writepage方法。否则，将页追加为bio描述符的一段。bio描述符的地址将作为参数被传给函数；如果该地址为NULL，mpage_writepage()将初始化一个新的bio描述符并将地址返回给调用函数，调用函数转而在未来调用mpage_writepage()时再将该地址传回来。这样，同一个bio可以加载几个页。如果bio中某页与上一个加载页不相邻，mpage_writepage()就调用mpage_bio_submit()开始该bio的I/O数据传输，并为该页分配一个新的bio。mpage_bio_submit()函数将bio的bi_end_io方法设为mpage_end_io_write()的地址，然后调用submit_bio()开始传输。一旦数据传输成功结束，完成函数mpage_end_io_write()就唤醒那些等待页传输结束的进程，并清除bio描述符。</p>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>正如我们在第九章的“线性区”一节中已经介绍过的一样，一个线性区可以和磁盘文件系统的普通文件的某一部分或者块设备文件相关联。这就意味着内核把对线性区中页内某个字节的访问转换成对文件中相应字节的操作。这种技术称为内存映射(memory mapping)。有两种类型的内存映射：</p>
<ul>
<li>共享型（可读，可写）:在线性区页上的任何写操作都会修改磁盘上的文件；而且，如果进程对共享映射中的一个页进行写，那么这种修改对于其他映射了这同一文件的所有进程来说都是可见的。</li>
<li>私有型（只读，写入不影响磁盘，参考写时复制）::当进程创建的映射只是为读文件，而不是写文件时才会使用此种映射。出于这种目的，私有映射的效率要比共享映射的效率更高。但是对私有映射页的任何写操作都会使内核停止映射该文件中的页。因此，写操作既不会改变磁盘上的文件，对访问相同文件的其他进程也不可见。但是私有内存映射中还没有被进程改变的页会因为其他进程进行的文件更新而更新。</li>
</ul>
<p>进程可以发出一个mmap()系统调用来创建一个新的内存映射。程序员必须指定一个MAP_SHARED标志或MAP_PRIVATE标志作为这个系统调用的参数。正如你可以猜到的那样，前一种情况下，映射是共享的，而后一种情况下，映射是私有的。一旦创建了这种映射，进程就可以从这个新线性区的内存单元读取数据，也就等价于读取了文件中存放的数据。如果这个内存映射是共享的，那么进程可以通过对相同的内存单元进行写而达到修改相应文件的目的。为了撤消或者缩小一个内存映射，进程可以使用munmap()系统调用。</p>
<p>作为一条通用规则，如果一个内存映射是共享的，相应的线性区就设置了VM_SHARED标志；如果一个内存映射是私有的，那么相应的线性区就清除了VM_SHARED标志。正如我们在后面会看到的一样，对于只读共享内存映射来说，有一个特例不符合本规则。</p>
<h4 id="内存映射的数据结构"><a href="#内存映射的数据结构" class="headerlink" title="内存映射的数据结构"></a>内存映射的数据结构</h4><p>内存映射可以用下列数据结构的组合来表示：</p>
<ol>
<li>与所映射的文件相关的索引节点对象</li>
<li>所映射文件的address_space对象</li>
<li>不同进程对一个文件进行不同映射所使用的文件对象</li>
<li>对文件进行每一不同映射所使用的vm_area_struct描述符对文件进行映射的线性区所分配的每个页框所对应的页描述符<br>图16-2说明了这些数据结构是如何链接在一起的。图的左边给出了标识文件的索引节点。每个索引节点对象的i_mapping字段指向文件的address_space对象。每个address_space对象的page_tree字段又指向该地址空间的页的基树，而i_mmap字段指向第二棵树，叫做radix优先级搜索树(priority search tree，PST)，这种树由地址空间的线性区组成。PST的主要作用是为了执行“反向映射”，这是为了快速标识共享一页的所有进程。我们将在下一章中详细讨论PST，因为它们用于页框回收。对同一文件的文件对象和索引节点之间链接的建立是通过f_mapping字段达到的。</li>
</ol>
<p><img src=".\image-20240503152611483.png" alt="image-20240503152611483"></p>
<p>每个线性区描述符都有一个vm_file字段，与所映射文件的文件对象链接(如果该字段为NULL，则线性区没有用于内存映射)。第一个映射单元的位置存放在线性区描述符的vm_pgoff字段，它表示以页大小为单位的偏移量。所映射的文件那部分的长度就是线性区的大小，这可以从vm_start和vm_end字段计算出来。共享内存映射的页通常都包含在页高速缓存中；私有内存映射的页只要还没有被修改，也都包含在页高速缓存中。当进程试图修改一个私有内存映射的页时，内核就把该页框进行复制，并在进程页表中用复制的页来替换原来的页框，这是第八章中介绍的写时复制机制的应用之一。虽然原来的页框还仍然在页高速缓存中，但不再属于这个内存映射，这是由于被复制的页框替换了原来的页框。依次类推，这个复制的页框不会被插入到页高速缓存中，因为其中所包含的数据不再是磁盘上表示那个文件的有效数据。图16-2还显示了包含在页高速缓存中的几个指向内存映射文件的页的页描述符。注意图中的第一个线性区有三页，但是只为它分配了两个页框；猜想一下，大概是拥有这个线性区的进程从没有访问过第三页。</p>
<p>对每个不同的文件系统，内核提供了几个钩子(hook)函数来定制其内存映射机制。内存映射实现的核心委托给文件对象的mmap方法。对于大多数磁盘文件系统和块设备文件，这个方法是由叫做generic_file_mmap()的通用函数实现的，该函数将在下一节进行描述。文件内存映射依赖于第九章的“请求调页”一节描述的请求调页机制。事实上，一个新建立的内存映射就是一个不包含任何页的线性区。当进程引用线性区中的一个地址时，缺页异常发生，缺页异常中断处理程序检查线性区的nopage方法是否被定义。如果没有定义nopage，则说明线性区不映射磁盘上的文件；否则，进行映射，这个方法通过访问块设备处理读取的页。几乎所有磁盘文件系统和块设备文件都通过filemap_nopage()函数实现nopage方法。</p>
<h4 id="创建内存映射"><a href="#创建内存映射" class="headerlink" title="创建内存映射"></a>创建内存映射</h4><p>要创建一个新的内存映射，进程就要发出一个mmap()系统调用，并向该函数传递以下参数：</p>
<ol>
<li>文件描述符，标识要映射的文件。</li>
<li>文件内的偏移量，指定要映射的文件部分的第一个字符。</li>
<li>要映射的文件部分的长度。</li>
<li>一组标志。进程必须显式地设置MAP_SHARED标志或MAP_PRIVATE标志来指定所请求的内存映射的种类。</li>
<li>一组权限，指定对线性区进行访问的一种或者多种权限：读访问(PROT_READ)、写访问(PROT_WRITE)或执行访问(PROT_EXEC)。</li>
<li>一个可选的线性地址，内核把该地址作为新线性区应该从哪里开始的一个线索。如果指定了MAP_FIXED标志，且内核不能从指定的线性地址开始分配新线性区，那么这个系统调用失败。</li>
</ol>
<p>mmap()系统调用返回新线性区中第一个单元位置的线性地址。为了兼容起见，在80× 86体系结构中，内核在系统调用表中为mmap()保留两个表项：一个在索引90处，一个在索引192处。前一个表项对应于old_mmap()服务例程(由老的C库使用)，而后一个表项对应于sys_mmap2()服务例程(由新近的C库使用)。这两个服务例程仅在如何传递系统调用的第6个参数时有所差异。这两个服务例程都调用do_mmap_pgoff()函数。我们现在就详细介绍当创建对文件进行映射的线性区时执行的步骤。我们所讨论的是do_mmap_pgoff()的file参数(文件对象指针)非空的情形。</p>
<p>为清楚起见，我们要列举描述do_mmap_pgoff()的步骤，并指出在新条件下执行的其他步骤。</p>
<ol>
<li><p>检查是否为要映射的文件定义了mmap文件操作。如果没有，就返回一个错误码。文件操作表中的mmap值为NULL说明相应的文件不能被映射(例如，因为这是一个目录)。</p>
</li>
<li><p>函数get_unmapped_area()调用文件对象的get_unmapped_area方法，如果已定义，就为文件的内存映射分配一个合适的线性地址区间。磁盘文件系统不会定义这个方法，get_unmapped_area()函数就调用内存描述符的get_unmapped_area方法。</p>
</li>
<li><p>除了进行正常的一致性检查之外，还要对所请求的内存映射的种类(存放在mmap()系统调用的flags参数中)与在打开文件时所指定的标志(存放在file-&gt;f_mode 字段中)进行比较。根据这两个消息源，执行以下的检查：</p>
<blockquote>
<ol>
<li>如果请求一个共享可写的内存映射，就检查文件是为写入而打开的，而不是以追加模式打开的(open()系统调用的O_APPEND标志)。</li>
<li>如果请求一个共享内存映射，就检查文件上没有强制锁。</li>
<li>对于任何种类的内存映射，都要检查文件是为读操作而打开的。如果以上这些条件都不能满足，就返回一个错误码。另外，当初始化新线性区描述符的vm_flags字段时，要根据文件的访问权限和所请求的内存映射的种类设置VM_READ、VM_WRITE、VM_EXEC、VM_SHARED、VM_MAYREAD、VM_MAYWRITE、VM_MAYEXEC和VM_MAYSHARE标志。最佳情况下，对于不可写共享内存映射，标志VM_SHARED和VM_MAYWRITE清0。可以这样处理是因为不允许进程写入这个线性区的页，因此，这种映射的处理就与私有映射的处理相同。但是，内核实际上允许共享该文件的其他进程读这个线性区中的页。</li>
</ol>
</blockquote>
</li>
<li><p>用文件对象的地址初始化线性区描述符的vm_file字段，并增加文件的引用计数器。对映射的文件调用mmap方法，将文件对象地址和线性区描述符地址作为参数传给它。对于大多数文件系统，该方法由generic_file_mmap()实现，它执行下列步骤：</p>
<blockquote>
<ol>
<li><p>将当前时间赋给文件索引节点对象的i_atime字段，并将该索引节点标记为脏。</p>
</li>
<li><p>用generic_file_vm_ops表的地址初始化线性区描述符的vm_ops字段。在这个表中的方法，除了nopage和populate方法外，其他所有都为空。nopage方法由filemap_nopage()实现，而populate方法由filemap_populate()实现。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>增加文件索引节点对象i_writecount字段的值，该字段就是写进程的引用计数器。</p>
</li>
</ol>
<h4 id="撤消内存映射"><a href="#撤消内存映射" class="headerlink" title="撤消内存映射"></a>撤消内存映射</h4><p>当进程准备撤消一个内存映射时，就调用munmap()；该系统调用还可用于减少每种内存区的大小。给它传递的参数如下：要删除的线性地址区间中第一个单元的地址。要删除的线性地址区间的长度。</p>
<p>该系统调用的sys_munmap()服务例程实际上是调用do_munmap()函数。注意，不需要将待撤销可写共享内存映射中的页刷新到磁盘。实际上，因为这些页仍然在页高速缓存内，因此继续起磁盘高速缓存的作用。</p>
<h4 id="内存映射的请求调页"><a href="#内存映射的请求调页" class="headerlink" title="内存映射的请求调页"></a>内存映射的请求调页</h4><p>出于效率的原因，内存映射创建之后并没有立即把页框分配给它，而是尽可能向后推迟到不能再推迟——也就是说，当进程试图对其中的一页进行寻址时，就产生一个“缺页”异常。我们在第九章中的“缺页异常处理程序”一节中已经看到，内核是如何验证缺页所在的地址是否包含在某个进程的线性区中的。如果是这样，那么内核就检查这个地址所对应的页表项，如果表项为空就调用do_no_page()函数。do_no_page()函数执行对请求调页的所有类型都通用的操作，例如分配页框和更新页表。它还检查所涉及的线性区是否定义了nopage方法。</p>
<p>在第九章的“请求调页”一节中，我们已经介绍了这个方法没有定义的情况(匿名线性区)。<br>现在我们讨论当nopage 方法被定义时，do_no_page()所执行的主要操作：</p>
<ol>
<li>调用nopage方法，它返回包含所请求页的页框的地址。</li>
<li>如果进程试图对页进行写入而该内存映射是私有的，则通过把刚读取的页拷贝一份并把它插入页的非活动链表中来避免进一步的“写时复制”异常。如果私有内存映射区域还没有一个包含新页的被动匿名线性区(slave anonymousmemory region)，它要么追加一个新的被动匿名线性区，要么增大现有的。在下面的步骤中，该函数使用新页而不是nopage方法返回的页，所以后者不会被用户态进程修改。</li>
<li>如果某个其他进程删改或作废了该页(address_space描述符的truncate_count字段就是用于这种检查的)，函数将跳回第1步，尝试再次获得该页。</li>
<li>增加进程内存描述符的rss字段，表示一个新页框已分配给进程。</li>
<li>用新页框的地址以及线性区的vm_page_prot字段中所包含的页访问权来设置缺页所在的地址对应的页表项。</li>
<li>如果进程试图对这个页进行写入，则把页表项的Read/Write和Dirty位强制置为1。在这种情况下，或者把这个页框互斥地分配给进程，或者让页成为共享；在这两种情况下，都应该允许对这个页进行写入。</li>
</ol>
<p>请求调页算法的核心在于线性区的nopage方法。一般来说，该方法必须返回进程所访问页所在的页框地址。其实现依赖于页所在线性区的种类。在处理对磁盘文件进行映射的线性区时，nopage方法必须首先在页高速缓存中查找所请求的页。如果没有找到相应的页，这个方法就必须将其从磁盘上读入。大部分文件系统都是使用filemap_nopage()函数来实现nopage方法的，该函数接收三个参数：</p>
<ol>
<li>area 所请求页所在线性区的描述符地址。</li>
<li>address 所请求页的线性地址。</li>
<li>type    存放函数侦测到的缺页类型(VM_FAULT_MAJOR或VM_FAULT_MINOR)的变量的指针。</li>
</ol>
<p>filemap_nopage()函数执行以下步骤：</p>
<ol>
<li>从area-&gt;vm_file字段得到文件对象地址file；从file-&gt;f_mapping得到address_space对象地址；从address_space对象的host字段得到索引节点对象地址。</li>
<li>用area的vm_star和vm_pgoff字段来确定从address开始的页对应的数据在文件中的偏移量。</li>
<li>检查文件偏移量是否大于文件大小。如果是，就返回NULL，这就意味着分配新页失败，除非缺页是由调试程序通过ptrace()系统调用跟踪另一个进程引起的，我们不打算讨论这种特殊情况。</li>
<li>如果线性区的VM_RAND_READ标志置位，我们假定进程以随机方式读内存映射中的页，那么它忽略预读，跳到第10步。</li>
<li>如果线性区的VM_SEQ_READ标志置位，我们假定进程以严格顺序方式读内存映射中的页，那么它调用page_cache_readahead()从缺页处开始预读。</li>
<li>调用find_get_page()，在页高速缓存内寻找由address_space对象和文件偏移量标识的页。如果找到这样的页，跳到第11步。</li>
<li>如果函数运行至此，说明没在页高速缓存内找到页，检查内存区的VM_SEQ_READ标志：<br>a. 如果标志置位，内核将强行预读线性区中的页，从而预读算法失败，它就调用handle_ra_miss()来调整预读参数，并跳到第10步。<br>b. 否则，如果标志未置位，将文件file_ra_state描述符中的mmap_miss计数器加1。如果失败数远大于命中数(存放在mmap_hit计数器内),它将忽略预读，跳到第10步。</li>
<li>如果预读没有永久禁止(file_ra_state描述符的ra_pages字段大于0)，它将调用do_page_cache_readahead()，读入围绕请求页的一组页。</li>
<li>调用find_get_page()来检查请求页是否在页高速缓存中，如果在，则跳到第11步。</li>
<li>调用page_cache_read()。这个函数检查请求页是否在页高速缓存中，如果不在，则分配一个新页框，把它追加到页高速缓存，执行mapping-&gt;a_ops-&gt;readpage方法，安排一个I/O操作从磁盘读入该页内容。</li>
<li>调用grab_swap_token()函数，尽可能为当前进程分配一个交换标记。</li>
<li>请求页现已在页高速缓存内，将文件file_ra_state描述符的mmap_hit计数器加1。</li>
<li>如果页不是最新的(标志PG_uptodate flag未置位)，就调用lock_page()锁定该页，执行mapping-&gt;a_ops-&gt;readpage方法来触发I/O数据传输，调用wait_on_page_bit()后睡眠，一直等到该页被解锁，就是说等到数据传输完成。</li>
<li>调用mark_page_accessed()来标记请求页为访问过。</li>
<li>如果在页高速缓存内找到该页的最新版，将*type设为VM_FAULT_MINOR，否则设为VM_FAULT_MAJOR。</li>
<li>返回请求页地址。用户态进程可以通过madvise()系统调用来调整filemap_nopage()函数的预读行为。<br>MADV_RANDOM命令将线性区的VM_RAND_READ标志置位，从而指定以随机方式访问线性区的页。<br>MADV_SEQUENTIAL命令将线性区的VM_SEQ_READ标志置位，从而指定以严格顺序方式访问页。<br>最后，MADV_NORMAL命令将复位VM_RAND_READ和VM_SEQ_READ标志，从而指定以不确定的顺序访问页。</li>
</ol>
<h4 id="把内存映射的脏页刷新到磁盘"><a href="#把内存映射的脏页刷新到磁盘" class="headerlink" title="把内存映射的脏页刷新到磁盘"></a>把内存映射的脏页刷新到磁盘</h4><p>进程可以使用msync()系统调用把属于共享内存映射的脏页刷新到磁盘。这个系统调用所接收的参数为：一个线性地址区间的起始地址、区间的长度以及具有下列含义的一组标志。</p>
<ol>
<li>MS_SYNC要求这个系统调用挂起进程，直到I/O操作完成为止。在这种方式中，调用进程就可以假设当系统调用完成时，这个内存映射中的所有页都已经被刷新到磁盘。</li>
<li>MS_ASYNC(对MS_SYNC的补充)要求系统调用立即返回，而不用挂起调用进程。</li>
<li>MS_INVALIDATE要求系统调用使同一文件的其他内存映射无效(没有真正实现，因为在Linux中无用)。</li>
</ol>
<p>对线性地址区间中所包含的每个线性区，sys_msync()服务例程都调用msync_interval()。后者依次执行以下操作：</p>
<ol>
<li>如果线性区描述符的vm_file字段为NULL，或者如果VM_SHARED标志清0，就返回0(说明这个线性区不是文件的可写共享内存映射)。</li>
<li>调用filemap_sync()函数，该函数扫描包含在线性区中的线性地址区间所对应的页表项。对于找到的每个页，重设对应页表项的Dirty标志，调用flush_tlb_page()刷新相应的转换后援缓冲器(translation lookaside buffer，TLB)。然后设置页描述符中的PG-dirty标志，把页标记为脏。</li>
<li>如果MS_ASYNC标志置位，它就返回。因此，MS_ASYNC标志的实际作用就是将线性区的页标志PG_dirty置位。该系统调用并没有实际开始I/O数据传输。</li>
<li>如果函数运行至此，则MS_SYNC标志置位，因此函数必须将内存区的页刷新到磁盘，而且，当前进程必须睡眠一直到所有I/O数据传输结束。为做到这一点，函数要得到文件索引节点的信号量i_sem。</li>
<li>调用filemap_fdatawrite()函数，该函数接收的参数为文件的address_space对象的地址。该函数必须用WB_SYNC_ALL同步模式建立一个writeback_control描述符，而且要检查地址空间是否有内置的writepages方法。如果有，则调用这个函数后返回。如果没有，就执行mpage_writepages()函数。</li>
<li>检查文件对象的fsync方法是否已定义，如果是，就执行它。对于普通文件，这个方法限制自己把文件的索引节点对象刷新到磁盘。然而，对于块设备文件，这个方法调用sync_blockdev()，它会激活该设备所有脏缓冲区的I/O数据传输。</li>
<li>执行filemap_fdatawait()函数。页高速缓存中的基树标识了所有通过PAGECACHE_TAG_WRITEBACK标记正在往磁盘写的页。函数快速地扫描覆盖给定线性地址区间的这一部分基树来寻找PG_writeback标志置位的页。函数调用wait_on_page_bit()使其在每一页上睡眠，一直到PG_writeback标志清0，也就是等到正在进行的该页的I/O数据传输结束。</li>
<li>释放文件的信号量i_sem并返回。</li>
</ol>
<h4 id="非线性内存映射"><a href="#非线性内存映射" class="headerlink" title="非线性内存映射"></a>非线性内存映射</h4><p>​    对普通文件，Linux 2.6内核还提供一个访问方法，即非线性内存映射。非线性内存映射基本上还是前面所述的文件内存映射，但它的内存页映射的并不是文件的顺序页，而是每一内存页都映射的是文件数据的随机页。</p>
<p>​    当然，一个用户态应用每次针对同一文件的不同4096字节部分重复调用mmap()系统调用，也可以得到同样的结果。然而，因为每个映射需要一个独立的线性区，所以这种方法对于大文件的非线性映射是非常低效的。<br>为了实现非线性映射，内核使用了另外的一些数据结构。</p>
<p>​    首先，线性区描述符的VM_NONLINEAR标志用于表示线性区存在一个非线性映射。给定文件的所有非线性映射线性区描述符都存放在一个双向循环链表，该链表根植于address_space对象的i_mmap_nonlinear字段。为创建一个非线性内存映射，用户态进程首先以mmap()系统调用创建一个常规的共享内存映射。应用然后调用remap_file_pages()来重新映射内存映射中的一些页。该系统调用的sys_remap_file_pages()服务例程有下面几个参数：</p>
<ul>
<li>start调用进程共享文件内存映射区域内的线性地址</li>
<li>size文件重新映射部分的字节数</li>
<li>prot未用(必须为0)</li>
<li>pgoff待映射文件初始页的页索引</li>
<li>flags控制非线性映射的标志</li>
</ul>
<p>该服务例程用线性地址start、页索引pgoff和映射尺寸size所确定的文件数据部分进行重新映射。如果线性区非共享或不能容纳要映射的所有页，则系统调用失败并返回错误码。实际上，该服务例程把线性区插入文件的i_mmap_nonlinear链表，并调用该线性区的populate方法。对于所有普通文件，populate方法是由filemap_populate()函数实现的。它执行以下步骤：</p>
<ol>
<li>检查remap_file_pages()系统调用的flags参数中MAP_NONBLOCK标志是否清0。如果是，则调用do_page_cache_readahead()预读待映射文件的页。</li>
<li>对重新映射的每一页，执行下列步骤：<br>a. 检查页描述符是否已在页高速缓存内，如果不在且MAP_NONBLOCK未置位，那从磁盘读入该页。<br>b. 如果页描述符在页高速缓存内，它将更新对应线性地址的页表项来指向该页框，并更新线性区描述符的页引用计数器。<br>c. 否则，如果没有在页高速缓存内找到该页描述符，它将文件页的偏移量存放在该线性地址对应的页表项的最高32位，并将页表项的Present位清0、Dirty位置位。</li>
</ol>
<p>正如第九章“请求调页”一节所述，当处理请求调页错误时，handle_pte_fault()函数检查页表项的Present和Dirty位。如果它们的值对应一个非线性内存映射，则handle_pte_fault()调用do_file_page()函数，从页表项的高位中取出所请求文件页的索引，然后，do_file_page()函数调用线性区的populate方法从磁盘读入页并更新页表项本身。因为非线性内存映射的内存页是按照相对于文件开始处的页索引存放在页高速缓存中，而不是按照相对于线性区开始处的索引存放的，所以非线性内存映射刷新到磁盘的方式与线性内存映射是一样的。</p>
<h4 id="直接I-O传送"><a href="#直接I-O传送" class="headerlink" title="直接I/O传送"></a>直接I/O传送</h4><p>我们已经看到，在Linux 2.6版本中，通过文件系统与通过引用基本块设备文件上的块，甚至与通过建立文件内存映射访问一个普通文件之间没有什么本质的差异。但是，还是有一些非常复杂的程序(自缓存的应用程序，self-caching application)更愿意具有控制I/O数据传送机制的全部权力。例如，考虑高性能数据库服务器：它们大都实现了自己的高速缓存机制，以充分挖掘对数据库独特的查询机制。对于这些类型的程序，内核页高速缓存毫无帮助；相反，因为以下原因它可能是有害的：</p>
<ol>
<li>很多页框浪费在复制已在RAM中的磁盘数据上(在用户级磁盘高速缓存中)。</li>
<li>处理页高速缓存和预读的多余指令降低了read()和write()系统调用的执行效率，也降低了与文件内存映射相关的分页操作。</li>
<li>read()和write()系统调用不是在磁盘和用户存储器之间直接传送数据，而是分两次传送：在磁盘和内核缓冲区之间和在内核缓冲区与用户存储器之间。因为必须通过中断和直接内存访问(DMA)处理块硬件设备，而且这只能在内核态完成，因此，最终需要某种内核支持来实现自缓存的应用程序。</li>
</ol>
<p>Linux提供了绕过页高速缓存的简单方法：直接I/O传送。<br>在每次I/O直接传送中，内核对磁盘控制器进行编程，以便在自缓存的应用程序的用户态地址空间中的页与磁盘之间直接传送数据。我们知道，任何数据传送都是异步进行的。当数据传送正在进行时，内核可能切换当前进程，CPU可能返回到用户态，产生数据传送的进程的页可能被交换出去，等等。这对于普通I/O数据传送没有什么影响，因为它们涉及磁盘高速缓存中的页，磁盘高速缓存由内核拥有，不能被换出去，并且对内核态的所有进程都是可见的。另一方面，直接I/O传送应当在给定进程的用户态地址空间的页内移动数据。内核必须当心这些页是由内核态的任一进程访问的，当数据传送正在进行时不能把它们交换出去。让我们看看这是如何实现的。</p>
<p>当自缓存的应用程序要直接访问文件时，它以O_DIRECT标志置位的方式打开文件。在运行open()系统调用时，dentry_open()函数检查打开文件的address_space对象是否有已实现的direct_IO方法，如果没有则返回错误码。对一个已打开的文件也可以由fcntl()系统调用的F_SETFL命令把O_DIRECT 置位。让我们首先看第一种情况，这里自缓存应用程序对一个以O_DIRECT标志置位的方式打开的文件调用read()系统调用。文件的read方法通常是由generic_file_read()函数实现的，它初始化iovec和kiocb描述符并调用__generic_file_aio_read()。后面这个函数检查iovec描述符描述的用户态缓冲区是否有效，然后检查文件的O_DIRECT标志是否置位。当被read()调用时，该函数执行的代码段实际上等效于下面的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">if〈filp-&gt;f_flags &amp; O_DIRECT) &#123;
	if(count &#x3D;&#x3D; 0 Il*ppos&gt;filp-&gt;f_mapping-&gt;host-&gt;i_size)
		return 0;
	retval &#x3D; generic_file_direct_IO(READ, iocb, iov, *ppos, 1);
	if(retval &gt; 0)
		*ppos +&#x3D; retval;
	file_accessed(filp);
	return retval;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数检查文件指针的当前值、文件大小与请求的字符数，然后调用generic_file_direct_IO()函数，传给它READ操作类型、iocb描述符、iovec描述符、文件指针的当前值以及io_vec描述符中指定的用户态缓冲区号。当generic_file_direct_IO()结束时，__generic_file_aio_read()更新文件指针，设置对文件索引节点的访问时间戳，然后返回。 对一个以O_DIRECT标志置位打开的文件调用write()系统调用时，情况类似。文件的write方法就是调用generic_file_aio_write_nolock()。该函数检查O_DIRECT标志是否置位，如果置位，则调用generic_file_direct_IO()函数，而这次限定的是WRITE操作类型。generic_file_direct_IO()函数有以下参数：</p>
<pre class="line-numbers language-none"><code class="language-none">rw
	操作类型：READ或WRITE
iocb
	kiocb描述符指针
iov
	iove描述符数组指针
offset
	文件偏移量
nr_segs
	iov数组中iovec描述符数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>generic_file_direct_IO()函数的执行步骤如下：</p>
<ol>
<li>从kiocb描述符的ki_filp字段得到文件对象的地址file，从file-&gt;f_mapping字段得到address_space对象的地址mapping。</li>
<li>如果操作类型为WRITE，而且一个或多个进程已创建了与文件的某个部分关联的内存映射，那么它调用unmap_mapping_range()取消该文件所有页的内存映射。如果任何取消映射的页所对应的页表项，其Dirty位置位，则该函数也确保它在页高速缓存内的相应页被标记为脏。</li>
<li>如果根植于mapping的基树不为空(mapping-&gt;nrpages大干0)，则调用filemap_fdatawrite()和filemap_fdatawait()函数刷新所有脏页到磁盘，并等待I/O操作结束。(即使自缓存应用程序是直接访问文件的，系统中还可能有通过页高速缓存访问文件的其他应用程序。为了避免数据的丢失，在启动直接I/O传送之前，磁盘映像要与页高速缓存进行同步)。</li>
<li>调用mapping地址空间的direct_IO方法。</li>
<li>如果操作类型为WRITE，则调用invalidate_inode_pages2()扫描mapping基树中的所有页并释放它们。该函数同时也清空指向这些页的用户态页表项。</li>
</ol>
<p>大多数情况下，direct_IO方法都是<strong>blockdev_direct_IO()函数的封装函数。这个函数相当复杂，它调用大量的辅助数据结构和函数，但是实际上它所执行的操作与本章所描述的操作一样：对存放在相应块中要读或写的数据进行拆分，确定数据在磁盘上的位置，并添加一个或多个用于描述要进行的I/O操作的bio描述符。当然，数据将被直接从iov数组中iovec描述符确定的用户态缓冲区读写。调用submit_bio()函数将bio 描述符提交给通用块层。通常情况下，</strong>blockdev_direct_IO()函数并不立即返回，而是等所有的直接I/O传送都已完成才返回；因此，一旦read()或write()系统调用返回，自缓存应用程序就可以安全地访问含有文件数据的缓冲区。</p>
<h4 id="异步-0"><a href="#异步-0" class="headerlink" title="异步/0"></a>异步/0</h4><p>POSIX 1003.1标准为异步方式访问文件定义了一套库函数。“异步”实际上就是：当用户态进程调用库函数读写文件时，一旦读写操作进入队列函数就结束，甚至有可能真正的I/O数据传输还没有开始。这样调用进程可以在数据正在传输时继续自己的运行。</p>
<ul>
<li>aio_read() 从文件异步读数据  </li>
<li>aio_write()  向文件异步写数据  </li>
<li>aio_fsync()  请求刷新所有正在运行的异步I/O操作（不阻塞）</li>
<li>aio_error()   获得正在运行的异步I/O操作的错误代码  </li>
<li>aio_return()  获得一个已完成异步I/O操作的返回码  </li>
<li>aio_cancel()  取消正在运行的异步I/O操作   </li>
<li>aio_suspend() 挂起正在允许的异步I/O操作</li>
</ul>
<p>​    使用异步I/O很简单，应用程序还是通过open()系统调用打开文件，然后用描述请求操作的信息填充struct aiocb类型的控制块。struct aiocb控制块最常用的字段有：</p>
<ul>
<li>aio_fildes 文件的文件描述符(由open()系统调用返回)</li>
<li>aio_buf 文件数据的用户态缓冲区</li>
<li>aio_nbytes 待传输的字节数</li>
<li>aio_offset 读写操作在文件中的起始位置(与“同步”文件指针无关）</li>
</ul>
<p>最后，应用程序将控制块地址传给aio_read()或aio_write()。一旦请求的I/O数据传输已由系统库或内核送进队列，这两个函数就结束。应用程序稍后可以调用aio_error()检查正在运行的I/0操作的状态。如数据传输仍在进行当中，则返回EINPROGRESS；如果成功完成，则返回0；如果失败，则返回一个错误码。aio_return()函数返回已完成异步I/O操作的有效读写字节数；或者如果失败，返回-1。</p>
<h4 id="Linux-2-6中的异步IO"><a href="#Linux-2-6中的异步IO" class="headerlink" title="Linux 2.6中的异步IO"></a>Linux 2.6中的异步IO</h4><p>异步I/O可以由系统库实现而完全不需要内核支持。实际上aio_read()或aio_write()库函数克隆当前进程，让子进程调用同步的read()或write()系统调用，然后父进程结束aio_read()或aio_write()函数并继续程序的执行。因此，它不用等待由子进程启动的同步操作完成。但是，这个“穷人版”POSIX函数比内核层实现的异步I/O要慢很多。</p>
<p>Linux 2.6内核版运用一组系统调用实现异步I/O。但在Linux2.6.11中，这个功能还在实现中，异步I/O只能用于打开O_DIRECT标志置位的文件。表16-5列出了异步I/O的系统调用。</p>
<ul>
<li>io_setup() 为当前进程初始化一个异步环境  </li>
<li>io_submit()   提交一个或多个异步I/O操作</li>
<li>io_getevents() 获得正在运行的异步I/O操作的完成状态</li>
<li>io_cancel()    取消一个正在运行的异步I/O操作</li>
<li>io_destroy()       删除当前进程的异步环境   </li>
</ul>
<h4 id="异步I-O环境"><a href="#异步I-O环境" class="headerlink" title="异步I/O环境"></a>异步I/O环境</h4><p>​    如果一个用户态进程调用io_submit()系统调用开始异步I/O操作，那么它必须预先创建一个异步I/O环境。基本上，一个异步I/O环境(简称AIO环境)就是一组数据结构，这个数据结构用于跟踪进程请求的异步I/O操作的运行情况。每个AIO环境与一个kioctx对象关联，它存放了与该环境有关的所有信息。一个应用可以创建多个AIO环境。一个给定进程的所有的kioctx描述符存放在一个单向链表中，该链表位于内存描述符的ioctx_list字段。</p>
<p>​    我们不再详细讨论kioctx对象。但是我们应当注意一个kioctx对象使用的重要的数据结构：AIO环。AIO环是用户态进程中地址空间的内存缓冲区，它也可以由内核态的所有进程访问。kioctx对象中的ring_info.mmap_base和ring_info.mmap_size字段分别存放AIO环的用户态起始地址和长度。ring_info.ring_pages字段则存放有一个数组指针，该数组存放所有含AIO环的页框的描述符。</p>
<p>​    AIO环实际上是一个环形缓冲区，内核用它来写正运行的异步I/O操作的完成报告。AIO 环的第一个字节有一个首部(struct aio_ring数据结构),后面的所有字节是io_event 数据结构，每个都表示一个已完成的异步I/O操作。因为AIO环的页映射至进程的用户态地址空间，应用可以直接检查正运行的异步I/O操作的情况，从而避免使用相对较慢的系统调用。</p>
<p>​    io_setup()系统调用为调用进程创建一个新的AIO环境。它有两个参数：正在运行的异步I/O操作的最大数目(这将确定AIO环的大小)和一个存放环境句柄的变量指针。这个句柄也是AIO环的基地址。sys_io_setup()服务例程实际上是调用do_mmap()为进程分配一个存放AIO环的新匿名线性区，然后创建和初始化描述该AIO环境的kioctx对象。相反地，io_destroy()系统调用删除AIO环境，还删除含有对应AIO环的匿名线性区。这个系统调用阻塞当前进程直到所有正在运行的异步I/O操作结束。</p>
<h4 id="提交异步I0操作"><a href="#提交异步I0操作" class="headerlink" title="提交异步I0操作"></a>提交异步I0操作</h4><p>为开始异步I/O操作，应用要调用io_submit()系统调用。该系统调用有三个参数：</p>
<ul>
<li>ctx_id 由io_setup()(标识AIO环境)返回的句柄</li>
<li>iocbpp iocb类型描述符的指针数组的地址，其中描述符的每项描述一个异步I/O操作</li>
<li>nr iocbpp指向的数组长度</li>
</ul>
<p>iocb数据结构与POSIX aiocb描述符有同样的字段aio_fildes、aio_buf、aio_nbytes、aio_offset，另外还有aio_lio_opcode字段存放请求操作的类型(典型地有：read、write或sync)。sys_io_submit()服务例程执行下列步骤：</p>
<ol>
<li><p>验证iocb描述符数组的有效性。</p>
</li>
<li><p>在内存描述符的ioctx_list字段所对应的链表中查找ctx_id句柄对应的kioctx对象。</p>
</li>
<li><p>对数组中的每一个iocb描述符，执行下列子步骤：</p>
<blockquote>
<ol>
<li>获得aio_fildes字段中的文件描述符对应的文件对象地址。</li>
<li>为该I/O操作分配和初始化一个新的kiocb描述符。</li>
<li>检查AIO环中是否有空闲位置来存放操作的完成情况。</li>
<li>根据操作类型设置kiocb描述符的ki_retry方法(见下面)。</li>
<li>执行aio_run_iocb()函数，它实际上调用ki_retry方法为相应的异步I/O操作启动数据传输。如果ki_retry方法返回-EIOCBRETRY，则表示异步I/O操作已提交但还没有完全成功：稍后在这个kiocb上，aio_run_iocb()函数会被再次调用(见下面)；否则，调用aio_complete()，为异步I/O操作在AIO环境的环中追加完成事件。</li>
</ol>
</blockquote>
</li>
</ol>
<p>如果异步I/O操作是一个读请求，那么对应kiocb描述符的ki_retry方法是由aio_pread()实现的。该函数实际上执行的是文件对象的aio_read方法，然后按照aio_read方法的返回值更新kiocb描述符的ki_buf和ki_left字段(参见本章前面的表16-1)。最后aio_pread()返回从文件读入的有效字节数，或者，如果函数确定请求的字节没有传输完，则返回-EIOCBRETRY。对于大部分文件系统，文件对象的aio_read方法就是调用<strong>generic_file_aio_read()函数。假如文件的O_DIRECT标志置位，函数就调用generic_file_direct_IO()函数，这在上一节描述过。但在这种情况下，</strong>blockdev_direct_IO()函数不是阻塞当前进程使之等待I/O数据传输完毕，而是立即返回。因为异步I/O操作仍在运行，aio_run_iocb()会被再次调用，而这一次的调用者是aio_wq工作队列的aio内核线程。kiocb描述符跟踪I/O数据传输的运行。终于所有数据传输完毕，将完成结果追加到AIO环。</p>
<p>类似地，如果异步I/O操作是一个写请求，那么对应kiocb描述符的ki_retry方法是由aio_pwrite()实现的。该函数实际上执行的是文件对象的aio_write方法，然后按照aio_write方法的返回值更新kiocb描述符的ki_buf和ki_left字段(参见本章前面的表16-1)。最后aio_pwrite()返回写入文件的有效字节数，或者，如果函数确定请求的字节没有完全传输完，则返回-EIOCBRETRY。<br>对于大部分文件系统，文件对象的aio_write方法就是调用generic_file_aio_write_nolock()函数。假如文件的O_DIRECT标志置位，跟上面一样，函数就调用generic_file_direct_IO()函数。</p>
<h1 id="页高速缓存"><a href="#页高速缓存" class="headerlink" title="页高速缓存"></a>页高速缓存</h1><h2 id="页高速缓存-1"><a href="#页高速缓存-1" class="headerlink" title="页高速缓存"></a>页高速缓存</h2><p>​    在绝大多数情况下，内核在读写磁盘时都<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=引用页&amp;spm=1001.2101.3001.7020">引用页</a>高速缓存。新页被追加到页高速缓存以满足用户态进程的读请求。<br>如果页不在高速缓存中，新页就被加到高速缓存中，然后用从磁盘读出的数据填充它。<br>如果内存有足够的空闲空间，就让该页在高速缓存（内存）中长期保留，使其他进程再使用该页时不再访问磁盘。</p>
<p>​    同样，在把一页数据写到块设备之前，内核首先检查对应的页是否已经在高速缓存中；<br>如果不在，就要先在其中增加一个新项，并用要写到磁盘中的数据填充该项。<br>I/O数据的传送并不是马上开始，而是要延迟几秒之后才对磁盘进行更新，从而使进程有机会对要写入磁盘的数据做进一步的修改(换句话说，就是内核执行延迟的写操作)。以便对磁盘IO进行寻道优化等。</p>
<p>​    内核的代码和内核数据结构不必从磁盘读，也不必写入磁盘，因此，页高速缓存中的页（磁盘页）可能是下面的类型：</p>
<ul>
<li>含有普通文件数据的页。</li>
<li>含有目录的页。</li>
<li>含有直接从块设备文件(跳过文件系统层)读出的数据的页。</li>
<li>含有用户态进程数据的页，但页中的数据已经被交换到磁盘。</li>
<li>内核可能会强行在页高速缓存中保留一些页面，而这些页面中的数据已经被写到交换区(可能是普通文件或磁盘分区)。</li>
<li>属于特殊文件系统文件的页，如共享内存的进程间通信所使用的特殊文件系统<code>shm</code>。</li>
</ul>
<p>页高速缓存中的页所包含的数据属于某个文件时。这个文件(或者更准确地说是文件的索引节点)就称为页的所有者(<code>owner</code>)。</p>
<p>几乎所有的文件读和写操作都依赖于页高速缓存。页高速缓存是内存和磁盘的中间层。<br>只有在<code>O_DIRECT</code>标志被置位而进程打开文件的情况下才会出现例外：此时，<code>I/0</code>数据的传送绕过了页高速缓而使用了进程用户态地址空间的缓冲区；少数数据库应用软件为了能采用自己的磁盘高速缓存算法而使用了<code>O_DIRECT</code>标志。</p>
<p>内核设计者实现页高速缓存主要为了满足下面两种需要：<br>快速定位含有<code>给定所有者</code>相关数据的特定页。为了尽可能充分发挥页高速缓存的优势，对它应该采用高速的搜索操作。<br>记录在读或写页中的数据时应当如何处理高速缓存中的每个页。</p>
<p>例如，从普通文件、块设备文件或交换区（这些都存储在磁盘上）读一个数据页必须用不同的实现方式，因此内核必须根据<code>页的所有者</code>选择适当的操作。一个页中包含的磁盘块在物理上不一定是相邻的，通过<code>页的所有者</code>和<code>所有者数据中的索引</code>(通常是一个索引节点和在相应文件中的偏移量)来识别页高速缓存中的页。</p>
<h3 id="address-space对象"><a href="#address-space对象" class="headerlink" title="address_space对象"></a>address_space对象</h3><p>页高速缓存的核心数据结构是<code>address_space</code>对象，它是一个<code>嵌入</code>在<code>页所有者的索引节点对象</code>中的数据结构。</p>
<p>高速缓存中的许多页可能属于同一个所有者，从而可能被链接到同一个<code>address_space</code>对象。</p>
<p>每个页描述符的<code>mapping</code>字段指向拥有页的索引节点的<code>address_space对象</code>，<br>每个页描述符的<code>index</code> 字段表示<code>在所有者的地址空间中以页大小为单位的偏移量</code>，也就是在所有者的磁盘映像中页中数据的位置。</p>
<p>可以用下述方式访问普通文件的同一<code>4KB</code>的数据块：<br>(1). 读文件，数据就包含在<code>普通文件的索引节点</code>所拥有的页中。<br>(2). 从文件所在的设备文件(磁盘分区)读取块；数据就包含在<code>块设备文件的主索引节点</code>所拥有的页中。<br><code>两个不同address_space对象</code>所引用的两个不同的页中出现了<code>相同的磁盘数据</code>。。</p>
<ul>
<li>host 指向拥有该对象的索引节点的指针（如 果存在) </li>
<li>page_tree  表示拥有者页的基树（radix tree）的根  </li>
<li>tree_lock Spin lock 保护基树的自旋锁</li>
<li>i_mmap_writable  地址空间中共享内存映射的个数  </li>
<li>i_mmap  radix优先搜索树的根</li>
<li>i_mmap_nonlinear 地址空间中非线性内存区的链表 </li>
<li>i_mmap_lock  保护radix优先搜索树的自旋锁  </li>
<li>truncate_count  截断文件时使用的顺序计数器  </li>
<li>nrpages writeback_index  a..ops  所有者的页总数最后一次回写操作所作用的页的索引！对所有者页进行操作的方法  </li>
<li>flags 指向拥有所有者数据的块设备的错误位和内存分配器的标志</li>
<li>backing_dev_info   backing_dev_info的指针</li>
<li>private_lock  通常是管理private_list链表时使用的自旋锁</li>
<li>private_list  通常是与索引节点相关的间接块的脏缓冲区的链表</li>
<li>assoc_mapping   通常是指向间接块所在块设备的address_space对象的指针  </li>
</ul>
<p>(1). 如果页高速缓存中<code>页的所有者是一个文件</code>，<br><code>address_space对象</code>就嵌入在<code>VFS索引节点对象的i_data字段</code>中。<br><code>VFS索引节点的i_mapping字段</code>总是指向索引节点的数据页所有者的<code>address_space对象</code>。<br><code>address_space对象</code>的<code>host字段</code>指向其<code>所有者的索引节点对象</code>。</p>
<p>故，如果页属于一个文件(存放在<code>Ext3</code>文件系统中)，那么<code>页的所有者</code>就是<code>文件的索引节点</code>，而且<code>相应的address_space对象</code>存放在<code>VFS索引节点对象</code>的<code>i_data字段</code>中。<code>索引节点的i_mapping字段</code>指向<code>同一个索引节点的i_data字段</code>，而<code>address_space对象</code>的<code>host字段</code>也指向这个<code>索引节点</code>。</p>
<p>(2). 如果页中包含的数据来自块设备文件，即页含有存放着块设备的“原始”数据，<br>那么就把<code>address_space对象</code>嵌入到<code>与该块设备相关的特殊文件系统bdev中文件的“主”索引节点</code>中(<code>块设备描述符</code>的<code>bd_inode字段</code>引用这个索引节点)。<br><code>块设备文件对应索引节点的i_mapping 字段</code>指向<code>主索引节点中的address_space对象</code>。<br><code>address_space对象</code>的<code>host 字段</code>指向<code>主索引节点</code>。</p>
<p><code>backing_dev_info字段</code>指向<code>backing_dev_info描述符</code>，后者是对所有者的数据<code>所在块设备进行有关描述的数据结构</code>。<br><code>address_space对象</code>的关键字段是<code>a_ops</code>，它指向一个类型为<code>address_space_operations 的表</code>，表中定义了对所有者的页进行处理的各种方法。这些方法如表15-2所示。</p>
<ul>
<li>writepage 写操作（从页写到所有者的磁盘映像）</li>
<li>readpage 读操作（从所有者的磁盘映像读到页）</li>
<li>sync_page 如果对所有者页进行的操作已推备好，则立刻开始1/0数据的传输</li>
<li>writepages  把指定数量的所有者脏页写回磁盘 </li>
<li>set_page_dirty 把所有者的页设置为脏页  </li>
<li>readpages 从磁盘中读所有者页的链表  </li>
<li>prepare_write  为写操作做准备（由磁盘文件系统使用）  </li>
<li>commit_write  完成写操作（由磁盘文件系统使用） </li>
<li>bmap  从文件块索引中获取逻辑块号  </li>
<li>invalidatepage  使所有者的页无效（截断文件时使用）  </li>
<li>releasepage 由日志文件系统使用以准备释放页</li>
<li>direct_IO    所有者页的直接IO传输（绕过页高速缓存）  </li>
</ul>
<p>​    在绝大多数情况下，这些方法把<code>所有者的索引节点对象</code>和<code>访问物理设备的低级驱动程序</code>联系起来。<br>例如，为普通文件的索引节点实现readpage方法的函数知道如何确定文件页的对应块在物理磁盘设备上的位置。</p>
<h3 id="基树"><a href="#基树" class="headerlink" title="基树"></a>基树</h3><p>访问大文件时，页高速缓存中可能充满太多的文件页，以至于顺序扫描这些页要消耗大量的时间。<br>为了实现页高速缓存的高效查找，<code>Linux 2.6</code> 采用了大量的搜索树，其中每个<code>address_space对象</code>对应<code>一棵搜索树</code>。</p>
<p><code>address_space对象</code>的<code>page_tree字段</code>是<code>基树(radix tree)的根</code>。</p>
<p><code>给定的页索引</code>表示页在<code>所有者磁盘映像中的位置</code>，内核能够通过快速搜索操作来确定所需要的页是否在页高速缓存中。</p>
<p>当查找所需要的页时，内核把<code>页索引</code>转换为<code>基树中的路径</code>，并快速找到<code>页描述符</code>所(或应当)在的位置。<br>如果找到，内核可以<code>从基树获得页描述符</code>，而且还可以很快确定所找到的<code>页是否是脏页</code>(也就是应当被刷新到磁盘的页)，以及其<code>数据的I/O传送</code>是否正在进行。</p>
<p>基树的<code>每个节点</code>可以有<code>多到64个指针</code>指向其他节点或页描述符。<br><code>底层节点</code>存放<code>指向页描述符</code>的指针(叶子节点)，而<code>上层的节点</code>存放指向<code>其他节点</code>(孩子节点)的指针。<br>每个节点由<code>radix_tree_node</code>数据结构表示，它包括三个字段：</p>
<ul>
<li><code>slots</code>是包括<code>64个指针</code>的数组，</li>
<li><code>count</code>是记录节点中非空指针数量的计数器，</li>
<li><code>tags</code>是二维的标志数组，</li>
</ul>
<p>树根由<code>radix_tree_root</code>数据结构表示，它有三个字段：</p>
<ul>
<li><code>height</code>表示树的当前深度(不包括叶子节点的层数),</li>
<li><code>gfp_mask</code>指定为新节点请求内存时所用的标志，</li>
<li><code>rnode</code>指向与树中第一层节点相应的数据结构<code>radix_tree_node</code>(如果有的话)。<br><img src=".\image-20240503154150238.png" alt="image-20240503154150238"></li>
</ul>
<h3 id="页高速缓存的处理函数"><a href="#页高速缓存的处理函数" class="headerlink" title="页高速缓存的处理函数"></a>页高速缓存的处理函数</h3><h4 id="查找页–find-get-page"><a href="#查找页–find-get-page" class="headerlink" title="查找页–find_get_page()"></a>查找页–find_get_page()</h4><p>参数：</p>
<ol>
<li>指向address_space对象的指针，</li>
<li>偏移量。</li>
</ol>
<p>它获取地址空间的自旋锁,调用radix_tree_lookup()函数搜索拥有指定偏移量的基树的叶子节点。该函数根据偏移量值中的位依次从树根开始并向下搜索，如上节所述。如果遇到空指针，函数返回NULL；否则，返回叶子节点的地址，也就是所需要的页描述符指针。如果找到了所需要的页，</p>
<p><code>find_get_page()</code>函数就增加该页（页框）的使用计数器，释放自旋锁，返回该页的地址；否则，函数就释放自旋锁并返回NULL。</p>
<p><strong>find_get_pages()</strong>：<br>与find_get_page()类似，但它实现在高速缓存中查找一组具有相邻索引的页。</p>
<p>参数：</p>
<ol>
<li>指向address_space对象的指针、</li>
<li>地址空间中相对于搜索起始位置的偏移量、</li>
<li>所检索到页的最大数量、</li>
<li>指向由该函数赋值的页描述符数组的指针。</li>
</ol>
<p>依赖<code>radix_tree_gang_lookup()</code>函数实现查找操作。<br><code>radix_tree_gang_lookup()</code>函数为指针数组赋值并返回找到的页数。</p>
<p><strong>find_lock_page()函数</strong>：<br>与<code>find_get_page()</code>类似，但它增加返回页的使用记数器，并调用<code>lock_page()</code>设置<code>PG_locked</code>标志，从而当函数返回时调用者能够以互斥的方式访问返回的页。如果页已经被加锁，lock_page()函数就阻塞当前进程。调用<code>_wait_on_bit_lock()</code>函数。当前进程置为<code>TASK_UNINTERRUPTIBLE</code> 状态，把进程描述符存入等待队列，执行<code>address_space</code>对象的<code>sync_page</code>方法以取消文件所在块设备的请求队列，最后调用<code>schedule()</code>函数来挂起进程，直到把<code>PG_locked</code> 标志清<code>0</code>。内核使用<code>unlock_page()</code>函数对页进行解锁，并唤醒在等待队列上睡眠的进程。</p>
<h4 id="增加页–add-to-page-cache"><a href="#增加页–add-to-page-cache" class="headerlink" title="增加页–add_to_page_cache()"></a>增加页–add_to_page_cache()</h4><p>把一个新页的描述符插入到页高速缓存。</p>
<p>参数：</p>
<ol>
<li>页描述符的地址<code>page</code>、</li>
<li><code>address_space</code>对象的地址<code>mapping</code>、</li>
<li>表示在地址空间内的页索引的值<code>offset</code></li>
<li>为基树分配新节点时所使用的内存分配标志<code>gfp_mask</code>。</li>
</ol>
<p>函数执行以下操作：</p>
<ol>
<li><p>调用<code>radix_tree_preload()</code>函数，它禁用内核抢占，并把一些空的<code>radix_tree_node</code>结构赋给每<code>CPU</code>变量<code>radix_tree_preloads</code>。<code>radix_tree_node</code>结构的分配由<code>slab</code>分配器高速缓存<code>radix_tree_node_cachep</code>来完成。如果<code>radix_tree_preload()</code>预分配<code>radix_tree_node</code>结构不成功，函数<code>add_to_page_cache()</code>就终止并返回错误码<code>-ENOMEM</code>。否则，如果<code>radix_tree_preload()</code>成功地完成预分配，<code>add_to_page_cache()</code>函数肯定不会因为缺乏空闲内存或因为文件的大小达到了<code>64GB</code>而无法完成新页描述符的插入。</p>
</li>
<li><p>获取<code>mapping-&gt;tree_lock</code>自旋锁——注意，<code>radix_tree_preload()</code>函数已经禁用了内核抢占。</p>
</li>
<li><p>调用<code>radix_tree_insert()</code>在树中插入新节点，该函数执行下述操作：</p>
<blockquote>
<ol>
<li>调用<code>radix_tree_maxindex()</code>获得最大索引，该索引可能被插入具有当前深度的基树；如果新页的索引不能用当前深度表示，就调用<code>radix_tree_extend()</code>通过增加适当数量的节点来增加树的深度(例如，对图15-1(a)所示的基树，<code>radix_tree_extend()</code>在它的顶端增加一个节点)。分配新节点是通过执行<code>radix_tree_node_alloc()</code>函数实现的，该函数试图从<code>slab</code>分配器高速缓存获得<code>radix_tree_node</code>结构，如果分配失败，就从存放在<code>radix_tree_preloads</code>中的预分配的结构池中获得<code>radix_tree_node</code>结构。</li>
<li>根据页索引的偏移量，从根节点(<code>mapping-&gt;page_tree</code>)开始遍历树，直到叶子节点，如上一节所述。如果需要，就调用<code>radix_tree_node_alloc()</code>分配新的中间节点。</li>
<li>把页描述符地址存放在对基树所遍历的最后节点的适当位置，并返回<code>0</code>。</li>
</ol>
</blockquote>
</li>
<li><p>增加页描述符的使用计数器<code>page-&gt;_count</code>。</p>
</li>
<li><p>由于页是新的，所以其内容无效：函数设置页框的<code>PG_locked</code>标志，以阻止其他的内核路径并发访问该页。</p>
</li>
<li><p>用<code>mapping</code>和<code>offset</code>参数初始化<code>page-&gt;mapping</code>和<code>page-&gt;index</code>。</p>
</li>
<li><p>递增在地址空间所缓存页的计数器(<code>mapping-&gt;nrpages</code>)。</p>
</li>
<li><p>释放地址空间的自旋锁。</p>
</li>
<li><p>调用<code>radix_tree_preload_end()</code>重新启用内核抢占。</p>
</li>
<li><p>返回<code>0</code>(成功)。</p>
</li>
</ol>
<h4 id="删除页"><a href="#删除页" class="headerlink" title="删除页"></a>删除页</h4><p>函数<code>remove_from_page_cache()</code>通过下述步骤从页高速缓存中删除页描述符：</p>
<ol>
<li><p>获取自旋锁<code>page-&gt;mapping-&gt;tree_lock</code>并关中断。</p>
</li>
<li><p>调用<code>radix_tree_delete()</code>函数从树中删除节点。该函数接收树根的地址(<code>page-&gt;mapping-&gt;page_tree</code>)和要删除的页索引作为参数，并执行下述步骤：</p>
<blockquote>
<ol>
<li>如上节所述，根据页索引从根节点开始遍历树，直到到达叶子节点。遍历时，建立<code>radix_tree_path</code>结构的数组，描述从根到与要删除的页相应的叶子节点的路径构成。</li>
<li>从最后一个节点(包含指向页描述符的指针)开始，对路径数组中的节点开始循环操作。对每个节点，把指向下一个节点(或页描述符)位置数组的元素置为<code>NULL</code>，并递减<code>count</code>字段。如果<code>count</code>变为<code>0</code>，就从树中删除节点并把<code>radix_tree_node</code>结构释放给<code>slab</code>分配器高速缓存。然后继续循环处理路径数组中的节点。否则，如果<code>count</code>不等于<code>0</code>，继续执行下一步。</li>
<li>返回已经从树中删除的页描述符指针。</li>
</ol>
</blockquote>
</li>
<li><p>把<code>page-&gt;mapping</code>字段置为<code>NULL</code>。</p>
</li>
<li><p>把所缓存页的<code>page-&gt;mapping-&gt;nrpages</code>计数器的值减<code>1</code>。</p>
</li>
<li><p>释放自旋锁<code>page-&gt;mapping-&gt;tree_lock</code>，打开中断，函数终止。</p>
</li>
</ol>
<h4 id="更新页"><a href="#更新页" class="headerlink" title="更新页"></a>更新页</h4><p>函数<code>read_cache_page()</code>确保高速缓存中包括最新版本的指定页。它的参数是</p>
<ol>
<li>指向<code>address_space</code>对象的指针<code>mapping</code>、</li>
<li>表示所请求页的偏移量的值<code>index</code>、</li>
<li>指向从磁盘读页数据的函数的指针<code>filler</code>(通常是实现地址空间readpage方法的函数)</li>
<li>传递给<code>filler</code>函数的指针<code>data</code>(通常为<code>NULL</code>)。</li>
</ol>
<p>下面是对这个函数的简单说明：</p>
<ol>
<li><p>调用函数<code>find_get_page()</code>检查页是否已经在页高速缓存中。</p>
</li>
<li><p>如果页不在页高速缓存中，则执行下述子步骤：</p>
<blockquote>
<ol>
<li>调用<code>alloc_pages()</code>分配一个新页框。</li>
<li>调用<code>add_to_page_cache()</code>在页高速缓存中插入相应的页描述符。</li>
<li>调用<code>1ru_cache_add()</code>把页插入该管理区的非活动LRU链表中。</li>
</ol>
</blockquote>
</li>
<li><p>此时，所请求的页已经在页高速缓存中了。调用<code>mark_page_accessed()</code>函数记录页已经被访问过的事实。</p>
</li>
<li><p>如果页不是最新的(<code>PG_uptodate</code>标志为<code>0</code>)，就调用<code>filler</code>函数从磁盘读该页。</p>
</li>
<li><p>返回页描述符的地址。</p>
</li>
</ol>
<h4 id="基树的标记"><a href="#基树的标记" class="headerlink" title="基树的标记"></a>基树的标记</h4><p>前面我们曾强调，页高速缓存不仅允许内核快速获得含有块设备中指定数据的页，还允许内核从高速缓存中快速获得给定状态的页。<br>例如，我们假设内核必须从高速缓存获得属于指定所有者的所有页和脏页(即其内容还没有写回磁盘)。<br>存放在页描述符中的<code>PG_dirty</code>标志表示页是否是脏的，但是，如果绝大多数页都不是脏页，遍历整个基树以顺序访问所有叶子节点(页描述符)的操作就太慢了。</p>
<p>相反，为了能快速搜索脏页，基树中的每个中间节点都包含一个针对每个孩子节点(或叶子节点)的脏标记，当有且只有至少有一个孩子节点的脏标记被置位时这个标记被设置。最底层节点的脏标记通常是页描述符的<code>PG_dirty</code>标志的副本。通过这种方式，当内核遍历基树搜索脏页时，就可以跳过脏标记为<code>0</code>的中间结点的所有子树：中间结点的脏标记为<code>0</code>说明其子树中的所有页描述符都不是脏的。</p>
<p>同样的想法应用到了<code>PG_writeback</code>标志，该标志表示页正在被写回磁盘。这样，为基树的每个结点引入两个页描述符的标志：<code>PG_dirty</code>和<code>PG_writeback</code>。每个结点的<code>tags</code>字段中有两个<code>64</code>位的数组来存放这两个标志。<code>tags[0](PAGECACHE_TAG_DIRTY)</code>数组是脏标记，而<code>tags[1](PAGECACHE_TAG_WRITEBACK)</code>数组是写回标记。</p>
<p>设置页高速缓存中页的<code>PG_dirty</code>或<code>PG_writeback</code>标志时调用函数<code>radix_tree_tag_set()</code>，它作用于三个参数：</p>
<ul>
<li>(1). 基树的根、</li>
<li>(2). 页的索引</li>
<li>(3). 要设置的标记的类型(<code>PAGECACHE_TAG_DIRTY</code>或<code>PAGECACHE_TAG_WRITEBACK</code>)。</li>
</ul>
<p>函数从树根开始并向下搜索到与指定索引对应的叶子结点；对于从根通往叶子路径上的每一个节点，函数利用指向路径中下一个结点的指针设置标记。然后，函数返回页描述符的地址。结果是，从根结点到叶子结点的路径中的所有结点都以适当的方式被加上了标记。</p>
<p>清除页高速缓存中页的<code>PG_dirty</code>或<code>PG_writeback</code>标志时调用函数<code>radix_tree_tag_clear()</code>，它的参数与函数<code>radix_tree_tag_set()</code>的参数相同。函数从树根开始并向下到叶子结点，建立描述路径的<code>radix_tree_path</code>结构的数组。然后，函数从叶子结点到根结点向后进行操作：清除底层结点的标记，然后检查是否结点数组中所有标记都被清<code>0</code>，如果是，函数把上层父结点的相应标记清<code>0</code>，并如此继续上述操作。最后，函数返回页描述符的地址。从基树删除页描述符时，必须更新从根结点到叶子结点的路径中结点的相应标记。函数<code>radix_tree_delete()</code>可以正确地完成这个工作(尽管我们在上一节没有提到这一点)。而函数<code>radix_tree_insert()</code>不更新标记，因为插入基树的所有页描述符的<code>PG_dirty</code> 和<code>PG_writeback</code>标志都被认为是清零的。如果需要，内核可以随后调用函数<code>radix_tree_tag_set()</code>。</p>
<p>函数<code>radix_tree_tagged()</code>利用树的所有结点的标志数组来测试基树是否至少包括一个指定状态的页。<br>函数通过执行下面的代码轻松地完成这一任务(<code>root</code>是指向基树的<code>radix_tree_root</code>结构的指针，<code>tag</code>是要测试的标记)：因为可能假设基树所有结点的标记都正确地更新过，所以<code>radix_tree_tagged()</code>函数只需要检查第一层的标记。使用该函数的一个例子是：确定一个包含脏页的索引节点是否要写回磁盘。<br>注意，函数在每次循环时要测试在无符号长整型的<code>32</code>个标志中，是否有被设置的标志。函数<code>find_get_pages_tag()</code>和<code>find_get_pages()</code>类似，只有一点不同，就是前者返回的只是那些用<code>tag</code>参数标记的页。正如我们将在“把脏页写入磁盘”一节所见的，该函数对快速找到一个索引节点的所有脏页是非常关键的。</p>
<h4 id="把块存放在页高速缓存中"><a href="#把块存放在页高速缓存中" class="headerlink" title="把块存放在页高速缓存中"></a>把块存放在页高速缓存中</h4><p><code>VFS</code>(映射层)和各种文件系统以叫做“块”的逻辑单位组织磁盘数据。在<code>Linux</code>内核的旧版本中，主要有两种不同的磁盘高速缓存：<br>页高速缓存和缓冲区高速缓存，前者用来存放访问磁盘文件内容时生成的磁盘数据页，后者把通过<code>VFS</code>(管理磁盘文件系统)访问的块的内容保留在内存中。</p>
<p>从<code>2.4.10</code>的稳定版本开始，缓冲区高速缓存其实就不存在了。事实上，由于效率的原因，不再单独分配块缓冲区；<br>相反，把它们存放在叫做“缓冲区页”的专门页中，而缓冲区页保存在页高速缓存中。缓冲区页在形式上就是与称做“缓冲区首部”的附加描述符相关的数据页，其主要目的是快速确定页中的一个块在磁盘中的地址。实际上，页高速缓存内的页中的一大块数据在磁盘上的地址不一定是相邻的。</p>
<h4 id="块缓冲区和缓冲区首部"><a href="#块缓冲区和缓冲区首部" class="headerlink" title="块缓冲区和缓冲区首部"></a>块缓冲区和缓冲区首部</h4><p>每个块缓冲区都有<code>buffer_head</code>类型的缓冲区首部描述符。该描述符包含内核必须了解的、有关如何处理块的所有信息。因此，在对所有块操作之前，内核检查缓冲区首部。</p>
<p>缓冲区首部的两个字段编码表示块的磁盘地址：</p>
<ul>
<li>(1). <code>b_bdev</code>字段表示包含块的块设备，通常是磁盘或分区；</li>
<li>(2). <code>b_blocknr</code>字段存放逻辑块号，即块在磁盘或分区中的编号。</li>
<li><p>(3). <code>b_data</code>字段表示块缓冲区在缓冲区页中的位置。实际上，这个位置的编号依赖于页是否在高端内存。如果页在高端内存，则<code>b_data</code>字段存放的是块缓冲区相对于页的起始位置的偏移量，否则，<code>b_data</code>存放的是块缓冲区的线性地址。</p>
</li>
<li><p><code>b_state</code>字段可以存放几个标志。其中一些标志是通用的，把它们列在表<code>15-5</code>中。每个文件系统还可以定义自己的私有缓冲区首部标志。</p>
</li>
<li><p>BH_UptodateBH_Dirty  缓冲区包含有效数据时被置位如果缓冲区脏就置位（表示缓冲区中的数据必须写回块设备） </p>
</li>
<li>BH_Lock  如果缓冲区加锁就置位，通常发生在缓冲区进行磁盘传输时  </li>
<li>BH_Req  如果已经为初始化缓冲区而请求数据传输就置位  </li>
<li>BH_Mapped    如果缓冲区被映射到磁盘就置位，即：如果相应的缓冲区首部的b bdev和 b_blocknr是有效的就置位</li>
<li>BH_New  如果相应的块刚被分配而还没有被访问过就置位 </li>
<li>BH_Async_Read  如果在异步地读缓冲区就置位  </li>
<li>BH_Async_Write 如果在异步地写缓冲区就置位 </li>
<li>BH_Delay 如果还没有在磁盘上分配缓冲区就置位  </li>
<li>BH_Boundary  如果两个相邻的块在其中一个提交之后不再相邻就置位  </li>
<li>BH_Write_EIO  如果写块时出现I/O错误就置位  </li>
<li>BH_Ordered  如果必须严格地把块写到在它之前提交的块的后面就置位（用于日  志文件系统）  </li>
<li>BH_Eopnotsupp  如果块设备的驱动程序不支持所请求的操作就置位</li>
</ul>
<h4 id="管理缓冲区首部"><a href="#管理缓冲区首部" class="headerlink" title="管理缓冲区首部"></a>管理缓冲区首部</h4><p>缓冲区首部有它们自己的<code>slab</code>分配器高速缓存，其描述符<code>kmem_cache_s</code>存在变量<code>bh_cachep</code>中。<br><code>alloc_buffer_head()</code>和<code>free_buffer_head()</code>函数分别用于获取和释放缓冲区首部。<br>缓冲区首部的<code>b_count</code>字段是相应的块缓冲区的引用计数器。在每次对块缓冲区进行操作之前递增计数器并在操作之后递减它。</p>
<p>除了周期性地检查保存在页高速缓存中的块缓冲区之外，当空闲内存变得很少时也要对它进行检查，只有引用计数器等于<code>0</code>的块缓冲区才可以被回收。当内核控制路径希望访问块缓冲区时，应该先递增引用计数器。确定块在页高速缓存中的位置的函数<code>(__getblk()</code>，自动完成这项工作，因此，高层函数通常不增加块缓冲区的引用计数器。</p>
<p>当内核控制路径停止访问块缓冲区时，应该调用<code>__brelse()</code>或<code>__bforget()</code>递减相应的引用计数器。这两个函数之间的不同是<code>__bforget()</code>还从间接块链表(缓冲区首部的<code>b_assoc_buffers</code>字段)中删除块，并把该缓冲区标记为干净的，因此强制内核忽略对缓冲区所做的任何修改，但实际上缓冲区依然必须被写回磁盘。</p>
<h4 id="缓冲区页"><a href="#缓冲区页" class="headerlink" title="缓冲区页"></a>缓冲区页</h4><p>只要内核必须单独地访问一个块，就要涉及存放块缓冲区的缓冲区页，并检查相应的缓冲区首部。<br>下面是内核创建缓冲区页的两种普通情况：<br>(1). 当读或写的文件页在磁盘块中不相邻时。发生这种情况是因为文件系统为文件分配了非连续的块，或因为文件有“洞”。<br>(2). 当访问一个单独的磁盘块时(例如，当读超级块或索引节点块时)。</p>
<p>在第一种情况下，把缓冲区页的描述符插入普通文件的基树；<br>保存好缓冲区首部，因为其中存有重要的信息，即存有数据在磁盘中位置的块设备和逻辑块号。</p>
<p>在第二种情况下，把缓冲区页的描述符插入基树，<br>树根是与块设备相关的特殊bdev文件系统中索引节点的<code>address_space对象</code>。<br>这种缓冲区页必须满足很强的约束条件，就是所有的块缓冲区涉及的块必须是在块设备上相邻存放的。</p>
<p>这种情况的一个应用实例是：<br>如果<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=虚拟文件系统&amp;spm=1001.2101.3001.7020">虚拟文件系统</a>要读大小为<code>1024</code>个字节的索引节点块(包含给定文件的索引节点)。<br>内核并不是只分配一个单独的缓冲区，而是必须分配一个整页，从而存放四个缓冲区；<br>这些缓冲区将存放块设备上相邻的<code>4</code>块数据，其中包括所请求的索引节点块。</p>
<p>本章我们将重点讨论第二种类型的缓冲区页，即所谓的块设备缓冲区页(有时简称为块设备页)。<br>在一个缓冲区页内的所有块缓冲区大小必须相同，因此，在<code>80x86</code>体系结构上，根据块的大小，一个缓冲区页可以包括<code>1～8</code>个缓冲区。<br>如果一个页作为缓冲区页使用，那么与它的块缓冲区相关的所有缓冲区首部都被收集在一个单向循环链表中。</p>
<p>缓冲区页描述符的<code>private</code>字段指向页中第一个块的缓冲区首部；<br>每个缓冲区首部在<code>b_this_page</code>字段中，该字段是指向链表中下一个缓冲区首部的指针。<br>此外，每个缓冲区首部还把缓冲区页描述符的地址存放在<code>b_page</code>字段中。<br>图<code>15-2</code>显示了一个缓冲区页，其中包含四个块缓冲区和对应的缓冲区首部。<br><img src=".\image-20240503154733714.png" alt="image-20240503154733714"></p>
<h3 id="分配块设备缓冲区页"><a href="#分配块设备缓冲区页" class="headerlink" title="分配块设备缓冲区页"></a>分配块设备缓冲区页</h3><p>当内核发现指定块的缓冲区所在的页不在页高速缓存中时，就分配一个新的块设备缓冲区页。<br>特别是，对块的查找操作会由于下述原因而失败：</p>
<ul>
<li>包含数据块的页不在块设备的基树中：这种情况下，必须把新页的描述符加到基树中。</li>
<li>包含数据块的页在块设备的基树中，但这个页不是缓冲区页：在这种情况下，必须分配新的缓冲区首部，并将它链接到所属的页，从而把它变成块设备缓冲区页。</li>
<li>包含数据块的缓冲区页在块设备的基树中，但页中块的大小与所请求的块大小不相同：</li>
</ul>
<p>这种情况下，必须释放旧的缓冲区首部，分配经过重新赋值的缓冲区首部并将它链接到所属的页。内核调用函数<code>grow_buffers()</code>把块设备缓冲区页添加到页高速缓存中。</p>
<p>该函数接收三个标识块的参数：</p>
<ul>
<li>(1). block_device描述符的地址bdev。</li>
<li>(2). 逻辑块号block(块在块设备中的位置)。</li>
<li>(3). 块大小size。</li>
</ul>
<p>该函数本质上执行下列操作：</p>
<ol>
<li><p>计算数据页在所请求块的块设备中的偏移量<code>index</code>。</p>
</li>
<li><p>如果需要，就调用<code>grow_dev_page()</code>创建新的块设备缓冲区页。<br>该函数依次执行下列子步骤：</p>
<blockquote>
<ol>
<li>调用函数<code>find_or_create_page()</code>，传递给它的参数有：</li>
</ol>
<ul>
<li>块设备的<code>address_space对象(bdev-&gt;bd_inode-&gt;i_mapping)</code>、</li>
<li>页偏移<code>index</code></li>
<li>以及<code>GFP_NOFS</code>标志。</li>
</ul>
<p><code>find_or_create_page()</code>在页高速缓存中搜索需要的页，如果需要，就把新页插入高速缓存。</p>
<ol>
<li>此时，所请求的页已经在页高速缓存中，而且函数获得了它的描述符地址。函数检查它的<code>PG_private</code>标志；<br>如果为空，说明页还不是一个缓冲区页(没有相关的缓冲区首部)，就跳到第<code>2e</code>步。</li>
<li>页已经是缓冲区页。从页描述符的<code>private</code>字段获得第一个缓冲区首部的地址<code>bh</code>，并检查块大小<code>bh-&gt;size</code>是否等于所请求的块大小；<br>如果大小相等，在页高速缓存中找到的页就是有效的缓冲区页，因此跳到第<code>2g</code>步。</li>
<li>如果页中块的大小有错误，就调用<code>try_to_free_buffers()</code>释放缓冲区页的上一个缓冲区首部。</li>
<li>调用函数<code>alloc_page_buffers()</code>根据页中所请求的块大小分配缓冲区首部，并把它们插入由<code>b_this_page</code>字段实现的单向循环链表。此外，函数用页描述符的地址初始化缓冲区首部的<code>b_page</code>字段，用块缓冲区在页内的线性地址或偏移量初始化<code>b_data</code>字段。</li>
<li>在字段<code>private</code>中存放第一个缓冲区首部的地址，把<code>PG_private</code>字段置位，并递增页的使用计数器(页中的块缓冲区被算作一个页用户)。</li>
<li>调用<code>init_page_buffers()</code>函数初始化连接到页的缓冲区首部的字段<code>b_bdev</code>、<code>b_blocknr</code>和<code>b_bstate</code>。<br>因为所有的块在磁盘上都是相邻的，因此逻辑块号是连续的，而且很容易从块得出。<br>h. 返回页描述符地址。</li>
</ol>
</blockquote>
</li>
<li><p>为页解锁(函数<code>find_or_create_page()</code>曾为页加了锁)。</p>
</li>
<li><p>递减页的使用计数器(函数<code>find_or_create_page()</code>曾递增了计数器)。</p>
</li>
<li><p>返回<code>1</code>(成功)。</p>
</li>
</ol>
<h4 id="释放块设备缓冲区页"><a href="#释放块设备缓冲区页" class="headerlink" title="释放块设备缓冲区页"></a>释放块设备缓冲区页</h4><p>当内核试图获得更多的空闲内存时，就释放块设备缓冲区页。<br>显然，不可能释放有脏缓冲区或上锁的缓冲区的页。内核调用函数<code>try_to_release_page()</code>释放缓冲区页，该函数接收页描述符的地址<code>page</code>。</p>
<p>执行下述步骤:</p>
<ol>
<li><p>如果设置了页的<code>PG_writeback</code>标志，则返回<code>0</code>(因为正在把页写回磁盘，所以不可能释放该页)。</p>
</li>
<li><p>如果已经定义了块设备<code>address_space</code>对象的<code>releasepage</code>方法，就调用它(通常没有为块设备定义的<code>releasepage</code>方法)。</p>
</li>
<li><p>调用函数<code>try_to_free_buffers()</code>并返回它的错误代码。<br>函数<code>try_to_free_buffers()</code>依次扫描链接到缓冲区页的缓冲区首部，它本质上执行下列操作：</p>
<blockquote>
<ol>
<li>检查页中所有缓冲区的缓冲区首部的标志。如果有些缓冲区首部的<code>BH_Dirty</code>或<code>BH_Locked</code>标志被置位，说明函数不可能释放这些缓冲区，所以函数终止并返回<code>0(</code>失败)。</li>
<li>如果缓冲区首部在间接缓冲区的链表中，该函数就从链表中删除它</li>
</ol>
</blockquote>
</li>
<li><p>清除页描述符的<code>PG_private</code>标记，把<code>private</code>字段设置为<code>NULL</code>，并递减页的使用计数器。清除页的<code>PG_dirty</code>标记。反复调用<code>free_buffer_head()</code>，以释放页的所有缓冲区首部。</p>
</li>
<li><p>返回<code>1</code>(成功)。</p>
</li>
</ol>
<h4 id="在页高速缓存中搜索块"><a href="#在页高速缓存中搜索块" class="headerlink" title="在页高速缓存中搜索块"></a>在页高速缓存中搜索块</h4><p>当内核需要读或写一个单独的物理设备块时(例如一个超级块)，必须检查所请求的块缓冲区是否已经在页高速缓存中。</p>
<p>在页高速缓存中搜索指定的块缓冲区(由块设备描述符的地址<code>bdev</code>和逻辑块号<code>nr</code>表示)的过程分成三个步骤：</p>
<ul>
<li>(1). 获取一个指针，让它指向包含指定块的块设备的<code>address_space</code>对象(<code>bdev-&gt;bd_inode-&gt;i_mapping</code>)。</li>
<li>(2). 获得设备的块大小(<code>bdev-&gt;bd_block_size</code>)，并计算包含指定块的页索引。</li>
<li>这需要在逻辑块号上进行位移操作。例如，如果块的大小是<code>1024</code>字节，每个缓冲区页包含四个块缓冲区，那么页的索引是<code>nr / 4</code>。</li>
<li>(3). 在块设备的基树中搜索缓冲区页。</li>
</ul>
<p>获得页描述符之后，内核访问缓冲区首部，它描述了页中块缓冲区的状态。不过，实现的细节要更为复杂。为了提高系统性能，内核维持一个小磁盘高速缓存数组<code>bh_lrus</code>(每个<code>CPU</code>对应一个数组元素)，即所谓的最近最少使用(<code>LRU</code>)块高速缓存。每个磁盘高速缓存有<code>8</code>个指针，指向被指定<code>CPU</code>最近访问过的缓冲区首部。对每个<code>CPU</code> 数组的元素排序，使指向最后被使用过的那个缓冲区首部的指针索引为<code>0</code>。相同的缓冲区首部可能出现在几个<code>CPU</code>数组中(但是同一个<code>CPU</code>数组中不会有相同的缓冲区首部)。在<code>LRU</code>块高速缓存中每出现一次缓冲区首部，该缓冲区首部的使用计数器<code>b_count</code> 就加<code>1</code>。</p>
<h4 id="find-get-block-函数"><a href="#find-get-block-函数" class="headerlink" title="__find_get_block()函数"></a>__find_get_block()函数</h4><p>函数<code>__find_get_block()</code>的参数有：<br><code>block_device</code>描述符地址<code>bdev</code>、块号<code>block</code>和块大小<code>size</code>。<br>函数返回页高速缓存中的块缓冲区对应的缓冲区首部的地址；如果不存在指定的块，就返回<code>NULL</code>。</p>
<p>该函数本质上执行下面的操作：</p>
<ol>
<li>检查执行<code>CPU</code>的<code>LRU</code>块高速缓存数组中是否有一个缓冲区首部，其<code>b_bdev</code>、<code>b_blocknr</code>和<code>b_size</code>字段分别等于<code>bdev</code>、<code>block</code>和<code>size</code>。</li>
<li>如果缓冲区首部在<code>LRU</code>块高速缓存中，就刷新数组中的元素，以便让指针指在第一个位置(索引为<code>0</code>)刚找到的缓冲区首部，递增它的<code>b_count</code>字段，并跳转到第<code>8</code>步。</li>
<li>如果缓冲区首部不在<code>LRU</code>块高速缓存中，根据块号和块大小得到与块设备相关的页的索引：<code>index= block &gt;&gt; (PAGE_SHIFT- bdev-&gt;bd_inode-&gt;i_blkbits)</code></li>
<li>调用<code>find_get_page()</code>确定存有所请求的块缓冲区的缓冲区页的描述符在页高速缓存中的位置。该函数传递的参数有：指向块设备的<code>address_space</code>对象的指针(<code>bdev-&gt;bd_inode-&gt;i_mapping</code>)和页索引。页索引用于确定存有所请求的块缓冲区的缓冲区页的描述符在页高速缓存中的位置。如果高速缓存中没有这样的页，就返回<code>NULL</code>(失败)。</li>
<li>此时，函数已经得到了缓冲区页描述符的地址：它扫描链接到缓冲区页的缓冲区首部链表，查找逻辑块号等于<code>block</code>的块。</li>
<li>递减页描述符的<code>count</code>字段(<code>find_get_page()</code>曾递增它的值)。</li>
<li>把<code>LRU</code>块高速缓存中的所有元素向下移动一个位置，并把指向所请求块的缓冲区首部的指针插入到第一个位置。如果一个缓冲区首部已经不在<code>LRU</code>块高速缓存中，就递减它的引用计数器<code>b_count</code>。</li>
<li>如果需要，就调用<code>mark_page_accessed()</code>把缓冲区页移至适当的<code>LRU</code>链表中。</li>
<li>返回缓冲区首部指针。</li>
</ol>
<h4 id="getblk-函数"><a href="#getblk-函数" class="headerlink" title="__getblk()函数"></a>__getblk()函数</h4><p>函数<code>__getblk()</code>与<code>__find_get_block()</code>接收相同的参数，也就是<code>block_device</code>描述符的地址<code>bdev</code>、块号<code>block</code>和块大小<code>size</code>，并返回与缓冲区对应的缓冲区首部的地址。即使块根本不存在，该函数也不会失败，<code>__getblk()</code>友好地分配块设备缓冲区页并返回将要描述块的缓冲区首部的指针。注意，<code>__getblk()</code>返回的块缓冲区不必存有有效数据——缓冲区首部的<code>BH_Uptodate</code>标志可能被清<code>0</code>。</p>
<p>函数<code>__getblk()</code>本质上执行下面的步骤：</p>
<ol>
<li>调用<code>__find_get_block()</code>检查块是否已经在页高速缓存中。如果找到块，则函数返回其缓冲区首部的地址。</li>
<li>否则，调用<code>grow_buffers()</code>为所请求的页分配一个新的缓冲区页。</li>
<li>如果<code>grow_buffers()</code>分配这样的页失败，<code>__getblk()</code>试图通过调用函数<code>free_more_memory()</code>回收一部分内存。</li>
<li>跳转到第<code>1</code>步。</li>
</ol>
<h4 id="bread-函数"><a href="#bread-函数" class="headerlink" title="__bread()函数"></a>__bread()函数</h4><p>函数<code>__bread()</code>接收与<code>__getblk()</code>相同的参数，即<code>block_device</code>描述符的地址<code>bdev</code>、块号<code>block</code>和块大小<code>size</code>，并返回与缓冲区对应的缓冲区首部的地址。与<code>__getblk()</code>相反的是，如果需要的话，在返回缓冲区首部之前函数<code>__bread()</code>从磁盘读块。</p>
<p>函数<code>__bread()</code>执行下述步骤：</p>
<ol>
<li>调用<code>__getblk()</code>在页高速缓存中查找与所请求的块相关的缓冲区页，并获得指向相应的缓冲区首部的指针。</li>
<li>如果块已经在页高速缓存中并包含有效数据(<code>BH_Uptodate</code>标志被置位)，就返回缓冲区首部的地址。</li>
<li>否则，递增缓冲区首部的引用计数器。</li>
<li>把<code>end_buffer_read_sync()</code>的地址赋给<code>b_end_io</code>字段。</li>
<li>调用<code>submit_bh()</code>把缓冲区首部传送到通用块层。</li>
<li>调用<code>wait_on_buffer()</code>把当前进程插入等待队列，直到<code>I/O</code>操作完成，即直到缓冲区首部的<code>BH_Lock</code>标志被清<code>0</code>。</li>
<li>返回缓冲区首部的地址。</li>
</ol>
<h4 id="向通用块层提交缓冲区首部"><a href="#向通用块层提交缓冲区首部" class="headerlink" title="向通用块层提交缓冲区首部"></a>向通用块层提交缓冲区首部</h4><p>一对<code>submit_bh()</code>和<code>ll_rw_block()</code>函数，允许内核对缓冲区首部描述的一个或多个缓冲区进行<code>I/O</code>数据传送。</p>
<h4 id="submit-bh-函数"><a href="#submit-bh-函数" class="headerlink" title="submit_bh()函数"></a>submit_bh()函数</h4><p>内核利用<code>submit_bh()</code>函数向通用块层传递一个缓冲区首部，并由此请求传输一个数据块。它的参数是数据传输的方向(本质上就是<code>READ</code>或<code>WRITE</code>)和指向描述块缓冲区的缓冲区首部的指针bh。</p>
<p><code>submit_bh()</code>函数假设缓冲区首部已经被彻底初始化；尤其是，必须正确地为<code>b_bdev</code>、<code>b_blocknr</code>和<code>b_size</code>字段赋值以标识包含所请求数据的磁盘上的块。如果块缓冲区在块设备缓冲区页中，就由<code>__find_get_block()</code>完成对缓冲区首部的初始化，就像在上一节所描述的。不过，我们将在下一章看到，还可以对普通文件所有的缓冲区页中的块调用<code>submit_bh()</code>。<code>submit_bh()</code>函数只是一个起连接作用的函数，它根据缓冲区首部的内容创建一个<code>bio</code> 请求，并随后调用<code>generic_make_request()</code>。</p>
<p>函数执行的主要步骤如下：</p>
<ol>
<li><p>设置缓冲区首部的<code>BH_Req</code>标志以表示块至少被访问过一次。此外，如果数据传输的方向是<code>WRITE</code>，就将<code>BH_Write_EIO</code>标志清<code>0</code>。</p>
</li>
<li><p>调用<code>bio_alloc()</code>分配一个新的<code>bio</code>描述符。</p>
</li>
<li><p>根据缓冲区首部的内容初始化<code>bio</code>描述符的字段：</p>
<blockquote>
<ol>
<li>把块中的第一个扇区的号(<code>bh-&gt;b_blocknr * bh-&gt;b_size / 512</code>)赋给<code>bi_sector</code>字段。</li>
<li>把块设备描述符的地址(<code>bh-&gt;b_bdev</code>)赋给<code>bi_bdev</code>字段。</li>
<li>把块大小(<code>bh-&gt;b_size</code>)赋给<code>bi_size</code>字段。</li>
<li>初始化<code>bi_io_vec</code>数组的第一个元素以使该段对应于块缓冲区：把<code>bh-&gt;b_page</code>赋给<code>bi_io_vec[0].bv_page</code>，把<code>bh-&gt;b_size</code>赋给<code>bi_io_vec[0].bv_len</code>，并把块缓冲区在页中的偏移量<code>bh-&gt;b_data</code>赋给<code>bi_io_vec[0].bv_offset</code>。</li>
<li>把<code>bi_vcnt</code>置为<code>1</code>(只有一个涉及<code>bio</code>的段)，并把<code>bi_idx</code>置为<code>0</code>(将要传输的是当前段)。</li>
<li>把<code>end_bio_bh_io_sync()</code>的地址赋给<code>bi_end_io</code>字段，并把缓冲区首部的地址赋给<code>bi_private</code>字段；数据传输结束时调用函数。</li>
</ol>
</blockquote>
</li>
<li><p>递增<code>bio</code>的引用计数器(它变为<code>2</code>)。</p>
</li>
<li><p>调用<code>submit_bio()</code>，把<code>bi_rw</code>标志设置为数据传输的方向，更新每<code>CPU</code>变量<code>page_states</code>以表示读和写的扇区数，并对<code>bio</code>描述符调用<code>generic_make_request()</code>函数。</p>
</li>
<li><p>递减<code>bio</code>的使用计数器；因为<code>bio</code>描述符现在已经被插人<code>I/O</code>调度程序的队列，所以没有释放<code>bio</code>描述符。</p>
</li>
<li><p>返回<code>0</code>(成功)。当针对<code>bio</code>上的<code>I/O</code>数据传输终止的时候，内核执行<code>bi_end_io</code>方法，具体来说执行<code>end_bio_bh_io_sync()</code>函数。后者本质上从<code>bio</code>的<code>bi_private</code>字段获取缓冲区首部的地址，然后调用缓冲区首部(在调用<code>submit_bh()</code>之前已为它正确赋值)的方法<code>b_end_io</code>，最后调用<code>bio_put()</code>释放<code>bio</code>结构。</p>
</li>
</ol>
<h4 id="ll-rw-block-函数"><a href="#ll-rw-block-函数" class="headerlink" title="ll_rw_block()函数"></a>ll_rw_block()函数</h4><p>有些时候内核必须立刻触发几个数据块的数据传输，这些数据块不一定物理上相邻。<br><code>ll_rw_block()</code>函数接收的参数有数据传输的方向(本质上就是<code>READ</code>或<code>WRITE</code>)、要传输的数据块的块号以及指向块缓冲区所对应的缓冲区首部的指针数组。</p>
<p>该函数在所有缓冲区首部上进行循环，每次循环执行下面的操作：</p>
<ol>
<li>检查并设置缓冲区首部的<code>BH_Lock</code>标志；如果缓冲区已经被锁住，而另外一个内核控制路径已经激活了数据传输，就不处理这个缓冲区，而跳转到第<code>9</code>步。</li>
<li>把缓冲区首部的使用计数器<code>b_count</code>加<code>1</code>。</li>
<li>如果数据传输的方向是<code>WRITE</code>，就让缓冲区首部的方法<code>b_end_io</code>指向函数<code>end_buffer_write_sync()</code>的地址，否则让<code>b_end_io</code>指向<code>end_buffer_read_sync()</code>函数的地址。</li>
<li>如果数据传输的方向是<code>WRITE</code>，就检查并清除缓冲区首部的<code>BH_Dirty</code>标志。如果该标志没有置位，就不必把块写入磁盘，因此跳转到第<code>7</code>步。</li>
<li>如果数据传输的方向是<code>READ</code>或<code>READA</code>(向前读)，检查缓冲区首部的<code>BH_Uptodate</code>标志是否被置位；如果是，就不必从磁盘读块，因此跳转到第<code>7</code>步。</li>
<li>此时必须读或写数据块：调用<code>submit_bh()</code>函数把缓冲区首部传递到通用块层，然后跳转到第<code>9</code>步。</li>
<li>通过清除<code>BH_Lock</code>标志为缓冲区首部解锁，然后唤醒所有等待块解锁的进程。</li>
<li>递减缓冲区首部的<code>b_count</code>字段。</li>
<li>如果数组中还有其他的缓冲区首部要处理，就选择下一个缓冲区首部并跳转回到第<code>1</code>步，否则，就结束。</li>
</ol>
<p>注意，如果函数<code>1l_rw_block()</code>把缓冲区首部传递到通用块层，而留下加了锁的缓冲区和增加了的引用计数器，这样，在完成数据传输之前就不可能访问该缓冲区，也不可能释放这个缓冲区。当块的数据传送结束时，内核执行缓冲区首部的<code>b_end_io</code>方法。<br>假设没有<code>I/O</code>错误，<code>end_buffer_write_sync()</code>和<code>end_buffer_read_sync()</code>函数只是简单地把缓冲区首部的<code>BH_Uptodate</code>字段置位，为缓冲区解锁，并递减它的引用计数器。</p>
<h4 id="把脏页写入磁盘"><a href="#把脏页写入磁盘" class="headerlink" title="把脏页写入磁盘"></a>把脏页写入磁盘</h4><p>正如我们所了解的，内核不断用包含块设备数据的页填充页高速缓存。<br>只要进程修改了数据，相应的页就被标记为脏页，即把它的<code>PG_dirty</code>标志置位。<br><code>Unix</code>系统允许把脏缓冲区写入块设备的操作延迟执行，因为这种策略可以显著地提高系统的性能。<br>对高速缓存中的页的几次写操作可能只需对相应的磁盘块进行一次缓慢的物理更新就可以满足。<br>此外，写操作没有读操作那么紧迫，因为进程通常是不会由于延迟写而挂起，而大部分情况都因为延迟读而挂起。<br>正是由于延迟写，使得任一物理块设备平均为读请求提供的服务将多于写请求。</p>
<p>一个脏页可能直到最后一刻(即直到系统关闭时)都一直逗留在主存中。然而，从延迟写策略的局限性来看，它有两个主要的缺点：<br>(1). 如果发生了硬件错误或电源掉电的情况，那么就无法再获得<code>RAM</code>的内容，因此，从系统启动以来对文件进行的很多修改就丢失了。<br>(2). 页高速缓存的大小(由此存放它所需的<code>RAM</code>的大小)就可能要很大——至少要与所访问块设备的大小相同。<br>因此，在下列条件下把脏页刷新(写入)到磁盘：<br>a. 页高速缓存变得太满，但还需要更多的页，或者脏页的数量已经太多。<br>b. 自从页变成脏页以来已过去太长时间。<br>c. 进程请求对块设备或者特定文件任何待定的变化都进行刷新。</p>
<p>通过调用<code>sync()</code>、<code>fsync()</code>或<code>fdatasync()</code>系统调用来实现。<br>缓冲区页的引入使问题更加复杂。与每个缓冲区页相关的缓冲区首部使内核能够了解每个独立块缓冲区的状态。如果至少有一个缓冲区首部的<code>BH_Dirty</code>标志被置位，就应该设置相应缓冲区页的<code>PG_dirty</code>标志。当内核选择要刷新的缓冲区页时，它扫描相应的缓冲区首部，并只把脏块的内容有效地写到磁盘。一旦内核把页缓冲区的所有脏块刷新到磁盘，就把页的<code>PG_dirty</code>标记清<code>0</code>。</p>
<h4 id="pdflush内核线程"><a href="#pdflush内核线程" class="headerlink" title="pdflush内核线程"></a>pdflush内核线程</h4><p>早期版本的<code>Linux</code>使用<code>bdflush</code>内核线程系统地扫描页高速缓存以搜索要刷新的脏页，并且使用另一个内核线程<code>kupdate</code>来保证所有的页不会“脏”太长的时间。<code>Linux 2.6</code>用一组通用内核线程<code>pdflush</code>代替上述两个线程。<br>这些内核线程结构灵活，它们作用于两个参数：<br>一个指向线程要执行的函数的指针和一个函数要用的参数。</p>
<p>系统中<code>pdflush</code>内核线程的数量是要动态调整的：<br><code>pdflush</code>线程太少时就创建，太多时就杀死。</p>
<p>因为这些内核线程所执行的函数可以阻塞，所以创建多个而不是一个<code>pdflush</code>内核线程可以改善系统性能。<br>根据下面的原则控制<code>pdflush</code>线程的产生和消亡:</p>
<ul>
<li>(1). 必须有至少两个，最多八个<code>pdflush</code>内核线程。</li>
<li>(2). 如果到最近的1s期间没有空闲<code>pdflush</code>，就应该创建新的<code>pdflush</code>。</li>
<li>(3). 如果最近一次<code>pdflush</code>变为空闲的时间超过了1s，就应该删除一个<code>pdflush</code>。</li>
</ul>
<p>所有的<code>pdflush</code>内核线程都有<code>pdflush_work</code>描述符。空闲<code>pdflush</code>内核线程的描述符都集中在<code>pdFlush_list</code>链表中；<br>在多处理器系统中，<code>pdflush_lock</code>自旋锁保护该链表不会被并发访问。<code>nr_pdflush_threads</code>变量存放<code>pdflush</code>内核线程(空闲的或忙的)的总数。最后，<code>last_empty_jifs</code>变量存放<code>pdflush</code>线程的<code>pdflush_list</code>链表变为空的时间(以<code>jiffies</code>表示)。<br><img src=".\image-20240503155501347.png" alt="image-20240503155501347"></p>
<p>所有<code>pdflush</code>内核线程都执行函数<code>__pdflush()</code>，它本质上循环执行一直到内核线程死亡。我们不妨假设<code>pdflush</code>内核线程是空闲的，而进程正在<code>TASK_INTERRUPTIBLE</code>状态睡眠。一但内核线程被唤醒，<code>__pdflush()</code>就访问其<code>pdflush_work</code>描述符，并执行字段<code>fn</code>中的回调函数，把<code>arg0</code>字段中的参数传递给该函数。</p>
<p>当回调函数结束时，<code>__pdflush()</code>检查<code>last_empty_jifs</code>变量的值如果不存在空闲<code>pdflush</code>内核线程的时间已经超过<code>1s</code>，而且<code>pdflush</code>内核线程的数量不到<code>8</code>个，函数<code>__pdflush()</code>就创建另外一个内核线程。相反，如果<code>pdflush_list</code>链表中的最后一项对应的<code>pdflush</code>内核线程空闲时间超过了<code>1s</code>，而且系统中有两个以上的<code>pdflush</code>内核线程，函数<code>__pdflush()</code>就终止：相应的内核线程执行<code>_exit()</code>系统调用，并因此而被撤消。否则，如果系统中<code>pdflush</code>内核线程不多于两个，<code>__pdflush()</code>就把内核线程的<code>pdflush_work</code>描述符重新插入到<code>pdflush_list</code>链表中，并使内核线程睡眠。</p>
<p><code>pdflush_operation()</code>函数用来激活空闲的<code>pdflush</code>内核线程。该函数作用于两个参数：一个指针<code>fn</code>，指向必须执行的函数；以及参数<code>arg0</code>。<br>函数执行下面的步骤：<br>(1). 从<code>pdflush_list</code>链表中获取<code>pdf</code>指针，它指向空闲<code>pdlush</code>内核线程的<code>pdflush_work</code>描述符。如果链表为空，就返回<code>-1</code>。如果链表中仅剩一个元素，就把<code>jiffies</code>的值赋给变量<code>last_empty_jifs</code>。<br>(2). 把参数<code>fn</code>和<code>arg0</code>分别赋给<code>pdf-&gt;fn</code>和<code>pdf-&gt;arg0</code>。<br>(3). 调用<code>wake_up_process()</code>唤醒空闲的<code>pdflush</code>内核线程，即<code>pdf-&gt;who</code>。把哪些工作委托给<code>Pdflush</code>内核线程来完成呢?其中一些工作与脏数据的刷新相关。尤其是，<code>pdflush</code>通常执行下面的回调函数之一：<br>a. <code>background_writeout()</code>：系统地扫描页高速缓存以搜索要刷新的脏页。<br>b. <code>wb_kupdate()</code>：检查页高速缓存中是否有“脏”了很长时间的页。</p>
<h4 id="搜索要刷新的脏页"><a href="#搜索要刷新的脏页" class="headerlink" title="搜索要刷新的脏页"></a>搜索要刷新的脏页</h4><p>所有的基树都可能有要刷新的脏页。为了得到所有这些页，就要彻底搜索与在磁盘上有映像的索引节点相应的所有<code>address_space</code>对象。由于页高速缓存可能有大量的页，如果用一个单独的执行流来扫描整个高速缓存，会令<code>CPU</code>和磁盘长时间繁忙。因此，<code>Linux</code> 使用一种复杂的机制把对页高速缓存的扫描划分为几个执行流。</p>
<p><code>wakeup_bdflush()</code>函数接收页高速缓存中应该刷新的脏页数量作为参数；<br><code>0</code>值表示高速缓存中的所有脏页都应该写回磁盘。<br>该函数调用<code>pdflush_operation()</code>唤醒<code>pdflush</code>内核线程，并委托它执行回调函数<code>background_writeout()</code>，后者有效地从页高速缓存获得指定数量的脏页，并把它们写回磁盘。当内存不足或用户显式地请求刷新操作时执行<code>wakeup_bdflush()</code>函数。</p>
<p>特别是在下述情况下会调用该函数：</p>
<ul>
<li>(1). 用户态进程发出<code>sync()</code>系统调用</li>
<li>(2). <code>grow_buffers()</code>函数分配一个新缓冲区页时失败</li>
<li>(3). 页框回收算法调用<code>free_more_memory()</code>或<code>try_to_free_pages()</code></li>
<li>(4). <code>mempool_alloc()</code>函数分配一个新的内存池元素时失败</li>
</ul>
<p>此外，执行<code>background_writeout()</code>回调函数的<code>pdflush</code>内核线程也可由满足以下两个条件的进程唤醒的：<br>一是对页高速缓存中的页内容进行了修改，<br>二是引起脏页部分增加到超过某个脏背景阈值(<code>background threshold</code>)。<br>背景阈值通常设置为系统中所有页的<code>10%</code>，不过可以通过修改文件<code>/proc/sys/vm/dirty_background_ratio</code>来调整这个值。</p>
<p><code>background_writeout()</code>函数依赖于作为双向通信设备的<code>writeback_control</code>结构：<br>一方面，它告诉辅助函数<code>writeback_inodes()</code>要做什么；<br>另一方面，它保存写回磁盘的页的数量的统计值。下面是这个结构最重要的字段：<br><code>sync_mode</code>，表示同步模式：<code>WB_SYNC_ALL</code>表示如果遇到一个上锁的索引节点，必须等待而不能略过它；<code>WB_SYNC_HOLD</code>表示把上锁的索引节点放入稍后涉及的链表中；<code>WB_SYNC_NONE</code>表示简单地略过上锁的索引节点。<br><code>bdi</code>，如果不为空，就指向<code>backing_dev_info</code>结构。此时，只有属于基本块设备的脏页将会被刷新。<br><code>older_than_this</code>，如果不为空，就表示应该略过比指定值还新的索引节点。<br><code>nr_to_write</code>，当前执行流中仍然要写的脏页的数量。<br><code>nonblocking</code>，如果这个标志被置位，就不能阻塞进程。</p>
<p><code>background_writeout()</code>函数只作用于一个参数<code>nr_pages</code>，表示应该刷新到磁盘的最少页数。它本质上执行下述步骤：</p>
<ul>
<li>从每<code>CPU</code>变量<code>page_state</code>中读当前页高速缓存中页和脏页的数量。如果脏页所占的比例低于给定的阀值，而且已经至少有<code>nr_pages</code>页被刷新到磁盘，该函数就终止。这个阈值通常大约是系统中总页数的<code>40%</code>，可以通过写文件<code>/proc/sys/vmldirty_ratio</code>来调整这个值。</li>
<li>调用<code>writeback_inodes()</code>尝试写<code>1024</code>个脏页(见下面)。</li>
<li>检查有效写过的页的数量，并减少需要写的页的个数。</li>
<li>如果已经写过的页少于<code>1024</code>页，或略过了一些页，则可能块设备的请求队列处于拥塞状态：此时，<code>background_writeout()</code>函数使当前进程在特定的等待队列上睡眠<code>100ms</code>，或使当前进程睡眠到队列变得不拥塞。</li>
<li>返回到第<code>1</code>步。</li>
</ul>
<p><code>writeback_inodes()</code>函数只作用于一个参数，就是指针<code>wbc</code>，它指向<code>writeback_control</code> 描述符。该描述符的<code>nr_to_write</code>字段存有要刷新到磁盘的页数。函数返回时，该字段存有要刷新到磁盘的剩余页数，如果一切顺利，则该字段的值被赋为<code>0</code>。</p>
<p>我们假设<code>writeback_inodes()</code>函数被调用的条件为：</p>
<ul>
<li>指针<code>wbc-&gt;bdi</code>和<code>wbc -&gt;older_than_this</code>被置为<code>NULL</code>,</li>
<li><code>WB_SYNC_NONE</code>同步模式和<code>wbc-&gt;nonblocking</code>标志置位(这些值都由<code>background_writeout()</code>函数设置)。</li>
</ul>
<p>函数<code>writeback_inodes()</code>扫描在<code>super_blocks</code>变量中建立的超级块链表。当遍历完整个链表或刷新的页数达到预期数量时，就停止扫描。对每个超级块<code>sb</code>。</p>
<p>函数执行下述步骤：</p>
<ol>
<li><p>检查<code>sb-&gt;s_dirty</code>或<code>sb-&gt;s_io</code>链表是否为空：第一个链表集中了超级块的脏索引节点，而第二个链表集中了等待被传输到磁盘的索引节点(见下面)。如果两个链表都为空，说明相应文件系统的索引节点没有脏页，因此函数处理链表中的下一个超级块。</p>
</li>
<li><p>此时，超级块有脏索引节点。对超级块<code>sb</code>调用<code>sync_sb_inodes()</code>，该函数执行下面的操作：</p>
<blockquote>
<ol>
<li>把<code>sb-&gt;s_dirty</code>的所有索引节点插入<code>sb-&gt;s_io</code>指向的链表，并清空脏索引节点链表。</li>
<li>从<code>sb-&gt;s_io</code>获得下一个索引节点的指针。如果该链表为空，就返回。</li>
<li>如果<code>sync_sb_inodes()</code>函数开始执行后，索引节点变为脏节点，就略过这个索引节点的脏页并返回。注意，<code>sb-&gt;s_io</code>链表中可能残留一些脏索引节点。</li>
<li>如果当前进程是<code>pdflush</code>内核线程，<code>sync_sb_inodes()</code>就检查运行在另一个<code>CPU</code>上的<code>pdflush</code>内核线程是否已经试图刷新这个块设备文件的脏页。这是通过一个原子测试和对索引节点的<code>backing_dev_info</code>的<code>BDI_pdflush</code>标志的设置操作来完成的。本质上，它对同一个请求队列上有多个<code>pdflush</code>内核线程是毫无意义的。</li>
<li>把索引节点的引用计数器加1。</li>
<li>调用<code>__writeback_single_inode()</code>回写与所选择的索引节点相关的脏缓冲区</li>
<li>如果索引节点被锁定，就把它移到脏索引节点链表中(<code>inode-&gt;i_sb-&gt;s_dirty</code>)并返回<code>0</code>。(因为我们假定<code>wbc-&gt;sync_mode</code>字段不等于<code>WB_SYNC_ALL</code>，所以函数不会因为等待索引结点解锁而阻塞。)</li>
<li>使用索引节点地址空间的<code>writepages</code>方法，或者在没有这个方法的情况下使用<code>mpage_writepages()</code>函数来写<code>wbc-&gt;nr_to_write</code>个脏页。该函数调用<code>find_get_pages_tag()</code>函数快速获得索引节点地址空间的所有脏页，细节将在下一章描述。</li>
<li>如果索引节点是脏的，就用超级块的<code>write_inode</code>方法把索引节点写到磁盘。实现该方法的函数通常依靠<code>submit_bh()</code>来传输一个数据块。</li>
<li>检查索引节点的状态。如果索引节点还有脏页，就把索引节点移回<code>sb-&gt;s_dirty</code>链表；如果索引节点引用计数器为<code>0</code>，就把索引节点移到<code>inode_unused</code>链表中；否则就把索引节点移到<code>inode_in_use</code>链表中。</li>
<li>返回在错误代码。</li>
<li>回到<code>sync_sb_inodes()</code>函数中。如果当前进程是<code>pdflush</code>内核线程，就把在第<code>2d</code>步设置的<code>BDI_pdflush</code>标志清<code>0</code>。</li>
<li>如果略过了刚处理的索引节点中的一些页，那么该索引节点包括锁定的缓冲区：把<code>sb-&gt;S_io</code>链表中的所有剩余索引节点移回到<code>sb-&gt;s_dirty</code>链表中，以后将重新处理它们。</li>
<li>把索引节点的引用计数器减<code>1</code>。</li>
<li>如果<code>wbc-&gt;nr_to_write</code>大于<code>0</code>，则回到第2.2步搜索同一个超级块的其他脏索引节点。否则，<code>sync_sb_inodes()</code>函数终止。</li>
</ol>
</blockquote>
</li>
<li><p>回到<code>writeback_inodes()</code>函数中。如果<code>wbc-&gt;nr_to_write</code>大于<code>0</code>，就跳转到第<code>1</code>步，并继续处理全局链表中的下一个超级块。否则，就返回。</p>
</li>
</ol>
<h4 id="回写陈旧的脏页"><a href="#回写陈旧的脏页" class="headerlink" title="回写陈旧的脏页"></a>回写陈旧的脏页</h4><p>如前所述，内核试图避免当一些页很久没有被刷新时发生饥饿危险。因此，脏页在保留一定时间后，内核就显式地开始进行<code>I/O</code>数据的传输，把脏页的内容写到磁盘。回写陈旧脏页的工作委托给了被定期唤醒的<code>pdflush</code>内核线程。在内核初始化期间，<code>page_writeback_init()</code>函数建立<code>wb_timer</code>动态定时器，以便定时器的到期时间发生在<code>dirty_writeback_centisecs</code>文件中所规定的几百分之一秒之后(通常是<code>500</code>分之一秒，不过可以通过修改<code>/proc/sys/vm/dirty_writeback_centisecs</code>文件调整这个值)。</p>
<p>定时器函数<code>wb_timer_fn()</code>本质上调用<code>pdflush_operation()</code>函数，传递给它的参数是回调函数<code>wb_kupdate()</code>的地址。<code>wb_kupdate()</code>函数遍历页高速缓存搜索陈旧的脏索引节点。</p>
<p>它执行下面的步骤：</p>
<ol>
<li>调用<code>sync_supers()</code>函数把脏的超级块写到磁盘中。虽然这与页高速缓存中的页刷新没有很密切的关系，但对<code>sync_supers()</code>的调用确保了任何超级块脏的时间通常不会超过<code>5s</code>。</li>
<li>把当前时间减<code>30s</code>所对应的值(用<code>jiffies</code>表示)的指针存放在<code>writeback_control</code>描述符的<code>older_than_this</code>字段中。允许一个页保持脏状态的最长时间是<code>30s</code>。</li>
<li>根据每<code>CPU</code>变量<code>page_state</code>确定当前在页高速缓存中脏页的大概数量。</li>
<li>反复调用<code>writeback_inodes()</code>，直到写入磁盘的页数等于上一步所确定的值，或直到把所有保持脏状态时间超过<code>30s</code>的页都写到磁盘。如果在循环的过程中一些请求队列变得拥塞，函数就可能去睡眠。</li>
<li>用<code>mod_timer()</code>重新启动<code>wb_timer</code>动态定时器：</li>
<li>一旦从调用该函数开始经历过文件<code>dirty_writeback_centisecs</code>中规定的几百分之一秒时间后，定时器到期(或者如果本次执行的时间太长，就从现在开始<code>1s</code>后到期)。</li>
</ol>
<h4 id="sync-、fsync-和fdatasync-系统调用"><a href="#sync-、fsync-和fdatasync-系统调用" class="headerlink" title="sync()、fsync()和fdatasync()系统调用"></a>sync()、fsync()和fdatasync()系统调用</h4><p>在本节我们简要介绍用户应用程序把脏缓冲区刷新到磁盘会用到的三个系统调用：<br><code>sync()</code>，允许进程把所有的脏缓冲区刷新到磁盘<br><code>fsync()</code>，允许进程把属于特定打开文件的所有块刷新到磁盘。<br><code>fdatasync()</code>，与<code>fsync()</code>非常相似，但不刷新文件的索引节点块。</p>
<h4 id="sync-系统调用"><a href="#sync-系统调用" class="headerlink" title="sync()系统调用"></a>sync()系统调用</h4><p><code>sync()</code>系统调用的服务例程<code>sys_sync()</code>调用一系列辅助函数：</p>
<pre class="line-numbers language-none"><code class="language-none">wakeup_bdflush(0);
sync_inodes(0);
sync_supers();
sync_filesystems(0);
sync_filesystems(1);
sync_inodes(1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正如上一节所描述的，<code>wakeup_bdflush()</code>启动<code>pdflush</code>内核线程，把页高速缓存中的所有脏页刷新到磁盘。<br><code>sync_inodes()</code>函数扫描超级块的链表以搜索要刷新的脏索引节点；它作用于参数<code>wait</code>，该参数表示在执行完刷新之前函数是否必须等待。函数扫描当前已安装的所有文件系统的超级块；对于每个包含脏索引节点的超级块，<code>sync_inodes()</code></p>
<p>​    首先调用<code>sync_sb_inodes()</code>刷新相应的脏页，然后调用<code>sync_blockdev()</code>显式刷新该超级块所在块设备的脏缓冲区页。</p>
<p>​    这一步之所以能完成是因为许多磁盘文件系统的<code>write_inode</code>超级块方法仅仅把磁盘索引节点对应的块缓冲区标记为“脏”；</p>
<ul>
<li>函数<code>sync_blockdev()</code>确保把<code>sync_sb_inodes()</code>所完成的更新有效地写到磁盘。</li>
<li>函数<code>sync_supers()</code>把脏超级块写到磁盘，如果需要，也可以使用适当的<code>write_super</code> 超级块操作。</li>
<li>最后，<code>sync_filesystems()</code>为所有可写的文件系统执行<code>sync_fs</code>超级块方法。</li>
</ul>
<p>​    该方法只不过是提供给文件系统的一个“钩子”，在需要对每个同步执行一些特殊操作时使用，只有像<code>Ext3</code>这样的日志文件系统使用这个方法。注意，<code>sync_inodes()</code>和<code>sync_filesystems()</code>都是被调用两次，一次是参数<code>wait</code>等于<code>0</code>时，另一次是<code>wait</code>等于<code>1</code>时。</p>
<p>​    这样做的目的是：首先，它们把未上锁的索引节点快速刷新到磁盘；其次，它们等待所有上锁的索引节点被解锁，然后把它们逐个地写到磁盘。</p>
<h4 id="fsync-和fdatasync-系统调用"><a href="#fsync-和fdatasync-系统调用" class="headerlink" title="fsync()和fdatasync()系统调用"></a>fsync()和fdatasync()系统调用</h4><p>系统调用<code>fsync()</code>强制内核把文件描述符参数<code>fd</code>所指定文件的所有脏缓冲区写到磁盘中(如果需要，还包括存有索引节点的缓冲区)。相应的服务例程获得文件对象的地址，并随后调用<code>fsync</code>方法。通常这个方法以调用函数<code>__writeback_single_inode</code>结束，该函数把与被选中的索引节点相关的脏页和索引节点本身都写回磁盘。</p>
<p>系统调用<code>fdatasync()</code>与<code>fsync()</code>非常相似，但是它只把包含文件数据而不是那些包含索引节点信息的缓冲区写到磁盘。由于<code>Linux 2.6</code>没有提供专门的<code>fdatasync()</code>文件方法，该系统调用使用<code>fsync</code>方法，因此与<code>fsync()</code>是相同的。</p>
<h1 id="页框回收"><a href="#页框回收" class="headerlink" title="页框回收"></a>页框回收</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><code>Linux</code>内核的页框回收算法(<code>page frame reclaiming algorithm</code>，<code>PFRA</code>)采取从用户态进程和内核高速缓存“窃取”页框的办法补充<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=伙伴系统&amp;spm=1001.2101.3001.7020">伙伴系统</a>的空闲块列表。</p>
<h4 id="1-选择目标页"><a href="#1-选择目标页" class="headerlink" title="1.选择目标页"></a>1.选择目标页</h4><p>页框回收算法(<code>PFRA</code>)的目标就是获得页框并使之空闲。显然，<code>PFRA</code>选取的页框肯定不是空闲的，即这些页框原本不在伙伴系统的任何一个<code>free_area</code>数组中。<code>PFRA</code>按照页框所含内容，以不同的方式处理页框。</p>
<p>我们将它们区分成：不可回收页、可交换页、可同步页和可丢弃页，如表17-1所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>页框类型</th>
<th>说明</th>
<th>回收操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>不可回收页</td>
<td>空闲页，保留页（PG_reserved），内核动态分配页，进程内核态堆栈页，临时锁定页（PG_locked），内存锁定页（VM_LOCKED）</td>
<td>无需回收</td>
</tr>
<tr>
<td>可交换页</td>
<td>用户态地址空间的匿名线性区的页（用户态堆，用户态栈），tmpfs文件系统的映射页（IPC共享内存页）</td>
<td>将页的内容写入磁盘交换区</td>
</tr>
<tr>
<td>可同步页</td>
<td>用户态地址空间有名线性区（又可分为匿名映射，文件映射）下的页，存有磁盘文件数据且在高速缓存中的页，块设备缓存区页</td>
<td>将页内容写入磁盘对应位置</td>
</tr>
<tr>
<td>可丢弃页</td>
<td>用于slab的页</td>
<td>无需操作</td>
</tr>
</tbody>
</table>
</div>
<p>采用mmap得到的用户态线性区中的页称为可同步的，为回收页框，内核必须检查页是否为脏，而且必要时将页的内容写到相应的磁盘文件中。</p>
<p>进程的匿名线性区(如进程的用户态堆和堆栈对应的线性区)中的页称为可交换的，为回收页框，内核必须将页中内容保存到一个专门的磁盘分区或磁盘文件，叫做“交换区”。tmpfs下的映射页用于实现IPC共享内存，也算可交换的。</p>
<p>当<code>PFRA</code>必须回收属于某进程用户态地址空间的页框时，它必须考虑页框是否为共享的。共享页框属于多个用户态地址空间，而非共享页框属于单个用户态地址空间。同一线程组内多个线程共享一个用户态地址空间。</p>
<h4 id="2-PFRA设计"><a href="#2-PFRA设计" class="headerlink" title="2.PFRA设计"></a>2.PFRA设计</h4><p>让我们先看看<code>PFRA</code>采用的几个总的原则，这些原则包含在本章后面介绍的几个函数中。</p>
<ol>
<li>首先释放“无害”页</li>
</ol>
<blockquote>
<p>先回收没有被任何进程使用的磁盘高速缓存，内存高速缓存中的页框。</p>
<p>再回收被进程使用的页框。</p>
</blockquote>
<ol>
<li>将用户态进程的所有页定为可回收页，除了锁定页，<code>FPRA</code>必须能够窃得任何用户态进程页，包括匿名页。</li>
<li>同时取消引用一个共享页框的所有页表项的映射，就可以回收该共享页框。当<code>PFRA</code>要释放几个进程共享的页框时，它就清空引用该页框的所有页表项，然后回收该页框。</li>
<li>只回收“未用”页。使用简化的最近最少使用(<code>Least Recently Used</code>，<code>LRU</code>)置换算法，<code>PFRA</code>将页分为“在用(<code>in_use</code>)”与“未用(<code>unused</code>)”。如果某页很长时间没有被访问，那么它将来被访问的可能性较小，就可以将它看作未用；另一方面，如果某页最近被访问过，那么它将来被访问的可能性较大，就必须将它看作在用。<code>PFRA</code>只回收未用页。</li>
</ol>
<p><code>Linux</code>使用每个页表项中的访问标志位(<code>Accessed</code>)，在页被访问时，该标志位由硬件自动置位；而且，页年龄由页描述符在链表(两个不同的链表之一)中的位置来表示。因此，页框回收算法是几种启发式方法的混合：</p>
<ul>
<li>(1). 谨慎选择检查高速缓存的顺序。</li>
<li>(2). 基于页年龄的变化排序(在释放最近访问的页之前，应当释放最近最少使用的页)。</li>
<li>(3). 区别对待不同状态的页(例如，不脏的页与脏页之间，最好把前者换出，因为前者不必写磁盘)。</li>
</ul>
<h4 id="3-反向映射"><a href="#3-反向映射" class="headerlink" title="3.反向映射"></a>3.反向映射</h4><p><code>Linux 2.6</code>内核能够快速定位指向同一页框的所有页表项。这个过程就叫做反向映射(<code>reverse mapping</code>)。<br>实际上，对任何可回收的用户态页，内核保留系统中该页所在所有线性区(“对象”)的反向链接，每个线性区描述符存放一个指针指向一个内存描述符，而该内存描述符又包含一个指针指向一个页全局目录(<code>Page Global Directory</code>)。因此，这些反向链接使得<code>PFRA</code>能够检索引用某页的所有页表项。因为线性区描述符比页描述符少，所以更新共享页的反向链接就比较省时间。我们来看看这一方法是如何实现的。</p>
<p>首先，<code>PFRA</code>必须要确定待回收页是共享的或是非共享的，以及是映射页或是匿名页。为做到这一点，内核要查看页描述符的两个字段：<code>_mapcount</code>和<code>mapping</code>。<code>_mapcount</code>字段存放引用页框的页表项数目。计数器的起始值为<code>-1</code>，这表示没有页表项引用该页框；如果值为<code>0</code>，就表示页是非共享的；而如果值大于<code>0</code>，则表示页是共享的。</p>
<p><code>page_mapcount</code>函数接收页描述符地址，返回值为<code>_mapcount + 1</code> (这样，如返回值为<code>1</code>，表明是某个进程的用户态地址空间中存放的一个非共享页)。</p>
<p>页描述符的<code>mapping</code>字段用于确定页是映射的或匿名的。说明如下：</p>
<ol>
<li>如果<code>mapping</code>字段空，则该页属于交换高速缓存。</li>
<li>如果<code>mapping</code>字段非空，且最低位是<code>1</code>，表示该页为匿名页；同时<code>mapping</code>字段中存放的是指向<code>anon_vma</code>（用于找到匿名线性区）描述符的指针。</li>
<li>如果<code>mapping</code>字段非空，且最低位是<code>0</code>，表示该页为映射页；同时<code>mapping</code>字段指向对应文件的<code>address_space</code>（用于找到位于磁盘后备对象）对象。</li>
</ol>
<ul>
<li><code>PageAnon()</code>：函数接收页描述符地址作为参数，如果<code>mapping</code>字段的最低位置位，则函数返回<code>1</code>；否则返回<code>0</code>。</li>
<li><code>try_to_unmap()</code>：函数接收页描述符指针作为参数，尝试清空所有引用该页描述符对应页框的页表项。如果从页表项中成功清除所有对该页框的应用，函数返回<code>SWAP_SUCCESS (0)</code>；如果有些引用不能清除，函数返回<code>SWAP_AGAIN(1)</code>；如果出错，函数返回<code>SWAP_FAIL</code></li>
</ul>
<p>这个函数很短：</p>
<pre class="line-numbers language-none"><code class="language-none">int try_to_unmap(struct page *page)
&#123;
	int ret;
	if(PageAnon(page))
		ret &#x3D; try_to_unmap_anon(page);
	else
		ret &#x3D; try_to_unmap_file(page);
	
	if(!page_mapped(page))
		ret &#x3D; SWAP_SUCCESS;
	return ret;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数<code>try_to_unmap_anon()</code>和<code>try_to_unmap_file()</code>分别处理匿名页和映射页。后面会对这两个函数加以说明。</p>
<h4 id="3-1-匿名页的反向映射"><a href="#3-1-匿名页的反向映射" class="headerlink" title="3.1.匿名页的反向映射"></a>3.1.匿名页的反向映射</h4><p>匿名页的共享主要在父子进程间。将引用同一个页框的所有匿名页链接起来的策略非常简单，即将该页框所在的匿名线性区存放在一个双向循环链表中。当为一个匿名线性区分配第一页时，内核创建一个新的<code>anon_vma</code>数据结构，它只有两个字段：<code>lock</code>和<code>head</code>。<code>lock</code>字段是竞争条件下保护链表的自旋锁；<code>head</code>字段是线性区描述符双向循环链表的头部。然后，内核将匿名线性区的<code>vm_area_struct</code>描述符插入<code>anon_vma</code>链表。为实现这个目的，<code>vm_area_struct</code>数据结构中包含有对应该链表的两个字段：<code>anon_vma_node</code>（自身作为一个节点存在于双向链表）和<code>anon_vma</code>（指向双向链表哨兵节点）。最后，按前面所述，内核将<code>anon_vma</code>数据结构的地址存放在匿名页描述符的<code>mapping</code>字段。调用<code>fork()</code>系统调用实现匿名页父子间共享时，内核只是将第二个进程的匿名线性区插入<code>anon_vma</code>数据结构的双向循环链表。</p>
<h4 id="3-2-try-to-unmap-anon-函数"><a href="#3-2-try-to-unmap-anon-函数" class="headerlink" title="3.2.try_to_unmap_anon()函数"></a>3.2.try_to_unmap_anon()函数</h4><p>当回收匿名页框时，<code>PFRA</code>必须扫描<code>anon_vma</code>链表中的所有线性区，仔细检查是否每个区域都存有一个匿名页，而其对应的页框就是目标页框。</p>
<p><code>try_to_unmap_anon()</code>：</p>
<p>参数：</p>
<ul>
<li>目标页框描述符</li>
</ul>
<p>主要步骤：</p>
<ol>
<li>获得<code>anon_vma</code>数据结构的自旋锁，页描述符的<code>mapping</code>字段指向该数据结构。</li>
<li>扫描线性区描述符的<code>anon_vma</code>链表。<br>对该链表中的每一个<code>vma</code>线性区描述符，调用<code>try_to_unmap_one()</code>函数，传给它参数<code>vma</code>和页描述符。如果由于某种原因返回值为<code>SWAP_FAIL</code>，或如果页描述符的<code>_mapcount</code>字段表明已找到所有引用该页框的页表项，那么停止扫描，而不用扫描到链表底部。</li>
<li>释放第1步得到的自旋锁。</li>
<li>返回最后调用<code>try_to_unmap_one()</code>函数得到的值：<code>SWAP_AGAIN</code>(部分成功)或<code>SWAP_FAIL</code>(失败)。</li>
</ol>
<h4 id="3-3-try-to-unmap-one-函数"><a href="#3-3-try-to-unmap-one-函数" class="headerlink" title="3.3.try_to_unmap_one()函数"></a>3.3.try_to_unmap_one()函数</h4><p><code>try_to_unmap_one()</code>函数由<code>try_to_unmap_anon()</code>和<code>try_to_unmap_file()</code>重复调用。<br>参数：</p>
<ul>
<li><code>page</code>，是一个指向目标页描述符的指针；</li>
<li><code>vma</code>，而<code>vma</code>是指向线性区描述符的指针。</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>计算出待回收页的线性地址，所依据的参数有：线性区的起始线性地址(<code>vma-&gt;vm_start</code>)、被映射文件的线性区偏移量(<code>vma-&gt;vmpgoff</code>)，被映射文件内的页偏移量(<code>page-&gt;index</code>，这说明匿名页在多个共享其的线性区内相对于线性区起始的偏移一致)。对于匿名页，<code>vma-&gt;vmpgoff</code>字段是<code>0</code> 或者 <code>vm_start / PAGE_SIZE</code>；相应地，<code>page-&gt;index</code>字段是区域内的页索引或是页的线性地址除以<code>PAGE_SIZE</code>。</p>
</li>
<li><p>如果目标页是匿名页，则检查页的线性地址是否在线性区内。如果不是，则结束并返回<code>SWAP_AGAIN</code>。</p>
</li>
<li><p>从<code>vma-&gt;vm_mm</code>得到内存描述符地址，并获得保护页表的自旋锁<code>vma-&gt;vm_mn-&gt;page_table_lock</code>。</p>
</li>
<li><p>成功调用<code>pgd_offset()</code>、<code>pud_offset()</code>、<code>pmd_offset()</code>和<code>pte_offset_map()</code>以获得对应目标页线性地址的页表项地址。</p>
</li>
<li><p>执行一些检查来验证目标页可有效回收。<br>下面的检查步骤中，如果任何一步失败，函数跳到第(12)步，结束并返回一个有关的错误码：<code>SWAP_AGAIN</code>或<code>SWAP_FAIL</code>。</p>
<blockquote>
<ol>
<li>检查指向目标页的页表项。如果不成功，则函数返回<code>SWAP_AGAIN</code>。这可能在以下几种情形下发生：</li>
</ol>
<blockquote>
<ol>
<li>指向页框的页表项与<code>COW</code>关联，而<code>vma</code>标识的匿名线性区仍然属于原页框的<code>anon_vma</code>链表。</li>
<li><code>mremap()</code>系统调用可重新映射线性区，并通过直接修改页表项将页移到用户态地址空间。这种特殊情况下，因为页描述符的<code>index</code>字段不能用于确定页的实际线性地址，所以面向对象的反向映射就不能使用了。</li>
</ol>
</blockquote>
<ol>
<li>文件内存映射是非线性的。</li>
<li>验证线性区不是锁定(<code>VM_LOCKED</code>)或保留(<code>VM_RESERVED</code>)的。如果有锁定(<code>VM_LOCKED</code>)或保留情况之一出现，函数就返回<code>SWAP_FAIL</code>。</li>
<li>验证页表项中的访问标志位(<code>Accessed</code>)被清<code>0</code>。如果没有，该函数将它清<code>0</code>，并返回<code>SWAP_FAIL</code>。访问标志位置位表示页在用，因此不能被回收。<br>d. 检查页是否属于交换高速缓存，且此时它正由<code>get_user_pages()</code>处理。在这种情形下，为避免恶性竞争条件，函数返回<code>SWAP_FAIL</code>。</li>
</ol>
</blockquote>
</li>
<li><p>页可以被回收。如果页表项的<code>Dirty</code>标志位置位，则将页的<code>PG_dirty</code>标志置位。</p>
</li>
<li><p>清空页表项，刷新相应的<code>TLB</code>。这样就取消了匿名页在一个页表中的注册。</p>
</li>
<li><p>如果是匿名页，函数将换出页(<code>swapped-out page</code>)标识符插入页表项，以便将来访问时将该页换入。而且，递减存放在内存描述符<code>anon_rss</code>字段中的匿名页计数器。<br>因为匿名页变为空闲页框的逻辑是：</p>
<blockquote>
<ol>
<li>解除匿名页与所有进程联系</li>
<li>将匿名页现有内容写入磁盘</li>
<li>此时匿名页变为空闲页。可作为空闲页框进行物理内存分配。</li>
<li>每个使用此匿名页的页表中表项需要能包含此页表项指向了一个暂时不在内存的页。且包含此页在磁盘的定位信息。</li>
</ol>
</blockquote>
</li>
<li><p>递减存放在内存描述符<code>rss</code>字段中的页框计数器。</p>
</li>
<li><p>递减页描述符的<code>_mapcount</code>字段，因为对用户态页表项中页框的引用已被删除。</p>
</li>
<li><p>递减存放在页描述符<code>_count</code>字段中的页框使用计数器。如果计数器变为负数，则从活动或非活动链表中删除页描述符，活动或非活动链表中的页框都是分配出去供外部使用的。现在将页描述符移除，表明对应页框不再供外部使用。而且调用<code>free_hot_page()</code>释放页框，释放后此页框成为空闲页框便可被页框分配器用于新的分配。</p>
</li>
<li><p>释放第3步中获得的自旋锁<code>vma-&gt;vm_mm-&gt;page_table_lock</code>。</p>
</li>
<li><p>返回相应的错误码(成功时返回<code>SWAP_AGAIN</code>)。</p>
</li>
</ol>
<h4 id="映射页的反向映射"><a href="#映射页的反向映射" class="headerlink" title="映射页的反向映射"></a>映射页的反向映射</h4><p>共享匿名页框的数量不是很大，因此用双向链表记录所有使用匿名页框的线性区可行。映射页的共同使用者可能较多，因此，<code>Linux2.6</code>依靠叫做“优先搜索树(<code>priority search tree</code>)”的结构来快速定位引用同一页框的所有线性区。因为映射页描述符的<code>mapping</code>字段指向<code>address_space</code>对象，所以总是能够快速检索搜索树的根。</p>
<h4 id="优先搜索树"><a href="#优先搜索树" class="headerlink" title="优先搜索树"></a>优先搜索树</h4><p><code>Linux 2.6</code>使用的优先搜索树(<code>PST</code>)是基于<code>Edward McCreight</code>于<code>1985</code>年提出的一种数据结构，用于表示一组相互重叠的区间。<code>McCreight</code>树是一个堆和对称搜索树的混合体，且用于对一个区间集进行查询。<code>PST</code>中的每一个区间相当于一个树的节点，它由基索引(<code>radix index</code>)和堆索引(<code>heap index</code>)两个索引来标识。基索引表示区间的起始点而堆索引表示终点。除了基索引和堆索引，<code>PST</code>的每个节点附带一个大小索引(<code>size index</code>)。该大小索引的值为线性区大小(页数)减<code>1</code>。</p>
<p>该大小索引使搜索程序能够区分同一起始文件位置的不同线性区。然而，大小索引会大大增加不同的节点数，会使<code>PST</code>溢出。特别是，当有很多节点具有相同的基索引但堆索引不同时，<code>PST</code>就无法全部容下它们。为了解决这个问题，<code>PST</code>可以包括溢出子树(<code>overflow subtree</code>)，该子树以<code>PST</code>的叶为根，且包含具有相同基索引的节点。</p>
<p>此外，不同进程拥有的线性区可能是映射了相同文件的相同部分(如上面提及的标准<code>C</code> 库)。在这种情况下，对应这些区域的所有节点具有相同的基索引、堆索引和大小索引。当必须在<code>PST</code>中插入一个与现存某个节点具有相同索引值(基索引、堆索引和大小索引都相同)的线性区时，内核将该线性区描述符插入一个以原<code>PST</code>节点为根的双向循环列表。</p>
<p>图<code>17-2</code>所示是一个简单的优先搜索树。在图的左侧，我们看到有七个线性区覆盖着一个文件的前六页。每个区间都标有基索引、堆索引和大小索引。在图的右侧，则是对应的<code>PST</code>。注意，子节点的堆索引都不大于相应父节点的堆索引。而且我们可以看到，任意一个节点的左子节点基索引也都不大于右子节点基索引，如果基索引相等，则按照大小索引排序。让我们假定：<code>PFRA</code>搜索包含某页(索引为<code>5</code>)的全部线性区。搜索算法从根<code>(0,5,5)</code>开始，因为相应区间包含该页，那么这就是得到的第一个线性区。然后算法搜索根的左子节点<code>(0,4,4)</code>，比较堆索引<code>(4)</code>和页索引，因为堆索引较小，所以区间不包括该页。而且，有了<code>PST</code>的类堆属性，该节点的所有子节点都不包括该页。因此，算法直接跳到根的右子节点<code>(2,3,5)</code>，其相应区间包含该页，因此得到这个区间。然后，算法搜索子节点<code>(1,2,3)</code>和<code>(2,0,2)</code>，但它们都不包含该页。<br><img src=".\image-20240503160008655.png" alt="image-20240503160008655"></p>
<p>因篇幅有限，我们对实现<code>Linux PST</code>的数据结构与函数无法作详尽阐述。我们只讨论由<code>prio_tree_node</code>数据结构表示的一个<code>PST</code>节点。该数据结构在每个线性区描述符的<code>shared.prio_tree_node</code>字段中。<code>shared.vm_set</code>数据结构作为<code>shared.prio_tree_node</code> 的替代品，可以用来将线性区描述符插入一个<code>PST</code>节点的链表副本。可以用<code>vma_prio_tree_insert()</code>和<code>vma_prio_tree_remove()</code>函数分别插入和删除<code>PST</code>节点。两个函数的参数都是线性区描述符地址与<code>PST</code>根地址。对<code>PST</code>的搜索可调用<code>vma_prio_tree_foreach</code>宏来实现，该宏循环搜索所有线性区描述符，这些描述符在给定范围的线性地址中包含至少一页。</p>
<h3 id="try-to-unmap-file-函数"><a href="#try-to-unmap-file-函数" class="headerlink" title="try_to_unmap_file()函数"></a>try_to_unmap_file()函数</h3><p><code>try_to_unmap_file()</code>函数由<code>try_to_unmap()</code>调用，并执行映射页的反向映射。<br>当为线性内存映射时，该函数就很容易描述。这种情况下，它执行的步骤如下：</p>
<ol>
<li>获得<code>page-&gt;mapping-&gt;i_mmap_lock</code>自旋锁。</li>
<li>对搜索树应用<code>vma_prio_tree_foreach()</code>宏，搜索树的根存放在<code>page-&gt;mapping-&gt;i_mmap</code>字段。对宏发现的每个<code>vm_area_struct</code>描述符，函数调用<code>try_to_unmap_one()</code>，尝试对该页所在的线性区页表项清<code>0</code>。如果由于某种原因，返回<code>SWAP_FAIL</code>，或者如果页描述符的<code>_mapcount</code>字段表明引用该页框的所有页表项都已找到，则搜索过程马上结束。</li>
<li>释放<code>page-&gt;mapping-&gt;i_mmap_lock</code>自旋锁。</li>
<li>根据所有的页表项清<code>0</code>与否，返回<code>SWAP_AGAIN</code>或<code>SWAP_FAIL</code>。如果映射是非线性的，那么<code>try_to_unmap_one()</code>函数可能无法清<code>0</code>某些页表项，这是因为页描述符的<code>index</code>字段(该字段存放文件中页的位置)不再对应线性区中的页位置，</li>
</ol>
<p><code>try_to_unmap_one()</code>函数就无法确定页的线性地址，也就无法得到页表项地址。唯一的解决方法是对文件非线性线性区的穷尽搜索。双向链表以文件的所有非线性线性区的描述符所在的<code>page-&gt;mapping</code>文件的<code>address-space</code>对象的<code>i_rmap_nonlinear</code>字段为根。对每个这样的线性区，<code>try_to_unmap_file()</code>函数调用<code>try_to_unmap_cluster()</code>，而<code>try_to_unmap_cluster()</code>函数会扫描该线性区线性地址所对应的所有页表项，并尝试将它们清<code>0</code>。因为搜索可能很费时，所以执行有限扫描，而且通过试探法决定扫描线性区的哪一部分，<code>vma_area_struct</code>描述符的<code>vm_private_data</code>字段存有当前扫描的当前指针。因此，<code>try_to_unmap_file()</code>函数在某些情况下可能会找不到待停止映射的页。出现这种情况时，<code>try_to_unmap()</code>函数发现页仍然是映射的，那么返回<code>SWAP_AGAIN</code>而不是<code>SWAP_SUCCESS</code>。</p>
<h3 id="PFRA实现"><a href="#PFRA实现" class="headerlink" title="PFRA实现"></a>PFRA实现</h3><p>页框回收算法必须处理多种属于用户态进程、磁盘高速缓存的页，“内存高速缓存”（<code>slab</code>中页），而且必须遵照几条试探法准则。因此，<code>PFRA</code>有很多函数也就不奇怪了。图<code>17-3</code>列出了<code>PFRA</code>的主要函数，箭头表示函数调用。例如，<code>try_to_free_pages()</code>函数调用<code>shrink_caches()</code>、<code>shrink_slab()</code>和<code>out_of_memory()</code>三个函数。</p>
<p>正如你所看到的，<code>PFRA</code>有几个入口(<code>entry point</code>)。实际上，页框回收算法的执行有三种基本情形：<br><img src=".\image-20240503160019536.png" alt="image-20240503160019536"><br>内存紧缺回收，内核发现内存紧缺<br>睡眠回收，在进入<code>suspend-to-disk</code>状态时，内核必须释放内存<br>周期回收，必要时，周期性激活内核线程执行内存回收算法</p>
<p>内存紧缺回收在下列几种情形下激活：</p>
<ul>
<li><code>grow_buffers()</code>函数(由<code>__getblk()</code>调用)无法获得新的缓冲区页。</li>
<li><code>alloc_page_buffers()</code>函数(由<code>create_empty_buffers()</code>调用)无法获得页临时缓冲区首部。</li>
<li><code>__alloc_pages()</code>函数无法在给定的内存管理区(<code>memory zone</code>)中分配一组连续页框。</li>
</ul>
<p>周期回收由下面两种不同的内核线程激活：</p>
<ul>
<li><code>kswapd</code>内核线程，它检查某个内存管理区中空闲页框数是否已低于<code>pages_high</code>值的标高。</li>
<li><code>events</code>内核线程，它是预定义工作队列的工作者线程；<code>PFRA</code>周期性地调度预定义工作队列中的一个任务执行，从而回收<code>slab</code>分配器处理的位于”内存高速缓存”中的所有空闲<code>slab</code>。</li>
</ul>
<h3 id="最近最少使用-LRU-链表"><a href="#最近最少使用-LRU-链表" class="headerlink" title="最近最少使用(LRU)链表"></a>最近最少使用(LRU)链表</h3><p>属于进程用户态地址空间或页高速缓存的所有页被分成两组：活动链表与非活动链表。它们被统称为<code>LRU</code>链表。前面一个链表用于存放最近被访问过的页；后面的则存放有一段时间没有被访问过的页。显然，页必须从非活动链表中窃取。页的活动链表和非活动链表是页框回收算法的核心数据结构。这两个双向链表的头分别存放在每个<code>zone</code>描述符的<code>active_list</code>（双向链表哨兵节点）和<code>inactive_list</code>（双向链表哨兵节点）字段，而该描述符的<code>nr_active</code>和<code>nr_inactive</code>字段表示存放在两个链表中的页数。最后，<code>lru_lock</code>字段是一个自旋锁，保护两个链表免受<code>SMP</code>系统上的并发访问。</p>
<p>如果页属于<code>LRU</code>链表，则设置页描述符中的<code>PG_1ru</code>标志。此外，如果页属于活动链表，则设置<code>PG_active</code>标志，而如果页属于非活动链表，则清<code>PG_active</code>标志。页描述符的<code>lru</code>字段（双向链表的节点）存放指向<code>LRU</code>链表中下一个元素和前一个元素的指针。另外有几个辅助函数处理LRU链表：</p>
<ul>
<li><code>add_page_to_active_list()</code>，将页加入管理区的活动链表头部并递增管理区描述符的<code>nr_active</code>字段。</li>
<li><code>add_page_to_inactive_list()</code>，将页加入管理区的非活动链表头部并递增管理区描述符的<code>nr_inactive</code>字段。</li>
<li><code>del_page_from_active_list()</code>，从管理区的活动链表中删除页并递减管理区描述符的<code>nr_active</code>字段</li>
<li><code>del_page_from_inactive_list()</code>，从管理区的非活动链表中删除页并递减管理区描述符的<code>nr_inactive</code>字段。</li>
<li><code>del_page_from_lru()</code>，检查页的<code>PG_active</code>标志。依据检查结果，将页从活动或非活动链表中删除，递减管理区描述符的<code>nr_active</code>或<code>nr_inactive</code>字段，且如有必要，将<code>PG_active</code>标志清<code>0</code>。</li>
<li><code>activate_page()</code>，检查<code>PG_active</code>标志，如果未置位(页在非活动链表中)，将页移到活动列表中，依次调用<code>del_page_from_inactive_list()</code>和<code>add_page_to_active_list()</code>，最后将<code>PG_active</code>标志置位。在移动页之前，获得管理区的<code>lru_lock</code>自旋锁。</li>
<li><code>lru_cache_add()</code>，如果页不在<code>LRU</code>链表中，将<code>PG_lru</code>标志置位，得到管理区的<code>lru_lock</code>自旋锁，调用<code>add_page_to_inactive_list()</code>把页插入管理区的非活动链表。</li>
<li><code>lru_cache_add_active()</code>，如果页不在<code>LRU</code>链表中，将<code>PG_lru</code>和<code>PG_active</code>标志置位，得到管理区的<code>lru_lock</code>自旋锁，调用<code>add_page_to_active_list()</code>把页插入管理区的活动链表。</li>
</ul>
<p>​    事实上，最后两个函数，<code>lru_cache_add()</code>和<code>lru_cache_add_active()</code>稍有些复杂。这两个函数实际上并没有立刻把页移到<code>LRU</code>，而是在<code>pagevec</code>类型的临时数据结构中聚集这些页，每个结构可以存放多达<code>14</code>个页描述符指针。只有当一个<code>pagevec</code>结构写满了，页才真正被移到<code>LRU</code>链表中。这种机制可以改善系统性能，这是因为只当<code>LRU</code>链表实际修改后才获得<code>LRU</code>自旋锁。</p>
<h3 id="在LRU链表之间移动页"><a href="#在LRU链表之间移动页" class="headerlink" title="在LRU链表之间移动页"></a>在LRU链表之间移动页</h3><p><code>PFRA</code>把最近访问过的页集中放在活动链表中，以便当查找要回收的页框时不扫描这些页。相反，<code>PFRA</code>把很长时间没有访问的页集中放在非活动链表中。当然，应该根据页是否正被访问，把页从非活动链表移到活动链表或者退回。显然，两个状态(“活动”和“非活动”)是不足以描述所有可能的访问模式的。</p>
<p>页不应该在每次单独的访问中就改变自己的状态似乎是合理的。在页描述符中的<code>PG_referenced</code>标志用来把一个页从非活动链表移到活动链表所需的访问次数加倍；也把一个页从活动链表移到非活动链表所需的“丢失访问”次数加倍。</p>
<p>例如，假定在非活动链表中的一个页其<code>PG_referenced</code>标志为<code>0</code>。第一次访问把这个标志置为<code>1</code>，但是这一页仍然留在非活动链表中。第二次对该页访问时发现这一标志被设置，因此，把页移到活动链表。但是，如果第一次访问之后在给定的时间间隔内第二次访问没有发生，那么页框回收算法就可能重置<code>PG_referenced</code>标志。</p>
<p>从非活动变为活动，先是被引用，再是活动。被引用后一段时间内没有触发变为活动的访问，则取消被引用。如图<code>17-4</code>所示，<code>PFRA</code>使用<code>mark page_accessed()</code>、<code>page_referenced()</code>和<code>refill_inactive_zane()</code>函数在<code>LRU</code>链表之间移动页。在图中，包含有页的<code>LRU</code>链表由<code>PG_active</code>标志的状态表示。<br><img src=".\image-20240503160039482.png" alt="image-20240503160039482"></p>
<h3 id="mark-page-accessed-函数"><a href="#mark-page-accessed-函数" class="headerlink" title="mark_page_accessed()函数"></a>mark_page_accessed()函数</h3><p>当内核必须把一个页标记为访问过时，就调用<code>mark_page_accessed()</code>函数。每当内核决定一个页是被用户态进程、文件系统层还是设备驱动程序引用时，这种情况就会发生。例如，在下列情况下调用<code>mark_page_accessed()</code>：</p>
<ol>
<li>当按需装入进程的一个匿名页（从磁盘交换区装入内存）时(由<code>do_anonymous_page()</code>函数执行)。</li>
<li>当按需装入内存映射文件的一个页（磁盘文件内容装入内存）时(由<code>filemap_nopage()</code>函数执行)。</li>
<li>当按需装入IPC共享内存区的一个页时(由<code>shmem_nopage()</code>函数执行)。</li>
<li>当从文件读取数据页时(由<code>do_generic_file_read()</code>函数执行)。</li>
<li>当换入一个页时(由<code>do_swap_page()</code>函数执行)。</li>
<li>当在页高速缓存中搜索一个缓冲区页时。</li>
</ol>
<p><code>mark_page_accessed()</code>函数执行下列代码片段：</p>
<pre class="line-numbers language-none"><code class="language-none">if(!PageActive(page)&amp;&amp; PageReferenced(page) &amp;&amp; PageLRU(page))&#123;
	activate_page(page);
	ClearPageReferenced(page);&#x2F;&#x2F; 激活的同时取消引用
&#125; else if(!PageReferenced(page〉)
	SetPageReferenced(page);&#x2F;&#x2F; 从非引用变为引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如图<code>17-4</code>所示，该函数调用前，只有当<code>PG_referenced</code>标志置位，它才把页从非活动链表移到活动链表。</p>
<h3 id="page-referenced-函数"><a href="#page-referenced-函数" class="headerlink" title="page_referenced()函数"></a>page_referenced()函数</h3><p><code>PFRA</code>扫描一页调用一次<code>page_referenced()</code>函数，如果<code>PG_referenced</code>标志或页表项中的某些<code>Accessed</code>标志位置位，则该函数返回<code>1</code>；否则返回<code>0</code>。该函数首先检查页描述符的<code>PG_referenced</code>标志。如果标志置位则清<code>0</code>。然后使用面向对象的反向映射方法，对引用该页的所有用户态页表项中的<code>Accessed</code>标志位进行检查并清<code>0</code>。为此，函数用到三个辅助函数：<code>page_referenced_anon()</code>、<code>page_referenced_file()</code>和<code>page_referenced_one()</code>，从活动链表到非活动链表移动页由<code>refill_inactive_zone()</code>函数实施的。<code>refill_inactive_zone()</code>函数除此之外还有其他很多功能。</p>
<h3 id="refill-inactive-zone-函数"><a href="#refill-inactive-zone-函数" class="headerlink" title="refill_inactive_zone()函数"></a>refill_inactive_zone()函数</h3><p>如图<code>17-3</code>所示，<code>refill_inactive_zone()</code>函数由<code>shrink_zone()</code>调用，而<code>shrink_zone()</code>函数对页高速缓存和用户态地址空间进行页回收。此函数有两个参数：<code>zone</code>和<code>sc</code>。指针<code>zone</code>指向一个内存管理区描述符；指针<code>sc</code>指向一个<code>scan_control</code>结构。<code>PFRA</code>广泛使用<code>scan_control</code>这个数据结构，该结构存放着回收操作执行时的有关信息。</p>
<p>开始时，对每次调用，扫描非活动链表中少量的页，但是当<code>PFRA</code>很难回收内存时，<code>refill_inactive_zone()</code>在每次调用时就逐渐增加扫描的活动页数。<code>scan_control</code>数据结构中<code>priority</code>字段的值控制该函数的行为(低值表示更紧迫的优先级)。还有一个试探法可以调整<code>refill_inactive_zone()</code>函数行为。<code>LRU</code>链表中有两类页：属于用户态地址空间的页、不属于任何用户态进程且在页高速缓存中的页。</p>
<p>如前所述，<code>PFRA</code>倾向于压缩页高速缓存，而将用户态进程的页留在<code>RAM</code>中。<code>refill_inactive_zone()</code>函数使用交换倾向(<code>swap tendency</code>)经验值，由它确定函数是移动所有的页还是只移动不属于用户态地址空间的页。<br>函数按如下公式计算交换倾向值：交换倾向值=映射比率 / 2 + 负荷值 + 交换值。<br>映射比率(<code>mapped ratio</code>)是用户态地址空间所有内存管理区的页(<code>sc-&gt;nr_mapped</code>)占所有可分配页框数的百分比。<code>mapped_ratio</code>的值大表示动态内存大部分用于用户态进程，而值小则表示大部分用于页高速缓存。负荷值(<code>distress</code>)用于表示<code>PFRA</code>在管理区中回收页框的效率。其依据是前一次<code>PFRA</code>运行时管理区的扫描优先级，这个优先级存放在管理区描述符的<code>prev_priority</code>字段。</p>
<p>​    交换值(<code>swappiness</code>)是一个用户定义常数，通常为<code>60</code>。系统管理员可以在<code>/proc/sys/vm/swappiness</code>文件内修改这个值，或用相应的<code>sysct1()</code>系统调用调整这个值。只有当管理区交换倾向值大于等于<code>100</code>时，页才从进程地址空间回收。</p>
<p>​    那么当系统管理员将交换值设为<code>0</code>时，<code>PFRA</code>就不会从用户态地址空间回收页，除非管理区的前一次优先级为<code>0</code>(这不大可能发生)。如果系统管理员将交换值设为<code>100</code>，那么<code>PFRA</code>每次调用该函数时都会从用户态地址空间回收页。</p>
<p>下面是<code>refill_inactive_zone()</code>函数执行步骤的一个简要说明：</p>
<ol>
<li>调用<code>1ru_add_drain()</code>，把仍留在<code>pagevec</code>数据结构中的所有页移入活动与非活动链表。</li>
<li>获得<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>对<code>zone-&gt;active_list</code>中的页进行首次扫描，从链表的底部开始向上，一直执行下去，直到链表为空或<code>sc-&gt;nr_to_scan</code>的页扫描完毕。在这一次循环中每扫描一页，函数就将引用计数器加<code>1</code>，从<code>zone-&gt;active_list</code>中删除页描述符，把它放在临时局部链表<code>l_hold</code>中。但是如果页框引用计数器是<code>0</code>，则把该页放回活动链表。实际上，引用计数器为<code>0</code>的页框一定属于管理区的伙伴系统，但释放页框时，首先递减使用计数器，然后将页框从<code>LRU</code>链表删除并插入伙伴系统链表。因此在一个很小的时间段，<code>PFRA</code>可能会发现<code>LRU</code>链表中的空闲页。</li>
<li>把已扫描的活动页数追加到<code>zone-&gt;pages_scanned</code>。</li>
<li>从<code>zone-&gt;nr_active</code>中减去移入局部链表<code>1_hold</code>中的页数。</li>
<li>释放<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>计算交换倾向值。</li>
<li>对局部链表<code>1_hold</code>中的页运行第二次循环。这次循环的目的是：把其中的页分到两个子链表<code>l_active</code>和<code>l_inactive</code>中。属于某个进程用户态地址空间的页(即<code>page-&gt;_mapcount</code>为非负数的页)被加入<code>l_active</code>的条件是：<br>交换倾向值小于<code>100</code>，或者是匿名页但又没有激活的交换区，或者应用于该页的<code>page_referenced()</code>函数返回正数(正数表示该页最近被访问过)。而任何其他情形下，页被加入<code>l_inactive</code>链表。<br> 获得<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>对局部链表<code>l_inactive</code>中的页执行第三次循环。把页移入<code>zone-&gt;inactive_list</code>链表，更新<code>zone-&gt;nr_inactive</code>字段，同时递减被移页框的使用计数器，从而抵消第<code>3</code>步中增加的值。</li>
<li>对局部链表<code>l_active</code>中的页执行第四次也是最后一次循环。把页移入<code>zone-&gt;active_list</code>链表，更新<code>zone-&gt;nr_active</code>字段，同时递减被移页框的使用计数器，从而抵消第<code>3</code>步中增加的值。</li>
<li>释放自旋锁<code>zone-&gt;lru_lock</code>并返回。 <code>refill_inactive_zone()</code>只检查用户态地址空间页的<code>PG_referenced</code>标志。相反的情况是，页在活动链表的底部，也就是较长时间以前被访问过，那么不大可能会在近期被访问。如果页属于某个用户态进程且最近被使用过，那么函数也不会将页从活动链表删除。</li>
</ol>
<h3 id="内存紧缺回收"><a href="#内存紧缺回收" class="headerlink" title="内存紧缺回收"></a>内存紧缺回收</h3><p>当内存分配失败时激活内存紧缺回收。在图<code>17-3</code>中，在分配<code>VFS</code>缓冲区或缓冲区首部时，内核调用<code>free_more_memory()</code>；而当从伙伴系统分配一个或多个页框时，调用<code>try_to_free_pages()</code>。</p>
<h3 id="free-more-memory-函数"><a href="#free-more-memory-函数" class="headerlink" title="free_more_memory()函数"></a>free_more_memory()函数</h3><ul>
<li>调用<code>wakeup_bdflush()</code>唤醒一个<code>pdflush</code>内核线程，并触发页高速缓存中<code>1024</code>个脏页的写操作。写脏页到磁盘的操作将最终使包含缓冲区、缓冲区首部和其他<code>VFS</code>数据结构的页框成为可释放的。</li>
<li>调用<code>sched_yield()</code>系统调用的服务例程，为<code>pdflush</code>内核线程提供执行机会。</li>
<li>对系统的所有内存节点，启动一个循环。</li>
<li>对每一个节点，调用<code>try_to_free_pages()</code>函数，传给它的参数是一个“紧缺”内存管理区链表(在<code>80x86</code>体系结构中是<code>ZONE_DMA</code>和<code>ZONE_NORMAL</code>。</li>
</ul>
<h3 id="try-to-free-pages-函数"><a href="#try-to-free-pages-函数" class="headerlink" title="try_to_free_pages()函数"></a>try_to_free_pages()函数</h3><p>参数：</p>
<ul>
<li><code>zones</code>，要回收的页所在的内存管理区链表。</li>
<li><code>gfp_mask</code>，用于失败的内存分配的一组分配标志。</li>
<li><code>order</code>，没有使用。</li>
</ul>
<p>该函数的目标就是通过重复调用<code>shrink_caches()</code>和<code>shrink_slab()</code>函数释放至少<code>32</code> 个页框，每次调用后优先级会比前一次提高。有关的辅助函数可以获得<code>scan_control</code> 类型描述符中的优先级，以及正在进行的扫描操作的其他参数。最低的、也是初始的优先级是<code>12</code>，而最高的、也是最终的优先级是<code>0</code>。如果<code>try_to_free_pages()</code>没能在某次(共<code>13</code>次)调用<code>shrink_caches()</code>和<code>shrink_slab()</code>函数时成功回收至少<code>32</code>个页框，<code>PFRA</code>就要黔驴技穷了。最后一招：删除一个进程，释放它的所有页框。</p>
<p>这一操作由<code>out_of_memory()</code>函数执行。该函数主要执行如下步骤：</p>
<ol>
<li><p>分配和初始化一个<code>scan_control</code>描述符，具体说就是把分配掩码<code>gfp_mask</code>存入<code>gfp_mask</code>字段。</p>
</li>
<li><p>对<code>zones</code>链表中的每个管理区，将管理区描述符的<code>temp_priority</code>字段设为初始优先级<code>12</code>，而且计算管理区<code>LRU</code>链表中的总页数。</p>
</li>
<li><p>从优先级<code>12</code>到<code>0</code>，执行最多<code>13</code>次的循环，每次迭代执行如下子步骤：</p>
<blockquote>
<ol>
<li>更新<code>scan_control</code>描述符的一些字段。具体地，把用户态进程的总页数存入<code>nr_mapped</code>字段，把本次迭代的当前优先级存人<code>priority</code>字段。而且将<code>nr_scanned</code>和<code>nr_reclaimed</code>字段设为0。</li>
<li>调用<code>shrink_caches()</code>，传给它<code>zones</code>链表和<code>scan_control</code>描述符地址作为参数。这个函数扫描管理区的非活动页。</li>
<li>调用<code>shrink_slab()</code>从可压缩内核高速缓存中回收页。</li>
<li>如果<code>current-&gt;reclaim_state</code>非空，则将<code>slab</code>分配器高速缓存中回收的页数追加到<code>scan_control</code>描述符的<code>nr_reclaimed</code>字段。在调用<code>try_to_free_pages()</code>函数之前，<code>__alloc_pages()</code>函数建立<code>current-&gt;reclaim_state</code>字段，并在结束后马上清除该字段。</li>
<li>如果已达目标(<code>scan_control</code>描述符的<code>nr_reclaimed</code>字段大于等于<code>32</code>)，则跳出循环到第<code>4</code>步。</li>
<li>如果未达目标，但已扫描完成至少<code>49</code>页，则调<code>wakeup_bdflush()</code>激活<code>pdflush</code>内核线程，并将页高速缓存中的一些脏页写入磁盘。<br>如果函数已完成<code>4</code>次迭代而又未达目标，则调用<code>blk_congestion_wait()</code>挂起进程，直到没拥塞的<code>WRITE</code>请求队列或<code>100ms</code>超时已过。</li>
</ol>
</blockquote>
</li>
<li><p>把每个管理区描述符的<code>prev_priority</code>字段设为上一次调用<code>shrink_caches()</code>使用的优先级，该值存放在管理区描述符的<code>temp_priority</code>字段。</p>
</li>
<li><p>如果成功回收则返回<code>1</code>，否则返回<code>0</code>。</p>
</li>
</ol>
<h3 id="shrink-caches-函数"><a href="#shrink-caches-函数" class="headerlink" title="shrink_caches()函数"></a>shrink_caches()函数</h3><p><code>shrink_caches()</code>函数由<code>try_to_free_pages()</code>调用，它有两个参数：内存管理区链表<code>zones</code>和<code>scan_control</code>描述符地址<code>sc</code>。该函数的目的只是对<code>zones</code>链表中的每个管理区调用<code>shrink_zone()</code>函数。但对给定管理区调用<code>shrink_zone()</code>之前，<code>shrink_caches()</code>函数用<code>sc-&gt;priority</code>字段的值更新管理区描述符的<code>temp_priority</code>字段，这就是扫描操作的当前优先级。而且如果<code>PFRA</code>的上一次调用优先级高于当前优先级，即这个管理区进行页框回收变得更难了，那么<code>shrink_caches()</code>把当前优先级拷贝到管理区描述符的<code>prev_priority</code>。最后，如果管理区描述符中的<code>all_unreclaimable</code>标志置位，且当前优先级小于<code>12</code>，则<code>shrink_caches()</code>不调用<code>shrink_zone()</code>，也就是说，在<code>try_to_free_pages()</code>的第一迭代中不调用<code>shrink_caches()</code>。当<code>PFRA</code>确定一个管理区都是不可回收页，扫描该管理区的页纯粹是浪费时间时，则将<code>all_unreclaimable</code>标志置位。</p>
<h3 id="shrink-zone-函数"><a href="#shrink-zone-函数" class="headerlink" title="shrink_zone()函数"></a>shrink_zone()函数</h3><p><code>shrink_zone()</code>函数有两个参数：<code>zone</code>和<code>sc</code>。<code>zone</code>是指向<code>struct_zone</code>描述符的指针；<code>sc</code>是指向<code>scan_control</code>描述符的指针。该函数的目标是从管理区非活动链表回收<code>32</code>页。它每次在更大的一段管理区非活动链表上重复调用辅助函数<code>shrink_cache()</code>，以期达到目标。</p>
<p>而且<code>shrink_zone()</code>重复调用<code>refill_inactive_zone()</code>函数来补充管理区非活动链表。管理区描述符的<code>nr_scan_active</code>和<code>nr_scan_inactive</code>字段在这里起到很重要的作用。为提高效率，函数每批处理<code>32</code>页。因此如果函数在低优先级运行(对应<code>sc-&gt;priority</code> 的高值)，且某个<code>LRU</code>链表中没有足够的页，函数就跳过对这个链表的扫描。但因此跳过的活动或不活动页数就分别存放在<code>nr_scan_active</code>或<code>nr_scan_inactive</code>中，这样函数下次执行时再处理这些跳过的页。</p>
<p><code>shrink_zone()</code>函数的具体执行步骤如下：</p>
<ol>
<li>递增<code>zone-&gt;nr_scan_active</code>，增量是活动链表(<code>zone-&gt;nr_active</code>)的一小部分。实际增量取决于当前优先级，其范围是：<br><code>zone-&gt;nr_active / 2 ^ 12</code>到<code>zone-&gt;nr_active / 2</code>(即管理区内的总活动页数)。</li>
<li><p>递增<code>zone-&gt;nr_scan_inactive</code>，增量是非活动链表(<code>zone-&gt;nr_inactive</code>)的一小部分。实际增量取决于当前优先级，其范围是：<code>zone-&gt;nr_inactive / 2 ^ 12</code>到<code>zone-&gt;nr_inactive</code>。</p>
</li>
<li><p>如果<code>zone-&gt;nr_scan_active</code>字段大于等于<code>32</code>，函数就把该值赋给局部变量<code>nr_active</code>，并把该字段设为<code>0</code>，否则把<code>nr_active</code>设为<code>0</code>。</p>
</li>
<li>如果<code>zone-&gt;nr_scan_inactive</code>字段大于等于<code>32</code>，函数就把该值赋给局部变量<code>nr_inactive</code>，并把该字段设为<code>0</code>，否则把<code>nr_inactive</code>设为<code>0</code>。</li>
<li>设定<code>scan_control</code>描述符的<code>sc-&gt;nr_to_reclaim</code>字段为<code>32</code>。</li>
<li>如果<code>nr_active</code>和<code>nr_inactive</code>都为<code>0</code>，则无事可做，函数结束。这不常见，用户态进程没有被分配到任何页时才可能出现这种情形。</li>
<li>如果<code>nr_active</code>为正，则补充管理区非活动链表：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">sc-&gt;nr_to_scan &#x3D; min(nr_active,32);
nr_active -&#x3D; sc-&gt;nr_to_scan;
refill_inactive_zone(zone,sc);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol>
<li>如果<code>nr_inactive</code>为正，则尝试从非活动链表回收最多<code>32</code>页：</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">sc-&gt;nr_to_scan &#x3D; min(nr_inactive,32);
nr_inactive -&#x3D; sc-&gt;nr_to_scan;
shrink_cache(zone,sc);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol>
<li>如果<code>shrink_zone()</code>成功回收<code>32</code>页(现在<code>sc-&gt;nr_to_reclaim</code>小于等于<code>0)</code>，则结束；否则，跳回第<code>6</code>步。</li>
</ol>
<h3 id="shrink-cache-函数"><a href="#shrink-cache-函数" class="headerlink" title="shrink_cache()函数"></a>shrink_cache()函数</h3><p><code>shrink_cache()</code>函数又是一个辅助函数，它的主要目的就是从管理区非活动链表取出一组页，把它们放入一个临时链表，然后调用<code>shrink_list()</code>函数对这个链表中的每一页进行有效的页框回收操作。</p>
<p><code>shrink_cache()</code>函数的参数与<code>shrink_zones()</code>一样，都是<code>zone</code>和<code>sc</code>，执行的主要步骤如下：</p>
<ol>
<li>调用<code>lru_add_drain()</code>，把仍然在<code>pagevec</code>数据结构中的页移入活动与非活动链表。</li>
<li>获得<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>处理非活动链表中的页(最多<code>32</code>页)，对于每一页，函数递增使用计数器；检查该页是否不会被释放到伙伴系统；把页从管理区非活动链表移入一个局部链表。</li>
<li>把<code>zone-&gt;nr_inactive</code>计数器的值减去从非活动链表中删除的页数。</li>
<li>递增<code>zone-&gt;pages_scanned</code>计数器的值，增量为在非活动链表中有效检查的页数。</li>
<li>释放<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>调用<code>shrink_list()</code>函数，传给它上面第<code>3</code>步中搜集的页。</li>
<li>把<code>sc-&gt;nr_to_reclaim</code>字段的值减去由<code>shrink_list()</code>实际回收的页数。</li>
<li>再次获取<code>zone-&gt;lru_lock</code>自旋锁。</li>
<li>把局部链表中<code>shrink_list()</code>没有成功释放的页放回非活动或活动链表。注意，<code>shrink_list()</code>有可能置位<code>PG_active</code>标志，从而将某页标记为活动页。这一操作使用<code>pagevec</code>数据结构对一组页进行处理。</li>
<li>如果函数扫描的页数至少是<code>sc-&gt;nr_to_scan</code>，且如果没有成功回收目标页数(即<code>sc-&gt;nr_to_reclaim</code>仍然大于<code>0</code>)，则跳回第<code>3</code>步。</li>
<li>释放<code>zone-&gt;lru_lock</code>自旋锁并结束。</li>
</ol>
<h3 id="shrink-list-函数"><a href="#shrink-list-函数" class="headerlink" title="shrink_list()函数"></a>shrink_list()函数</h3><p>我们现在讨论页框回收算法的核心部分。从<code>try_to_free_pages()</code>到<code>shrink_cache()</code>函数，前面所述这些函数的目的就是找到一组适合回收的候选页。<code>shrink_list()</code>函数则从参数<code>page_list</code>链表中尝试回收这些页，该函数的第二个参数<code>sc</code>是指向<code>scan_control</code> 描述符的指针。当<code>shrink_list()</code>返回时，<code>page_list</code>链表中剩下的是无法回收的页。</p>
<p>函数执行步骤如下：</p>
<ul>
<li>如果当前进程的<code>need_resched</code>字段置位，则调用<code>schedule()</code>。</li>
<li>执行一个循环，处理<code>page_list</code>链表中的每一页。对其中每个元素，从链表中删除页描述符并尝试回收该页框。如果由于某种原因页框不能释放，则把该页描述符插入一个局部链表。</li>
<li>现在<code>page_list</code>已空，函数再把页描述符从局部链表移回<code>page_list</code>链表。</li>
<li>递增<code>sc-&gt;nr_reclaimed</code>字段，增量为第<code>2</code>步中回收的页数，并返回这个数。当然，<code>shrink_list()</code>函数尝试回收页框的代码确实很有意思。图<code>17-5</code>是这段代码的流程图。</li>
</ul>
<p><code>shrink_list()</code>处理的每个页框只可能有三种结果：</p>
<ul>
<li>调用<code>free_cold_page()</code>函数，把页释放到管理区伙伴系统，因此被有效回收。</li>
<li>页没有被回收，因此被重新插入<code>page_list</code>链表。但是<code>shrink_list()</code>假设不久还能回收该页。因此函数让页描述符的<code>PG_active</code>标志保持清<code>0</code>，这样页将被放回内存管理区的非活动链表。这种情况对应于图<code>17-5</code>中标为“<code>INACTIVE</code>”的小方框。</li>
<li>页没有被回收，因此被重新插入<code>page_list</code>链表。但是，或是页正被使用，或是<code>shrink_list()</code>假设近期无法回收该页。函数将页描述符的<code>PG_active</code>标志置位，这样页将被放回内存管理区的活动链表。这种情况对应于图<code>17-5</code>中标为“<code>ACTIVE</code>”的小方框。</li>
</ul>
<p><code>shrink_list()</code>函数不会去回收锁定页(<code>PG_locked</code>置位)与写回页(<code>PG_writeback</code> 置位)。<code>shrink_list()</code>调用<code>page_referenced()</code>函数检查该页是否最近被引用过，要回收匿名页，就必须把它加入交换高速缓存，那么就必须在交换区为它保留一个新页槽<code>(slot</code>)。<br>如果页在某个进程的用户态地址空间(页描述符的<code>_mapcount</code>字段大于等于<code>0</code>)，则<code>shrink_list()</code>调用<code>try_to_unmap()</code>寻找引用该页框的所有页表项。当然，只有当这个函数返回<code>SWAP_SUCCESS</code>时，回收才可继续。如果是脏页，则写回磁盘前不能回收、为此，<code>shrink_list()</code>使用<code>pageout()</code>。只有当<code>pageout()</code>不必进行写操作或写操作不久将结束时，回收才可继续。<br><img src=".\image-20240503160649840.png" alt="image-20240503160649840"></p>
<p>如果页包含<code>VFS</code>缓冲区，则<code>shrink_list()</code>调用<code>try_to_release_page()</code>释放关联的缓冲区首部。<br>最后，如果一切顺利，<code>shrink_list()</code>就检查页的引用计数器。<br>若等于<code>2</code>，那么这两个拥有者就是：页高速缓存(如果是匿名页，则为交换高速缓存)和<code>PFRA</code>自己(<code>shrink_cache()</code>函数中第<code>3</code>步中会递增引用计数器，参见前面)。这种情况下，如果页仍然不为脏，则页可以回收。为此，首先根据页描述符的<code>PG_swapcache</code>标志的值，从页高速缓存或交换高速缓存删除该页，然后，执行函数<code>free_cold_page()</code>。</p>
<h3 id="pageout-函数"><a href="#pageout-函数" class="headerlink" title="pageout()函数"></a>pageout()函数</h3><p>当一个脏页必须写回磁盘时，<code>shrink_list()</code>调用<code>pageout()</code>函数。函数执行的主要步骤如下：</p>
<ul>
<li>检查页存放在页高速缓存还是交换高速缓存中。进一步检查该页是否由页高速缓存(或交换高速缓存)与<code>PFRA</code>拥有。如果检查失败，则返回<code>PAGE_KEEP</code>。</li>
<li>检查<code>address_space</code>对象的<code>writepage</code>方法是否已定义。如果没有，则返回<code>PAGE_ACTIVATE</code>。</li>
<li>检查当前进程是否可以向块设备(与<code>address_space</code>对象对应)请求队列发出写请求。实际上，<code>kswapd</code>和<code>pdflush</code>内核线程总会发出写请求；而普通进程只有在请求队列不拥塞的情况下才能发出写请求，除非<code>current-&gt;backing_dev_info</code>字段指向块设备的<code>backing_dev_info</code>数据结构。</li>
<li>检查是否仍然是脏页。如果不是则返回<code>PAGE_CLEAN</code>。</li>
<li>建立一个<code>writeback_control</code>描述符，调用<code>address_space</code>对象的<code>writepage</code>方法以启动一个写回操作。</li>
<li>如果<code>writepage</code>方法返回错误码，则函数返回<code>PAGE_ACTIVATE</code>。</li>
<li>返回<code>PAGE_SUCCESS</code>。</li>
</ul>
<h3 id="回收可压缩磁盘高速缓存的页"><a href="#回收可压缩磁盘高速缓存的页" class="headerlink" title="回收可压缩磁盘高速缓存的页"></a>回收可压缩磁盘高速缓存的页</h3><p>内核在页高速缓存之外还使用其他磁盘高速缓存，例如，目录项高速缓存与索引节点高速缓存。<br>当要回收其中的页框时，<code>PFRA</code>就必须检查这些磁盘高速缓存是否可压缩。<br><code>PFRA</code>处理的每个磁盘高速缓存在初始化时必须注册一个<code>shrinker</code>函数。<br><code>shrinker</code>函数有两个参数：待回收页框数和一组<code>GFP</code>分配标志。函数按照要求从磁盘高速缓存回收页，然后返回仍然留在高速缓存内的可回收页数。</p>
<p><code>set_shrinker()</code>函数向<code>PFRA</code>注册一个<code>shrinker</code>函数。该函数分配一个<code>shrinker</code>类型的描述符，在该描述符中存放<code>shrinker</code>函数的地址，然后把描述符插入一个全局链表，该链表存放在<code>shrinker_list</code>全局变量中，<code>set_shrinker()</code>函数还初始化<code>shrinker</code> 描述符的<code>seeks</code>字段，通俗地说，这个字段表示：在高速缓存中的元素一旦被删除，那么重建一个所需的代价。</p>
<p>在<code>Linux2.6.11</code>中，向<code>PFRA</code>注册的磁盘高速缓存很少。除了目录项高速缓存和索引节点高速缓存之外，注册<code>shrinker</code>函数的只有磁盘限额层、文件系统元信息块高速缓存(主要用于文件系统扩展属性)和<code>XFS</code>日志文件系统。从可压缩磁盘高速缓存回收页的<code>PFRA</code>函数叫作<code>shrink_slab()</code>，它由<code>try_to_free_pages()</code>和<code>balance_pgdat()</code>调用。(函数名有点误导，因为该函数与<code>slab</code>分配器高速缓存没什么关系)。</p>
<p>对于从可压缩磁盘高速缓存回收的代价与及从<code>LRU</code>链表回收的代价之间，<code>shrink_slab()</code>函数试图作出一种权衡。实际上，函数扫描<code>shrinker</code>描述符的链表，调用这些<code>shrinker</code>函数并得到磁盘高速缓存中总的可回收页数。然后，函数再一次扫描<code>shrinker</code>描述符的链表，对于每个可压缩磁盘高速缓存，函数推算出待回收页框数。推算考虑的因素有：磁盘高速缓存中总的可回收页数、在磁盘高速缓存中重建一页的相关代价、<code>LRU</code>链表中的页数。然后再调用<code>shrinker</code>函数尝试回收一组页(至少<code>128</code>页)。因篇幅所限，我们只简单讨论目录项高速缓存和索引节点高速缓存的<code>shrinker</code>函数。</p>
<h3 id="从目录项高速缓存回收页框"><a href="#从目录项高速缓存回收页框" class="headerlink" title="从目录项高速缓存回收页框"></a>从目录项高速缓存回收页框</h3><p><code>shrink_dcache_memory()</code>函数是目录项高速缓存的<code>shrinker</code>函数。它搜索高速缓存中的未用目录项对象，即没有被任何进程引用的目录项对象，然后将它们释放。由于目录项高速缓存对象是通过<code>slab</code>分配器分配的，因此<code>shrink_dcache_memory()</code>函数可能导致一些<code>slab</code>变成空闲的，这样有些页框就可以被<code>cache_reap()</code>回收。此外，目录项高速缓存起索引节点高速缓存控制器的作用，因此，当一个目录项对象被释放时，存放相应索引节点对象的页就可以变为未用，而最终被释放。</p>
<p><code>shrink_dcache_memory()</code>函数接收两个参数：待回收页框数和<code>GFP</code>掩码。一开始，它检查<code>GFP</code>掩码中的<code>__GFP_FS</code>标志位是否清<code>0</code>。如果是则返回<code>-1</code>，因为释放目录项可能触发基于磁盘文件系统的操作。通过调用<code>prune_dcache()</code>，就可以有效地进行页框回收。该函数扫描未用目录项链表(该链表的头部存放在<code>dentry_unused</code>变量中)，一直到获得请求数量的释放对象或整个链表扫描完毕。对每个最近未被引用的对象，函数执行如下步骤：</p>
<ol>
<li>把目录项对象从目录项散列表、从其父目录中的目录项对象链表、从拥有者索引节点的目录项对象链表中删除。</li>
<li>调用d_iput目录项方法(如果定义)或者iput()函数减少目录项的索引节点的引用计数器。</li>
<li>调用目录项对象的d_release方法(如果定义)。</li>
<li>调用call_rcu()函数以注册一个会删除目录项对象的回调函数，该回调函数又调用kmem_cache_free()把对象释放给slab分配器。</li>
<li>减少父目录的引用计数器。</li>
</ol>
<p>最后，依据仍然留在目录项高速缓存中的未用目录项数，<code>shrink_dcache_memory()</code>返回一个值。更准确地说，返回值是未用目录项数乘以<code>100</code>除以<code>sysctl_vfs_cache_pressure</code>全局变量的值。该变量的系统默认值是<code>100</code>，因此返回值实际就是未用目录项数。但是通过修改文件<code>/proc/sys/vm/yfs_cache_pressure</code>或通过有关的<code>sysct1()</code>系统调用，系统管理员可以改变这个变量值。把值改为小于<code>100</code>，则使<code>shrink_slab()</code>从目录项高速缓存回收的页少于从<code>LRU</code>链表中回收的页。反之，如把值改为大于<code>100</code>，则使<code>shrink_slab()</code>从目录项高速缓存回收的页多于从<code>LRU</code>链表中回收的页。</p>
<h3 id="从索引节点高速缓存回收页框"><a href="#从索引节点高速缓存回收页框" class="headerlink" title="从索引节点高速缓存回收页框"></a>从索引节点高速缓存回收页框</h3><p><code>shrink_icache_memory()</code>函数被调用来从索引节点高速缓存删除未用索引节点对象。“未用”就是指索引节点不再有一个控制目录项对象。这个函数非常类似于刚描述的<code>shrink_dcache_memory()</code>。它检查<code>gfp_mask</code>参数的<code>__GFP_FS</code>位，然后调用<code>prune_icache()</code>，最后与前面一样，依据仍然留在索引节点高速缓存中的未用索引节点数和<code>sysctl_vfs_cache_pressure</code>变量的值，返回一个值。</p>
<p><code>prune_icache()</code>函数又扫描<code>inode_unused</code>链表。要释放一个索引节点，函数必须释放与该索引节点关联的任何私有缓冲区，它使页高速缓存内(引用该索引节点的)不再使用的干净页框无效，然后通过调用<code>clear_inode()</code>和<code>destroy_inode()</code>函数来删除索引节点对象。</p>
<h3 id="周期回收"><a href="#周期回收" class="headerlink" title="周期回收"></a>周期回收</h3><p><code>PFRA</code>用两种机制进行周期回收：<code>kswapd</code>内核线程和<code>cache_reap</code>函数。前者调用<code>shrink_zone()</code>和<code>shrink_slab()</code>从<code>LRU</code>链表中回收页；后者则被周期性地调用以便从<code>slab</code>分配器中回收未用的<code>slab</code>。</p>
<h3 id="kswapd内核线程"><a href="#kswapd内核线程" class="headerlink" title="kswapd内核线程"></a>kswapd内核线程</h3><p><code>kswapd</code>内核线程是激活内存回收的另外一种机制。为什么还需要这个内核线程呢？当空闲内存变得紧缺并且发出另一个内存分配请求时，调用<code>try_to_free_pages()</code>还不足够吗?</p>
<p>有些内存分配请求是由中断和异常处理程序执行的，它们不会阻塞等待释放页框的当前进程；还有，有些内存分配请求是由已经获得对临界资源互斥访问权限，因此就不能激活<code>I/O</code>数据传送的内核控制路径实现的。在极少的情况下，所有的内存分配请求都是由这种内核控制路径完成的，因此内核将永远不能释放空闲内存。<code>kswapd</code>利用机器空闲的时间保持内存空闲也对系统性能有良好的影响，进程因此能很快获得自己的页。</p>
<p>每个内存节点对应各自的<code>kswapd</code>内核线程。每个这样的线程通常睡眠在等待队列中，该等待队列以节点描述符的<code>kswapd_wait</code>字段为头部。但是，如果<code>__alloc_pages()</code>发现所有适合内存分配的内存管理区包含的空闲页框数低于“警告”阈值(一个依据内存管理区描述符的<code>pages_low</code> 和<code>protection</code>字段推算出来的值)时，那么相应内存节点的<code>kswapd</code>内核线程被激活。</p>
<p>从本质上说，为了避免更多紧张的“内存紧缺”的情形，内核才开始回收页框。每个管理区描述符还包括字段<code>pages_min</code>和<code>pages_high</code>。前者表示必须保留的最小空闲页框数阈值；后者表示“安全”空闲页框数阈值，即空闲页框数大于该阈值时，应该停止页框回收。</p>
<p><code>kswapd</code>内核线程执行<code>kswapd()</code>函数。内核线程被初始化的内容是：把线程绑定到访问内存节点的<code>CPU</code>；再把<code>reclaim_state</code>描述符地址存入进程描述符的<code>current-&gt;reclaim_state</code>字段；把<code>current-&gt;flags</code>字段的<code>PF_MEMALLOC</code>和<code>PF_KSWAP</code>标志置位，其含义是进程将回收内存，运行时允许使用全部可用空闲内存。每当<code>kswapd</code>内核线程被唤醒，<code>kswapd ()</code>函数执行下列主要操作：</p>
<ul>
<li>调用<code>finish_wait()</code>从节点的<code>kswapd_wait</code>等待队列删除内核线程。</li>
<li>调用<code>balance_pgdat()</code>对<code>kswapd</code>的内存节点进行内存回收。</li>
<li>调用<code>prepare_to_wait()</code>把进程设成<code>TASK_INTERRUPTIBLE</code>状态，并让它在节点的<code>kswapd_wait</code>等待队列中睡眠。</li>
<li>调用<code>schedule()</code>让<code>CPU</code>处理一些其他可运行进程。</li>
</ul>
<p><code>balance_pgdat()</code>函数又执行下面的主要步骤：</p>
<ol>
<li>建立<code>scan_control</code>描述符。</li>
<li>把内存节点的每个管理区描述符中的<code>temp_priority</code>字段设为<code>12</code>(最低优先级)。</li>
<li>执行一个循环，从<code>12</code>到<code>0</code>最多<code>13</code>次迭代。每次迭代执行下列子步骤：</li>
</ol>
<blockquote>
<ol>
<li>扫描内存管理区，寻找空闲页框数不足的最高管理区(从<code>ZONE_DMA</code>到<code>ZONE_HIGHMEM</code>)。由<code>zone_watermark_ok()</code>函数进行每次的检测。如果所有管理区都有大量空闲页框，则跳到第<code>4</code>步。</li>
<li>对一部分管理区再一次进行扫描，范围是从<code>ZONE_DMA</code>到第<code>3a</code>步找到的管理区。对每个管理区，必要时用当前优先级更新管理区描述符的<code>prev_priority</code>字段，且连续调用<code>shrink_zone()</code>以回收管理区中的页。然后，调用<code>shrink_slab()</code>从可压缩磁盘高速缓存回收页。</li>
<li>如果已有至少<code>32</code>页被回收，则跳出循环至第<code>4</code>步。<br>用各自<code>temp_priority</code>字段的值更新每个管理区描述符的<code>prev_priority</code>字段。<br>如果仍有“内存紧缺”管理区存在，且如果进程的<code>need_resched</code>字段置位，则调用<code>schedule()</code>。当再一次执行时，跳到第<code>1</code>步。</li>
</ol>
</blockquote>
<ol>
<li>返回回收的页数。</li>
</ol>
<h3 id="cache-reap-函数"><a href="#cache-reap-函数" class="headerlink" title="cache_reap()函数"></a>cache_reap()函数</h3><p><code>PFRA</code>还必须回收<code>slab</code>分配器高速缓存的页。为此，它使用<code>cache_reap()</code>函数，该函数周期性(差不多每两秒一次)地在预定事件工作队列中被调度。它的地址存放在每<code>CPU</code>变量<code>reap_work</code> 的<code>func</code>字段，该变量为<code>work_struct</code>类型。</p>
<p><code>cache_reap()</code>函数主要执行如下步骤：<br>(1). 尝试获得<code>cache_chain_sem</code>信号量，该信号量保护<code>slab</code>高速缓存描述符链表。如果信号量已取得，就调用<code>schedule_delayed_work()</code>去调度该函数的下一次执行，然后结束。<br>(2). 否则，扫描存放在<code>cache_chain</code>链表中的<code>kmem_cache_t</code>描述符。对找到的每一个高速缓存描述符，函数执行以下步骤：<br>a. 如果高速缓存描述符的<code>SLAB_NO_REAP</code>标志置位，则页框回收被禁止，因此处理链表中的下一个高速缓存。<br>b. 清空局部<code>slab</code>高速缓存，则会有新的<code>slab</code>被释放。<br>c. 每个高速缓存都有“收割时间(<code>reap time</code>)”，该值存放在高速缓存描述符中<code>kmem_list3</code>结构的<code>next_reap</code>字段。如果<code>jiffies</code>值仍然小于<code>next_reap</code>，则继续处理链表中的下一个高速缓存。<br>d. 把存放在<code>next_reap</code>字段的下一次“收割时间”设为：从现时起的<code>4s</code>。<br>e. 在多处理器系统中，函数清空<code>slab</code>共享高速缓存，那么会有新的<code>slab</code>被释放。<br>f. 如有新的<code>slab</code>最近被加入高速缓存，即高速缓存描述符中<code>kmem_list3</code>结构的<code>free_touched</code>置位，那么跳过这个高速缓存，继续处理链表中的下一个高速缓存。<br>g. 根据经验公式计算要释放的<code>slab</code>数量。基本上，这个数取决于高速缓存中空闲对象数的上限和能装入单个<code>slab</code>的对象数。<br>h. 对高速缓存空闲<code>slab</code>链表中的每个<code>slab</code>，重复调用<code>slab_destroy()</code>，一直到链表为空或者已回收目标数量的空闲<code>slab</code>。<br>i. 调用<code>cond_resched()</code>检查当前进程的<code>TIF_NEED_RESCHED</code>标志，如果该标志置位，则调用<code>schedule()</code>。<br>(3). 释放<code>cache_chain_sem</code>信号量。<br>(4). 调用<code>schedule_delayed_work()</code>去调度该函数的下一次执行，然后结束。</p>
<h3 id="内存不足删除程序"><a href="#内存不足删除程序" class="headerlink" title="内存不足删除程序"></a>内存不足删除程序</h3><p>为满足一些紧迫请求，内核总试图释放内存，但是无法成功，这是因为交换区已满且所有磁盘高速缓存已被压缩。因此，没有进程可以继续执行，也就没有进程会释放它所拥有的页框。为应对这种突发情况，<code>PFRA</code>使用所谓的内存不足(<code>out ofmemory</code>,00M)删除程序，该程序选择系统中的一个进程，强行删除它并释放页框。当空闲内存十分紧缺且<code>PFRA</code>又无法成功回收任何页时，<code>__alloc_pages()</code>调用<code>out_of_memory()</code>函数。函数调用<code>select_bad_process()</code>在现有进程中选择一个“牺牲品”，然后调用<code>oom_kill_process()</code>删除该进程。</p>
<p>当然，<code>select_bad_process()</code>并不是随机挑选进程的。被选进程应满足下列条件：</p>
<ul>
<li>它必须拥有大量页框，从而可以释放出大量内存。</li>
<li>删除它只损失少量工作成果(删除一个工作了几个小时或几天的批处理进程就不是个好主意)。</li>
<li>它应具有较低的静态优先级，用户通常给不太重要的进程赋予较低的优先级。</li>
<li>它不应是有root特权的进程，特权进程的工作通常比较重要。</li>
<li>它不应直接访问硬件块设备(如<code>XWindow</code>服务器)，因为硬件不能处在一个无法预知的状态。</li>
<li>它不能是<code>swapper</code>(进程<code>0</code>)、<code>init</code>(进程<code>1</code>)和任何其他内核线程。</li>
</ul>
<p><code>select_bad_process()</code>函数扫描系统中的每一个进程，根据以上准则用经验公式计算一个值，这个值表示选择这个进程的有利程度，然后返回最有利的被选进程描述符的地址。<code>out_of_memory()</code>函数再调用<code>oom_kill_process()</code>并发出死亡信号，该信号发给该进程的一个子进程，或如果做不到，就发给该进程本身。<code>oom_kill_process()</code>同时也删除与被选进程共享内存描述符的所有克隆进程。</p>
<h3 id="交换标记"><a href="#交换标记" class="headerlink" title="交换标记"></a>交换标记</h3><p>当系统内存不足时，<code>PFRA</code>全力把页写入磁盘以释放内存并从一些进程窃取相应的页框；而同时，这些进程要继续执行，也全力访问它们的页。因此内核把<code>PFRA</code>刚释放的页框又分配给这些进程，并从磁盘读回其内容。</p>
<p>其结果就是页被无休止地写入磁盘并且再从磁盘读回。大部分的时间耗在访问磁盘上，从而没有进程能实质性地运行下去。为减少交换失效的发生，一种由<code>Jiang</code>和<code>Zhang</code>在<code>2004</code>年提出的技术在内核版本<code>2.6.9</code> 中得到实现。即把所谓的交换标记(<code>swap token</code>)赋给系统中的单个进程，该标记可以使该进程免子页框回收，所以进程可以实质性地运行，而且即使内存十分稀少，也有希望运行至结束。交换标记的具体实现形式是<code>swap_token_mm</code>内存描述符指针。当进程拥有交换标记时，<code>swap_token_mm</code>被设为进程内存描述符的地址。</p>
<p>页框回收算法的免除以如此简洁的方式实现了。我们在“最近最少使用(<code>LRU</code>)链表”一节看到，只当最近没有被引用时，一页才可从活动链表移入非活动链表。<code>page_referenced()</code>函数进行这一检查。如果该页属于一个线性区，该区域所在进程拥有交换标记，那么该函数认可这个交换标记并返回<code>1</code>(被引用)。实际上，交换标记在几种情况下不予考虑：<code>PFRA</code>代表一个拥有交换标记的进程运行，以及<code>PFRA</code>达到页框回收的最难优先级(<code>0</code>级)。</p>
<p><code>grab_swap_token()</code>函数决定是否将交换标记赋给当前进程。对每个主缺页(<code>major page fault</code>)调用该函数，这只有两种情形：<br>(1). 当<code>filemap_nopage()</code>函数发现请求页不在页高速缓存中时。<br>(2). 当<code>do_swap_page()</code>函数从交换区读入一个新页时。</p>
<p><code>grab_swap_token()</code>函数在分配交换标记之前要进行一些检查，具体地说，就是要满足下列条件才可赋予交换标记：<br>(1). 上次调用<code>grab_swap_token()</code>后，至少已过了<code>2s</code>。<br>(2). 在上一次调用<code>grab_swap_token()</code>后，当前拥有交换标记的进程没再提出主缺页，或该进程拥有交换标记的时间超出<code>swap_token_default_timeout</code>个节拍。<br>(3). 当前进程最近没有获得过交换标记。</p>
<p>交换标记的持有时间最好长一些，甚至以分钟为单位，因为其目标就是允许进程完成其执行。在<code>Linux 2.6.11</code>中，交换标记的持有时间默认值很小，即一个节拍。但是，通过编辑<code>/proc/sys/vm/swap_token_default_timeout</code>文件或发出相应的<code>sysct1()</code>系统调用，系统管理员可以修改<code>swap_token_default_timeout</code>变量的值。当删除一个进程时，内核检查该进程是否拥有交换标记。如果是则放开它。这由<code>mmput()</code>函数实现。</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>交换(<code>swapping</code>)用来为非映射页在磁盘上提供备份。从前面的讨论我们知道有三类页必须由交换子系统处理：<br>(1). 属于进程（没有名字的线性区）匿名线性区(例如，用户态堆栈和堆)的页。—属于没有名字线性区的页<br>(2). 属于进程私有内存映射的脏页。—内存映射，映射所在的线性区也是匿名的<br>(3). 属于IPC共享内存区的页。—内存映射，映射所在的线性区也是匿名的。共享只限于父子进程间。</p>
<p>就像请求调页，交换对于程序必须是透明的。换句话说，不需要在代码中嵌入与交换有关的特别指令。我们知道每个页表项包含一个<code>Present</code>标志。内核利用这个标志来通知属于某个进程地址空间的页已被换出。在这个标志之外，<code>Linux</code>还利用页表项中的其他位存放换出页标识符(<code>swapped-out page identifier</code>)。该标识符用于编码换出页在磁盘上的位置。当缺页异常发生时，相应的异常处理程序可以检测到该页不在<code>RAM</code>中，然后调用函数从磁盘换入该缺页。</p>
<p>交换子系统的主要功能总结如下:<br>(1). 在磁盘上建立交换区(swap area)，用于存放没有磁盘映像的页。<br>(2). 管理交换区空间。当需求发生时，分配与释放页槽(page slot)。<br>(3). 提供函数用于从RAM中把页换出(swap out)到交换区或从交换区换入(swap in)到RAM中。<br>(4). 利用页表项(现已被换出的换出页页表项)中的换出页标识符跟踪数据在交换区中的位置。<br>总之，交换是页框回收的一个最高级特性。</p>
<p>如果我们要确保进程的所有页框都能被<code>PFRA</code> 随意回收，而不仅仅是回收有磁盘映像的页，那么就必须使用交换。<br>当然，你可以用<code>swapoff</code>命令关闭交换，但此时随着磁盘系统负载增加，很快就会发生磁盘系统瘫痪。<br>我们还需指出，交换可以用来扩展内存地址空间，使之被用户态进程有效地使用。</p>
<p>事实上，一个大交换区可允许内核运行几个大需求量的应用，它们的内存总需求量超过系统中安装的物理内存量。<br>但是，就性能而言，<code>RAM</code>的仿真还是比不上<code>RAM</code>本身。<br>进程对当前换出页的每一次访问，与对<code>RAM</code>中页的访问比起来，要慢几个数量级。简而言之，如果性能重要，那么交换仅仅作为最后一个方案；为了解决不断增长的计算需求增加<code>RAM</code>芯片的容量仍然是一个最好的方法。</p>
<h3 id="交换区"><a href="#交换区" class="headerlink" title="交换区"></a>交换区</h3><p>从内存中换出的页存放在交换区(<code>swap area</code>)中，交换区的实现可以使用自己的磁盘分区，也可以使用包含在大型分区中的文件。可以定义几种不同的交换区，最大个数由<code>MAX_SWAPFILES</code>宏(通常被设置成<code>32</code>)确定。如果有多个交换区，就允许系统管理员把大的交换空间分布在几个磁盘上，以使硬件可以并发操作这些交换区；这样处理还允许在系统运行时不用重新启动系统就可以扩大交换空间的大小。</p>
<p>每个交换区都由一组页槽(<code>page slot</code>)组成，也就是说，由一组<code>4096</code>字节大小的块组成，每块中包含一个换出的页。交换区的第一个页槽用来永久存放有关交换区的信息，其格式由<code>swap_heade</code>r联合体(由两个结构<code>info</code>和<code>magic</code>组成)来描述。</p>
<p><code>magic</code>结构提供了一个字符串，用来把磁盘某部分明确地标记成交换区，它只含有一个字段<code>magic</code>。<code>magic</code>，这个字段含有一个<code>10</code>字符的“<code>magic</code>”字符串。<code>magic</code>结构从根本上允许内核明确地把一个文件或分区标记成交换区，这个字符串的内容就是“<code>SWAPSPACE2</code>“。该字段通常位于第一个页槽的末尾。</p>
<p><code>info</code>结构包括以下字段：</p>
<ul>
<li><code>bootbits</code>，交换算法不使用该字段。该字段对应于交换区的第一个<code>1024</code>字节，可以存放分区数据、磁盘标签等等。</li>
<li><code>version</code>，交换算法的版本。</li>
<li><code>last_page</code>，可有效使用的最后一个页槽。</li>
<li><code>nr_badpages</code>，有缺陷的页槽的个数。</li>
<li><code>padding[125]</code>，填充字节。</li>
<li><code>badpages[1]</code>，一共<code>637</code>个数字，用来指定有缺陷页槽的位置。</li>
</ul>
<h3 id="创建与激活交换区"><a href="#创建与激活交换区" class="headerlink" title="创建与激活交换区"></a>创建与激活交换区</h3><p>只要系统是打开的，存放在交换区中的数据就是有意义的。<br>当系统被关闭时，所有的进程都被杀死，因此，进程存放在交换区中的数据也被丢弃。<br>基于这个原因，交换区包含很少的控制信息，实际上包含交换区类型和有缺陷页槽的链表。<br>这种控制信息很容易存放在一个单独的<code>4KB</code>页中。<br>通常，系统管理员在创建<code>Linux</code>系统中的其他分区时都创建一个交换分区，然后使用<code>mkswap</code>命令把这个磁盘区设置成一个新的交换区。<br>该命令对刚才介绍的第一个页槽中的字段进行初始化。<br>由于磁盘中可能会有一些坏块，这个程序还可以对其他所有的页槽进行检查从而确定有缺陷页槽的位置。但是执行<code>mkswap</code>命令会把交换区设置成非激活的状态。</p>
<p>每个交换区都可以在系统启动时在脚本文件中被激活，也可以在系统运行之后动态激活。每个交换区由一个或多个交换子区(<code>swap extent</code>)组成，每个交换子区由一个<code>swap_extent</code>描述符表示，每个子区对应一组页(更准确地说，是一组页槽)，它们在磁盘上是物理相邻的。</p>
<p><code>swap_extent</code>描述符由下面这几部分组成：交换区的子区首页索引、子区的页数和子区的起始磁盘扇区号。<br>当激活交换区自身的同时，组成交换区的有序子区链表也被创建。存放在磁盘分区中的交换区只有一个子区；<br>但是，存放在普通文件中的交换区则可能有多个子区，这是因为文件系统有可能没把该文件全部分配在磁盘的一组连续块中。</p>
<h3 id="如何在交换区中分布页"><a href="#如何在交换区中分布页" class="headerlink" title="如何在交换区中分布页"></a>如何在交换区中分布页</h3><p>当换出时，内核尽力把换出的页存放在相邻的页槽中，从而减少在访问交换区时磁盘的寻道时间，这是高效交换算法的一个重要因素。<br>但是，如果系统使用了多个交换区，事情就变得更加复杂了。快速交换区(也就是存放在快速磁盘中的交换区)可以获得比较高的优先级。</p>
<p>当查找一个空闲页槽时，要从优先级最高的交换区中开始搜索。<br>如果优先级最高的交换区不止一个，为了避免超负荷地使用其中一个，应该循环选择相同优先级的交换区。<br>如果在优先级最高的交换区中没有找到空闲页槽，就在优先级次高的交换区中继续进行搜索，依此类推。</p>
<h3 id="交换区描述符"><a href="#交换区描述符" class="headerlink" title="交换区描述符"></a>交换区描述符</h3><p>每个活动的交换区在内存中都有自己的swap_info_struct描述符<br><code>flags</code>字段包括三个重叠的子字段：</p>
<ul>
<li><code>SWP_USED</code>，如果交换区是活动的，该值就是<code>1</code>；如果交换区不是活动的，该值就是<code>0</code>。</li>
<li><code>SWP_WRITEOK</code>，如果可以写入交换区，该值就是<code>1</code>；如果交换区只读，该值就是<code>0</code>(可以是活动的或不是活动的)。</li>
<li><code>SWP_ACTIVE</code>，这个两位的字段实际上是<code>SWP_USED</code>和<code>SWP_WRITEOK</code>的组合。如果前面两个标志置位，那么<code>SWP_ACTIVE</code>标志置位。</li>
</ul>
<p><code>swap_map</code>字段指向一个计数器数组，交换区的每个页槽对应一个元素。<br>如果计数器值等于<code>0</code>，那么这个页槽就是空闲的；如果计数器为正数，那么换出页就填充了这个页槽。<br>实际上，页槽计数器的值就表示共享换出页的进程数。<br>如果计数器的值为<code>SWAP_MAP_MAX</code>(等于32767)，那么存放在这个页槽中的页就是“永久”的，并且不能从相应的页槽中删除。如果计数器的值是<code>SWAP_MAP_BAD(</code>等于32768)，那么就认为这个页槽是有缺陷的，也就是不可用的。</p>
<p><code>prio</code>字段是一个有符号的整数，表示交换子系统依据这个值考虑每个交换区的次序。<br><code>sdev_lock</code>字段是一个自旋锁，它防止<code>SMP</code>系统上对交换区数据结构(主要是交换描述符)的并发访问。<br><code>swap_info</code>数组包括<code>MAX_SWAPFILES</code>个交换区描述符。只有那些设置了<code>SWP_USED</code> 标志的交换区才被使用，因为它们是活动区域。<br>图<code>17-6</code>说明了<code>swap_info</code>数组、一个交换区和相应的计数器数组的情况。<br><img src=".\image-20240503160928242.png" alt="image-20240503160928242"></p>
<ol>
<li><code>nr_swapfiles</code>变量存放数组中包含或已包含所使用交换区描述符的最后一个元素的索引。</li>
<li>这个变量有些名不符实，它并没有包含活动交换区的个数。</li>
<li>活动交换区描述符也被插入按交换区优先级排序的链表中。</li>
<li>该链表是通过交换区描述符的<code>next</code>字段实现的，<code>next</code>字段存放的是<code>swap_info</code>数组中下一个描述符的索引。该字段作为索引的这种用法与我们已经见过的很多名为<code>next</code>字段的用法有所不同，后者通常都是指针。</li>
</ol>
<p><code>swap_list_t</code>类型的<code>swap_list</code>变量包括以下字段：</p>
<ul>
<li><code>head</code>，第一个链表元素在<code>swap_info</code>数组中的下标。</li>
<li><code>next</code>，为换出页所选中的下一个交换区的描述符在<code>swap_info</code>数组中的下标。该字段用于在具有空闲页槽的最大优先级的交换区之间实现轮询算法。</li>
</ul>
<p><code>swaplock</code>自旋锁防止在多处理器系统中对链表的并发访问。<br>交换区描述符的<code>max</code>字段存放以页为单位交换区的大小，而<code>pages</code>字段存放可用页槽的数目。<br>这两个数字之所以不同是因为<code>pages</code>字段并没有考虑第一个页槽和有缺陷的页槽。<br>最后，<code>nr_swap_pages</code>变量包含所有活动交换区中可用的(空闲并且无缺陷)页槽数目，而<code>total_swap_pages</code>变量包含无缺陷页槽的总数。</p>
<h3 id="换出页标识符"><a href="#换出页标识符" class="headerlink" title="换出页标识符"></a>换出页标识符</h3><p>可以很简单地而又唯一地标识一个换出页，这是通过在<code>swap_info</code>数组中指定交换区的索引和在交换区内指定页槽的索引实现的。由于交换区的第一个页(索引为<code>0</code>)留给<code>swap_header</code>联合体，第一个可用页槽的索引就为<code>1</code>。</p>
<p><code>swp_entry(type，offset)</code>宏负责从交换区索引<code>type</code>和页槽索引<code>offset</code>中构造换出页标识符。<br><code>swp_type</code>和<code>swp_offset</code>宏，分别从换出页标识符中提取出交换区索引和页槽索引。<br>当页被换出时，其标识符就作为页的表项插入页表中，这样在需要时就可以再找到这个页。<br>要注意这种标识符的最低位与<code>Present</code>标志对应，通常被清除来说明该页目前不在<code>RAM</code>中。<br>但是，剩余<code>31</code>位中至少有一位被置位，因为没有页存放在交换区<code>0</code>的页槽<code>0</code> 中。<br>这样就可以从一个页表项中区分三种不同的情况：</p>
<ul>
<li>空项，该页不属于进程的地址空间，或相应的页框还没有分配给进程(请求调页)。</li>
<li>前<code>31</code>个最高位不全等于<code>0</code>，最后一位等于<code>0</code>，该页现在被换出。</li>
<li>最低位等于<code>1</code>，该页包含在<code>RAM</code>中。</li>
</ul>
<p>注意，交换区的最大值由表示页槽的可用位数决定。在<code>80x86</code>体系结构上，有<code>24</code>位可用，这就限制了交换区的大小为<code>2^24</code>个页槽(也就是<code>64GB</code>)。由于一个页可以属于几个进程的地址空间(参见前面的“反向映射”一节)，所以它可能从一个进程的地址空间中被换出，但是仍旧保留在主存中；因此可能把同一个页换出多次。当然，一个页在物理上只被换出并存储一次，但是后来每次试图换出该页都会增加<code>swap_map</code>计数器的值。</p>
<p>在试图换出一个已经换出的页时就会调用<code>swap_duplicate()</code>函数。该函数只是验证以参数传递的换出页标识符是否有效，并增加相应的<code>swap_map</code>计数器的值。更确切地说，该函数执行以下操作：</p>
<ol>
<li>使用<code>swp_type</code>和<code>swp_offset</code>宏从参数中提取出交换区号<code>type</code>和页槽索引<code>offset</code>。</li>
<li>检查交换区是否被激活；如果不是，则返回<code>0</code>(无效的标识符)。</li>
<li>检查页槽是否有效且是否不为空闲(<code>swap_map</code>计数器大于<code>0</code>且小于<code>SWAP_MAP_BAD</code>)；如果不是，则返回<code>0</code>(无效的标识符)。</li>
<li>否则，换出页的标识符确定出一个有效页的位置。如果页槽的<code>swap_map</code>计数器还没有达到<code>SWAP_MAP_MAX</code>，则增加它的值。</li>
<li>返回<code>1</code>(有效的标识符)。</li>
</ol>
<h3 id="激活和禁用交换区"><a href="#激活和禁用交换区" class="headerlink" title="激活和禁用交换区"></a>激活和禁用交换区</h3><p>一旦交换区被初始化，超级用户(或者更确切地说是任何具有<code>CAP_SYS_ADMIN</code>权能的用户)就可以分别使用<code>swapon</code>和<code>swapoff</code>程序激活和禁用交换区。这两个程序分别使用了<code>swapon()</code>和<code>swapoff()</code>系统调用，我们将简要介绍相应的服务例程。</p>
<h4 id="sys-swapon-服务例程"><a href="#sys-swapon-服务例程" class="headerlink" title="sys_swapon()服务例程"></a>sys_swapon()服务例程</h4><p><code>sys_swapon()</code>服务例程接收如下参数：<br><code>specialfile</code>，这个参数指向设备文件(或分区)的路径名(在用户态地址空间)，或指向实现交换区的普通文件的路径名。<br><code>swap_flags</code>，这个参数由一个单独的<code>SWAP_FLAG_PREFER</code>位加上交换区优先级的3I位组成(只有在<code>SWAP_FLAG_PREFER</code>位置位时，优先级位才有意义)。</p>
<p><code>sys_swapon()</code>函数对创建交换区时放入第一个页槽中的<code>swap_header</code>联合体字段进行检查。其执行的主要步骤有：</p>
<ol>
<li><p>检查当前进程是否具有<code>CAP_SYS_ADMIN</code>权能。</p>
</li>
<li><p>在交换区描述符<code>swap_info</code>数组的前<code>nr_swapfiles</code>个元素中查找<code>SWP_USED</code>标志为<code>0</code>(即对应的交换区不是活动的)的第一个描述符。如果找到一个不活动交换区，则跳到第<code>4</code>步。</p>
</li>
<li><p>新交换区数组索引等于<code>nr_swapfiles</code>：它检查保留给交换区索引的位数是否足够用于编码新索引。如果不够，则返回错误代码；如果足够，就将<code>nr_swapfiles</code>的值加</p>
</li>
<li><p>找到未用交换区索引：它初始化这个描述符的字段，即把<code>flags</code>置为<code>SWP_USED</code>，把<code>lowest_bit</code>和<code>highest_bit</code>置为<code>0</code>。</p>
</li>
<li><p>如果<code>swap_flags</code>参数为新交换区指定了优先级，则设置描述符的<code>prio</code>字段。否则，就把所有活动交换区中最低的优先级减<code>1</code>后赋给这个字段(这样就假设最后一个被激活的交换区在最慢的块设备上)。如果没有其他交换区是活动的，就把该字段设置成<code>-1</code>。</p>
</li>
<li><p>从用户态地址空间复制由<code>specialfile</code>参数所指向的字符串。</p>
</li>
<li><p>调用<code>filp_open()</code>打开由<code>specialfile</code>参数指定的文件。</p>
</li>
<li><p>把<code>filp_open()</code>返回的文件对象地址存放在交换区描述符的<code>swap_file</code>字段。</p>
</li>
<li><p>检查<code>swap_info</code>中其他的活动交换区，以确认该交换区还未被激活。具体就是，检查交换区描述符的<code>swap_file-&gt;f_mapping</code>字段中存放的<code>address_space</code>对象地址。如果交换区已被激活，则返回错误码。</p>
</li>
<li><p>如果<code>specialfile</code>参数标识一个块设备文件，则执行下列子步骤：</p>
<blockquote>
<ol>
<li>调用<code>bd_claim()</code>把交换子系统设置成块设备的占有者。如果块设备已有一个占有者，则返回错误码。</li>
<li>把<code>block_device</code>描述符地址存入交换区描述符的<code>bdev</code>字段。</li>
<li>把设备的当前块大小存放在交换区描述符的<code>old_block_size</code>字段，然后把设备的块大小设成<code>4096</code>字节(即页的大小)。</li>
</ol>
</blockquote>
</li>
<li><p>如果<code>specialfile</code>参数标识一个普通文件，则执行下列子步骤：</p>
<blockquote>
<ol>
<li><p>检查文件索引节点<code>i_flags</code>字段中的<code>S_SWAPFILE</code>字段。如果该标志置位，说明文件已被用作交换区，返回错误码。</p>
</li>
<li><p>把该文件所在块设备的描述符地址存入交换区描述符的<code>bdev</code>字段。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>读入存放在交换区页槽<code>0</code>中的<code>swap_header</code>描述符。为达到这个目的，它调用<code>read_cache_page()</code>，并传入参数：由<code>swap_file-&gt;f_mapping</code>指向的<code>address_space</code>对象、页索引<code>0</code>、文件<code>readpage</code>方法的地址(存放在<code>swap_file-&gt;f_mapping-&gt;a_ops-&gt;readpage</code>)指向文件对象<code>swap_file</code>的指针。然后等待直到页被读入内存。</p>
</li>
<li><p>检查交换区中第一页的最后<code>10</code>个字符中的魔术字符串是否等于“<code>SWAPSPACE2</code>”。如果不是，就返回一个错误码。</p>
</li>
<li><p>根据存放在<code>swap_header</code>联合体的<code>info.last_page</code>字段中的交换区的大小，初始化交换区描述符的<code>lowest_bit</code>和<code>highest_bit</code>字段。</p>
</li>
<li><p>调用<code>vmalloc()</code>来创建与新交换区相关的计数器数组，并把它的地址存放在交换描述符的<code>swap_map</code>字段中。还要根据<code>swap_header</code>联合体的<code>info.bad_pages</code>字段中存放的有缺陷的页槽链表把这个数组的对应元素初始化成<code>0</code>或<code>SWAP_MAP_BAD</code>。</p>
</li>
<li><p>通过访问第一个页槽中的<code>info.last_page</code>和<code>info.nr_badpages</code>字段计算可用页槽的个数，并把它存入交换区描述符的<code>pages</code>字段。而且把交换区中的总页数赋给<code>max</code>字段。</p>
</li>
<li><p>为新交换区建立子区链表<code>extent_list</code>(如果交换区建立在磁盘分区上，则只有一个子区)，并相应地设定交换区描述符的<code>nr_extents</code>和<code>curr_swap_extent</code>字段。</p>
</li>
<li><p>把交换区描述符的<code>flags</code>字段设为<code>SWP_ACTIVE</code>。</p>
</li>
<li><p>更新<code>nr_good_pages</code>、<code>nr_swap_pages</code>和<code>total_swap_pages</code>三个全局变量。</p>
</li>
<li><p>把新交换区描述符插入<code>swap_list</code>变量所指向的链表中。</p>
</li>
<li><p>返回<code>0</code>(成功)。</p>
</li>
</ol>
<h4 id="sys-swapoff-服务例程"><a href="#sys-swapoff-服务例程" class="headerlink" title="sys_swapoff()服务例程"></a>sys_swapoff()服务例程</h4><p><code>sys_swapoff()</code>服务例程使<code>specialfile</code>参数所指定的交换区无效。<code>sys_swapoff()</code>比<code>sys_swapon()</code>复杂得多，也更加耗时，因为使之无效的这个分区现在可能仍然还包含几个进程的页。因此，强制该函数扫描交换区并把所有现有的页都换入。</p>
<p>由于每个换入操作都需要一个新的页框，因此如果现在没有空闲页框，这个操作就可能失败。在这种情况下，该函数就返回一个错误码。所有这些操作都是通过执行以下主要步骤实现的：<br>(1). 验证当前进程是否具有<code>CAP_SYS_ADMIN</code>权能。<br>(2). 拷贝内核空间中<code>specialfile</code>所指向的字符串。<br>(3). 调用<code>filp_open()</code>，打开<code>specialfile</code>参数确定的文件。与往常一样，该函数返回文件对象的地址。<br>(4). 扫描交换区描述符链表<code>swap_list</code>，比较由<code>filp_open()</code>返回的文件对象地址与活动交换区描述符的<code>swap_file</code>字段中的地址，如果不一致，说明传给函数的是一个无效参数，则返回一个错误码。<br>(5). 调用<code>cap_vm_enough_memory()</code>，检查是否有足够的空闲页框把交换区上存放的所有页换入。如果不够，交换区就不能禁用，然后释放文件对象，返回错误码。这只是个粗略的检查，但可使内核免于许多无用的磁盘操作。当执行这项检查时，<code>cap_vm_enough_memory()</code>要考虑由<code>slab</code>高速缓存分配且<code>SLAB_RECLAIM_ACCOUNT</code>标志置位的页框，这样的页(被认为是可回收的这些页)的数量存放在<code>slab_reclaim pages</code>变量中。<br>(6). 从<code>swap_list</code>链表中删除该交换区描述符。<br>(7). 从<code>nr_swap_pages</code>和<code>total_swap_pages</code>的值中减去存放在交换区描述符的<code>pages</code>字段中的值。<br>(8). 把交换区描述符<code>flags</code>字段中的<code>SWP_WRITEOK</code>标志清<code>0</code>。这可禁止<code>PFRA</code>向交换区换出更多的页。<br>(9). 调用<code>try_to_unuse()</code>函数强制把这个交换区中剩余的所有页都移到<code>RAM</code>中，并相应地修改使用这些页的进程的页表。当执行该函数时，当前进程(即运行<code>swapoff</code>的进程)的<code>PF_SWAPOFF</code>标志置位。该标志置位只有一个结果：如页框严重不足，<code>select_bad_process()</code>函数就会被强制选择并删除该进程。<br>(10). 一直等到交换区所在的块设备驱动器被卸载。这样在交换区被禁用之前，<code>try_to_unuse()</code>发出的读请求会被驱动器处理。<br>(11). 如果在分配所有请求的页框时<code>try_to_unuse()</code>函数失败，那么就不能禁用这个交换区。因此，<code>sys_swapoff()</code>执行下列子步骤：<br>a. 把这个交换区描述符重新插入<code>swap_list</code>链表，并把它的<code>flags</code>字段置为<code>SWP_WRITEOK</code>。<br>b. 把交换区描述符中<code>pages</code>字段的值加到<code>nr_swap_pages</code>和<code>total_swap_pages</code>变量以恢复其原值。<br>c. 调用<code>filp_close()</code>关闭在第<code>3</code>步中打开的文件，并返回错误码。<br>(12). 否则，所有已用的页槽都已经被成功传送到<code>RAM</code>中。因此，执行下列子步骤<br>a. 释放存有<code>swap_map</code>数组和子区描述符的内存区域。<br>b. 如果交换区存放在磁盘分区，则把块大小恢复到原值，该原值存放在交换区描述符的<code>old_block_size</code>字段。而且，调用<code>bd_release()</code>函数，使交换子系统不再占有该块设备。<br>c. 如果交换区存放在普通文件中，则把文件索引节点的<code>S_SWAPFILE</code>标志清<code>0</code>。<br>d. 调用<code>filp_close()</code>两次，第一次针对<code>swap_file</code>文件对象，第二次针对第<code>3</code>步中<code>filp_open()</code>返回的对象。<br>e. 返回<code>0</code>(成功)。</p>
<h3 id="try-to-unuse-函数"><a href="#try-to-unuse-函数" class="headerlink" title="try_to_unuse()函数"></a>try_to_unuse()函数</h3><p><code>try_to_unuse()</code>函数使用一个索引参数，该参数标识待清空的交换区。该函数换入页并更新已换出页的进程的所有页表。因此，该函数从<code>init_mm</code>内存描述符(用作标记)开始，访问所有内核线程和进程的地址空间。这是一个相当耗时的函数，通常以开中断运行。因此，与其他进程的同步也是关键的。</p>
<p><code>try_to_unuse()</code>函数扫描交换区的<code>swap_map</code>数组。当它找到一个“在用”页槽时，首先换入其中的页，然后开始查找引用该页的进程。这两个操作的顺序对避免竞争条件是至关重要的。当<code>I/O</code>数据传送正在进行时，页被加锁，因此没有进程可以访问它。一旦<code>I/O</code>数据传送完成，页又被<code>try_to_unuse()</code>加锁，以使它不会被另一个内核控制路径再次换出。</p>
<p>因为每个进程在开始进行换入或换出操作之前查找页高速缓存，所以这也可以避免竞争条件。最后，由<code>try_to_unuse()</code>所考虑的交换区被标记为不可写(<code>SWP_WRITEOK</code>标志被清<code>0</code>)，因此，没有进程可以对这个交换区的页槽执行换出。但是，可能强迫<code>try_to_unuse()</code>对交换区引用计数器的<code>swap_map</code>数组扫描几次。这是因为对换出页引用的线性区可能在一次扫描中消失，而在随后又出现在进程链表中。</p>
<p>例如，回想<code>do_munmap()</code>函数的描述；只要进程释放一个线性地址区间，<code>do_munmap()</code>就从进程链表中删除所有受影响线性地址所在的线性区；随后，该函数把只是部分解除映射的那部分线性区重新插入进程链表中。</p>
<p><code>do_munmap()</code>还要负责释放属于已释放线性地址区间的换出页；但是，如果换出的页属于重新插入进程链表的线性区，则最好不要释放它们。 因此，<code>try_to_unuse()</code>对引用给定页槽的进程进行查找时可能失败，因为相应的线性区暂时没有包含在进程的线性区链表中。为了处理这种情况，<code>try_to_unuse()</code>一直对<code>swap_map</code> 数组进行扫描，直到所有的引用计数器都变为空。引用了换出页的“神出鬼没”的线性区最终会重新出现在进程链表中，因此，<code>try_to_unuse()</code>终将会成功释放所有页槽。</p>
<p>让我们现在来描述<code>try_to_unuse()</code>所执行的主要操作。传递给它的参数为交换区<code>swap_map</code>数组的引用计数器，该函数在这个引用计数器上执行连续循环。如果当前进程接收到一个信号，则循环会中断，函数返回错误码。对于数组中的每个引用计数器，<code>try_to_unuse()</code>执行下列步骤：</p>
<blockquote>
<ol>
<li>如果计数器等于<code>0</code>(没有页存放在这里)或者等于<code>SWAP_MAP_BAD</code>，则对下一个页槽继续处理。</li>
<li>否则，调用<code>read_swap_cache_async()</code>函数换入该页。这包括分配一个新页框(如果必要)，用存放在页槽中的数据填充新页框并把这个页存放在交换高速缓存。</li>
<li>等待，直到用磁盘中的数据适当地更新了这个新页，然后锁住它。</li>
<li>当正在执行前一步时，进程有可能被挂起。因此，还要检查这个页槽的引用计数器是否变为空，如果是，说明这个交换页可能被另一个内核控制路径释放，然后继续处理下一个页槽。</li>
<li>对于以<code>init_mm</code>为头部的双向链表中的每个内存描述符，调用<code>unuse_process()</code>。这个耗时的函数扫描拥有内存描述符的进程的所有页表项，并用这个新页框的物理地址替换页表中每个出现的换出页标识符。为了反映这种移动，还要把<code>swap_map</code>数组中的页槽计数器减<code>1</code>(除非计数器等于<code>SWAP_MAP_MAX</code>)，并增加这个页框的引用计数器。</li>
<li>调用<code>shmem_unuse()</code>检查换出的页是否用于<code>IPC</code>共享内存资源，并适当地处理那种情况。</li>
<li>检查页的引用计数器。如果它的值等于<code>SWAP_MAP_MAX</code>，则页槽是“永久的”。为了释放它，则把引用计数器强制置为<code>1</code>。</li>
<li>交换高速缓存可能也拥有该页(它对引用计数器的值起作用)。如果页属于交换高速缓存，就调用<code>swap_writepage()</code>函数把页的内容刷新到磁盘(如果页为脏)，调用<code>delete_from_swap_cache()</code>从交换高速缓存删去页，并把页的引用计数减<code>1</code>。</li>
<li>设置页描述符的<code>PG_dirty</code>标志，并打开页框的锁，递减它的引用计数器(取消第<code>5</code>步的增量)。</li>
<li>检查当前进程的<code>need_resched</code>字段；如果它被设置，则调用<code>schedule()</code>放弃<code>CPU</code>。禁用交换区是一件冗长的工作，内核必须保证系统中的其他进程仍然继续执行。只要这个进程再次被调度程序选中，<code>try_to_unuse()</code>函数就从这一步继续执行。</li>
<li>继续到下一个页槽，从第<code>1</code>步开始。</li>
</ol>
</blockquote>
<p><code>try_to_unuse()</code>继续执行，直到<code>swap_map</code>数组中的每个引用计数器都为空。回想一下，即使这个函数已经开始检查下一个页槽，但是前一个页槽的的引用计数器有可能仍然为正。事实上，一个“神出鬼没”的进程可能还在引用这个页，典型的原因是某些线性区已经被临时从第<code>5</code>步所扫描的进程链表中删除。<code>try_to_unuse()</code>最终会捕获到每个引用。但是，在此期间，页不再位于交换高速缓存，它的锁被打开，并且页的一个拷贝仍然包含在要禁用的交换区的页槽中。</p>
<p>一般会认为这种情形可能导致数据丢失。例如，假定某个“神出鬼没”的进程访问页槽，并开始换入其中的页。因为页不再位于交换高速缓存，因此，进程用从磁盘读取的数据填充一个新的页框。但是，这个页框可能不同于与“神出鬼没”进程共享页的那些进程曾经拥有的页框。当禁用交换区时这个问题不会发生，因为只有在换出的页属于私有匿名内存映射时，对“神出鬼没“进程的干涉才会发生。把不同的页框分配给引用了同一页的进程是完全合法的。但是，<code>try_to_unuse()</code>函数将页标记为“脏”。否则，<code>shrink_list()</code>函数可能随后从某个进程的页表中删除这一页，而并不把它保存在另一个交换区中。</p>
<h3 id="分配和释放页槽"><a href="#分配和释放页槽" class="headerlink" title="分配和释放页槽"></a>分配和释放页槽</h3><p>搜索空闲页槽的第一种方法可以选择下列两种既简单而又有些极端的策略之一：</p>
<ul>
<li>总是从交换区的开头开始。这种方法在换出操作过程中可能会增加平均寻道时间，因为空闲页槽可能已经被弄得凌乱不堪。</li>
<li>(2). 总是从最后一个已分配的页槽开始。如果交换区的大部分空间都是空闲的(这是最通常的情况),</li>
</ul>
<p><code>Linux</code>采用了一种混合的方法。除非发生以下这些条件之一，否则<code>Linux</code>总是从最后一个已分配的页槽开始查找。已经到达交换区的末尾。<br>(1). 上次从交换区的开头重新分配之后，已经分配了<code>SWAPFILE_CLUSTER</code>(通常是<code>256</code>)个空闲页槽。<br>(2). <code>swap_info_struct</code>描述符的<code>cluster_nr</code>字段存放已分配的空闲页槽数。当函数从交换区的开头重新分配时该字段被重置为<code>0</code>。</p>
<p><code>cluster_next</code>字段存放在下一次分配时要检查的第一个页槽的索引。为了加速对空闲页槽的搜索，内核要保证每个交换区描述符的<code>lowest_bit</code>和<code>highest_bit</code>字段是最新的。这两个字段定义了第一个和最后一个可能为空的页槽，换言之，所有低于<code>lowest_bit</code>和高于<code>highest_bit</code>的页槽都被认为已经分配过。</p>
<h3 id="scan-swap-map-函数"><a href="#scan-swap-map-函数" class="headerlink" title="scan_swap_map()函数"></a>scan_swap_map()函数</h3><p><code>scan_swap_map()</code>函数用来在给定的交换区中查找一个空闲页槽。该函数只作用于一个参数，该参数指向交换区描述符返回一个空闲页槽的索引。如果交换区不含有任何空闲页槽，就返回<code>0</code>。该函数执行以下步骤：</p>
<ol>
<li>首先试图使用当前的簇。如果交换区描述符的<code>cluster_nr</code>字段是正数，就从<code>cluster_next</code>索引处的元素开始对计数器的<code>swap_map</code>数组进行扫描，查找一个空项。如果找到一个空项，就减少<code>cluster_nr</code>字段的值并转到第<code>4</code>步。</li>
<li>如果执行到这儿，那么，或者<code>cluster_nr</code>字段为空，或者从<code>cluster_next</code>开始搜索后没有在<code>swap_map</code>数组中找到空项。现在就应该开始第二阶段的混合查找。把<code>cluster_nr</code>重新初始化成<code>SWAPFILE_CLUSTER</code>，并从<code>lowest_bit</code>索引处开始重新扫描这个数组，以便试图找到有<code>SWAPFILE_CLUSTER</code>个空闲页槽的一个组。如果找到这样的一个组，就转到第<code>4</code>步。</li>
<li>不存在<code>SWAPFILE_CLUSTER</code>个空闲页槽的组。从<code>lowest_bit</code>索引处开始重新开始扫描这个数组，以便试图找到一个单独的空闲页槽。如果没有找到空项，就把<code>lowest_bit</code>字段置为数组的最大索引，<code>highest_bit</code>字段置为<code>0</code>，并返回<code>0</code>(交换区已满)。</li>
<li>已经找到空项。把<code>1</code>放在空项中，减少<code>nr_swap_pages</code>的值，如果需要就修改<code>lowest_bit</code>和<code>highest_bit</code>字段，把<code>inuse_page</code>字段的值加<code>1</code>，并把<code>cluster_next</code>字段设置成刚才分配的页槽的索引加<code>1</code>。</li>
<li>返回刚才分配的页槽的索引。</li>
</ol>
<h3 id="get-swap-page-函数"><a href="#get-swap-page-函数" class="headerlink" title="get_swap_page()函数"></a>get_swap_page()函数</h3><p><code>get_swap_page()</code>函数通过搜索所有活动的交换区来查找一个空闲页槽。它返回一个新近分配页槽的换出页标识符，如果所有的交换区都填满，就返回<code>0</code>，该函数要考虑活动交换区的不同优先级。该函数需要经过两遍扫描，以便在容易发现页槽时节约运行时间。第一遍是部分的，只适用于只有相同优先级的交换区。该函数以轮询的方式在这种交换区中查找一个空闲页槽。如果没有找到空闲页槽，就从交换区链表的起始位置开始进行第二遍扫描。在第二遍扫描中，要对所有的交换区都进行检查。</p>
<h3 id="swap-free-函数"><a href="#swap-free-函数" class="headerlink" title="swap_free()函数"></a>swap_free()函数</h3><p>当换入页时，调用<code>swap_free()</code>函数以对相应的<code>swap_map</code>计数器进行减<code>1</code>操作。当相应的计数器达到<code>0</code>时，由于页槽的标识符不再包含在任何页表项中，因此页槽就变成空闲。但是，我们将在后面“交换高速缓存”一节看到，交换高速缓存也记入页槽拥有者的个数。该函数只作用于一个参数<code>entry</code>，<code>entry</code>表示换出页标识符。</p>
<p>函数执行以下步骤：</p>
<ol>
<li>从<code>entry</code>参数导出交换区索引和页槽索引<code>offset</code>，并获得交换区描述符的地址。</li>
<li>检查交换区是否是活动的。如果不是，就立即返回。</li>
<li>如果正在释放的页槽对应的<code>swap_map</code>计数器小于<code>SWAP_MAP_MAX</code>，就减少这个计数器的值。回想一下，值为<code>SWAP_MAP_MAX</code>的项都被认为是永久的(不可删除的)。</li>
<li>如果<code>swap_map</code>计数器变成<code>0</code>，就增加<code>nr_swap_pages</code>的值，减少<code>inuse_pages</code>字段的值，如果需要就修改这个交换区描述符的<code>lowest_bit</code>和<code>highest_bit</code>字段。</li>
</ol>
<h3 id="交换高速缓存"><a href="#交换高速缓存" class="headerlink" title="交换高速缓存"></a>交换高速缓存</h3><p>向交换区来回传送页会引发很多竟争条件，具体地说，交换子系统必须仔细处理下面的情形：</p>
<ul>
<li>多重换入，两个进程可能同时要换入同一个共享匿名页。</li>
<li>同时换入换出，一个进程可能换入正由<code>PFRA</code>换出的页。</li>
</ul>
<p>交换高速缓存(<code>swap cache</code>)的引入就是为了解决这类同步问题。<br>    关键的原则是，没有检查交换高速缓存是否已包括了所涉及的页，就不能进行换入或换出操作。有了交换高速缓存，涉及同一页的并发交换操作总是作用于同一个页框的。因此，内核可以安全地依赖页描述符的<code>PG_locked</code>标志，以避免任何竞争条件。考虑一下共享同一换出页的两个进程这种情形。当第一个进程试图访问页时，内核开始换入页操作，第一步就是检查页框是否在交换高速缓存中，我们假定页框不在交换高速缓存中，那么内核就分配一个新页框并把它插入交换高速缓存，然后开始<code>I/O</code>操作，从交换区读入页的数据；同时，第二个进程访问该共享匿名页，与上面相同，内核开始换入操作，检查涉及的页框是否在交换高速缓存中。现在页框是在交换高速缓存，因此内核只是访问页框描述符，在<code>PG_locked</code>标志清<code>0</code>之前(即<code>I/O</code>数据传输完毕之前)，让当前进程睡眠。</p>
<p>​    当换入换出操作同时出现时，交换高速缓存起着至关重要的作用。<code>shrink_list()</code>函数要开始换出一个匿名页，就必须当<code>try_to_unmap()</code>从进程(所有拥有该页的进程)的用户态页表中成功删除了该页后才可以。但是当换出的写操作还在执行的时候，这些进程中可能有某个进程要访问该页，而产生换入操作。在写入磁盘前，待换出页由<code>shrink_list()</code>存放在交换高速缓存。</p>
<p>​    考虑页<code>P</code>由两个进程(<code>A</code>和<code>B</code>)共享。最初，两个进程的页表项都引用该页框，该页有两个拥有者，如图<code>17-8(a)</code>所示。当<code>PFRA</code>选择回收页时，<code>shrink_list()</code>把页框插入交换高速缓存。如图<code>17-8(b)</code>所示，现在页框有三个拥有者，而交换区中的页槽只被交换高速缓存引用。然后<code>PFRA</code>调用<code>try_to_unmap()</code>从这两个进程的页表项中删除对该页框的引用。一旦这个函数结束，该页框就只有交换高速缓存引用它，而引用页槽的有这两个进程和交换高速缓存，如图<code>17-8(c)</code>所示。假定：当页中的数据写入磁盘时，进程<code>B</code>访问该页，即它要用该页内部的线性地址访问内存单元。那么，缺页异常处理程序发现页框在交换高速缓存，并把物理地址放回进程<code>B</code>的页表项，如图<code>17-8(d)</code>所示。</p>
<p>相反地，如果换出操作结束，而没有并发换入操作，<code>shrink_list()</code>函数则从交换高速缓存删除该页框并把它释放到伙伴系统，如图<code>17-8(e)</code>所示。你可以认为交换高速缓存是一个临时区域，该区域存有正在被换入或换出的匿名页描述符。当换入或换出结束时(对于共享匿名页，换入换出操作必须对共享该页的所有进程进行)，匿名页描述符就可以从交换高速缓存删除。<br><img src=".\image-20240503161246925.png" alt="image-20240503161246925"><br><img src=".\image-20240503161254852.png" alt="image-20240503161254852"></p>
<h3 id="交换高速缓存的实现"><a href="#交换高速缓存的实现" class="headerlink" title="交换高速缓存的实现"></a>交换高速缓存的实现</h3><p>交换高速缓存由页高速缓存数据结构和过程实现。回想一下，页高速缓存的核心就是一组基树，借助基树，算法就可以从<code>address_space</code>对象地址(即该页的拥有者)和偏移量值推算出页描述符的地址。在交换高速缓存中页的存放方式是隔页存放，并有下列特征：页描述符的<code>mapping</code>字段为<code>NULL</code>。页描述符的<code>PG_swapcache</code>标志置位。<code>private</code>字段存放与该页有关的换出页标识符。此外，当页被放入交换高速缓存时，则页描述符的<code>count</code>字段和页槽引用计数器的值都增加，因为交换高速缓存既要使用页框，也要使用页槽。最后，交换高速缓存中的所有页只使用一个<code>swapper_space</code>地址空间，因此只有一个基树(由<code>swapper_space.page_tree</code>指向)对交换高速缓存中的页进行寻址。<code>swapper_space</code>地址空间的<code>nrpages</code>字段存放交换高速缓存中的页数。</p>
<h3 id="交换高速缓存的辅助函数"><a href="#交换高速缓存的辅助函数" class="headerlink" title="交换高速缓存的辅助函数"></a>交换高速缓存的辅助函数</h3><p>内核使用几个函数来处理交换高速缓存，稍后我们将说明这些相对低层的函数是如何被高层函数调用来按需换入和换出页的。处理交换高速缓存的函数主要有：</p>
<ul>
<li><code>lookup_swap_cache()</code>，通过传递来的参数(换出页标识符)在交换高速缓存中查找页并返回页描述符的地址。如果该页不在交换高速缓存中，就返回0。该函数调用<code>radix_tree_lookup()</code>函数，把指向<code>swapper_space.page_tree</code>的指针(用于交换高速缓存中页的基树)和换出页标识符作为参数传递，以查找所需要的页。</li>
<li><code>add_to_swap_cache()</code>，把页插入交换高速缓存中。它本质上调用<code>swap_duplicate()</code>检查作为参数传递来的页槽是否有效，并增加页槽引用计数器；然后调用<code>radix_tree_insert()</code>把页插入高速缓存；最后递增页引用计数器并将<code>PG_swapcache</code>和<code>PG_locked</code>标志置位。</li>
<li><code>__add_to_swap_cache()</code>，与<code>add_to_swap_cache()</code>类似，但是，在把页框插入交换高速缓存前，这个函数不调用<code>swap_duplicate()</code>。</li>
<li><code>delete_from_swap_cache()</code>，调用<code>radix_tree_delete()</code>从交换高速缓存中删除页，递减<code>swap_map</code>中相应的使用计数器，递减页引用计数器。</li>
<li><code>free_page_and_swap_cache()</code>，如果除了当前进程外，没有其它用户态进程正在引用相应的页槽，则从交换高速缓存中删除该页，并递减页使用计数器。</li>
<li><code>free_pages_and_swap_cache()</code>，与<code>free_page_and_swap_cache()</code>相似，但它是对一组页操作。</li>
<li><code>free_swap_and_cache()</code>，释放一个交换表项，并检查该表项引用的页是否在交换高速缓存。如果没有用户态进程(除了当前进程之外)引用该页，或者超过<code>50%</code>的交换表项在用，则从交换高速缓存中释放该页。</li>
</ul>
<h3 id="换出页"><a href="#换出页" class="headerlink" title="换出页"></a>换出页</h3><p>我们从本章前面“内存紧缺回收”一节可看到，<code>PFRA</code>是如何确定一个给定的匿名页是否该被换出。在这一节，我们描述内核如何执行换出操作。</p>
<h4 id="向交换高速缓存插入页框"><a href="#向交换高速缓存插入页框" class="headerlink" title="向交换高速缓存插入页框"></a>向交换高速缓存插入页框</h4><p>换出操作的第一步就是准备交换高速缓存。如果<code>shrink_list()</code>函数确认某页为匿名页(<code>PageAnon()</code>函数返回<code>1</code>)而且交换高速缓存中没有相应的页框(页描述符的<code>PG_swapcache</code> 标志清<code>0</code>)，内核就调用<code>add_to_swap()</code>函数。<code>add_to_swap()</code>函数在交换区中分配一个新页槽，并把一个页框(其页描述符地址作为参数传递)插入交换高速缓存。</p>
<p>函数执行如下主要步骤：</p>
<ol>
<li>调用<code>get_swap_page()</code>函数分配一个新页槽。如果失败(例如没有发现空闲页槽)，则返回<code>0</code>。</li>
<li>调用<code>__add_to_page_cache()</code>，传给它页槽索引、页描述符地址和一些分配标志。</li>
<li>将页描述符中的<code>PG_uptodate</code>和<code>PG_dirty</code>标志置位，从而强制<code>shrink_list()</code>函数把页写入磁盘。</li>
<li>返回<code>1</code>(成功)。</li>
</ol>
<h3 id="更新页表项"><a href="#更新页表项" class="headerlink" title="更新页表项"></a>更新页表项</h3><p>一旦<code>add_to_swap()</code>结束，<code>shrink_list()</code>就调用<code>try_to_unmap()</code>，它确定引用匿名页的每个用户态页表项地址，然后将换出页标识符写入其中。</p>
<h3 id="将页写入交换区"><a href="#将页写入交换区" class="headerlink" title="将页写入交换区"></a>将页写入交换区</h3><p>为完成换出操作需执行的下一个步骤是将页的数据写入交换区。这一<code>I/O</code>传输是由<code>shrink_list()</code>函数激活的，它检查页框的<code>PG_dirty</code>标志是否置位，然后执行<code>pageout()</code>函数。pageout()函数建立一个<code>writeback_control</code>描述符，且调用页<code>address_space</code>对象的<code>writepage</code>方法。而<code>swapper_state</code> 对象的<code>writepage</code>方法是由<code>swap_writepage()</code>函数实现的。</p>
<p><code>swap_writepage()</code>函数所执行的主要步骤如下：<br>(1). 检查是否至少有一个用户态进程引用该页。如果没有，则从交换高速缓存删除该页，并返回<code>0</code>。这一检查之所以必须做，是因为一个进程可能会与<code>PFRA</code>发生竞争并在<code>shrink_list()</code>检查完后释放一页。<br>(2). 调用<code>get_swap_bio()</code>分配并初始化一个<code>bio</code>描述符。函数从换出页标识符算出交换区描述符地址。然后它搜索交换子区链表，以找到页槽的初始磁盘扇区。<code>bio</code>描述符将包含一个单页数据请求(页槽)，其完成方法设为<code>end_swap_bio_write()</code>函数。<br>(3). 置位页描述符的<code>PG_writeback</code>标志和交换高速缓存基树的<code>writeback</code>标记。此外函数还清零<code>PG_locked</code>标志。<br>(4). 调用<code>submit_bio()</code>，传给它<code>WRITE</code>命令和<code>bio</code>描述符地址。<br>(5). 返回<code>0</code>。</p>
<p>一旦<code>I/O</code>数据传输结束，就执行<code>end_swap_bio_write()</code>函数。实际上，这个函数唤醒正等待页<code>PG_writeback</code>标志清零的所有进程，清除<code>PG_writeback</code>标志和基树中的相关标记，并释放用于<code>I/O</code>传输的<code>bio</code>描述符。</p>
<h3 id="从交换高速缓存中删除页框"><a href="#从交换高速缓存中删除页框" class="headerlink" title="从交换高速缓存中删除页框"></a>从交换高速缓存中删除页框</h3><p>换出操作的最后一步还是由<code>shrink_list()</code>执行。如果它验证在<code>I/O</code>数据传输时没有进程试图访问该页框，它实际就调用<code>delete_from_swap_cache()</code>从交换高速缓存中删除该页框。因为交换高速缓存是该页的唯一拥有者，该页框被释放到伙伴系统。</p>
<h3 id="换入页"><a href="#换入页" class="headerlink" title="换入页"></a>换入页</h3><p>当进程试图对一个已被换出到磁盘的页进行寻址时，必然会发生页的换入。</p>
<p>在以下条件发生时，缺页异常处理程序就会触发一个换入操作:<br>(1). 引起异常的地址所在的页是一个有效的页，也就是说，它属于当前进程的一个线性区。<br>(2). 页不在内存中，也就是说，页表项中的<code>Present</code>标志被清除。<br>(3). 与页有关的页表项不为空，但是<code>Dirty</code>位清<code>0</code>，这意味着页表项包含一个换出页标识符。如果上面的所有条件满足，则<code>handle_pte_fault()</code>调用相对简易的<code>do_swap_page()</code>函数换入所需页。</p>
<h3 id="do-swap-page-函数"><a href="#do-swap-page-函数" class="headerlink" title="do_swap_page()函数"></a>do_swap_page()函数</h3><p><code>do_swap_page()</code>函数作用于如下参数：</p>
<ul>
<li><code>mm</code>，引起缺页异常的进程的内存描述符地址</li>
<li><code>vma</code>，<code>address</code>所在的线性区描述符地址</li>
<li><code>address</code>，引起异常的线性地址</li>
<li><code>page_table</code>，映射<code>address</code>的页表项的地址</li>
<li><code>Pmd</code>，映射<code>address</code>的页中间目录的地址</li>
<li><code>orig_pte</code>，映射<code>address</code>的页表项的内容</li>
<li><code>write_access</code>，一个标志，表示试图执行的访问是读操作还是写操作</li>
</ul>
<p>与其他函数相反，<code>do_swap_page()</code>从不返回<code>0</code>。如果页已经在交换高速缓存中就返回<code>1</code> (次错误)，如果页已经从交换区读入就返回<code>2</code>(主错误)，如果在进行换入时发生错误就返回<code>-1</code>。</p>
<p>该函数本质上执行下列步骤：</p>
<blockquote>
<ol>
<li>从<code>orig_pte</code>获得换出页标识符。</li>
<li>调用<code>pte_unmap()</code>释放任何页表的临时内核映射，该页表由<code>handle_mm_fault()</code>函数建立。访问高端内存页表需要进行内核映射。</li>
<li>释放内存描述符的<code>page_table_lock</code>自旋锁(它是由调用者函数<code>handle_pte_fault()</code>获取的)。</li>
<li>调用<code>lookup_swap_cache()</code>检查交换高速缓存是否已经含有换出页标识符对应的页；如果页已经在交换高速缓存中，就跳到第<code>6</code>步。</li>
<li>调用<code>swapin_readahead()</code>函数从交换区读取至多有<code>2n</code>个页的一组页，其中包括所请求的页。值<code>n</code>存放在<code>page_cluster</code>变量中，通常等于<code>3</code>。其中的每个页是通过调用<code>read_swap_cache_async()</code>函数读入的。</li>
<li>再一次调用<code>read_swap_cache_async()</code>换入由引起缺页异常的进程所访问的那一页。这一步可能看起来有点多余，但其实不然。<code>swapin_readahead()</code>函数可能在读取请求的页时失败——例如，因为<code>page_cluster</code>被置为<code>0</code>，或者该函数试图读取一组含有空闲或有缺陷页槽(<code>SWAP_MAP_BAD</code>)的页。另一方面，如果<code>swapin_readahead()</code>成功，这次对<code>read_swap_cache_async()</code>的调用就很快结束，因为它在交换高速缓存找到了页。</li>
<li>尽管如此，如果请求的页还是没有被加到交换高速缓存，那么，另一个内核控制路径可能已经代表这个进程的一个子进程换入了所请求的页。这种情况的检查可以通过临时获取<code>page_table_lock</code>自旋锁，并把<code>page_table</code>所指向的表项与<code>orig_pte</code>进行比较来实现。如果二者有差异，则说明这一页已经被某个其他的内核控制路径换入，因此，函数返回<code>1</code>(次错误);否则，返回<code>-1</code>(失败)。</li>
<li>函数执行到此，我们知道页已经在高速缓存中。如果页已被换入(主错误),函数就调用<code>grab_swap_token()</code>试图获得一个交换标记。</li>
<li>调用<code>mark_page_accessed()</code>并对页加锁。</li>
<li>获取<code>page_table_lock</code>自旋锁。</li>
<li>检查另一个内核控制路径是否代表这个进程的一个子进程换入了所请求的页。如果是，就释放<code>page_table_lock</code>自旋锁，打开页上的锁，并返回<code>1</code>(次错误)。</li>
<li>调用<code>swap_free()</code>减少<code>entry</code>对应的页槽的引用计数器。</li>
<li>检查交换高速缓存是否至少占满<code>50%</code>(<code>nr_swap_pages</code>小于<code>total_swap_pages</code>的一半)。如果是，则检查页是否仅被引起异常的进程(或其一个子进程)拥有；如果是这样，则从交换高速缓存中删去这一页。</li>
<li>增加进程的内存描述符的<code>rss</code>字段。</li>
<li>更新页表项以便进程能找到这一页。这一操作的实现是通过把所请求页的物理地址和在线性区的<code>vm_page_prot</code>字段所找到的保护位写入<code>page_table</code>所指向的页表项中来达到的。此外，如果引起缺页的访问是一个写访问，且造成缺页的进程是页的唯一拥有者，那么，函数还要设置<code>Dirty</code>和<code>Read/Write</code>标志以防止无用的写时复制错误。</li>
<li>打开页上的锁。</li>
<li>调用<code>page_add_anon_rmap()</code>把匿名页插入面向对象的反向映射数据结构。</li>
<li>如果<code>write_access</code>参数等于<code>1</code>，则函数调用<code>do_wp_page()</code>复制一份页框。</li>
<li>释放<code>mm-&gt;page_table_lock</code>自旋锁，并返回<code>1</code>(次错误)或<code>2</code>(主错误)。</li>
</ol>
</blockquote>
<h3 id="read-swap-cache-async-函数"><a href="#read-swap-cache-async-函数" class="headerlink" title="read_swap_cache_async()函数"></a>read_swap_cache_async()函数</h3><p>只要内核必须换入一个页，就调用<code>read_swap_cache_async()</code>函数，它接收的参数为：</p>
<ul>
<li><code>entry</code>，换出页标识符</li>
<li><code>vma</code>，指向该页所在线性区的指针</li>
<li><code>addr</code>，页的线性地址</li>
</ul>
<p>我们知道，在访问交换分区之前，该函数必须检查交换高速缓存是否已经包含了所要的页框。因此，该函数本质上执行下列操作：</p>
<ol>
<li>调用<code>radix_tree_lookup()</code>，搜索<code>swapper_space</code>对象的基树，寻找由换出页标识符<code>entry</code>给出位置的页框。如果找到该页，递增它的引用计数器，返回它的描述符地址。</li>
<li>页不在交换高速缓存。调用<code>alloc_page()</code>分配一个新的页框。如果没有空闲的页框可用，则返回<code>0</code>(表示系统没有足够的内存)。</li>
<li>调用<code>add_to_swap_cache()</code>把新页框的页描述符插入交换高速缓存。这个函数也对页加锁。</li>
<li>如果<code>add_to_swap_cache()</code>在交换高速缓存找到页的一个副本，则前一步可能失败。例如，进程可能在第<code>2</code>步阻塞，因此允许另一个进程在同一个页槽上开始换入操作。在这种情况下，该函数释放在第<code>2</code>步分配的页框，并从第<code>1</code>步重新开始。</li>
<li>调用<code>lru_cache_add_active()</code>把页插入<code>LRU</code>的活动链表。</li>
<li>新页框的页描述符现已在交换高速缓存。调用<code>swap_readpage()</code>从交换区读入该页数据。这个函数与前面“换出页”一节所描述的<code>swap_writepage()</code>函数很相似，它将页描述符的<code>PG_uptodate</code>标志清<code>0</code>，调用<code>get_swap_bio()</code>为<code>I/O</code>传输分配与初始化一个<code>bio</code>描述符，再调用’<code>submit_bio()</code>向块设备子系统层发出<code>I/O</code>请求。</li>
<li>返回页描述符的地址。</li>
</ol>
<h1 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h1><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>​    管道(<code>pipe</code>)是所有<code>Unix</code>都愿意提供的一种<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=进程间通信&amp;spm=1001.2101.3001.7020">进程间通信</a>机制。管道是进程之间的一个单向数据流：一个进程写入管道的所有数据都由内核定向到另一个进程，另一个进程由此就可以从管道中读取数据。在<code>Unix</code>的命令<code>shell</code>中，可以使用<code>“1”</code>操作符来创建管道。例如，下面的语句通知<code>shell</code> 创建两个进程，并使用一个管道把这两个进程连接在一起：<code>$ ls | more</code></p>
<p>第一个进程(执行<code>ls</code>程序)的标准输出被重定向到管道中；第二个进程(执行<code>more</code>程序)从这个管道中读取输入。注意，执行下面这两条命令也可以得到相同的结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">ls</span> <span class="token operator">></span> temp
$ <span class="token function">more</span> <span class="token operator">&lt;</span> temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个命令把<code>ls</code>的输出重定向到一个普通文件中；接下来，第二个命令强制<code>more</code>从这个普通文件中读取输入。</p>
<p>当然，通常使用管道比使用临时文件更方便，这是因为：</p>
<ul>
<li><code>shell</code>语句比较短，也比较简单。</li>
<li>没有必要创建将来还必须删除的临时普通文件。</li>
</ul>
<h3 id="使用管道"><a href="#使用管道" class="headerlink" title="使用管道"></a>使用管道</h3><p>管道被看作是打开的文件，但在已安装的文件系统中没有相应的映像。可以使用<code>pipe()</code>系统调用来创建一个新管道，这个系统调用返回一对文件描述符；然后进程通过<code>fork()</code>把这两个描述符传递给它的子进程，由此与子进程共享管道。进程可以在<code>read()</code>系统调用中使用第一个文件描述符从管道中读取数据，同样也可以在<code>write()</code>系统调用中使用第二个文件描述符向管道中写入数据。</p>
<p><code>POSIX</code>只定义了半双工的管道，因此即使<code>pipe()</code>系统调用返回了两个描述符，每个进程在使用一个文件描述符之前仍得把另外一个文件描述符关闭。</p>
<p>如果所需要的是双向数据流，那么进程必须通过两次调用<code>pipe()</code>来使用两个不同的管道。有些<code>Unix</code>系统，例如<code>System VReleas 4</code>，实现了全双工的管道。在全双工管道中，允许两个文件描述符既可以被写入也可以被读取，这就有两个双向信息通道。</p>
<p><code>Linux</code>采用了另外一种解决方法；每个管道的文件描述符仍然都是单向的，但是在使用一个描述符之前不必把另外一个描述符关闭。让我们回顾一下前面的那个例子。当<code>shell</code>命令对<code>ls I more</code>语句进行解释时，实际上要执行以下操作：</p>
<p><code>shell</code>进程：</p>
<ul>
<li>调用<code>pipe()</code>系统调用；让我们假设<code>pipe()</code>返回文件描述符<code>3</code>(管道的读通道)和<code>4</code>(管道的写通道)。</li>
<li>两次调用<code>fork()</code>系统调用。</li>
<li>两次调用<code>close()</code>系统调用来释放文件描述符<code>3</code>和<code>4</code>。</li>
</ul>
<p>第一个子进程必须执行<code>ls</code>程序，它执行以下操作：</p>
<ol>
<li>调用<code>dup2(4,1)</code>把文件描述符<code>4</code>拷贝到文件描述符<code>1</code>。从现在开始，文件描述符<code>1</code>就代表该管道的写通道。</li>
<li>两次调用<code>close()</code>系统调用来释放文件描述符<code>3</code>和<code>4</code>。</li>
<li>调用<code>execve()</code>系统调用来执行<code>ls</code>程序。缺省情况下，这个程序要把自己的输出写到文件描述符为<code>1</code>的那个文件(标准输出)中，也就是说，写入管道中。</li>
</ol>
<p>第二个子进程必须执行<code>more</code>程序；因此，该进程执行以下操作：</p>
<ol>
<li>调用<code>dup2(3,0)</code>把文件描述符<code>3</code>拷贝到文件描述符<code>0</code>。从现在开始，文件描述符<code>0</code>就代表管道的读通道。</li>
<li>两次调用<code>close()</code>系统调用来释放文件描述符<code>3</code>和<code>4</code>。</li>
<li>调用<code>execve()</code>系统调用来执行<code>more</code>程序。缺省情况下，这个程序要从文件描述符为<code>0</code>的那个文件(标准输入)中读取输入，也就是说，从管道中读取输入。</li>
</ol>
<p>在这个简单的例子中，管道完全被两个进程使用。但是，由于管道的这种实现方式，二个管道可以供任意个进程使用。显然，如果两个或者更多个进程对同一个管道进行读写，</p>
<p>那么这些进程必须使用文件加锁机制或者<code>IPC</code>信号量机制，对自己的访问进行显式的同步。除了<code>pipe()</code>系统调用之外，很多<code>Unix</code>系统都提供了两个名为<code>popen()</code>和<code>pclose()</code>的封装函数来处理在使用管道的过程中产生的所有脏工作。只要使用<code>popen()</code>函数创建二个管道，就可以使用包含在<code>C</code>函数座中的高级<code>IO</code>函数(<code>fprintf(),fscanf()</code>等等)对这个管道进行操作。在<code>Linux</code>中，<code>popen()</code>和<code>pclose()</code>都包含在<code>C</code>函数库中。<code>popen()</code>函数接收两个参数：可执行文件的路径名<code>filename</code>和定义数据传输方向的字符串<code>type</code>。该函数返回一个指向<code>FILE</code>数据结构的指针。</p>
<p><code>popen()</code>函数实际上执行以下操作：</p>
<ol>
<li><p>使用<code>pipe()</code>系统调用创建一个新管道。</p>
</li>
<li><p>创建一个新进程，该进程又执行以下操作：</p>
<blockquote>
<ol>
<li>如果<code>type</code>是<code>r</code>，就把与管道的写通道相关的文件描述符拷贝到文件描述符<code>1</code>(标准输出)；如果<code>type</code>是<code>w</code>，就把与管道的读通道相关的文件描述符拷贝到文件描述符<code>0</code>(标准输入)。</li>
<li>关闭<code>pipe()</code>返回的文件描述符。</li>
<li>调用<code>execve()</code>系统调用执行<code>filename</code>所指定的程序。</li>
</ol>
</blockquote>
</li>
<li><p>如果<code>type</code>是<code>r</code>，就关闭与管道的写通道相关的文件描述符；如果<code>type</code>是<code>w</code>，就关闭与管道的读通道相关的文件描述符。</p>
</li>
<li><p>返回<code>FILE</code>文件指针所指向的地址，这个指针指向仍然打开的管道所涉及的任一文件描述符。在<code>popen()</code>函数被调用之后，父进程和子进程就可以通过管道交换信息：</p>
</li>
</ol>
<p><code>1，2，3，4</code>说的是父进程。<br><code>1, 2, 3</code>说的是子进程。</p>
<p>父进程可以使用该函数所返回的<code>FILE</code>指针来读(如果<code>type</code>是<code>r</code>)写(如果<code>type</code>是<code>w</code>)数据。子进程所执行的程序分别把数据写入标准输出或从标准输入中读取数据。<code>pclose()</code>函数接收<code>popen()</code>所返回的文件指针作为参数，它会简单地调用<code>wait4()</code>系统调用并等待<code>popen()</code>所创建的进程结束。</p>
<h3 id="管道数据结构"><a href="#管道数据结构" class="headerlink" title="管道数据结构"></a>管道数据结构</h3><p>我们现在又一次在系统调用的层次考虑问题。只要管道一被创建，进程就可以使用<code>read()</code>和<code>write()</code>这两个<code>VFS</code>系统调用来访问管道。因此，对于每个管道来说，内核都要创建一个索引节点对象和两个文件对象，一个文件对象用于读，另外一个对象用于写。</p>
<p>当进程希望从管道中读取数据或向管道中写入数据时，必须使用适当的文件描述符。当索引节点指的是管道时，其<code>i_pipe</code>字段指向一个如表<code>19-1</code>所示的<code>pipe_inode_info</code> 结构。<br><img src=".\image-20240503162029666.png" alt="image-20240503162029666"></p>
<p>除了一个索引节点对象和两个文件对象之外，每个管道都还有自己的管道缓冲区(<code>pipe buffer</code>)。实际上，它是一个单独的页，其中包含了已经写入管道等待读出的数据。</p>
<p>在<code>Linux 2.6.10</code>以前，每个管道一个管道缓冲区。而<code>2.6.11</code>内核中，管道(与<code>FIFO</code>)的数据缓冲区已有很大改变，每个管道可以使用<code>16</code>个管道缓冲区。这个改变大大增强了向管道写大量数据的用户态应用的性能。</p>
<p><code>pipe_inode_info</code>数据结构的<code>bufs</code>字段存放一个具有<code>16</code>个<code>pipe_buffer</code>对象的数组，每个对象代表一个管道缓冲区。该对象的字段如表<code>19-2</code>所示。<br><img src=".\image-20240503162042119.png" alt="image-20240503162042119"><br><code>ops</code>字段指向管道缓冲区方法表<code>anon_pipe_buf_ops</code>，它是一个类型为<code>pipe_buf_operations</code> 的数据结构。实际上，它有三个方法：<br>(1). <code>map</code><br>在访问缓冲区数据之前调用。它只在管道缓冲区在高端内存时对管道缓冲区页框调用<code>kmap()</code>。<br>(2). <code>unmap</code><br>不再访问缓冲区数据时调用。它对管道缓冲区页框调用<code>kunmap()</code>。<br>(3). <code>release</code><br>当释放管道缓冲区时调用。<br>该方法实现了一个单页内存高速缓存：释放的不是存放缓冲区的那个页框，而是由<code>pipe_inode_info</code>数据结构(如果不是<code>NULL</code>)的<code>tmp_page</code>字段指向的高速缓存页框。<br>存放缓冲区的页框变成新的高速缓存页框。</p>
<p><code>16</code>个缓冲区可以被看作一个整体环形缓冲区：写进程不断向这个大缓冲区追加数据，而读进程则不断移出数据。</p>
<p>所有管道缓冲区中当前写入而等待读出的字节数就是所谓的管道大小。为提高效率，仍然要读的数据可以分散在几个未填充满的管道缓冲区内：事实上，在上一个管道缓冲区没有足够空间存放新数据时，每个写操作都可能会把数据拷贝到一个新的空管道缓冲区。因此，内核必须记录：<br>(1). 下一个待读字节所在的管道缓冲区、页框中的对应偏移量。该管道缓冲区的索引存放在<code>pipe_inode_info</code>数据结构的<code>curbuf</code>字段，而偏移量在相应<code>pipe_buffer</code>对象的<code>offset</code>字段。<br>(2). 第一个空管道缓冲区。它可以通过增加当前管道缓冲区的索引得到(模为<code>16</code>)，并存放在<code>pipe_inode_info</code>数据结构的<code>curbuf</code>字段，而存放有效数据的管道缓冲区号存放在<code>nrbufs</code>字段。为了避免对管道数据结构的竟争条件，内核使用包含在索引节点对象中的<code>i_sem</code>信号量。</p>
<h3 id="pipefs特殊文件系统"><a href="#pipefs特殊文件系统" class="headerlink" title="pipefs特殊文件系统"></a>pipefs特殊文件系统</h3><p>管道是作为一组<code>VFS</code>对象来实现的，因此没有对应的磁盘映象。在<code>Linux 2.6</code>中，把这些<code>VFS</code>对象组织为<code>pipefs</code>特殊文件系统以加速它们的处理。因为这种文件系统在系统目录树中没有安装点，因此用户根本看不到它。</p>
<p>但是，有了<code>pipefs</code>，管道完全被整合到<code>VFS</code>层，内核就可以以命名管道或<code>FIFO</code>的方式处理它们，<code>FIFO</code>是以终端用户认可的文件而存在的。<code>init_pipe_fs()</code>函数(一般是在内核初始化期间执行)注册<code>pipefs</code>文件系统并安装它:</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> pipe_fs_type<span class="token punctuation">;</span>
pipe_fs_type<span class="token punctuation">.</span>name <span class="token operator">=</span><span class="token string">"pipefs"</span><span class="token punctuation">;</span>
pipe_fs_type<span class="token punctuation">.</span>get_sb <span class="token operator">=</span> pipefs_get_sb<span class="token punctuation">;</span>
pipe_fs<span class="token punctuation">.</span>kill_sb <span class="token operator">=</span> kill_anon_super<span class="token punctuation">;</span>
<span class="token function">register_filesystem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pipe_fs_type<span class="token punctuation">)</span><span class="token punctuation">;</span>
pipe_mnt <span class="token operator">=</span> <span class="token function">do_kern_mount</span><span class="token punctuation">(</span><span class="token string">"pipefs"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"pipefs"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>表示<code>pipefs</code>根目录的已安装文件系统对象存放在<code>pipe_mnt</code>变量中。</p>
<h3 id="创建和撤消管道"><a href="#创建和撤消管道" class="headerlink" title="创建和撤消管道"></a>创建和撤消管道</h3><p><code>pipe()</code>系统调用由<code>sys_pipe()</code>函数处理，后者又会调用<code>do_ pipe()</code>函数。为了创建一个新的管道，<code>do_ pipe()</code>函数执行以下操作：</p>
<ol>
<li><p>调用<code>get_pipe_inode()</code>函数，该函数为<code>pipefs</code>文件系统中的管道分配一个索引节点对象并对其进行初始化。具体来说，该函数执行下列操作：</p>
<blockquote>
<ol>
<li>在<code>pipefs</code>文件系统中分配一个新的索引节点。</li>
<li>分配<code>pipe_inode_info</code>数据结构，并把它的地址存放在索引节点的<code>i_pipe</code>字段。</li>
<li>设置<code>pipe_inode_info</code>的<code>curbuf</code>和<code>nrbufs</code>字段为<code>0</code>，并将<code>bufs</code>数组中的管道缓冲区对象的所有字段都清<code>0</code>。</li>
<li>把<code>pipe_inode_info</code>结构的<code>r_counter</code>和<code>w_counter</code>字段初始化为<code>1</code>。</li>
<li>把<code>pipe_inode_info</code>结构的<code>readers</code>和<code>writers</code>字段初始化为<code>1</code>。</li>
</ol>
</blockquote>
</li>
<li><p>为管道的读通道分配一个文件对象和一个文件描述符，并把这个文件对象的f_flag字段设置成O_RDONLY，把f_op字段初始化成read pipe_fops表的地址。</p>
</li>
<li><p>为管道的写通道分配一个文件对象和一个文件描述符，并把这个文件对象的<code>flag</code>字段设置成<code>O_WRONLY</code>，把<code>f_op</code>字段初始化成<code>write_pipe_fops</code>表的地址。</p>
</li>
<li><p>分配一个目录项对象，并使用它把两个文件对象和索引节点对象连接在一起;然后，把新的索引节点插入<code>pipefs</code>特殊文件系统中。</p>
</li>
<li><p>把两个文件描述符返回给用户态进程。发出一个<code>pipe()</code>系统调用的进程是最初唯一一个可以读写访问新管道的进程。为了表示该管道实际上既有一个读进程，又有一个写进程，就要把<code>pipe_inode_info</code>数据结构的<code>readers</code>和<code>writers</code>字段都初始化成<code>1</code>。通常，只要相应管道的文件对象仍然由某个进程打开，这两个字段中的每个字段就应该都被设置成<code>1</code>;如果相应的文件对象已经被释放，那么这个字段就被设置成<code>0</code>，因为不会再有任何进程访问这个管道。创建一个新进程并不增加<code>readers</code>和<code>writers</code>字段的值，因此这两个值从不超过<code>1</code>。但是，父进程仍然使用的所有文件对象的引用计数器的值都会增加。因此，即使父进程死亡时这个对象都不会被释放，管道仍会一直打开供子进程使用。只要进程对与管道相关的一个文件描述符调用<code>close()</code>系统调用，内核就对相应的文件对象执行<code>fput()</code>函数，这会减少它的引用计数器的值。如果这个计数器变成<code>0</code>，那么该函数就调用这个文件操作的<code>release</code>方法。</p>
</li>
</ol>
<p>根据文件是与读通道还是与写通道关联，<code>release</code>方法或者由<code>pipe_read_release()</code>或者由<code>pipe_write_release()</code>函数来实现。这两个函数都调用<code>pipe_release()</code>，后者把<code>pipe_inode_info</code>结构的<code>readers</code>字段或<code>writers</code>字段设置成<code>0</code>。</p>
<p><code>pipe_release()</code>还要检查<code>readers</code>和<code>writers</code>是否都等于<code>0</code>。如果是，就调用所有管道缓冲区的<code>release</code> 方法，向伙伴系统(<code>buddy system</code>)释放所有管道缓冲区页框；此外，函数还释放由<code>tmp_page</code>字段指向的高速缓存页框。否则，<code>readers</code>或者<code>writers</code>字段不为<code>0</code>，函数唤醒在管道的等待队列上睡眠的任一进程，以使它们可以识别管道状态的变化。</p>
<h3 id="从管道中读取数据"><a href="#从管道中读取数据" class="headerlink" title="从管道中读取数据"></a>从管道中读取数据</h3><p>希望从管道中读取数据的进程发出一个<code>read()</code>系统调用，为管道的读端指定一个文件描述符。内核最终调用与这个文件描述符相关的文件操作表中所找到的<code>read</code>方法。在管道的情况下，<code>read</code> 方法在<code>read_pipe_fops</code>表中的表项指向<code>pipe_read()</code>函数。<code>pipe_read()</code>相当复杂，因为<code>POSIX</code>标准定义了管道的读操作的一些要求。表<code>19-3</code>概述了所期望的<code>read()</code>系统调用的行为，该系统调用从一个管道大小(管道缓冲区中待读的字节数)为<code>p</code>的管道中读取<code>n</code>个字节。<br>这个系统调用可能以两种方式阻塞当前进程：</p>
<ul>
<li>当系统调用开始时管道缓冲区为空。</li>
<li>管道缓冲区没有包含所有请求的字节，写进程在等待缓冲区的空间时曾被置为睡眠。</li>
</ul>
<p>注意，读操作可以是非阻塞的。在这种情况下，只要所有可用的字节(即使是<code>0</code>个)一被拷贝到用户地址空间中，读操作就完成。还要注意，只有在管道为空而且当前没有进程正在使用与管道的写通道相关的文件对象时，<code>read()</code>系统调用才会返回<code>0</code>。</p>
<p><code>pipe_read()</code>函数执行以下操作：</p>
<ol>
<li><p>获取索引节点的<code>i_sem</code>信号量。</p>
</li>
<li><p>确定存放在<code>pipe_inode_info</code>结构<code>nrbufs</code>字段中的管道大小是否为<code>0</code>。如果是，说明所有管道缓冲区为空。这时还要确定函数必须返回还是进程在等待时必须被阻塞，直到其他进程向管道中写入一些数据。<code>I/O</code>操作的类型(阻塞或非阻塞)是通过文件对象的<code>f_flags</code>字段中的<code>O_NONBLOCK</code>标志来表示的。如果当前进程必须被阻塞，则函数执行下列操作：</p>
<blockquote>
<ol>
<li>调用<code>prepare_to_wait()</code>把<code>current</code>加到管道的等待队列(<code>pipe_inode_info</code>结构的<code>wait</code>字段)。</li>
<li>释放索引节点的信号量。</li>
<li>调用<code>schedule()</code>。</li>
<li>一旦<code>current</code>被唤醒，就调用<code>finish_wait()</code>把它从等待队列中删除，再次获取<code>i_sem</code>索引节点信号量，然后跳回第<code>2</code>步。</li>
</ol>
</blockquote>
</li>
<li><p>从<code>pipe_inode_info</code>数据结构的<code>curbuf</code>字段得到当前管道缓冲区索引。</p>
</li>
<li><p>执行管道缓冲区的<code>map</code>方法。</p>
</li>
<li><p>从管道缓冲区拷贝请求的字节数(如果较小，就是管道缓冲区可用字节数)到用户地址空间。</p>
</li>
<li><p>执行管道缓冲区的<code>unmap</code>方法。</p>
</li>
<li><p>更新相应<code>pipe_buffer</code>对象的<code>offset</code>和<code>len</code>字段。</p>
</li>
<li><p>如果管道缓冲区已空(<code>pipe_buffer</code>对象的<code>len</code>字段现在等于<code>0</code>)，则调用管道缓冲区的<code>release</code>方法释放对应的页框，把<code>pipe_buffer</code>对象的<code>ops</code>字段置为<code>NULL</code>，增加在<code>pipe_inode_info</code>数据结构的<code>curbuf</code>字段中存放的当前管道缓冲区索引，并减小<code>nrbufs</code>字段中非空管道缓冲区计数器的值。</p>
</li>
<li><p>如果所有请求字节拷贝完毕，则跳至第<code>12</code>步。</p>
</li>
<li><p>目前，还没有把所有请求字节拷贝到用户态地址空间。如果管道大小大于<code>0</code>(<code>pipe_inode_info</code>的<code>nrbufs</code>字段不是<code>NULL</code>)，则跳到第<code>3</code>步。</p>
</li>
<li><p>管道缓冲区内已没有剩余字节。如果至少有一个写进程正在睡眠(即<code>pipe_inode_info</code>数据结构的<code>waiting_writers</code>字段大于<code>0</code>)，且读操作是阻塞的，那么调用<code>wake_up_interruptible_sync()</code>唤醒在管道等待队列中所有睡眠的进程，然后跳至第<code>2</code>步。</p>
</li>
<li><p>释放索引节点的<code>i_sem</code>信号量。</p>
</li>
<li><p>调用<code>wake_up_interruptible_sync()</code>函数唤醒在管道的等待队列中所有睡眠的写者进程。</p>
</li>
<li><p>返回拷贝到用户地址空间的字节数。</p>
</li>
</ol>
<h3 id="向管道中写入数据"><a href="#向管道中写入数据" class="headerlink" title="向管道中写入数据"></a>向管道中写入数据</h3><p>希望向管道中写入数据的进程发出一个<code>write()</code>系统调用，为管道的写端指定一个文件描述符。内核通过调用适当文件对象的<code>write</code>方法来满足这个请求；<code>write_pipe_fops</code> 表中相应的项指向<code>pipe_write()</code>函数。</p>
<p>表<code>19-4</code>概述了由<code>POSIX</code>标准所定义的<code>write()</code>系统调用的行为，该系统调用请求把<code>n</code> 个字节写入一个管道中，而该管道在它的缓冲区中有<code>u</code>个未用的字节。</p>
<p>具体地说，该标准要求涉及少量字节数的写操作必须原子地执行。更确切地说，如果两个或者多个进程并发地在写入一个管道，那么任何少于<code>4096</code>个字节(管道缓冲区的大小)的写操作都必须单独完成，而不能与唯一进程对同一个管道的写操作交叉进行。但是，超过<code>4096</code>个字节的写操作是可分割的，也可以强制调用进程睡眠。<br><img src=".\image-20240503162210182.png" alt="image-20240503162210182"><br>还有，如果管道没有读进程(也就是说，如果管道的索引节点对象的<code>readers</code>字段的值是<code>0</code>)，那么任何对管道执行的写操作都会失败。在这种情况下，内核会向写进程发送一个<code>SIGPIPE</code>信号，并停止<code>write()</code>系统调用，使其返回一个<code>-EPIPE</code>错误码，这个错误码就表示我们熟悉的“<code>Broken pipe</code>(损坏的管道)”消息。</p>
<p><code>pipe_write()</code>函数执行以下操作：</p>
<ol>
<li><p>获取索引节点的<code>i_sem</code>信号量。</p>
</li>
<li><p>检查管道是否至少有一个读进程。如果不是，就向当前进程发送一个<code>SIGPIPE</code>信号，释放索引节点信号量并返回<code>-EPIPE</code>值。</p>
</li>
<li><p>将<code>pipe_inode_info</code>数据结构<code>curbuf</code>和<code>nrbufs</code>字段相加并减一得到最后写入的管道缓冲区索引。如果该管道缓冲区有足够空间存放待写字节，就拷入这些数据：</p>
<blockquote>
<ol>
<li>执行管道缓冲区的<code>map</code>方法。</li>
<li>把所有字节拷贝到管道缓冲区。</li>
<li>执行管道缓冲区的<code>unmap</code>方法。</li>
<li>更新相应<code>pipe_buffer</code>对象的<code>len</code>字段。</li>
<li>跳至第<code>11</code>步。</li>
</ol>
</blockquote>
</li>
<li><p>如果<code>pipe_inode_info</code>数据结构的<code>nrbufs</code>字段等于<code>16</code>，就表明没有空闲管道缓冲区来存放待写字节。这种情况下：</p>
<blockquote>
<ul>
<li>如果写操作是非阻塞的，跳至第<code>11</code>步，结束并返回错误码<code>-EAGAIN</code></li>
<li>如果写操作是阻塞的，将<code>pipe_inode_info</code>结构的<code>waiting_writers</code>字段加<code>1</code>，调用<code>prepare_to_wait()</code>将当前操作加入管道等待队列(<code>pipe_inode_info</code>结构的<code>wait</code>字段)，释放索引节点信号量，调用<code>schedule()</code>。一旦唤醒，则调用<code>finish_wait()</code>从等待队列中移出当前操作，重新获得索引节点信号量，递减<code>waiting_writers</code>字段，然后跳回第<code>4</code>步。</li>
</ul>
</blockquote>
</li>
<li><p>现在至少有一个空缓冲区，将<code>pipe_inode_info</code>数据结构的<code>curbuf</code>和<code>nrbufs</code>字段相加得到第一个空管道缓冲区索引。</p>
</li>
<li><p>除非<code>pipe_inode_info</code>数据结构的<code>tmp_page</code>字段不是<code>NULL</code>，否则从伙伴系统中分配一个新页框。</p>
</li>
<li><p>从用户态地址空间拷贝多达<code>4096</code>个字节到页框(如果必要，在内核态线性地址空间作临时映射)。</p>
</li>
<li><p>更新与管道缓冲区关联的<code>pipe_buffer</code>对象的字段：将<code>page</code>字段设为页框描述符的地址，<code>ops</code>字段设为<code>anon_pipe_buf_ops</code>表的地址，<code>offset</code>字段设为<code>0</code>，<code>len</code>字段设为写入的字节数。</p>
</li>
<li><p>增加非空管道缓冲区计数器的值，该缓冲区计数器存放在<code>pipe_inode_inf</code>结构的<code>nrbufs</code>字段。</p>
</li>
<li><p>如果所有请求的字节还没有写完，则跳至第<code>4</code>步。</p>
</li>
<li><p>释放索引节点信号量。</p>
</li>
<li><p>唤醒在管道等待队列上睡眠的所有读进程。</p>
</li>
<li><p>返回写入管道缓冲区的字节数(如果无法写入，则返回错误码)。</p>
</li>
</ol>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>虽然管道是一种十分简单、灵活、有效的通信机制，但它们有一个主要的缺点，也就是无法打开已经存在的管道。这就使得任意的两个进程不可能共享同一个管道，除非管道由一个共同的祖先进程创建。这个缺点在很多应用程序中都存在。</p>
<p>服务器和给定客户端之间的每次交互都可以使用一个管道进行处理。但是，当用户显式查询数据库时，通常由shell命令根据需要创建客户端进程；因此，服务器进程和客户端进程就不能方便地共享管道。</p>
<p>为了突破这种限制，<code>Unix</code>系统引入了一种称为命名管道(<code>named pipe</code>)或者<code>FIFO</code>[<code>FIFO</code> 代表“先进先出(<code>first in,first out</code>)”；最先写入文件的字节总是被最先读出]的特殊文件类型。</p>
<p><code>FIFO</code>在这几个方面都非常类似于管道：在文件系统中不拥有磁盘块，打开的<code>FIFO</code> 总是与一个内核缓冲区相关联，这一缓冲区中临时存放两个或多个进程之间交换的数据。然而，有了磁盘索引节点，使得任何进程都可以访问<code>FIFO</code>，因为<code>FIFO</code>文件名包含在系统的目录树中。</p>
<p>因此，在前面那个数据库的例子中，服务器和客户端之间的通信可以很容易地使用<code>FIFO</code>而不是管道。服务器在启动时创建一个<code>FIFO</code>，由客户端程序用来发出自己的请求。每个客户端程序在建立连接之前都另外创建一个<code>FIFO</code>，并在自己对服务器发出的最初请求中包含这个<code>FIFO</code>的名字，服务器程序就可以把查询结果写入这个<code>FIFO</code>。在<code>Linux 2.6</code>中，<code>FIFO</code>和管道几乎是相同的，并使用相同的<code>pipe_inode_info</code>结构。</p>
<p>事实上，<code>FIFO</code>的<code>read</code>和<code>write</code>操作就是由前面“从管道中读取数据”和“向管道中写入数据”这两节描述的<code>pipe_read()</code>和<code>pipe_write()</code>函数实现的。事实上，只有两点主要的差别：</p>
<ul>
<li><code>FIFO</code>索引节点出现在系统目录树上而不是<code>pipefs</code>特殊文件系统中。</li>
<li><code>FIFO</code>是一种双向通信管道；</li>
</ul>
<p>也就是说，可能以读/写模式打开一个<code>FIFO</code>。因此，为了完成我们的描述，我们仅说明如何创建和打开<code>FIFO</code>。</p>
<h3 id="创建并打开FIFO"><a href="#创建并打开FIFO" class="headerlink" title="创建并打开FIFO"></a>创建并打开FIFO</h3><p>进程通过执行<code>mknod()</code>系统调用创建一个<code>FIFO</code>，传递的参数是新<code>FIFO</code>的路径名以及<code>S_IFIFO</code>(<code>0x10000</code>)与这个新文件的权限位掩码进行逻辑或的结果。<code>POSIX</code>引入了一个名为<code>mkfifo()</code>的系统调用专门用来创建<code>FIFO</code>。这个系统调用在<code>Linux</code>以及<code>System VRelease 4</code>中是作为调用<code>mknod()</code>的<code>C</code>库函数实现的。</p>
<p><code>FIFO</code>一旦被创建，就可以使用普通的<code>open()、read()、write()</code>和<code>close()</code>系统调用访问<code>FIFO</code>，但是<code>VFS</code>对<code>FIFO</code>的处理方法比较特殊，因为<code>FIFO</code>的索引节点及文件操作都是专用的，并且不依赖于<code>FIFO</code>所在的文件系统。<code>POSIX</code>标准定义了<code>open()</code>系统调用对<code>FIFO</code>的操作；这种操作本质上与所请求的访问类型、<code>I/O</code>操作的种类(阻塞或非阻塞)以及其他正在访问<code>FIFO</code>的进程的存在状况有关。</p>
<p>进程可以为读操作、写操作或者读写操作打开一个<code>FIFO</code>。根据这三种情况，把与相应的文件对象相关的文件操作设置成特定的方法。</p>
<p>当进程打开一个<code>FIFO</code>时，<code>VFS</code>就执行一些与设备文件所执行的操作相同的操作。与打开的<code>FIFO</code>相关的索引节点对象是由依赖于文件系统的<code>read_inode</code>超级块方法进行初始化的。</p>
<p>这个方法总要检查磁盘上的索引节点是否表示一个特殊文件，并在必要时调用<code>init_special_inode()</code>函数。这个函数又把索引节点对象的<code>i_fop</code>字段设置为<code>def_fifo_fops</code>表的地址。</p>
<p>随后，内核把文件对象的文件操作表设置为<code>def_fifo_fops</code>，并执行它的<code>open</code>方法，这个方法由<code>fifo_open()</code>实现。<code>fifo_open()</code>函数初始化专用于<code>FIFO</code>的数据结构；具体来说，它执行下列操作：</p>
<ol>
<li>取<code>i_sem</code>索引节点信号量。</li>
<li>检查索引节点对象的<code>i_pipe</code>字段；如果为<code>NULL</code>，则分配并初始化一个新的<code>pipe_inode_info</code>结构，这与本章前面“创建和撤销管道”一节的第<code>1b～le</code>步相同。</li>
<li>根据<code>open()</code>系统调用的参数中指定的访问模式，用合适的文件操作表的地址初始化文件对象的<code>f_op</code>字段</li>
<li>如果访问模式或者为只读或者为读/写，则把<code>1</code>加到<code>pipe_inode_info</code>结构的<code>readers</code>字段和<code>r_counter</code>字段。此外，如果访问模式是只读的，且没有其他的读进程，则唤醒等待队列上的任何写进程。</li>
<li>如果访问模式或者为只写或者为读/写，则把<code>1</code>加到<code>pipe_inode_info</code>结构的<code>writers</code>字段和<code>w_counter</code>字段。此外，如果访问模式是只写的，且没有其他的写进程，则唤醒等待队列上的任何读进程。</li>
<li>如果没有读进程或没有写进程，则确定函数是应当阻塞还是返回一个错误码而终止(如表<code>19-6</code>所示)。</li>
</ol>
<p><img src=".\image-20240503162357975.png" alt="image-20240503162357975"></p>
<ol>
<li>释放索引节点信号量，并终止，返回<code>0</code>(成功)。</li>
<li><code>FIFO</code>的三个专用文件操作表的主要区别是<code>read</code>和<code>write</code>方法的实现不同。如果访问类型允许读操作，那么<code>read</code>方法是使用<code>pipe_read()</code>函数实现的；否则，<code>read</code>方法就是使用<code>bad pipe_r()</code>函数实现的，该函数只是返回一个错误码。如果访问类型允许写操作，那么<code>write</code>方法就是使用<code>pipe_write()</code>函数实现的；否则，<code>write</code>方法就是使用<code>bad pipe_w()</code>函数实现的，该函数也只是返回一个错误代码。</li>
</ol>
<h3 id="System-V-IPC"><a href="#System-V-IPC" class="headerlink" title="System V IPC"></a>System V IPC</h3><p><code>IPC</code>是进程间通信(<code>Interprocess Communication</code>)的缩写，通常指允许用户态进程执行下列操作的一组机制：<br>(1). 通过信号量与其他进程进行同步<br>(2). 向其他进程发送消息或者从其他进程接收消息和其他进程共享一段内存，<code>System VIPC</code>最初是在一个名为<code>“Columbus Unix”</code>的开发版<code>Unix</code>变体中引入的，之后在<code>AT&amp;T</code>的<code>System II</code>中采用。现在在大部分<code>Unix</code>系统(包括<code>Linux</code>)中都可以找到。</p>
<p><code>IPC</code>数据结构是在进程请求<code>IPC</code>资源(信号量、消息队列或者共享内存区)时动态创建的。每个<code>IPC</code>资源都是持久的：除非被进程显式地释放，否则永远驻留在内存中(直到系统关闭)。<code>IPC</code>资源可以由任一进程使用，包括那些不共享祖先进程所创建的资源的进程。</p>
<p>由于一个进程可能需要同类型的多个<code>IPC</code>资源，因此每个新资源都是使用一个<code>32</code>位的<code>IPC</code>关键字来标识的，这和系统的目录树中的文件路径名类似。每个<code>IPC</code>资源都有一个<code>32</code>位的<code>IPC</code>标识符，这与和打开文件相关的文件描述符有些类似。<code>IPC</code>标识符由内核分配给<code>IPC</code>资源，在系统内部是唯一的，而<code>IPC</code>关键字可以由程序员自由地选择。</p>
<p>当两个或者更多的进程要通过一个<code>IPC</code>资源进行通信时，这些进程都要引用该资源的<code>IPC</code>标识符。</p>
<h3 id="使用IPC资源"><a href="#使用IPC资源" class="headerlink" title="使用IPC资源"></a>使用IPC资源</h3><p>根据新资源是信号量、消息队列还是共享内存区，分别调用<code>semget()、msgget()</code>或者<code>shmget()</code>函数创建<code>IPC</code>资源。</p>
<p>这三个函数的主要目的都是从<code>IPC</code>关键字(作为第一个参数传递)中导出相应的<code>IPC</code>标识符，进程以后就可以使用这个标识符对资源进行访问。</p>
<p>如果还没有<code>IPC</code>资源和<code>IPC</code>关键字相关联，就创建一个新的资源。如果一切都顺利，那么函数就返回一个正的<code>IPC</code>标识符；否则，就返回一个如表<code>19-7</code>所示的错误码。</p>
<ul>
<li>EACCES：指定的消息队列已存在，但调用进程没有权限访问它</li>
<li>EEXIST：key指定的消息队列已存在，而msgflg中同时指定IPC_CREAT和IPC_EXCL标志</li>
<li>ENOENT：key指定的消息队列不存在同时msgflg中没有指定IPC_CREAT标志</li>
<li>ENOMEM：需要建立消息队列，但内存不足</li>
<li>ENOSPC：需要建立消息队列，但已达到系统的限制</li>
</ul>
<p>​    假设两个独立的进程想共享一个公共的<code>IPC</code>资源。这可以使用两种方法来达到：</p>
<ul>
<li>这两个进程统一使用固定的、预定义的<code>IPC</code>关键字。这是最简单的情况，对于由很多进程实现的复杂的应用程序也工作得很好。然而，另外一个无关的程序也可能使用了相同的<code>IPC</code>关键字。在这种情况下，<code>IPC</code>函数可能被成功地调用，但返回错误资源的<code>IPC</code>标识符。</li>
<li>一个进程通过指定<code>IPC_PRIVATE</code>作为自己的<code>IPC</code>关键字来调用<code>semget()、msgget()</code>或<code>shmget()</code>函数。一个新的<code>IPC</code>资源因此而被分配，这个进程或者可以与应用程序中的另一个进程共享自己的<code>IPC</code>标识符，或者自己创建另一个进程。这种方法确保<code>IPC</code>资源不会偶然被其他应用程序使用。</li>
</ul>
<p><code>semget()、msgget()</code>和<code>shnget()</code>函数的最后一个参数可以包括三个标志。</p>
<ul>
<li><code>IPC_CREAT</code> 说明如果<code>IPC</code>资源不存在，就必须创建它；</li>
<li><code>IPC_EXCL</code>说明如果资源已经存在而且设置了<code>IPC_CREAT</code>标志，那么函数就必定失败；</li>
<li><code>IPC_NOWAIT</code>说明访问<code>IPC</code>资源时进程从不阻塞(典型的情况如取得消息或获取信号量)。</li>
</ul>
<p>​    即使进程使用了<code>IPC_CREAT</code>和<code>IPC_EXCL</code>标志，也没有办法保证对一个<code>IPC</code>资源进行排它访问，因为其他进程也可能用自己的<code>IPC</code>标识符引用了这个资源。</p>
<p>​    为了把不正确地引用错误资源的风险降到最小，内核不会在<code>IPC</code>标识符一空闲时就再利用它。相反，分配给资源的<code>IPC</code>标识符总是大于给同类型的前一个资源所分配的标识符(唯一的例外发生在<code>32</code>位的<code>IPC</code>标识符溢出时)。</p>
<p>​    每个<code>IPC</code>标识符都是通过结合使用与资源类型相关的位置使用序号(<code>slot usage sequence number</code>)、已分配资源的任意位置索引(<code>slot index</code>)以及内核中为可分配资源所选定的的最大值而计算出来的。</p>
<p>如果我们使用<code>s</code>来代表位置使用序号，<code>M</code>来代表可分配资源的最大数目，<code>i</code>来代表位置索引，此处<code>0 ≤ i &lt; M</code>，则每个<code>IPC</code>资源的<code>ID</code>都可以按如下公式来计算：<code>IPC</code>标识符 <code>= s × M + i</code>。在<code>Linux 2.6</code>中，<code>M</code>的值设为<code>32768</code>(<code>IPCMNI</code>宏)。位置使用序号<code>s</code>被初始化成<code>0</code>，每次分配资源时增加<code>1</code>。当<code>s</code>达到预定的阈值时(这取决于<code>IPC</code>资源类型)，它从<code>0</code>重新开始。</p>
<p><code>IPC</code>资源的每种类型(信号量、消息队列和共享内存区)都拥有<code>ipc_ids</code>数据结构<code>ipc_id_ary</code>数据结构有两个字段：<code>p</code>和<code>size</code>。<code>p</code>字段是一个指向<code>kern_ipc_perm</code>数据结构的指针数组，每个结构对应一个可分配资源。<code>size</code>字段是这个数组的大小。</p>
<p>最初，数组为共享内存区、消息队列与信号量分别存放<code>1</code>、<code>16</code>或<code>128</code>个指针。当太小时，内核动态地增大数组。但是每种资源都有个上限。系统管理员可以修改<code>/proc/sys/kernel/sem、/proc/sys/kernel/msgmni</code>和<code>/proc/sys/kernel/shmmni</code>这三个文件以改变这些上限。每个<code>kern_ipc_perm</code>数据结构与一个<code>IPC</code>资源相关联，并且包含如表<code>19-9</code>所示的字段。<code>uid、gid、cuid</code>和<code>cgid</code>分别存放资源的创建者的用户标识符和组标识符以及当前资源属主的用户标识符和组标识符。<code>mode</code>位掩码包括六个标志，分别存放资源的属主、组以及其他用户的读、写访问权限。</p>
<p><code>IPC</code>访问许可权和第一章的“访问权限和文件模式”一节中介绍的文件访问许可权类似，唯一不同的是这里没有执行许可权标志。<br><code>kern_ipc_perm</code>数据结构也包括一个<code>key</code>字段和一个<code>seq</code>字段，前者指的是相应资源的<code>IPC</code>关键字，后者存放的是用来计算该资源的<code>IPC</code>标识符所使用的位置使用序号。</p>
<p><code>semctl()、msgctl()</code>和<code>shmctl()</code>函数都可以用来处理<code>IPC</code>资源。<code>IPC_SET</code>子命令允许进程改变属主的用户标识符和组标识符以及<code>ipc_perm</code>数据结构中的许可权位掩码。<code>IPC_STAT</code>和<code>IPC_INFO</code>子命令取得和资源有关的信息。最后，<code>IPC_RMID</code>子命令释放<code>IPC</code>资源。</p>
<p>根据<code>IPC</code>资源的种类不同，还可以使用其他专用的子命令。一旦一个<code>IPC</code>资源被创建，进程就可以通过一些专用函数对这个资源进行操作。进程可以执行<code>semop()</code>函数获得或释放一个<code>IPC</code>信号量。当进程希望发送或接收一个<code>IPC</code>消息时，就分别使用<code>msgsnd()</code>和<code>msgrcv()</code>函数。最后，进程可以分别使用<code>shmat()</code>和<code>shmdt()</code>函数把一个共享内存区附加到自己的地址空间中或者取消这种附加关系。</p>
<h3 id="ipc-系统调用"><a href="#ipc-系统调用" class="headerlink" title="ipc()系统调用"></a>ipc()系统调用</h3><p>所有的<code>IPC</code>函数都必须通过适当的<code>Linux</code>系统调用实现。实际上，在<code>80×86</code>体系结构中，只有一个名为<code>ipc()</code>的<code>IPC</code>系统调用。当进程调用一个<code>IPC</code>函数时，比如说<code>msgget()</code>，该函数实际上调用<code>C</code>库中的一个封装函数，该函数又通过传递<code>msgget()</code>的所有参数加上一个适当的子命令代码(在本例中是<code>MSGGET</code>)来调用<code>ipc()</code>系统调用。<code>sys_ipc()</code>服务例程检查子命令代码，并调用内核函数实现所请求的服务。<code>ipc()</code>“多路复用”系统调用是从早期的<code>Linux</code>版本中继承而来的，早期<code>Linux</code>版本把<code>IPC</code> 代码包含在动态模块中。在<code>system_call</code>表中为可能未实现的内核部件保留几个系统调用入口并没有什么意义，因此内核设计者就采用了这种多路复用的方法。现在，<code>System V IPC</code>不再作为动态模块被编译，因此也就没有理由使用单个<code>IPC</code>系统调用。事实上，<code>Linux</code>在<code>HP</code>的<code>Alpha</code>体系结构和<code>Intel</code>的<code>IA-64</code>上为每个<code>IPC</code>函数都提供了一个系统调用。</p>
<h3 id="IPC信号量"><a href="#IPC信号量" class="headerlink" title="IPC信号量"></a>IPC信号量</h3><p><code>IPC</code>信号量和在内核信号量非常类似：二者都是计数器，用来为多个进程共享的数据结构提供受控访问。如果受保护的资源是可用的，那么信号量的值就是正数；如果受保护的资源现不可用，那么信号量的值就是<code>0</code>。要访问资源的进程试图把信号量的值减<code>1</code>，但是，内核阻塞这个进程，直到在这个信号量上的操作产生一个正值。当进程释放受保护的资源时，就把信号量的值增加<code>1</code>；在这样处理的过程中，其他所有正在等待这个信号量的进程就都被唤醒。</p>
<p>实际上，<code>IPC</code>信号量比内核信号量的处理更复杂是由于两个主要的原因：</p>
<p>每个<code>IPC</code>信号量都是一个或者多个信号量值的集合，而不像内核信号量一样只有一个值。这意味着同一个<code>IPC</code>资源可以保护多个独立、共享的数据结构。在资源正在被分配的过程中，必须把每个<code>IPC</code>信号量中的信号量的个数指定为<code>semget()</code>函数的一个参数。</p>
<p>从现在开始，我们就把信号量内部的计数器作为原始信号量(<code>primitive semaphore</code>)来引用。<code>IPC</code>信号量资源的个数和单个<code>IPC</code>资源内原始信号量的个数都有界限，其缺省值前者为<code>128</code>，后者为<code>250</code>；</p>
<p>不过，系统管理员可以通过<code>/proc/sys/kernel/sem</code>文件很容易地修改这两个界限。</p>
<p><code>System V IPC</code>信号量提供了一种失效安全机制，这是用于进程不能取消以前对信号量执行的操作就死亡的情况的。当进程选择使用这种机制时，由此引起的操作就是所谓的可取消的(<code>undoable</code>)信号量操作。当进程死亡时，所有<code>IPC</code>信号量都可以恢复成原来的值，就好像从来都没有开始它的操作。这有助于防止出现这种情况：由于正在结束的进程不能手工取消它的信号量操作，其他使用相同信号量的进程无限地停留在阻塞状态。</p>
<p>​    首先我们简要描绘一下，当进程想访问<code>IPC</code>信号量所保护的一个或者多个资源时所执行的典型步骤：</p>
<ul>
<li>调用<code>semget()</code>封装函数来获得<code>IPC</code>信号量标识符，作为参数指定对共享资源进行保护的<code>IPC</code>信号量的<code>IPC</code>关键字。如果进程希望创建一个新的<code>IPC</code>信号量，则还要指定<code>IPC_CREATE</code>或者<code>IPC_PRIVATE</code>标志以及所需要的原始信号量。</li>
<li>调用<code>semop()</code>封装函数来测试并递减所有原始信号量所涉及的值。如果所有的测试全部成功，就执行递减操作，结束函数并允许这个进程访问受保护的资源。</li>
</ul>
<p>如果有些信号量正在使用，那么进程通常都会被挂起，直到某个其他进程释放这个资源为止。函数接收的参数为<code>IPC</code>信号量标识符、用来指定对原始信号量所进行的原子操作的一组整数以及这种操作的个数。作为选项，进程也可以指定<code>SEM_UNDO</code>标志，这个标志通知内核：如果进程没有释放原始信号量就退出，那么撤消那些操作。<br>(4). 当放弃受保护的资源时，就再次调用<code>semop()</code>函数来原子地增加所有有关的原始信号量。<br>(5). 作为选择，调用<code>semctl()</code>封装函数，在参数中指定<code>IPC_RMID</code>命令把这个<code>IPC</code>信号量从系统中删除。</p>
<p>现在我们就可以讨论内核是如何实现<code>IPC</code>信号量的。有关的数据结构如图<code>19-1</code>所示。<code>sem_ids</code>变量存放<code>IPC</code>信号量资源类型的<code>ipc_ids</code>数据结构；对应的<code>ipc_id_ary</code>数据结构包含一个指针数组，它指向<code>sem_array</code>数据结构，每个元素对应一个<code>IPC</code>信号量资源。<br><img src=".\image-20240503162543765.png" alt="image-20240503162543765"><br>从形式上说，这个数组存放指向<code>kern_ipc_perm</code>数据结构的指针，但是每个结构只不过是<code>sem_array</code>数据结构的第一个字段。<br><code>sem_base</code>字段指向<code>sem</code>数据结构的数组，每个元素对应一个<code>IPC</code>原始信号量。<code>sem</code>数据结构只包括两个字段：<br>(1). <code>semval</code><br>信号量的计数器的值。<br>(2). <code>sempid</code><br>最后一个访问信号量的进程的<code>PID</code>。进程可以使用<code>semctl()</code>封装函数查询该值</p>
<h3 id="可取消的信号量操作"><a href="#可取消的信号量操作" class="headerlink" title="可取消的信号量操作"></a>可取消的信号量操作</h3><p>​    如果一个进程突然放弃执行，那么它就不能取消已经开始执行的操作(例如，释放自己保留的信号量)；因此通过把这些操作定义成可取消的，进程就可以让内核把信号量返回到一致状态并允许其他进程继续执行。进程可以在<code>semop()</code>函数中指定<code>SEM_UNDO</code>标志来请求可取消的操作。</p>
<p>​    为了有助于内核撤消给定进程对给定的<code>IPC</code>信号量资源所执行的可撤销操作，有关的信息存放在<code>sem_undo</code>数据结构中。这个结构实际上包含信号量的<code>IPC</code>标识符及一个整数数组，这个数组表示由进程执行的所有可取消操作对原始信号量值引起的修改。</p>
<p>​    有一个简单的例子可以说明如何使用这种<code>sem_undo</code>元素。考虑一个进程使用具有<code>4</code>个原始信号量的一个<code>IPC</code>信号量资源，并假设该进程调用<code>semop()</code>函数把第一个计数器的值增加<code>1</code>并把第二个计数器的值减<code>2</code>。如果该函数指定了<code>SEM_UNDO</code>标志，<code>sem_undo</code>数据结构中的第一个数组元素中的整数值就被减少<code>1</code>，而第二个元素就被增加<code>2</code>，其他两个整数都保持不变。</p>
<p>​    同一进程对这个<code>IPC</code>信号量执行的更多的可取消操作将相应地改变存放在<code>sem_undo</code>结构中的整数值。当进程退出时，该数组中的任何非零值就表示对相应原始信号量的一个或者多个错乱操作；</p>
<p>​    内核只简单地给相应的原始信号量计数器增加这个非零值来取消这些操作。换而言之，把异常中断的进程所做的修改退回，而其他进程所做的修改仍然能反映信号量的状态。</p>
<p>​    对于每个进程来说，内核都要记录以可取消操作处理的所有信号量资源，这样如果进程意外退出，就可以回滚这些操作。还有，内核还必须对每个信号量都记录它所有的<code>sem_undo</code>结构，这样只要进程使用<code>semctl()</code>来强行给一个原始信号量的计数器赋一个明确的值或者撤消一个<code>IPC</code>信号量资源时，内核就可以快速访问这些结构。</p>
<p>​    正是由于两个链表(我们称之为每个进程的链表和每个信号量的链表)，使得内核可以有效地处理这些任务。第一个链表记录给定进程以可取消操作处理的所有信号量。第二个链表记录对以可取消操对给定信号量进行操作的所有进程。更确切地说：</p>
<ul>
<li>每个进程链表包含所有的<code>sem_undo</code>数据结构，该结构对应于进程执行了可取消操作的<code>IPC</code>信号量。进程描述符的<code>sysvsem.undo_list</code>字段指向一个<code>sem_undo_list</code> 类型的数据结构，而该结构又包含了指针指向该链表的第一个元素。</li>
<li>每个<code>sem_undo</code> 数据结构的<code>proc_next</code>字段指向该链表的下一个元素，因为都共享一个<code>sem_undo_list</code>描述符，将<code>CLONE_SYSVSEM</code>标志传给<code>clone()</code>系统调用而克隆的进程都共享同一个可取消信号量操作链表。</li>
<li>每个信号量链表包含的所有<code>sem_undo</code>数据结构对应于在该信号量上执行可取消操作的进程。<code>sem_array</code>数据结构的<code>undo</code>字段指向链表的第一个元素，而每个<code>sem_undo</code>数据结构的<code>id_next</code>字段指向链表的下一个元素。</li>
</ul>
<p>当进程结束时，每个进程的链表才被使用。<code>exit_sem()</code>函数由<code>do_exit()</code>调用，后者会遍历这个链表，并为进程所涉及的每个<code>IPC</code>信号量平息错乱操作产生的影响。</p>
<p>与此相对照，当进程调用<code>semctl()</code>函数强行给一个原始信号量赋一个明确的值时，每个信号量的链表才被使用。内核把指向<code>IPC</code>信号量资源的所有<code>sem_undo</code>数据结构中的数组的相应元素都设置成<code>0</code>，因为撤消原始信号量的一个可取消操作不再有任何意义。此外，在<code>IPC</code>信号量被清除时，每个信号量链表也被使用。通过把<code>semid</code>字段设置成<code>-1</code>而使所有有关的<code>sem_undo</code>数据结构都变为无效。</p>
<h3 id="挂起请求的队列"><a href="#挂起请求的队列" class="headerlink" title="挂起请求的队列"></a>挂起请求的队列</h3><p>内核给每个<code>IPC</code>信号量都分配了一个挂起请求队列，用来标识正在等待数组中的一个(或多个)信号量的进程。<br>这个队列是一个<code>sem_queue</code>数据结构的双向链表，其字段如表<code>19-11</code>所示。队列中的第一个和最后一个挂起请求分别由<code>sem_array</code>结构中的<code>sem pending</code>和<code>sem_pending_last</code>字段所指向。<br>这最后一个字段允许把链表作为一个<code>FIFO</code>进行简单的处理。新的挂起请求都被追加到链表的末尾，这样就可以稍后得到服务。<br>挂起请求最重要的字段是<code>nsops</code>和<code>sops</code>，前者存放挂起操作所涉及的原始信号量的个数，后者指向描述每个信号量操作的整型数组。<code>sleeper</code>字段存放发出请求操作的睡眠进程的描述符地址。</p>
<p>​    有三个挂起请求的一个<code>IPC</code>信号量。第二个和第三个请求涉及可取消操作，因此<code>sem_queue</code>数据结构的<code>undo</code>字段指向相应的<code>sem_undo</code>结构；第一个挂起请求的<code>undo</code>字段为<code>NULL</code>，因为相应的操作是不可取消的。</p>
<h3 id="IPC消息"><a href="#IPC消息" class="headerlink" title="IPC消息"></a>IPC消息</h3><p>进程彼此之间可以通过<code>IPC</code>消息进行通信。进程产生的每条消息都被发送到一个<code>IPC</code>消息队列中，这个消息一直存放在队列中直到另一个进程将其读走为止。<br>消息是由固定大小的首部和可变长度的正文组成的，可以使用一个整数值(消息类型)标识消息，这就允许进程有选择地从消息队列中获取消息。只要进程从<code>IPC</code>消息队列中读出一条消息，内核就把这个消息删除；因此，只能有一个进程接收一条给定的消息。</p>
<p>为了发送一条消息，进程要调用<code>msgsnd()</code>函数，传递给它以下参数：</p>
<ul>
<li>目标消息队列的<code>IPC</code>标识符</li>
<li>消息正文的大小</li>
<li>用户态缓冲区的地址，缓冲区中包含消息类型，之后紧跟消息正文</li>
</ul>
<p>进程要获得一条消息就要调用<code>msgrcv()</code>函数，传递给它如下参数：</p>
<ul>
<li><code>IPC</code>消息队列资源的<code>IPC</code>标识符</li>
<li>指向用户态缓冲区的指针，消息类型和消息正文应该到被拷贝这个缓冲区</li>
<li>缓冲区的大小</li>
<li>一个值<code>t</code>，指定应该获得什么消息</li>
</ul>
<p>如果<code>t</code>的值为<code>0</code>，就返回队列中的第一条消息。如果<code>t</code>为正数，就返回队列中类型等于<code>t</code> 的第一条消息。最后，如果<code>1</code>为负数，就返回消息类型小于等于<code>t</code>绝对值的最小的第一条消息。为了避免资源耗尽，<code>IPC</code>消息队列资源在这几个方面是有限制的：</p>
<p><code>IPC</code>消息队列数(缺省为<code>16</code>)，每个消息的大小(缺省为<code>8192</code>字节)及队列中全部信息的大小(缺省为<code>16384</code> 字节)。不过和前面类似，系统管理员可以分别修改<code>/proc/sys/kernel/msgmni</code>、<code>/proc/sys/kernel/msgmnb</code>和<code>/proc/sys/kernel/msgmax</code>文件调整这些值。与<code>IPC</code>消息队列有关的数据结构如图<code>19-2</code>所示。<code>msg_ids</code>变量存放<code>IPC</code>消息队列资源类型的<code>ipc_ids</code>数据结构；相应的<code>ipc_id_ary</code>数据结构包含一个指向<code>shmid_kernel</code>数据结构的指针数组–每个<code>IPC</code>消息资源对应一个元素。</p>
<p>从形式上看，数组中存放指向<code>kern_ipc_perm</code>数据结构的指针，但是，每个这样的结构只不过是<code>msg_queue</code>数据结构的第一个字段。<code>msg_queue</code>数据结构的所有字段如表19-12所示。<br><img src=".\3032e57d069f49e291a66f318ee4d551.png" alt="在这里插入图片描述"></p>
<p>​    最重要的字段是<code>qmessages</code>，它表示包含队列中当前所有消息的双向循环链表的首部(也就是第一个哑元素)。每条消息分开存放在一个或多个动态分配的页中。</p>
<ul>
<li>第一页的起始部分存放消息头，消息头是一个<code>msg_msg</code>类型的数据结构；它的字段如表<code>19-13</code>所示。<code>m_list</code>字段指向队列中前一条和后一条消息的指针。消息的正文正好从<code>msg_msg</code>描述符之后开始；如果消息(页的大小减去<code>msg_msg</code>描述符的大小)大于<code>4072</code>字节，就继续放在另一页，它的地址存放在<code>msg_msg</code>描述符的<code>next</code>字段中。</li>
<li>第二个页框以<code>msg_msgseg</code>类型的描述符开始，这个描述符只包含一个<code>next</code>指针，该指针存放可选的第三个页，以此类推。当消息队列满时(或者达到了最大消息数，或者达到了队列最大字节数)，则试图让新消息入队的进程可能被阻塞。<br><code>msg_queue</code>数据结构的<code>q_senders</code>字段是所有阻塞的发送进程的描述符形成的链表的头。当消息队列为空时(或者当进程指定的一条消息类型不在队列中时)，则接收进程也会被阻塞。</li>
</ul>
<p><code>msg_queue</code>数据结构的<code>qreceivers</code>字段是<code>msg_receiver</code>数据结构链表的头，每个阻塞的接收进程对应其中一个元素。其中的每个结构本质上都包含。一个指向进程描述的指针、一个指向消息的<code>msg_msg</code>结构的指针和所请求的消息类型。</p>
<h3 id="IPC共享内存"><a href="#IPC共享内存" class="headerlink" title="IPC共享内存"></a>IPC共享内存</h3><p>最有用的<code>IPC</code>机制是共享内存，这种机制允许两个或多个进程通过把公共数据结构放入一个共享内存区(<code>IPC shared memory region</code>)来访问它们。</p>
<p>如果进程要访问这种存放在共享内存区的数据结构，就必须在自己的地址空间中增加一个新内存区，它将映射与这个共享内存区相关的页框。</p>
<p>这样的页框可以很容易地由内核通过请求调页进行处理。与信号量以及消息队列一样，调用<code>shmget()</code>函数来获得一个共享内存区的<code>IPC</code>标识符，如果这个共享内存区不存在，就创建它。</p>
<p>调用<code>shmat()</code>函数把一个共享内存区“附加(<code>attach</code>)”到一个进程上。该函数使用<code>IPC</code> 共享内存资源的标识符作为参数，并试图把一个共享内存区加入到调用进程的地址空间中。</p>
<p>调用进程可以获得这个内存区域的起始线性地址，但是这个地址通常并不重要，访问这个共享内存区域的每个进程都可以使用自己地址空间中的不同地址。</p>
<p><code>shmat()</code>函数不修改进程的页表。我们稍后会介绍在进程试图访问属于新内存区域的页时内核究竟怎样进行处理。调用<code>shmdt()</code>函数来“分离”由<code>IPC</code>标识符所指定的共享内存区域，也就是说把相应的共享内存区域从进程的地址空间中删除。</p>
<p>回想一下，<code>IPC</code>共享内存资源是持久的；即使现在没有进程在使用它，相应的页也不能被丢弃，但是可以被换出。与<code>IPC</code>资源的其他类型一样，为了避免用户态进程过分使用内存，也有一些限制施加于所允许的，<code>IPC</code>共享内存区域数(缺省为<code>4096</code>)、每个共享段的大小(缺省为<code>32MB</code>)以及所有共享段的最大字节数(缺省为<code>8GB</code>)。</p>
<p>不过，系统管理员照样可以调整这些值，这是通过分别修改<code>/proc/sys/kernel/shmmni</code>、<code>/proc/sys/kernel/shmmax</code>和<code>/proc/sys/kernel/shmall</code>文件完成的。<br><img src=".\image-20240503162458649.png" alt="image-20240503162458649"></p>
<p>图<code>19-3</code>显示与<code>IPC</code>共享内存区相关的数据结构。<code>shm_ids</code>变量存放<code>IPC</code>共享内存资源类型<code>ipc_ids</code>的数据结构；相应的<code>ipc_id_ary</code>数据结构包含一个指向<code>shmid_kernel</code>数据结构的指针数组，每个<code>IPC</code>共享内存资源对应一个数组元素。</p>
<p>从形式上看，这个数组存放指向<code>kern_ipc_perm</code>数据结构指针，但是每个这样的结构只不过是<code>shmid_kernel</code>数据结构的第一个字段。<code>shmid_kernel</code>数据结构的所有字段如表<code>19-14</code>所示。<br><img src=".\image-20240503162446819.png" alt="image-20240503162446819"></p>
<p>最重要的字段是<code>shm_file</code>，该字段存放文件对象的地址。这反映<code>Linux 2.6</code>中<code>IPC</code>共享内存与<code>VFS</code>的紧密结合。具体来说，每个<code>IPC</code>共享内存区与属于<code>shm</code>特殊文件系统的一个普通文件相关联。</p>
<p>因为<code>shm</code>文件系统在系统目录树中没有安装点，因此，用户不能通过普通的<code>VFS</code>系统调用打开并访问它的文件。</p>
<p>但是，只要进程“附加”一个内存段，内核就调用<code>do_mmap()</code>，并在进程的地址空间创建文件的一个新的共享内存映射。因此，属于<code>shm</code>特殊文件系统的文件只有一个文件对象方法<code>mmap</code>，该方法是由<code>shm_mmap()</code>函数实现的。<br>如图<code>19-3</code>所示，与<code>IPC</code>共享内存区对应的内存区是用<code>vm_area_struct</code>对象描述的;<br>它的<code>vm_file</code>字段指回特殊文件的文件对象，而特殊文件又依次引用目录项对象和索引节点对象。</p>
<p>存放在索引节点<code>i_ino</code>字段的索引节点号实际上是<code>IPC</code>共享内存区的位置索引，因此，索引节点对象间接引用<code>shmid_kernel</code>描述符。</p>
<p>同样，对于任何共享内存映射，通过<code>address_space</code>对象把页框包含在页高速缓存中，而<code>address_space</code>对象包含在索引节点中而且被索引节点的<code>i_mapping</code>字段引用。</p>
<p>万一页框属于<code>IPC</code>共享内存区，<code>address_space</code>对象的方法就存放在全局变量<code>shmem_aops</code>中。</p>
<h3 id="换出IPC共享内存区的页"><a href="#换出IPC共享内存区的页" class="headerlink" title="换出IPC共享内存区的页"></a>换出IPC共享内存区的页</h3><p>内核在把包含在共享内存区的页换出时一定要谨慎，并且交换高速缓存的作用是至关紧要的。<br>因为<code>IPC</code>共享内存区映射的是在磁盘上没有映像的特殊索引节点，因此其页是可交换的。因此为了回收<code>IPC</code>共享内存区的页，内核必须把它写入交换区。因为<code>IPC</code>共享内存区是持久的——也就是说即使内存段不附加到进程，也必须保留这些页。</p>
<p>因此即使这些页没有进程在使用，内核也不能简单地删除它们。让我们看看<code>PFRA</code>是如何回收<code>IPC</code>共享内存区页框的。一直到<code>shrink_list()</code>函数处理页之前，都与第十七章“内存紧缺回收”一节所描述的一样。因为这个函数并不为<code>IPC</code> 共享内存区域作任何检查，因此它会调用<code>try_to_unmap()</code>函数从用户态地址空间删除对页框的每个引用。正如第十七章“反向映射”一节描述的一样，相应的页表项就被删除。</p>
<p>然后，<code>shrink_list()</code>函数检查页的<code>PG_dirty</code>标志，调用<code>pageout()</code>(当<code>IPC</code>共享内存区域的页框在分配时总是被标记为脏，因此<code>pageout()</code>总是被调用)。而<code>pageout()</code>函数又调用所映射文件的<code>address_space</code>对象的<code>writepage</code>方法。</p>
<p><code>shmem_writepage()</code>函数实现了<code>IPC</code>共享内存区页的<code>writepage</code>方法。它实际上给交换区域分配一个新页槽(<code>page slot</code>)，然后将它从页高速缓存移到交换高速缓存(实际上就是改变页所有者的<code>address_space</code>对象)。</p>
<p>该函数还在<code>shmem_inode_info</code>结构中存放换出页页标识符，这个结构包含了<code>IPC</code>共享内存区的索引节点对象，它再次设置页的<code>PG_dirty</code>标志。</p>
<p>如第十七章的表<code>17-5</code>所示，<code>shrink_list()</code>函数检查<code>PG_dirty</code>标志，并通过把页留在非活动链表而中断回收过程。<br>迟早，<code>PFRA</code>还会处理该页框。<code>shrink_list()</code>又一次调用<code>pageout()</code>尝试将页刷新到磁盘。</p>
<p>但这一次，页已在交换高速缓存内，因而它的所有者是交换子系统的<code>address_space</code>对象，即<code>swapper_space</code>。相应的<code>writepage</code>方法<code>swap_writepage()</code>开始有效地向交换区进行写入操作。</p>
<p>一旦<code>pageout()</code>结束，<code>shrink_list()</code>确认该页已干净，于是从交换高速缓存删除页并释放给伙伴系统。</p>
<h3 id="IPC共享内存区的请求调页"><a href="#IPC共享内存区的请求调页" class="headerlink" title="IPC共享内存区的请求调页"></a>IPC共享内存区的请求调页</h3><p>通过<code>shmat()</code>加入进程的页都是哑元页(<code>dummy page</code>)；该函数把一个新内存区加入一个进程的地址空间中，但是它不修改该进程的页表。</p>
<p>此外，我们已经看到，<code>IPC</code>共享内存区的页可以被换出。因此，可以通过请求调页机制来处理这些页。</p>
<p>我们知道，当进程试图访问<code>IPC</code>共享内存区的一个单元，而其基本的页框还没有分配时则发生缺页异常。相应的异常处理程序确定引起缺页的地址是在进程的地址空间内，且相应的页表项为空；因此，它就调用<code>do_no_page()</code>函数。这个函数又检查是否为这个内存区定义了<code>nopage</code>方法。然后调用这个方法，并把页表项设置成所返回的地址。</p>
<p><code>IPC</code>共享内存所使用的内存区通常都定义了<code>nopage</code>方法。这是通过<code>shmem_nopage()</code>函数实现的，该函数执行以下操作：</p>
<ol>
<li>遍历<code>VFS</code>对象的指针链表，并导出<code>IPC</code>共享内存资源的索引节点对象的地址(参见图<code>19-3</code>)。</li>
<li>从内存区域描述符的<code>vm_start</code>字段和请求的地址计算共享段内的逻辑页号。</li>
<li>检查页是否已经在页高速缓存中，如果是，则结束并返回该描述符的地址。</li>
<li>检查页是否在交换高速缓存内且是否最新。如果是，则结束并返回该描述符的地址。</li>
<li>检查内嵌在索引节点对象的<code>shmem_inode_info</code>是否存放着逻辑页号对应的换出页标识符。如果是，就调用<code>read_swap_cache_async()</code>执行换入操作，并一直等到数据传送完成，然后结束并返回页描述符的地址。</li>
<li>否则，页不在交换区中；因此就从伙伴系统分配一个新页框，把它插入页高速缓存，并返回它的地址。<code>do_no_page()</code>函数对引起缺页的地址在进程的页表中所对应的表项进行设置，以使该函数指向<code>nopage</code>方法所返回的页框。</li>
</ol>
<h1 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h1><h2 id="进程的信任状和权能"><a href="#进程的信任状和权能" class="headerlink" title="进程的信任状和权能"></a>进程的信任状和权能</h2><p>​    从传统上看，<code>Unix</code>系统与每个进程的一些信任状(<code>credential</code>)相关，信任状把进程与一个特定的用户或<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=用户组&amp;spm=1001.2101.3001.7020">用户组</a>捆绑在一起。<br>​    信任状在多用户系统上尤为重要，因为信任状可以决定每个进程能做什么，不能做什么，这样既保证了每个用户的个人数据的完整性，也保证了系统整体上的稳定性。信任状的使用既需要在进程的数据结构方面给予支持，也需要在被保护的资源方面给予支持。</p>
<p>​    文件就是一种显而易见的资源。因此，在<code>Ext2</code>文件系统中，每个文件都属于一个特定的用户，并被捆绑于某个用户组。<br>​    文件的拥有者可以决定对某个文件允许哪些操作，以在文件的拥有者、文件的用户组及其他所有用户之间做出区别。当某个进程试图访问一个文件时，VFS总是根据文件的拥有者和进程的信任状所建立的许可权检查访问的合法性。进程的信任状存放在进程描述符的几个字段中，如表<code>20-1</code>所示。这些字段包括系统中用户和用户组的标识符，与之可以相比较的通常是存放在所访问文件索引节点中的标识符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>uid, gid</td>
<td>用户与组的实际标识符</td>
</tr>
<tr>
<td>euid, egid</td>
<td>用户与组的有效标识符</td>
</tr>
<tr>
<td>fsuid, fsgid</td>
<td>文件访问的用户和组的有效标识符</td>
</tr>
<tr>
<td>groups</td>
<td>补充的组标识符</td>
</tr>
<tr>
<td>suid, sgid</td>
<td>用户和组保存的标识符</td>
</tr>
</tbody>
</table>
</div>
<p>​    值为<code>0</code>的<code>UID</code>指定给<code>root</code>超级用户，而值为<code>0</code>的用户<code>GID</code>指定给<code>root</code>超级组。只要有关进程的信任状存放了一个零值，则内核将放弃权限检查，始终允许这个进程做任何事情，如涉及系统管理或硬件处理的那些操作，而这些操作对于非特权进程是不允许的。当一个进程被创建时，总是继承父进程的信任状。不过，这些信任状以后可以被修改，这发生在当进程开始执行一个新程序时，或者当进程发出合适的系统调用时。</p>
<p>​    通常情况下，进程的<code>uid、euid、fsuid</code>及<code>suid</code>字段具有相同的值。然而，当进程执行<code>setuid</code> 程序时，即可执行文件的<code>setuid</code>标志被设置时，<code>euid</code>和<code>fsuid</code>字段被置为这个文件拥有者的标识符。几乎所有的检查都涉及这两个字段中的一个： <code>fsuid</code>用于与文件相关的操作，而<code>euid</code>用于其他所有的操作。</p>
<p>​    这也同样适用于组标识符的<code>gid、egid、fsgid</code>及<code>sgid</code>字段。我们用一个例子来说明如何使用<code>fsuid</code>字段，考虑一下当用户想改变她的口令时的典型情况。所有的口令都存放在一个公共文件中，但用户不能直接编辑这样的文件，因为它是受保护的。因此，用户调用一个名为<code>/usr/bin/passwd</code>的系统程序，它可以设置<code>setuid</code> 标志，而且它的拥有者是超级用户。</p>
<p>​    当<code>shell</code>创建的进程执行这样一个程序时，进程的<code>euid</code>和<code>fsuid</code>字段被置为<code>0</code>，即超级用户的<code>PID</code>。现在，这个进程可以访问这个文件，因为当内核执行访问控制表时在<code>fsuid</code>字段发现了值<code>0</code>。当然，<code>usr/bin/passwd</code>程序除了让用户改变自己的口令外，并不允许做其他任何事情。</p>
<p>​    从<code>Unix</code>的历史发展可以得出一个教训，即<code>setuid</code>程序是相当危险的：恶意用户可以以这样的方式触发代码中的一些编程错误(bug)，从而强迫<code>setuid</code>程序执行程序的最初设计者从未安排的操作。这可能常常危及整个系统的安全。为了减少这样的风险，<code>Linux</code>与所有现代<code>Unix</code>操作系统一样，让进程只有在必要时才获得setuid特权，并在不需要时取消它们。</p>
<p>​    可以证明，当以几个保护级别实现用户应用程序时，这种特点是很有用的。进程描述符包含一个<code>suid</code>字段，在<code>setuid</code>程序执行以后在该字段中正好存放有效标识符(<code>euid</code>和<code>fsuid</code>)的值。进程可以通过<code>setuid()、setresuid()、setfsuid()</code>和<code>setreuid()</code>系统调用改变有效标识符。</p>
<p>​    请注意，如果调用进程还没有超级用户特权，即它的<code>euid</code>字段不为<code>0</code>，那么，只能用这些系统调用来设置在这个进程的信任状字段已经有的值。例如，一个普通用户进程可以通过调用系统调用<code>setfsuid()</code>强迫它的<code>fsuid</code>值为<code>500</code>，但这只有在其他信任状字段中有一个字段已经有相同的值<code>500</code>时才行。</p>
<p>为了理解四个用户ID字段之间的复杂关系，让我们考虑一下<code>setuid()</code>系统调用的效果。这些操作是不同的，这取决于调用者进程的<code>euid</code>字段是否被置为<code>0</code>(即进程有超级用户特权)或被置为一个正常的<code>UID</code>。</p>
<p>如果<code>euid</code>字段为<code>0</code>，这个系统调用就把调用进程的所有信任状字段(<code>uid、euid、fsuid</code> 及<code>suid</code>)置为参数<code>e</code>的值。超级用户进程因此就可以删除自己的特权而变为由普通用户拥有的一个进程。例如，在用户登录时，系统以超级用户特权创建一个新进程，但这个进程通过调用<code>setuid()</code>系统调用删除自己的特权，然后开始执行用户的<code>login shell</code>程序。如果<code>euid</code>字段不为<code>0</code>，那么这个系统调用只修改存放在<code>euid</code>和<code>fsuid</code>中的值，让其他两个字段保持不变。当运行<code>setuid</code>程序来提高和降低进程有效权限时(这些权限存放在<code>euid</code>和<code>fsuid</code>字段)，该系统调用的这种功能是非常有用的。</p>
<h3 id="进程的权能"><a href="#进程的权能" class="headerlink" title="进程的权能"></a>进程的权能</h3><p><code>POSIX.le</code>草案(现已撤销)用“权能(<code>capability</code>)”一词引入进程信任状的另一种模型。<code>Linux</code>内核支持<code>POSIX</code>权能，但是大部分<code>Linux</code>的发行版本不用它。一种权能仅仅是一个标志，它表明是否允许进程执行一个特定的操作或一组特定的操作。这个模型不同于传统的“超级用户VS普通用户”模型，在后一种模型中，一个进程要么能做任何事情，要么什么也不能做，这取决于它的有效<code>UID</code>。如表20-3所示，在<code>Linux</code> 内核中已包含了很多权能。</p>
<blockquote>
<ul>
<li>CAP_CHOWN:修改文件属主的权限</li>
<li>CAP_DAC_OVERRIDE:忽略文件的DAC访问限制</li>
<li>CAP_DAC_READ_SEARCH:忽略文件读及目录搜索的DAC访问限制</li>
<li>CAP_FOWNER：忽略文件属主ID必须和进程用户ID相匹配的限制</li>
<li>CAP_FSETID:允许设置文件的setuid位</li>
<li>CAP_KILL:允许对不属于自己的进程发送信号</li>
<li>CAP_SETGID:允许改变进程的组ID</li>
<li>CAP_SETUID:允许改变进程的用户ID</li>
<li>CAP_SETPCAP:允许向其他进程转移能力以及删除其他进程的能力</li>
<li>CAP_LINUX_IMMUTABLE:允许修改文件的IMMUTABLE和APPEND属性标志</li>
<li>CAP_NET_BIND_SERVICE:允许绑定到小于1024的端口</li>
<li>CAP_NET_BROADCAST:允许网络广播和多播访问</li>
<li>CAP_NET_ADMIN:允许执行网络管理任务</li>
<li>CAP_NET_RAW:允许使用原始套接字</li>
<li>CAP_IPC_LOCK:允许锁定共享内存片段</li>
<li>CAP_IPC_OWNER:忽略IPC所有权检查</li>
<li>CAP_SYS_MODULE:允许插入和删除内核模块</li>
<li>CAP_SYS_RAWIO:允许直接访问/devport,/dev/mem,/dev/kmem及原始块设备</li>
<li>CAP_SYS_CHROOT:允许使用chroot()系统调用</li>
<li>CAP_SYS_PTRACE:允许跟踪任何进程</li>
<li>CAP_SYS_PACCT:允许执行进程的BSD式审计</li>
<li>CAP_SYS_ADMIN:允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</li>
<li>CAP_SYS_BOOT:允许重新启动系统</li>
<li>CAP_SYS_NICE:允许提升优先级及设置其他进程的优先级</li>
<li>CAP_SYS_RESOURCE:忽略资源限制</li>
<li>CAP_SYS_TIME:允许改变系统时钟</li>
<li>CAP_SYS_TTY_CONFIG:允许配置TTY设备</li>
<li>CAP_MKNOD:允许使用mknod()系统调用</li>
<li>CAP_LEASE:允许修改文件锁的FL_LEASE标志</li>
</ul>
</blockquote>
<p>补充：更加细致版本：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xzongblogs/p/14106481.html">Linux Capabilities 简介及使用 - 五月的麦田 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>​    权能的主要优点是，任何时候每个进程只需要有限种权能。因此，即使有恶意的用户发现一种利用有潜在错误的程序的方法，他也只能非法地执行有限个操作类型。例如，假定一个有潜在错误的程序只有<code>CAP_SYS_TIME</code>权能。在这种情况下，利用其错误的恶意用户只能在非法地改变实时时钟和系统时钟方面获得成功。她并不能执行任何其他特权的操作。不管是<code>VFS</code>还是<code>Ext2</code>文件系统目前都不支持权能模型，所以，当进程执行一个可执行文件时，无法把这个文件与本该强加的一组权能联系起来。</p>
<p>​    然而，进程可以分别用<code>capget()</code>和<code>capset()</code>系统调用显式地获得和降低它的权能。例如，完全可以通过修改<code>login</code>程序只保留其权能的一个子集而删除其他权能。事实上，<code>Linux</code>内核已经考虑权能。例如，让我们考虑一下<code>nice()</code>系统调用，它允许用户改变进程的静态优先级。在传统的模型中，只有超级用户才能提升一个优先级，内核因此应该检查调用进程描述符的<code>euid</code>字段是否为0。然而，<code>Linux</code>内核定义了一个名为<code>CAP_SYS_NICE</code>的权能，就正好对应着这种操作。内核通过调用<code>capable()</code>函数并把<code>CAP_SYS_NICE</code>值传给这个函数来检查这个标志的值。正是由于一些“兼容性小巧程序”已被加入到内核代码中，这种方法才起作用。每当一个进程把<code>euid</code>和<code>fsuid</code>字段设置为<code>0</code>时(或者通过调用表20-2中的一个系统调用，或者通过执行超级用户所拥有的setuid程序)，内核就设置进程的所有权能，以便使所有的检查成功。</p>
<p>​    类似地，当进程把<code>euid</code>和<code>fsuid</code>字段重新置为进程拥有者的实际<code>UID</code>时，内核检查进程描述符中的<code>keep_capabilities</code>标志，并在该标志设置时删除进程的所有权能。进程可以调用<code>Linux</code>专有的<code>prctl()</code>系统调用来设置和重新设置<code>keep_capabilities</code>标志。</p>
<h3 id="Linux安全模块框架"><a href="#Linux安全模块框架" class="headerlink" title="Linux安全模块框架"></a>Linux安全模块框架</h3><p>在<code>Linux 2.6</code>中，权能是与<code>Linux</code>安全模块(<code>LSM</code>)框架紧密结合在一起的。<br>简单地说，<code>LSM</code>框架允许开发人员定义几种可以选择的内核安全模型。每个安全模型是由一组安全钩(<code>security hook</code>)实现的。安全钩是由内核调用的一个函数，用于执行与安全有关的重要操作。</p>
<p>钩函数决定一个操作是否可以执行。钩函数存放在<code>security_operations</code>类型的表中。当前使用的安全模型钩表地址存放在<code>security_ops</code>变量中。内核默认使用<code>dummy_security_ops</code>表实现最小安全模型。</p>
<p>表中的每个钩函数实际上去检查相应的权能(如果有)是否允许，否则无条件返回0(允许操作)。例如，<code>stime()</code>和<code>settimeofday()</code>函数的服务例程在改变系统日期时间之前调用<code>settime</code>安全钩。<code>durmmy_security_ops</code>表指向相应的函数，而该函数约束自己去检查当前进程是否有<code>CAP_SYS_TIME</code>的权能，并相应地返回<code>0</code>或者<code>-EPERM</code>。</p>
<h2 id="命令行参数和shell环境"><a href="#命令行参数和shell环境" class="headerlink" title="命令行参数和shell环境"></a>命令行参数和shell环境</h2><p>​    当用户键入一个命令时，为满足这个请求而装入的程序可以从<code>shell</code>接收一些命令行参数(<code>command-line argument</code>)。<br>例如，当用户键入命令：</p>
<pre class="line-numbers language-none"><code class="language-none">$ ls -l &#x2F;usr&#x2F;bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    以获得在<code>/usr/bin</code>目录下的全部文件列表时，<code>shell</code>进程创建一个新进程执行这个命令。<br>这个新进程装入<code>/bin/ls</code>可执行文件。在这样做的过程中，从<code>shell</code>继承的大多数执行上下文被丢弃，但三个单独的参数<code>ls</code>、<code>-l</code>和<code>/usr/bin</code>依然保持。一般情况下，新进程可以接收任意多个参数。<br>传递命令行参数的约定依赖于所用的高级语言。在<code>C</code>语言中，程序的<code>main()</code>函数把传递给程序的参数个数和指向字符串指针数组的地址作为参数。下列原型形式化地表示了这种标准格式：<code>int main(int argc,char *argv[])</code></p>
<p>​    在C语言中，传递给<code>main()</code>函数的第三个可选参数是包含环境变量的参数。环境变量用来定制进程的执行上下文，由此为用户或其他进程提供通用的信息，或者允许进程在执行<code>execve()</code>系统调用的过程中保持一些信息。为了使用环境变量，<code>main()</code>可以声明如下：<code>int main(int argc, char *argv[], char *envp[])</code></p>
<p>​    <code>envp</code>参数指向环境串的指针数组，形式如下：<code>VAR_NAME=something</code>这里，<code>VAR_NAME</code>表示一个环境变量的名字，而<code>“=”</code>后面的子串表示赋给变量的实际值。<code>envp</code>数组的结尾用一个空指针标记，就像<code>argv</code>数组。<code>envp</code>数组的地址存放在<code>C</code> 库的<code>environ</code>全局变量中。命令行参数和环境串都存放在用户态堆栈中，正好位于返回地址之前。图<code>20-1</code>显示了用户态堆栈的底部单元。注意，环境变量位于栈底附近正好在一个<code>0</code>长整数之后。</p>
<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>每个高级语言的源码文件都是经过几个步骤才转化为目标文件的，目标文件中包含的是汇编语言指令的机器代码，它们和相应的高级语言指令对应。目标文件并不能被执行，因为它不包含源代码文件所用的全局外部符号名的线性地址(例如库函数或同一程序中的其他源代码文件)。这些地址的分配或解析是由链接程序完成的，链接程序把程序所有的目标文件收集起来并构造可执行文件。链接程序还分析程序所用的库函数，并以本章后面所描述的方式把它们粘合成可执行文件。<br><img src=".\cc78a214d4e849539fd062507e64e649.png" alt="在这里插入图片描述"></p>
<p>大多数程序，甚至是最小的程序都会利用C库。例如，请看下面只有一行的C程序：<code>void main(void)&#123;&#125;</code><br>尽管这个程序没有做任何事情，但还是需要做很多工作来建立执行环境，并在程序终止时杀死这个进程。尤其是当<code>main()</code>函数终止时，<code>C</code>编译程序把<code>exit_group()</code>函数插入到目标代码中。从第十章我们知道，程序通常通过<code>C</code>库中的封装例程调用系统调用。<code>C</code>编译器亦如此。任何可执行文件除了包括对程序的语句进行编译所直接产生的代码外，还包括一些“粘合”代码来处理用户态进程与内核之间的交互。这样的粘合代码有一部分存放在<code>C</code>库中。除了<code>C</code>库，<code>Unix</code>系统中还包含很多其他的函数库。一般的<code>Linux</code>系统通常就有几百个不同的库。这里仅仅列举其中的两个：数学库<code>libm</code>包含浮点操作的基本函数，而<code>X11</code>库<code>libX1l</code>收集了所有<code>X11</code>窗口系统图形接口的基本底层函数。</p>
<p>传统<code>Unix</code>系统中的所有可执行文件都是基于静态库(<code>static library</code>)的。这就意味着链接程序所产生的可执行文件不仅包括原程序的代码，还包括程序所引用的库函数的代码。静态库的一大缺点是：它们占用大量的磁盘空间。的确，每个静态链接的可执行文件都复制库代码的某些部分。</p>
<p><strong>现代<code>Unix</code>系统利用共享库(<code>shared library</code>)。可执行文件不用再包含库的目标代码，而仅仅指向库名。当程序被装入内存执行时，一个名为动态链接器(<code>dynamic linker</code>，也叫<code>ld.so</code>)的程序就专注于分析可执行文件中的库名，确定所需库在系统目录树中的位置，并使执行进程可以使用所请求的代码。进程也可以使用<code>dlopen()</code>库函数在运行时装入额外的共享库。</strong></p>
<p>共享库对提供文件内存映射的系统尤为方便，因为它们减少了执行一个程序所需的主内存量。当动态链接程序必须把某一共享库链接到进程时，并不拷贝目标代码，而是仅仅执行一个内存映射，把库文件的相关部分映射到进程的地址空间中。这就允许共享库机器代码所在的页框被使用同一代码的所有进程共享。显然，如果程序是静态链接的，那么共享是不可能的。共享库也有一些缺点。动态链接的程序启动时间通常比静态链接的程序长。此外，动态链接的程序的可移植性也不如静态链接的好，因为当系统中所包含的库版本发生变化时，动态链接的程序运行时就可能出现问题。用户可以始终请求一个程序被静态地链接。例如，<code>GCC</code>编译器提供<code>-static</code>选项，即告诉链接程序使用静态库而不是共享库。</p>
<h3 id="程序段和进程的线性区"><a href="#程序段和进程的线性区" class="headerlink" title="程序段和进程的线性区"></a>程序段和进程的线性区</h3><p>从逻辑上说，<code>Unix</code>程序的线性地址空间传统上被划分为几个叫做段(<code>segment</code>)的区间：<br>正文段，包含程序的可执行代码。<br>已初始化数据段，包含已初始化的数据，也就是初值存放在可执行文件中的所有静态变量和全局变量(因为程序在启动时必须知道它们的值)。<br>未初始化数据段(bss段)，包含未初始化的数据，也就是初值没有存放在可执行文件中的所有全局变量(因为程序在引用它们之前才赋值)；历史上把这个段叫做bss段。<br>堆栈段，包含程序的堆栈，堆栈中有返回地址、参数和被执行函数的局部变量。</p>
<p>每个<code>mm_struct</code>内存描述符都包含一些字段来标识相应进程特定线性区的作用：<br><code>start_code, end_code</code>，程序的源代码所在线性区的起始和终止线性地址，即可执行文件中的代码<br><code>start_data, end_data</code>，程序的初始化数据所在线性区的起始和终止线性地址，正如在可执行文件中所指定的那样。这两个字段指定的线性区大体上与数据段对应。<br><code>start_brk, brk</code>，存放线性区的起始和终止线性地址，该线性区包含动态分配给进程的内存区。有时把这部分线性区叫做堆(<code>heap</code>)。<br><code>start_stack</code>，正好在<code>main()</code>的返回地址之上的地址。如图20-1所示，更高的地址被保留(回想一下，栈是向低地址增长)。<br><code>arg_start, arg_end</code>，命令行参数所在的堆栈部分的起始地址和终止地址。<br><code>env_start, env_end</code>，环境串所在的堆栈部分的起始地址和终止地址。</p>
<h3 id="灵活线性区布局"><a href="#灵活线性区布局" class="headerlink" title="灵活线性区布局"></a>灵活线性区布局</h3><p>灵活线性区布局(<code>flexible memory region lagout</code>)在内核版本<code>2.6.9</code>中引入：实际上，每个进程是按照用户态堆栈预期的增长量来进行内存布局的。但是仍然可以使用老的经典布局(主要用于：当内核无法限制进程用户态堆栈的大小时)。</p>
<p>表<code>20-4</code>以<code>80x86</code>结构的默认用户态地址空间为例描述了这两种布局，地址空间最大可以到<code>3GB</code>。</p>
<p>正如你所看到的，布局之间只在文件内存映射与匿名映射时线性区的位置上有区别。在经典布局下，这些区域从整个用户态地址空间的<code>1/3</code>开始，通常在地址<code>0x40000000</code>。新的区域往更高线性地址追加，因此，这些区域往用户态堆栈方向扩展。</p>
<ul>
<li>正文段（ELF）：起自0X08048000</li>
<li>数据与BSS段：起自紧接正文段之后</li>
<li>堆：起自紧接数据与BSS之后</li>
<li>文件内存映射与匿名线性区：<ul>
<li>经典布局为0X40000000该地址对应于整个用户态地址空间的1/3处！库连续往高地址追加；</li>
<li>灵活的布局是紧接用户态堆栈，库连续往低地址追加！</li>
</ul>
</li>
<li>用户态堆栈起自：0XC00000000并向低地址增长 </li>
</ul>
<p>​    而相反的是，在灵活布局中，文件内存映射与匿名映射的线性区是紧接用户态堆栈尾的。新的区域往更低线性地址追加，因此，这些区域往堆的方向扩展。记住，堆栈也是连续往低地址追加的。当内核能通过<code>RLIMIT_STACK</code>资源限制来限定用户态堆栈的大小时，通常使用灵活布局。这个限制确定了为堆栈保留的线性地址空间大小。但是这个空间大小不能小于<code>128MB</code>或大于<code>2.5GB</code>。另外，如果<code>RLIMIT_STACK</code>资源限制设为无限(<code>infinity</code>)，或者系统管理员将<code>sysctl_legacy_va_layout</code>变量设为<code>1</code>(通过修改<code>/proc/sys/vm/legacy_va_layout</code> 文件或调用相应的<code>sysctl()</code>系统调用实现)，内核无法确定用户态堆栈的上限，就仍然使用经典线性区布局。</p>
<p>为什么引入灵活布局？<br>    其主要优点是可以允许进程更好地使用用户态线性地址空间。在经典布局中，堆的限制是小于<code>1GB</code>，而其他线性区可以使用到约<code>2GB</code>(要减去堆栈大小)。在灵活布局中，这些限制没有了，堆和其他线性区可以自由扩展，可以使用除了用户态堆栈和程序用固定大小的段以外的所有线性地址空间。现在，一个实用的小试验很有启发意义。让我们录入和编译下面的C程序；</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
include &lt;unistd.h&gt;
int main()
&#123;
	char cmd[32];
	brk((void *)0x8051000);
	sprintf(cmd, &quot;cat &#x2F;proc&#x2F;self&#x2F;maps&quot;);
	system(cmd);
	return 0;
&#125;
1234567891011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    实际上，程序将它的进程堆变大，然后在<code>/proc</code>特殊文件系统下读入<code>maps</code>文件，该文件产生进程自身的线性区清单。前两个十六进制数表示线性区的范围，后面是权限标志。最后面是线性区映射的文件的有关信息，如果有信息就是：文件内的开始偏移量、块设备号、索引节点号和文件名。请注意，列出的所有区域是由私有内存映射实现的(权限列的<code>p</code>字母)。这并不奇怪，因为这些线性区是只为进程提供数据而存在的。当执行指令时，进程可以修改这些线性区的内容，但是与它们相关的磁盘文件会保持不变。私有内存映射就具有如此作用。</p>
<p>从<code>0x8048000</code>开始的线性区是与<code>/tmp/memorylayout</code>文件的<code>0～4095</code>字节部分对应的内存映射。而相应的权限表示是可执行的(它包含了目标代码)、只读的(因为指令在执行期间是不改变的，因此不可写)和私有的。这很正确，这是程序正文段的映射区域。从<code>0x8049000</code>开始的线性区也是与<code>/tmp/memorylayout</code>文件的<code>0～4095</code>字节部分对应的另一个内存映射。这个程序太小，以至于程序的正文、数据和<code>bss</code>段都在同一个文件页里。因此，包含数据段和<code>bss</code>段的线性区与上一个线性区在线性地址空间是重叠的。</p>
<p>第三个线性区包含进程的堆。注意，它在线性地址<code>0x8051000</code>处终止，传递给<code>brk()</code>系统调用的就是该地址。接下来从<code>0x40000000</code>和<code>0x40014000</code>开始的两个线性区，分别对应这个系统<code>ELF</code>共享库(<code>/lib/ld-2.3.2.so</code>)动态链接程序的正文段和数据、<code>bss</code>段。动态链接程序决不单独执行，它总是以内存映射的方式映射到执行其他程序的进程地址空间内。</p>
<p>从<code>0x40015000</code> 开始的匿名线性区已由动态链接程序分配。<br>在这个系统上，<code>C</code>库正好存放在文件<code>/lib/libc-2.3.2.so</code>中。<code>C</code>库的正文段和数据、<code>bss</code>段被映射到从<code>0x4002f000</code>地址开始的两个线性区。还记得私有区域所在的页框，只要没被修改，就可以通过写时复制机制在几个进程间共享。因此，因为正文段是只读的，所示包含<code>C</code>库执行代码的页框几乎在所有当前运行进程间共享(除了静态链接程序)。</p>
<p>从<code>0x4015b000</code>开始的匿名线性区已由<code>C</code>库分配。<br>从<code>0xbffeb000</code>到<code>0xc0000000</code>的匿名内存区对应于用户态堆栈。我们在第九章“缺页异常处理程序”一节已讨论过堆栈是如何在必要时自动地向低地址方向扩展的。<br>最后，从<code>0xffffe000</code>开始的单页匿名线性区包含进程的<code>vsyscall</code>页，当发出系统调用和从信号处理程序返回时会访问该区域。</p>
<h3 id="执行跟踪"><a href="#执行跟踪" class="headerlink" title="执行跟踪"></a>执行跟踪</h3><p>执行跟踪(<code>execution tracing</code>)是一个程序监视另一个程序执行的一种技术。被跟踪的程序一步一步地执行，直到接收到一个信号或调用一个系统调用。执行跟踪由调试程序(<code>debugger</code>)广泛使用，当然还使用其他技术(包括在被调试程序中插入断点及运行时访问它的变量)。与往常一样，我们将集中讨论内核怎样支持执行跟踪，而不讨论调试程序怎样工作。在<code>Linux</code>中，通过<code>ptrace()</code>系统调用进行执行跟踪，这个系统调用能处理如表<code>20-5</code>所示的命令。设置了<code>CAP_SYS_PTRACE</code>权能的进程可以跟踪系统中的任何进程(除了<code>init</code>)。相反，没有<code>CAP_SYS_PTRACE</code>权能的进程<code>P</code>只能跟踪与<code>P</code>有相同属主的进程。此外，两个进程不能同时跟踪一个进程。</p>
<p><code>ptrace()</code>系统调用修改被跟踪进程描述符的<code>parent</code>字段以使它指向跟踪进程，因此，跟踪进程变为被跟踪进程的有效父进程。当执行跟踪终止时，也就是当以<code>PTRACE_DETACH</code>命令调用<code>ptrace()</code>时，这个系统调用把<code>p_pptr</code>设置为<code>real_parent</code> 的值，恢复被跟踪进程原来的父进程。与被跟踪程序相关的几个监控事件为：</p>
<blockquote>
<ol>
<li>一条单独汇编指令执行的结束</li>
<li>进入系统调用</li>
<li>退出系统调用</li>
<li>接收到一个信号</li>
</ol>
</blockquote>
<p>​    当一个监控的事件发生时，被跟踪的程序停止，并且将<code>SIGCHID</code>信号发送给它的父进程。</p>
<p>​    当父进程希望恢复子进程的执行时，就使用<code>PTRACE_CONT</code>、<code>PTRACE_SINGLESTEP</code> 和<code>PTRACE_SYSCALL</code>命令中的一条命令，这取决于父进程要监控哪种事件。</p>
<ul>
<li><code>PTRACE_CONT</code>命令只继续执行，子进程将一直执行到收到另一个信号。这种跟踪是通过进程描述符的<code>ptrace</code>字段中的<code>PF_PTRACED</code>标志实现的，而这个标志的检查是由<code>do_signal()</code>函数进行的。</li>
<li><code>PTRACE_SINGLESTEP</code>命令强迫子进程执行下一条汇编语言指令，然后又停止它。这种跟踪是基于<code>80×86</code>机器的<code>eflags</code>寄存器的<code>TF</code>陷阱标志而实现的。当这个标志为<code>1</code>时，在任一条汇编语言指令之后正好产生一个“<code>Debug</code>”异常。相应的异常处理程序只是清掉这个标志，强迫当前进程停止，并发送<code>SIGCHLD</code>信号给父进程。注意，设置<code>TF</code>标志并不是特权操作，因此用户态进程即使在没有<code>ptrace()</code>系统调用的情况下，也能强迫单步执行。内核检查进程描述符中的<code>PT_DTRACE</code>标志，以跟踪子进程是否通过<code>ptrace()</code>进行单步执行。</li>
<li><code>PTRACE_SYSCALL</code>命令使被跟踪的进程重新恢复执行，直到一个系统调用被调用。进程停止两次，第一次是在系统调用开始时，第二次是在系统调用终止时。这种跟踪是利用进程描述符中的<code>TIF_SYSCALL_TRACE</code>标志实现的。这个标志是在进程<code>thread_info</code> 结构的<code>flags</code>字段中，并在<code>system_call()</code>汇编语言的函数中被检查。</li>
</ul>
<p>​    也可以利用<code>Intel Pentium</code>处理器的一些调试特点来跟踪进程。例如，父进程使用<code>PTRACE_POKEUSR</code>命令为子进程设置<code>dr0,…,dr7</code>调试寄存器的值。当由某调试寄存器监控的事情发生时，<code>CPU</code>产生“<code>Debug</code>”异常，异常处理程序然后挂起被调试的进程并给父进程发送<code>SIGCHLD</code>信号。</p>
<h3 id="可执行格式"><a href="#可执行格式" class="headerlink" title="可执行格式"></a>可执行格式</h3><p><code>Linux</code>标准的可执行格式是<code>ELF</code>(<code>Executable and Linking Format</code>)。</p>
<p>Linux支持很多其他不同格式的可执行文件。在这种方式下，<code>Linux</code>能运行为其他操作系统所编译的程序，如<code>MS-DOS</code>的<code>EXE</code>程序。有几种可执行格式，如<code>Java</code>或<code>bash</code>脚本，是与平台无关的。</p>
<p>由类型为<code>linux_binfmt</code>的对象所描述的可执行格式实质上提供以下三种方法：<br><code>load_binary</code>，通过读存放在可执行文件中的信息为当前进程建立一个新的执行环境。<br><code>load_shlib</code>，用于动态地把一个共享库捆绑到一个已经在运行的进程，这是由<code>uselib()</code>系统调用激活的。<br><code>core_dump</code>，在名为<code>core</code>的文件中存放当前进程的执行上下文。这个文件通常是在进程接收到一个缺省操作为“<code>dump</code>”的信号时被创建的，其格式取决于被执行程序的可执行类型。</p>
<p>所有的<code>linux_binfmt</code>对象都处于一个单向链表中，第一个元素的地址存放在<code>formats</code> 变量中。<br>在系统启动期间，为每个编译进内核的可执行格式都执行<code>register_binfmt()</code>函数。当实现了一个新的可执行格式的模块正被装载时，也执行这个函数，当模块被卸载时，执行<code>unregister_binfmt()</code>函数。</p>
<p>在<code>formats</code>链表中的最后一个元素总是对解释脚本(<code>interpreted script</code>)的可执行格式进行描述的一个对象。这种格式只定义了<code>load_binary</code>方法。其相应的<code>load_script()</code>函数检查这种可执行文件是否以两个<code>#!</code>字符开始。如果是，这个函数就把第一行的其余部分解释为另一个可执行文件的路径名，并把脚本文件名作为参数传递以执行它。</p>
<pre class="line-numbers language-none"><code class="language-none">Linux&#96;允许用户注册自己定义的可执行格式。对这种格式的识别或者通过存放在文件前&#96;128&#96;字节的魔数，或者通过表示文件类型的扩展名。当内核确定可执行文件是自定义格式时，它就启动相应的解释程序(&#96;interpreterprogram&#96;)。解释程序运行在用户态，读入可执行文件的路径名作为参数，并执行计算。例如，包含&#96;Java&#96;程序的可执行文件就由&#96;Java&#96;虚拟机(如&#96;&#x2F;usr&#x2F;lib&#x2F;java&#x2F;bin&#x2F;java&#96;)来解释。这种机制与脚本格式类似，但功能更加强大，这是因为它对自定义格式不加任何限制。要注册一个新格式，就必须在&#96;binfmt_misc&#96;特殊文件系统(通常&#96;&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc&#96;)的注册文件内写入一个字符串，其格式如下：&#96;:name:type:offset:string:mask:interpreter;flags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="执行域"><a href="#执行域" class="headerlink" title="执行域"></a>执行域</h3><p>​    <code>Linux</code>的一个巧妙的特点就是能执行其他操作系统所编译的程序。当然，只有内核运行的平台与可执行文件包含的机器代码对应的平台相同时这才是可能的。对这些“外来”程序提供两种支持：</p>
<ol>
<li>模拟执行(<code>emulated execution</code>)：程序中包含的系统调用与POSIX不兼容时才有必要执行这种程序。</li>
<li>原样执行(<code>native execution</code>)：只有程序中所包含的系统调用完全与POSIX兼容时才有效。 </li>
</ol>
<p>​    Microsoft MS-DOS和Windows程序是被模拟执行的，因为它们包含的API不能被Linux 所认识，因此不能原样执行。像DOSemu或Wine这样的模拟程序被调用来把每个API调用转换为一个模拟的封装函数调用，而封装函数调用又使用现有的Linux系统调用。因为模拟程序主要是作为用户态的应用程序来执行，因此我们在此不做进一步的讨论。</p>
<p>另一方面，不用太费力就可以执行为其他操作系统编译的与POSIX兼容的程序，因为与POSIX兼容的操作系统都提供了类似的API(尽管实际上并不总是这种情况，但API应该相同)。内核必须消除的细微差别通常涉及如何调用系统调用或如何给各种信号编号。这种信息存放在类型为exec_domain的执行域描述符(execution domain descriptor)中。进程可以指定它的执行域，这是通过设置进程描述符的personality字段，以及把相应exec_domain数据结构的地址存放到thread_info结构的exec_domain字段来实现的。进程可以通过发布一个叫做personality()的系统调用来改变它的个性(personality)；</p>
<h2 id="exec函数"><a href="#exec函数" class="headerlink" title="exec函数"></a>exec函数</h2><p><code>Unix</code>系统提供了一系列函数，这些函数能用可执行文件所描述的新上下文代替进程的上下文。这样的函数名以前缀<code>exec</code>开始，后跟一个或两个字母，因此，家族中的一个普通函数被当作<code>exec</code>函数来引用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>路径搜索</th>
<th>命令行参数</th>
<th>环境数组</th>
</tr>
</thead>
<tbody>
<tr>
<td>execl</td>
<td>否</td>
<td>列表</td>
<td>否</td>
</tr>
<tr>
<td>execlp</td>
<td>是</td>
<td>列表</td>
<td>否</td>
</tr>
<tr>
<td>execle</td>
<td>否</td>
<td>列表</td>
<td>是</td>
</tr>
<tr>
<td>execv</td>
<td>否</td>
<td>数组</td>
<td>否</td>
</tr>
<tr>
<td>execvp</td>
<td>是</td>
<td>数组</td>
<td>否</td>
</tr>
<tr>
<td>execve</td>
<td>否</td>
<td>数组</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<p>​    每个函数的第一个参数表示被执行文件的路径名。路径名可以是绝对路径或是当前进程目录的相对路径。此外，如果路径名中不包含<code>“/”</code>字符，<code>execlp()</code>和<code>execvp()</code>函数就在<code>PATH</code>环境变量指定的所有目录中搜索这个可执行文件。除了第一个参数，<code>execl()、execlp()</code>和<code>execle()</code>函数包含的其他参数个数都是可变的。每个参数指向一个字符串，这个字符串是对新程序命令行参数的描述，正如函数名中<code>“l</code>”字符所隐含的一样，这些参数组织成一个列表(最后一个值为<code>NULL</code>)。</p>
<p>通常情况下，第一个命令行参数复制可执行文件名。相反，<code>execv()、execvp()</code>和<code>execve()</code>函数指定单个参数的命令行参数，正如函数名中的<code>“v”</code>字符所隐含的一样，这单个参数是指向命令行参数串的指针向量地址。数组的最后一个元素必须存放<code>NULL</code>值。</p>
<p><code>execle()</code>和<code>execve()</code>函数的最后一个参数是指向环境串的指针数组的地址；数组的最后一个元素照样必须为<code>NULL</code>。其他函数对新程序环境参数的访问是通过<code>C</code>库定义的外部全局变量<code>environ</code>进行的。</p>
<p>所有的<code>exec</code>函数(除<code>execve()</code>外)都是C库定义的封装例程，并利用了<code>execve()</code>系统调用，这是<code>Linux</code>所提供的处理程序执行的唯一系统调用。</p>
<p><code>sys_execve()</code>服务例程接收下列参数：<br>(1). 可执行文件路径名的地址(在用户态地址空间)。<br>(2). 以NULL结束的字符串指针数组的地址(在用户态地址空间)。每个字符串表示一个命令行参数。<br>(3). 以NULL结束的字符串指针数组的地址(也在用户态地址空间)。每个字符串以NAME=value形式表示一个环境变量。</p>
<p><code>sys_execve()</code>把可执行文件路径名拷贝到一个新分配的页框。<br>然后调用<code>do_execve()</code>函数，传递给它的参数为指向这个页框的指针、指针数组的指针及把用户态寄存器内容保存到内核态堆栈的位置。</p>
<p><code>do_execve()</code>依次执行下列操作：</p>
<ol>
<li><p>动态地分配一个<code>linux_binprm</code>数据结构，并用新的可执行文件的数据填充这个结构</p>
</li>
<li><p>调用<code>path_lookup()、dentry_open()</code>和<code>path_release()</code>，以获得与可执行文件相关的目录项对象、文件对象和索引节点对象。如果失败，则返回相应的错误码。</p>
</li>
<li><p>检查是否可以由当前进程执行该文件，再检查索引节点的<code>i_writecount</code>字段，以确定可执行文件没被写入；把<code>-1</code>存放在这个字段以禁止进一步的写访问。</p>
</li>
<li><p>在多处理器系统中，调用<code>sched_exec()</code>函数来确定最小负载<code>CPU</code>以执行新程序，并把当前进程转移过去。</p>
</li>
<li><p>调用<code>init_new_context()</code>检查当前进程是否使用自定义局部描述符表)。如果是，函数为新程序分配和准备一个新的<code>LDT</code>。</p>
</li>
<li><p>调用<code>prepare_binprm()</code>函数填充<code>linux_binprm</code>数据结构，这个函数又依次执行下列操作：</p>
<blockquote>
<ol>
<li>再一次检查文件是否可执行(至少设置一个执行访问权限)。如果不可执行，则返回错误码(因为带有<code>CAP_DAC_OVERRIDE</code>权能的进程总能通过检查，所以第<code>3</code>步中的检查还不够。)。</li>
<li>初始化<code>linux_binprm</code>结构的<code>e_uid</code>和<code>e_gid</code>字段，考虑可执行文件的<code>setuid</code>和<code>setgid</code>标志的值。这些字段分别表示有效的用户<code>ID</code>和组<code>ID</code>。也要检查进程的权能。</li>
<li>用可执行文件的前<code>128</code>字节填充<code>linux_binprm</code>结构的<code>buf</code>字段。这些字节包含的是适合于识别可执行文件格式的一个魔数和其他信息。</li>
</ol>
</blockquote>
</li>
<li><p>把文件路径名、命令行参数及环境串拷贝到一个或多个新分配的页框中(最终，它们会被分配给用户态地址空间)。</p>
</li>
<li><p>调用<code>search_binary_handler()</code>函数对<code>formats</code>链表进行扫描，并尽力应用每个元素的<code>load_binary</code>方法，把<code>linux_binprm</code>数据结构传递给这个函数。只要<code>load_binary</code>方法成功应答了文件的可执行格式，对<code>formats</code>的扫描就终止。</p>
</li>
<li><p>如果可执行文件格式不在<code>formats</code>链表中，就释放所分配的所有页框并返回错误码<code>-ENOEXEC</code>，表示<code>Linux</code>不认识这个可执行文件格式。</p>
</li>
<li><p>否则，函数释放<code>linux_binprm</code>数据结构，返回从这个文件可执行格式的<code>load_binary</code>方法中所获得的代码。</p>
</li>
</ol>
<p>可执行文件格式对应的<code>load_binary</code>方法执行下列操作(我们假定这个可执行文件所在的文件系统允许文件进行内存映射并需要一个或多个共享库)：</p>
<ol>
<li><p>检查存放在文件前<code>128</code>字节中的一些魔数以确认可执行格式。如果魔数不匹配，则返回错误码<code>-ENOEXEC</code>。</p>
</li>
<li><p>读可执行文件的首部。这个首部描述程序的段和所需的共享库。</p>
</li>
<li><p>从可执行文件获得动态链接程序的路径名，并用它来确定共享库的位置并把它们映射到内存。</p>
</li>
<li><p>获得动态链接程序的目录项对象(也就获得了索引节点对象和文件对象)。</p>
</li>
<li><p>检查动态链接程序的执行许可权。</p>
</li>
<li><p>把动态链接程序的前<code>128</code>字节拷贝到缓冲区。</p>
</li>
<li><p>对动态链接程序类型执行一些一致性检查。</p>
</li>
<li><p>调用<code>flush_old_exec()</code>函数释放前一个计算所占用的几乎所有资源。这个函数又依次执行下列操作：</p>
<blockquote>
<ol>
<li>如果信号处理程序的表为其他进程所共享，那么就分配一个新表并把旧表的引用计数器减<code>1</code>；而且它将进程从旧的线程组脱离。这是通过调用<code>de_thread()</code>函数完成的。</li>
<li>如果与其他进程共享，就调用<code>unshare_files()</code>函数拷贝一份包含进程已打开文件的<code>files_struct</code>结构。</li>
<li>调用<code>exec_mmap()</code>函数释放分配给进程的内存描述符、所有线性区及所有页框，并清除进程的页表。</li>
<li>将可执行文件路径名赋给进程描述符的<code>comm</code>字段。</li>
<li>调用<code>flush_thread()</code>函数清除浮点寄存器的值和在<code>TSS</code>段保存的调试寄存器的值。</li>
<li>调用<code>flush_signal_handlers()</code>函数，用于将每个信号恢复为默认操作，从而更新信号处理程序的表。</li>
<li>调用<code>flush_old_files()</code>函数关闭所有打开的文件，这些打开的文件在进程描述符的<code>files-&gt;close_on_exec</code>字段设置了相应的标志。现在，我们已经不能返回了：如果真出了差错，这个函数再不能恢复前一个计算。</li>
</ol>
</blockquote>
</li>
<li><p>清除进程描述符的<code>PF_FORKNOEXEC</code>标志。这个标志用于在进程创建时设置进程记账，在执行一个新程序时清除进程记账。</p>
</li>
<li><p>设立进程新的个性，即设置进程描述符的<code>personality</code>字段</p>
</li>
<li><p>调用<code>arch_pick_mmap_layout()</code>，以选择进程线性区的布局。</p>
</li>
<li><p>调用<code>setup_arg_pages()</code>函数为进程的用户态堆栈分配一个新的线性区描述符，并把那个线性区插入到进程的地址空间。<code>setup_arg_pages()</code>还把命令行参数和环境变量串所在的页框分配给新的线性区。</p>
</li>
<li><p>调用<code>do_mmap()</code>函数创建一个新线性区来对可执行文件正文段(即代码)进行映射。这个线性区的起始线性地址依赖于可执行文件的格式，因为程序的可执行代码通常是不可重定位的。因此，这个函数假定从某一特定逻辑地址的偏移量开始(因此就从某一特定的线性地址开始)装入正文段。<code>ELF</code>程序被装入的起始线性地址为<code>0x08048000</code>。</p>
</li>
<li><p>调用<code>do_mmap()</code>函数创建一个新线性区来对可执行文件的数据段进行映射。这个线性区的起始线性地址也依赖于可执行文件的格式，因为可执行代码希望在特定的偏移量(即特定的线性地址)处找到它自己的变量。在<code>ELF</code>程序中，数据段正好被装在正文段之后。</p>
</li>
<li><p>为可执行文件的其他专用段分配另外的线性区，通常是无。</p>
</li>
<li><p>调用一个装入动态链接程序的函数。如果动态链接程序是<code>ELF</code>可执行的，这个函数就叫做<code>load_elf_interp()</code>。<br>一般情况下，这个函数执行第<code>12～14</code>步的操作，不过要用动态链接程序代替被执行的文件。动态链接程序的正文段和数据段在线性区的起始线性地址是由动态链接程序本身指定的；但它们处于高地址区(通常高于<code>0x40000000</code>)，这是为了避免与被执行文件的正文段和数据段所映射的线性区发生冲突。</p>
</li>
<li><p>把可执行格式的<code>linux_binfmt</code>对象的地址存放在进程描述符的<code>binfmt</code>字段中。</p>
</li>
<li><p>确定进程的新权能。</p>
</li>
<li><p>创建特定的动态链接程序表并把它们存放在用户态堆栈，如图<code>20-1</code>所示，这些表处于命令行参数和指向环境串的指针数组之间。</p>
</li>
<li><p>设置进程的内存描述符的<code>start_code、end_code、start_data 、end_data、start_brk、brk</code>及<code>start_stack</code>字段。</p>
</li>
<li><p>调用<code>do_brk()</code>函数创建一个<code>新的匿名线性区</code>来映射程序的<code>bss</code>段(当进程写入一个变量时，就触发请求调页，进而分配一个页框)。这个线性区的大小是在可执行程序被链接时就计算出来的。因为程序的可执行代码通常是不可重新定位的，因此，必须指定这个线性区的起始线性地址。在<code>ELF</code>程序中，<code>bss</code>段正好装在<code>数据段之后</code>。</p>
</li>
<li><p>调用<code>start_thread()</code>宏修改保存在内核态堆栈但属于用户态寄存器的<code>eip</code>和<code>esp</code>的值，以使它们分别指向动态链接程序的入口点和新的用户态堆栈的栈顶。</p>
</li>
<li><p>如果进程正被跟踪，就通知调试程序<code>execve()</code>系统调用已完成。</p>
</li>
<li><p>返回<code>0</code>值(成功)。</p>
</li>
</ol>
<p>​    当<code>execve()</code>系统调用终止且调用进程重新恢复它在用户态的执行时，执行上下文被大幅度改变，调用系统调用的代码不复存在。<br>​    从这个意义上看，我们可以说<code>execve()</code>从未成功返回。取而代之的是，要执行的新程序已被映射到进程的地址空间。但是，新程序还不能执行，因为动态链接程序还必须考虑共享库的装载。尽管动态链接程序运行在用户态，但我们还要在这里简要概述一下它是如何运作的。</p>
<p>​    它的第一个工作就是从内核保存在用户态堆栈的信息(处于环境串指针数组和<code>arg_start</code> 之间)开始，为自己建立一个基本的执行上下文。然后，动态链接程序必须检查被执行的程序，以识别哪个共享库必须装入及在每个共享库中哪个函数被有效地请求。接下来，解释器发出几个<code>mmap()</code>系统调用来创建线性区，以对将存放程序实际使用的库函数(正文和数据)的页进行映射。然后，解释器根据库的线性区的线性地址更新对共享库符号的所有引用。最后，动态链接程序通过跳转到被执行程序的主入口点而终止它的执行。从现在开始，进程将执行可执行文件的代码和共享库的代码。</p>
<p>​    你可能已注意到，执行程序是一个相当复杂的活动，它涉及内核设计的很多方面，如进程抽象、内存管理、系统调用及文件系统。这会使你认识到：<code>Linux</code>真是一个杰作!</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2024/05/03/Linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%A8%E9%9B%86/">http://charliechen114514.github.io/2024/05/03/Linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%85%A8%E9%9B%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Operating-System/">Operating System</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/05/How-My-Arch-Linux-StartUp/" title="How My Arch Linux StartUp"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">How My Arch Linux StartUp</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/03/Linux-%E5%86%85%E6%A0%B8-Linux%E7%AE%80%E5%8D%95%E7%AE%80%E5%8F%B2%E4%B8%8E%E6%A6%82%E8%AE%BA/" title="Linux-内核-Linux简单简史与概论"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux-内核-Linux简单简史与概论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/03/Linux-%E5%86%85%E6%A0%B8-Linux%E7%AE%80%E5%8D%95%E7%AE%80%E5%8F%B2%E4%B8%8E%E6%A6%82%E8%AE%BA/" title="Linux-内核-Linux简单简史与概论"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">Linux-内核-Linux简单简史与概论</div></div></a></div><div><a href="/2024/04/03/Linux%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E5%BC%95%E8%AE%BA%EF%BC%89/" title="Linux深度学习教程（引论）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">Linux深度学习教程（引论）</div></div></a></div><div><a href="/2024/07/27/Linux%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E4%B8%8ESystemd/" title="Linux进程启动与Systemd"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-27</div><div class="title">Linux进程启动与Systemd</div></div></a></div><div><a href="/2024/07/30/Linux-Debug%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" title="Linux Debug学习之路"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-30</div><div class="title">Linux Debug学习之路</div></div></a></div><div><a href="/2024/01/19/Linux%E6%BC%AB%E6%B8%B8%E5%90%88%E9%9B%86/" title="Linux漫游合集"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-19</div><div class="title">Linux漫游合集</div></div></a></div><div><a href="/2024/01/17/MITS6081-Notes/" title="MITS6081 Notes"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-17</div><div class="title">MITS6081 Notes</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">上传了一些在CSDN和博客园写的博客(喜),甚至更换了背景图(喜x2)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E5%86%85%E6%A0%B8%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">Linux 内核深入理解 - 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.0.1.</span> <span class="toc-text">多用户系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.2.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="toc-number">1.0.3.</span> <span class="toc-text">内核体系架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">文件系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Base"><span class="toc-number">1.1.1.</span> <span class="toc-text">Base</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">硬链接和软链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unix%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">Unix文件类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">文件描述符与索引节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">文件操作的系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unix%E5%86%85%E6%A0%B8%E7%AE%80%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Unix内核简述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">进程的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%86%85%E6%A0%B8"><span class="toc-number">1.2.2.</span> <span class="toc-text">可重入内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.3.</span> <span class="toc-text">进程地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">1.2.4.</span> <span class="toc-text">同步和临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.5.</span> <span class="toc-text">信号与进程之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.6.</span> <span class="toc-text">进程管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.7.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">虚拟内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.8.</span> <span class="toc-text">随机访问存储器的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">1.2.9.</span> <span class="toc-text">内核分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-number">1.2.10.</span> <span class="toc-text">进程的虚拟地址空间处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.11.</span> <span class="toc-text">高速缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">2.</span> <span class="toc-text">内存寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%AE%BA%EF%BC%8C%E4%B8%89%E4%B8%AA%E5%9C%B0%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text">引论，三个地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%88%86%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">硬件中的分段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.2.1.</span> <span class="toc-text">段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%AE%BF%E9%97%AE%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.2.2.</span> <span class="toc-text">快速访问段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%8D%95%E5%85%83"><span class="toc-number">2.2.3.</span> <span class="toc-text">分段单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-GDT"><span class="toc-number">2.2.4.</span> <span class="toc-text">Linux GDT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-LDT"><span class="toc-number">2.2.5.</span> <span class="toc-text">Linux LDT</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5"><span class="toc-number">2.3.</span> <span class="toc-text">硬件中的分页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PAE"><span class="toc-number">2.4.</span> <span class="toc-text">PAE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">2.5.</span> <span class="toc-text">硬件高速缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLB"><span class="toc-number">2.6.</span> <span class="toc-text">TLB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5"><span class="toc-number">2.7.</span> <span class="toc-text">Linux中的分页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89pgd-t%E3%80%81pmd-t%E3%80%81pud-t%E5%92%8Cpte-t"><span class="toc-number">2.7.1.</span> <span class="toc-text">页表类型定义pgd_t、pmd_t、pud_t和pte_t</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pteval-t%EF%BC%8Cpmdval-t%EF%BC%8Cpudval-t%EF%BC%8Cpgdval-t"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">pteval_t，pmdval_t，pudval_t，pgdval_t</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pgd-t%E3%80%81pmd-t%E3%80%81pud-t%E5%92%8Cpte-t"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">pgd_t、pmd_t、pud_t和pte_t</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xxx-val%E5%92%8C-xxx"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">xxx_val和__xxx</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%8F%8F%E8%BF%B0%E5%AE%8F"><span class="toc-number">2.7.2.</span> <span class="toc-text">页表描述宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PAGE%E5%AE%8F%E2%80%93%E9%A1%B5%E8%A1%A8-Page-Table"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">PAGE宏–页表(Page Table)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PMD-Page-Middle-Directory-%E9%A1%B5%E7%9B%AE%E5%BD%95"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">PMD-Page Middle Directory (页目录)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUD-SHIFT-%E9%A1%B5%E4%B8%8A%E7%BA%A7%E7%9B%AE%E5%BD%95-Page-Upper-Directory"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">PUD_SHIFT-页上级目录(Page Upper Directory)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PGDIR-SHIFT-%E9%A1%B5%E5%85%A8%E5%B1%80%E7%9B%AE%E5%BD%95-Page-Global-Directory"><span class="toc-number">2.7.2.4.</span> <span class="toc-text">PGDIR_SHIFT-页全局目录(Page Global Directory)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.3.</span> <span class="toc-text">页表处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%A1%B5%E8%A1%A8%E9%A1%B9%E4%B8%AD%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E6%A0%87%E5%BF%97%E7%9A%84%E5%BD%93%E5%89%8D%E5%80%BC"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">查询页表项中任意一个标志的当前值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E8%AE%BE%E7%BD%AE%E9%A1%B5%E8%A1%A8%E9%A1%B9%E4%B8%AD%E5%90%84%E6%A0%87%E5%BF%97%E7%9A%84%E5%80%BC"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">2.3.2 设置页表项中各标志的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%87%BD%E6%95%B0-%E6%8A%8A%E4%B8%80%E4%B8%AA%E9%A1%B5%E5%9C%B0%E5%9D%80%E5%92%8C%E4%B8%80%E7%BB%84%E4%BF%9D%E6%8A%A4%E6%A0%87%E5%BF%97%E7%BB%84%E5%90%88%E6%88%90%E9%A1%B5%E8%A1%A8%E9%A1%B9%EF%BC%8C%E6%88%96%E8%80%85%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%8F%8D%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.7.3.3.</span> <span class="toc-text">宏函数-把一个页地址和一组保护标志组合成页表项，或者执行相反的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%92%A4%E6%B6%88"><span class="toc-number">2.7.3.4.</span> <span class="toc-text">简化页表项的创建和撤消</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%A1%AC%E4%BB%B6%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8ETLB"><span class="toc-number">2.8.</span> <span class="toc-text">处理硬件高速缓存与TLB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">3.</span> <span class="toc-text">Reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-1"><span class="toc-number">4.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.0.1.</span> <span class="toc-text">进程描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.0.2.</span> <span class="toc-text">标识一个进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%BB%87"><span class="toc-number">4.0.3.</span> <span class="toc-text">进程组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.0.4.</span> <span class="toc-text">进程之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.0.5.</span> <span class="toc-text">如何组织进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="toc-number">4.0.6.</span> <span class="toc-text">等待队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">进程资源限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">进程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">4.2.1.</span> <span class="toc-text">硬件上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-to%E5%AE%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">switch_to宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">创建进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#do-fork"><span class="toc-number">4.3.1.</span> <span class="toc-text">do_fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">内核进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">撤销有一个进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#do-group-exit"><span class="toc-number">4.4.1.</span> <span class="toc-text">do_group_exit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-exit%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.2.</span> <span class="toc-text">do_exit函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference-1"><span class="toc-number">5.</span> <span class="toc-text">Reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">6.</span> <span class="toc-text">中断与异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text">中断信号的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">6.2.</span> <span class="toc-text">中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IRQ%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">6.2.1.</span> <span class="toc-text">IRQ与中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">6.2.2.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">6.2.3.</span> <span class="toc-text">中断向量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">6.2.4.</span> <span class="toc-text">硬件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B5%8C%E5%A5%97%E6%89%A7%E8%A1%8C"><span class="toc-number">6.2.5.</span> <span class="toc-text">中断和异常处理程序的嵌套执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96IDT"><span class="toc-number">6.3.</span> <span class="toc-text">初始化IDT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">中断处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">中断描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0-irqaction"><span class="toc-number">6.4.1.2.</span> <span class="toc-text">响应函数 irqaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%95%B0%E6%8D%AE-irq-data"><span class="toc-number">6.4.1.3.</span> <span class="toc-text">中断数据 irq_data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%90%88%E9%9B%86-irq-chip"><span class="toc-number">6.4.1.4.</span> <span class="toc-text">操作合集 irq_chip</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%8CTasklet%E5%92%8CWork-Queue"><span class="toc-number">6.5.</span> <span class="toc-text">软中断，Tasklet和Work Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">6.5.1.</span> <span class="toc-text">软中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tasklet-API"><span class="toc-number">6.5.2.</span> <span class="toc-text">Tasklet API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tasklet-%E5%BE%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">6.5.3.</span> <span class="toc-text">tasklet 微线程的编程步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E"><span class="toc-number">6.5.4.</span> <span class="toc-text">从中断和异常返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference-2"><span class="toc-number">7.</span> <span class="toc-text">Reference</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8-1"><span class="toc-number">7.1.</span> <span class="toc-text">中断信号的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8-1"><span class="toc-number">7.2.</span> <span class="toc-text">中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IRQ%E4%B8%8E%E4%B8%AD%E6%96%AD-1"><span class="toc-number">7.2.1.</span> <span class="toc-text">IRQ与中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-1"><span class="toc-number">7.2.2.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8-1"><span class="toc-number">7.2.3.</span> <span class="toc-text">中断向量表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%A4%84%E7%90%86-1"><span class="toc-number">7.2.4.</span> <span class="toc-text">硬件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B5%8C%E5%A5%97%E6%89%A7%E8%A1%8C-1"><span class="toc-number">7.2.5.</span> <span class="toc-text">中断和异常处理程序的嵌套执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96IDT-1"><span class="toc-number">7.3.</span> <span class="toc-text">初始化IDT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86-1"><span class="toc-number">7.4.</span> <span class="toc-text">中断处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">7.4.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6-1"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">中断描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0-irqaction-1"><span class="toc-number">7.4.1.2.</span> <span class="toc-text">响应函数 irqaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%95%B0%E6%8D%AE-irq-data-1"><span class="toc-number">7.4.1.3.</span> <span class="toc-text">中断数据 irq_data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%90%88%E9%9B%86-irq-chip-1"><span class="toc-number">7.4.1.4.</span> <span class="toc-text">操作合集 irq_chip</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD%EF%BC%8CTasklet%E5%92%8CWork-Queue-1"><span class="toc-number">7.5.</span> <span class="toc-text">软中断，Tasklet和Work Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD-1"><span class="toc-number">7.5.1.</span> <span class="toc-text">软中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tasklet-API-1"><span class="toc-number">7.5.2.</span> <span class="toc-text">Tasklet API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tasklet-%E5%BE%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4%EF%BC%9A-1"><span class="toc-number">7.5.3.</span> <span class="toc-text">tasklet 微线程的编程步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E8%BF%94%E5%9B%9E-1"><span class="toc-number">7.5.4.</span> <span class="toc-text">从中断和异常返回</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference-3"><span class="toc-number">8.</span> <span class="toc-text">Reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5"><span class="toc-number">9.</span> <span class="toc-text">内核同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0"><span class="toc-number">9.1.</span> <span class="toc-text">内核抢占</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD"><span class="toc-number">9.2.</span> <span class="toc-text">同步原语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#per-CPU%E5%8F%98%E9%87%8F"><span class="toc-number">9.2.1.</span> <span class="toc-text">per-CPU变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Per-CPU-%E5%8F%98%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">Per CPU 变量的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#per-CPU-%E5%8F%98%E9%87%8F%E5%9C%A8%E5%A4%9A%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">9.2.1.3.</span> <span class="toc-text">per CPU 变量在多文件下的用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">9.2.2.</span> <span class="toc-text">原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-1"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%92%8C%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">9.2.3.</span> <span class="toc-text">优化和内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">9.2.4.</span> <span class="toc-text">自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-API-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.4.1.</span> <span class="toc-text">自旋锁 API 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">9.2.5.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-2"><span class="toc-number">9.2.5.1.</span> <span class="toc-text">API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RCU"><span class="toc-number">9.2.6.</span> <span class="toc-text">RCU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">9.2.7.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-3"><span class="toc-number">9.2.7.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">9.2.7.2.</span> <span class="toc-text">1. 信号量的结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0sema-init"><span class="toc-number">9.2.7.3.</span> <span class="toc-text">2. 初始化函数sema_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%AF%E4%B8%AD%E6%96%AD%E8%8E%B7%E5%8F%96%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0down-interruptible"><span class="toc-number">9.2.7.4.</span> <span class="toc-text">3. 可中断获取信号量函数down_interruptible</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%87%8A%E6%94%BE%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%87%BD%E6%95%B0-up"><span class="toc-number">9.2.7.5.</span> <span class="toc-text">4. 释放信号量函数 up</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference-4"><span class="toc-number">10.</span> <span class="toc-text">Reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E6%B5%8B%E9%87%8F"><span class="toc-number">11.</span> <span class="toc-text">定时测量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E7%94%B5%E8%B7%AF"><span class="toc-number">11.1.</span> <span class="toc-text">时钟和定时器电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F"><span class="toc-number">11.1.1.</span> <span class="toc-text">实时时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">11.1.2.</span> <span class="toc-text">计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E9%97%B4%E9%9A%94%E5%AE%9A%E6%95%B0"><span class="toc-number">11.1.3.</span> <span class="toc-text">可编程间隔定数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%9C%AC%E5%9C%B0%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">11.1.4.</span> <span class="toc-text">CPU本地定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%BA%8B%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8HPET"><span class="toc-number">11.1.5.</span> <span class="toc-text">高精度事件定时器HPET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACPI%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">11.1.6.</span> <span class="toc-text">ACPI电源管理定时器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E8%AE%A1%E6%97%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">11.2.</span> <span class="toc-text">Linux计时体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.1.</span> <span class="toc-text">计时体系结构的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.2.1.1.</span> <span class="toc-text">定时器对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jiffies%E5%8F%98%E9%87%8F"><span class="toc-number">11.2.2.</span> <span class="toc-text">jiffies变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xtime%E5%8F%98%E9%87%8F"><span class="toc-number">11.2.3.</span> <span class="toc-text">xtime变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E8%AE%A1%E6%97%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.4.</span> <span class="toc-text">单处理器系统上的计时体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">11.2.4.1.</span> <span class="toc-text">初始化阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.2.5.</span> <span class="toc-text">时钟中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E8%AE%A1%E6%97%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.6.</span> <span class="toc-text">多处理器系统上的计时体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5-1"><span class="toc-number">11.2.7.</span> <span class="toc-text">初始化阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.2.8.</span> <span class="toc-text">全局时钟中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">11.2.9.</span> <span class="toc-text">本地时钟中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F"><span class="toc-number">11.2.10.</span> <span class="toc-text">更新时间和日期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F%E7%BB%9F%E8%AE%A1%E6%95%B0"><span class="toc-number">11.2.11.</span> <span class="toc-text">更新系统统计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%9C%AC%E5%9C%B0CPU%E7%BB%9F%E8%AE%A1%E6%95%B0"><span class="toc-number">11.2.12.</span> <span class="toc-text">更新本地CPU统计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD"><span class="toc-number">11.2.13.</span> <span class="toc-text">记录系统负载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E7%AE%A1%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81"><span class="toc-number">11.2.14.</span> <span class="toc-text">监管内核代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E9%9D%9E%E5%B1%8F%E8%94%BD%E4%B8%AD%E6%96%AD%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">11.2.15.</span> <span class="toc-text">检查非屏蔽中断监视器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.16.</span> <span class="toc-text">软定时器和延迟函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">11.2.17.</span> <span class="toc-text">动态定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="toc-number">11.2.18.</span> <span class="toc-text">动态定时器与竞争条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.19.</span> <span class="toc-text">动态定时器的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86"><span class="toc-number">11.2.20.</span> <span class="toc-text">动态定时器处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BA%94%E7%94%A8%EF%BC%9Ananosleep%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.2.21.</span> <span class="toc-text">动态定时器应用：nanosleep系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.22.</span> <span class="toc-text">延迟函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%AE%9A%E6%97%B6%E6%B5%8B%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.2.23.</span> <span class="toc-text">与定时测量相关的系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#time%E5%92%8Cgettimeofday%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">11.2.23.1.</span> <span class="toc-text">time和gettimeofday系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#settimer%E5%92%8Calarm"><span class="toc-number">11.2.24.</span> <span class="toc-text">settimer和alarm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">12.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">12.1.</span> <span class="toc-text">调度策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9BAPI%EF%BC%9A"><span class="toc-number">12.1.0.1.</span> <span class="toc-text">一些API：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8A%A2%E5%8D%A0"><span class="toc-number">12.1.1.</span> <span class="toc-text">进程抢占</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E9%80%89%E6%8B%A9%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95"><span class="toc-number">12.1.2.</span> <span class="toc-text">时间片的选择应该如何</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">12.2.1.</span> <span class="toc-text">普通进程的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-number">12.2.2.</span> <span class="toc-text">基本时间片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%B9%B3%E5%9D%87%E7%9D%A1%E7%9C%A0%E6%97%B6%E9%97%B4"><span class="toc-number">12.2.3.</span> <span class="toc-text">动态优先级和平均睡眠时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E4%B8%8E%E8%BF%87%E6%9C%9F%E8%BF%9B%E7%A8%8B"><span class="toc-number">12.2.4.</span> <span class="toc-text">活动与过期进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">12.2.5.</span> <span class="toc-text">实时进程的调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.3.</span> <span class="toc-text">调度程序所使用的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84runqueue"><span class="toc-number">12.3.1.</span> <span class="toc-text">数据结构runqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6-1"><span class="toc-number">12.3.2.</span> <span class="toc-text">进程描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">12.3.3.</span> <span class="toc-text">调度程序所使用的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduler-tick"><span class="toc-number">12.3.4.</span> <span class="toc-text">scheduler_tick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-number">12.3.5.</span> <span class="toc-text">更新实时进程的时间片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%99%AE%E9%80%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-number">12.3.6.</span> <span class="toc-text">更新普通进程的时间片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-to-wake-up"><span class="toc-number">12.3.7.</span> <span class="toc-text">try_to_wake_up</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recalc-task-prio"><span class="toc-number">12.3.8.</span> <span class="toc-text">recalc_task_prio</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#schedule"><span class="toc-number">12.4.</span> <span class="toc-text">schedule</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%BD%BF%E7%94%A8%E8%A7%92%E5%BA%A6%E4%BB%8B%E7%BB%8Dschedule%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%93%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="toc-number">12.4.1.</span> <span class="toc-text">从使用角度介绍schedule使用场景–直接调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%BD%BF%E7%94%A8%E8%A7%92%E5%BA%A6%E4%BB%8B%E7%BB%8Dschedule%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E2%80%93%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8"><span class="toc-number">12.4.2.</span> <span class="toc-text">从使用角度介绍schedule使用场景–延迟调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E4%B9%8B%E5%89%8Dschedule%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">12.4.3.</span> <span class="toc-text">进程切换之前schedule所执行的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schedule%E5%AE%8C%E6%88%90%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E6%97%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">12.4.4.</span> <span class="toc-text">schedule完成进程切换时操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#context-switch"><span class="toc-number">12.4.5.</span> <span class="toc-text">context_switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%90%8Eschedule%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">12.4.6.</span> <span class="toc-text">进程切换后schedule所执行的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%B9%B3%E8%A1%A1"><span class="toc-number">12.4.7.</span> <span class="toc-text">多处理器系统中运行队列的平衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%9F%9F"><span class="toc-number">12.4.8.</span> <span class="toc-text">调度域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rebalance-tick"><span class="toc-number">12.4.9.</span> <span class="toc-text">rebalance_tick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load-balance"><span class="toc-number">12.4.10.</span> <span class="toc-text">load_balance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#move-tasks"><span class="toc-number">12.4.11.</span> <span class="toc-text">move_tasks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">12.5.</span> <span class="toc-text">与调度相关的系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nice"><span class="toc-number">12.5.1.</span> <span class="toc-text">nice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getpriority%E5%92%8Csetpriority"><span class="toc-number">12.5.2.</span> <span class="toc-text">getpriority和setpriority</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sched-getaffinity%E5%92%8Csched-setaffinity"><span class="toc-number">12.5.3.</span> <span class="toc-text">sched_getaffinity和sched_setaffinity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%AE%9E%E6%97%B6%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">12.5.4.</span> <span class="toc-text">与实时进程相关的系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference-5"><span class="toc-number">13.</span> <span class="toc-text">Reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="toc-number">14.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E6%A1%86%E7%AE%A1%E7%90%86"><span class="toc-number">14.1.</span> <span class="toc-text">页框管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">14.1.1.</span> <span class="toc-text">页描述符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UMA%E5%92%8CNUMA"><span class="toc-number">14.2.</span> <span class="toc-text">UMA和NUMA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA"><span class="toc-number">14.2.1.</span> <span class="toc-text">内存管理区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E7%9A%84%E9%A1%B5%E6%A1%86%E6%B1%A0"><span class="toc-number">14.2.2.</span> <span class="toc-text">保留的页框池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">14.2.3.</span> <span class="toc-text">分区页框分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E9%87%8A%E6%94%BE%E9%A1%B5%E6%A1%86"><span class="toc-number">14.2.4.</span> <span class="toc-text">请求和释放页框</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%A1%B5%E6%A1%86"><span class="toc-number">14.2.4.1.</span> <span class="toc-text">释放页框</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98%E9%A1%B5%E6%A1%86%E7%9A%84%E5%86%85%E6%A0%B8%E6%98%A0%E5%B0%84"><span class="toc-number">14.2.5.</span> <span class="toc-text">高端内存页框的内核映射</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E7%AE%97%E6%B3%95"><span class="toc-number">14.3.</span> <span class="toc-text">伙伴系统算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E9%A1%B5%E6%A1%86%E5%9D%97%E9%87%8A%E6%94%BE%EF%BC%9A"><span class="toc-number">14.3.1.</span> <span class="toc-text">连续页框块释放：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">14.3.1.1.</span> <span class="toc-text">1.数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%86%E9%85%8D%E5%9D%97"><span class="toc-number">14.3.1.2.</span> <span class="toc-text">2.分配块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%87%8A%E6%94%BE%E5%9D%97"><span class="toc-number">14.3.1.3.</span> <span class="toc-text">3.释放块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8FCPU%E9%A1%B5%E6%A1%86%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">14.4.</span> <span class="toc-text">每CPU页框高速缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E6%AF%8FCPU%E9%A1%B5%E6%A1%86%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%88%86%E9%85%8D%E9%A1%B5%E6%A1%86"><span class="toc-number">14.4.0.1.</span> <span class="toc-text">1.通过每CPU页框高速缓存分配页框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8A%E6%94%BE%E9%A1%B5%E6%A1%86%E5%88%B0%E6%AF%8FCPU%E9%A1%B5%E6%A1%86%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E2%80%93%E4%BD%8D%E4%BA%8E%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%A1%B5%E6%A1%86%E4%BD%BF%E7%94%A8%E8%80%85%E7%9A%84%E4%B8%AD%E9%97%B4%E5%B1%82"><span class="toc-number">14.4.0.2.</span> <span class="toc-text">2.释放页框到每CPU页框高速缓存–位于伙伴系统和页框使用者的中间层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">14.4.1.</span> <span class="toc-text">管理区分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">14.4.2.</span> <span class="toc-text">内存高速缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%B1%82%E6%AC%A1"><span class="toc-number">14.4.2.1.</span> <span class="toc-text">1.内存高速缓存层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">14.4.2.2.</span> <span class="toc-text">2.内存高速缓存描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-slab%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">14.4.2.3.</span> <span class="toc-text">3.slab描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%99%AE%E9%80%9A%E5%92%8C%E4%B8%93%E7%94%A8%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">14.4.2.4.</span> <span class="toc-text">4.普通和专用高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%BAslab%E5%88%86%E9%85%8D%E9%A1%B5%E6%A1%86%EF%BC%8C%E9%87%8A%E6%94%BE%E9%A1%B5%E6%A1%86"><span class="toc-number">14.4.2.5.</span> <span class="toc-text">5.为slab分配页框，释放页框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E7%BB%99%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%88%86%E9%85%8Dslab"><span class="toc-number">14.4.2.6.</span> <span class="toc-text">6.内存给高速缓存分配slab</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%8E%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%AD%E9%87%8A%E6%94%BEslab"><span class="toc-number">14.4.2.7.</span> <span class="toc-text">7.从高速缓存中释放slab</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%AF%B9%E8%B1%A1%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">14.4.2.8.</span> <span class="toc-text">8.对象描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%AF%B9%E9%BD%90%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.4.2.9.</span> <span class="toc-text">9.对齐内存中的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-slab%E7%9D%80%E8%89%B2"><span class="toc-number">14.4.2.10.</span> <span class="toc-text">10.slab着色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E7%A9%BA%E9%97%B2Slab%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E5%9C%B0%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E2%80%93slab%E5%88%86%E9%85%8D%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E4%BD%BF%E7%94%A8%E8%80%85%E7%9A%84%E4%B8%AD%E9%97%B4%E5%B1%82"><span class="toc-number">14.4.2.11.</span> <span class="toc-text">11.空闲Slab对象的本地高速缓存–slab分配器和内存申请使用者的中间层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E5%88%86%E9%85%8Dslab%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.4.2.12.</span> <span class="toc-text">12.分配slab对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E9%87%8A%E6%94%BEslab%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.4.2.13.</span> <span class="toc-text">13. 释放slab对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E9%80%9A%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.4.2.14.</span> <span class="toc-text">14.通用对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%86%85%E5%AD%98%E6%B1%A0%E2%80%93%E4%BD%BF%E7%94%A8%E8%80%85%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E4%B8%8Ekmem-cache%E4%BA%A4%E4%BA%92%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%B8%8Emempool-t%E4%BA%A4%E4%BA%92"><span class="toc-number">14.4.2.15.</span> <span class="toc-text">15.内存池–使用者可以直接与kmem_cache交互，也可与mempool_t交互</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">14.5.</span> <span class="toc-text">非连续内存区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="toc-number">14.5.0.1.</span> <span class="toc-text">1.非连续内存区的线性地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">14.5.0.2.</span> <span class="toc-text">2.非连续内存区的描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%86%E9%85%8D%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA"><span class="toc-number">14.5.0.3.</span> <span class="toc-text">3.分配非连续内存区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%87%8A%E6%94%BE%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA"><span class="toc-number">14.5.0.4.</span> <span class="toc-text">4.释放非连续内存区</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4-1"><span class="toc-number">15.</span> <span class="toc-text">进程地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">15.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">15.2.</span> <span class="toc-text">进程的地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">15.2.1.</span> <span class="toc-text">内存描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">15.2.1.1.</span> <span class="toc-text">内核线程的内存描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8C%BA"><span class="toc-number">15.2.2.</span> <span class="toc-text">线性区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8C%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">15.2.2.1.</span> <span class="toc-text">线性区数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B0%8F%E8%AE%BA"><span class="toc-number">15.2.2.2.</span> <span class="toc-text">红黑树小论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8C%BA%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">15.2.3.</span> <span class="toc-text">线性区访问权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8C%BA%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">15.2.4.</span> <span class="toc-text">线性区的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%BB%99%E5%AE%9A%E5%9C%B0%E5%9D%80%E7%9A%84%E6%9C%80%E8%BF%91%E9%82%BB%E5%8C%BA%EF%BC%9Afind-vma"><span class="toc-number">15.2.4.1.</span> <span class="toc-text">查找给定地址的最近邻区：find_vma</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E4%B8%8E%E7%BB%99%E5%AE%9A%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8C%BA%E9%97%B4%E7%9B%B8%E9%87%8D%E5%8F%A0%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%BA%EF%BC%9Afind-vma-intersection"><span class="toc-number">15.2.5.</span> <span class="toc-text">查找一个与给定的地址区间相重叠的线性区：find_vma_intersection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E7%A9%BA%E9%97%B2%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8C%BA%E9%97%B4%EF%BC%9Aget-unmapped-area"><span class="toc-number">15.2.6.</span> <span class="toc-text">查找一个空闲的地址区间：get_unmapped_area</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BA%BF%E6%80%A7%E5%8C%BA%EF%BC%9Ainsert-vm-struct"><span class="toc-number">15.2.7.</span> <span class="toc-text">向内存描述符链表中插入一个线性区：insert_vm_struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E5%8C%BA%E9%97%B4"><span class="toc-number">15.2.8.</span> <span class="toc-text">分配线性地址区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E5%8C%BA%E9%97%B4"><span class="toc-number">15.2.9.</span> <span class="toc-text">释放线性地址区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">15.2.10.</span> <span class="toc-text">缺页异常处理程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%84%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%BB%A5%E5%A4%96%E7%9A%84%E9%94%99%E8%AF%AF%E5%9C%B0%E5%9D%80"><span class="toc-number">15.2.10.1.</span> <span class="toc-text">1.处理地址空间以外的错误地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%84%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E9%94%99%E8%AF%AF%E5%9C%B0%E5%9D%80"><span class="toc-number">15.2.10.2.</span> <span class="toc-text">2.处理地址空间内的错误地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5%EF%BC%9A"><span class="toc-number">15.2.10.3.</span> <span class="toc-text">请求调页：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%9A"><span class="toc-number">15.2.10.4.</span> <span class="toc-text">写时复制：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">15.2.10.5.</span> <span class="toc-text">处理非连续内存区访问:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="toc-number">15.2.10.6.</span> <span class="toc-text">缺页异常主程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">15.2.11.</span> <span class="toc-text">创建和删除进程的地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">15.2.11.1.</span> <span class="toc-text">1.创建进程的地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">15.2.11.2.</span> <span class="toc-text">2.删除进程的地址空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">15.2.12.</span> <span class="toc-text">堆的管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">16.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#POSIX-API%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">16.0.1.</span> <span class="toc-text">POSIX API和系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%8F%8A%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B"><span class="toc-number">16.0.2.</span> <span class="toc-text">系统调用处理程序及服务例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%92%8C%E9%80%80%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">16.0.3.</span> <span class="toc-text">进入和退出系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87int-0x80%E5%8F%91%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">16.1.</span> <span class="toc-text">通过int $0x80发出系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#system-call"><span class="toc-number">16.1.1.</span> <span class="toc-text">system_call</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%80%80%E5%87%BA"><span class="toc-number">16.1.2.</span> <span class="toc-text">从系统调用退出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87sysenter%E5%8F%91%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">16.2.</span> <span class="toc-text">通过sysenter发出系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sysenter"><span class="toc-number">16.2.1.</span> <span class="toc-text">sysenter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vsyscall%E9%A1%B5"><span class="toc-number">16.2.2.</span> <span class="toc-text">vsyscall页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">16.2.3.</span> <span class="toc-text">进入系统调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">16.3.</span> <span class="toc-text">退出系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sysexit"><span class="toc-number">16.3.1.</span> <span class="toc-text">sysexit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYSENTER-RETURN"><span class="toc-number">16.3.2.</span> <span class="toc-text">SYSENTER_RETURN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">16.3.3.</span> <span class="toc-text">参数传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%8F%82%E6%95%B0"><span class="toc-number">16.4.</span> <span class="toc-text">验证参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">16.4.1.</span> <span class="toc-text">访问进程地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80%E6%A3%80%E6%9F%A5%EF%BC%9A%E4%BF%AE%E6%AD%A3%E4%BB%A3%E7%A0%81"><span class="toc-number">16.4.2.</span> <span class="toc-text">动态地址检查：修正代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="toc-number">16.4.3.</span> <span class="toc-text">异常表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%BC%82%E5%B8%B8%E8%A1%A8%E5%92%8C%E4%BF%AE%E6%AD%A3%E4%BB%A3%E7%A0%81"><span class="toc-number">16.4.4.</span> <span class="toc-text">生成异常表和修正代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%B0%81%E8%A3%85%E4%BE%8B%E7%A8%8B"><span class="toc-number">16.4.5.</span> <span class="toc-text">内核封装例程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E8%AF%B4%E6%98%8E"><span class="toc-number">16.4.5.0.1.</span> <span class="toc-text">额外说明</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">17.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">17.1.</span> <span class="toc-text">信号的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E5%8F%B7%E4%B9%8B%E5%89%8D%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">17.2.</span> <span class="toc-text">传递信号之前所执行的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#POSIX%E4%BF%A1%E5%8F%B7%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8"><span class="toc-number">17.2.1.</span> <span class="toc-text">POSIX信号和多线程应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">17.3.</span> <span class="toc-text">结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">17.3.1.</span> <span class="toc-text">信号描述符和信号处理程序描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sigaction%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">17.3.2.</span> <span class="toc-text">sigaction数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E4%BF%A1%E5%8F%B7%E9%98%9F%E5%88%97"><span class="toc-number">17.3.3.</span> <span class="toc-text">挂起信号队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7"><span class="toc-number">17.3.4.</span> <span class="toc-text">产生信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#specific-send-sig-info-%E5%87%BD%E6%95%B0"><span class="toc-number">17.3.5.</span> <span class="toc-text">specific_send_sig_info()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#signal-wake-up"><span class="toc-number">17.3.5.1.</span> <span class="toc-text">signal_wake_up</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#send-signal-%E5%87%BD%E6%95%B0"><span class="toc-number">17.3.6.</span> <span class="toc-text">send_signal()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#group-send-sig-info-%E5%87%BD%E6%95%B0"><span class="toc-number">17.3.7.</span> <span class="toc-text">group_send_sig_info()函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#handle-stop-signal-%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">17.3.7.1.</span> <span class="toc-text">handle_stop_signal()函数执行下面的步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#group-complete-sigmal"><span class="toc-number">17.3.7.2.</span> <span class="toc-text">__group_complete_sigmal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E5%8F%B7"><span class="toc-number">17.3.8.</span> <span class="toc-text">传递信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#do-signal"><span class="toc-number">17.3.8.1.</span> <span class="toc-text">do_signal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dequeue-signal"><span class="toc-number">17.3.8.2.</span> <span class="toc-text">dequeue_signal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%BA%E7%9C%81%E6%93%8D%E4%BD%9C"><span class="toc-number">17.3.9.</span> <span class="toc-text">执行信号的缺省操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#do-signal-stop"><span class="toc-number">17.3.9.1.</span> <span class="toc-text">do_signal_stop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7"><span class="toc-number">17.3.10.</span> <span class="toc-text">捕获信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup-frame"><span class="toc-number">17.3.11.</span> <span class="toc-text">setup_frame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BF%A1%E5%8F%B7%E6%A0%87%E5%BF%97"><span class="toc-number">17.3.12.</span> <span class="toc-text">检查信号标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">17.3.13.</span> <span class="toc-text">开始执行信号处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">17.3.14.</span> <span class="toc-text">终止信号处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">17.3.15.</span> <span class="toc-text">系统调用的重新执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E8%A2%AB%E6%9C%AA%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">17.3.16.</span> <span class="toc-text">重新执行被未捕获信号中断的系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E6%89%80%E6%8D%95%E8%8E%B7%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">17.3.17.</span> <span class="toc-text">为所捕获的信号重新执行系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">17.3.18.</span> <span class="toc-text">与信号处理相关的系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kill-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">17.3.18.1.</span> <span class="toc-text">kill()系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tkill-%E5%92%8Ctgkill-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">17.3.18.2.</span> <span class="toc-text">tkill()和tgkill()系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">17.3.19.</span> <span class="toc-text">改变信号的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%8C%82%E8%B5%B7%E7%9A%84%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7"><span class="toc-number">17.3.20.</span> <span class="toc-text">检查挂起的阻塞信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">17.3.21.</span> <span class="toc-text">修改阻塞信号的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E8%BF%9B%E7%A8%8B"><span class="toc-number">17.3.22.</span> <span class="toc-text">挂起进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">17.3.23.</span> <span class="toc-text">实时信号的系统调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VFS-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">18.</span> <span class="toc-text">VFS 虚拟文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">18.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">18.2.</span> <span class="toc-text">通用文件模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VFS%E6%89%80%E5%A4%84%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">18.2.1.</span> <span class="toc-text">VFS所处理的系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VFS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">18.2.2.</span> <span class="toc-text">VFS的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">18.2.3.</span> <span class="toc-text">超级块对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1%EF%BC%88inode%EF%BC%89"><span class="toc-number">18.2.4.</span> <span class="toc-text">索引节点对象（inode）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">18.2.5.</span> <span class="toc-text">文件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">18.2.6.</span> <span class="toc-text">目录项对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">18.2.6.1.</span> <span class="toc-text">目录项高速缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-number">18.2.7.</span> <span class="toc-text">与进程相关的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">18.2.8.</span> <span class="toc-text">文件系统类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">18.2.9.</span> <span class="toc-text">特殊文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%86%8C"><span class="toc-number">18.2.10.</span> <span class="toc-text">文件系统类型注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86"><span class="toc-number">18.2.11.</span> <span class="toc-text">文件系统处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">18.2.12.</span> <span class="toc-text">命名空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85"><span class="toc-number">18.3.</span> <span class="toc-text">文件系统安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">18.3.1.</span> <span class="toc-text">安装普通文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-kern-mount-%E5%87%BD%E6%95%B0"><span class="toc-number">18.3.2.</span> <span class="toc-text">do_kern_mount()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E8%B6%85%E7%BA%A7%E5%9D%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">18.3.3.</span> <span class="toc-text">分配超级块对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">18.4.</span> <span class="toc-text">安装根文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B51-%E5%AE%89%E8%A3%85rootfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">18.4.1.</span> <span class="toc-text">阶段1:安装rootfs文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#init-rootfs"><span class="toc-number">18.4.1.1.</span> <span class="toc-text">init_rootfs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init-mount-tree"><span class="toc-number">18.4.1.2.</span> <span class="toc-text">init_mount_tree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B52-%E5%AE%89%E8%A3%85%E5%AE%9E%E9%99%85%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">18.4.2.</span> <span class="toc-text">阶段2:安装实际根文件系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">18.5.</span> <span class="toc-text">卸载文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%90%8D%E6%9F%A5%E6%89%BE"><span class="toc-number">18.6.</span> <span class="toc-text">路径名查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%B7%AF%E5%BE%84%E5%90%8D%E6%9F%A5%E6%89%BE"><span class="toc-number">18.6.1.</span> <span class="toc-text">标准路径名查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E8%B7%AF%E5%BE%84%E5%90%8D%E6%9F%A5%E6%89%BE"><span class="toc-number">18.6.2.</span> <span class="toc-text">父路径名查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">18.6.3.</span> <span class="toc-text">符号链接的查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VFS%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.7.</span> <span class="toc-text">VFS系统调用的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#open-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">18.7.1.</span> <span class="toc-text">open()系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-%E5%92%8Cwrite-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">18.7.2.</span> <span class="toc-text">read()和write()系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">18.7.3.</span> <span class="toc-text">close()系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="toc-number">18.7.4.</span> <span class="toc-text">文件加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="toc-number">18.7.5.</span> <span class="toc-text">Linux文件加锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%94%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">18.7.6.</span> <span class="toc-text">文件锁的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FL-FLOCK%E9%94%81"><span class="toc-number">18.7.7.</span> <span class="toc-text">FL_FLOCK锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FL-POSIX%E9%94%81"><span class="toc-number">18.7.8.</span> <span class="toc-text">FL_POSIX锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference-6"><span class="toc-number">19.</span> <span class="toc-text">Reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%B7%E6%9D%BF"><span class="toc-number">20.</span> <span class="toc-text">一般的文件系统样板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ext2"><span class="toc-number">20.1.</span> <span class="toc-text">Ext2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2%E7%9A%84%E4%B8%80%E8%88%AC%E7%89%B9%E5%BE%81"><span class="toc-number">20.1.1.</span> <span class="toc-text">Ext2的一般特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">20.1.2.</span> <span class="toc-text">Ext2磁盘数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97"><span class="toc-number">20.1.3.</span> <span class="toc-text">超级块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E8%A1%A8"><span class="toc-number">20.1.4.</span> <span class="toc-text">索引节点表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E5%A2%9E%E5%BC%BA%E5%B1%9E%E6%80%A7"><span class="toc-number">20.1.5.</span> <span class="toc-text">索引节点的增强属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8"><span class="toc-number">20.1.6.</span> <span class="toc-text">访问控制列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%A3%81%E7%9B%98%E5%9D%97"><span class="toc-number">20.1.7.</span> <span class="toc-text">各种文件类型如何使用磁盘块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6"><span class="toc-number">20.1.8.</span> <span class="toc-text">普通文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">20.1.9.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="toc-number">20.1.10.</span> <span class="toc-text">符号链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E3%80%81%E7%AE%A1%E9%81%93%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">20.1.11.</span> <span class="toc-text">设备文件、管道和套接字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2%E7%9A%84%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">20.1.12.</span> <span class="toc-text">Ext2的内存数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2%E7%9A%84%E8%B6%85%E7%BA%A7%E5%9D%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">20.1.13.</span> <span class="toc-text">Ext2的超级块对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2%E7%9A%84%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1"><span class="toc-number">20.1.14.</span> <span class="toc-text">Ext2的索引节点对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAExt2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">20.1.15.</span> <span class="toc-text">创建Ext2文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">20.1.16.</span> <span class="toc-text">Ext2的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2%E8%B6%85%E7%BA%A7%E5%9D%97%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">20.1.17.</span> <span class="toc-text">Ext2超级块的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">20.1.18.</span> <span class="toc-text">Ext2索引节点的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext2%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">20.1.19.</span> <span class="toc-text">Ext2的文件操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86Ext2%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4"><span class="toc-number">20.1.20.</span> <span class="toc-text">管理Ext2磁盘空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">20.1.21.</span> <span class="toc-text">创建索引节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">20.1.22.</span> <span class="toc-text">删除索引节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9D%97%E5%AF%BB%E5%9D%80"><span class="toc-number">20.1.23.</span> <span class="toc-text">数据块寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%B4%9E"><span class="toc-number">20.1.24.</span> <span class="toc-text">文件的洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="toc-number">20.1.25.</span> <span class="toc-text">分配数据块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="toc-number">20.1.26.</span> <span class="toc-text">释放数据块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ext3%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">20.2.</span> <span class="toc-text">Ext3文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">20.2.1.</span> <span class="toc-text">日志文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ext3%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">20.2.2.</span> <span class="toc-text">Ext3日志文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%9D%97%E8%AE%BE%E5%A4%87%E5%B1%82"><span class="toc-number">20.2.3.</span> <span class="toc-text">日志块设备层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="toc-number">20.2.4.</span> <span class="toc-text">日志记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%A4%84%E7%90%86"><span class="toc-number">20.2.5.</span> <span class="toc-text">原子操作处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">20.2.6.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">20.2.7.</span> <span class="toc-text">日志如何工作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-O%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%92%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">21.</span> <span class="toc-text">I&#x2F;O体系结构和设备驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">21.0.1.</span> <span class="toc-text">I&#x2F;O体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E7%AB%AF%E5%8F%A3"><span class="toc-number">21.0.2.</span> <span class="toc-text">I&#x2F;O端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEI-O%E7%AB%AF%E5%8F%A3"><span class="toc-number">21.0.3.</span> <span class="toc-text">访问I&#x2F;O端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%8E%A5%E5%8F%A3"><span class="toc-number">21.0.4.</span> <span class="toc-text">I&#x2F;O接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E7%94%A8IO%E6%8E%A5%E5%8F%A3"><span class="toc-number">21.0.5.</span> <span class="toc-text">专用IO接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8IO%E6%8E%A5%E5%8F%A3"><span class="toc-number">21.0.6.</span> <span class="toc-text">通用IO接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">21.0.7.</span> <span class="toc-text">设备控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">21.0.8.</span> <span class="toc-text">设备驱动程序模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sysfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">21.0.9.</span> <span class="toc-text">sysfs文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kobject"><span class="toc-number">21.0.10.</span> <span class="toc-text">kobject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8Ckobject%E3%80%81kset%E5%92%8Csubsystem"><span class="toc-number">21.0.11.</span> <span class="toc-text">注册kobject、kset和subsystem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">21.0.12.</span> <span class="toc-text">设备驱动程序模型的组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87"><span class="toc-number">21.0.12.1.</span> <span class="toc-text">设备</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">21.0.13.</span> <span class="toc-text">驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF"><span class="toc-number">21.0.14.</span> <span class="toc-text">总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">21.0.15.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="toc-number">21.0.16.</span> <span class="toc-text">设备文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%A8%E6%88%B7%E6%80%81%E5%A4%84%E7%90%86"><span class="toc-number">21.0.17.</span> <span class="toc-text">设备文件的用户态处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">21.0.18.</span> <span class="toc-text">动态分配设备号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="toc-number">21.0.19.</span> <span class="toc-text">动态创建设备文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84VFS%E5%A4%84%E7%90%86"><span class="toc-number">21.0.20.</span> <span class="toc-text">设备文件的VFS处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">21.0.21.</span> <span class="toc-text">设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">21.0.22.</span> <span class="toc-text">注册设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">21.0.23.</span> <span class="toc-text">初始化设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7I-O%E6%93%8D%E4%BD%9C"><span class="toc-number">21.0.24.</span> <span class="toc-text">监控I&#x2F;O操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">21.0.25.</span> <span class="toc-text">轮询模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">21.0.26.</span> <span class="toc-text">中断模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEI-O%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">21.0.27.</span> <span class="toc-text">访问I&#x2F;O共享存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE-DMA"><span class="toc-number">21.0.28.</span> <span class="toc-text">直接内存访问(DMA)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5DMA%E5%92%8C%E5%BC%82%E6%AD%A5DMA"><span class="toc-number">21.0.29.</span> <span class="toc-text">同步DMA和异步DMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E4%BC%A0%E9%80%81%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">21.0.30.</span> <span class="toc-text">DMA传送的辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%9C%B0%E5%9D%80"><span class="toc-number">21.0.31.</span> <span class="toc-text">总线地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">21.0.32.</span> <span class="toc-text">高速缓存的一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7DMA%E6%98%A0%E5%B0%84%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">21.0.33.</span> <span class="toc-text">一致性DMA映射的辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%BC%8FDMA%E6%98%A0%E5%B0%84%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">21.0.34.</span> <span class="toc-text">流式DMA映射的辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="toc-number">21.0.35.</span> <span class="toc-text">内核支持的级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">21.0.36.</span> <span class="toc-text">字符设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">21.0.37.</span> <span class="toc-text">分配设备号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register-chrdev-region-%E5%87%BD%E6%95%B0%E5%92%8Calloc-chrdev-region-%E5%87%BD%E6%95%B0"><span class="toc-number">21.0.38.</span> <span class="toc-text">register_chrdev_region()函数和alloc_chrdev_region()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register-chrdev-%E5%87%BD%E6%95%B0"><span class="toc-number">21.0.39.</span> <span class="toc-text">register_chrdev()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">21.0.40.</span> <span class="toc-text">访问字符设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E7%9A%84%E7%BC%93%E5%86%B2%E7%AD%96%E7%95%A5"><span class="toc-number">21.0.41.</span> <span class="toc-text">字符设备的缓冲策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87"><span class="toc-number">22.</span> <span class="toc-text">块设备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">22.1.</span> <span class="toc-text">块设备的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%87%E5%8C%BA"><span class="toc-number">22.1.1.</span> <span class="toc-text">扇区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97"><span class="toc-number">22.1.2.</span> <span class="toc-text">块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5"><span class="toc-number">22.1.3.</span> <span class="toc-text">段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%9D%97%E5%B1%82"><span class="toc-number">22.1.4.</span> <span class="toc-text">通用块层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bio%E7%BB%93%E6%9E%84"><span class="toc-number">22.1.5.</span> <span class="toc-text">bio结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%92%8C%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">22.1.6.</span> <span class="toc-text">磁盘和磁盘分区的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82"><span class="toc-number">22.1.7.</span> <span class="toc-text">提交请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-number">22.2.</span> <span class="toc-text">I&#x2F;O调度程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">22.2.1.</span> <span class="toc-text">请求队列描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">22.2.2.</span> <span class="toc-text">请求描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%AF%B7%E6%B1%82%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%88%86%E9%85%8D%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86"><span class="toc-number">22.2.3.</span> <span class="toc-text">对请求描述符的分配进行管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97%E6%8B%A5%E5%A1%9E"><span class="toc-number">22.2.4.</span> <span class="toc-text">避免请求队列拥塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">22.2.5.</span> <span class="toc-text">激活块设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">22.2.6.</span> <span class="toc-text">IO调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9CNoop%E2%80%9D%E7%AE%97%E6%B3%95"><span class="toc-number">22.2.6.1.</span> <span class="toc-text">“Noop”算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9CCFQ%E2%80%9D%E7%AE%97%E6%B3%95"><span class="toc-number">22.2.6.2.</span> <span class="toc-text">“CFQ”算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E6%9C%80%E5%90%8E%E6%9C%9F%E9%99%90%E2%80%9D%E7%AE%97%E6%B3%95"><span class="toc-number">22.2.6.3.</span> <span class="toc-text">“最后期限”算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%80%9C%E9%A2%84%E6%9C%9F%E2%80%9D%E7%AE%97%E6%B3%95"><span class="toc-number">22.2.6.4.</span> <span class="toc-text">“预期”算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91I-O%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%87%BA%E8%AF%B7%E6%B1%82"><span class="toc-number">22.3.</span> <span class="toc-text">向I&#x2F;O调度程序发出请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#blk-queue-bounce-%E5%87%BD%E6%95%B0"><span class="toc-number">22.3.1.</span> <span class="toc-text">blk_queue_bounce()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">22.3.2.</span> <span class="toc-text">块设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87-1"><span class="toc-number">22.3.3.</span> <span class="toc-text">块设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%9D%97%E8%AE%BE%E5%A4%87"><span class="toc-number">22.3.4.</span> <span class="toc-text">访问块设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">22.3.5.</span> <span class="toc-text">注册和初始化设备驱动程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">22.4.</span> <span class="toc-text">自定义驱动程序描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E8%AE%A2%E4%B8%BB%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">22.4.1.</span> <span class="toc-text">预订主设备号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">22.4.2.</span> <span class="toc-text">初始化自定义描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96gendisk%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">22.4.3.</span> <span class="toc-text">初始化gendisk描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%E8%AE%BE%E5%A4%87%E6%93%8D%E4%BD%9C%E8%A1%A8"><span class="toc-number">22.4.4.</span> <span class="toc-text">初始化块设备操作表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%B7%E6%B1%82%E9%98%9F%E5%88%97"><span class="toc-number">22.4.5.</span> <span class="toc-text">分配和初始化请求队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">22.4.6.</span> <span class="toc-text">设置中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%A3%81%E7%9B%98"><span class="toc-number">22.4.7.</span> <span class="toc-text">注册磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E4%BE%8B%E7%A8%8B"><span class="toc-number">22.4.8.</span> <span class="toc-text">策略例程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">22.4.9.</span> <span class="toc-text">中断处理程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%9D%97%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="toc-number">22.4.10.</span> <span class="toc-text">打开块设备文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="toc-number">23.</span> <span class="toc-text">访问文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.1.</span> <span class="toc-text">五种常见的模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">23.1.1.</span> <span class="toc-text">读写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">23.1.2.</span> <span class="toc-text">从文件中读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0do-generic-file-read"><span class="toc-number">23.1.3.</span> <span class="toc-text">函数do_generic_file_read()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E7%9A%84readpage%E6%96%B9%E6%B3%95"><span class="toc-number">23.1.3.1.</span> <span class="toc-text">普通文件的readpage方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84readpage%E6%96%B9%E6%B3%95"><span class="toc-number">23.1.3.2.</span> <span class="toc-text">块设备文件的readpage方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%A2%84%E8%AF%BB"><span class="toc-number">23.1.3.3.</span> <span class="toc-text">文件的预读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#page-cache-readahead-%E5%87%BD%E6%95%B0"><span class="toc-number">23.1.3.4.</span> <span class="toc-text">page_cache_readahead()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#handle-ra-miss-%E5%87%BD%E6%95%B0"><span class="toc-number">23.1.3.5.</span> <span class="toc-text">handle_ra_miss()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">23.1.3.6.</span> <span class="toc-text">写入文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E7%9A%84prepare-write%E5%92%8Ccommit-write%E6%96%B9%E6%B3%95"><span class="toc-number">23.1.3.7.</span> <span class="toc-text">普通文件的prepare_write和commit_write方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%9A%84prepare-write%E5%92%8Ccommit-write%E6%96%B9%E6%B3%95"><span class="toc-number">23.1.3.8.</span> <span class="toc-text">块设备文件的prepare_write和commit_write方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E8%84%8F%E9%A1%B5%E5%86%99%E5%88%B0%E7%A3%81%E7%9B%98"><span class="toc-number">23.1.3.9.</span> <span class="toc-text">将脏页写到磁盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">23.1.4.</span> <span class="toc-text">内存映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">23.1.4.1.</span> <span class="toc-text">内存映射的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">23.1.4.2.</span> <span class="toc-text">创建内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%92%A4%E6%B6%88%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">23.1.4.3.</span> <span class="toc-text">撤消内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5"><span class="toc-number">23.1.4.4.</span> <span class="toc-text">内存映射的请求调页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84%E8%84%8F%E9%A1%B5%E5%88%B7%E6%96%B0%E5%88%B0%E7%A3%81%E7%9B%98"><span class="toc-number">23.1.4.5.</span> <span class="toc-text">把内存映射的脏页刷新到磁盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">23.1.4.6.</span> <span class="toc-text">非线性内存映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5I-O%E4%BC%A0%E9%80%81"><span class="toc-number">23.1.4.7.</span> <span class="toc-text">直接I&#x2F;O传送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-0"><span class="toc-number">23.1.4.8.</span> <span class="toc-text">异步&#x2F;0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-2-6%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5IO"><span class="toc-number">23.1.4.9.</span> <span class="toc-text">Linux 2.6中的异步IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5I-O%E7%8E%AF%E5%A2%83"><span class="toc-number">23.1.4.10.</span> <span class="toc-text">异步I&#x2F;O环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E5%BC%82%E6%AD%A5I0%E6%93%8D%E4%BD%9C"><span class="toc-number">23.1.4.11.</span> <span class="toc-text">提交异步I0操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">24.</span> <span class="toc-text">页高速缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98-1"><span class="toc-number">24.1.</span> <span class="toc-text">页高速缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#address-space%E5%AF%B9%E8%B1%A1"><span class="toc-number">24.1.1.</span> <span class="toc-text">address_space对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%A0%91"><span class="toc-number">24.1.2.</span> <span class="toc-text">基树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">24.1.3.</span> <span class="toc-text">页高速缓存的处理函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E9%A1%B5%E2%80%93find-get-page"><span class="toc-number">24.1.3.1.</span> <span class="toc-text">查找页–find_get_page()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E9%A1%B5%E2%80%93add-to-page-cache"><span class="toc-number">24.1.3.2.</span> <span class="toc-text">增加页–add_to_page_cache()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%A1%B5"><span class="toc-number">24.1.3.3.</span> <span class="toc-text">删除页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%A1%B5"><span class="toc-number">24.1.3.4.</span> <span class="toc-text">更新页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%A0%91%E7%9A%84%E6%A0%87%E8%AE%B0"><span class="toc-number">24.1.3.5.</span> <span class="toc-text">基树的标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E5%9D%97%E5%AD%98%E6%94%BE%E5%9C%A8%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%AD"><span class="toc-number">24.1.3.6.</span> <span class="toc-text">把块存放在页高速缓存中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E9%A6%96%E9%83%A8"><span class="toc-number">24.1.3.7.</span> <span class="toc-text">块缓冲区和缓冲区首部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E7%BC%93%E5%86%B2%E5%8C%BA%E9%A6%96%E9%83%A8"><span class="toc-number">24.1.3.8.</span> <span class="toc-text">管理缓冲区首部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E9%A1%B5"><span class="toc-number">24.1.3.9.</span> <span class="toc-text">缓冲区页</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%9D%97%E8%AE%BE%E5%A4%87%E7%BC%93%E5%86%B2%E5%8C%BA%E9%A1%B5"><span class="toc-number">24.1.4.</span> <span class="toc-text">分配块设备缓冲区页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E5%9D%97%E8%AE%BE%E5%A4%87%E7%BC%93%E5%86%B2%E5%8C%BA%E9%A1%B5"><span class="toc-number">24.1.4.1.</span> <span class="toc-text">释放块设备缓冲区页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%9D%97"><span class="toc-number">24.1.4.2.</span> <span class="toc-text">在页高速缓存中搜索块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-get-block-%E5%87%BD%E6%95%B0"><span class="toc-number">24.1.4.3.</span> <span class="toc-text">__find_get_block()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getblk-%E5%87%BD%E6%95%B0"><span class="toc-number">24.1.4.4.</span> <span class="toc-text">__getblk()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bread-%E5%87%BD%E6%95%B0"><span class="toc-number">24.1.4.5.</span> <span class="toc-text">__bread()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%80%9A%E7%94%A8%E5%9D%97%E5%B1%82%E6%8F%90%E4%BA%A4%E7%BC%93%E5%86%B2%E5%8C%BA%E9%A6%96%E9%83%A8"><span class="toc-number">24.1.4.6.</span> <span class="toc-text">向通用块层提交缓冲区首部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#submit-bh-%E5%87%BD%E6%95%B0"><span class="toc-number">24.1.4.7.</span> <span class="toc-text">submit_bh()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ll-rw-block-%E5%87%BD%E6%95%B0"><span class="toc-number">24.1.4.8.</span> <span class="toc-text">ll_rw_block()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E8%84%8F%E9%A1%B5%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98"><span class="toc-number">24.1.4.9.</span> <span class="toc-text">把脏页写入磁盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pdflush%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">24.1.4.10.</span> <span class="toc-text">pdflush内核线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E8%A6%81%E5%88%B7%E6%96%B0%E7%9A%84%E8%84%8F%E9%A1%B5"><span class="toc-number">24.1.4.11.</span> <span class="toc-text">搜索要刷新的脏页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E5%86%99%E9%99%88%E6%97%A7%E7%9A%84%E8%84%8F%E9%A1%B5"><span class="toc-number">24.1.4.12.</span> <span class="toc-text">回写陈旧的脏页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-%E3%80%81fsync-%E5%92%8Cfdatasync-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">24.1.4.13.</span> <span class="toc-text">sync()、fsync()和fdatasync()系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">24.1.4.14.</span> <span class="toc-text">sync()系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fsync-%E5%92%8Cfdatasync-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">24.1.4.15.</span> <span class="toc-text">fsync()和fdatasync()系统调用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E6%A1%86%E5%9B%9E%E6%94%B6"><span class="toc-number">25.</span> <span class="toc-text">页框回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">25.1.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%89%E6%8B%A9%E7%9B%AE%E6%A0%87%E9%A1%B5"><span class="toc-number">25.1.0.1.</span> <span class="toc-text">1.选择目标页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-PFRA%E8%AE%BE%E8%AE%A1"><span class="toc-number">25.1.0.2.</span> <span class="toc-text">2.PFRA设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84"><span class="toc-number">25.1.0.3.</span> <span class="toc-text">3.反向映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%8C%BF%E5%90%8D%E9%A1%B5%E7%9A%84%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84"><span class="toc-number">25.1.0.4.</span> <span class="toc-text">3.1.匿名页的反向映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-try-to-unmap-anon-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.0.5.</span> <span class="toc-text">3.2.try_to_unmap_anon()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-try-to-unmap-one-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.0.6.</span> <span class="toc-text">3.3.try_to_unmap_one()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E9%A1%B5%E7%9A%84%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84"><span class="toc-number">25.1.0.7.</span> <span class="toc-text">映射页的反向映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">25.1.0.8.</span> <span class="toc-text">优先搜索树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-to-unmap-file-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.1.</span> <span class="toc-text">try_to_unmap_file()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PFRA%E5%AE%9E%E7%8E%B0"><span class="toc-number">25.1.2.</span> <span class="toc-text">PFRA实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8-LRU-%E9%93%BE%E8%A1%A8"><span class="toc-number">25.1.3.</span> <span class="toc-text">最近最少使用(LRU)链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8LRU%E9%93%BE%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%A7%BB%E5%8A%A8%E9%A1%B5"><span class="toc-number">25.1.4.</span> <span class="toc-text">在LRU链表之间移动页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mark-page-accessed-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.5.</span> <span class="toc-text">mark_page_accessed()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#page-referenced-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.6.</span> <span class="toc-text">page_referenced()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#refill-inactive-zone-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.7.</span> <span class="toc-text">refill_inactive_zone()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%B4%A7%E7%BC%BA%E5%9B%9E%E6%94%B6"><span class="toc-number">25.1.8.</span> <span class="toc-text">内存紧缺回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-more-memory-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.9.</span> <span class="toc-text">free_more_memory()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-to-free-pages-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.10.</span> <span class="toc-text">try_to_free_pages()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shrink-caches-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.11.</span> <span class="toc-text">shrink_caches()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shrink-zone-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.12.</span> <span class="toc-text">shrink_zone()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shrink-cache-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.13.</span> <span class="toc-text">shrink_cache()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shrink-list-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.14.</span> <span class="toc-text">shrink_list()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pageout-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.15.</span> <span class="toc-text">pageout()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%8F%AF%E5%8E%8B%E7%BC%A9%E7%A3%81%E7%9B%98%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E9%A1%B5"><span class="toc-number">25.1.16.</span> <span class="toc-text">回收可压缩磁盘高速缓存的页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%9B%AE%E5%BD%95%E9%A1%B9%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%9B%9E%E6%94%B6%E9%A1%B5%E6%A1%86"><span class="toc-number">25.1.17.</span> <span class="toc-text">从目录项高速缓存回收页框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%9B%9E%E6%94%B6%E9%A1%B5%E6%A1%86"><span class="toc-number">25.1.18.</span> <span class="toc-text">从索引节点高速缓存回收页框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%A8%E6%9C%9F%E5%9B%9E%E6%94%B6"><span class="toc-number">25.1.19.</span> <span class="toc-text">周期回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kswapd%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="toc-number">25.1.20.</span> <span class="toc-text">kswapd内核线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-reap-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.21.</span> <span class="toc-text">cache_reap()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E5%88%A0%E9%99%A4%E7%A8%8B%E5%BA%8F"><span class="toc-number">25.1.22.</span> <span class="toc-text">内存不足删除程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%A0%87%E8%AE%B0"><span class="toc-number">25.1.23.</span> <span class="toc-text">交换标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-number">25.1.24.</span> <span class="toc-text">交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%8C%BA"><span class="toc-number">25.1.25.</span> <span class="toc-text">交换区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%BF%80%E6%B4%BB%E4%BA%A4%E6%8D%A2%E5%8C%BA"><span class="toc-number">25.1.26.</span> <span class="toc-text">创建与激活交换区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BA%A4%E6%8D%A2%E5%8C%BA%E4%B8%AD%E5%88%86%E5%B8%83%E9%A1%B5"><span class="toc-number">25.1.27.</span> <span class="toc-text">如何在交换区中分布页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%8C%BA%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">25.1.28.</span> <span class="toc-text">交换区描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E5%87%BA%E9%A1%B5%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">25.1.29.</span> <span class="toc-text">换出页标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E5%92%8C%E7%A6%81%E7%94%A8%E4%BA%A4%E6%8D%A2%E5%8C%BA"><span class="toc-number">25.1.30.</span> <span class="toc-text">激活和禁用交换区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sys-swapon-%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B"><span class="toc-number">25.1.30.1.</span> <span class="toc-text">sys_swapon()服务例程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sys-swapoff-%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B"><span class="toc-number">25.1.30.2.</span> <span class="toc-text">sys_swapoff()服务例程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-to-unuse-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.31.</span> <span class="toc-text">try_to_unuse()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE%E9%A1%B5%E6%A7%BD"><span class="toc-number">25.1.32.</span> <span class="toc-text">分配和释放页槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scan-swap-map-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.33.</span> <span class="toc-text">scan_swap_map()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-swap-page-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.34.</span> <span class="toc-text">get_swap_page()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap-free-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.35.</span> <span class="toc-text">swap_free()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">25.1.36.</span> <span class="toc-text">交换高速缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">25.1.37.</span> <span class="toc-text">交换高速缓存的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.38.</span> <span class="toc-text">交换高速缓存的辅助函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E5%87%BA%E9%A1%B5"><span class="toc-number">25.1.39.</span> <span class="toc-text">换出页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%8F%92%E5%85%A5%E9%A1%B5%E6%A1%86"><span class="toc-number">25.1.39.1.</span> <span class="toc-text">向交换高速缓存插入页框</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%A1%B5%E8%A1%A8%E9%A1%B9"><span class="toc-number">25.1.40.</span> <span class="toc-text">更新页表项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E9%A1%B5%E5%86%99%E5%85%A5%E4%BA%A4%E6%8D%A2%E5%8C%BA"><span class="toc-number">25.1.41.</span> <span class="toc-text">将页写入交换区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%AD%E5%88%A0%E9%99%A4%E9%A1%B5%E6%A1%86"><span class="toc-number">25.1.42.</span> <span class="toc-text">从交换高速缓存中删除页框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E5%85%A5%E9%A1%B5"><span class="toc-number">25.1.43.</span> <span class="toc-text">换入页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do-swap-page-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.44.</span> <span class="toc-text">do_swap_page()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-swap-cache-async-%E5%87%BD%E6%95%B0"><span class="toc-number">25.1.45.</span> <span class="toc-text">read_swap_cache_async()函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IPC"><span class="toc-number">26.</span> <span class="toc-text">IPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">26.0.1.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93"><span class="toc-number">26.0.2.</span> <span class="toc-text">使用管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">26.0.3.</span> <span class="toc-text">管道数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pipefs%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">26.0.4.</span> <span class="toc-text">pipefs特殊文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%92%A4%E6%B6%88%E7%AE%A1%E9%81%93"><span class="toc-number">26.0.5.</span> <span class="toc-text">创建和撤消管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%AE%A1%E9%81%93%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">26.0.6.</span> <span class="toc-text">从管道中读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E7%AE%A1%E9%81%93%E4%B8%AD%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">26.0.7.</span> <span class="toc-text">向管道中写入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FIFO"><span class="toc-number">26.0.8.</span> <span class="toc-text">FIFO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%89%93%E5%BC%80FIFO"><span class="toc-number">26.0.9.</span> <span class="toc-text">创建并打开FIFO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-V-IPC"><span class="toc-number">26.0.10.</span> <span class="toc-text">System V IPC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8IPC%E8%B5%84%E6%BA%90"><span class="toc-number">26.0.11.</span> <span class="toc-text">使用IPC资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipc-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">26.0.12.</span> <span class="toc-text">ipc()系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">26.0.13.</span> <span class="toc-text">IPC信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">26.0.14.</span> <span class="toc-text">可取消的信号量操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E8%AF%B7%E6%B1%82%E7%9A%84%E9%98%9F%E5%88%97"><span class="toc-number">26.0.15.</span> <span class="toc-text">挂起请求的队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC%E6%B6%88%E6%81%AF"><span class="toc-number">26.0.16.</span> <span class="toc-text">IPC消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">26.0.17.</span> <span class="toc-text">IPC共享内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E5%87%BAIPC%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8C%BA%E7%9A%84%E9%A1%B5"><span class="toc-number">26.0.18.</span> <span class="toc-text">换出IPC共享内存区的页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPC%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8C%BA%E7%9A%84%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5"><span class="toc-number">26.0.19.</span> <span class="toc-text">IPC共享内存区的请求调页</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">27.</span> <span class="toc-text">程序的执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BF%A1%E4%BB%BB%E7%8A%B6%E5%92%8C%E6%9D%83%E8%83%BD"><span class="toc-number">27.1.</span> <span class="toc-text">进程的信任状和权能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9D%83%E8%83%BD"><span class="toc-number">27.1.1.</span> <span class="toc-text">进程的权能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9D%97%E6%A1%86%E6%9E%B6"><span class="toc-number">27.1.2.</span> <span class="toc-text">Linux安全模块框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%92%8Cshell%E7%8E%AF%E5%A2%83"><span class="toc-number">27.2.</span> <span class="toc-text">命令行参数和shell环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93"><span class="toc-number">27.3.</span> <span class="toc-text">库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%AE%B5%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%BA"><span class="toc-number">27.3.1.</span> <span class="toc-text">程序段和进程的线性区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B5%E6%B4%BB%E7%BA%BF%E6%80%A7%E5%8C%BA%E5%B8%83%E5%B1%80"><span class="toc-number">27.3.2.</span> <span class="toc-text">灵活线性区布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%B7%9F%E8%B8%AA"><span class="toc-number">27.3.3.</span> <span class="toc-text">执行跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">27.3.4.</span> <span class="toc-text">可执行格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%9F%9F"><span class="toc-number">27.3.5.</span> <span class="toc-text">执行域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0"><span class="toc-number">27.4.</span> <span class="toc-text">exec函数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/18/%E6%9D%82%E8%B0%88%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%80%E4%B8%AAdebug%E8%AE%B0%E5%BD%95%E4%B9%8B%E9%94%99%E8%AF%AF%E7%9A%84ld-interpreter/" title="杂谈笔记：一个debug记录之错误的ld interpreter"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="杂谈笔记：一个debug记录之错误的ld interpreter"/></a><div class="content"><a class="title" href="/2024/10/18/%E6%9D%82%E8%B0%88%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%80%E4%B8%AAdebug%E8%AE%B0%E5%BD%95%E4%B9%8B%E9%94%99%E8%AF%AF%E7%9A%84ld-interpreter/" title="杂谈笔记：一个debug记录之错误的ld interpreter">杂谈笔记：一个debug记录之错误的ld interpreter</a><time datetime="2024-10-18T11:55:58.000Z" title="发表于 2024-10-18 19:55:58">2024-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/09/CMake%E6%95%99%E7%A8%8B%E8%B7%9F%E5%81%9AI/" title="CMake教程跟做I"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMake教程跟做I"/></a><div class="content"><a class="title" href="/2024/10/09/CMake%E6%95%99%E7%A8%8B%E8%B7%9F%E5%81%9AI/" title="CMake教程跟做I">CMake教程跟做I</a><time datetime="2024-10-09T03:24:34.000Z" title="发表于 2024-10-09 11:24:34">2024-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF1/" title="树莓派学习之路1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树莓派学习之路1"/></a><div class="content"><a class="title" href="/2024/09/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF1/" title="树莓派学习之路1">树莓派学习之路1</a><time datetime="2024-09-26T03:55:47.000Z" title="发表于 2024-09-26 11:55:47">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0F1/" title="设计模式小记F1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式小记F1"/></a><div class="content"><a class="title" href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0F1/" title="设计模式小记F1">设计模式小记F1</a><time datetime="2024-09-26T03:55:35.000Z" title="发表于 2024-09-26 11:55:35">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/30/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" title="Linux学习之路"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux学习之路"/></a><div class="content"><a class="title" href="/2024/07/30/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" title="Linux学习之路">Linux学习之路</a><time datetime="2024-07-30T02:02:02.000Z" title="发表于 2024-07-30 10:02:02">2024-07-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>