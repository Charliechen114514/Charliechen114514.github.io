<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架前言​    笔者前段时间花费了一周，整理了一下自从TM1637开始打算的，使用OLED来搭建一个通用的显示库的一个工程。笔者的OLED库已经开源到Github上了，地址在：MCU_Libs&#x2F;OLED at main · Charliechen114514&#x2F;MCU_Libs (github.com) ​    框架目前的最终目的，是设计一">
<meta property="og:type" content="article">
<meta property="og:title" content="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架">
<meta property="og:url" content="http://charliechen114514.github.io/2025/01/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架前言​    笔者前段时间花费了一周，整理了一下自从TM1637开始打算的，使用OLED来搭建一个通用的显示库的一个工程。笔者的OLED库已经开源到Github上了，地址在：MCU_Libs&#x2F;OLED at main · Charliechen114514&#x2F;MCU_Libs (github.com) ​    框架目前的最终目的，是设计一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2025-01-30T08:23:20.000Z">
<meta property="article:modified_time" content="2025-01-30T08:26:03.605Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="嵌入式开发">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="OLED">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2025/01/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-30 16:26:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-30T08:23:20.000Z" title="发表于 2025-01-30 16:23:20">2025-01-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-30T08:26:03.605Z" title="更新于 2025-01-30 16:26:03">2025-01-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>170分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架"><a href="#从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架" class="headerlink" title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架"></a>从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    笔者前段时间花费了一周，整理了一下自从TM1637开始打算的，使用OLED来搭建一个通用的显示库的一个工程。笔者的OLED库已经开源到Github上了，地址在：<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED">MCU_Libs/OLED at main · Charliechen114514/MCU_Libs (github.com)</a></p>
<p>​    框架目前的最终目的，是设计一个丝滑的带有动画和图标的动态多级菜单。笔者会尽可能详细的介绍自己的设计思路，供大家参考。</p>
<h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>​    首先，笔者惯用的是PlatformIO作为嵌入式开发的IDE，CubeMx作为方便的代码生成器辅助笔者进行快速的工作。各位可能更多使用的是CubeIDE或者是MDK5，关于这个，笔者会尽可能详细的阐述一些可能异于平台操作的操作。这里需要各位自行动手做更改！</p>
<h2 id="代码与动机"><a href="#代码与动机" class="headerlink" title="代码与动机"></a>代码与动机</h2><p>​    关于江科大的OLED代码和以KeysKing作为代码的优秀的嵌入式工程师的代码，笔者早就有所拜读，这些代码更多的是出于一种“可用的”而不是可复用的，代码风格上，笔者更青睐于KeysKing大佬的代码风格。但是笔者在移植的时候出现了一些困扰，导致最终失败。笔者随后决定基于KeysKing的思路，使用江科大的代码作为参考，使用Linux设备代码抽象的架构与面对对象C重新设计一套完整的OLED框架，全面的支持软硬件IIC和软硬件SPI。支持参数不同，大小不同的OLED作为显示。这也是笔者的一次大型的C语言工程训练。新手上路，多多包涵！</p>
<p>​    如果你并不关心如何实现的，只是想快速实现如何使用，请到<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED/library">MCU_Libs/OLED/library at main · Charliechen114514/MCU_Libs (github.com)</a>中直接拷贝两份代码，将所有代码添加进入你的工程（如果您有确定的OLED协议，请自行适当裁剪，笔者的代码极低耦合，可以直接删除不需要的代码）</p>
<p>​    如果你关心的是如何实现的，这就是笔者写这个系列博客的目的。</p>
<h2 id="架构设计，优缺点"><a href="#架构设计，优缺点" class="headerlink" title="架构设计，优缺点"></a>架构设计，优缺点</h2><p>​    简单的讲，分为协议层（使用何种协议进行通信？），设备层（这个设备可以做什么？），图像层（可以使用设备绘制哪一些图像？），组件层（可以使用图像绘制哪一些组件？），层层递进，保证互相之间互不干扰。</p>
<p>​    优点我说了，低耦合高内聚，笔者添加支持SSD1309的代码，从头到尾只是修改了两行代码 + 添加一行修正（<code>X += 2</code>），跑起来了整个框架。其他的代码笔者丝毫未动。</p>
<p>​    缺点就是老生常谈的效率问题。整个事情需要良好的抽象。尽可能大的变量复用，确保敏感部分的函数跳转尽可能少，对OLED的特性尽可能熟悉，对自己的要求很高。</p>
<h1 id="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架-协议层封装"><a href="#从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架-协议层封装" class="headerlink" title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架(协议层封装)"></a>从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架(协议层封装)</h1><p>​    关于架构设计概述等内容，笔者放到了：<a target="_blank" rel="noopener" href="https://blog.csdn.net/charlie114514191/article/details/145397231">https://blog.csdn.net/charlie114514191/article/details/145397231</a></p>
<h2 id="协议层设计，以IIC为例子"><a href="#协议层设计，以IIC为例子" class="headerlink" title="协议层设计，以IIC为例子"></a>协议层设计，以IIC为例子</h2><p>​    我们先按照最经典的软硬件IIC为例子！笔者大部分接触到的都是4针脚的使用IIC协议通信的OLED片子。所以，笔者打算优先的搭建起来IIC部分的代码。所有完整的代码放到了：<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED/library/OLED/Driver">MCU_Libs/OLED/library/OLED/Driver at main · Charliechen114514/MCU_Libs (github.com)</a>，这个文件夹内部都是协议层的代码。</p>
<h2 id="关于软硬件IIC"><a href="#关于软硬件IIC" class="headerlink" title="关于软硬件IIC"></a>关于软硬件IIC</h2><p>​    软硬件IIC都是完成IIC通信协议的东西。但区别在于，我们到底是使用自己手动模拟的IIC还是使用专门硬件特化的IIC。</p>
<p>​    关于IIC，看到这里的朋友都很熟悉了：IIC（Inter-Integrated Circuit）是一种常用的串行通信总线协议，用于微控制器与传感器、显示模块等外设之间的通信。而我们的软件IIC就是使用GPIO来模拟IIC时序。</p>
<blockquote>
<p>优点：</p>
<ol>
<li>灵活性强，可以使用任意引脚进行通信，不受特定硬件限制。</li>
<li>适用于不具备硬件IIC模块的微控制器。</li>
<li>可以方便地调节时序，兼容性较好。</li>
</ol>
<p>缺点：</p>
<ol>
<li>通信效率较低，占用CPU资源较多。</li>
<li>对实时性要求高的应用不太适合。</li>
<li>稳定性较差，容易受程序时序影响。</li>
</ol>
</blockquote>
<p>​    硬件IIC则是将IIC应答处理委托给了专门的硬件。</p>
<blockquote>
<p>优点</p>
<ol>
<li>通信速度快，效率高，因为由专用硬件处理时序。</li>
<li>占用CPU资源少，适合需要高实时性的场合。</li>
<li>通信稳定可靠，不易受到程序时序干扰。</li>
</ol>
<p>缺点：</p>
<ol>
<li>只能使用特定的IIC引脚，不够灵活。</li>
<li>不同微控制器之间的硬件IIC兼容性可能存在差异。</li>
<li>部分微控制器可能没有硬件IIC模块，导致无法使用硬IIC。</li>
</ol>
</blockquote>
<p>​    我们大概清楚了。代码上的实现就不会复杂。下面我们就可以开始聊一聊设计了。</p>
<h2 id="设计的一些原则"><a href="#设计的一些原则" class="headerlink" title="设计的一些原则"></a>设计的一些原则</h2><p>​    你认为这样的代码好看吗？</p>
<pre class="line-numbers language-none"><code class="language-none">void OLED_ShowImage(int16_t X, int16_t Y, uint8_t Width, uint8_t Height, const uint8_t *Image)
&#123;
    uint8_t i &#x3D; 0, j &#x3D; 0;
    int16_t Page, Shift;
     
    &#x2F;*将图像所在区域清空*&#x2F;
    OLED_ClearArea(X, Y, Width, Height);
     
    &#x2F;*遍历指定图像涉及的相关页*&#x2F;
    &#x2F;*(Height - 1) &#x2F; 8 + 1的目的是Height &#x2F; 8并向上取整*&#x2F;
    for (j &#x3D; 0; j &lt; (Height - 1) &#x2F; 8 + 1; j ++)
    &#123;
        &#x2F;*遍历指定图像涉及的相关列*&#x2F;
        for (i &#x3D; 0; i &lt; Width; i ++)
        &#123;
            if (X + i &gt;&#x3D; 0 &amp;&amp; X + i &lt;&#x3D; 127)       &#x2F;&#x2F;超出屏幕的内容不显示
            &#123;
                &#x2F;*负数坐标在计算页地址和移位时需要加一个偏移*&#x2F;
                Page &#x3D; Y &#x2F; 8;
                Shift &#x3D; Y % 8;
                if (Y &lt; 0)
                &#123;
                    Page -&#x3D; 1;
                    Shift +&#x3D; 8;
                &#125;
                 
                if (Page + j &gt;&#x3D; 0 &amp;&amp; Page + j &lt;&#x3D; 7)       &#x2F;&#x2F;超出屏幕的内容不显示
                &#123;
                    &#x2F;*显示图像在当前页的内容*&#x2F;
                    OLED_DisplayBuf[Page + j][X + i] |&#x3D; Image[j * Width + i] &lt;&lt; (Shift);
                &#125;
                 
                if (Page + j + 1 &gt;&#x3D; 0 &amp;&amp; Page + j + 1 &lt;&#x3D; 7)       &#x2F;&#x2F;超出屏幕的内容不显示
                &#123;                   
                    &#x2F;*显示图像在下一页的内容*&#x2F;
                    OLED_DisplayBuf[Page + j + 1][X + i] |&#x3D; Image[j * Width + i] &gt;&gt; (8 - Shift);
                &#125;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    好吧，好像大部分人的代码都是这样的。</p>
<p>​    那这样呢？</p>
<pre class="line-numbers language-none"><code class="language-none">void CCGraphicWidget_draw_image(
    CCDeviceHandler*    handler,
    CCGraphic_Image*    image)
&#123;
    if(!image-&gt;sources_register) return;
    handler-&gt;operations.draw_area_device_function(
        handler, image-&gt;point.x, image-&gt;point.y,
        image-&gt;image_size.width, image-&gt;image_size.height, image-&gt;sources_register
    );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    你需要在乎image是如何实现的吗？你需要知道如何完成OLED图像的显示是如何做的吗？</p>
<p>​    你不需要！</p>
<p>​    这段代码无非就是告诉了你一件事情：提供一个设备句柄作为“告知一个设备，在上面绘制”，告知一个“图像”你需要绘制，直接提供进来，由设备自己约定的方法绘制即可。怎么绘制的？你需要关心吗？你不需要。</p>
<p>​    直到你需要考虑设备是如何工作的时候，你会看一眼内部的设备</p>
<pre class="line-numbers language-none"><code class="language-none">void oled_helper_draw_area(OLED_Handle* handle, 
        uint16_t x, uint16_t y, uint16_t width, 
        uint16_t height, uint8_t* sources)
&#123;
	&#x2F;&#x2F; 嘿！超出绘制范围了
    if(x &gt; POINT_X_MAX)  return;
    if(y &gt; POINT_Y_MAX) return;

    &#x2F;&#x2F; clear the area before being set
    &#x2F;&#x2F; 先清理一下这个区域，不要干扰赋值
    oled_helper_clear_area(handle, x, y , width, height); 

    for(uint16_t j &#x3D; 0; j &lt; (height -1) &#x2F; 8 + 1; j++)
    &#123;
        for(uint16_t i &#x3D; 0; i &lt; width; i++)
        &#123;
            if(x + i &gt; OLED_WIDTH)&#123;break;&#125;
            if(y &#x2F; 8 + j &gt; OLED_HEIGHT - 1)&#123;return;&#125;

            OLED_GRAM[y &#x2F; 8 + j][x + i] |&#x3D; sources[j * width + i] &lt;&lt; (y % 8);

            if(y &#x2F; 8 + j + 1 &gt; OLED_HEIGHT - 1)&#123;continue;&#125;

            OLED_GRAM[y &#x2F; 8 + j + 1][x + i] |&#x3D; sources[j * width + i] &gt;&gt; (8 - y % 8);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    原来如此，是通过写OLED缓存赋值就可以把这个事情给搞明白的——但是当你不关心如何实现的时候，你并不需要付出心血代价把代码看懂然后——哦我的天，这个我压根不关心！当然，代价就是多支付若干次的函数调用（笑）</p>
<p>​    这就是架构抽象带来的对开发的好处，但是只有这个不足以让我们使用复杂的抽象，我们一定还有别的好处，不是吗？让我们慢慢看吧！</p>
<h2 id="完成协议层的抽象"><a href="#完成协议层的抽象" class="headerlink" title="完成协议层的抽象"></a>完成协议层的抽象</h2><p>​    我已经说过，我们的OLED框架是由协议层（使用何种协议进行通信？），设备层（这个设备可以做什么？），图像层（可以使用设备绘制哪一些图像？），组件层（可以使用图像绘制哪一些组件？），层层递进，保证互相之间互不干扰。我们下面就着重的关心协议层。协议层需要完成的就是将委托的命令（OLED命令）和委托的数据（OLED数据）发送到设备上即可。</p>
<h3 id="刨析我们的原理"><a href="#刨析我们的原理" class="headerlink" title="刨析我们的原理"></a>刨析我们的原理</h3><p>​    协议需要进行初始化，对于硬件，特别是HAL库，只需要咔咔调API就能把事情做完了。但是对于软件IIC，事情就需要麻烦一些，我们需要自己完成IIC时序的通信。</p>
<p>​    让我们看看IIC的基本原理，基本上看，就是：通知起始通信，通知数据（他是命令还是数据并不关心）和通知停止。</p>
<ol>
<li><strong>起始条件（Start Condition）</strong><br>主设备将SDA从高电平拉低，同时保持SCL为高电平。当SDA从高到低时形成起始条件（START），通知从设备通信即将开始。</li>
<li><strong>地址传输（Address Transmission）</strong><br>主设备发送一个7位或10位的从设备地址，紧接着是1位的读写方向标志位（R/W位）。<ul>
<li>R/W为0表示写操作，主设备发送数据</li>
<li>R/W为1表示读操作，主设备接收数据<br>每发送一位数据时，SCL产生一个时钟脉冲（SCL上升沿锁存数据）。</li>
</ul>
</li>
<li><strong>应答信号（ACK/NACK）</strong><br>从设备在收到地址和R/W位后，如果能够正常接收数据，会在下一个时钟周期内将SDA拉低产生应答信号ACK（Acknowledge）。如果不响应，则保持SDA为高电平，产生非应答信号NACK（Not Acknowledge）。</li>
<li><strong>数据传输（Data Transmission）</strong><br>主设备根据读写操作继续发送或接收数据，每次传输8位数据。<ul>
<li>写操作：主设备发送数据，从设备应答ACK</li>
<li>读操作：从设备发送数据，主设备应答ACK<br>每个字节传输完成后，从设备需发送ACK信号以确认接收正常。</li>
</ul>
</li>
<li><strong>停止条件（Stop Condition）</strong><br>通信结束时，主设备将SDA从低电平拉高，同时保持SCL为高电平。当SDA从低到高时形成停止条件（STOP），表示通信结束。</li>
</ol>
<p>​    说了一大堆，其实就是：</p>
<ol>
<li><strong>起始条件：SDA高变低，SCL保持高</strong></li>
<li><strong>数据传输：SDA根据数据位变化，SCL上升沿锁存数据</strong></li>
<li><strong>应答信号：从设备将SDA拉低产生ACK，高电平为NACK</strong></li>
<li><strong>停止条件：SDA低变高，SCL保持高</strong></li>
</ol>
<p>​    所以这样看来，无非就是使用两个引脚，按照上述规则进行高低电平的按照时序的拉高拉低。</p>
<p>​    话里有话，我的意思就是：软件IIC需要知道你使用哪两个引脚进行通信，需要你来告知如何完成上面的协议约定控制设备。最终我们提供的，是像我们跟人聊天一般的：</p>
<blockquote>
<p><strong>嘿！我用软件IIC发送了一个Byte的命令/数据！</strong></p>
</blockquote>
<p>​    这是重点！也是我们协议层抽象的终点：完成委托给我们的数据传输的任务，其他的任何事情都与我们无关，也不在乎这个数据到底是啥！</p>
<h3 id="如何完成我们的抽象"><a href="#如何完成我们的抽象" class="headerlink" title="如何完成我们的抽象"></a>如何完成我们的抽象</h3><p>​    <strong>软件IIC需要知道你使用哪两个引脚进行通信，需要你来告知如何完成上面的协议约定控制设备！</strong>我再强调的一次！</p>
<p>​    所以，我们给一个被抽象为软件IIC的实体，提供一个配置，这个配置委婉的提醒了我们的IIC使用哪两个引脚进行通信。最终这个软件IIC实体将会提供可以完成“委托给我们的数据传输的任务”这个任务，需要注意的是，OLED发送数据需要区分他是命令还是数据。这样来看，我们最终就是提供两套方法：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* command send fucntion *&#x2F;
typedef void(*SendCommand)(void*, uint8_t);
&#x2F;* data send fucntion *&#x2F;
typedef void(*SendData)(void*, uint8_t*, uint16_t);

&#x2F;* driver level oled driver&#39;s functionalities *&#x2F;
typedef struct __OLED_Operations&#123;
    SendCommand command_sender;
    SendData    data_sender;
&#125;OLED_Operations;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    好像很是罕见！这是一个包装了函数指针的结构体。说的拗口，让我们引入面对对象的设计逻辑来再阐述上面的句子。</p>
<blockquote>
<p>这是一个可以保证完成数据传输的OLED方法。调用这个方法，就可以保证我们完成了一个字节传递的命令，或者是完成一系列字节的数据传输</p>
</blockquote>
<p>​    又问我咋做的？先别管，你现在需要知道的是——我一调用！他就能干好这个事情！实现是下面的事情！它隶属于我们的协议实体的结构体，如下所示</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* this will make the gpio used for iic *&#x2F;
typedef struct __OLED_SOFT_IIC_Private_Config
&#123;
    &#x2F;* soft gpio handling *&#x2F; 
    OLED_IICGPIOPack       sda;
    OLED_IICGPIOPack       scl;
    uint32_t            accepted_time_delay;
    uint16_t            device_address;
    OLED_Operations     operation;
&#125;OLED_SOFT_IIC_Private_Config;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><strong><code>OLED_IICGPIOPack sda</code></strong><br>表示用于IIC的SDA（数据线）引脚配置。</p>
<ul>
<li><code>OLED_IICGPIOPack</code> 应该是一个结构体或类型，定义了与GPIO相关的参数，比如引脚号、端口等。</li>
<li>该成员用来指定IIC通信中用作SDA的具体引脚。</li>
</ul>
<p><strong><code>OLED_IICGPIOPack scl</code></strong><br>表示用于IIC的SCL（时钟线）引脚配置。</p>
<ul>
<li>同样是 <code>OLED_IICGPIOPack</code> 类型，用来配置时钟信号线（SCL）的具体引脚。</li>
<li>这个成员和 <code>sda</code> 一起决定了软IIC使用的GPIO引脚。</li>
</ul>
<p><strong><code>uint32_t accepted_time_delay</code></strong><br>用于设置IIC时序中的时间延迟。</p>
<ul>
<li>因为软IIC需要软件控制时序，这个值可能表示每个时钟周期的延迟时间（以微秒或纳秒为单位）。</li>
<li>调节这个值可以改变IIC的通信速度，从而适配不同的外设设备。</li>
</ul>
<p><strong><code>uint16_t device_address</code></strong><br>IIC从设备的地址。</p>
<ul>
<li>IIC通信中，每个从设备都有唯一的地址，用于主设备区分不同的从设备。</li>
<li>这个值通常是7位或10位地址，需要根据设备规格书配置。</li>
</ul>
<p><strong><code>OLED_Operations operation</code></strong><br>表示IIC通信的操作类型。</p>
<ul>
<li><code>OLED_Operations</code>定义了常见的IIC操作，比如 <code>READ</code>（读操作）、<code>WRITE</code>（写操作）等。</li>
</ul>
</blockquote>
<p>​    初始化的办法，这里就只需要按部就班的赋值。</p>
<pre class="line-numbers language-none"><code class="language-none">void oled_bind_softiic_handle(
    OLED_SOFT_IIC_Private_Config*   config,
    OLED_IICGPIOPack*                  sda,  
    OLED_IICGPIOPack*                  scl,
    uint16_t                        device_address,
    uint32_t                        accepted_time_delay
)
&#123;
    config-&gt;accepted_time_delay &#x3D; accepted_time_delay;
    config-&gt;device_address &#x3D; device_address;
    config-&gt;sda &#x3D; *sda;
    config-&gt;scl &#x3D; *scl;
    config-&gt;operation.command_sender    &#x3D; ?
    config-&gt;operation.data_sender       &#x3D; ?
    &#x2F;* we need to init the gpio type for communications *&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    我们的函数写到下面就顿住了。对啊，咋发送啊？咋操作啊？这才是这个时候我们思考的问题：如何实现软件IIC呢？</p>
<p>​    我们首先需要完成的是：初始化我们的引脚，让他们可以完成传递电平的任务。</p>
<pre class="line-numbers language-none"><code class="language-none">static void __pvt_on_init_iic_gpio(OLED_SOFT_IIC_Private_Config* config)
&#123;
    &#x2F;* Enable the GPIOB clock *&#x2F;
    &#x2F;* 这就是把时钟打开了而已，是__HAL_RCC_GPIOB_CLK_ENABLE的一个等价替换 *&#x2F;
    &#x2F;* 
    	#define OLED_ENABLE_GPIO_SCL_CLK() __HAL_RCC_GPIOB_CLK_ENABLE()
		#define OLED_ENABLE_GPIO_SDA_CLK() __HAL_RCC_GPIOB_CLK_ENABLE()
    *&#x2F;
    &#x2F;&#x2F; 为什么这样做。。。你换引脚了直接改上面的#define不香吗？集中起来处理一坨屎而不是让你的史满天飞到处改
    OLED_ENABLE_GPIO_SCL_CLK();
    OLED_ENABLE_GPIO_SDA_CLK();

    GPIO_InitTypeDef GPIO_InitStructure &#x3D; &#123;0&#125;;
    &#x2F;* configuration *&#x2F;
    GPIO_InitStructure.Pin &#x3D; config-&gt;sda.pin | config-&gt;scl.pin;
    GPIO_InitStructure.Mode &#x3D; GPIO_MODE_OUTPUT_OD;			&#x2F;&#x2F; 开漏模式
    GPIO_InitStructure.Pull &#x3D; GPIO_NOPULL;					&#x2F;&#x2F; 不上拉也不下拉
    GPIO_InitStructure.Speed &#x3D; GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStructure);
    &#x2F;&#x2F; 这个是一个非常方便的宏，是笔者自己封装的：
    &#x2F;*
    	#define SET_SCL(config, pinstate) \
        do&#123;\
            HAL_GPIO_WritePin(config-&gt;scl.port, config-&gt;scl.pin, pinstate);\
        &#125;while(0)

		#define SET_SDA(config, pinstate) \
        do&#123;\
            HAL_GPIO_WritePin(config-&gt;sda.port, config-&gt;sda.pin, pinstate);\
        &#125;while(0)
    *&#x2F;
    SET_SCL(config, 1);
    SET_SDA(config, 1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="插入几个C语言小技巧"><a href="#插入几个C语言小技巧" class="headerlink" title="插入几个C语言小技巧"></a>插入几个C语言小技巧</h3><blockquote>
<ol>
<li><p>结构体的使用更加像是对一个物理实体的抽象，比如说我们的软件IIC实体由两个GPIO引脚，提供一个OLED地址和延迟时间组成，他可以发送命令和数据</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* this will make the gpio used for iic *&#x2F;
typedef struct __OLED_SOFT_IIC_Private_Config
&#123;
    &#x2F;* soft gpio handling *&#x2F; 
    OLED_IICGPIOPack       sda;
    OLED_IICGPIOPack       scl;
    uint32_t            accepted_time_delay;
    uint16_t            device_address;
    OLED_Operations     operation;
&#125;OLED_SOFT_IIC_Private_Config;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的抽象也就呼之欲出了</p>
</li>
<li><p>为什么使用do while呢？答案是：符合大部分人的使用习惯。</p>
<p><strong>避免宏定义中的语法问题</strong><br>在宏中使用 <code>do &#123; &#125; while(0);</code> 可以确保宏内容被当作一个独立的语句块执行。<br>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">#define MY_MACRO(x) do &#123; if (x) func(); &#125; while (0)  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样，即使在使用时加上分号也不会引发编译错误：</p>
<pre class="line-numbers language-none"><code class="language-none">if (condition)  
    MY_MACRO(1);  &#x2F;&#x2F; 正确处理，避免语法歧义  
else  
    other_func();  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果直接使用 <code>&#123;&#125;</code> 而不加 <code>do-while(0)</code>，编译器可能会报错或者导致意外的逻辑问题。</p>
<p><strong>提升代码的可读性与可维护性</strong><br><code>do &#123; &#125; while(0);</code> 语法块明确限制了语句作用范围，避免宏或语句中的变量污染外部作用域，从而增强代码的封装性。</p>
<p><strong>兼容语法规则，减少隐患</strong><br><code>do &#123; &#125; while(0);</code> 总能确保语法结构合法，即使宏中包含复杂的控制语句也不会影响逻辑。</p>
<pre class="line-numbers language-none"><code class="language-none">#define SAFE_BLOCK do &#123; statement1; statement2; &#125; while(0)  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样即便加了分号也能正常执行，符合常规语句格式。</p>
<p><strong>避免空语句问题</strong><br>使用 <code>do-while(0)</code> 可以有效避免空语句可能带来的逻辑漏洞。</p>
<p>你问我担心开销？拜托！编译器会自动优化！全给你消的一点不剩了，完全就是正常的调用，为啥不用？</p>
</li>
<li><p>为什么在函数的起头带上static?</p>
<p>保证我们的函数在文件作用域是私有的，不会跟其他函数起冲突的。说白了，就是我说的：你需要在干别的事情还要担心一下自己的软件IIC是咋工作的吗？你不需要！担心是一个有病的行为。所以，他保证了接口是简洁的。</p>
</li>
</ol>
</blockquote>
<h3 id="完成软件IIC通信"><a href="#完成软件IIC通信" class="headerlink" title="完成软件IIC通信"></a>完成软件IIC通信</h3><h4 id="开始我们的IIC通信"><a href="#开始我们的IIC通信" class="headerlink" title="开始我们的IIC通信"></a>开始我们的IIC通信</h4><p>​    软件IIC通信开始，需要先拉高SDA和SCL保证处于高电平，然后拽低SDA和SCL的电平</p>
<pre class="line-numbers language-none"><code class="language-none">static void __pvt_on_start_iic(OLED_SOFT_IIC_Private_Config* config) 
&#123;
    SET_SDA(config, 1);
    SET_SCL(config, 1);
    SET_SDA(config, 0);
    SET_SCL(config, 0);    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="结束我们的IIC通信"><a href="#结束我们的IIC通信" class="headerlink" title="结束我们的IIC通信"></a>结束我们的IIC通信</h4><p>​    设置我们的SDA先低，之后让SDA和SCL都处于高电平结束战斗</p>
<pre class="line-numbers language-none"><code class="language-none">static void __pvt_on_stop_iic(OLED_SOFT_IIC_Private_Config* handle)
&#123;
	SET_SDA(handle, 0);		
	SET_SCL(handle, 1);		
	SET_SDA(handle, 1);		 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="发送一个字节"><a href="#发送一个字节" class="headerlink" title="发送一个字节"></a>发送一个字节</h4><p>​    发送一个目标字节给我们的设备，你不需要关心这个字节是什么，你不需要现在关心它！</p>
<pre class="line-numbers language-none"><code class="language-none">static void __pvt_iic_send_bytes(OLED_SOFT_IIC_Private_Config* handle, uint8_t data)
&#123;	
	for (uint8_t i &#x3D; 0; i &lt; 8; i++)
	&#123;	
		SET_SDA(handle,!!(data &amp; (0x80 &gt;&gt; i)));
		SET_SCL(handle,1);	
		SET_SCL(handle,0);	
	&#125;
	
	SET_SCL(handle,1);		
	SET_SCL(handle,0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>!!</code> 的作用是将任意数值转换为布尔值，保证我们发的就是0和1，<code>(0x80 &gt;&gt; i)</code>萃取了从高向低数的第I位数字发送，也就是往SDA电平上传递我们的data上的第I位。之后拉起释放SCL告知完成传递。</p>
</blockquote>
<h4 id="（重要）完成命令传递和数据传递"><a href="#（重要）完成命令传递和数据传递" class="headerlink" title="（重要）完成命令传递和数据传递"></a>（重要）完成命令传递和数据传递</h4><p>​    我们现在开始想起来，我们最终的目的是：完成一个字节命令的传递或者是传递一系列的数据比特。结合手册，我们来看看实际上怎么做。</p>
<p>​    按照顺序，依次传递</p>
<ul>
<li>开启IIC通信</li>
<li>设备的地址</li>
<li>数据类型（是命令还是数据）</li>
<li>数据本身。</li>
<li>结束IIC通信</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
	#define DATA_PREFIX     (0x40)
	#define CMD_PREFIX      (0x00)
*&#x2F;
static void __pvt_iic_send_command(void* pvt_handle, uint8_t cmd)
&#123;
    OLED_SOFT_IIC_Private_Config* config &#x3D; 
        (OLED_SOFT_IIC_Private_Config*)pvt_handle;

    __pvt_on_start_iic(config);
    __pvt_iic_send_bytes(config, config-&gt;device_address);
    __pvt_iic_send_bytes(config, CMD_PREFIX);
    __pvt_iic_send_bytes(config, cmd);
    __pvt_on_stop_iic(config);
&#125;

static void __pvt_iic_send_data(
    void* pvt_handle, 
    uint8_t* data, uint16_t size)
&#123;
    OLED_SOFT_IIC_Private_Config* config &#x3D; 
        (OLED_SOFT_IIC_Private_Config*)pvt_handle;
    __pvt_on_start_iic(config);
    __pvt_iic_send_bytes(config, config-&gt;device_address);
    __pvt_iic_send_bytes(config, DATA_PREFIX);
    for(uint16_t i &#x3D; 0; i &lt; size; i++)
        __pvt_iic_send_bytes(config, data[i]);
    __pvt_on_stop_iic(config); 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="最终一击，完成我们的IIC通信"><a href="#最终一击，完成我们的IIC通信" class="headerlink" title="最终一击，完成我们的IIC通信"></a>最终一击，完成我们的IIC通信</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
    config: 
        Pointer to an OLED_SOFT_IIC_Private_Config structure that 
        contains the configuration settings for the software I2C communication,
        such as timing, pins, and other relevant parameters.
        config should be blank or uninitialized.
    sda: 
        Pointer to an OLED_GPIOPack structure that 
        represents the GPIO configuration for the Serial Data (SDA) line of 
        the software I2C interface.

    scl: 
        Pointer to an OLED_GPIOPack structure that 
        represents the GPIO configuration for the Serial Clock (SCL) line of 
        the software I2C interface.

    device_address: 
        The 7-bit I2C address of the device that the software I2C 
        communication is targeting, typically used to identify the 
        device on the I2C bus.

    accepted_time_delay: 
        A timeout value in milliseconds, 
        specifying the maximum allowed delay for the software 
        I2C communication process.
*&#x2F;
void oled_bind_softiic_handle(
    OLED_SOFT_IIC_Private_Config*   config,
    OLED_IICGPIOPack*                  sda,  
    OLED_IICGPIOPack*                  scl,
    uint16_t                        device_address,
    uint32_t                        accepted_time_delay
)&#123;
    config-&gt;accepted_time_delay &#x3D; accepted_time_delay;
    config-&gt;device_address &#x3D; device_address;
    config-&gt;sda &#x3D; *sda;
    config-&gt;scl &#x3D; *scl;
    config-&gt;operation.command_sender    &#x3D; __pvt_iic_send_command;
    config-&gt;operation.data_sender       &#x3D; __pvt_iic_send_data;
    __pvt_on_init_iic_gpio(config);	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    我们把方法和数据都传递给这个软件iic实体，现在，他就能完成一次软件IIC通信了。给各位看看如何使用</p>
<pre class="line-numbers language-none"><code class="language-none">config-&gt;operation.command_sender(config, oled_spi_init_command[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    可以看到，我们的结构体函数指针就是这样使用的。</p>
<h2 id="硬件IIC"><a href="#硬件IIC" class="headerlink" title="硬件IIC"></a>硬件IIC</h2><p>​    硬件IIC事情就会简单特别多，原因在于，我们有专门的硬件帮助我们完成IIC通信</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef OLED_HARD_IIC_H
#define OLED_HARD_IIC_H
#include &quot;OLED&#x2F;Driver&#x2F;oled_config.h&quot;
#include &quot;stm32f1xx_hal.h&quot;
#include &quot;stm32f1xx_hal_i2c.h&quot;

typedef struct __OLED_HARD_IIC_Private_Config&#123;
    I2C_HandleTypeDef*  pvt_handle;
    uint32_t            accepted_time_delay;
    uint16_t            device_address;
    OLED_Operations     operation;
&#125;OLED_HARD_IIC_Private_Config;

&#x2F;* 
    handle binder, bind the raw data to the oled driver
    
    blank_config: Pointer to an OLED_HARD_IIC_Private_Config structure that 
        holds the configuration settings for the I2C communication, 
        typically initializing the OLED hardware interface.
    
    raw_handle: 
        Pointer to an I2C_HandleTypeDef structure, 
        representing the raw I2C peripheral handle used to 
        configure and manage I2C communication for the device.

    device_address: The 7-bit I2C address of the device to 
        which the communication is being established, 
        typically used for identifying the target device on the I2C bus.

    accepted_time_delay: A timeout value in milliseconds 
        that specifies the maximum allowable 
        delay for the I2C communication process.
*&#x2F;
void bind_hardiic_handle(
    OLED_HARD_IIC_Private_Config* blank_config,
    I2C_HandleTypeDef* raw_handle,
    uint16_t    device_address,
    uint32_t    accepted_time_delay
);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    现在我们可以不需要两个引脚了，只需要客户端提供一个硬件IIC句柄就好。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;OLED&#x2F;Driver&#x2F;hard_iic&#x2F;hard_iic.h&quot;

static void __pvt_hardiic_send_data(void* pvt_handle, uint8_t* data, uint16_t size)
&#123;
    OLED_HARD_IIC_Private_Config* config &#x3D; 
        (OLED_HARD_IIC_Private_Config*)pvt_handle;
    for (uint8_t i &#x3D; 0; i &lt; size; i ++)
	&#123;
		 HAL_I2C_Mem_Write(
            config-&gt;pvt_handle,
            config-&gt;device_address,
            DATA_PREFIX,
            I2C_MEMADD_SIZE_8BIT,
            &amp;data[i], 1, config-&gt;accepted_time_delay);	&#x2F;&#x2F;依次发送Data的每一个数据
	&#125;
&#125;

static void __pvt_hardiic_send_command(void* pvt_handle, uint8_t cmd)
&#123;
    OLED_HARD_IIC_Private_Config* config &#x3D; 
        (OLED_HARD_IIC_Private_Config*)pvt_handle;
    HAL_I2C_Mem_Write(
        config-&gt;pvt_handle, 
        config-&gt;device_address,
        CMD_PREFIX,
        I2C_MEMADD_SIZE_8BIT,
        &amp;cmd,1,config-&gt;accepted_time_delay);
&#125;

void bind_hardiic_handle(
    OLED_HARD_IIC_Private_Config* blank_config,
    I2C_HandleTypeDef* raw_handle,
    uint16_t    device_address,
    uint32_t    accepted_time_delay
)
&#123;
    blank_config-&gt;accepted_time_delay &#x3D; accepted_time_delay;
    blank_config-&gt;device_address &#x3D; device_address;
    blank_config-&gt;pvt_handle &#x3D; raw_handle;
    blank_config-&gt;operation.command_sender  &#x3D; __pvt_hardiic_send_command;
    blank_config-&gt;operation.data_sender     &#x3D; __pvt_hardiic_send_data;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    HAL_I2C_Mem_Write函数直接完成了我们的委托，注意的是，我们每一次的调用这个函数，内部都是重新开始一次IIC通信的，所以，发送数据的时候，只能一个字节一个字节的发送（因为每一次都要指定这个是数据还是命令）。这一点，SPI协议的OLED就要好很多！（内部的引脚高低就直接决定了整个是命令还是数据，不需要通过解析传递的数据本身！）</p>
<p>​    这样，一个典型的基于软硬件IIC的协议层抽象就完成了。如果你着急测试的话，可以自己替换原本OLED的操作。</p>
<p>​    我们下一篇，就是开始抽象OLED的设备层。</p>
<h1 id="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（OLED设备层驱动封装）"><a href="#从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（OLED设备层驱动封装）" class="headerlink" title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（OLED设备层驱动封装）"></a>从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（OLED设备层驱动封装）</h1><h2 id="OLED设备层驱动开发"><a href="#OLED设备层驱动开发" class="headerlink" title="OLED设备层驱动开发"></a>OLED设备层驱动开发</h2><p>​    现在，我们终于来到了最难的设备层驱动开发。在这里，我们抽象出来了一个叫做OLED_Device的东西，我们终于可以关心的是一块OLED，他可以被打开，被设置，被关闭，可以绘制点，可以绘制面，可以清空，可以反色等等。（画画不是这个层次该干的事情，要知道，绘制一个图形需要<strong>从这个设备可以被绘制开始，也就是他可以画点，画面开始</strong>！）</p>
<p>​    所以，离我在这篇总览中<a target="_blank" rel="noopener" href="https://blog.csdn.net/charlie114514191/article/details/145397231提到的绘制一个多级菜单还是有一些遥远的。饭一口口吃，事情一步步做，这急不得，一着急反而会把我们精心维护的抽象破坏掉。">https://blog.csdn.net/charlie114514191/article/details/145397231提到的绘制一个多级菜单还是有一些遥远的。饭一口口吃，事情一步步做，这急不得，一着急反而会把我们精心维护的抽象破坏掉。</a></p>
<p>​    代码在<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED/library/OLED">MCU_Libs/OLED/library/OLED at main · Charliechen114514/MCU_Libs (github.com)</a>，两个文件夹都有所涉及，所以本篇的代码量会非常巨大。请各位看官合理安排。</p>
<h3 id="如何抽象一个OLED"><a href="#如何抽象一个OLED" class="headerlink" title="如何抽象一个OLED"></a>如何抽象一个OLED</h3><p>​    协议层上，我们抽象了一个IIC协议。现在在设备层上，我们将进一步抽象一个OLED。上面笔者提到了，一个OLED可以被开启，关闭，画点画面，反色等等操作，他能干！他如何干是我们马上要做的事情。现在，我们需要一个OLED句柄。这个OLED句柄代表了<strong>背后使用的通信协议和它自身相关的属性信息</strong>，而不必要外泄到其他模块上去。所以，封装一个这样的抽象变得很有必要。</p>
<p>​    OLED的品种很多，分法也很多，笔者顺其自然，打算封装一个这样的结构体</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct __OLED_Handle_Type&#123;
    &#x2F;* driver types announced the way we explain the handle *&#x2F;
    OLED_Driver_Type        stored_handle_type;
    &#x2F;* handle data types here *&#x2F;
    OLED_Handle_Private     private_handle;
&#125;OLED_Handle;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    让我来解释一下：首先，我们的OLED品种很多，程序如何知道你的OLED如何被解释呢？stored_handle_type标识的类型来决定采取何种行动解释。。。什么呢？解释我们的private_handle。</p>
<pre class="line-numbers language-none"><code class="language-none">typedef enum &#123;
    OLED_SOFT_IIC_DRIVER_TYPE,
    OLED_HARD_IIC_DRIVER_TYPE,
    OLED_SOFT_SPI_DRIVER_TYPE,
    OLED_HARD_SPI_DRIVER_TYPE
&#125;OLED_Driver_Type;

&#x2F;*  
    to abstract the private handle base 
    this is to isolate the dependencies of
    the real implementations
*&#x2F;
typedef void* OLED_Handle_Private;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    也就是说，笔者按照采取的协议进行抽象，将OLED<strong>本身的信息属性差异封装到文件内部去</strong>，作为使用不同的片子，只需要使用编译宏编译不同的文件就好了。现在，OLED_Handle就是我们的OLED，拿到这个结构体，我们就掌握了整个OLED。所以，整个OLED结构体必然可以做到如下的事情</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef OLED_BASE_DRIVER_H
#define OLED_BASE_DRIVER_H

#include &quot;oled_config.h&quot;

typedef struct __OLED_Handle_Type&#123;
    &#x2F;* driver types announced the way we explain the handle *&#x2F;
    OLED_Driver_Type        stored_handle_type;
    &#x2F;* handle data types here *&#x2F;
    OLED_Handle_Private     private_handle;
&#125;OLED_Handle;

&#x2F;*
    oled_init_hardiic_handle registers the hardiic commnications
handle: 
    Pointer to an OLED_Handle structure that represents the handle 
    for the OLED display, used for managing 
    and controlling the OLED device.
    programmers should pass a blank one!

config: 
    Pointer to an OLED_HARD_IIC_Private_Config structure 
    that contains the configuration settings 
    for initializing the hardware interface, 
    typically related to the I2C communication 
    parameters for the OLED display.
*&#x2F;
&#x2F;&#x2F; 按照硬件IIC进行初始化
void oled_init_hardiic_handle(
    OLED_Handle* handle, 
    OLED_HARD_IIC_Private_Config* config);

&#x2F;*
    oled_init_hardiic_handle registers the hardiic commnications
handle: 
    Pointer to an OLED_Handle structure that represents the handle 
    for the OLED display, used for managing 
    and controlling the OLED device.
    programmers should pass a blank one!

config: 
    Pointer to an OLED_SOFT_IIC_Private_Config structure 
    that contains the configuration settings 
    for initializing the hardware interface, 
    typically related to the I2C communication 
    parameters for the OLED display.
*&#x2F;
&#x2F;&#x2F; 按照软件IIC进行初始化
void oled_init_softiic_handle(
    OLED_Handle* handle,
    OLED_SOFT_IIC_Private_Config* config
);

&#x2F;* 可以清空 *&#x2F;
void oled_helper_clear_frame(OLED_Handle* handle);
void oled_helper_clear_area(OLED_Handle* handle, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height);

&#x2F;* 需要刷新，这里采用了缓存机制 *&#x2F;
void oled_helper_update(OLED_Handle* handle);
void oled_helper_update_area(OLED_Handle* handle, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height);

&#x2F;* 可以反色 *&#x2F;
void oled_helper_reverse(OLED_Handle* handle);
void oled_helper_reversearea(OLED_Handle* handle, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height);

&#x2F;* 可以绘制 *&#x2F;
void oled_helper_setpixel(OLED_Handle* handle, uint16_t x, uint16_t y);
void oled_helper_draw_area(OLED_Handle* handle, 
        uint16_t x, uint16_t y, uint16_t width, 
        uint16_t height, uint8_t* sources);

&#x2F;* 自身的属性接口，是我们之后要用的 *&#x2F;
uint8_t     oled_support_rgb(OLED_Handle* handle);
uint16_t    oled_width(OLED_Handle* handle);
uint16_t    oled_height(OLED_Handle* handle);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    说完了接口，下面就是实现了。</p>
<h3 id="完成OLED的功能"><a href="#完成OLED的功能" class="headerlink" title="完成OLED的功能"></a>完成OLED的功能</h3><h4 id="初始化OLED"><a href="#初始化OLED" class="headerlink" title="初始化OLED"></a>初始化OLED</h4><p>​    整个事情我们终于开始翻开我们的OLED手册了。我们的OLED需要一定的初始化。让我们看看江科大代码是如何进行OLED的初始化。</p>
<pre class="line-numbers language-none"><code class="language-none">void OLED_Init(void)
&#123;
	uint32_t i, j;
	
	for (i &#x3D; 0; i &lt; 1000; i++)			&#x2F;&#x2F;上电延时
	&#123;
		for (j &#x3D; 0; j &lt; 1000; j++);
	&#125;
	
	OLED_I2C_Init();			&#x2F;&#x2F;端口初始化
	
	OLED_WriteCommand(0xAE);	&#x2F;&#x2F;关闭显示
	
	OLED_WriteCommand(0xD5);	&#x2F;&#x2F;设置显示时钟分频比&#x2F;振荡器频率
	OLED_WriteCommand(0x80);
	
	OLED_WriteCommand(0xA8);	&#x2F;&#x2F;设置多路复用率
	OLED_WriteCommand(0x3F);
	
	OLED_WriteCommand(0xD3);	&#x2F;&#x2F;设置显示偏移
	OLED_WriteCommand(0x00);
	
	OLED_WriteCommand(0x40);	&#x2F;&#x2F;设置显示开始行
	
	OLED_WriteCommand(0xA1);	&#x2F;&#x2F;设置左右方向，0xA1正常 0xA0左右反置
	
	OLED_WriteCommand(0xC8);	&#x2F;&#x2F;设置上下方向，0xC8正常 0xC0上下反置
 
	OLED_WriteCommand(0xDA);	&#x2F;&#x2F;设置COM引脚硬件配置
	OLED_WriteCommand(0x12);
	
	OLED_WriteCommand(0x81);	&#x2F;&#x2F;设置对比度控制
	OLED_WriteCommand(0xCF);
 
	OLED_WriteCommand(0xD9);	&#x2F;&#x2F;设置预充电周期
	OLED_WriteCommand(0xF1);
 
	OLED_WriteCommand(0xDB);	&#x2F;&#x2F;设置VCOMH取消选择级别
	OLED_WriteCommand(0x30);
 
	OLED_WriteCommand(0xA4);	&#x2F;&#x2F;设置整个显示打开&#x2F;关闭
 
	OLED_WriteCommand(0xA6);	&#x2F;&#x2F;设置正常&#x2F;倒转显示
 
	OLED_WriteCommand(0x8D);	&#x2F;&#x2F;设置充电泵
	OLED_WriteCommand(0x14);
 
	OLED_WriteCommand(0xAF);	&#x2F;&#x2F;开启显示
		
	OLED_Clear();				&#x2F;&#x2F;OLED清屏
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    好长一大串，麻了，代码真的不好看。我们为什么不使用数组进行初始化呢？</p>
<pre class="line-numbers language-none"><code class="language-none">uint8_t oled_init_commands[] &#x3D; &#123;
    0xAE,  &#x2F;&#x2F; Turn off OLED panel
    0xFD, 0x12,  &#x2F;&#x2F; Set display clock divide ratio&#x2F;oscillator frequency
    0xD5,  &#x2F;&#x2F; Set display clock divide ratio
    0xA0,  &#x2F;&#x2F; Set multiplex ratio
    0xA8,  &#x2F;&#x2F; Set multiplex ratio (1 to 64)
    0x3F,  &#x2F;&#x2F; 1&#x2F;64 duty
    0xD3,  &#x2F;&#x2F; Set display offset
    0x00,  &#x2F;&#x2F; No offset
    0x40,  &#x2F;&#x2F; Set start line address
    0xA1,  &#x2F;&#x2F; Set SEG&#x2F;Column mapping (0xA0 for reverse, 0xA1 for normal)
    0xC8,  &#x2F;&#x2F; Set COM&#x2F;Row scan direction (0xC0 for reverse, 0xC8 for normal)
    0xDA,  &#x2F;&#x2F; Set COM pins hardware configuration
    0x12,  &#x2F;&#x2F; COM pins configuration
    0x81,  &#x2F;&#x2F; Set contrast control register
    0xBF,  &#x2F;&#x2F; Set SEG output current brightness
    0xD9,  &#x2F;&#x2F; Set pre-charge period
    0x25,  &#x2F;&#x2F; Set pre-charge as 15 clocks &amp; discharge as 1 clock
    0xDB,  &#x2F;&#x2F; Set VCOMH
    0x34,  &#x2F;&#x2F; Set VCOM deselect level
    0xA4,  &#x2F;&#x2F; Disable entire display on
    0xA6,  &#x2F;&#x2F; Disable inverse display on
    0xAF   &#x2F;&#x2F; Turn on the display
&#125;;
#define CMD_TABLE_SZ ( (sizeof(oled_init_commands)) &#x2F; sizeof(oled_init_commands[0]) )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    现在，我们只需要按部就班的按照顺序发送我们的指令。以hardiic的初始化为例子</p>
<pre class="line-numbers language-none"><code class="language-none">void oled_init_hardiic_handle(
    OLED_Handle* handle, 
    OLED_HARD_IIC_Private_Config* config)
&#123;
	&#x2F;&#x2F; 传递使用的协议句柄, 以及告知我们的句柄类型 
    handle-&gt;private_handle &#x3D; config;
    handle-&gt;stored_handle_type &#x3D; OLED_HARD_IIC_DRIVER_TYPE;
    &#x2F;&#x2F; 按部就班的发送命令表
    for(uint8_t i &#x3D; 0; i &lt; CMD_TABLE_SZ; i++)
    	&#x2F;&#x2F; 这里我们协议的send_command就发力了, 现在我们完全不关心他是如何发送命令的
        config-&gt;operation.command_sender(config, oled_init_commands[i]);
    &#x2F;&#x2F; 把frame清空掉
    oled_helper_clear_frame(handle);
    &#x2F;&#x2F; 把我们的frame commit上去
    oled_helper_update(handle);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这里我们还剩下最后两行代码没解释，为什么是oled_helper_clear_frame和update要分离开来呢？我们知道，频繁的刷新OLED屏幕非常占用我们的单片机内核，也不利于我们合并绘制操作。比如说，我想绘制两个圆，为什么不画完一起更新上去呢？比起来画一个点更新一下，这个操作显然更合理。所以，为了完成这样的技术，我们需要一个Buffer缓冲区。</p>
<pre class="line-numbers language-none"><code class="language-none">uint8_t OLED_GRAM[OLED_HEIGHT][OLED_WIDTH];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    他就承担了我们的缓存区。多大呢？这个事情跟OLED的种类有关系，一些OLED的大小是128 x 64，另一些是144 x 64，无论如何，我们需要根据chip的种类，来选择我们的OLED的大小，更加严肃的说，是OLED的属性和它的功能。</p>
<p>​    所以，这就是为什么笔者在<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/blob/main/OLED/library/OLED/Driver/oled_config.h">MCU_Libs/OLED/library/OLED/Driver/oled_config.h at main · Charliechen114514/MCU_Libs (github.com)</a>文件中，引入了这样的控制宏</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef SSD1306_H
#define SSD1306_H

&#x2F;* hardware level defines *&#x2F;
#define PORT_SCL    GPIOB
#define PORT_SDA    GPIOB
#define PIN_SCL     GPIO_PIN_8
#define PIN_SDA     GPIO_PIN_9

#define OLED_ENABLE_GPIO_SCL_CLK() __HAL_RCC_GPIOB_CLK_ENABLE()
#define OLED_ENABLE_GPIO_SDA_CLK() __HAL_RCC_GPIOB_CLK_ENABLE()

#define OLED_WIDTH  (128)
#define OLED_HEIGHT (8)

#define POINT_X_MAX     (OLED_WIDTH)
#define POINT_Y_MAX     (OLED_HEIGHT * 8)

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这个文件是ssd1306.h，这个文件专门承载了关于SSD1306配置的一切。现在，我们将OLED的配置系统建立起来了，当我们的chip是SSD1306的时候，只需要定义SSD1306的宏</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef OLED_CONFIG_H
#define OLED_CONFIG_H

...

&#x2F;* oled chips selections *&#x2F;

#ifdef SSD1306

#include &quot;configs&#x2F;ssd1306.h&quot;

#elif SSD1309
#include &quot;configs&#x2F;ssd1309.h&quot;
#else
#error &quot;Unknown chips, please select in compile time using define!&quot;
#endif

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    现在，我们的configure就完整了，我们只需要依赖config文件就能知道OLED自身的全部信息。如果你有IDE，现在就可以看到，当我们定义了SSD1306的时候，我们的OLED_GRAM自动调整为<code>OLED_GRAM[8][128]</code>的数组，另一放面，如果我们使用了SSD1309，我们自动会更新为<code>OLED_GRAM[8][144]</code>,此事在ssd1309.h中亦有记载</p>
<h4 id="清空屏幕"><a href="#清空屏幕" class="headerlink" title="清空屏幕"></a>清空屏幕</h4><p>​    显然，我们有一些人对C库并不太了解，memset函数负责将一块内存设置为给定的值。一般而言，编译器实现将会使用独有的硬件加速优化，使用上，绝对比手动设置值只快不慢。</p>
<blockquote>
<p>软件工程的一大原则：复用！能不自己手搓就不自己手搓，编译器提供了就优先使用编译器提供的</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">void oled_helper_clear_frame(OLED_Handle* handle)
&#123;
    memset(OLED_GRAM, 0, sizeof(OLED_GRAM));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="刷新屏幕与光标设置1"><a href="#刷新屏幕与光标设置1" class="headerlink" title="刷新屏幕与光标设置1"></a>刷新屏幕与光标设置1</h4><p>​    设置涂写光标，就像我们使用Windows的绘图软件一样，鼠标在哪里，左键嗯下就从那里开始绘制，我们的set_cursor函数就是干设置鼠标在哪里的工作。查询手册，我们可以这样书写（笔者是直接参考了江科大的实现）</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
    set operating cursor
*&#x2F;
void __pvt_oled_set_cursor(
    OLED_Handle* handle, 
    const uint8_t y,
    const uint8_t x)
&#123;   
    const uint8_t new_x &#x3D; x + 2;
    OLED_Operations op_table;
    __on_fetch_oled_table(handle, &amp;op_table);
    op_table.command_sender(handle-&gt;private_handle, 0xB0 | y);
	op_table.command_sender(handle-&gt;private_handle,0x10 | ((new_x &amp; 0xF0) &gt;&gt; 4));	&#x2F;&#x2F;设置X位置高4位
	op_table.command_sender(handle-&gt;private_handle,0x00 | (new_x &amp; 0x0F));			&#x2F;&#x2F;设置X位置低4位
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="刷新屏幕与光标设置2"><a href="#刷新屏幕与光标设置2" class="headerlink" title="刷新屏幕与光标设置2"></a>刷新屏幕与光标设置2</h4><p>​    不对，这个代码没有看懂！其一原因是我没有给出__on_fetch_oled_table是什么。</p>
<pre class="line-numbers language-none"><code class="language-none">static void __on_fetch_oled_table(
    const OLED_Handle* handle, 
    OLED_Operations* blank_operations)
&#123;
    switch (handle-&gt;stored_handle_type)
    &#123;
        case OLED_HARD_IIC_DRIVER_TYPE:
        &#123;
            OLED_HARD_IIC_Private_Config* config &#x3D; 
                (OLED_HARD_IIC_Private_Config*)(handle-&gt;private_handle);
            blank_operations-&gt;command_sender &#x3D; config-&gt;operation.command_sender;
            blank_operations-&gt;data_sender &#x3D; config-&gt;operation.data_sender;
        &#125;break;
        case OLED_SOFT_IIC_DRIVER_TYPE:
        &#123;
            OLED_SOFT_IIC_Private_Config* config &#x3D; 
                (OLED_SOFT_IIC_Private_Config*)(handle-&gt;private_handle);
            blank_operations-&gt;command_sender &#x3D; config-&gt;operation.command_sender;
            blank_operations-&gt;data_sender &#x3D; config-&gt;operation.data_sender;
        &#125;break;
		... &#x2F;&#x2F; ommited spi seletctions
        &#125;break;
        default:
            break;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这是干什么呢？答案是：根据OLED的类型，选择我们的操作句柄。这是因为C语言没法自动识别void*的原貌是如何的，我们必须将<code>C++</code>中的虚表选择手动的完成</p>
<blockquote>
<p>题外话：接触过C++的朋友都知道继承这个操作，实际上，这里就是一种继承。无论是何种IIC操作，都是IIC操作。他都必须遵守可以发送字节的接口操作，现在的问题是：他到底是哪样的IIC？需要执行的是哪样IIC的操作呢？所以，__on_fetch_oled_table就是把正确的操作函数根据OLED的类型给筛选出来。也就是C++中的虚表选择操作</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*
    set operating cursor
*&#x2F;
void __pvt_oled_set_cursor(
    OLED_Handle* handle, 
    const uint8_t y,
    const uint8_t x)
&#123;   
    const uint8_t new_x &#x3D; x + 2;
    OLED_Operations op_table;
    __on_fetch_oled_table(handle, &amp;op_table);
    op_table.command_sender(handle-&gt;private_handle, 0xB0 | y);
	op_table.command_sender(handle-&gt;private_handle,0x10 | ((new_x &amp; 0xF0) &gt;&gt; 4));	&#x2F;&#x2F;设置X位置高4位
	op_table.command_sender(handle-&gt;private_handle,0x00 | (new_x &amp; 0x0F));			&#x2F;&#x2F;设置X位置低4位
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    现在回到上面的代码，我们将正确的操作句柄选择出来之后，可以发送设置“鼠标”的指令了。</p>
<blockquote>
<p>复习一下位操作的基本组成</p>
<ul>
<li>&amp;是一种萃取操作，任何数&amp;0就是0，&amp;1则是本身，说明可以通过对应&amp;1保留对应位，&amp;0抹除对应位</li>
<li>|是一种赋值操作，任何数&amp;1就是1，|0是本身，所以|可以起到对应位置1的操作。</li>
</ul>
<p>所以，保留高4位只需要 &amp; 0xF0（0b11110000），保留低四位只需要&amp;0x0F就好了（0b00001111）</p>
</blockquote>
<h4 id="刷新屏幕与光标设置3"><a href="#刷新屏幕与光标设置3" class="headerlink" title="刷新屏幕与光标设置3"></a>刷新屏幕与光标设置3</h4><p>​    现在让我们看看刷新屏幕是怎么做的</p>
<pre class="line-numbers language-none"><code class="language-none">void oled_helper_update(OLED_Handle* handle)
&#123;
    OLED_Operations op_table;
    __on_fetch_oled_table(handle, &amp;op_table);
    	
	for (uint8_t j &#x3D; 0; j &lt; OLED_HEIGHT; j ++)
	&#123;
		&#x2F;*设置光标位置为每一页的第一列*&#x2F;
		__pvt_oled_set_cursor(handle, j, 0);
		&#x2F;*连续写入128个数据，将显存数组的数据写入到OLED硬件*&#x2F;
		&#x2F;&#x2F; 有趣的是,这里笔者埋下了一个伏笔,我为什么没写OLED_WIDTH呢?尽管在SSD1306这样做是正确的
		&#x2F;&#x2F; 但那也是偶然,笔者在移植SSD1309的时候就发现了这样的不一致性,导致OLED死机.
		&#x2F;&#x2F; 笔者提示: OLED长宽和可绘制区域的大小不一致性
		op_table.data_sender(handle-&gt;private_handle, OLED_GRAM[j], 128);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    刷新整个屏幕就是将鼠标设置到开头，然后直接向后面写入128个数据结束我们的事情，这比一个个写要快得多！</p>
<h4 id="绘制一个点"><a href="#绘制一个点" class="headerlink" title="绘制一个点"></a>绘制一个点</h4><p>​    实际上，就是将对应的数组的位置放上1就好了，这需要牵扯到的是OLED独特的显示方式。</p>
<p>​    OLED自身分有页这个概念，一个页8个像素，由传递的比特控制。举个例子，我想显示的是第一个像素亮起来，就需要在一个字节的第一个比特置1余下置0，这就是为什么OLED_HEIGHT的大小不是64而是8，也就意味着setpixel函数不是简单的</p>
<pre class="line-numbers language-none"><code class="language-none">OLED[height][width] &#x3D; val<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    而实需要进行一个复杂的计算。我们分析一下，给定一个Y的值。它落在的页就是 Y / 8。比如说，Y为5的时候落在第0页的第六个比特上，Y为9的时候落在第一个页的第一个第二个比特上（注意我们的Y从0开始计算），我们设置的位置也就是：<code>OLED_GRAM[y / 8][x]</code>，设置的值就是Y给定的比特是<code>0x01 &lt;&lt; (y % 8)</code></p>
<pre class="line-numbers language-none"><code class="language-none">void oled_helper_setpixel(OLED_Handle* handle, uint16_t x, uint16_t y)
&#123;
    &#x2F;&#x2F; current unused
    (void)handle;
    if( 
        0 &lt;&#x3D; x &amp;&amp; x &lt;&#x3D; POINT_X_MAX &amp;&amp;
        0 &lt;&#x3D; y &amp;&amp; y &lt;&#x3D; POINT_Y_MAX
    )
        OLED_GRAM[y &#x2F; 8][x] |&#x3D; 0x01 &lt;&lt; (y % 8);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>(void)T是一种常见的放置maybe_unused的写法，现代编译器支持<code>[[maybe_unused]]</code>的指示符，表达的是这个参数可能不被用到，编译器不需要为此警告我，这在复用中很常见，一些接口的参数可能不被使用，这样的可读性会比传递空更加的好读，为了遵循ISO C，笔者没有采取，保证任何编译器都可以正确的理解我们的意图。</p>
</blockquote>
<h4 id="反色"><a href="#反色" class="headerlink" title="反色"></a>反色</h4><p>​    反色就很简单了。只需要异或即可，首先，当给定的比特是0的时候，我们异或1，得到的就是相异的比较，所以结果是1：即0变成了1。我们给定的比特是1的时候，我们还是异或1，得到了相同的结果，所以结果是0，即1变成了0，这样不就实现了一个像素的反转吗！</p>
<pre class="line-numbers language-none"><code class="language-none">void oled_helper_reverse(OLED_Handle* handle)
&#123;
    for(uint8_t i &#x3D; 0; i &lt; OLED_HEIGHT; i++)
    &#123;
        for(uint8_t j &#x3D; 0; j &lt; OLED_WIDTH; j++)
        &#123;
            OLED_GRAM[i][j] ^&#x3D; 0xFF;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>能使用memset吗？为什么？所以memset是在什么情况下能使用呢？</p>
<p>我都这样问了，那显然不能，因为设置的值跟每一个字节的内存强相关，memset的值必须跟内存的值没有关系。</p>
</blockquote>
<h4 id="区域化操作"><a href="#区域化操作" class="headerlink" title="区域化操作"></a>区域化操作</h4><p>​    我们还有区域化操作没有实现。基本的步骤是</p>
<blockquote>
<p>思考需要的参数：需要知道对</p>
<ul>
<li>哪个OLED：OLED_Handle* handle,</li>
<li>起头在哪里：uint16_t x, uint16_t y, </li>
<li>长宽如何：uint16_t width, uint16_t height</li>
<li>对于置位，则需要一个连续的数组进行置位，它的大小就是描述了区域矩形的大小</li>
</ul>
</blockquote>
<p>​    我们先来看置位函数</p>
<h5 id="区域置位"><a href="#区域置位" class="headerlink" title="区域置位"></a>区域置位</h5><pre class="line-numbers language-none"><code class="language-none">void oled_helper_draw_area(OLED_Handle* handle, 
        uint16_t x, uint16_t y, uint16_t width, 
        uint16_t height, uint8_t* sources)
&#123;
    &#x2F;&#x2F; 确保绘制区域的起点坐标在有效范围内，如果超出最大显示坐标则直接返回
    if(x &gt; POINT_X_MAX)  return;
    if(y &gt; POINT_Y_MAX)  return;

    &#x2F;&#x2F; 在设置图像前，先清空绘制区域
    oled_helper_clear_area(handle, x, y, width, height); 

    &#x2F;&#x2F; 遍历绘制区域的高度，以8像素为单位划分区域
    for(uint16_t j &#x3D; 0; j &lt; (height - 1) &#x2F; 8 + 1; j++)
    &#123;
        for(uint16_t i &#x3D; 0; i &lt; width; i++)
        &#123;
            &#x2F;&#x2F; 如果绘制超出屏幕宽度，则跳出循环
            if(x + i &gt; OLED_WIDTH) &#123; break; &#125;
            &#x2F;&#x2F; 如果绘制超出屏幕高度，则直接返回
            if(y &#x2F; 8 + j &gt; OLED_HEIGHT - 1) &#123; return; &#125;

            &#x2F;&#x2F; 将sources中的数据按位移方式写入OLED显存GRAM
            &#x2F;&#x2F; 当前行显示，低8位数据左移与显存当前内容进行按位或
            OLED_GRAM[y &#x2F; 8 + j][x + i] |&#x3D; sources[j * width + i] &lt;&lt; (y % 8);

            &#x2F;&#x2F; 如果绘制数据跨页（8像素一页），处理下一页的数据写入
            if(y &#x2F; 8 + j + 1 &gt; OLED_HEIGHT - 1) &#123; continue; &#125;

            &#x2F;&#x2F; 将高8位数据右移后写入下一页显存
            OLED_GRAM[y &#x2F; 8 + j + 1][x + i] |&#x3D; sources[j * width + i] &gt;&gt; (8 - y % 8);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 如果绘制超出屏幕宽度，则跳出循环
if(x + i &gt; OLED_WIDTH) &#123; break; &#125;
&#x2F;&#x2F; 如果绘制超出屏幕高度，则直接返回
if(y &#x2F; 8 + j &gt; OLED_HEIGHT - 1) &#123; return; &#125;

&#x2F;&#x2F; 将sources中的数据按位移方式写入OLED显存GRAM
&#x2F;&#x2F; 当前行显示，低8位数据左移与显存当前内容进行按位或
OLED_GRAM[y &#x2F; 8 + j][x + i] |&#x3D; sources[j * width + i] &lt;&lt; (y % 8);

&#x2F;&#x2F; 如果绘制数据跨页（8像素一页），处理下一页的数据写入
if(y &#x2F; 8 + j + 1 &gt; OLED_HEIGHT - 1) &#123; continue; &#125;

&#x2F;&#x2F; 将高8位数据右移后写入下一页显存
OLED_GRAM[y &#x2F; 8 + j + 1][x + i] |&#x3D; sources[j * width + i] &gt;&gt; (8 - y % 8);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    我们正常来讲，传递的会是一个二维数组，C语言对于二维数组的处理是连续的。也就是说。对于一个被声明为<code>OLED[WIDTH][HEIGHT]</code>的数组，访问<code>OLED[i][j]</code>本质上等价于<code>OLED + i * WIDTH + j</code>，这个事情如果还是不能理解可以查照专门的博客进行学习。笔者默认在这里看我写的东西已经不会被这样基础的知识所困扰了。所以，我们的所作的就是将出于低页的内容拷贝到底页上</p>
<blockquote>
<p><code>OLED_GRAM[y / 8 + j][x + i]</code>：这是显存二维数组的索引访问。</p>
<ul>
<li><code>y / 8 + j</code> 计算出当前数据位于哪个页（OLED通常按8个像素一页分块存储），通过整除将 <code>y</code> 坐标映射到显存页。</li>
<li><code>x + i</code> 表示横向的列位置。</li>
</ul>
<p><code>sources[j * width + i]</code>：这是源图像数据数组的索引访问。</p>
<ul>
<li><code>j * width + i</code> 计算当前像素在 <code>sources</code> 数据中的位置偏移。</li>
</ul>
<p><code>&lt;&lt; (y % 8)</code>：将当前像素数据向左移动 <code>(y % 8)</code> 位，以确保源数据对齐到目标位置。</p>
<ul>
<li><code>y % 8</code> 获取绘制的起点在当前页中的垂直偏移。</li>
</ul>
<p><code>|=</code>：按位或运算符，将偏移后的数据合并到 <code>OLED_GRAM</code> 中现有内容。</p>
<p>如果 <code>y = 5</code>，那么 <code>y % 8 = 5</code>，表示当前像素从第5位开始绘制。例如：</p>
<ul>
<li>如果 <code>sources[j * width + i]</code> 的值是 <code>0b11000000</code>，经过 <code>&lt;&lt; 5</code> 位移后变为 <code>0b00000110</code>，再与 <code>OLED_GRAM</code> 的原有数据合并，从而只影响目标位置上的两个像素。</li>
</ul>
</blockquote>
<p>​    先试一下分析<code>OLED_GRAM[y / 8 + j + 1][x + i] |= sources[j * width + i] &gt;&gt; (8 - y % 8);</code>，笔者的分析如下</p>
<blockquote>
<ol>
<li><code>OLED_GRAM[y / 8 + j + 1][x + i]</code>：<ul>
<li>这是下一页显存中的对应位置。</li>
<li><code>y / 8 + j + 1</code> 表示当前绘制位置的下一页。</li>
<li><code>x + i</code> 仍为当前列位置。</li>
</ul>
</li>
<li><code>sources[j * width + i]</code>：<ul>
<li>源图像数据中当前像素的数据。</li>
<li><code>j * width + i</code> 计算出当前像素在源数据中的位置。</li>
</ul>
</li>
<li><code>&gt;&gt; (8 - y % 8)</code>：<ul>
<li>将数据右移 <code>(8 - y % 8)</code> 位，将超出当前页的高位部分对齐到下一页。</li>
<li><code>8 - y % 8</code> 计算需要移入下一页的位数。</li>
</ul>
</li>
<li><code>|=</code>：<ul>
<li>按位或，将偏移后的数据合并到下一页显存中，以保留已有内容。</li>
</ul>
</li>
</ol>
<p>假设 <code>y = 5</code>，那么 <code>8 - y % 8 = 3</code>。如果 <code>sources[j * width + i]</code> 为 <code>0b10110000</code>，右移 3 位得到 <code>0b00010110</code>，这部分数据写入下一页显存。</p>
</blockquote>
<h5 id="区域反色"><a href="#区域反色" class="headerlink" title="区域反色"></a>区域反色</h5><pre class="line-numbers language-none"><code class="language-none">void oled_helper_reversearea(OLED_Handle* handle, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height)
&#123;
    &#x2F;&#x2F; 确认起点坐标是否超出有效范围
    if(x &gt; POINT_X_MAX)  return;
    if(y &gt; POINT_Y_MAX)  return;

    &#x2F;&#x2F; 确保绘制区域不会超出最大范围，如果超出则调整宽度和高度
    if(x + width &gt; POINT_X_MAX)     width &#x3D; POINT_X_MAX - x;
    if(y + height &gt; POINT_Y_MAX)    height &#x3D; POINT_Y_MAX - y;

    &#x2F;&#x2F; 遍历高度范围中的每个像素行
    for(uint8_t i &#x3D; y; i &lt; y + height; i++)
    &#123;
        for(uint8_t j &#x3D; x; j &lt; x + width; j++)
        &#123;
            &#x2F;&#x2F; 反转显存GRAM中的指定像素位（按位异或）
            OLED_GRAM[i &#x2F; 8][j] ^&#x3D; (0x01 &lt;&lt; (i % 8));
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="区域更新"><a href="#区域更新" class="headerlink" title="区域更新"></a>区域更新</h5><pre class="line-numbers language-none"><code class="language-none">void oled_helper_update_area(OLED_Handle* handle, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height)
&#123;
    &#x2F;&#x2F; 检查起点坐标是否超出有效范围
    if(x &gt; POINT_X_MAX)  return;
    if(y &gt; POINT_Y_MAX)  return;

    &#x2F;&#x2F; 确认绘制区域不超出最大范围
    if(x + width &gt; POINT_X_MAX)     width &#x3D; POINT_X_MAX - x;
    if(y + height &gt; POINT_Y_MAX)    height &#x3D; POINT_Y_MAX - y;

    &#x2F;&#x2F; 定义OLED操作表变量
    OLED_Operations op_table;
    &#x2F;&#x2F; 获取对应的操作函数表
    __on_fetch_oled_table(handle, &amp;op_table);

    &#x2F;&#x2F; 遍历绘制区域中的每个页（8像素一页）
    for(uint8_t i &#x3D; y &#x2F; 8; i &lt; (y + height - 1) &#x2F; 8 + 1; i++)
    &#123;
        &#x2F;&#x2F; 设置光标到指定页及列的位置
        __pvt_oled_set_cursor(handle, i, x);
        &#x2F;&#x2F; 从显存中读取指定页和列的数据，通过data_sender发送到OLED硬件
        op_table.data_sender(handle, &amp;OLED_GRAM[i][x], width);        
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    也就是将光标对应到位置上刷新width个数据，完事！</p>
<h4 id="区域清空"><a href="#区域清空" class="headerlink" title="区域清空"></a>区域清空</h4><pre class="line-numbers language-none"><code class="language-none">void oled_helper_clear_area(OLED_Handle* handle, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height)
&#123;
    &#x2F;&#x2F; 检查起点坐标是否超出有效范围
    if(x &gt; POINT_X_MAX)  return;
    if(y &gt; POINT_Y_MAX)  return;

    &#x2F;&#x2F; 确保绘制区域不超出最大范围
    if(x + width &gt; POINT_X_MAX)     width &#x3D; POINT_X_MAX - x;
    if(y + height &gt; POINT_Y_MAX)    height &#x3D; POINT_Y_MAX - y;

    &#x2F;&#x2F; 遍历高度范围内的所有像素
    for(uint8_t i &#x3D; y; i &lt; y + height; i++)
    &#123;
        for(uint8_t j &#x3D; x; j &lt; x + width; j++)
        &#123;
            &#x2F;&#x2F; 清除显存中的指定像素位（按位与非操作）
            OLED_GRAM[i &#x2F; 8][j] &amp;&#x3D; ~(0x01 &lt;&lt; (i % 8));
        &#125;
    &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<ol>
<li><code>OLED_GRAM[i / 8][j]</code>：<ul>
<li>访问显存缓冲区中指定位置的字节。</li>
<li><code>i / 8</code> 确定当前像素所在的页，因为 OLED 每页存储 8 个垂直像素。</li>
<li><code>j</code> 为水平方向的列位置。</li>
</ul>
</li>
<li><code>0x01 &lt;&lt; (i % 8)</code>：<ul>
<li>生成一个掩码，将 <code>0x01</code> 左移 <code>(i % 8)</code> 位。</li>
<li><code>i % 8</code> 计算出在当前页中的垂直位偏移。</li>
</ul>
</li>
<li><code>~(0x01 &lt;&lt; (i % 8))</code>：<ul>
<li>对掩码取反，生成一个用于清零的掩码。例如，如果 <code>i % 8 == 2</code>，则 <code>0x01 &lt;&lt; 2</code> 为 <code>0b00000100</code>，取反后得到 <code>0b11111011</code>。</li>
</ul>
</li>
<li><code>&amp;=</code>：<ul>
<li>按位与运算，将显存当前位置对应的像素清零，而其他位保持不变。</li>
</ul>
</li>
</ol>
<p>假设 <code>i = 10</code>，<code>j = 5</code>：</p>
<ul>
<li><code>i / 8 = 1</code> 表示访问第 2 页（页索引为 1）；</li>
<li><code>i % 8 = 2</code> 表示需要清除该页第 3 位的像素；</li>
<li><code>0x01 &lt;&lt; 2 = 0b00000100</code>，取反得到 <code>0b11111011</code>；</li>
<li><code>OLED_GRAM[1][5] &amp;= 0b11111011</code> 会将第 3 位清零，其余位保持不变。</li>
</ul>
</blockquote>
<h3 id="测试我们的抽象"><a href="#测试我们的抽象" class="headerlink" title="测试我们的抽象"></a>测试我们的抽象</h3><p>​    现在，我们终于可以开始测试我们的抽象了。完成了既可以使用软件IIC，又可以使用硬件IIC进行通信的OLED抽象，我们当然迫不及待的想要测试一下我们的功能是否完善。笔者这里刹住车，耐下性子听几句话。</p>
<p>​    首先，测试不是一番风顺的，我们按照我们的期望对着接口写出了功能代码，基本上不会一番风顺的得到自己想要的结果，往往需要我们进行调试，找到其中的问题，修正然后继续测试。</p>
<h4 id="整理一下，我们应该如何使用？"><a href="#整理一下，我们应该如何使用？" class="headerlink" title="整理一下，我们应该如何使用？"></a>整理一下，我们应该如何使用？</h4><p>​    首先回顾接口。我们需要指定一个协议按照我们期望的方式进行通信。在上一篇博客中，我们做完了协议层次的抽象，在这里，我们只需要老老实实的注册接口就好了。</p>
<blockquote>
<p>指引：如果你忘记了我们上一篇博客在做什么的话，请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/charlie114514191/article/details/145397569!">https://blog.csdn.net/charlie114514191/article/details/145397569!</a></p>
</blockquote>
<p>​    笔者建议，新建一个Test文件夹，书写一个文件叫:<code>oled_test_hard_iic.c</code>和<code>oled_test_soft_iic.c</code>测试我们的设备层和协议层是正确工作的。笔者这里以测试硬件IIC的代码为例子。</p>
<p>​    新建一个CubeMX工程，只需要简单的配置一下IIC就好了（笔者选择的是Fast Mode，为了方便以后测试我们的组件刷新），之后，只需要</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;OLED&#x2F;Driver&#x2F;hard_iic&#x2F;hard_iic.h&quot;
#include &quot;Test&#x2F;OLED_TEST&#x2F;oled_test.h&quot;
#include &quot;i2c.h&quot;
&#x2F;* configs should be in persist way *&#x2F;
OLED_HARD_IIC_Private_Config config;

void user_init_hard_iic_oled_handle(OLED_Handle* handle)
&#123;
    bind_hardiic_handle(&amp;config, &amp;hi2c1, 0x78, HAL_MAX_DELAY);
    oled_init_hardiic_handle(handle, &amp;config);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    <code>bind_hardiic_handle</code>注册了使用硬件IIC通信的协议实体,我们将一个空白的config，注册了配置好的iic的HAL库句柄，提供了IIC地址和最大可接受的延迟时间</p>
<p>​    <code>oled_init_hardiic_handle</code>则是进一步的从协议层飞跃到设备层，完成一个OLED设备的注册，即，我们注册了一个使用硬件IIC通信的OLED。现在，我们就可以直接拿这个OLED进行绘点了。</p>
<pre class="line-numbers language-none"><code class="language-none">void test_set_pixel_line(
    OLED_Handle* handle, uint8_t xoffset, uint8_t y_offset)
&#123;
    for(uint8_t i &#x3D; 0; i &lt; 20; i++)
        oled_helper_setpixel(handle,xoffset * i, y_offset * i);
    oled_helper_update(handle);
&#125;

void test_oled_iic_functionalities()
&#123;
    OLED_Handle handle;
    &#x2F;&#x2F; 注册了一个使用硬件IIC通信的OLED
    user_init_hard_iic_oled_handle(&amp;handle);
    &#x2F;&#x2F; 绘制一个
    test_set_pixel_line(&amp;handle, 1, 2);
    HAL_Delay(1000);
    test_clear(&amp;handle);
    test_set_pixel_line(&amp;handle, 2, 1);
    HAL_Delay(1000);
    test_clear(&amp;handle);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这个测试并不全面，自己可以做修改。效果就是在导言当中的视频开始的两条直线所示。</p>
<p>​    笔者的OLED设备层的代码已经全部开源到<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED/library/OLED">MCU_Libs/OLED/library/OLED at main · Charliechen114514/MCU_Libs (github.com)</a>，感兴趣的朋友可以进一步研究。</p>
<h1 id="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（绘图设备抽象）"><a href="#从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（绘图设备抽象）" class="headerlink" title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（绘图设备抽象）"></a>从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（绘图设备抽象）</h1><h2 id="图像层的底层抽象——绘图设备抽象"><a href="#图像层的底层抽象——绘图设备抽象" class="headerlink" title="图像层的底层抽象——绘图设备抽象"></a>图像层的底层抽象——绘图设备抽象</h2><p>​    在上一篇博客中，我们完成了对设备层的抽象。现在，我们终于可以卖出雄心壮志的一步了！那就是尝试去完成一个最为基础的图形库。我们要做的，就是设计一个更加复杂的绘图设备。</p>
<p>​    为什么是绘图设备呢？我们程序员都是懒蛋，想要最大程度的复用代码，省最大的力气干最多的事情。所以，我们的图像框架在未来，还会使用LCD绘制，还会使用其他形形色色的绘制设备来绘制我们的图像。而不仅限于OLED。所以，让我们抽象一个可以绘制的设备而不是一个OLED设备，是非常重要的。</p>
<p>​    一个绘图设备，是OLED设备的的子集。他可以开启关闭，完成绘制操作，刷新绘制操作，清空绘制操作。仅此而已。</p>
<pre class="line-numbers language-none"><code class="language-none">typedef void*   CCDeviceRawHandle;
typedef void*   CCDeviceRawHandleConfig;

&#x2F;&#x2F; 初始化设备，设备需要做一定的初始化后才能绘制图形
typedef void(*Initer)(
    CCDeviceHandler* handler, 
    CCDeviceRawHandleConfig config);

&#x2F;&#x2F; 清空设备
typedef void(*ClearDevice)(
    CCDeviceHandler* handler);

&#x2F;&#x2F; 更新设备
typedef void(*UpdateDevice)(
    CCDeviceHandler* handler);

&#x2F;&#x2F; 反色设备
typedef void(*ReverseDevice)(
    CCDeviceHandler* handler);

&#x2F;&#x2F; 绘制点
typedef void(*SetPixel)(
    CCDeviceHandler* handler, uint16_t x, uint16_t y);

&#x2F;&#x2F; 绘制面
typedef void(*DrawArea)(
    CCDeviceHandler* handler, 
    uint16_t x, uint16_t y, 
    uint16_t width, uint16_t height, uint8_t* sources
);

&#x2F;&#x2F; 面操作（清空，反色，更新等等，反正不需要外来提供绘制资源的操作）
typedef void(*AreaOperation)(
    CCDeviceHandler* handler, 
    uint16_t x, uint16_t y, 
    uint16_t width, uint16_t height
);

&#x2F;&#x2F; 这个比较新，笔者后面讲
typedef enum&#123;
    CommonProperty_WIDTH,
    CommonProperty_HEIGHT,
    CommonProperty_SUPPORT_RGB
&#125;CommonProperty;

&#x2F;&#x2F; 获取资源的属性
typedef void(*FetchProperty)(CCDeviceHandler*, void*, CommonProperty p);

&#x2F;&#x2F; 一个绘图设备可以完成的操作
&#x2F;&#x2F; 提示，其实可以化简，一些函数指针（或者说方法）是没有必要存在的，思考一下如何化简呢？
typedef struct __DeviceOperations 
&#123;
    Initer          init_function;
    ClearDevice     clear_device_function;
    UpdateDevice    update_device_function;
    SetPixel        set_pixel_device_function;
    ReverseDevice   reverse_device_function;
    DrawArea        draw_area_device_function;
    AreaOperation   clearArea_function;
    AreaOperation   updateArea_function;
    AreaOperation   reverseArea_function;
    FetchProperty   property_function;
&#125;CCDeviceOperations;

&#x2F;&#x2F; 一个绘图设备的最终抽象
typedef struct __DeviceProperty
&#123;
    &#x2F;* device type *&#x2F;
    CCDeviceType            device_type;
    &#x2F;* device raw data handle *&#x2F;
    CCDeviceRawHandle       handle;
    &#x2F;* device functions *&#x2F;
    CCDeviceOperations      operations;
&#125;CCDeviceHandler;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    设计上笔者是自底向上设计的，笔者现在打算自顶向下带大伙解读一下我的代码。</p>
<h3 id="如何抽象一个绘图设备？"><a href="#如何抽象一个绘图设备？" class="headerlink" title="如何抽象一个绘图设备？"></a>如何抽象一个绘图设备？</h3><p>​    这个设备是什么？是一个OLED？还是一个LCD？</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* device type *&#x2F;
CCDeviceType            device_type;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​    这个设备的底层保存资源是什么？当我们动手准备操作的时候，需要拿什么进行操作呢？</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* device raw data handle *&#x2F;
CCDeviceRawHandle       handle;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>你不需要在使用的时候关心他到底是什么，因为我们从头至尾都在使用接口进行操作，你只需要知道，一个绘图设备可以绘制图像，这就足够了</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* device functions *&#x2F;
CCDeviceOperations      operations;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​    这里是我们的命根子，一个绘图设备可以完成的操作。我们在之后的设计会大量的见到operations这个操作。</p>
<blockquote>
<p>笔者的operations借鉴了Linux是如何抽象文件系统的代码。显然，一个良好的面对对象C编写规范的参考代码就是Linux的源码</p>
</blockquote>
<p>​    下一步，就是DeviceType有哪些呢？目前，我们开发的是OLED，也就意味着只有OLED是一个合法的DeviceType</p>
<pre class="line-numbers language-none"><code class="language-none">typedef enum&#123;
    OLED_Type
&#125;CCDeviceType;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​    最后，我们需要思考的是，如何定义一个绘图设备的行为呢？我们知道我们现在操作的就是一个OLED，所以，我们的问题实际上就转化成为：</p>
<blockquote>
<p>当我们给定了一个明确的，是OLED设备的绘图设备的时候，怎么联系起来绘图设备和OLED设备呢？</p>
</blockquote>
<p>​    答案还是回到我们如何抽象设备层的代码上，那就是根据我们的类型来选择我们的方法。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* calling this is not encouraged! *&#x2F;
void __register_paintdevice(
    CCDeviceHandler* blank_handler, 
    CCDeviceRawHandle raw_handle, 
    CCDeviceRawHandleConfig config, 
    CCDeviceType type);

#define register_oled_paintdevice(handler, raw, config) \
    __register_paintdevice(handler, raw, config, OLED_Type)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    所以，我们注册一个OLED的绘图设备，只需要调用接口register_oled_paintdevice就好了，提供一个干净的OLED_HANDLE和初始化OLED_HANDLE所需要的资源，我们的设备也就完成了初始化。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;device_adapter&#x2F;CCGraphic_device_oled_adapter.h&quot;
#include &quot;Graphic&#x2F;CCGraphic_device_adapter.h&quot;

void __register_paintdevice(
    CCDeviceHandler* blank_handler, 
    CCDeviceRawHandle raw_handle, 
    CCDeviceRawHandleConfig config, 
    CCDeviceType type)
&#123;
    blank_handler-&gt;handle &#x3D; raw_handle;
    blank_handler-&gt;device_type &#x3D; type;
    switch(type)
    &#123;
        case OLED_Type:
        &#123;
            blank_handler-&gt;operations.init_function &#x3D; 
                (Initer)init_device_oled;
            blank_handler-&gt;operations.clear_device_function &#x3D;
                clear_device_oled;
            blank_handler-&gt;operations.set_pixel_device_function &#x3D; 
                setpixel_device_oled;
            blank_handler-&gt;operations.update_device_function &#x3D; 
                update_device_oled;
            blank_handler-&gt;operations.clearArea_function &#x3D;
                clear_area_device_oled;
            blank_handler-&gt;operations.reverse_device_function &#x3D;
                reverse_device_oled;
            blank_handler-&gt;operations.reverseArea_function &#x3D; 
                reversearea_device_oled;
            blank_handler-&gt;operations.updateArea_function &#x3D; 
                update_area_device_oled;
            blank_handler-&gt;operations.draw_area_device_function &#x3D;
                draw_area_device_oled;
            blank_handler-&gt;operations.property_function &#x3D; 
                property_fetcher_device_oled;
        &#125;
        break;
    &#125;
    blank_handler-&gt;operations.init_function(blank_handler, config);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这个仍然是最空泛的代码，我们只是简单的桥接了一下，声明我们的设备是OLED，还有真正完成桥接的文件：<code>CCGraphic_device_oled_adapter</code>文件没有给出来。所以，让我们看看实际上是如何真正的完成桥接的。</p>
<h4 id="桥接绘图设备，特化为OLED设备"><a href="#桥接绘图设备，特化为OLED设备" class="headerlink" title="桥接绘图设备，特化为OLED设备"></a>桥接绘图设备，特化为OLED设备</h4><p>​    什么是桥接？什么是特化？<strong>桥接指的是讲一个抽象结合过度到另一个抽象上，在这里，我们讲绘图设备引渡到我们的OLED设备而不是其他更加宽泛的设备上去，而OLED设备属于绘图设备的一个子集，看起来，我们就像是把虚无缥缈的“绘图设备”落地了，把一个抽象的概念更加具体了。</strong>我们的聊天从“用绘图设备完成XXX”转向了“使用一个OLED作为绘图设备完成XXX”了。这就是特化，将一个概念明晰起来。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;CCGraphic_device_adapter.h&quot;
#include &quot;OLED&#x2F;Driver&#x2F;oled_config.h&quot;

&#x2F;* 
 * 提供用于 OLED 设备的相关操作函数 
 *&#x2F;

&#x2F;**
 * @struct CCGraphic_OLED_Config
 * @brief OLED 设备的配置结构体
 *&#x2F;
typedef struct &#123;
    OLED_Driver_Type    createType;      &#x2F;&#x2F; OLED 驱动类型（软 I2C、硬 I2C 等）
    void*               related_configs; &#x2F;&#x2F; 与驱动相关的具体配置
&#125; CCGraphic_OLED_Config;

&#x2F;**
 * @brief 初始化 OLED 设备
 * @param blank 空的设备句柄，初始化后填充
 * @param onProvideConfigs OLED 配置参数指针，包含驱动类型及配置
 * 
 * @note 调用此函数时需要传递初始化好的配置（软 I2C 或硬 I2C 配置等）
 *&#x2F;
void init_device_oled(
    CCDeviceHandler* blank, CCGraphic_OLED_Config* onProvideConfigs);

&#x2F;**
 * @brief 刷新整个 OLED 屏幕内容
 * @param handler 设备句柄
 *&#x2F;
void update_device_oled(CCDeviceHandler* handler);

&#x2F;**
 * @brief 清空 OLED 屏幕内容
 * @param handler 设备句柄
 *&#x2F;
void clear_device_oled(CCDeviceHandler* handler);

&#x2F;**
 * @brief 设置指定位置的像素点
 * @param handler 设备句柄
 * @param x 横坐标
 * @param y 纵坐标
 *&#x2F;
void setpixel_device_oled(CCDeviceHandler* handler, uint16_t x, uint16_t y);

&#x2F;**
 * @brief 清除指定区域的显示内容
 * @param handler 设备句柄
 * @param x 区域起点的横坐标
 * @param y 区域起点的纵坐标
 * @param width 区域宽度
 * @param height 区域高度
 *&#x2F;
void clear_area_device_oled(CCDeviceHandler* handler, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height);

&#x2F;**
 * @brief 更新指定区域的显示内容
 * @param handler 设备句柄
 * @param x 区域起点的横坐标
 * @param y 区域起点的纵坐标
 * @param width 区域宽度
 * @param height 区域高度
 *&#x2F;
void update_area_device_oled(CCDeviceHandler* handler, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height);

&#x2F;**
 * @brief 反转整个屏幕的显示颜色
 * @param handler 设备句柄
 *&#x2F;
void reverse_device_oled(CCDeviceHandler* handler);

&#x2F;**
 * @brief 反转指定区域的显示颜色
 * @param handler 设备句柄
 * @param x 区域起点的横坐标
 * @param y 区域起点的纵坐标
 * @param width 区域宽度
 * @param height 区域高度
 *&#x2F;
void reversearea_device_oled(CCDeviceHandler* handler, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height);

&#x2F;**
 * @brief 绘制指定区域的图像
 * @param handler 设备句柄
 * @param x 区域起点的横坐标
 * @param y 区域起点的纵坐标
 * @param width 区域宽度
 * @param height 区域高度
 * @param sources 图像数据源指针
 *&#x2F;
void draw_area_device_oled(
    CCDeviceHandler* handler, 
    uint16_t x, uint16_t y, 
    uint16_t width, uint16_t height, uint8_t* sources
);

&#x2F;**
 * @brief 获取设备属性
 * @param handler 设备句柄
 * @param getter 属性获取指针
 * @param p 属性类型
 *&#x2F;
void property_fetcher_device_oled(
    CCDeviceHandler* handler, void* getter, CommonProperty p
);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    好在代码实际上并不困难，具体的代码含义我写在下面了，可以参考看看</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;device_adapter&#x2F;CCGraphic_device_oled_adapter.h&quot;
#include &quot;OLED&#x2F;Driver&#x2F;oled_base_driver.h&quot;

&#x2F;**
 * @brief 初始化 OLED 设备
 * 
 * 根据提供的配置（软 I2C、硬 I2C、软 SPI、硬 SPI）初始化 OLED 设备。
 * 
 * @param blank 空的设备句柄，初始化后填充
 * @param onProvideConfigs OLED 配置参数指针，包含驱动类型及具体配置
 *&#x2F;
void init_device_oled(
    CCDeviceHandler* blank, CCGraphic_OLED_Config* onProvideConfigs)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)(blank-&gt;handle);
    OLED_Driver_Type type &#x3D; onProvideConfigs-&gt;createType;

    switch(type)
    &#123;
        case OLED_SOFT_IIC_DRIVER_TYPE:
            oled_init_softiic_handle(
                handle,
                (OLED_SOFT_IIC_Private_Config*) (onProvideConfigs-&gt;related_configs)
            );
        break;

        case OLED_HARD_IIC_DRIVER_TYPE:
            oled_init_hardiic_handle(
                handle, 
                (OLED_HARD_IIC_Private_Config*)(onProvideConfigs-&gt;related_configs));
        break;

        case OLED_SOFT_SPI_DRIVER_TYPE:
            oled_init_softspi_handle(
                handle,
                (OLED_SOFT_SPI_Private_Config*)(onProvideConfigs-&gt;related_configs)
            );
        break;

        case OLED_HARD_SPI_DRIVER_TYPE:
            oled_init_hardspi_handle(
                handle,
                (OLED_HARD_SPI_Private_Config*)(onProvideConfigs-&gt;related_configs)
            );
        break;
    &#125;
&#125;

&#x2F;**
 * @brief 刷新整个 OLED 屏幕内容
 * 
 * @param handler 设备句柄
 *&#x2F;
void update_device_oled(CCDeviceHandler* handler)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    oled_helper_update(handle);
&#125;

&#x2F;**
 * @brief 清空 OLED 屏幕内容
 * 
 * @param handler 设备句柄
 *&#x2F;
void clear_device_oled(CCDeviceHandler* handler)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    oled_helper_clear_frame(handle);
&#125;

&#x2F;**
 * @brief 设置指定位置的像素点
 * 
 * @param handler 设备句柄
 * @param x 横坐标
 * @param y 纵坐标
 *&#x2F;
void setpixel_device_oled(CCDeviceHandler* handler, uint16_t x, uint16_t y)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    oled_helper_setpixel(handle, x, y);
&#125;

&#x2F;**
 * @brief 清除指定区域的显示内容
 * 
 * @param handler 设备句柄
 * @param x 区域起点的横坐标
 * @param y 区域起点的纵坐标
 * @param width 区域宽度
 * @param height 区域高度
 *&#x2F;
void clear_area_device_oled(CCDeviceHandler* handler, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    oled_helper_clear_area(handle, x, y, width, height);
&#125;

&#x2F;**
 * @brief 更新指定区域的显示内容
 * 
 * @param handler 设备句柄
 * @param x 区域起点的横坐标
 * @param y 区域起点的纵坐标
 * @param width 区域宽度
 * @param height 区域高度
 *&#x2F;
void update_area_device_oled(CCDeviceHandler* handler, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    oled_helper_update_area(handle, x, y, width, height);
&#125;

&#x2F;**
 * @brief 反转整个屏幕的显示颜色
 * 
 * @param handler 设备句柄
 *&#x2F;
void reverse_device_oled(CCDeviceHandler* handler)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    oled_helper_reverse(handle);
&#125;

&#x2F;**
 * @brief 反转指定区域的显示颜色
 * 
 * @param handler 设备句柄
 * @param x 区域起点的横坐标
 * @param y 区域起点的纵坐标
 * @param width 区域宽度
 * @param height 区域高度
 *&#x2F;
void reversearea_device_oled(CCDeviceHandler* handler, 
        uint16_t x, uint16_t y, uint16_t width, uint16_t height)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    oled_helper_reversearea(handle, x, y, width, height);
&#125;

&#x2F;**
 * @brief 绘制指定区域的图像
 * 
 * @param handler 设备句柄
 * @param x 区域起点的横坐标
 * @param y 区域起点的纵坐标
 * @param width 区域宽度
 * @param height 区域高度
 * @param sources 图像数据源指针
 *&#x2F;
void draw_area_device_oled(
    CCDeviceHandler* handler, 
    uint16_t x, uint16_t y, 
    uint16_t width, uint16_t height, uint8_t* sources
)&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    oled_helper_draw_area(handle, x, y, width, height, sources);
&#125;

&#x2F;**
 * @brief 获取 OLED 设备属性
 * 
 * @param handler 设备句柄
 * @param getter 属性获取指针
 * @param p 属性类型（如：高度、宽度、是否支持 RGB 等）
 *&#x2F;
void property_fetcher_device_oled(
    CCDeviceHandler* handler, void* getter, CommonProperty p
)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    switch (p)
    &#123;
    case CommonProperty_HEIGHT:
    &#123;   
        int16_t* pHeight &#x3D; (int16_t*)getter;
        *pHeight &#x3D; oled_height(handle);
    &#125; break;

    case CommonProperty_WIDTH:
    &#123;
        int16_t* pWidth &#x3D; (int16_t*)getter;
        *pWidth &#x3D; oled_width(handle);
    &#125; break;

    case CommonProperty_SUPPORT_RGB:
    &#123;
        uint8_t* pSupportRGB &#x3D; (uint8_t*)getter;
        *pSupportRGB &#x3D; oled_support_rgb(handle);
    &#125; break;

    default:
        break;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="题外话：设备的属性，与设计一个相似函数化简的通用办法"><a href="#题外话：设备的属性，与设计一个相似函数化简的通用办法" class="headerlink" title="题外话：设备的属性，与设计一个相似函数化简的通用办法"></a>题外话：设备的属性，与设计一个相似函数化简的通用办法</h4><p>​    绘图设备有自己的属性，比如说告知自己的可绘图范围，是否支持RGB色彩绘图等等，我们的办法是提供一个对外暴露的可以访问的devicePropertyEnum</p>
<pre class="line-numbers language-none"><code class="language-none">typedef enum&#123;
    CommonProperty_WIDTH,
    CommonProperty_HEIGHT,
    CommonProperty_SUPPORT_RGB
&#125;CommonProperty;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    设计一个接口，这个接口函数就是FetchProperty</p>
<pre class="line-numbers language-none"><code class="language-none">typedef void(*FetchProperty)(CCDeviceHandler*, void*, CommonProperty p);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    上层框架代码提供一个承接返回值的void*和查询的设备以及查询类型，我们就返回这个设备的期望属性</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * @brief 获取 OLED 设备属性
 * 
 * @param handler 设备句柄
 * @param getter 属性获取指针
 * @param p 属性类型（如：高度、宽度、是否支持 RGB 等）
 *&#x2F;
void property_fetcher_device_oled(
    CCDeviceHandler* handler, void* getter, CommonProperty p
)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    switch (p)
    &#123;
    case CommonProperty_HEIGHT:
    &#123;   
        int16_t* pHeight &#x3D; (int16_t*)getter;
        *pHeight &#x3D; oled_height(handle);
    &#125; break;

    case CommonProperty_WIDTH:
    &#123;
        int16_t* pWidth &#x3D; (int16_t*)getter;
        *pWidth &#x3D; oled_width(handle);
    &#125; break;

    case CommonProperty_SUPPORT_RGB:
    &#123;
        uint8_t* pSupportRGB &#x3D; (uint8_t*)getter;
        *pSupportRGB &#x3D; oled_support_rgb(handle);
    &#125; break;

    default:
        break;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这个就是一种设计<strong>返回相似内容的数据的设计思路，将过多相同返回的函数简化为一个函数，将差异缩小到使用枚举宏而不是一大坨函数到处拉屎的设计方式</strong></p>
<blockquote>
<p>任务提示：笔者这里实际上做的不够好，你需要知道的是，我在这里是没有做错误处理的。啥意思？你必须让人家知道你返回的值是不是合法的，人家才知道这个值敢不敢用。</p>
<p>笔者提示您，两种办法：</p>
<ol>
<li><p>返回值上动手脚：这个是笔者推介的，也是Linux设备代码中使用的，那就是将属性获取的函数签名返回值修改为uint8_t，或者更进一步的封装：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef enum &#123;
	FETCH_PROPERTY_FAILED;	&#x2F;&#x2F; 0, YOU CAN USE AS FALSE, BUT NOT RECOMMENDED!
	FETCH_PROPERTY_SUCCESS;	&#x2F;&#x2F; 1, YOU CAN USE AS TRUE, BUT NOT RECOMMENDED!
&#125;FetchPropertyStatus;

&#x2F;**
 * @brief 获取 OLED 设备属性
 * 
 * @param handler 设备句柄
 * @param getter 属性获取指针
 * @param p 属性类型（如：高度、宽度、是否支持 RGB 等）
 * @return 
 *&#x2F;
FetchPropertyStatus property_fetcher_device_oled(
    CCDeviceHandler* handler, void* getter, CommonProperty p
)
&#123;
    OLED_Handle* handle &#x3D; (OLED_Handle*)handler-&gt;handle;
    switch (p)
    &#123;
    case CommonProperty_HEIGHT:
    &#123;   
        int16_t* pHeight &#x3D; (int16_t*)getter;
        *pHeight &#x3D; oled_height(handle);
    &#125; break;

    case CommonProperty_WIDTH:
    &#123;
        int16_t* pWidth &#x3D; (int16_t*)getter;
        *pWidth &#x3D; oled_width(handle);
    &#125; break;

    case CommonProperty_SUPPORT_RGB:
    &#123;
        uint8_t* pSupportRGB &#x3D; (uint8_t*)getter;
        *pSupportRGB &#x3D; oled_support_rgb(handle);
    &#125; break;

    default:
        return FETCH_PROPERTY_FAILED; &#x2F;&#x2F; not supported property
    &#125;
    return FETCH_PROPERTY_SUCCESS; &#x2F;&#x2F; fetched value can be used for further
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用上，事情也就变得非常的简单，笔者后面的一个代码</p>
<pre class="line-numbers language-none"><code class="language-none">int16_t device_width &#x3D; 0;
device_handle-&gt;operations.property_function(
    device_handle, &amp;device_width, CommonProperty_WIDTH
);
int16_t device_height &#x3D; 0;
device_handle-&gt;operations.property_function(
    device_handle, &amp;device_height, CommonProperty_HEIGHT
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也就可以更加合理的修改为</p>
<pre class="line-numbers language-none"><code class="language-none">FetchPropertyStatus status;
&#x2F;&#x2F; fetch the width property
int16_t device_width &#x3D; 0;
status &#x3D; device_handle-&gt;operations.property_function(
    device_handle, &amp;device_width, CommonProperty_WIDTH
);
&#x2F;&#x2F; check if the value valid
if(!statue)&#123;
	&#x2F;&#x2F; handling error, or enter HAL_Hard_Fault... anyway!
&#125;
int16_t device_height &#x3D; 0;
statue &#x3D; device_handle-&gt;operations.property_function(
    device_handle, &amp;device_height, CommonProperty_HEIGHT
);
&#x2F;&#x2F; check if the value valid
if(!statue)&#123;
	&#x2F;&#x2F; handling error, or enter HAL_Hard_Fault... anyway!
&#125;
&#x2F;&#x2F; now pass the check
&#x2F;&#x2F; use the variable directly
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>选取一个非法值。比如说</p>
<pre class="line-numbers language-none"><code class="language-none">#define INVALID_PROPERTY_VALUE		-1
...
default:
	&#123;	
		(int8_t*)value &#x3D; (int8_t*)getter;
		value &#x3D; INVALID_PROPERTY_VALUE;
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是显然不好！我们没办法区分：是不支持这个属性呢？还是设备的返回值确实就是-1呢？谁知道呢？所以笔者很不建议在这样的场景下这样做！甚至更糟糕的，如果是返回设备的长度，我们使用的是uint16_t接受，那么我们完全没办法区分究竟是设备是0xFFFF长，还是是非法值呢？<strong>我们一不小心把判断值的非法和值的含义本身混淆在一起了！</strong></p>
</li>
</ol>
</blockquote>
<p>​    现在，我们就可以完成对一整个设备的抽象了。</p>
<h4 id="使用函数指针来操作设备"><a href="#使用函数指针来操作设备" class="headerlink" title="使用函数指针来操作设备"></a>使用函数指针来操作设备</h4><p>​    笔者之前的代码已经反反复复出现了使用函数指针而不是调用函数来进行操作，从开销分析上讲，我们多了若干次的解引用操作，但是从封装上，我们明确的归属了函数隶属于绘图设备的方法，在极大量的代码下，这样起到了一种自说明的效果。</p>
<p>​    比起来，在业务层次（拿库做应用的层次，比如说开发一个OLED菜单，做一个恐龙奔跑小游戏，或者是绘制电棍突脸尖叫的动画），我们只需要强调是这个设备在绘图</p>
<pre class="line-numbers language-none"><code class="language-none">device_handle-&gt;operations.updateArea_function(...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    而不是我们让绘图的是这个设备</p>
<pre class="line-numbers language-none"><code class="language-none">updateArea_device(device_handle, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    显然前者更加的自然。</p>
<h4 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h4><p>​    其实，就是完成了对绘图设备的特化，现在，我们终于可以直接使用Device作为绘图设备而不是OLED_Handle，下一步，我们就开始真正的手搓设备绘制了。</p>
<h1 id="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础图形库的抽象）"><a href="#从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础图形库的抽象）" class="headerlink" title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础图形库的抽象）"></a>从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础图形库的抽象）</h1><h2 id="基础图形库的抽象"><a href="#基础图形库的抽象" class="headerlink" title="基础图形库的抽象"></a>基础图形库的抽象</h2><p>​    历经千辛万苦，我们终于可以开始行动起来，绘制图形了。我们将要绘制线，矩形，圆，椭圆等一系列基础的图形。问我其他的绘制呢？不必着急，我们慢慢来谈。</p>
<p>​    有没有发现我们现在的谈论越来越高层了？我们现在绘制图像的时候还会关心我用的是硬件IIC或者是软件SPI吗？不会，你甚至可能才意识到我们使用的是OLED！这就是抽象带给我们的好处。我们现在脑子里只有抽象的绘图设备这个概念。它可以绘制点，面。仅此而已。</p>
<p>​    本篇的代码在：<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED/library/Graphic/base">MCU_Libs/OLED/library/Graphic/base at main · Charliechen114514/MCU_Libs (github.com)</a></p>
<h2 id="抽象图形"><a href="#抽象图形" class="headerlink" title="抽象图形"></a>抽象图形</h2><h3 id="抽象点"><a href="#抽象点" class="headerlink" title="抽象点"></a>抽象点</h3><h4 id="设计我们的抽象"><a href="#设计我们的抽象" class="headerlink" title="设计我们的抽象"></a>设计我们的抽象</h4><p>​    我们即将迈出我们的第一步，那就是绘制一个点。</p>
<pre class="line-numbers language-none"><code class="language-none">typedef uint16_t    PointBaseType;
&#x2F;*
    x:  The x-coordinate of the point
    y:  The y-coordinate of the point
    operations: 
        An instance of CCGraphic_BaseOperations that 
        stores operations or behaviors related to the point, 
        likely used for drawing or other graphical manipulations.
*&#x2F;
typedef struct __CCGraphic_Point&#123;
    PointBaseType                     x;
    PointBaseType                     y;
&#125;CCGraphic_Point;

void CCGraphic_init_point(CCGraphic_Point* point, 
        PointBaseType x, PointBaseType y);
void CCGraphic_draw_point(CCDeviceHandler* handler, CCGraphic_Point* point);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    一个点的基本组成，就是给定一个由两个数的组合——X和Y，长度上，笔者为了防止特大设备，使用了PointBaseType隔离了具体的长度大小。</p>
<blockquote>
<p>小技巧：</p>
<p>当你发现一个问题很复杂的时候，最好的办法就是隔离！将大问题分解为若干的小问题，以笔者上面遇到的困难为例子。如何保证自己的点可以分布在满足设备宽度的平面上呢？答案是分解问题：<strong>点分布在平面上，使用的是对平面属性的PointBaseType上，他只知道自己属于这个类型，就一定不会超越所在的平面，不会出现绘图平面过大导致使用的数据类型发生溢出</strong>，至于如何保证不发生溢出呢？那是另一个问题，笔者使用的架构下，不会出现uint16_t不够使用的问题。但是如果的确出现了超大设备，我只需要轻而易举的定义一个HYPER_LARGE_DEVICE的宏，或者是面对资源极端紧张的嵌入式设备，定义一个HYPER_SMALL_DEVICE，就可以让所有的资源占用瞬间缩小一半</p>
<pre class="line-numbers language-none"><code class="language-none">#ifdef 	HYPER_LARGE_DEVICE
typedef uint32_t    PointBaseType;
#elif defined(HYPER_SMALL_DEVICE)
typedef uint8_t		PointBaseType;
#else
typedef uint16_t    PointBaseType;
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而我其他的代码一行都不用动，轻而易举的完成了迁移。</p>
</blockquote>
<h4 id="实现我们的抽象"><a href="#实现我们的抽象" class="headerlink" title="实现我们的抽象"></a>实现我们的抽象</h4><p>​    让我们看看我们的代码多么简洁吧！</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Point&#x2F;CCGraphic_Point.h&quot;
#include &quot;Graphic&#x2F;CCGraphic_device_adapter.h&quot;

void CCGraphic_draw_point(
    CCDeviceHandler* handler, CCGraphic_Point* point)
&#123;
    handler-&gt;operations.set_pixel_device_function(
        handler, point-&gt;x, point-&gt;y);
&#125;

void CCGraphic_init_point(CCGraphic_Point* point, 
    PointBaseType x, PointBaseType y)
&#123;
    point-&gt;x &#x3D; x;
    point-&gt;y &#x3D; y;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    绘制一个点，<strong>就是调用了设备的绘制点的办法</strong>。你问我咋绘制的？<strong>啥？你需要关心吗？我不说你可能都不知道我是拿的LCD做测试呢（笑）</strong>，但是，这里我需要严肃提醒的是——不要在关心实时性的绘图设备上这样做，让我们看一看调用链就好了：</p>
<pre class="line-numbers language-none"><code class="language-none">CCGraphic_draw_point -&gt; set_pixel_device_function(实际上就是setpixel_device_oled) -&gt; oled_helper_setpixel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    也就是说，我们多调用了两次functions来换取对任意设备的抽象。但是我也可以一行代码不改，就可以完全把调用链换成</p>
<pre class="line-numbers language-none"><code class="language-none">CCGraphic_draw_point -&gt; set_pixel_device_function(实际上就是setpixel_device_lcd) -&gt; lcd_helper_setpixel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    多简单！</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>​    现在我们就可以开始测试了</p>
<pre class="line-numbers language-none"><code class="language-none">OLED_HARD_IIC_Private_Config pvt_config;
OLED_Handle handle;
CCGraphic_OLED_Config config;

void on_test_init_hardiic_oled(CCDeviceHandler* device)
&#123;
    bind_hardiic_handle(
        &amp;pvt_config, &amp;hi2c1, 0x78, HAL_MAX_DELAY
    );
    config.createType &#x3D; OLED_HARD_IIC_DRIVER_TYPE;
    config.related_configs &#x3D; &amp;pvt_config;
    register_oled_paintdevice(device, &amp;handle, &amp;config);
&#125;

void on_test_draw_points(CCDeviceHandler* handle)
&#123;
    CCGraphic_Point point;
    CCGraphic_init_point(&amp;point, 0, 0);
    for(uint8_t i &#x3D; 0; i &lt; 20; i++)
    &#123;
        point.x &#x3D; i;
        point.y &#x3D; i * 2;
        CCGraphic_draw_point(handle, &amp;point);
    &#125;
    handle-&gt;operations.update_device_function(handle);
&#125;

&#x2F;&#x2F; at main.c
CCDeviceHandler handler;
on_test_init_hardiic_oled(&amp;handler);
on_test_draw_points(&amp;handler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    不出意外的话不会有任何问题。</p>
<h3 id="抽象线"><a href="#抽象线" class="headerlink" title="抽象线"></a>抽象线</h3><p>​    线的绘制开始有所讲究了，我们需要使用更好的，不涉及浮点数运算的办法来尽可能的回避耗费时间的浮点数运算。这隶属于计算机架构体系的内容，关于ARM，计算浮点数远远比计算整数的开销大（除非使用的是更贵的特化硬件）。现在，让我们开始绘制线线</p>
<h4 id="设计我们的抽象-1"><a href="#设计我们的抽象-1" class="headerlink" title="设计我们的抽象"></a>设计我们的抽象</h4><p>​    笔者建议你看到这里了，先自己构思一下如果是你，你如何抽象呢？</p>
<p>​    笔者先给你看看江科大的代码</p>
<pre class="line-numbers language-none"><code class="language-none">void OLED_DrawLine(int16_t X0, int16_t Y0, int16_t X1, int16_t Y1)
&#123;
	...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    啥？你问我抽象呢？怎么是实现呢？我只能说——它的函数签名就是抽象咯（笑）。各种处理混在一起，是这样的代码非常难读的一个根本原因。</p>
<p>​    笔者揭晓我的抽象。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Base.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Point&#x2F;CCGraphic_Point.h&quot;

typedef struct __CCGraphic_Line&#123;
    CCGraphic_Point p_left;
    CCGraphic_Point p_right;
&#125;CCGraphic_Line;

void CCGraphic_init_line(   CCGraphic_Line* line, 
                            CCGraphic_Point pl, 
                            CCGraphic_Point pr);

void CCGraphic_draw_line(CCDeviceHandler* handler, CCGraphic_Line* line);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>一个争论：</p>
<p>​    这样实现好不好啊？</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct __CCGraphic_Line&#123;
 CCGraphic_Point* p_left;
 CCGraphic_Point* p_right;
&#125;CCGraphic_Line;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    笔者思考过，事实上，笔者第一代的OLED框架（当然，远远没有现在的那么完善，也远远没有现在的好，甚至还有bug）就是这样实现的。我既然跟上面的实现不一致，那显然，有好处也就有坏处。</p>
<p>​    我们需要思考的是——我们的对象指针和对象本身表达的含义的区别是什么。关于这个说法，婆说婆有理，公说公有理，笔者这里给出的看法是：</p>
<p>​    <strong>对象本身在结构体中的声明是一种上层抽象对底层对象的强所属权，也就是说，对于每一个整个结构体模板刻出来的结构体对象的成员而言，内部所拥有的点都是独一无二的。</strong>换而言之：这就是我的资源，不是借的，更不是偷的！所以现在笔者采用的抽象，更加像是线对点宣誓了主权，这就是线组成的点，没有任何可以商量的余地。</p>
<p>​    <strong>对象指针则是一种弱的引用，表达的是一种借用。</strong>上面使用指针占用的抽象，更加像是：借来了两个点，然后用一下这两个点来描述了一下一根直线。用完了对象释放干净了，也就作罢了，但是点本身不会消失。就像我们用一根笔连起来了两个点，组成了一根线，现在我们只是把线擦除了，但是点还在呢！它还可以用来做别的事情。</p>
<p>​    从内存占用上来看，在ARM32体系上，我们都知道指针的大小是32位，4个字节，所以，我们一个sizeof就能得到使用指针抽象的线也就是8个字节。是一个恒定的大小。对于现在笔者采用的抽象，则是2倍的CCGraphic_Point大小，随着不同的PointBaseType, Line自身的大小也会发生波动，在uint8_t设备上，我们一共是4个字节大小，比指针描述的小，在uint16_t上则是不分伯仲，对于超大设备Line的大小就会膨胀为指针实现的两倍。</p>
<p>​    但是，另一方面，正如我所说的，这样的资源只是借用，他必须存在于哪个地方，问题来了，你能保证你所使用的点总是有效的吗？</p>
<pre class="line-numbers language-none"><code class="language-none">CCGraphic_Line	l;
&#123;
	CCGraphic_Point tl;
	CCGraphic_Point br;
	CCGraphic_init_line(&amp;l, tl, br);
&#125;
&#x2F;&#x2F; 在这里使用还安全嘛？
CCGraphic_draw_line(&amp;handle, &amp;l);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你也许知道你使用的对象是有效的，但是客户程序员呢？他不知道啊？随后应用层的程序因为非法的内存访问崩溃了（进入了Hard_Fault），他还要幸幸苦苦看你的实现，然后沮丧的调试了一天发现是库作者这个家伙居然只是借用点！最后代来的时间的开销是任何人都无法接受的，这样不确定的风险分明更加的剧烈。</p>
<p>笔者想要说的是：每一个设计都有它的优点和缺点，作为一个合格的程序员，不管是嵌入式程序员，还是架构设计师，都需要明确的表达自己资源的所属权，以及，不要违反“最小惊讶原则”（例子：这个怎么资源突然非法了！为什么库没有帮助我维护？？？）</p>
</blockquote>
<h4 id="实现我们的抽象-1"><a href="#实现我们的抽象-1" class="headerlink" title="实现我们的抽象"></a>实现我们的抽象</h4><p>​    规避浮点数运算！这个是我早就说了的。我们需要请出的算法就是<a target="_blank" rel="noopener" href="https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf">Bresenham (montana.edu)</a>算法，这个算法本质上使用的是DDA算法，一种整数微分思维。我们对得到的微分做一次取整，得到的就是整数的点（这是可以接受的，我们没办法在一个LCD或者是OLED上绘制坐标为<code>(1.25, 4.75)</code>的点，不是吗？）</p>
<p>​    为了化简，我们对绘制直线进行分类讨论</p>
<ol>
<li>绘制一条垂直的线</li>
<li>绘制一条水平的线</li>
<li>绘制任意斜率的线</li>
</ol>
<pre class="line-numbers language-none"><code class="language-none">void CCGraphic_draw_line(CCDeviceHandler* handler, CCGraphic_Line* line)
&#123; 
    &#x2F;&#x2F; test if the vertical
    if(line-&gt;p_left.x &#x3D;&#x3D; line-&gt;p_right.x) 
        return __on_handle_vertical_line(handler, line);   
    if(line-&gt;p_left.y &#x3D;&#x3D; line-&gt;p_right.y)
        return __on_handle_horizental_line(handler, line);
    return __pvt_BresenhamMethod_line(handler, line);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    没想到吧，笔者就用了这几行，完成了这几个事情。好吧，我承认这样有点耍赖了。实际上内部还是颇为复杂，但是，绘制垂直还有水平的线是轻而易举的，试一试？来看看笔者的代码吧！</p>
<h5 id="绘制垂直的和水平的线"><a href="#绘制垂直的和水平的线" class="headerlink" title="绘制垂直的和水平的线"></a>绘制垂直的和水平的线</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;*
    draw the lines that matches the equal x
*&#x2F;
static void __on_handle_vertical_line(
    CCDeviceHandler* handler,
    CCGraphic_Line* line
)
&#123;
    PointBaseType max_y &#x3D; max_uint16(line-&gt;p_left.y, line-&gt;p_right.y);
    PointBaseType min_y &#x3D; min_uint16(line-&gt;p_left.y, line-&gt;p_right.y);
    CCGraphic_Point p;
    p.x &#x3D; line-&gt;p_left.x;
    for(PointBaseType i &#x3D; min_y; i &lt;&#x3D; max_y; i++)
    &#123;
        p.y &#x3D; i;
        CCGraphic_draw_point(handler, &amp;p);
    &#125;
&#125;

static void __on_handle_horizental_line(
    CCDeviceHandler* handler,
    CCGraphic_Line* line
)
&#123;
    PointBaseType max_x &#x3D; max_uint16(line-&gt;p_left.x, line-&gt;p_right.x);
    PointBaseType min_x &#x3D; min_uint16(line-&gt;p_left.x, line-&gt;p_right.x);
    CCGraphic_Point p;
    p.y &#x3D; line-&gt;p_left.y;
    for(PointBaseType i &#x3D; min_x; i &lt;&#x3D; max_x; i++)
    &#123;
        p.x &#x3D; i;
        CCGraphic_draw_point(handler, &amp;p);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    我下面来谈论一下一些要点：</p>
<blockquote>
<ol>
<li><p>解释一下max_uint16和min_uint16?</p>
<p>没啥好解释的啊？这个就是择取大者和小者，有啥好说的呢？</p>
</li>
<li><p>为什么变量没有像江科大那样一股脑堆在前面呢？</p>
<p>笔者可以给出充分的原因：我希望变量出现在它该出现的位置，比起来，你也不喜欢看变量一坨屎拉在了函数的前面，下面看实现的时候漫天找这个变量在哪里吧。没那个必要！但是这个需要看情况，如果作者实在不会哪怕一丁点的函数设计，把代码一股脑的堆到了一个函数里，那还不如江科大的变量写法！</p>
</li>
<li><p>为什么不考虑</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
    PointBaseType max_y &#x3D; max_uint16(line-&gt;p_left.y, line-&gt;p_right.y);
    PointBaseType min_y &#x3D; min_uint16(line-&gt;p_left.y, line-&gt;p_right.y);
    for(PointBaseType i &#x3D; min_y; i &lt;&#x3D; max_y; i++)
    &#123;
    	CCGraphic_Point p;
    	p.x &#x3D; line-&gt;p_left.x;
        p.y &#x3D; i;
        CCGraphic_draw_point(handler, &amp;p);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个是经典的效率之争。你相信所有的编译器，都会意识到：“哦我的天，这个程序员是一个白痴，p的X坐标永远不会改变，这个白痴为什么要重新赋值一个相同的值max_y - min_y + 1次呢？”嘛？<br><strong>你不敢！</strong>，你永远也不知道使用你的代码的人，在用着怎样的老毕等编译器，他对这样的优化足够迟钝，以至于他对你那可怜的栈来来回回弹弹压压，让你的程序性能被砍到惊呼国骂。<strong>你敢打赌使用你库的代码的人，足够的现代嘛？</strong>那么，不如让我们的表述更加的明白</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;
    PointBaseType max_x &#x3D; max_uint16(line-&gt;p_left.x, line-&gt;p_right.x);
    PointBaseType min_x &#x3D; min_uint16(line-&gt;p_left.x, line-&gt;p_right.x);
    CCGraphic_Point p;
    p.y &#x3D; line-&gt;p_left.y;
    for(PointBaseType i &#x3D; min_x; i &lt;&#x3D; max_x; i++)
    &#123;
        p.x &#x3D; i;
        CCGraphic_draw_point(handler, &amp;p);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的代码的开销瞬间压到只剩下一次地址解引用和赋值操作了，一下子无论何种编译器，都能生成最为高效的字节码。</p>
</li>
<li><p>参数设计的时候，对于复杂抽象类型，使用指针还是使用结构体本身传递参数？</p>
<p>​    ARM32体系架构有16个寄存器，不同于x86老毕等，传递个结构体最后压内存去了，一些简单的POD类型（我们的Point就是一个简单的POD类型，只有数据没有方法）回直接解析内部的类型是整数，直接传送到寄存器中，将效率提升十几倍，而不用访问内存。这样看，对于一部分最为简单的结构体，直接传递对象本身不是一件特别耗操作的事情，但是，笔者仍然建议：<strong>如果你希望这个资源只是被借用一下，或者，表达传递的就是这个对象本身，他在ARM广阔的内存海洋是独一无二的话，使用指针，哪怕他就一个字节大小！</strong></p>
</li>
<li><p>所以，为什么在函数前面的最前面添加static</p>
<p>可惜了我们的C语言程序设计表达私有只能使用static办法，这表明，这个函数只能在文件内部访问，实际上的函数签名会被独特标记，导致外部生成的签名无法对应于实际上被static修饰的函数，这也就意味着无法通过编译！他没办法认识这个被static修饰的函数。<strong>至于其他乱七八糟的什么重名问题，我负责的告诉你，不要指望所有编译器都会正确的反应你的UB行为，不然，你就会在“编译了半天发现被这个问题绊了一跤”和“这个程序的行为怎么这么诡异啊？不是跳转道我想要的函数”中二选一了，反正代价是你的一天被你的UB行为坑害（笑）</strong></p>
</li>
</ol>
</blockquote>
<h5 id="使用Bresenham算法完成任意斜率的绘制"><a href="#使用Bresenham算法完成任意斜率的绘制" class="headerlink" title="使用Bresenham算法完成任意斜率的绘制"></a>使用Bresenham算法完成任意斜率的绘制</h5><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Bresenham&#39;s Line Algorithm, designed to avoid floating point calculations
&#x2F;&#x2F; References: https:&#x2F;&#x2F;www.cs.montana.edu&#x2F;courses&#x2F;spring2009&#x2F;425&#x2F;dslectures&#x2F;Bresenham.pdf
&#x2F;&#x2F; https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1364y1d7Lo
void __pvt_BresenhamMethod_line(CCDeviceHandler* handler, CCGraphic_Line* line)
&#123;
#define __pvt_fast_draw_point(X, Y) \
    do &#123; \
        p.x &#x3D; X; \
        p.y &#x3D; Y; \
        CCGraphic_draw_point(handler, &amp;p); \
    &#125; while(0)

    &#x2F;&#x2F; Define initial points for the line: p_left and p_right represent the endpoints
    int16_t startX &#x3D; line-&gt;p_left.x;
    int16_t startY &#x3D; line-&gt;p_left.y;
    int16_t endX &#x3D; line-&gt;p_right.x;
    int16_t endY &#x3D; line-&gt;p_right.y;

    &#x2F;&#x2F; Flags to indicate transformations of coordinates
    uint8_t isYInverted &#x3D; 0, isXYInverted &#x3D; 0;
    &#123;
        &#x2F;&#x2F; If the start point&#39;s X coordinate is greater than the end point&#39;s X, swap the points
        if (startX &gt; endX) &#123;
            &#x2F;&#x2F; Swap the X and Y coordinates for the start and end points
            swap_int16(&amp;startX, &amp;endX);
            swap_int16(&amp;startY, &amp;endY);
        &#125;

        &#x2F;&#x2F; If the start point&#39;s Y coordinate is greater than the end point&#39;s Y, invert the Y coordinates
        if (startY &gt; endY) &#123;
            &#x2F;&#x2F; Invert Y coordinates to make the line direction consistent in the first quadrant
            startY &#x3D; -startY;
            endY &#x3D; -endY;
            &#x2F;&#x2F; Set the flag indicating Y coordinates were inverted
            isYInverted &#x3D; 1;
        &#125;

        &#x2F;&#x2F; If the line&#39;s slope (dy&#x2F;dx) is greater than 1, swap X and Y coordinates for a shallower slope
        if (endY - startY &gt; endX - startX) &#123;
            &#x2F;&#x2F; Swap X and Y coordinates for both points
            swap_int16(&amp;startX, &amp;startY);
            swap_int16(&amp;endX, &amp;endY);
            &#x2F;&#x2F; Set the flag indicating both X and Y coordinates were swapped
            isXYInverted &#x3D; 1;
        &#125;

        &#x2F;&#x2F; Calculate differences (dx, dy) and the decision variables for Bresenham&#39;s algorithm
        const int16_t dx &#x3D; endX - startX;
        const int16_t dy &#x3D; endY - startY;
        const int16_t incrE &#x3D; 2 * dy;  &#x2F;&#x2F; Increment for eastward movement
        const int16_t incrNE &#x3D; 2 * (dy - dx);  &#x2F;&#x2F; Increment for northeastward movement

        int16_t decision &#x3D; 2 * dy - dx;  &#x2F;&#x2F; Initial decision variable
        int16_t x &#x3D; startX;  &#x2F;&#x2F; Starting X coordinate
        int16_t y &#x3D; startY;  &#x2F;&#x2F; Starting Y coordinate

        &#x2F;&#x2F; Draw the starting point and handle coordinate transformations based on flags
        CCGraphic_Point p;
        if (isYInverted &amp;&amp; isXYInverted) &#123;
            __pvt_fast_draw_point(y, -x);
        &#125; else if (isYInverted) &#123;
            __pvt_fast_draw_point(x, -y);
        &#125; else if (isXYInverted) &#123;
            __pvt_fast_draw_point(y, x);
        &#125; else &#123;
            __pvt_fast_draw_point(x, y);
        &#125;

        &#x2F;&#x2F; Iterate through the X-axis to draw the rest of the line
        while (x &lt; endX) &#123;
            x++;  &#x2F;&#x2F; Increment X coordinate
            if (decision &lt; 0) &#123;
                decision +&#x3D; incrE;  &#x2F;&#x2F; Move eastward if decision variable is negative
            &#125; else &#123;
                y++;  &#x2F;&#x2F; Move northeastward if decision variable is positive or zero
                decision +&#x3D; incrNE;
            &#125;

            &#x2F;&#x2F; Draw each point along the line with coordinate transformation as needed
            if (isYInverted &amp;&amp; isXYInverted) &#123;
                __pvt_fast_draw_point(y, -x);
            &#125; else if (isYInverted) &#123;
                __pvt_fast_draw_point(x, -y);
            &#125; else if (isXYInverted) &#123;
                __pvt_fast_draw_point(y, x);
            &#125; else &#123;
                __pvt_fast_draw_point(x, y);
            &#125;
        &#125;
    &#125;
#undef __pvt_fast_draw_point
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    好长一大串，先不必着急，我一步步慢慢说。实际上，这个算法除了使用DDA以外，还用了化未知为已知的办法。我的意思是：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; If the start point&#39;s X coordinate is greater than the end point&#39;s X, swap the points
if (startX &gt; endX) &#123;
    &#x2F;&#x2F; Swap the X and Y coordinates for the start and end points
    swap_int16(&amp;startX, &amp;endX);
    swap_int16(&amp;startY, &amp;endY);
&#125;

&#x2F;&#x2F; If the start point&#39;s Y coordinate is greater than the end point&#39;s Y, invert the Y coordinates
if (startY &gt; endY) &#123;
    &#x2F;&#x2F; Invert Y coordinates to make the line direction consistent in the first quadrant
    startY &#x3D; -startY;
    endY &#x3D; -endY;
    &#x2F;&#x2F; Set the flag indicating Y coordinates were inverted
    isYInverted &#x3D; 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    首先，确保我们的线总是向正的，斜率总是大于0</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; If the line&#39;s slope (dy&#x2F;dx) is greater than 1, swap X and Y coordinates for a shallower slope
 if (endY - startY &gt; endX - startX) &#123;
     &#x2F;&#x2F; Swap X and Y coordinates for both points
     swap_int16(&amp;startX, &amp;startY);
     swap_int16(&amp;endX, &amp;endY);
     &#x2F;&#x2F; Set the flag indicating both X and Y coordinates were swapped
     isXYInverted &#x3D; 1;
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    上面则是在斜率大于1的基础上，将变换映射到介于0 &lt; k &lt; 1的范围上。</p>
<p>​    最后，使用核心算法直接绘制</p>
<pre class="line-numbers language-none"><code class="language-none">    &#x2F;&#x2F; Calculate differences (dx, dy) and the decision variables for Bresenham&#39;s algorithm
    const int16_t dx &#x3D; endX - startX;
    const int16_t dy &#x3D; endY - startY;
    const int16_t incrE &#x3D; 2 * dy;  &#x2F;&#x2F; Increment for eastward movement
    const int16_t incrNE &#x3D; 2 * (dy - dx);  &#x2F;&#x2F; Increment for northeastward movement

    int16_t decision &#x3D; 2 * dy - dx;  &#x2F;&#x2F; Initial decision variable
    int16_t x &#x3D; startX;  &#x2F;&#x2F; Starting X coordinate
    int16_t y &#x3D; startY;  &#x2F;&#x2F; Starting Y coordinate

    &#x2F;&#x2F; Draw the starting point and handle coordinate transformations based on flags
    CCGraphic_Point p;
    if (isYInverted &amp;&amp; isXYInverted) &#123;
        __pvt_fast_draw_point(y, -x);
    &#125; else if (isYInverted) &#123;
        __pvt_fast_draw_point(x, -y);
    &#125; else if (isXYInverted) &#123;
        __pvt_fast_draw_point(y, x);
    &#125; else &#123;
        __pvt_fast_draw_point(x, y);
    &#125;

    &#x2F;&#x2F; Iterate through the X-axis to draw the rest of the line
    while (x &lt; endX) &#123;
        x++;  &#x2F;&#x2F; Increment X coordinate
        if (decision &lt; 0) &#123;
            decision +&#x3D; incrE;  &#x2F;&#x2F; Move eastward if decision variable is negative
        &#125; else &#123;
            y++;  &#x2F;&#x2F; Move northeastward if decision variable is positive or zero
            decision +&#x3D; incrNE;
        &#125;

        &#x2F;&#x2F; Draw each point along the line with coordinate transformation as needed
        if (isYInverted &amp;&amp; isXYInverted) &#123;
            __pvt_fast_draw_point(y, -x);
        &#125; else if (isYInverted) &#123;
            __pvt_fast_draw_point(x, -y);
        &#125; else if (isXYInverted) &#123;
            __pvt_fast_draw_point(y, x);	&#x2F;&#x2F; 对角对称，互换XY即可变换
        &#125; else &#123;
            __pvt_fast_draw_point(x, y);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这个代码就是直接翻译了我给的PDF的算法，下面来聊一聊算法之外的：</p>
<blockquote>
<ol>
<li><p>使用宏来化简我们的工作</p>
<pre class="line-numbers language-none"><code class="language-none">#define __pvt_fast_draw_point(X, Y) \
    do &#123; \
        p.x &#x3D; X; \
        p.y &#x3D; Y; \
        CCGraphic_draw_point(handler, &amp;p); \
    &#125; while(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个是一个简单的封装宏，为什么使用do..while请参考笔者之前的博客（协议篇）</p>
<p>C没有constexpr，没有模板，有的时候会显得十分贫瘠，所以，我们只好忍一下，使用宏完成重复的，0开销的工作。</p>
</li>
</ol>
</blockquote>
<h3 id="绘制三角形和矩形"><a href="#绘制三角形和矩形" class="headerlink" title="绘制三角形和矩形"></a>绘制三角形和矩形</h3><h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><pre class="line-numbers language-none"><code class="language-none">#ifndef CCGraphic_Rectangle_H
#define CCGraphic_Rectangle_H

#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Base.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Point&#x2F;CCGraphic_Point.h&quot;

typedef struct __CCGraphic_Rectangle&#123;
    CCGraphic_Point         top_left;
    CCGraphic_Point         bottom_right;
&#125;CCGraphic_Rectangle;

void CCGraphic_init_rectangle(
    CCGraphic_Rectangle* rect, CCGraphic_Point tl, CCGraphic_Point br);

void CCGraphic_draw_rectangle(
    CCDeviceHandler* handler, CCGraphic_Rectangle* rect);

void CCGraphic_drawfilled_rectangle(
    CCDeviceHandler* handler, CCGraphic_Rectangle* rect);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h4><pre class="line-numbers language-none"><code class="language-none">#ifndef CCGraphic_Triangle_H
#define CCGraphic_Triangle_H

#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Base.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Point&#x2F;CCGraphic_Point.h&quot;

typedef struct __CCGraphic_Triangle
&#123;
    CCGraphic_Point     p1;
    CCGraphic_Point     p2;
    CCGraphic_Point     p3;
&#125;CCGraphic_Triangle;


void CCGraphic_init_triangle(
    CCGraphic_Triangle* triangle, 
    CCGraphic_Point     p1,
    CCGraphic_Point     p2,
    CCGraphic_Point     p3
);

void CCGraphic_draw_triangle(
    CCDeviceHandler*    handle,
    CCGraphic_Triangle* triangle
);

void CCGraphic_drawfilled_triangle(
    CCDeviceHandler*    handle,
    CCGraphic_Triangle* triangle
);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>​    我们还是使用Bresenham算法和Franklin算法完成我们对三角形和矩形的绘制</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Triangle&#x2F;CCGraphic_Triangle.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Line&#x2F;CCGraphic_Line.h&quot;
#include &quot;Graphic&#x2F;CCGraphic_device_adapter.h&quot;
#include &quot;Graphic&#x2F;common&#x2F;CCGraphic_Utils.h&quot;

void CCGraphic_init_triangle(
    CCGraphic_Triangle* triangle, 
    CCGraphic_Point     p1,
    CCGraphic_Point     p2,
    CCGraphic_Point     p3
)
&#123;
    triangle-&gt;p1 &#x3D; p1;
    triangle-&gt;p2 &#x3D; p2;
    triangle-&gt;p3 &#x3D; p3;
&#125;

void CCGraphic_draw_triangle(
    CCDeviceHandler*    handle,
    CCGraphic_Triangle* triangle
)
&#123;
    CCGraphic_Line  line;
    CCGraphic_init_line(&amp;line, triangle-&gt;p1, triangle-&gt;p2);
    CCGraphic_draw_line(handle, &amp;line);
    handle-&gt;operations.update_device_function(handle);
    CCGraphic_init_line(&amp;line, triangle-&gt;p2, triangle-&gt;p3);
    CCGraphic_draw_line(handle, &amp;line);
    handle-&gt;operations.update_device_function(handle);
    CCGraphic_init_line(&amp;line, triangle-&gt;p1, triangle-&gt;p3);
    CCGraphic_draw_line(handle, &amp;line);
&#125;

static uint8_t __pvt_is_in_triangle(
    int16_t* triangles_x,
    int16_t* triangles_y,
    CCGraphic_Point* p)
&#123;
    uint8_t is_in &#x3D; 0;
	&#x2F;*此算法由W. Randolph Franklin提出*&#x2F;
	&#x2F;*参考链接：https:&#x2F;&#x2F;wrfranklin.org&#x2F;Research&#x2F;Short_Notes&#x2F;pnpoly.html*&#x2F;
	for (uint8_t i &#x3D; 0, j &#x3D; 2; i &lt; 3; j &#x3D; i++)
	&#123;
		if (((triangles_y[i] &gt; p-&gt;y) !&#x3D; (triangles_y[j] &gt; p-&gt;y)) &amp;&amp;
			(p-&gt;x &lt; (triangles_x[j] - triangles_x[i]) * 
            (p-&gt;y - triangles_y[i]) &#x2F; (triangles_y[j] - triangles_y[i]) + 
                triangles_x[i]))
		&#123;
			is_in &#x3D; !is_in;
		&#125;
	&#125;
	return is_in;
&#125;

void CCGraphic_drawfilled_triangle(
    CCDeviceHandler*    handle,
    CCGraphic_Triangle* triangle
)
&#123;
    int16_t triangles_x[] &#x3D; 
        &#123;triangle-&gt;p1.x, triangle-&gt;p2.x, triangle-&gt;p3.x&#125;;

    int16_t triangles_y[] &#x3D; 
        &#123;triangle-&gt;p1.y, triangle-&gt;p2.y, triangle-&gt;p3.y&#125;;

    int16_t minX &#x3D; find_int16min(triangles_x, 3);
    int16_t minY &#x3D; find_int16min(triangles_y, 3);

    int16_t maxX &#x3D; find_int16max(triangles_x, 3);
    int16_t maxY &#x3D; find_int16max(triangles_y, 3);
    
    CCGraphic_Point p;
    p.x &#x3D; minX;
    p.y &#x3D; minY;
    for(int16_t i &#x3D; minX; i &lt; maxX; i++)
    &#123;
        for(int16_t j &#x3D; minY; j &lt; maxY; j++)
        &#123;
            p.x &#x3D; i;
            p.y &#x3D; j;
            if(__pvt_is_in_triangle(triangles_x, triangles_y, &amp;p))
            &#123;
                CCGraphic_draw_point(handle, &amp;p);
            &#125;
        &#125;
    &#125;

&#125;

#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Rectangle&#x2F;CCGraphic_Rectangle.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Line&#x2F;CCGraphic_Line.h&quot;

void CCGraphic_init_rectangle(
    CCGraphic_Rectangle* rect, CCGraphic_Point tl, CCGraphic_Point br)
&#123;
    rect-&gt;top_left &#x3D; tl;
    rect-&gt;bottom_right &#x3D; br;
&#125;

void CCGraphic_draw_rectangle(
    CCDeviceHandler* handler, CCGraphic_Rectangle* rect)
&#123;
    CCGraphic_Line l;
    CCGraphic_Point tmp;

    &#x2F;&#x2F; draw top, set tmp as the top_right
    tmp.x &#x3D; rect-&gt;bottom_right.x;
    tmp.y &#x3D; rect-&gt;top_left.y;
    CCGraphic_init_line(&amp;l, rect-&gt;top_left, tmp);
    CCGraphic_draw_line(handler, &amp;l);

    &#x2F;&#x2F; draw right
    CCGraphic_init_line(&amp;l, tmp, rect-&gt;bottom_right);
    CCGraphic_draw_line(handler, &amp;l);    

    &#x2F;&#x2F; draw left
    tmp.x &#x3D; rect-&gt;top_left.x;
    tmp.y &#x3D; rect-&gt;bottom_right.y;
    CCGraphic_init_line(&amp;l, rect-&gt;top_left, tmp);
    CCGraphic_draw_line(handler, &amp;l);      

    &#x2F;&#x2F; draw bottom
    CCGraphic_init_line(&amp;l,tmp, rect-&gt;bottom_right);
    CCGraphic_draw_line(handler, &amp;l);      
&#125;


void CCGraphic_drawfilled_rectangle(
    CCDeviceHandler* handler, CCGraphic_Rectangle* rect)
&#123;
    CCGraphic_Point p;
    for(PointBaseType 
        iterate_x &#x3D; rect-&gt;top_left.x; 
        iterate_x &lt;&#x3D; rect-&gt;bottom_right.x; iterate_x++)
    &#123;
        p.x &#x3D; iterate_x;
        for(PointBaseType 
            iterate_y &#x3D; rect-&gt;top_left.y; 
            iterate_y &lt;&#x3D; rect-&gt;bottom_right.y; iterate_y++)
        &#123;
            p.y &#x3D; iterate_y;
            CCGraphic_draw_point(handler, &amp;p);
        &#125;        
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>小问题：提示，矩形的填充绘制是可以优化，你认为应该如何优化呢？（提示：我们是不是用错了device的功能了？）（可以在评论区回答的）</p>
</blockquote>
<h3 id="绘制圆，圆弧和椭圆"><a href="#绘制圆，圆弧和椭圆" class="headerlink" title="绘制圆，圆弧和椭圆"></a>绘制圆，圆弧和椭圆</h3><p>​    没有什么特殊的，笔者出于一些人上不去github，先把代码放到这里。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED/library/Graphic/base">MCU_Libs/OLED/library/Graphic/base at main · Charliechen114514/MCU_Libs (github.com)</a></p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">#ifndef CCGraphic_Arc_H
#define CCGraphic_Arc_H
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Base.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Point&#x2F;CCGraphic_Point.h&quot;

typedef struct __CCGraphic_Arc&#123;
    CCGraphic_Point     center;
    PointBaseType       radius;
    int16_t             start_degree;
    int16_t             end_degree;
&#125;CCGraphic_Arc;

void CCGraphic_init_CCGraphic_Arc(
    CCGraphic_Arc*      handle,
    CCGraphic_Point     center,
    PointBaseType       radius,
    int16_t             start_degree,
    int16_t             end_degree  
);

void CCGraphic_draw_arc(
    CCDeviceHandler* handler,
    CCGraphic_Arc* handle
);

void CCGraphic_drawfilled_arc(
    CCDeviceHandler* handler,
    CCGraphic_Arc* handle
);

#endif

#ifndef __CCGraphic_Circle_H
#define __CCGraphic_Circle_H
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Base.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Point&#x2F;CCGraphic_Point.h&quot;

typedef struct __CCGraphic_Circle
&#123;
    CCGraphic_Point             center;
    PointBaseType               radius;
&#125;CCGraphic_Circle;

void CCGraphic_init_circle(CCGraphic_Circle* circle, CCGraphic_Point c, uint8_t radius);
void CCGraphic_draw_circle(CCDeviceHandler* handler, CCGraphic_Circle* circle);
void CCGraphic_drawfilled_circle(CCDeviceHandler* handler, CCGraphic_Circle* circle);
#endif

#ifndef CCGraphic_Ellipse_H
#define CCGraphic_Ellipse_H
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Base.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Point&#x2F;CCGraphic_Point.h&quot;

typedef struct __CCGraphic_Ellipse&#123;
    CCGraphic_Point                 center;
    PointBaseType                   X_Radius;
    PointBaseType                   Y_Radius;  
&#125;CCGraphic_Ellipse;

void CCGraphic_init_ellipse(
    CCGraphic_Ellipse*          handle, 
    CCGraphic_Point             center,
    PointBaseType               X_Radius,
    PointBaseType               Y_Radius 
);

void CCGraphic_draw_ellipse(
    CCDeviceHandler* handler,
    CCGraphic_Ellipse* ellipse
);

void CCGraphic_drawfilled_ellipse(
    CCDeviceHandler* handler,
    CCGraphic_Ellipse* ellipse
);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>实现如下</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Arc&#x2F;CCGraphic_Arc.h&quot;
#include &lt;math.h&gt;

void CCGraphic_init_CCGraphic_Arc(
    CCGraphic_Arc*      handle,
    CCGraphic_Point     center,
    PointBaseType       radius,
    int16_t             start_degree,
    int16_t             end_degree  
)
&#123;
    handle-&gt;center          &#x3D; center;
    handle-&gt;end_degree      &#x3D; end_degree;
    handle-&gt;start_degree    &#x3D; start_degree;
    handle-&gt;radius          &#x3D; radius;
&#125;

static uint8_t __pvt_is_in_angle(int16_t x, int16_t y, int16_t start, int16_t end)
&#123;
    int16_t point_angle &#x3D; (atan2(y, x) &#x2F; 3.14 * 180);
	&#x2F;&#x2F; 笔者的一个更加清晰的写法
	&#x2F;&#x2F; if (start &lt; end)	&#x2F;&#x2F;起始角度小于终止角度的情况
	&#x2F;&#x2F; &#123;
	&#x2F;&#x2F; 	&#x2F;*如果指定角度在起始终止角度之间，则判定指定点在指定角度*&#x2F;
	&#x2F;&#x2F; 	if (point_angle &gt;&#x3D; start &amp;&amp; point_angle &lt;&#x3D; end)
	&#x2F;&#x2F; 	&#123;
	&#x2F;&#x2F; 		return 1;
	&#x2F;&#x2F; 	&#125;
	&#x2F;&#x2F; &#125;
	&#x2F;&#x2F; else			&#x2F;&#x2F;起始角度大于于终止角度的情况
	&#x2F;&#x2F; &#123;
	&#x2F;&#x2F; 	&#x2F;*如果指定角度大于起始角度或者小于终止角度，则判定指定点在指定角度*&#x2F;
	&#x2F;&#x2F; 	if (point_angle &gt;&#x3D; start || point_angle &lt;&#x3D; end)
	&#x2F;&#x2F; 	&#123;
	&#x2F;&#x2F; 		return 1;
	&#x2F;&#x2F; 	&#125;
	&#x2F;&#x2F; &#125;
	&#x2F;&#x2F; return 0;	

    return start &lt; end ?
        (start &lt; point_angle &amp;&amp; point_angle &lt; end):
        (start &gt; point_angle || point_angle &gt; end);
&#125;

#define DRAW_OFFSET_POINT(offsetx, offsety) \
    do&#123;\
        point.x &#x3D; handle-&gt;center.x + (offsetx);\
        point.y &#x3D; handle-&gt;center.y + (offsety);\
        CCGraphic_draw_point(handler, &amp;point);\
    &#125;while(0)

#define DRAW_IF_IN(offsetx, offsety) \
    do&#123;\
        if (__pvt_is_in_angle((offsetx), (offsety), start_angle, end_angle))	&#123;\
            DRAW_OFFSET_POINT(offsetx, offsety);\
        &#125;\
    &#125;while(0)   

void CCGraphic_draw_arc(
    CCDeviceHandler* handler,
    CCGraphic_Arc* handle
)
&#123;
	&#x2F;*此函数借用Bresenham算法画圆的方法*&#x2F;	
	int16_t x &#x3D; 0;
	int16_t y &#x3D; handle-&gt;radius;
    int16_t d &#x3D; 1 - y;

    CCGraphic_Point point;
	const int16_t start_angle &#x3D; handle-&gt;start_degree;
    const int16_t end_angle &#x3D; handle-&gt;end_degree;
	&#x2F;*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*&#x2F;
    DRAW_IF_IN(x, y);
    DRAW_IF_IN(-x, -y);
    DRAW_IF_IN(y, x);
    DRAW_IF_IN(-y, -x);
	
	while (x &lt; y)		&#x2F;&#x2F;遍历X轴的每个点
	&#123;
		x ++;
		if (d &lt; 0)		&#x2F;&#x2F;下一个点在当前点东方
		&#123;
			d +&#x3D; 2 * x + 1;
		&#125;
		else			&#x2F;&#x2F;下一个点在当前点东南方
		&#123;
			y --;
			d +&#x3D; 2 * (x - y) + 1;
		&#125;
		
		&#x2F;*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*&#x2F;
        DRAW_IF_IN(x, y);
        DRAW_IF_IN(y, x);
        DRAW_IF_IN(-x, -y);
        DRAW_IF_IN(-y, -x);
        DRAW_IF_IN(x, -y);
        DRAW_IF_IN(y, -x);
        DRAW_IF_IN(-x, y);
        DRAW_IF_IN(-y, x);
	&#125;
&#125;

void CCGraphic_drawfilled_arc(
    CCDeviceHandler* handler,
    CCGraphic_Arc* handle
)
&#123;
	&#x2F;*此函数借用Bresenham算法画圆的方法*&#x2F;	
	int16_t x &#x3D; 0;
	int16_t y &#x3D; handle-&gt;radius;
    int16_t d &#x3D; 1 - y;

    CCGraphic_Point point;
	const int16_t start_angle &#x3D; handle-&gt;start_degree;
    const int16_t end_angle &#x3D; handle-&gt;end_degree;
    point.x &#x3D; x;
    point.y &#x3D; y;
	
	&#x2F;*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*&#x2F;
    DRAW_IF_IN(x, y);
    DRAW_IF_IN(-x, -y);
    DRAW_IF_IN(y, x);
    DRAW_IF_IN(-y, -x);

	&#x2F;*遍历起始点Y坐标*&#x2F;
	for (int16_t j &#x3D; -y; j &lt; y; j ++)
	&#123;
		&#x2F;*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*&#x2F;
		DRAW_IF_IN(0, j);
	&#125;
	
	while (x &lt; y)		&#x2F;&#x2F;遍历X轴的每个点
	&#123;
		x ++;
		if (d &lt; 0)		&#x2F;&#x2F;下一个点在当前点东方
		&#123;
			d +&#x3D; 2 * x + 1;
		&#125;
		else			&#x2F;&#x2F;下一个点在当前点东南方
		&#123;
			y --;
			d +&#x3D; 2 * (x - y) + 1;
		&#125;
		
		&#x2F;*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*&#x2F;
        DRAW_IF_IN(x, y);
        DRAW_IF_IN(y, x);
        DRAW_IF_IN(-x, -y);
        DRAW_IF_IN(-y, -x);
        DRAW_IF_IN(x, -y);
        DRAW_IF_IN(y, -x);
        DRAW_IF_IN(-x, y);
        DRAW_IF_IN(-y, x);

		&#x2F;*遍历中间部分*&#x2F;
		for (int16_t j &#x3D; -y; j &lt; y; j ++)
		&#123;
				&#x2F;*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*&#x2F;
			DRAW_IF_IN(x, j);
            DRAW_IF_IN(-x, j);
		&#125;
			
		&#x2F;*遍历两侧部分*&#x2F;
		for (int16_t j &#x3D; -x; j &lt; x; j ++)
		&#123;
			&#x2F;*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则不做处理*&#x2F;
			DRAW_IF_IN(y, j);
            DRAW_IF_IN(-y, j);
		&#125;
	&#125;
&#125;

#undef DRAW_OFFSET_POINT
#undef DRAW_IF_IN

#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Ellipse&#x2F;CCGraphic_Ellipse.h&quot;

void CCGraphic_init_ellipse(
    CCGraphic_Ellipse*          handle, 
    CCGraphic_Point             center,
    PointBaseType               X_Radius,
    PointBaseType               Y_Radius 
)
&#123;
    handle-&gt;center &#x3D; center;
    handle-&gt;X_Radius &#x3D; X_Radius;
    handle-&gt;Y_Radius &#x3D; Y_Radius;
&#125;

#define DRAW_OFFSET_POINT(offsetx, offsety) \
    do&#123;\
        point.x &#x3D; ellipse-&gt;center.x + (offsetx);\
        point.y &#x3D; ellipse-&gt;center.y + (offsety);\
        CCGraphic_draw_point(handler, &amp;point);\
    &#125;while(0)

#define SQUARE(X) ((X) * (X))

void CCGraphic_draw_ellipse(
    CCDeviceHandler* handler,
    CCGraphic_Ellipse* ellipse
)
&#123;
    const int16_t x_radius &#x3D; ellipse-&gt;X_Radius;
    const int16_t y_radius &#x3D; ellipse-&gt;Y_Radius;

    &#x2F;&#x2F; Bresenham&#39;s Ellipse Algorithm to avoid costly floating point calculations
    &#x2F;&#x2F; Reference: https:&#x2F;&#x2F;blog.csdn.net&#x2F;myf_666&#x2F;article&#x2F;details&#x2F;128167392

    int16_t x &#x3D; 0;
    int16_t y &#x3D; y_radius;
    const int16_t y_radius_square &#x3D; SQUARE(y_radius);
    const int16_t x_radius_square &#x3D; SQUARE(x_radius);

    &#x2F;&#x2F; Initial decision variable for the first region of the ellipse
    float d1 &#x3D; y_radius_square + x_radius_square * (-y_radius + 0.5);

    &#x2F;&#x2F; Draw initial points on the ellipse (4 points due to symmetry)
    CCGraphic_Point point;
    DRAW_OFFSET_POINT(x, y);
    DRAW_OFFSET_POINT(-x, -y);
    DRAW_OFFSET_POINT(-x, y);
    DRAW_OFFSET_POINT(x, -y);

    &#x2F;&#x2F; Draw the middle part of the ellipse (first region)
    while (y_radius_square * (x + 1) &lt; x_radius_square * (y - 0.5)) &#123;
        if (d1 &lt;&#x3D; 0) &#123;  &#x2F;&#x2F; Next point is to the east of the current point
            d1 +&#x3D; y_radius_square * (2 * x + 3);
        &#125; else &#123;  &#x2F;&#x2F; Next point is southeast of the current point
            d1 +&#x3D; y_radius_square * (2 * x + 3) + x_radius_square * (-2 * y + 2);
            y--;
        &#125;
        x++;

        &#x2F;&#x2F; Draw ellipse arc for each point in the current region
        DRAW_OFFSET_POINT(x, y);
        DRAW_OFFSET_POINT(-x, -y);
        DRAW_OFFSET_POINT(-x, y);
        DRAW_OFFSET_POINT(x, -y);
    &#125;

    &#x2F;&#x2F; Draw the two sides of the ellipse (second region)
    float d2 &#x3D; SQUARE(y_radius * (x + 0.5)) + SQUARE(x_radius * (y - 1)) - x_radius_square * y_radius_square;

    while (y &gt; 0) &#123;
        if (d2 &lt;&#x3D; 0) &#123;  &#x2F;&#x2F; Next point is to the east of the current point
            d2 +&#x3D; y_radius_square * (2 * x + 2) + x_radius_square * (-2 * y + 3);
            x++;
        &#125; else &#123;  &#x2F;&#x2F; Next point is southeast of the current point
            d2 +&#x3D; x_radius_square * (-2 * y + 3);
        &#125;
        y--;

        &#x2F;&#x2F; Draw ellipse arc for each point on the sides
        DRAW_OFFSET_POINT(x, y);
        DRAW_OFFSET_POINT(-x, -y);
        DRAW_OFFSET_POINT(-x, y);
        DRAW_OFFSET_POINT(x, -y);
    &#125;
&#125;

void CCGraphic_drawfilled_ellipse(
    CCDeviceHandler* handler,
    CCGraphic_Ellipse* ellipse
)
&#123;
    const int16_t x_radius &#x3D; ellipse-&gt;X_Radius;
    const int16_t y_radius &#x3D; ellipse-&gt;Y_Radius;

    &#x2F;&#x2F; Bresenham&#39;s Ellipse Algorithm to avoid costly floating point calculations
    &#x2F;&#x2F; Reference: https:&#x2F;&#x2F;blog.csdn.net&#x2F;myf_666&#x2F;article&#x2F;details&#x2F;128167392

    int16_t x &#x3D; 0;
    int16_t y &#x3D; y_radius;
    const int16_t y_radius_square &#x3D; SQUARE(y_radius);
    const int16_t x_radius_square &#x3D; SQUARE(x_radius);

    &#x2F;&#x2F; Initial decision variable for the first region of the ellipse
    float d1 &#x3D; y_radius_square + x_radius_square * (-y_radius + 0.5);
    CCGraphic_Point point;
    &#x2F;&#x2F; Fill the ellipse by drawing vertical lines in the specified range (filled area)
    for (int16_t j &#x3D; -y; j &lt; y; j++) &#123;
        &#x2F;&#x2F; Draw vertical lines to fill the area of the ellipse
        DRAW_OFFSET_POINT(0, j);
        DRAW_OFFSET_POINT(0, j);
    &#125;

    &#x2F;&#x2F; Draw initial points on the ellipse (4 points due to symmetry)
    DRAW_OFFSET_POINT(x, y);
    DRAW_OFFSET_POINT(-x, -y);
    DRAW_OFFSET_POINT(-x, y);
    DRAW_OFFSET_POINT(x, -y);

    &#x2F;&#x2F; Draw the middle part of the ellipse (first region)
    while (y_radius_square * (x + 1) &lt; x_radius_square * (y - 0.5)) &#123;
        if (d1 &lt;&#x3D; 0) &#123;  &#x2F;&#x2F; Next point is to the east of the current point
            d1 +&#x3D; y_radius_square * (2 * x + 3);
        &#125; else &#123;  &#x2F;&#x2F; Next point is southeast of the current point
            d1 +&#x3D; y_radius_square * (2 * x + 3) + x_radius_square * (-2 * y + 2);
            y--;
        &#125;
        x++;

        &#x2F;&#x2F; Fill the ellipse by drawing vertical lines in the current range
        for (int16_t j &#x3D; -y; j &lt; y; j++) &#123;
            DRAW_OFFSET_POINT(x, j);
            DRAW_OFFSET_POINT(-x, j);
        &#125;

        &#x2F;&#x2F; Draw ellipse arc for each point in the current region
        DRAW_OFFSET_POINT(x, y);
        DRAW_OFFSET_POINT(-x, -y);
        DRAW_OFFSET_POINT(-x, y);
        DRAW_OFFSET_POINT(x, -y);
    &#125;

    &#x2F;&#x2F; Draw the two sides of the ellipse (second region)
    float d2 &#x3D; SQUARE(y_radius * (x + 0.5)) + SQUARE(x_radius * (y - 1)) - x_radius_square * y_radius_square;

    while (y &gt; 0) &#123;
        if (d2 &lt;&#x3D; 0) &#123;  &#x2F;&#x2F; Next point is to the east of the current point
            d2 +&#x3D; y_radius_square * (2 * x + 2) + x_radius_square * (-2 * y + 3);
            x++;
        &#125; else &#123;  &#x2F;&#x2F; Next point is southeast of the current point
            d2 +&#x3D; x_radius_square * (-2 * y + 3);
        &#125;
        y--;

        &#x2F;&#x2F; Fill the ellipse by drawing vertical lines in the current range
        for (int16_t j &#x3D; -y; j &lt; y; j++) &#123;
            DRAW_OFFSET_POINT(x, j);
            DRAW_OFFSET_POINT(-x, j);
        &#125;

        &#x2F;&#x2F; Draw ellipse arc for each point on the sides
        DRAW_OFFSET_POINT(x, y);
        DRAW_OFFSET_POINT(-x, -y);
        DRAW_OFFSET_POINT(-x, y);
        DRAW_OFFSET_POINT(x, -y);
    &#125;
&#125;

#undef DRAW_OFFSET_POINT
#undef SQUARE

#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Circle&#x2F;CCGraphic_Circle.h&quot;
#include &quot;Graphic&#x2F;CCGraphic_device_adapter.h&quot;
#include &quot;Graphic&#x2F;common&#x2F;CCGraphic_Utils.h&quot;

void CCGraphic_init_circle(
    CCGraphic_Circle* circle, CCGraphic_Point c, uint8_t radius)
&#123;
    circle-&gt;center &#x3D; c;
    circle-&gt;radius &#x3D; radius;
&#125;

#define DRAW_OFFSET_POINT(point, offsetx, offsety) \
    do &#123; \
        point.x &#x3D; circle-&gt;center.x + (offsetx); \
        point.y &#x3D; circle-&gt;center.y + (offsety); \
        CCGraphic_draw_point(handler, &amp;point);&#125;while(0)

void CCGraphic_draw_circle(
    CCDeviceHandler* handler, CCGraphic_Circle* circle)
&#123;
	&#x2F;*参考文档：https:&#x2F;&#x2F;www.cs.montana.edu&#x2F;courses&#x2F;spring2009&#x2F;425&#x2F;dslectures&#x2F;Bresenham.pdf*&#x2F;
	&#x2F;*参考教程：https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1VM4y1u7wJ*&#x2F;
    CCGraphic_Point p;
    int16_t d &#x3D; 1 - circle-&gt;radius;
    int16_t x &#x3D; 0;
    int16_t y &#x3D; circle-&gt;radius;

    DRAW_OFFSET_POINT(p, x, y);
    DRAW_OFFSET_POINT(p, -x, -y);
    DRAW_OFFSET_POINT(p, y, x);
    DRAW_OFFSET_POINT(p, -y, -x);

    while(x &lt; y)
    &#123;
        x++;
        if(d &lt; 0)&#123; d +&#x3D; 2 * x + 1;&#125;
        else &#123;y--; d +&#x3D; 2 * (x - y) + 1;&#125;
        DRAW_OFFSET_POINT(p, x, y);
        DRAW_OFFSET_POINT(p, y, x);
        DRAW_OFFSET_POINT(p, -x, -y);
        DRAW_OFFSET_POINT(p, -y, -x);
        DRAW_OFFSET_POINT(p, x, -y);
        DRAW_OFFSET_POINT(p, y, -x);
        DRAW_OFFSET_POINT(p, -x, y);
        DRAW_OFFSET_POINT(p, -y, x);            
    &#125;
&#125;

void CCGraphic_drawfilled_circle(CCDeviceHandler* handler, CCGraphic_Circle* circle)
&#123;
    CCGraphic_Point p;
    int16_t d &#x3D; 1 - circle-&gt;radius;
    int16_t x &#x3D; 0;
    int16_t y &#x3D; circle-&gt;radius;

    DRAW_OFFSET_POINT(p, x, y);
    DRAW_OFFSET_POINT(p, -x, -y);
    DRAW_OFFSET_POINT(p, y, x);
    DRAW_OFFSET_POINT(p, -y, -x);

    for(int16_t i &#x3D; -y; i &lt; y; i++)
        DRAW_OFFSET_POINT(p, 0, i);

    while(x &lt; y)
    &#123;
        x++;
        if(d &lt; 0)&#123; d +&#x3D; 2 * x + 1;&#125;
        else &#123;y--; d +&#x3D; 2 * (x - y) + 1;&#125;
        DRAW_OFFSET_POINT(p, x, y);
        DRAW_OFFSET_POINT(p, y, x);
        DRAW_OFFSET_POINT(p, -x, -y);
        DRAW_OFFSET_POINT(p, -y, -x);
        DRAW_OFFSET_POINT(p, x, -y);
        DRAW_OFFSET_POINT(p, y, -x);
        DRAW_OFFSET_POINT(p, -x, y);
        DRAW_OFFSET_POINT(p, -y, x);   
        for(int16_t i &#x3D; -y; i &lt; y; i++)
        &#123;
            DRAW_OFFSET_POINT(p, x, i);
            DRAW_OFFSET_POINT(p, -x, i);  
        &#125;
        for(int16_t i &#x3D; -x; i &lt; x; i++)
        &#123;
            DRAW_OFFSET_POINT(p, y, i);
            DRAW_OFFSET_POINT(p, -y, i);  
        &#125;              
    &#125;    
&#125;

#undef DRAW_OFFSET_POINT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    现在我们可以上测试了</p>
<h3 id="继续我们的测试"><a href="#继续我们的测试" class="headerlink" title="继续我们的测试"></a>继续我们的测试</h3><pre class="line-numbers language-none"><code class="language-none">#include &quot;Test&#x2F;GraphicTest&#x2F;graphic_test.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Point&#x2F;CCGraphic_Point.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Line&#x2F;CCGraphic_Line.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Circle&#x2F;CCGraphic_Circle.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Rectangle&#x2F;CCGraphic_Rectangle.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Triangle&#x2F;CCGraphic_Triangle.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Ellipse&#x2F;CCGraphic_Ellipse.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Arc&#x2F;CCGraphic_Arc.h&quot;

void on_test_draw_points(CCDeviceHandler* handle)
&#123;
    CCGraphic_Point point;
    CCGraphic_init_point(&amp;point, 0, 0);
    for(uint8_t i &#x3D; 0; i &lt; 20; i++)
    &#123;
        point.x &#x3D; i;
        point.y &#x3D; i * 2;
        CCGraphic_draw_point(handle, &amp;point);
    &#125;
    handle-&gt;operations.update_device_function(handle);
&#125;

void on_test_draw_line(CCDeviceHandler* handle)
&#123;
    CCGraphic_Line  l;
    CCGraphic_Point pleft;
    CCGraphic_Point pright;
    &#x2F;&#x2F; try vertical
    pleft.x     &#x3D; 5;
    pleft.y     &#x3D; 0;
    pright.x    &#x3D; pleft.x;
    pright.y    &#x3D; 63;

    CCGraphic_init_line(&amp;l, pleft, pright);
    CCGraphic_draw_line(handle, &amp;l);

    &#x2F;&#x2F; try horizontal
    pleft.x     &#x3D; 0;
    pleft.y     &#x3D; 5;
    pright.x    &#x3D; 120;
    pright.y    &#x3D; pleft.y;

    CCGraphic_init_line(&amp;l, pleft, pright);
    CCGraphic_draw_line(handle, &amp;l);

    &#x2F;&#x2F; try different
    pleft.x     &#x3D; 0;
    pleft.y     &#x3D; 10;
    pright.x    &#x3D; 105;
    pright.y    &#x3D; 63;

    CCGraphic_init_line(&amp;l, pleft, pright);
    CCGraphic_draw_line(handle, &amp;l);
    handle-&gt;operations.update_device_function(handle);
&#125;

void on_test_draw_circle(CCDeviceHandler* handle)
&#123;
    CCGraphic_Circle c;
    CCGraphic_Point p;
    p.x &#x3D; 64;
    p.y &#x3D; 32;
    CCGraphic_init_circle(&amp;c, p, 10);
    CCGraphic_drawfilled_circle(handle, &amp;c);

    p.x &#x3D; 10;
    p.y &#x3D; 32;
    CCGraphic_init_circle(&amp;c, p, 5);
    CCGraphic_draw_circle(handle, &amp;c);
    handle-&gt;operations.update_device_function(handle);
&#125;

void on_test_draw_rectangle(CCDeviceHandler* handle)
&#123;
    CCGraphic_Rectangle rect;
    CCGraphic_Point     tl;
    CCGraphic_Point     br;

    tl.x &#x3D; 5;
    tl.y &#x3D; 5;

    br.x &#x3D; 20;
    br.y &#x3D; 20;

    CCGraphic_init_rectangle(&amp;rect, tl, br);
    CCGraphic_draw_rectangle(handle, &amp;rect);

    tl.x &#x3D; 21;
    tl.y &#x3D; 21;

    br.x &#x3D; 50;
    br.y &#x3D; 50;    
    CCGraphic_init_rectangle(&amp;rect, tl, br);
    CCGraphic_drawfilled_rectangle(handle, &amp;rect);
    handle-&gt;operations.update_device_function(handle);
&#125;

void on_test_draw_triangle(CCDeviceHandler* handle)
&#123;
    CCGraphic_Triangle  triangle;
    CCGraphic_Point     p1;
    CCGraphic_Point     p2;
    CCGraphic_Point     p3;

    p1.x &#x3D; 10;
    p1.y &#x3D; 10;

    p2.x &#x3D; 15;
    p2.y &#x3D; 5;

    p3.x &#x3D; 80;
    p3.y &#x3D; 40;

    CCGraphic_init_triangle(&amp;triangle, p1, p3, p2);
    CCGraphic_drawfilled_triangle(handle, &amp;triangle);
    handle-&gt;operations.update_device_function(handle);
&#125;

void on_test_draw_ellipse(CCDeviceHandler* handle)
&#123;
    CCGraphic_Ellipse ellipse;
    CCGraphic_Point p;
    p.x &#x3D; 20;
    p.y &#x3D; 32;

    CCGraphic_init_ellipse(&amp;ellipse, p, 10, 30);
    CCGraphic_draw_ellipse(handle, &amp;ellipse);

    p.x &#x3D; 80;
    p.y &#x3D; 32;
    CCGraphic_init_ellipse(&amp;ellipse, p, 40, 30);
    CCGraphic_drawfilled_ellipse(handle, &amp;ellipse);
    handle-&gt;operations.update_device_function(handle);
&#125;

void on_test_draw_arc(CCDeviceHandler* handle)
&#123;
    CCGraphic_Arc arc;
    CCGraphic_Point p;
    p.x &#x3D; 64;
    p.y &#x3D; 32;
    CCGraphic_init_CCGraphic_Arc(&amp;arc, p, 40, -20, 40);
    CCGraphic_draw_arc(handle, &amp;arc);
    handle-&gt;operations.update_device_function(handle);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    在main.c中就可以这样调用</p>
<pre class="line-numbers language-none"><code class="language-none">on_test_draw_points(handler);
  HAL_Delay(1000);
  on_test_draw_line(handler);
  HAL_Delay(1000);
  on_test_draw_circle(handler);
  HAL_Delay(1000);
  on_test_draw_rectangle(handler);
  HAL_Delay(1000);
  on_test_draw_triangle(handler);
  HAL_Delay(1000);
  on_test_draw_ellipse(handler);
  HAL_Delay(1000);
  on_test_draw_arc(handler);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础组件实现）"><a href="#从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础组件实现）" class="headerlink" title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础组件实现）"></a>从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础组件实现）</h1><h2 id="基础组件实现"><a href="#基础组件实现" class="headerlink" title="基础组件实现"></a>基础组件实现</h2><p>​    我们现在离手搓一个动态的多级菜单越来越近了。终于！我们来到了最基础的组件实现，我们现在搓的东西的代码库放到了：<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED/library/Graphic/widgets/base">MCU_Libs/OLED/library/Graphic/widgets/base at main · Charliechen114514/MCU_Libs (github.com)</a>当中，也就是手搓图像显示和文字显示。如果你对这篇博客所属的集合有任何疑问，可以到<a target="_blank" rel="noopener" href="https://blog.csdn.net/charlie114514191/article/details/145397231">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架-CSDN博客</a>阅读。</p>
<h3 id="如何将图像和文字显示到OLED上"><a href="#如何将图像和文字显示到OLED上" class="headerlink" title="如何将图像和文字显示到OLED上"></a>如何将图像和文字显示到OLED上</h3><p>​    <strong>三个字：画出来！</strong>带上一个KeysKing大跌手搓的取码地址：<a target="_blank" rel="noopener" href="https://led.baud-dance.com/">波特律动LED字模生成器 (baud-dance.com)</a>，实际上，你的悟性足够高，已经可以离开这篇博客自己继续手搓了。</p>
<p>​    好吧，你继续往下看了，那我就详细的好好说明。</p>
<h4 id="如何绘制图像"><a href="#如何绘制图像" class="headerlink" title="如何绘制图像"></a>如何绘制图像</h4><p>​    绘制图像之前，我们还要遵循老步骤，思考一下如何设计我们的抽象。</p>
<p>​    我们如何描述一个给定的图像呢？我们可能着急于描述这个图像表达了什么，也就是图像的资源，在OLED中，我们习惯于阐述为一个字节的数组，这个数组描述了我们的图像，只要把它传递上去，一个图像就显示出来我们可以看了。</p>
<p>​    但是还是有问题：你这个图像放到哪里呢？画的要多大呢？这就是我们需要设计一个结构体抽象的原因了。请看VCR：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct __CCGraphic_Image&#123;
    CCGraphic_Point point;
    CCGraphic_Size  image_size;
    uint8_t*        sources_register;
&#125;CCGraphic_Image;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    关于CCGraphic_Size，并不复杂，可以到<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED/library/Graphic/widgets/common/CCGraphic_Size">MCU_Libs/OLED/library/Graphic/widgets/common/CCGraphic_Size at main · Charliechen114514/MCU_Libs (github.com)</a>中看到源码，实际上就是宽和高的一个封装，没什么大不了的。</p>
<p>​    此外，我们对图像的操作就是绘制了</p>
<pre class="line-numbers language-none"><code class="language-none">void CCGraphicWidget_init_image(
    CCGraphic_Image*    image,
    CCGraphic_Point     tl_point,
    CCGraphic_Size      image_size,
    uint8_t*      sources_register
);

void CCGraphicWidget_draw_image(
    CCDeviceHandler*    handler,
    CCGraphic_Image*    image
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    出乎你意料的是。绘制图像远远比你想象的简单的多</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;widgets&#x2F;base&#x2F;CCGraphic_Image&#x2F;CCGraphic_Image.h&quot;
#include &quot;Graphic&#x2F;CCGraphic_device_adapter.h&quot;
void CCGraphicWidget_init_image(
    CCGraphic_Image*    image,
    CCGraphic_Point     tl_point,
    CCGraphic_Size      image_size,
    uint8_t*      sources_register
)
&#123;
    image-&gt;image_size &#x3D; image_size;
    image-&gt;point &#x3D; tl_point;
    image-&gt;sources_register &#x3D; sources_register;
&#125;

void CCGraphicWidget_draw_image(
    CCDeviceHandler*    handler,
    CCGraphic_Image*    image
)
&#123;
    if(!image-&gt;sources_register) return;
    handler-&gt;operations.draw_area_device_function(
        handler, image-&gt;point.x, image-&gt;point.y,
        image-&gt;image_size.width, image-&gt;image_size.height, image-&gt;sources_register
    );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    我们直接使用设备draw_area的方法，将图像资源传递上去了。</p>
<pre class="line-numbers language-none"><code class="language-none">CCGraphicWidget_draw_image -&gt; draw_area_device_function(draw_area_device_oled) -&gt; oled_helper_draw_area<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    你看，干净利落！完事。</p>
<h4 id="如何绘制文字"><a href="#如何绘制文字" class="headerlink" title="如何绘制文字"></a>如何绘制文字</h4><p>​    现在这个事情就需要深思熟虑了，设计到文字，就必然需要考虑字体大小，以及解析字符串的问题。笔者这里没有实现UTF-8字符的打印实现，但是笔者提示你，<strong>仍然是画出来字符</strong>。让我们看看该咋做。</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct __CCGraphic_TextHandle&#123;
    char*               sources_borrowed;		&#x2F;&#x2F; 这个就是所持有的字体资源指针
    CCGraphic_Point     tl_point;				&#x2F;&#x2F; 这个是所占有的左上角的绘制起点
    CCGraphic_Point     indexed_point; 			&#x2F;&#x2F; 这个是现在的绘制指针，表明现在我们绘制到了那个地方
    CCGraphic_Size      TexthandleSize;   		&#x2F;&#x2F; 整个Text所在的BoundingRect大小
    Ascii_Font_Size     font_size;				&#x2F;&#x2F; 字体多大？
&#125;CCGraphic_AsciiTextItem;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="如何获取字体？"><a href="#如何获取字体？" class="headerlink" title="如何获取字体？"></a>如何获取字体？</h5><p>关于ASCII字体的获取，笔者放到了附录里，值得一提的是，江科大的OLED_Data.h中对字体数组的初始化时<strong>不严谨的，不规范的</strong>，正确的初始化方案已经放到了附录，不再赘述。</p>
<h5 id="如何正确的访问字体"><a href="#如何正确的访问字体" class="headerlink" title="如何正确的访问字体"></a>如何正确的访问字体</h5><p>​    C语言中，有一个著名的关键字叫extern，他随了汇编语言的关键字extern，在所属权层面上表达的同static完全相反，即这个资源的定义需要到其他文件中寻找。所以，当我们想要引用字体（这个字体被存放到了其他的C源文件中）的时候，只需要手动的extern一下，而且确保资源被正确的编译进来就OK了。</p>
<pre class="line-numbers language-none"><code class="language-none">extern const uint8_t ascii6x8_sources[][6];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h5 id="如何抽象字体"><a href="#如何抽象字体" class="headerlink" title="如何抽象字体"></a>如何抽象字体</h5><p>​    很简单，虽然说正常而言只需要抽象一个<code>TextFont</code>结构体即可，但是笔者认为这里更多看重的是方法，而且，没有必要对用户暴露一个Font结构体，选择结构体更加不如暴露的是一个枚举和公开的方法。</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef CCGraphic_TextConfig_H
#define CCGraphic_TextConfig_H
#include &quot;Graphic&#x2F;config&#x2F;CCGraphic_config.h&quot;
#include &quot;Graphic&#x2F;CCGraphic_common.h&quot;
#include &quot;Graphic&#x2F;widgets&#x2F;common&#x2F;CCGraphic_Size&#x2F;CCGraphic_Size.h&quot;
&#x2F;*
    current version we only support
    6x8 and 8x16. to register more, u should
    provide the source and implement the functions
*&#x2F;
typedef enum &#123;
#if ENABLE_ASCII_6x8_SOURCES
    ASCII_6x8,
#endif

#if ENABLE_ASCII_8x16_SOURCES
    ASCII_8x16,
#endif
    NO_ASCII_SIZE 
&#125;Ascii_Font_Size;

typedef enum &#123;
    Unicode_16x16
&#125;Unicode_Font_Size;

#define UNSUPPORTIVE_FONT_SOURCE    ((void*)0)

&#x2F;**
 * @brief Selects the font data array based on the specified font size.
 *
 * This function receives an &#96;Ascii_Font_Size&#96; value 
 * and returns a pointer to the corresponding font data array. 
 * The function helps in selecting
 * the appropriate font data for display purposes, allowing for different
 * font sizes (e.g., 8x16, 6x8, etc.).
 *
 * @param s The font size to be selected 
 *          (from the &#96;Ascii_Font_Size&#96; enum).
 * @param ch the character wanna display
 * @return  A pointer to the font data array corresponding to the selected font size.
 *          If an invalid font size is passed, 
 *          the function returns UNSUPPORTIVE_FONT_SOURCE.
 *&#x2F;
uint8_t*        __select_from_ascii_font_size(const Ascii_Font_Size s, const char ch);


CCGraphic_Size  __fetch_font_size(const Ascii_Font_Size s);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;widgets&#x2F;base&#x2F;CCGraphic_TextItem&#x2F;CCGraphic_TextConfig.h&quot;

extern const uint8_t ascii8x16_sources[][16];
extern const uint8_t ascii6x8_sources[][6];

uint8_t* __select_from_ascii_font_size(
    const Ascii_Font_Size s, const char ch)
&#123;
    switch(s)
    &#123;
#if ENABLE_ASCII_6x8_SOURCES
        case ASCII_6x8:
            return (uint8_t*)(ascii6x8_sources[ch - &#39; &#39;]);
#endif
#if ENABLE_ASCII_8x16_SOURCES       
        case ASCII_8x16:
            return (uint8_t*)(ascii8x16_sources[ch - &#39; &#39;]);
#endif
        &#x2F;* 
            To programmers, if new ascii like sources is
            registered, please implement follows
        *&#x2F;
        default:
            return UNSUPPORTIVE_FONT_SOURCE;
    &#125;
&#125;

CCGraphic_Size  __fetch_font_size(const Ascii_Font_Size s)
&#123;
    CCGraphic_Size size &#x3D; &#123;0, 0&#125;;
    switch(s)
    &#123;
#if ENABLE_ASCII_6x8_SOURCES
        case ASCII_6x8:
            size.height     &#x3D;   8;
            size.width      &#x3D;   6;
            break;
#endif

#if ENABLE_ASCII_8x16_SOURCES  
        case ASCII_8x16:
            size.height     &#x3D;   16;
            size.width      &#x3D;   8;
            break;
#endif
        default:
            break;
    &#125;
    return size;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>题外话：使用编译宏控制资源编译：GCC是一个智能的编译器，对于任何没有使用到的资源，概不参与编译，所以，对于使用GCC的编译器，只需要确保自己不额外使用其他资源，就不会将冗余的C符号纳入编译。</p>
<p>但还是那句话，为了确保语义更加清晰，仍然使用控制宏对资源进行编译控制和符号控制，让自己的代码语义更加的明确，是一件事半功倍的举措</p>
</blockquote>
<h5 id="如何绘制字符串"><a href="#如何绘制字符串" class="headerlink" title="如何绘制字符串"></a>如何绘制字符串</h5><p>​    绘制字符串是一个复杂的活。但是在那之前，把杂活做了。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;widgets&#x2F;base&#x2F;CCGraphic_TextItem&#x2F;CCGraphic_TextItem.h&quot;
#include &quot;Graphic&#x2F;widgets&#x2F;base&#x2F;CCGraphic_TextItem&#x2F;CCGraphic_TextConfig.h&quot;
#include &quot;Graphic&#x2F;widgets&#x2F;base&#x2F;CCGraphic_Image&#x2F;CCGraphic_Image.h&quot;
#include &quot;Graphic&#x2F;CCGraphic_device_adapter.h&quot;
#include &lt;string.h&gt;

&#x2F;**
 * 初始化一个ASCII文本项。
 * @param item 指向CCGraphic_AsciiTextItem的指针。
 * @param tl_point 文本项的左上角起始坐标。
 * @param textHandleSize 文本项的尺寸信息（宽度和高度）。
 * @param text_size 字体大小枚举类型。
 *&#x2F;
void CCGraphicWidget_init_AsciiTextItem(
    CCGraphic_AsciiTextItem* item,
    CCGraphic_Point tl_point,
    CCGraphic_Size textHandleSize,
    Ascii_Font_Size text_size
)
&#123;
    item-&gt;font_size &#x3D; text_size;
    item-&gt;sources_borrowed &#x3D; &quot;&quot;;  &#x2F;&#x2F; 初始化为空字符串，表示未设置内容。
    item-&gt;tl_point &#x3D; tl_point;
    item-&gt;indexed_point &#x3D; tl_point;
    item-&gt;TexthandleSize &#x3D; textHandleSize;
&#125;

&#x2F;**
 * 设置ASCII文本项的内容。
 * @param item 指向CCGraphic_AsciiTextItem的指针。
 * @param text 待设置的文本内容字符串。
 *&#x2F;
void CCGraphicWidget_AsciiTextItem_setAsciiText(
    CCGraphic_AsciiTextItem* item,
    char* text
)
&#123;
    item-&gt;sources_borrowed &#x3D; text;
&#125;

&#x2F;**
 * 设置ASCII文本项的索引点。
 * @param item 指向CCGraphic_AsciiTextItem的指针。
 * @param p 索引点的指针。
 *&#x2F;
void CCGraphicWidget_AsciiTextItem_setIndexedPoint(
    CCGraphic_AsciiTextItem* item,
    CCGraphic_Point* p
)
&#123;
    item-&gt;indexed_point &#x3D; *p;
&#125;

&#x2F;**
 * 重新定位ASCII文本项。
 * @param item 指向CCGraphic_AsciiTextItem的指针。
 * @param tl_point 新的左上角起始坐标。
 * @param textHandleSize 新的尺寸信息（宽度和高度）。
 *&#x2F;
void CCGraphicWidget_AsciiTextItem_relocate(
    CCGraphic_AsciiTextItem* item,
    CCGraphic_Point tl_point,
    CCGraphic_Size textHandleSize
)
&#123;
	&#x2F;&#x2F; 这个函数的一个重要的目的就是重定位文本框，为之后的文本显示做铺垫。
    item-&gt;tl_point &#x3D; tl_point;
    item-&gt;TexthandleSize &#x3D; textHandleSize;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    <strong>绘制一个字符串本身就是绘制一串字符</strong>，掌握整个原理，事情就会变得非常简单，我们线讨论如何绘制字符本身</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * 绘制ASCII字符到设备。
 * @param device_handle 设备句柄。
 * @param borrowing_image 临时用于绘制的图像对象。
 * @param ch 要绘制的字符。
 * @param size 字体大小枚举类型。
 *&#x2F;
static void __pvt_draw_char_each(
    CCDeviceHandler* device_handle, 
    CCGraphic_Image* borrowing_image, 
    const char ch, Ascii_Font_Size size
)
&#123;
    borrowing_image-&gt;image_size &#x3D; __fetch_font_size(size);
    uint8_t* ascii &#x3D; __select_from_ascii_font_size(size, ch);
    borrowing_image-&gt;sources_register &#x3D; ascii;
    CCGraphicWidget_draw_image(device_handle, borrowing_image);
#if CCGraphic_TextDebug
    device_handle-&gt;operations.update_device_function(device_handle);
#endif
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    我们将一个字符的字体绘制文件放置到Image中，<strong>所以我强调：字符是画出来的</strong>。</p>
<blockquote>
<p>设计缺陷：注意到，我这里并没有设置绘制的位置，这是因为这件事情在上层做好了，所以我也在参变量中警示自己：整个变量是部分初始化的。</p>
</blockquote>
<h5 id="绘制方案"><a href="#绘制方案" class="headerlink" title="绘制方案"></a>绘制方案</h5><p>​    我们绘制的时候，更多会去在乎：是在之前的文本基础上继续绘制呢？还是换一行继续绘制，还是直接清空文本重新绘制？为了防止反复的刷新，笔者设计了三个函数完成整个工作。</p>
<p>​    首先，设置游标点：</p>
<pre class="line-numbers language-none"><code class="language-none">CCGraphic_Point     indexed_point; 			&#x2F;&#x2F; 这个是现在的绘制指针，表明现在我们绘制到了那个地方<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    整个在Text的结构体中，不由用户直接设置。</p>
<p>​    下面，就是依赖设置：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * 判断当前字符是否需要换行。
 * @param device_handle 设备句柄。
 * @param brpoint 右下角边界点。
 * @param cur_draw_p 当前绘制点的指针。
 * @param s 字体大小枚举类型。
 * @return 如果需要换行，返回非零值；否则返回零。
 *&#x2F;
static uint8_t inline __pvt_should_be_next_line(
    CCDeviceHandler* device_handle,
    CCGraphic_Point* brpoint,
    CCGraphic_Point* cur_draw_p, Ascii_Font_Size s 
)
&#123;
    return cur_draw_p-&gt;x + 
        (int16_t)(1.5 * __fetch_font_size(s).width) &gt;&#x3D; brpoint-&gt;x;
&#125;
&#x2F;**
 * 计算有效的右下角点。
 * @param device_handle 设备句柄。
 * @param size 文本项的尺寸信息。
 * @param tl 文本项的左上角起始点。
 * @return 计算后的右下角点。
 *&#x2F;
static CCGraphic_Point inline __pvt_fetch_valid_final_point(
    CCDeviceHandler* device_handle,
    CCGraphic_Size* size, CCGraphic_Point* tl
) 
&#123;
    CCGraphic_Point br;
    int16_t device_width &#x3D; 0;
    device_handle-&gt;operations.property_function(
        device_handle, &amp;device_width, CommonProperty_WIDTH
    );
    int16_t device_height &#x3D; 0;
    device_handle-&gt;operations.property_function(
        device_handle, &amp;device_height, CommonProperty_HEIGHT
    );
    &#x2F;&#x2F; 上面我们获取了设备的宽高，现在我们开获取最大的合法右下角的点
    br.x &#x3D; tl-&gt;x + size-&gt;width;
    br.y &#x3D; tl-&gt;y + size-&gt;height;
    if(device_width &lt; br.x) &#123; br.x &#x3D; device_width; &#125;
    if(device_height &lt; br.y) &#123; br.y &#x3D; device_height; &#125;
    return br;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="文本绘制"><a href="#文本绘制" class="headerlink" title="文本绘制"></a>文本绘制</h5><p>​    绘制文本的本质是绘图。这一点务必注意。下面的整个函数实现了自动的文本换行！</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * 绘制ASCII文本项。
 * @param device_handle 设备句柄，用于控制绘制设备。
 * @param item 要绘制的ASCII文本项，包含文本内容、位置及尺寸信息。
 *&#x2F;
void CCGraphicWidget_drawAsciiTextItem(
    CCDeviceHandler* device_handle,
    CCGraphic_AsciiTextItem* item)
&#123;
    &#x2F;&#x2F; 如果文本内容为空，直接返回，不进行绘制。
    if(strcmp(item-&gt;sources_borrowed, &quot;&quot;) &#x3D;&#x3D; 0) &#123;
        return;
    &#125;

    &#x2F;&#x2F; 定义用于绘制的图像结构体。
    CCGraphic_Image handle_draw_image;

    &#x2F;&#x2F; 初始化绘制的起始点为当前索引位置。
    CCGraphic_Point draw_tl_point &#x3D; item-&gt;indexed_point;

    &#x2F;&#x2F; 获取当前文本字体的尺寸（宽度和高度）。
    const Ascii_Font_Size font_size &#x3D; item-&gt;font_size;
    const CCGraphic_Size size &#x3D; __fetch_font_size(font_size);
    const SizeBaseType font_width &#x3D; size.width;
    const SizeBaseType font_height &#x3D; size.height;

    &#x2F;&#x2F; 计算文本绘制区域的有效右下角点（即绘制边界）。
    CCGraphic_Point br &#x3D; __pvt_fetch_valid_final_point(
        device_handle, &amp;(item-&gt;TexthandleSize), &amp;(item-&gt;tl_point) 
    );

    &#x2F;&#x2F; 定义x方向和y方向的字符偏移量，用于逐字符定位绘制。
    uint8_t offseterx &#x3D; 0;
    uint8_t offsetery &#x3D; 0;

    &#x2F;&#x2F; 遍历文本中的每个字符并绘制。
    for(uint8_t i &#x3D; 0; item-&gt;sources_borrowed[i] !&#x3D; &#39;\0&#39;; i++) &#123;
        &#x2F;&#x2F; 计算当前字符的绘制位置。
        draw_tl_point.x &#x3D; item-&gt;indexed_point.x + offseterx * font_width;
        draw_tl_point.y &#x3D; item-&gt;indexed_point.y + offsetery * font_height;

        &#x2F;&#x2F; 设置图像绘制的左上角点。
        handle_draw_image.point &#x3D; draw_tl_point;

        &#x2F;&#x2F; 绘制当前字符到目标设备上。
        __pvt_draw_char_each(
            device_handle, 
            &amp;handle_draw_image, 
            item-&gt;sources_borrowed[i], 
            item-&gt;font_size
        );

        &#x2F;&#x2F; 判断是否需要换行绘制。
        if(__pvt_should_be_next_line(device_handle, &amp;br, &amp;draw_tl_point, font_size)) &#123;
            &#x2F;&#x2F; 如果需要换行，将x偏移量归零，并增加y方向的行数。
            offseterx &#x3D; 0;
            offsetery++;
            &#x2F;&#x2F; 重置x方向的起点位置为文本的左上角点。
            item-&gt;indexed_point.x &#x3D; item-&gt;tl_point.x;
        &#125; else &#123;
            &#x2F;&#x2F; 否则继续绘制当前行的下一个字符。
            offseterx++;
        &#125;
    &#125;

    &#x2F;&#x2F; 更新文本项的索引点位置为最后一个字符的右侧位置。
    item-&gt;indexed_point &#x3D; draw_tl_point;
    item-&gt;indexed_point.x +&#x3D; font_width;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="更加方便的绘制"><a href="#更加方便的绘制" class="headerlink" title="更加方便的绘制"></a>更加方便的绘制</h5><p>​    当然，还可以为了之后的组件方便生成一个返回绘制点的方便函数：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;**
 * 绘制ASCII文本项，并返回绘制后的点。
 * @param device_handle 设备句柄，用于控制绘制设备。
 * @param item 要绘制的ASCII文本项，包含文本内容、位置及尺寸信息。
 * @param method 文本追加方式，指示绘制后是否换行或连续追加。
 * @return 绘制后的坐标点，表示下一个绘制位置。
 *&#x2F;
CCGraphic_Point CCGraphicWidget_drawAsciiTextItem_with_finPoint(
    CCDeviceHandler* device_handle,
    CCGraphic_AsciiTextItem* item,
    AppendMethod method
)
&#123;
    &#x2F;&#x2F; 如果文本内容为空，直接返回文本的初始左上角点。
    if(strcmp(item-&gt;sources_borrowed, &quot;&quot;) &#x3D;&#x3D; 0) &#123;
        return item-&gt;tl_point;
    &#125;

    &#x2F;&#x2F; 定义绘制图像和绘制位置。
    CCGraphic_Image handle_draw_image;
    CCGraphic_Point draw_tl_point &#x3D; item-&gt;indexed_point;

    &#x2F;&#x2F; 获取字体尺寸。
    const Ascii_Font_Size font_size &#x3D; item-&gt;font_size;
    const CCGraphic_Size size &#x3D; __fetch_font_size(font_size);
    const SizeBaseType font_width &#x3D; size.width;
    const SizeBaseType font_height &#x3D; size.height;

    &#x2F;&#x2F; 获取有效绘制区域的右下角点。
    CCGraphic_Point br &#x3D; __pvt_fetch_valid_final_point(
        device_handle, &amp;(item-&gt;TexthandleSize), &amp;(item-&gt;tl_point) 
    );

    &#x2F;&#x2F; x方向和y方向的偏移量，用于字符定位。
    uint8_t offseterx &#x3D; 0;
    uint8_t offsetery &#x3D; 0;

    &#x2F;&#x2F; 遍历文本中的每个字符。
    for(uint8_t i &#x3D; 0; item-&gt;sources_borrowed[i] !&#x3D; &#39;\0&#39;; i++) &#123;
        &#x2F;&#x2F; 计算当前字符的绘制位置。
        draw_tl_point.x &#x3D; item-&gt;indexed_point.x + offseterx * font_width;
        draw_tl_point.y &#x3D; item-&gt;indexed_point.y + offsetery * font_height;

        &#x2F;&#x2F; 设置图像的绘制点。
        handle_draw_image.point &#x3D; draw_tl_point;

        &#x2F;&#x2F; 绘制当前字符。
        __pvt_draw_char_each(
            device_handle, 
            &amp;handle_draw_image, 
            item-&gt;sources_borrowed[i], 
            item-&gt;font_size
        );

        &#x2F;&#x2F; 判断是否需要换行绘制。
        if(__pvt_should_be_next_line(device_handle, &amp;br, &amp;draw_tl_point, font_size)) &#123;
            offseterx &#x3D; 0; &#x2F;&#x2F; x方向偏移归零
            offsetery++;   &#x2F;&#x2F; y方向增加一行
            item-&gt;indexed_point.x &#x3D; item-&gt;tl_point.x; &#x2F;&#x2F; 重置x起点
        &#125; else &#123;
            offseterx++; &#x2F;&#x2F; 继续绘制当前行的下一个字符
        &#125;
    &#125;

    &#x2F;&#x2F; 更新文本项的索引点为最后一个字符位置。
    item-&gt;indexed_point &#x3D; draw_tl_point;
    item-&gt;indexed_point.x +&#x3D; font_width;

    &#x2F;&#x2F; 根据文本追加方式调整返回的最终坐标点。
    switch(method) &#123;
        case CCGraphic_AsciiTextItem_AppendNextLine:
            &#x2F;&#x2F; 追加到下一行开始位置。
            draw_tl_point.x &#x3D; item-&gt;tl_point.x;
            draw_tl_point.y +&#x3D; font_height;
            break;
        case CCGraphic_AsciiTextItem_AppendContinously:
            &#x2F;&#x2F; 继续追加到同一行的下一个位置。
            draw_tl_point.x +&#x3D; font_width;
            break;
        default:
            break;
    &#125;

    &#x2F;&#x2F; 返回绘制完成后的坐标点。
    return draw_tl_point;
&#125;


&#x2F;**
 * 获取当前文本项的附加点（追加位置）。
 * @param item ASCII文本项。
 * @return 当前索引位置坐标点。
 *&#x2F;
CCGraphic_Point CCGraphicWidget_AsciiTextItem_on_append_point(CCGraphic_AsciiTextItem* item)
&#123;
    return item-&gt;indexed_point;
&#125;

&#x2F;**
 * 获取文本项换行后的新行起点。
 * @param item ASCII文本项。
 * @return 新行的起始坐标点。
 *&#x2F;
CCGraphic_Point CCGraphicWidget_AsciiTextItem_on_newLine_point(CCGraphic_AsciiTextItem* item)
&#123;
    CCGraphic_Point draw_tl_point;
    draw_tl_point.x &#x3D; item-&gt;tl_point.x;
    const CCGraphic_Size size &#x3D; __fetch_font_size(item-&gt;font_size);
    draw_tl_point.y &#x3D; item-&gt;indexed_point.y + size.height;
    return draw_tl_point;    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>为什么要给函数标记为inline</p>
<p>对于现代的编译器，inline只是起到了一种劝说的作用，他将调用转换为直接插入函数的汇编代码，节约了流水线刷新和代码跳转，这样来看，是一个不错的关键字，但是，一个过于庞大的函数标记为inline是一个无效的举措（几乎没有节约开销，所以编译器有的时候不会理睬，对于GCC，尝试使用force_inline标记符强制内联），现代的inline更加像是一种允许重复定义的关键字（因为他直接将汇编代码插入到了调用者上，符号直接被替换消失了）</p>
</blockquote>
<h2 id="字体附录"><a href="#字体附录" class="headerlink" title="字体附录"></a>字体附录</h2><p>或者，你可以访问Github地址：<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MCU_Libs/tree/main/OLED/library/Graphic/resources/default">MCU_Libs/OLED/library/Graphic/resources/default at main · Charliechen114514/MCU_Libs (github.com)</a></p>
<h3 id="ascii-6x8字体"><a href="#ascii-6x8字体" class="headerlink" title="ascii 6x8字体"></a>ascii 6x8字体</h3><pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;CCGraphic_common.h&quot;
#include &quot;Graphic&#x2F;config&#x2F;CCGraphic_config.h&quot;
&#x2F;&#x2F;  This is an array of font data for a 
&#x2F;&#x2F;  6x8 OLED display using 6x8 pixel font representation.
&#x2F;&#x2F;  Each character in this font set is defined by an 
&#x2F;&#x2F;  6x8 pixel matrix (8 pixels wide, 16 pixels high).

&#x2F;* 
    sources should be externed copy this for 
    the usage in application level
*&#x2F;

&#x2F;&#x2F; ---------------------------------------------
&#x2F;&#x2F; extern const uint8_t ascii6x8_sources[][6];
&#x2F;&#x2F; ---------------------------------------------
#if ENABLE_ASCII_6x8_SOURCES
const uint8_t ascii6x8_sources[][6] &#x3D; 
&#123;
    &#123;0x00,0x00,0x00,0x00,0x00,0x00&#125;, &#x2F;&#x2F; 0
    &#123;0x00,0x00,0x00,0x2F,0x00,0x00&#125;, &#x2F;&#x2F; ! 1
    &#123;0x00,0x00,0x07,0x00,0x07,0x00&#125;, &#x2F;&#x2F; &quot; 2
    &#123;0x00,0x14,0x7F,0x14,0x7F,0x14&#125;, &#x2F;&#x2F; # 3
    &#123;0x00,0x24,0x2A,0x7F,0x2A,0x12&#125;, &#x2F;&#x2F; $ 4
    &#123;0x00,0x23,0x13,0x08,0x64,0x62&#125;, &#x2F;&#x2F; % 5
    &#123;0x00,0x36,0x49,0x55,0x22,0x50&#125;, &#x2F;&#x2F; &amp; 6
    &#123;0x00,0x00,0x00,0x07,0x00,0x00&#125;, &#x2F;&#x2F; &#39; 7
    &#123;0x00,0x00,0x1C,0x22,0x41,0x00&#125;, &#x2F;&#x2F; ( 8
    &#123;0x00,0x00,0x41,0x22,0x1C,0x00&#125;, &#x2F;&#x2F; ) 9
    &#123;0x00,0x14,0x08,0x3E,0x08,0x14&#125;, &#x2F;&#x2F; * 10
    &#123;0x00,0x08,0x08,0x3E,0x08,0x08&#125;, &#x2F;&#x2F; + 11
    &#123;0x00,0x00,0x00,0xA0,0x60,0x00&#125;, &#x2F;&#x2F; , 12
    &#123;0x00,0x08,0x08,0x08,0x08,0x08&#125;, &#x2F;&#x2F; - 13
    &#123;0x00,0x00,0x60,0x60,0x00,0x00&#125;, &#x2F;&#x2F; . 14
    &#123;0x00,0x20,0x10,0x08,0x04,0x02&#125;, &#x2F;&#x2F; &#x2F; 15
    &#123;0x00,0x3E,0x51,0x49,0x45,0x3E&#125;, &#x2F;&#x2F; 0 16
    &#123;0x00,0x00,0x42,0x7F,0x40,0x00&#125;, &#x2F;&#x2F; 1 17
    &#123;0x00,0x42,0x61,0x51,0x49,0x46&#125;, &#x2F;&#x2F; 2 18
    &#123;0x00,0x21,0x41,0x45,0x4B,0x31&#125;, &#x2F;&#x2F; 3 19
    &#123;0x00,0x18,0x14,0x12,0x7F,0x10&#125;, &#x2F;&#x2F; 4 20
    &#123;0x00,0x27,0x45,0x45,0x45,0x39&#125;, &#x2F;&#x2F; 5 21
    &#123;0x00,0x3C,0x4A,0x49,0x49,0x30&#125;, &#x2F;&#x2F; 6 22
    &#123;0x00,0x01,0x71,0x09,0x05,0x03&#125;, &#x2F;&#x2F; 7 23
    &#123;0x00,0x36,0x49,0x49,0x49,0x36&#125;, &#x2F;&#x2F; 8 24
    &#123;0x00,0x06,0x49,0x49,0x29,0x1E&#125;, &#x2F;&#x2F; 9 25
    &#123;0x00,0x00,0x36,0x36,0x00,0x00&#125;, &#x2F;&#x2F; : 26
    &#123;0x00,0x00,0x56,0x36,0x00,0x00&#125;, &#x2F;&#x2F; ; 27
    &#123;0x00,0x08,0x14,0x22,0x41,0x00&#125;, &#x2F;&#x2F; &lt; 28
    &#123;0x00,0x14,0x14,0x14,0x14,0x14&#125;, &#x2F;&#x2F; &#x3D; 29
    &#123;0x00,0x00,0x41,0x22,0x14,0x08&#125;, &#x2F;&#x2F; &gt; 30
    &#123;0x00,0x02,0x01,0x51,0x09,0x06&#125;, &#x2F;&#x2F; ? 31
    &#123;0x00,0x3E,0x49,0x55,0x59,0x2E&#125;, &#x2F;&#x2F; @ 32
    &#123;0x00,0x7C,0x12,0x11,0x12,0x7C&#125;, &#x2F;&#x2F; A 33
    &#123;0x00,0x7F,0x49,0x49,0x49,0x36&#125;, &#x2F;&#x2F; B 34
    &#123;0x00,0x3E,0x41,0x41,0x41,0x22&#125;, &#x2F;&#x2F; C 35
    &#123;0x00,0x7F,0x41,0x41,0x22,0x1C&#125;, &#x2F;&#x2F; D 36
    &#123;0x00,0x7F,0x49,0x49,0x49,0x41&#125;, &#x2F;&#x2F; E 37
    &#123;0x00,0x7F,0x09,0x09,0x09,0x01&#125;, &#x2F;&#x2F; F 38
    &#123;0x00,0x3E,0x41,0x49,0x49,0x7A&#125;, &#x2F;&#x2F; G 39
    &#123;0x00,0x7F,0x08,0x08,0x08,0x7F&#125;, &#x2F;&#x2F; H 40
    &#123;0x00,0x00,0x41,0x7F,0x41,0x00&#125;, &#x2F;&#x2F; I 41
    &#123;0x00,0x20,0x40,0x41,0x3F,0x01&#125;, &#x2F;&#x2F; J 42
    &#123;0x00,0x7F,0x08,0x14,0x22,0x41&#125;, &#x2F;&#x2F; K 43
    &#123;0x00,0x7F,0x40,0x40,0x40,0x40&#125;, &#x2F;&#x2F; L 44
    &#123;0x00,0x7F,0x02,0x0C,0x02,0x7F&#125;, &#x2F;&#x2F; M 45
    &#123;0x00,0x7F,0x04,0x08,0x10,0x7F&#125;, &#x2F;&#x2F; N 46
    &#123;0x00,0x3E,0x41,0x41,0x41,0x3E&#125;, &#x2F;&#x2F; O 47
    &#123;0x00,0x7F,0x09,0x09,0x09,0x06&#125;, &#x2F;&#x2F; P 48
    &#123;0x00,0x3E,0x41,0x51,0x21,0x5E&#125;, &#x2F;&#x2F; Q 49
    &#123;0x00,0x7F,0x09,0x19,0x29,0x46&#125;, &#x2F;&#x2F; R 50
    &#123;0x00,0x46,0x49,0x49,0x49,0x31&#125;, &#x2F;&#x2F; S 51
    &#123;0x00,0x01,0x01,0x7F,0x01,0x01&#125;, &#x2F;&#x2F; T 52
    &#123;0x00,0x3F,0x40,0x40,0x40,0x3F&#125;, &#x2F;&#x2F; U 53
    &#123;0x00,0x1F,0x20,0x40,0x20,0x1F&#125;, &#x2F;&#x2F; V 54
    &#123;0x00,0x3F,0x40,0x38,0x40,0x3F&#125;, &#x2F;&#x2F; W 55
    &#123;0x00,0x63,0x14,0x08,0x14,0x63&#125;, &#x2F;&#x2F; X 56
    &#123;0x00,0x07,0x08,0x70,0x08,0x07&#125;, &#x2F;&#x2F; Y 57
    &#123;0x00,0x61,0x51,0x49,0x45,0x43&#125;, &#x2F;&#x2F; Z 58
    &#123;0x00,0x00,0x7F,0x41,0x41,0x00&#125;, &#x2F;&#x2F; [ 59
    &#123;0x00,0x02,0x04,0x08,0x10,0x20&#125;, &#x2F;&#x2F; \ 60
    &#123;0x00,0x00,0x41,0x41,0x7F,0x00&#125;, &#x2F;&#x2F; ] 61
    &#123;0x00,0x04,0x02,0x01,0x02,0x04&#125;, &#x2F;&#x2F; ^ 62
    &#123;0x00,0x40,0x40,0x40,0x40,0x40&#125;, &#x2F;&#x2F; _ 63
    &#123;0x00,0x00,0x01,0x02,0x04,0x00&#125;, &#x2F;&#x2F; &#96; 64
    &#123;0x00,0x20,0x54,0x54,0x54,0x78&#125;, &#x2F;&#x2F; a 65
    &#123;0x00,0x7F,0x48,0x44,0x44,0x38&#125;, &#x2F;&#x2F; b 66
    &#123;0x00,0x38,0x44,0x44,0x44,0x20&#125;, &#x2F;&#x2F; c 67
    &#123;0x00,0x38,0x44,0x44,0x48,0x7F&#125;, &#x2F;&#x2F; d 68
    &#123;0x00,0x38,0x54,0x54,0x54,0x18&#125;, &#x2F;&#x2F; e 69
    &#123;0x00,0x08,0x7E,0x09,0x01,0x02&#125;, &#x2F;&#x2F; f 70
    &#123;0x00,0x18,0xA4,0xA4,0xA4,0x7C&#125;, &#x2F;&#x2F; g 71
    &#123;0x00,0x7F,0x08,0x04,0x04,0x78&#125;, &#x2F;&#x2F; h 72
    &#123;0x00,0x00,0x44,0x7D,0x40,0x00&#125;, &#x2F;&#x2F; i 73
    &#123;0x00,0x40,0x80,0x84,0x7D,0x00&#125;, &#x2F;&#x2F; j 74
    &#123;0x00,0x7F,0x10,0x28,0x44,0x00&#125;, &#x2F;&#x2F; k 75
    &#123;0x00,0x00,0x41,0x7F,0x40,0x00&#125;, &#x2F;&#x2F; l 76
    &#123;0x00,0x7C,0x04,0x18,0x04,0x78&#125;, &#x2F;&#x2F; m 77
    &#123;0x00,0x7C,0x08,0x04,0x04,0x78&#125;, &#x2F;&#x2F; n 78
    &#123;0x00,0x38,0x44,0x44,0x44,0x38&#125;, &#x2F;&#x2F; o 79
    &#123;0x00,0xFC,0x24,0x24,0x24,0x18&#125;, &#x2F;&#x2F; p 80
    &#123;0x00,0x18,0x24,0x24,0x18,0xFC&#125;, &#x2F;&#x2F; q 81
    &#123;0x00,0x7C,0x08,0x04,0x04,0x08&#125;, &#x2F;&#x2F; r 82
    &#123;0x00,0x48,0x54,0x54,0x54,0x20&#125;, &#x2F;&#x2F; s 83
    &#123;0x00,0x04,0x3F,0x44,0x40,0x20&#125;, &#x2F;&#x2F; t 84
    &#123;0x00,0x3C,0x40,0x40,0x20,0x7C&#125;, &#x2F;&#x2F; u 85
    &#123;0x00,0x1C,0x20,0x40,0x20,0x1C&#125;, &#x2F;&#x2F; v 86
    &#123;0x00,0x3C,0x40,0x30,0x40,0x3C&#125;, &#x2F;&#x2F; w 87
    &#123;0x00,0x44,0x28,0x10,0x28,0x44&#125;, &#x2F;&#x2F; x 88
    &#123;0x00,0x1C,0xA0,0xA0,0xA0,0x7C&#125;, &#x2F;&#x2F; y 89
    &#123;0x00,0x44,0x64,0x54,0x4C,0x44&#125;, &#x2F;&#x2F; z 90
    &#123;0x00,0x00,0x08,0x7F,0x41,0x00&#125;, &#x2F;&#x2F; &#123; 91
    &#123;0x00,0x00,0x00,0x7F,0x00,0x00&#125;, &#x2F;&#x2F; | 92
    &#123;0x00,0x00,0x41,0x7F,0x08,0x00&#125;, &#x2F;&#x2F; &#125; 93
    &#123;0x00,0x08,0x04,0x08,0x10,0x08&#125;, &#x2F;&#x2F; ~ 94
&#125;;
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ascii-8-x-16字体"><a href="#ascii-8-x-16字体" class="headerlink" title="ascii 8 x 16字体"></a>ascii 8 x 16字体</h3><pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;CCGraphic_common.h&quot;
#include &quot;Graphic&#x2F;config&#x2F;CCGraphic_config.h&quot;
&#x2F;&#x2F;  This is an array of font data for a 
&#x2F;&#x2F;  8x16 OLED display using 8x16 pixel font representation.
&#x2F;&#x2F;  Each character in this font set is defined by an 
&#x2F;&#x2F;  8x16 pixel matrix (8 pixels wide, 16 pixels high).

&#x2F;* 
    sources should be externed copy this for 
    the usage in application level
*&#x2F;

&#x2F;&#x2F; ---------------------------------------------
&#x2F;&#x2F; extern const uint8_t ascii8x16_sources[][16];
&#x2F;&#x2F; ---------------------------------------------
#if ENABLE_ASCII_8x16_SOURCES
const uint8_t ascii8x16_sources[][16] &#x3D;
&#123;
	&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,&#x2F;&#x2F;   0
	&#123;0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00&#125;,&#x2F;&#x2F; ! 1
	&#123;0x00,0x16,0x0E,0x00,0x16,0x0E,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,&#x2F;&#x2F; &quot; 2
	&#123;0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,
	0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00&#125;,&#x2F;&#x2F; # 3
	&#123;0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,
	0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00&#125;,&#x2F;&#x2F; $ 4
	&#123;0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,
	0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00&#125;,&#x2F;&#x2F; % 5
	&#123;0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,
	0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10&#125;,&#x2F;&#x2F; &amp; 6
	&#123;0x00,0x00,0x00,0x16,0x0E,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,&#x2F;&#x2F; &#39; 7
	&#123;0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,
	0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00&#125;,&#x2F;&#x2F; ( 8
	&#123;0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,
	0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00&#125;,&#x2F;&#x2F; ) 9
	&#123;0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,
	0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00&#125;,&#x2F;&#x2F; * 10
	&#123;0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,
	0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00&#125;,&#x2F;&#x2F; + 11
	&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0xB0,0x70,0x00,0x00,0x00,0x00,0x00&#125;,&#x2F;&#x2F; , 12
	&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01&#125;,&#x2F;&#x2F; - 13
	&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00&#125;,&#x2F;&#x2F; . 14
	&#123;0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,
	0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00&#125;,&#x2F;&#x2F; &#x2F; 15
	&#123;0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,
	0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00&#125;,&#x2F;&#x2F; 0 16
	&#123;0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,&#x2F;&#x2F; 1 17
	&#123;0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,
	0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00&#125;,&#x2F;&#x2F; 2 18
	&#123;0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,
	0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00&#125;,&#x2F;&#x2F; 3 19
	&#123;0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,
	0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00&#125;,&#x2F;&#x2F; 4 20
	&#123;0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,
	0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00&#125;,&#x2F;&#x2F; 5 21
	&#123;0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,
	0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00&#125;,&#x2F;&#x2F; 6 22
	&#123;0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,
	0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00&#125;,&#x2F;&#x2F; 7 23
	&#123;0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,
	0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00&#125;,&#x2F;&#x2F; 8 24
	&#123;0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,
	0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00&#125;,&#x2F;&#x2F; 9 25
	&#123;0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,
	0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00&#125;,&#x2F;&#x2F; : 26
	&#123;0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,
	0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00&#125;,&#x2F;&#x2F; ; 27
	&#123;0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,
	0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00&#125;,&#x2F;&#x2F; &lt; 28
	&#123;0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,
	0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00&#125;,&#x2F;&#x2F; &#x3D; 29
	&#123;0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,
	0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00&#125;,&#x2F;&#x2F; &gt; 30
	&#123;0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,
	0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00&#125;,&#x2F;&#x2F; ? 31
	&#123;0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,
	0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00&#125;,&#x2F;&#x2F; @ 32
	&#123;0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,
	0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20&#125;,&#x2F;&#x2F; A 33
	&#123;0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,
	0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00&#125;,&#x2F;&#x2F; B 34
	&#123;0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,
	0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00&#125;,&#x2F;&#x2F; C 35
	&#123;0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,
	0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00&#125;,&#x2F;&#x2F; D 36
	&#123;0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,
	0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00&#125;,&#x2F;&#x2F; E 37
	&#123;0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,
	0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00&#125;,&#x2F;&#x2F; F 38
	&#123;0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,
	0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00&#125;,&#x2F;&#x2F; G 39
	&#123;0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,
	0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20&#125;,&#x2F;&#x2F; H 40
	&#123;0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,&#x2F;&#x2F; I 41
	&#123;0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,
	0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00&#125;,&#x2F;&#x2F; J 42
	&#123;0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,
	0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00&#125;,&#x2F;&#x2F; K 43
	&#123;0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,
	0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00&#125;,&#x2F;&#x2F; L 44
	&#123;0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,
	0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00&#125;,&#x2F;&#x2F; M 45
	&#123;0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,
	0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00&#125;,&#x2F;&#x2F; N 46
	&#123;0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,
	0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00&#125;,&#x2F;&#x2F; O 47
	&#123;0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,
	0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00&#125;,&#x2F;&#x2F; P 48
	&#123;0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,
	0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00&#125;,&#x2F;&#x2F; Q 49
	&#123;0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,
	0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20&#125;,&#x2F;&#x2F; R 50
	&#123;0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,
	0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00&#125;,&#x2F;&#x2F; S 51
	&#123;0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,
	0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00&#125;,&#x2F;&#x2F; T 52
	&#123;0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,
	0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00&#125;,&#x2F;&#x2F; U 53
	&#123;0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,
	0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00&#125;,&#x2F;&#x2F; V 54
	&#123;0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,
	0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00&#125;,&#x2F;&#x2F; W 55
	&#123;0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,
	0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20&#125;,&#x2F;&#x2F; X 56
	&#123;0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,
	0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00&#125;,&#x2F;&#x2F; Y 57
	&#123;0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,
	0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00&#125;,&#x2F;&#x2F; Z 58
	&#123;0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,
	0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00&#125;,&#x2F;&#x2F; [ 59
	&#123;0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00&#125;,&#x2F;&#x2F; \ 60
	&#123;0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,
	0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00&#125;,&#x2F;&#x2F; ] 61
	&#123;0x00,0x20,0x10,0x08,0x04,0x08,0x10,0x20,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,&#x2F;&#x2F; ^ 62
	&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80&#125;,&#x2F;&#x2F; _ 63
	&#123;0x00,0x02,0x04,0x08,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,&#x2F;&#x2F; &#96; 64
	&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,
	0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20&#125;,&#x2F;&#x2F; a 65
	&#123;0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,
	0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00&#125;,&#x2F;&#x2F; b 66
	&#123;0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,
	0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00&#125;,&#x2F;&#x2F; c 67
	&#123;0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,
	0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20&#125;,&#x2F;&#x2F; d 68
	&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,
	0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00&#125;,&#x2F;&#x2F; e 69
	&#123;0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,&#x2F;&#x2F; f 70
	&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,
	0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00&#125;,&#x2F;&#x2F; g 71
	&#123;0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,
	0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20&#125;,&#x2F;&#x2F; h 72
	&#123;0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,&#x2F;&#x2F; i 73
	&#123;0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,
	0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00&#125;,&#x2F;&#x2F; j 74
	&#123;0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,
	0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00&#125;,&#x2F;&#x2F; k 75
	&#123;0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,
	0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,&#x2F;&#x2F; l 76
	&#123;0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
	0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F&#125;,&#x2F;&#x2F; m 77
	&#123;0x00,0x80,0x80,0x00,0x80,0x80,0x00,0x00,
	0x00,0x20,0x3F,0x21,0x00,0x20,0x3F,0x20&#125;,&#x2F;&#x2F; n 78
	&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,
	0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00&#125;,&#x2F;&#x2F; o 79
	&#123;0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,
	0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00&#125;,&#x2F;&#x2F; p 80
	&#123;0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,
	0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80&#125;,&#x2F;&#x2F; q 81
	&#123;0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,
	0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00&#125;,&#x2F;&#x2F; r 82
	&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,
	0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00&#125;,&#x2F;&#x2F; s 83
	&#123;0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,
	0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00&#125;,&#x2F;&#x2F; t 84
	&#123;0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,
	0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20&#125;,&#x2F;&#x2F; u 85
	&#123;0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,
	0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00&#125;,&#x2F;&#x2F; v 86
	&#123;0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,
	0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00&#125;,&#x2F;&#x2F; w 87
	&#123;0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,
	0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00&#125;,&#x2F;&#x2F; x 88
	&#123;0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,
	0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00&#125;,&#x2F;&#x2F; y 89
	&#123;0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,
	0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00&#125;,&#x2F;&#x2F; z 90
	&#123;0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,
	0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40&#125;,&#x2F;&#x2F; &#123; 91
	&#123;0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00&#125;,&#x2F;&#x2F; | 92
	&#123;0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,
	0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00&#125;,&#x2F;&#x2F; &#125; 93
	&#123;0x00,0x80,0x40,0x40,0x80,0x00,0x00,0x80,
	0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00&#125;,&#x2F;&#x2F; ~ 94
&#125;;
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（动态菜单组件实现）"><a href="#从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（动态菜单组件实现）" class="headerlink" title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（动态菜单组件实现）"></a>从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（动态菜单组件实现）</h1><p>​    终于，我们来到了这个令人激动的部分了，现在，我们终于把所有的基础工作做好了，就差我们的动态组件了。</p>
<h2 id="面对对象C的程序设计（范例）"><a href="#面对对象C的程序设计（范例）" class="headerlink" title="面对对象C的程序设计（范例）"></a>面对对象C的程序设计（范例）</h2><p>​    我想，你可能使用过C++这门语言，他派生于C，但是最终的惯用编程范式又远远不同于C。尽管如此，C仍然可以按照一个相对变扭的方式完成面对对象的程序设计。这是因为在C语言本质上是过程化语言，没有直接的类和对象概念，因<strong>此面向对象设计需要通过结构体、函数指针等手段模拟实现。</strong></p>
<p>​    面对对象，首先讲究的就是把所有的目标看成对象。举个例子，现在我们来看看动态多级菜单这个东西，按照面对对象的设计思路。我们说面对对象它通过抽象和封装将数据与功能结合，形成具有特定属性和行为的对象。</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct &#123;
    int x;
    int y;
    void (*move)(struct Point*, int, int);
&#125; Point;

void movePoint(Point* p, int dx, int dy) &#123;
    p-&gt;x +&#x3D; dx;
    p-&gt;y +&#x3D; dy;
&#125;

int main() &#123;
    Point p &#x3D; &#123;0, 0, movePoint&#125;;
    p.move(&amp;p, 5, 3);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    这个就是一个将点看作对象的例子。</p>
<p>​    我们设计对象的时候，<strong>要思考对象能干什么，进一步的，才需要知道他需要有什么。</strong>这种方式可以辅助一个习惯于面对过程的朋友设计一个对象。</p>
<h2 id="面对对象C的程序设计（应用）"><a href="#面对对象C的程序设计（应用）" class="headerlink" title="面对对象C的程序设计（应用）"></a>面对对象C的程序设计（应用）</h2><p>​    我们现在把上面谈到的用一下。</p>
<ul>
<li>他能显示多级的文字菜单</li>
<li>他能将目前选中的文本区域进行反色</li>
<li>他能再切换选中文本的时候演示一个阻塞的动画（提示，笔者的框架没有做异步，这需要牵扯到中断，笔者不打算现在做）</li>
<li>如果一个子项存在子菜单，他能显示出来这个子菜单，然后还能返回去（怎么样触发进入和返回不是我们关心的，<strong>他能！</strong>）</li>
<li>他可以显示和隐藏我们的icon，为此，我们还需要注册接口。</li>
</ul>
<p>​    为了做到上面的事情，我们要想他要拥有什么。</p>
<ul>
<li>一个简略的文本编辑器，他能展示文字，我们菜单的文本绘制基本上依赖于这个文本编辑器</li>
<li>一个负责动画演示的结构体（对象），他能完成我们对“他能再切换选中文本的时候演示一个阻塞的动画”这个任务</li>
<li>一个菜单子项结构体数组，他维护了当前这个菜单子项的文本显示，是否有子菜单，甚至，还需要有callback行为的结构体数组（这个是额外任务，笔者没有做callback）</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">typedef void* CCgraphicWidgetBase;

&#x2F;* update requist functions *&#x2F;
typedef void(*Update)(CCgraphicWidgetBase);
typedef void(*Hide)(CCgraphicWidgetBase);
typedef void(*Show)(CCgraphicWidgetBase);


typedef struct&#123;
    Update      update;
    Hide        hide;
    Show        show;
&#125;CCGraphicWidgetCommonOperation;

typedef struct
&#123;
    CCGraphicWidgetCommonOperation  common;
    void (*switchToIndex)(CCGraphic_Menu*, uint8_t index);
    void (*enabled_showAnimations)(CCGraphic_Menu*, uint8_t enabled);
    void (*setIcon)(CCGraphic_Menu*, CCGraphic_Image* image, uint8_t size);
    void (*showIcon)(CCGraphic_Menu*);
    void (*hideIcon)(CCGraphic_Menu*);
    CCGraphic_Menu* (*enterSub)(CCGraphic_Menu*);
    CCGraphic_Menu* (*backParent)(CCGraphic_Menu*);
&#125;CCGraphic_MenuOperations;

typedef struct __CCGraphic_Menu&#123;
	&#x2F;&#x2F; 菜单项数组
    CCGraphic_MenuItem*         menuItemArrays;
    &#x2F;&#x2F; 菜单项数组个数
    uint8_t                     menuArraySize;
    
    &#x2F;&#x2F; 内部主控件
    CCGraphicTextEdit*          internelTextEdit;
    &#x2F;&#x2F; 动画负责的结构体
    CCGraphic_MenuAnimations*   animation_holder;
    &#x2F;&#x2F; 操作
    CCGraphic_MenuOperations    operations;
    &#x2F;&#x2F; 当前维护的其他信息
    uint8_t                     current_offset;
    uint8_t                     enabled_animations;
    CCGraphic_Image*            icons_sources;
    uint8_t                     icon_size;
    uint8_t                     icon_state;
&#125;CCGraphic_Menu;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>任务：你可以改进这个抽象！你可以看到零碎一地的变量成员不太美观！</p>
</blockquote>
<h2 id="进一步谈论我上面给出的代码——继承"><a href="#进一步谈论我上面给出的代码——继承" class="headerlink" title="进一步谈论我上面给出的代码——继承"></a>进一步谈论我上面给出的代码——继承</h2><p>​    让我们进一步讨论更多的概念，上面的代码出现了一个很有意思的片段</p>
<pre class="line-numbers language-none"><code class="language-none">typedef void* CCgraphicWidgetBase;

&#x2F;* update requist functions *&#x2F;
typedef void(*Update)(CCgraphicWidgetBase);
typedef void(*Hide)(CCgraphicWidgetBase);
typedef void(*Show)(CCgraphicWidgetBase);


typedef struct&#123;
    Update      update;
    Hide        hide;
    Show        show;
&#125;CCGraphicWidgetCommonOperation;

typedef struct
&#123;
    CCGraphicWidgetCommonOperation  common;
    void (*switchToIndex)(CCGraphic_Menu*, uint8_t index);
    void (*enabled_showAnimations)(CCGraphic_Menu*, uint8_t enabled);
    void (*setIcon)(CCGraphic_Menu*, CCGraphic_Image* image, uint8_t size);
    void (*showIcon)(CCGraphic_Menu*);
    void (*hideIcon)(CCGraphic_Menu*);
    CCGraphic_Menu* (*enterSub)(CCGraphic_Menu*);
    CCGraphic_Menu* (*backParent)(CCGraphic_Menu*);
&#125;CCGraphic_MenuOperations;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    仔细研究一下，你会发现，我们似乎复用了一个结构体：CCGraphicWidgetCommonOperation，也就是组件Widget的通用操作。为了理解这个特征，我们先不着急，实现一个完全面对对象的，一个简单的文本编辑器</p>
<h3 id="实现一个面对对象的文本编辑器"><a href="#实现一个面对对象的文本编辑器" class="headerlink" title="实现一个面对对象的文本编辑器"></a>实现一个面对对象的文本编辑器</h3><pre class="line-numbers language-none"><code class="language-none">#ifndef CCGraphic_TextEdit_H
#define CCGraphic_TextEdit_H
#include &quot;Graphic&#x2F;widgets&#x2F;common&#x2F;CCGraphic_WidgetBase.h&quot;
#include &quot;Graphic&#x2F;base&#x2F;CCGraphic_Point&#x2F;CCGraphic_Point.h&quot;
#include &quot;Graphic&#x2F;widgets&#x2F;common&#x2F;CCGraphic_Size&#x2F;CCGraphic_Size.h&quot;
#include &quot;Graphic&#x2F;widgets&#x2F;common&#x2F;CCGraphic_WidgetBase.h&quot;
#include &quot;Graphic&#x2F;widgets&#x2F;base&#x2F;CCGraphic_TextItem&#x2F;CCGraphic_TextItem.h&quot;
#include &quot;Graphic&#x2F;widgets&#x2F;base&#x2F;CCGraphic_TextItem&#x2F;CCGraphic_TextConfig.h&quot;
typedef struct __CCGraphicTextEdit CCGraphicTextEdit;  
&#x2F;&#x2F; 前向声明：定义一个名为 &#96;CCGraphicTextEdit&#96; 的结构体类型。  

typedef struct &#123;  
    CCGraphicWidgetCommonOperation operation;  
    &#x2F;&#x2F; 控件通用操作，提供基本控件功能。  

    void (*appendText)(CCGraphicTextEdit*, char* appendee);  
    &#x2F;&#x2F; 函数指针：向文本控件追加文本。  

    void (*setText)(CCGraphicTextEdit*, char* text);  
    &#x2F;&#x2F; 函数指针：设置控件内的完整文本内容。  

    void (*newLineText)(CCGraphicTextEdit*, char* text);  
    &#x2F;&#x2F; 函数指针：在控件中新起一行并写入文本。  

    void (*clear)(CCGraphicTextEdit*);  
    &#x2F;&#x2F; 函数指针：清空控件中的文本。  

    void (*relocate)(CCGraphicTextEdit*, CCGraphic_Point p, CCGraphic_Size size);  
    &#x2F;&#x2F; 函数指针：重新定位控件位置并调整控件尺寸。  

&#125; CCGraphicTextEdit_SupportiveOperations;  
&#x2F;&#x2F; 结构体 &#96;CCGraphicTextEdit_SupportiveOperations&#96;：定义文本控件支持的操作集合。  

typedef struct __CCGraphicTextEdit &#123;  
    uint8_t acquired_stepped_update;  
    &#x2F;&#x2F; 标记是否启用分步更新机制的标志变量。  

    CCDeviceHandler* borrowed_device;  
    &#x2F;&#x2F; 设备处理器指针，用于管理外部设备资源。  

    CCGraphicTextEdit_SupportiveOperations operations;  
    &#x2F;&#x2F; 文本控件支持操作的集合。  

    CCGraphic_AsciiTextItem* handle;  
    &#x2F;&#x2F; 控件中的具体文本项句柄，用于操作字符显示内容。  

&#125; CCGraphicTextEdit;  
&#x2F;&#x2F; 结构体 &#96;CCGraphicTextEdit&#96;：定义文本控件的属性与操作。  

void CCGraphic_init_CCGraphicTextEdit(  
    CCGraphicTextEdit* text_self,  
    CCDeviceHandler* handler,  
    CCGraphic_AsciiTextItem* inited  
);  
&#x2F;&#x2F; 函数声明：初始化 &#96;CCGraphicTextEdit&#96; 控件，传入控件对象、设备处理器和已初始化的文本项。  
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    你可能会问，怎么看起来这么奇怪，我们应该如何调用功能呢？你看，这就是思维没有转变过来，笔者想要说的是，现在功能被集成进入了结构体，意味着，我们想要调用的不叫函数了，是一个结构体的方法。</p>
<pre class="line-numbers language-none"><code class="language-none">static void __helper_on_set_text(CCGraphicTextEdit* edit, char* sources, uint32_t shown_time)
&#123;
    edit-&gt;operations.setText(edit, sources);
    HAL_Delay(shown_time * 1000);
    edit-&gt;operations.clear(edit);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    看到了吗？当我们想要设置文本的时候，不是</p>
<pre class="line-numbers language-none"><code class="language-none">CCGraphicTextEdit_setText(edit, sources);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    而是</p>
<pre class="line-numbers language-none"><code class="language-none">edit-&gt;operations.setText(edit, sources);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    看起来好像没什么区别，我想说的是，你现在不知道，<strong>也没法去引用一个函数，叫“给一个是CCGraphicTextEdit的结构体设置文本”的函数，你找不到</strong>，我藏起来了（笑），而是，<strong>一个属于CCGraphicTextEdit这个类的对象可以被设置文本，文本是sources</strong>，这就是面对对象的设计思考范式。换而言之，<strong>一个CCGraphicTextEdit的对象可以设置文本，他能设置文本而且优先的投射到绘图设备上，而你完全不知道底下发生了什么，只知道这样做一定没有问题！</strong></p>
<p>​    在源文件中，我们才将如何实现暴露出来</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Graphic&#x2F;widgets&#x2F;components&#x2F;CCGraphic_TextEdit&#x2F;CCGraphic_TextEdit.h&quot;
#include &quot;Graphic&#x2F;widgets&#x2F;base&#x2F;CCGraphic_TextItem&#x2F;CCGraphic_TextItem.h&quot;
#include &quot;Graphic&#x2F;CCGraphic_device_adapter.h&quot;

static void __pvt_update_text(CCGraphicTextEdit* text_self)  
&#x2F;&#x2F; 静态函数：更新控件所依赖的设备内容。  
&#123;
    text_self-&gt;borrowed_device-&gt;operations.update_device_function(
        text_self-&gt;borrowed_device  
        &#x2F;&#x2F; 调用设备的更新函数，使文本控件的内容刷新显示。  
    );
&#125;

static void __pvt_show(CCGraphicTextEdit* text_self)  
&#x2F;&#x2F; 静态函数：绘制并显示文本控件内容。  
&#123;
    CCGraphicWidget_drawAsciiTextItem(
        text_self-&gt;borrowed_device, text_self-&gt;handle  
        &#x2F;&#x2F; 绘制文本控件的内容。  
    );
    if(text_self-&gt;acquired_stepped_update)  
        &#x2F;&#x2F; 如果启用了分步更新，则执行设备更新。  
        __pvt_update_text(text_self);
&#125;

static void __pvt_hide(CCGraphicTextEdit* text_self)  
&#x2F;&#x2F; 静态函数：隐藏控件，即清除其显示区域。  
&#123;
    text_self-&gt;borrowed_device-&gt;operations.clearArea_function(
        text_self-&gt;borrowed_device, 
        text_self-&gt;handle-&gt;tl_point.x,  
        text_self-&gt;handle-&gt;tl_point.y,  
        text_self-&gt;handle-&gt;TexthandleSize.width,  
        text_self-&gt;handle-&gt;TexthandleSize.height  
        &#x2F;&#x2F; 清除控件所在区域的内容。  
    );
    __pvt_update_text(text_self);
&#125;

static void __pvt_clear_text(CCGraphicTextEdit* text_self)  
&#x2F;&#x2F; 静态函数：清除控件中的文本内容。  
&#123;
    CCGraphic_Point tl &#x3D; text_self-&gt;handle-&gt;tl_point;  
    CCGraphic_Size size &#x3D; text_self-&gt;handle-&gt;TexthandleSize;  
    &#x2F;&#x2F; 获取控件左上角坐标和尺寸，用于清除操作。  

    text_self-&gt;borrowed_device-&gt;operations.clearArea_function(
        text_self-&gt;borrowed_device, tl.x, tl.y, size.width, size.height  
        &#x2F;&#x2F; 执行清除操作。  
    );
    __pvt_update_text(text_self);
&#125;

static void __pvt_append_text(CCGraphicTextEdit* text_self, char* text)  
&#x2F;&#x2F; 静态函数：向控件追加文本。  
&#123;
    CCGraphicWidget_AsciiTextItem_setAsciiText(text_self-&gt;handle, text);  
    &#x2F;&#x2F; 设置追加的文本内容。  
    __pvt_show(text_self);  
    &#x2F;&#x2F; 显示控件内容。  
&#125;

static void __pvt_newLine_text(CCGraphicTextEdit* text_self, char* text)  
&#x2F;&#x2F; 静态函数：在控件中新建一行并写入文本。  
&#123;
    CCGraphic_Point new_begin &#x3D;  
        CCGraphicWidget_AsciiTextItem_on_newLine_point(text_self-&gt;handle);  
    &#x2F;&#x2F; 获取新行起始点坐标。  

    CCGraphicWidget_AsciiTextItem_setAsciiText(text_self-&gt;handle, text);  
    &#x2F;&#x2F; 设置文本内容。  

    CCGraphicWidget_AsciiTextItem_setIndexedPoint(text_self-&gt;handle, &amp;new_begin);  
    &#x2F;&#x2F; 更新文本项的绘制位置。  

    __pvt_show(text_self);  
    &#x2F;&#x2F; 显示控件内容。  
&#125;

static void __pvt_setText(CCGraphicTextEdit* text_self, char* text)  
&#x2F;&#x2F; 静态函数：设置控件的完整文本内容。  
&#123;
    __pvt_clear_text(text_self);  
    &#x2F;&#x2F; 清除原有内容。  

    CCGraphicWidget_AsciiTextItem_setIndexedPoint(
        text_self-&gt;handle, 
        &amp;(text_self-&gt;handle-&gt;tl_point)  
        &#x2F;&#x2F; 重置文本绘制位置为控件起点。  
    );

    CCGraphicWidget_AsciiTextItem_setAsciiText(text_self-&gt;handle, text);  
    &#x2F;&#x2F; 设置新的文本内容。  

    __pvt_show(text_self);  
    &#x2F;&#x2F; 显示控件内容。  
&#125;

static void __pvt_relocate(CCGraphicTextEdit* edit, CCGraphic_Point p, CCGraphic_Size size)  
&#x2F;&#x2F; 静态函数：重新定位控件位置并调整尺寸。  
&#123;
    __pvt_hide(edit);  
    &#x2F;&#x2F; 隐藏控件内容。  

    CCGraphicWidget_AsciiTextItem_relocate(edit-&gt;handle, p, size);  
    &#x2F;&#x2F; 重新设置控件位置和尺寸。  
&#125;

void CCGraphic_init_CCGraphicTextEdit(  
    CCGraphicTextEdit* text_self,  
    CCDeviceHandler* handler,  
    CCGraphic_AsciiTextItem* inited  
)  
&#x2F;&#x2F; 初始化函数：设置文本编辑控件的初始状态。  
&#123;
    text_self-&gt;acquired_stepped_update &#x3D; 0;  
    &#x2F;&#x2F; 初始化为未启用分步更新。  

    text_self-&gt;borrowed_device &#x3D; handler;  
    &#x2F;&#x2F; 绑定设备处理器。  

    text_self-&gt;handle &#x3D; inited;  
    &#x2F;&#x2F; 设置文本项句柄。  

    text_self-&gt;operations.appendText &#x3D; __pvt_append_text;  
    text_self-&gt;operations.clear &#x3D; __pvt_clear_text;  
    text_self-&gt;operations.newLineText &#x3D; __pvt_newLine_text;  
    text_self-&gt;operations.setText &#x3D; __pvt_setText;  
    text_self-&gt;operations.relocate &#x3D; __pvt_relocate;  
    &#x2F;&#x2F; 绑定控件的各类操作函数。  

    text_self-&gt;operations.operation.hide &#x3D; (Hide)__pvt_hide;  
    text_self-&gt;operations.operation.show &#x3D; (Show)__pvt_show;  
    text_self-&gt;operations.operation.update &#x3D; (Update)__pvt_update_text;  
    &#x2F;&#x2F; 绑定通用控件操作。  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    可以看到，代码被分成了一层一层的，关心哪一个方法，只需要进入对应的方法查看即可。</p>
<h3 id="所以，什么是继承"><a href="#所以，什么是继承" class="headerlink" title="所以，什么是继承"></a>所以，什么是继承</h3><p>​    <strong>继承</strong>允许一个类从另一个类中获取属性和方法，从而实现代码复用和逻辑扩展。也就是说，我们认为继承表达了“一个对象是另一个对象”的陈述。比如说。</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct &#123;  
    CCGraphicWidgetCommonOperation operation;  
    &#x2F;&#x2F; 控件通用操作，提供基本控件功能。  

    void (*appendText)(CCGraphicTextEdit*, char* appendee);  
    &#x2F;&#x2F; 函数指针：向文本控件追加文本。  

    void (*setText)(CCGraphicTextEdit*, char* text);  
    &#x2F;&#x2F; 函数指针：设置控件内的完整文本内容。  

    void (*newLineText)(CCGraphicTextEdit*, char* text);  
    &#x2F;&#x2F; 函数指针：在控件中新起一行并写入文本。  

    void (*clear)(CCGraphicTextEdit*);  
    &#x2F;&#x2F; 函数指针：清空控件中的文本。  

    void (*relocate)(CCGraphicTextEdit*, CCGraphic_Point p, CCGraphic_Size size);  
    &#x2F;&#x2F; 函数指针：重新定位控件位置并调整控件尺寸。  

&#125; CCGraphicTextEdit_SupportiveOperations;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    表达了CCGraphicTextEdit的功能集合是CCGraphicWidget的一个超集，他不光拥有一个Widget该有的操作，而且，还有自己跟Widget独有的操作，这就是继承的力量——复用接口，甚至可以是实现！</p>
<h2 id="重申我们对菜单的抽象"><a href="#重申我们对菜单的抽象" class="headerlink" title="重申我们对菜单的抽象"></a>重申我们对菜单的抽象</h2><p>​    根据最之前的描述，菜单本身应该是一个树状的结构，你可以看到：</p>
<h3 id="抽象菜单项目"><a href="#抽象菜单项目" class="headerlink" title="抽象菜单项目"></a>抽象菜单项目</h3><pre class="line-numbers language-none"><code class="language-none">#ifndef CCGraphic_MenuItem_H
#define CCGraphic_MenuItem_H
#include &quot;Graphic&#x2F;CCGraphic_common.h&quot;
&#x2F;* This version we use simple menu Item *&#x2F;

&#x2F;* announced the menu type for the further usage *&#x2F;  
&#x2F;&#x2F; 预声明 &#96;CCGraphic_Menu&#96; 类型，用于菜单关联。  

typedef struct __CCGraphic_Menu CCGraphic_Menu;  
&#x2F;&#x2F; 结构体 &#96;CCGraphic_Menu&#96; 的前向声明，以便在结构中使用指针引用该类型。  

#define NO_SUB_MENU (NULL)  
&#x2F;&#x2F; 定义宏 &#96;NO_SUB_MENU&#96; 表示没有子菜单，为空指针。  

typedef struct __CCGraphic_MenuItem &#123;  
    char* text;  
    &#x2F;&#x2F; 菜单项显示的文本内容。  

    CCGraphic_Menu* subMenu;  
    &#x2F;&#x2F; 指向子菜单的指针，若无子菜单则为 &#96;NO_SUB_MENU&#96;。  

    CCGraphic_Menu* parentMenu;  
    &#x2F;&#x2F; 指向父菜单的指针，用于返回或层级控制。  
&#125; CCGraphic_MenuItem;  
&#x2F;&#x2F; 定义菜单项结构体 &#96;CCGraphic_MenuItem&#96;，包含菜单文字、子菜单及父菜单指针。  

void CCGraphic_MenuItem_register_menuItem(  
    CCGraphic_MenuItem* item,  
    &#x2F;&#x2F; 菜单项指针，用于注册菜单项。  

    CCGraphic_Menu* parentMenu,  
    &#x2F;&#x2F; 父菜单指针，将菜单项附加到此菜单下。  

    char* text,  
    &#x2F;&#x2F; 菜单项文本内容。  

    CCGraphic_Menu* subMenu  
    &#x2F;&#x2F; 子菜单指针，可为 &#96;NO_SUB_MENU&#96;。  
);  
&#x2F;&#x2F; 函数声明：将菜单项注册到指定父菜单下，同时设置菜单项文本和子菜单。  
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>提示：需要做callback?（用户明确选择了这个菜单项目）试一下在CCGraphic_MenuItem中添加抽象！完成你的代码！</p>
</blockquote>
<h3 id="抽象菜单动画"><a href="#抽象菜单动画" class="headerlink" title="抽象菜单动画"></a>抽象菜单动画</h3><pre class="line-numbers language-none"><code class="language-none">typedef struct __CCGraphic_MenuAnimations CCGraphic_MenuAnimations;  
&#x2F;&#x2F; 前向声明 &#96;CCGraphic_MenuAnimations&#96; 结构体，表示菜单动画的管理结构。  

typedef void (*DoByStep)(CCGraphic_MenuAnimations*);  
&#x2F;&#x2F; 定义一个函数指针类型 &#96;DoByStep&#96;，指向以 &#96;CCGraphic_MenuAnimations*&#96; 为参数的函数，
&#x2F;&#x2F; 该函数用于执行逐步动画操作。  

typedef struct &#123;  
    DoByStep doByStep;  
    &#x2F;&#x2F; 操作结构体，包含逐步执行动画的函数指针。  
&#125; CCGraphic_MenuAnimationsOperations;  
&#x2F;&#x2F; 定义 &#96;CCGraphic_MenuAnimationsOperations&#96; 结构体，封装了逐步动画执行的操作。  

&#x2F;*
    this struct shouldn&#39;t be registered by programmers
    it shoule be registered by program, so no interface is
    publiced!
*&#x2F;  
&#x2F;&#x2F; 该结构体不应由程序员手动注册，而是由程序自动注册，因此没有提供公开接口。  

typedef struct __CCGraphic_MenuAnimations &#123;  
    &#x2F;* animating rectangle *&#x2F;  
    &#x2F;&#x2F; 定义菜单动画的结构体。  

    CCDeviceHandler* handler;  
    &#x2F;&#x2F; 设备处理器，用于控制设备的操作。  

    CCGraphic_Point tl_point;  
    &#x2F;&#x2F; 动画的起始点（左上角坐标）。  

    CCGraphic_Size animationOffsetSize;  
    &#x2F;&#x2F; 动画的偏移尺寸，用于表示动画区域的大小。  

    int16_t x_step;  
    &#x2F;&#x2F; x轴每步移动的像素值，用于控制动画的水平位移。  

    int16_t y_step;  
    &#x2F;&#x2F; y轴每步移动的像素值，用于控制动画的垂直位移。  

    CCGraphic_MenuAnimationsOperations op;  
    &#x2F;&#x2F; 操作对象，包含执行逐步动画的函数指针。  

    uint8_t is_doing;  
    &#x2F;&#x2F; 标志位，表示动画是否正在进行中。  
&#125; CCGraphic_MenuAnimations;  
&#x2F;&#x2F; 定义菜单动画结构体，封装了动画的状态、操作及设备控制。  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    初始化一个动画的办法是：</p>
<pre class="line-numbers language-none"><code class="language-none">static void __pvt_init_animations(  
    CCGraphic_Menu*             menu,  
    CCGraphic_MenuAnimations*   animations  
) &#123;  
    &#x2F;* no animations are registered *&#x2F;  
    &#x2F;&#x2F; 如果没有提供动画对象，直接返回。  
    if (animations &#x3D;&#x3D; NULL) &#123;  
        return;  
    &#125;

    &#x2F;&#x2F; 获取菜单中的文本编辑项句柄，进行后续动画初始化。  
    CCGraphic_AsciiTextItem* internelTextEdit &#x3D; menu-&gt;internelTextEdit-&gt;handle;  

    &#x2F;* calculate the animations holding size *&#x2F;  
    &#x2F;&#x2F; 计算动画的大小，首先设置动画起始点为文本编辑项的起始点。  
    animations-&gt;tl_point &#x3D; internelTextEdit-&gt;tl_point;  

    &#x2F;&#x2F; 设置动画的高度为字体的大小（通过 &#96;__fetch_font_size&#96; 获取字体的高度）。  
    animations-&gt;animationOffsetSize.height &#x3D; __fetch_font_size(internelTextEdit-&gt;font_size).height;  

    &#x2F;&#x2F; 设置动画的宽度为文本处理器的宽度。  
    animations-&gt;animationOffsetSize.width &#x3D; internelTextEdit-&gt;TexthandleSize.width;  

    &#x2F;&#x2F; 设置设备处理器，使用菜单中的文本编辑项借用的设备。  
    animations-&gt;handler &#x3D; menu-&gt;internelTextEdit-&gt;borrowed_device;  

    &#x2F;&#x2F; 设置每步的水平和垂直步长（默认值）。  
    animations-&gt;x_step &#x3D; _DEFAULT_X_STEP;  
    animations-&gt;y_step &#x3D; _DEFAULT_Y_STEP;  

    &#x2F;&#x2F; 设置执行逐步动画操作的函数指针，指向 &#96;__pvt_doByStep&#96; 函数。  
    animations-&gt;op.doByStep &#x3D; __pvt_doByStep;  

    &#x2F;* set state *&#x2F;  
    &#x2F;&#x2F; 设置动画状态为未开始。  
    animations-&gt;is_doing &#x3D; 0;  
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    对于逐步开始动画的办法是</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* do by steps *&#x2F;
static void __pvt_doByStep(CCGraphic_MenuAnimations* animations)  
&#123;  
    &#x2F;&#x2F; 如果动画尚未开始（is_doing 为 0），则直接返回，避免不必要的操作。  
    if (!animations-&gt;is_doing) return;  

    &#x2F;&#x2F; 使用设备的操作对象反转（擦除）动画区域，传入当前动画的起始位置（tl_point）和尺寸。  
    animations-&gt;handler-&gt;operations.reverseArea_function(  
        animations-&gt;handler,  
        animations-&gt;tl_point.x, animations-&gt;tl_point.y,  
        animations-&gt;animationOffsetSize.width,  
        animations-&gt;animationOffsetSize.height  
    );  

    &#x2F;&#x2F; 更新动画的起始点（左上角坐标），按水平步长（x_step）和垂直步长（y_step）更新。  
    animations-&gt;tl_point.x +&#x3D; animations-&gt;x_step;  
    animations-&gt;tl_point.y +&#x3D; animations-&gt;y_step;  

    &#x2F;&#x2F; 再次调用反转（擦除）区域，传入更新后的动画位置和尺寸。  
    animations-&gt;handler-&gt;operations.reverseArea_function(  
        animations-&gt;handler,  
        animations-&gt;tl_point.x, animations-&gt;tl_point.y,  
        animations-&gt;animationOffsetSize.width,  
        animations-&gt;animationOffsetSize.height  
    );  

    &#x2F;&#x2F; 调用更新设备函数，刷新屏幕以显示动画效果。  
    animations-&gt;handler-&gt;operations.update_device_function(  
        animations-&gt;handler  
    );  
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    看到了吗，非必要不调用刷新设备的操作就在这里体现了。当然，当我们配置不需要动画的时候</p>
<pre class="line-numbers language-none"><code class="language-none">static void __pvt_do_as_immediate(
    CCGraphic_MenuAnimations* animations, 
    CCGraphic_Point*        end_tpl)
&#123;
    if(!animations-&gt;is_doing) return;
    animations-&gt;handler-&gt;operations.reverseArea_function(
        animations-&gt;handler, 
        animations-&gt;tl_point.x, animations-&gt;tl_point.y,
        animations-&gt;animationOffsetSize.width, 
        animations-&gt;animationOffsetSize.height
    );
    animations-&gt;tl_point &#x3D; *end_tpl;
    animations-&gt;handler-&gt;operations.reverseArea_function(
        animations-&gt;handler, 
        animations-&gt;tl_point.x, animations-&gt;tl_point.y,
        animations-&gt;animationOffsetSize.width, 
        animations-&gt;animationOffsetSize.height
    );
    animations-&gt;handler-&gt;operations.update_device_function(
        animations-&gt;handler);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    直接拉到最后就好了。</p>
<h3 id="实现菜单功能"><a href="#实现菜单功能" class="headerlink" title="实现菜单功能"></a>实现菜单功能</h3><p>​    到了真正实现的时候，一切反而水到渠成。</p>
<h4 id="初始化我们的菜单"><a href="#初始化我们的菜单" class="headerlink" title="初始化我们的菜单"></a>初始化我们的菜单</h4><pre class="line-numbers language-none"><code class="language-none">void CCGraphic_init_Menu(
    CCGraphic_Menu*             blank_menu,
    CCGraphic_MenuItem*         menuItemArrays,
    uint8_t                     menuArraySize,
    CCGraphicTextEdit*          configured_menu,
    CCGraphic_MenuAnimations*   blank_animations,
    uint8_t                     enabled_animations 
)
&#123;
    blank_menu-&gt;internelTextEdit    &#x3D; configured_menu;
    blank_menu-&gt;menuItemArrays      &#x3D; menuItemArrays;
    blank_menu-&gt;menuArraySize       &#x3D; menuArraySize;
    blank_menu-&gt;animation_holder    &#x3D; blank_animations;
    blank_menu-&gt;current_offset      &#x3D; 0;
    blank_menu-&gt;icon_state          &#x3D; 0;
    blank_menu-&gt;enabled_animations &#x3D; enabled_animations;

    &#x2F;&#x2F; map the functions
    blank_menu-&gt;operations.common.hide      &#x3D; (Hide)__pvt_hide_CCGraphic_Menu;
    blank_menu-&gt;operations.common.show      &#x3D; (Show)__pvt_show_CCGraphic_Menu;
    blank_menu-&gt;operations.common.update    &#x3D; (Update)__pvt_update;
    blank_menu-&gt;operations.switchToIndex    &#x3D; __pvt_switchIndex;
    blank_menu-&gt;operations.enabled_showAnimations &#x3D; 
        __pvt_setAnimationShowState_wrapper;
    
    &#x2F;&#x2F; icons
    blank_menu-&gt;operations.setIcon &#x3D; __pvt_setIcon;
    blank_menu-&gt;operations.hideIcon &#x3D; __pvt_hideIcon;
    blank_menu-&gt;operations.showIcon &#x3D; __pvt_showIcon;
    blank_menu-&gt;operations.enterSub &#x3D; __pvt_enterSub;
    blank_menu-&gt;operations.backParent &#x3D; __pvt_backParent;
    __pvt_init_animations(blank_menu, blank_animations);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="关于我们的图标设置，显示和隐藏"><a href="#关于我们的图标设置，显示和隐藏" class="headerlink" title="关于我们的图标设置，显示和隐藏"></a>关于我们的图标设置，显示和隐藏</h4><pre class="line-numbers language-none"><code class="language-none">static void __pvt_setIcon(CCGraphic_Menu* menu, CCGraphic_Image* sources, uint8_t size)  
&#123;  
    &#x2F;&#x2F; 设置菜单的图标源和图标数量  
    menu-&gt;icons_sources &#x3D; sources;  
    menu-&gt;icon_size &#x3D; size;  

    &#x2F;&#x2F; 初始化每个图标的尺寸和位置  
    for (uint8_t i &#x3D; 0; i &lt; menu-&gt;icon_size; i++) &#123;  
        &#x2F;&#x2F; 设置图标的高度和宽度  
        sources[i].image_size.height &#x3D; ICON_HEIGHT;  
        sources[i].image_size.width &#x3D; ICON_WIDTH;  

        &#x2F;&#x2F; 设置每个图标的位置，&#96;y&#96; 方向依次排列  
        sources[i].point.x &#x3D; 0;  
        sources[i].point.y &#x3D; i * ICON_HEIGHT;  
    &#125;  

    &#x2F;&#x2F; 显示图标  
    __pvt_showIcon(menu);  
&#125;  

static void __pvt_showIcon(CCGraphic_Menu* menu)  
&#123;  
    &#x2F;&#x2F; 如果没有图标源，则不执行任何操作  
    if (!menu-&gt;icons_sources) return;  
    
    &#x2F;&#x2F; 设置图标的状态为显示（1）  
    menu-&gt;icon_state &#x3D; 1;  
    
    CCGraphic_Point tlp;  
    CCGraphic_Size _size;  
    
    &#x2F;&#x2F; 获取显示图标的位置和大小  
    __pvt_providePoint(menu, &amp;tlp, 1);  
    __pvt_provideSize(menu, &amp;_size, 1);  
    
    &#x2F;&#x2F; 设置动画的显示状态为 0（关闭动画）  
    __pvt_setAnimationShowState(menu-&gt;animation_holder, 0);  
    
    &#x2F;&#x2F; 将菜单项的文本编辑区域重新定位到指定的位置和大小  
    menu-&gt;internelTextEdit-&gt;operations.relocate(menu-&gt;internelTextEdit, tlp, _size);  
    
    &#x2F;&#x2F; 遍历图标源，逐一绘制每个图标  
    for (uint8_t i &#x3D; 0; i &lt; menu-&gt;icon_size; i++) &#123;  
        CCGraphicWidget_draw_image(  
            menu-&gt;internelTextEdit-&gt;borrowed_device,  
            &amp;menu-&gt;icons_sources[i]  
        );  
    &#125;  
    
    &#x2F;&#x2F; 设置动画的显示状态为 1（启用动画）  
    __pvt_setAnimationShowState(menu-&gt;animation_holder, 1);  
    
    &#x2F;&#x2F; 仅显示文本编辑器  
    __pvt_show_textEditOnly(menu);  
&#125;  

static void __pvt_hideIcon(CCGraphic_Menu* menu)  
&#123;  
    &#x2F;&#x2F; 如果没有图标源，则不执行任何操作  
    if (!menu-&gt;icons_sources) return;  
    
    CCGraphic_Point tlp;  
    CCGraphic_Size _size;  
    
    &#x2F;&#x2F; 设置图标的状态为隐藏（0）  
    menu-&gt;icon_state &#x3D; 0;  
    
    &#x2F;&#x2F; 获取隐藏图标的位置和大小  
    __pvt_providePoint(menu, &amp;tlp, 0);  
    __pvt_provideSize(menu, &amp;_size, 0);  
    
    &#x2F;&#x2F; 设置动画的显示状态为 0（关闭动画）  
    __pvt_setAnimationShowState(menu-&gt;animation_holder, 0);  
    
    &#x2F;&#x2F; 将菜单项的文本编辑区域重新定位到指定的位置和大小  
    menu-&gt;internelTextEdit-&gt;operations.relocate(menu-&gt;internelTextEdit, tlp, _size);  
    
    &#x2F;&#x2F; 清除图标区域  
    menu-&gt;internelTextEdit-&gt;borrowed_device-&gt;operations.clearArea_function(  
        menu-&gt;internelTextEdit-&gt;borrowed_device,  
        0, 0, ICON_WIDTH, ICON_HEIGHT * menu-&gt;icon_size  
    );  
    
    &#x2F;&#x2F; 仅显示文本编辑器  
    __pvt_show_textEditOnly(menu);  
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    图标的绘制就是让位子绘制，清除掉重新绘制这个思路。</p>
<h4 id="菜单本体功能"><a href="#菜单本体功能" class="headerlink" title="菜单本体功能"></a>菜单本体功能</h4><pre class="line-numbers language-none"><code class="language-none">static void __pvt_update(CCGraphic_Menu* menu)
&#123;
    &#x2F;&#x2F; 调用文本编辑器的更新操作，刷新菜单显示
    menu-&gt;internelTextEdit-&gt;operations.operation.update(
        menu-&gt;internelTextEdit
    );
&#125;

&#x2F;&#x2F; 更新动画状态
static void __pvt_setAnimationShowState(
    CCGraphic_MenuAnimations* animations, uint8_t is_doing)
&#123;
    &#x2F;&#x2F; 如果动画状态没有变化，直接返回
    if(is_doing &#x3D;&#x3D; animations-&gt;is_doing)&#123;
        return;
    &#125;
    &#x2F;&#x2F; 如果动画正在进行，先逆向绘制区域，清除之前的显示
    animations-&gt;handler-&gt;operations.reverseArea_function(
        animations-&gt;handler, 
        animations-&gt;tl_point.x, animations-&gt;tl_point.y,
        animations-&gt;animationOffsetSize.width, 
        animations-&gt;animationOffsetSize.height
    );
    &#x2F;&#x2F; 更新动画状态
    animations-&gt;is_doing &#x3D; is_doing;
    &#x2F;&#x2F; 更新设备，刷新显示
    animations-&gt;handler-&gt;operations.update_device_function(
        animations-&gt;handler);
&#125;

&#x2F;*
    以下是显示&#x2F;隐藏图标时，提供布局计算的函数
*&#x2F;
static void __pvt_providePoint(
    CCGraphic_Menu* menu, 
    CCGraphic_Point* p, 
    uint8_t icons_enabled)
&#123;
    &#x2F;&#x2F; 根据是否启用图标，设置图标显示的起始位置
    p-&gt;x &#x3D; icons_enabled ? ICON_WIDTH : 0;
    p-&gt;y &#x3D; 0;
&#125;

static void __pvt_provideSize(
    CCGraphic_Menu* menu, 
    CCGraphic_Size* size, 
    uint8_t icons_enabled
)&#123;
    &#x2F;&#x2F; 根据是否启用图标，调整文本区域的宽度和高度
    size-&gt;width &#x3D; menu-&gt;internelTextEdit-&gt;handle-&gt;TexthandleSize.width - 
        (icons_enabled ? ICON_HEIGHT : 0);
    size-&gt;height &#x3D; menu-&gt;internelTextEdit-&gt;handle-&gt;TexthandleSize.height;
&#125;

&#x2F;&#x2F; 获取当前菜单项是否有子菜单
static inline CCGraphic_Menu* __pvt_current_owns_subMenu(CCGraphic_Menu* menu)
&#123;
    return  menu-&gt;menuItemArrays[
            menu-&gt;current_offset].subMenu;
&#125;

&#x2F;&#x2F; 获取当前菜单项的父菜单
static inline CCGraphic_Menu* __pvt_owns_parent_current(CCGraphic_Menu* menu)
&#123;
    return  menu-&gt;menuItemArrays[
            menu-&gt;current_offset].parentMenu;
&#125;

&#x2F;&#x2F; 仅显示文本编辑器的内容，更新菜单显示
void __pvt_show_textEditOnly(CCGraphic_Menu* menu)
&#123;
    &#x2F;&#x2F; 如果菜单没有项，则直接返回
    if(menu-&gt;menuArraySize &#x3D;&#x3D; 0)&#123;
        return;
    &#125;
    &#x2F;&#x2F; 设置动画状态为不显示
    __pvt_setAnimationShowState(menu-&gt;animation_holder, 0);
    &#x2F;&#x2F; 设置文本编辑器的内容，显示第一项菜单
    CCGraphicTextEdit* edit &#x3D; menu-&gt;internelTextEdit;
    edit-&gt;operations.setText(edit, menu-&gt;menuItemArrays[0].text);
    &#x2F;&#x2F; 显示后续菜单项
    for(uint8_t i &#x3D; 1; i &lt; menu-&gt;menuArraySize; i++)
    &#123;
        edit-&gt;operations.newLineText(edit, menu-&gt;menuItemArrays[i].text);
    &#125;
    &#x2F;&#x2F; 设置动画状态为显示
    __pvt_setAnimationShowState(menu-&gt;animation_holder, 1);    
&#125;

&#x2F;&#x2F; 隐藏菜单和图标
void __pvt_hide_CCGraphic_Menu(CCGraphic_Menu* menu)
&#123;
    &#x2F;&#x2F; 隐藏图标
    __pvt_hideIcon(menu);
    &#x2F;&#x2F; 隐藏文本编辑器
    menu-&gt;internelTextEdit-&gt;operations.operation.hide(menu-&gt;internelTextEdit);
    &#x2F;&#x2F; 获取动画控制器
    CCGraphic_MenuAnimations* animation &#x3D; menu-&gt;animation_holder;
    &#x2F;&#x2F; 如果没有动画控制器，则返回
    if(!animation) return;
    &#x2F;&#x2F; 如果动画正在进行，则停止动画
    if(animation-&gt;is_doing)&#123;
        __pvt_setAnimationShowState(animation, 0);
    &#125;
&#125;

&#x2F;* 绘制菜单显示 *&#x2F;
void __pvt_show_CCGraphic_Menu(CCGraphic_Menu* menu)
&#123;
    &#x2F;&#x2F; 仅显示文本编辑器内容
    __pvt_show_textEditOnly(menu);   
&#125;

&#x2F;&#x2F; 执行动画，逐步更新菜单位置直到目标位置
void __pvt_do_stepped_animate(
    CCGraphic_MenuAnimations* animations, 
    CCGraphic_Point* end_tl_p 
)
&#123;
    &#x2F;&#x2F; 如果动画步长为负，表示需要向下移动
    if(animations-&gt;y_step &lt; 0)&#123;
        &#x2F;&#x2F; 逐步向下执行动画，直到达到目标位置
        while(animations-&gt;tl_point.y &gt; end_tl_p-&gt;y)&#123;
            __pvt_doByStep(animations);  &#x2F;&#x2F; 执行单步动画
#ifdef REQ_ANIMATION_DELAY
            &#x2F;&#x2F; 延时，模拟动画效果
            __device_delay(ANIMATION_DELAY_MS);
#endif
        &#125;
    &#125;
    &#x2F;&#x2F; 如果动画步长为正，表示需要向上移动
    else
    &#123;
        &#x2F;&#x2F; 逐步向上执行动画，直到达到目标位置
        while(animations-&gt;tl_point.y &lt; end_tl_p-&gt;y)&#123;
            __pvt_doByStep(animations);  &#x2F;&#x2F; 执行单步动画
#ifdef REQ_ANIMATION_DELAY
            &#x2F;&#x2F; 延时，模拟动画效果
            __device_delay(ANIMATION_DELAY_MS);
#endif
        &#125;        
    &#125;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="关于切换focus的菜单和进入父子菜单的函数"><a href="#关于切换focus的菜单和进入父子菜单的函数" class="headerlink" title="关于切换focus的菜单和进入父子菜单的函数"></a>关于切换focus的菜单和进入父子菜单的函数</h4><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 切换菜单项索引并执行动画
static void __pvt_switchIndex(
    CCGraphic_Menu* menu, uint8_t index)
&#123;
    &#x2F;&#x2F; 如果索引没有变化，不做任何操作
    if(index &#x3D;&#x3D; menu-&gt;current_offset) return;

    &#x2F;&#x2F; 如果新索引大于当前索引，表示需要向下移动
    if(index &gt; menu-&gt;current_offset)&#123;
        &#x2F;&#x2F; 如果当前动画步长为负，改为正值
        if(menu-&gt;animation_holder-&gt;y_step &lt; 0)&#123;
            menu-&gt;animation_holder-&gt;y_step &#x3D; 
                -menu-&gt;animation_holder-&gt;y_step;
        &#125;
    &#125;
    &#x2F;&#x2F; 如果新索引小于当前索引，表示需要向上移动
    else&#123;
        &#x2F;&#x2F; 如果当前动画步长为正，改为负值
        if(menu-&gt;animation_holder-&gt;y_step &gt; 0)&#123;
            menu-&gt;animation_holder-&gt;y_step &#x3D; 
                -menu-&gt;animation_holder-&gt;y_step;
        &#125;
    &#125;
    &#x2F;&#x2F; 更新当前菜单项的索引
    menu-&gt;current_offset &#x3D; index;
    &#x2F;&#x2F; 计算目标位置
    CCGraphic_Point end_tlp;
    end_tlp &#x3D; menu-&gt;animation_holder-&gt;tl_point; 
    end_tlp.y &#x3D; index * menu-&gt;animation_holder-&gt;animationOffsetSize.height;
    &#x2F;&#x2F; 如果启用了动画，执行逐步动画
    if(menu-&gt;enabled_animations)
        __pvt_do_stepped_animate(menu-&gt;animation_holder, &amp;end_tlp);
    else
        &#x2F;&#x2F; 否则，立即执行动画
        __pvt_do_as_immediate(menu-&gt;animation_holder, &amp;end_tlp);
&#125;

&#x2F;&#x2F; 进入子菜单并显示子菜单的内容
static CCGraphic_Menu* __pvt_enterSub(CCGraphic_Menu* parentMenu)
&#123;
    &#x2F;&#x2F; 缓存父菜单的图标状态
    uint8_t cached_icon_state &#x3D; parentMenu-&gt;icon_state;
    &#x2F;&#x2F; 获取父菜单的子菜单
    CCGraphic_Menu* subone &#x3D; __pvt_current_owns_subMenu(parentMenu);
    &#x2F;&#x2F; 如果没有子菜单，返回NULL
    if(!subone) return NULL;
    &#x2F;&#x2F; 隐藏当前菜单
    parentMenu-&gt;operations.common.hide(parentMenu);
    &#x2F;&#x2F; 恢复父菜单的图标状态
    parentMenu-&gt;icon_state &#x3D; cached_icon_state;
    &#x2F;&#x2F; 如果子菜单有图标，显示图标，否则显示子菜单
    if(subone-&gt;icon_state)&#123;
        subone-&gt;operations.showIcon(subone);
    &#125;else&#123;
        subone-&gt;operations.common.show(subone);
    &#125;
    &#x2F;&#x2F; 返回子菜单
    return subone;
&#125;

&#x2F;&#x2F; 返回父菜单并显示父菜单的内容
static CCGraphic_Menu* __pvt_backParent(CCGraphic_Menu* subMenu)
&#123;
    &#x2F;&#x2F; 缓存子菜单的图标状态
    uint8_t cached_icon_state &#x3D; subMenu-&gt;icon_state;
    &#x2F;&#x2F; 获取子菜单的父菜单
    CCGraphic_Menu* parentMenu &#x3D; __pvt_owns_parent_current(subMenu);
    &#x2F;&#x2F; 如果没有父菜单，返回NULL
    if(!parentMenu) return NULL;
    &#x2F;&#x2F; 隐藏当前子菜单
    subMenu-&gt;operations.common.hide(subMenu);
    &#x2F;&#x2F; 恢复子菜单的图标状态
    subMenu-&gt;icon_state &#x3D; cached_icon_state;
    &#x2F;&#x2F; 如果父菜单有图标，显示图标，否则显示父菜单
    if(parentMenu-&gt;icon_state)&#123;
        parentMenu-&gt;operations.showIcon(parentMenu);
    &#125;else&#123;
        parentMenu-&gt;operations.common.show(parentMenu);
    &#125;
    
    &#x2F;&#x2F; 返回父菜单
    return parentMenu;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="完整的测试文件"><a href="#完整的测试文件" class="headerlink" title="完整的测试文件"></a>完整的测试文件</h2><p>​    现在来看看完整的测试文件！</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;Test&#x2F;OLED_TEST&#x2F;oled_test.h&quot;
#include &quot;Test&#x2F;GraphicTest&#x2F;graphic_test.h&quot;
#include &quot;Graphic&#x2F;widgets&#x2F;components&#x2F;CCGraphic_TextEdit&#x2F;CCGraphic_TextEdit.h&quot;
void test_oled_iic_functionalities()
&#123;
    OLED_Handle handle;
    user_init_hard_iic_oled_handle(&amp;handle);
    test_set_pixel_line(&amp;handle, 1, 2);
    HAL_Delay(1000);
    test_clear(&amp;handle);
    test_set_pixel_line(&amp;handle, 2, 1);
    HAL_Delay(1000);
    test_clear(&amp;handle);
&#125;

void test_oled_spi_functionalities()
&#123;
    OLED_Handle handle;
    user_init_hard_spi_oled_handle(&amp;handle);
    test_set_pixel_line(&amp;handle, 1, 2);
    HAL_Delay(1000);
    test_clear(&amp;handle);
    test_set_pixel_line(&amp;handle, 2, 1);
    HAL_Delay(1000);
    test_clear(&amp;handle);
&#125;

static void __helper_on_set_text(CCGraphicTextEdit* edit, char* sources, uint32_t shown_time)
&#123;
    edit-&gt;operations.setText(edit, sources);
    HAL_Delay(shown_time * 1000);
    edit-&gt;operations.clear(edit);
&#125;

#define SET_TEXT_CONV(SRC, SECS) do&#123; sources &#x3D; SRC;\
    __helper_on_set_text(&amp;edit, sources, SECS);&#125;while(0)

static void __test_common(CCDeviceHandler* handler)
&#123;
    CCGraphicTextEdit   edit;
    CCGraphic_AsciiTextItem item;
    CCGraphic_Point p;
    p.x &#x3D; 0;
    p.y &#x3D; 0;
    CCGraphic_Size acceptablesize &#x3D; 
        CCGraphicWidget_MaxAcceptable_Size(handler);
    CCGraphicWidget_init_AsciiTextItem(
        &amp;item, p, acceptablesize, ASCII_6x8
    );
    CCGraphic_init_CCGraphicTextEdit(
        &amp;edit, handler, &amp;item
    );
    edit.acquired_stepped_update &#x3D; 1;
    char* sources;
    SET_TEXT_CONV(&quot;Hello! Welcome CCGraphic SimpleTest!&quot;, 5);
    SET_TEXT_CONV(&quot;If you see this sentences, &quot;
    &quot;it means that you have passed the GraphicTest&quot;
    &quot;and congratulations!&quot;, 7);

    SET_TEXT_CONV(&quot;Graphic Test On Base begin&quot;, 4);
    SET_TEXT_CONV(&quot;Test Points&quot;, 4);
    on_test_draw_points(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Test Lines&quot;, 4);
    on_test_draw_line(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Test Circles&quot;, 4);
    on_test_draw_circle(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Test Rectangle&quot;, 4);
    on_test_draw_rectangle(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Test Triangle&quot;, 4);
    on_test_draw_triangle(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Test Ellipse&quot;, 4);
    on_test_draw_ellipse(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Test Arc&quot;, 4);
    on_test_draw_arc(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Graphic Test On Base end&quot;, 4);
    SET_TEXT_CONV(&quot;Graphic Test On widget begin&quot;, 4);
    SET_TEXT_CONV(&quot;Test Image Drawing&quot;, 4);

    &#x2F;* widget test *&#x2F;
    on_test_draw_image(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Test Ascii Draw&quot;, 4);
    on_test_draw_ascii(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Graphic Test On widget end&quot;, 4);
    SET_TEXT_CONV(&quot;Graphic Test On component begin&quot;, 4);
    SET_TEXT_CONV(&quot;Test TextEdit&quot;, 4);
    &#x2F;* components test *&#x2F;
    on_test_component_textEdit_test(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Test Frame&quot;, 4);
    on_test_component_frame_test(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Test Menu&quot;, 4);
    on_test_component_menu(handler);
    HAL_Delay(1000);
    SET_TEXT_CONV(&quot;Graphic Test On component end&quot;, 4);
    SET_TEXT_CONV(&quot;Finish Testing, enjoy!&quot;, 4);
&#125;


void test_graphic_hardiic_functionalities()
&#123;
    CCDeviceHandler handler;
    on_test_init_hardiic_oled(&amp;handler);

    __test_common(&amp;handler);
&#125;

void test_graphic_soft_spi_functionalities()
&#123;
    CCDeviceHandler handler;
    on_test_init_softspi_oled(&amp;handler);

    __test_common(&amp;handler);
&#125;


void test_graphic_hard_spi_functionalities()
&#123;
    CCDeviceHandler handler;
    on_test_init_hardspi_oled(&amp;handler);

    __test_common(&amp;handler);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2025/01/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6/">http://charliechen114514.github.io/2025/01/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a><a class="post-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a><a class="post-meta__tags" href="/tags/OLED/">OLED</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/02/03/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="快速入门C++并发编程"><img class="cover" src="/img/loading.gif" data-original="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">快速入门C++并发编程</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/13/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E8%BF%9C%E7%A8%8B%E4%B8%8B%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E7%A8%8B%E5%BA%8F%E5%8A%9E%E6%B3%95-VSCode%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%95%8C%E9%9D%A2%E8%B0%83%E8%AF%95%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87/" title="关于使用GDB调试远程下位机开发板的应用层程序办法 + VSCode更好的界面调试体验提升"><img class="cover" src="/img/loading.gif" data-original="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关于使用GDB调试远程下位机开发板的应用层程序办法 + VSCode更好的界面调试体验提升</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/27/STM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8EPlatformIO-VSCode-CubeMX%E7%9A%84%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="STM32开发环境配置记录——关于PlatformIO + VSCode + CubeMX的集成环境配置"><img class="cover" src="/img/loading.gif" data-original="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-27</div><div class="title">STM32开发环境配置记录——关于PlatformIO + VSCode + CubeMX的集成环境配置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">大幅度精简了博客，余下的部分是我认为质量上课的；分离了笔记部分（我传到了额外的诸如CSDN的垃圾场（逃））。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6"><span class="toc-number">1.</span> <span class="toc-text">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">环境介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%8E%E5%8A%A8%E6%9C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">代码与动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">架构设计，优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6-%E5%8D%8F%E8%AE%AE%E5%B1%82%E5%B0%81%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架(协议层封装)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%B1%82%E8%AE%BE%E8%AE%A1%EF%BC%8C%E4%BB%A5IIC%E4%B8%BA%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.</span> <span class="toc-text">协议层设计，以IIC为例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6IIC"><span class="toc-number">2.2.</span> <span class="toc-text">关于软硬件IIC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.</span> <span class="toc-text">设计的一些原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E5%8D%8F%E8%AE%AE%E5%B1%82%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">完成协议层的抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A8%E6%9E%90%E6%88%91%E4%BB%AC%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">刨析我们的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E6%88%91%E4%BB%AC%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">2.4.2.</span> <span class="toc-text">如何完成我们的抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%87%A0%E4%B8%AAC%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">2.4.3.</span> <span class="toc-text">插入几个C语言小技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E8%BD%AF%E4%BB%B6IIC%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.4.</span> <span class="toc-text">完成软件IIC通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%88%91%E4%BB%AC%E7%9A%84IIC%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">开始我们的IIC通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E6%88%91%E4%BB%AC%E7%9A%84IIC%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">结束我们的IIC通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">发送一个字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89%E5%AE%8C%E6%88%90%E5%91%BD%E4%BB%A4%E4%BC%A0%E9%80%92%E5%92%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">（重要）完成命令传递和数据传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E4%B8%80%E5%87%BB%EF%BC%8C%E5%AE%8C%E6%88%90%E6%88%91%E4%BB%AC%E7%9A%84IIC%E9%80%9A%E4%BF%A1"><span class="toc-number">2.4.4.5.</span> <span class="toc-text">最终一击，完成我们的IIC通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6IIC"><span class="toc-number">2.5.</span> <span class="toc-text">硬件IIC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6%EF%BC%88OLED%E8%AE%BE%E5%A4%87%E5%B1%82%E9%A9%B1%E5%8A%A8%E5%B0%81%E8%A3%85%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（OLED设备层驱动封装）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OLED%E8%AE%BE%E5%A4%87%E5%B1%82%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-number">3.1.</span> <span class="toc-text">OLED设备层驱动开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E4%B8%80%E4%B8%AAOLED"><span class="toc-number">3.1.1.</span> <span class="toc-text">如何抽象一个OLED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%88%90OLED%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.2.</span> <span class="toc-text">完成OLED的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96OLED"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">初始化OLED</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E5%B1%8F%E5%B9%95"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">清空屏幕</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E5%B1%8F%E5%B9%95%E4%B8%8E%E5%85%89%E6%A0%87%E8%AE%BE%E7%BD%AE1"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">刷新屏幕与光标设置1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E5%B1%8F%E5%B9%95%E4%B8%8E%E5%85%89%E6%A0%87%E8%AE%BE%E7%BD%AE2"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">刷新屏幕与光标设置2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E5%B1%8F%E5%B9%95%E4%B8%8E%E5%85%89%E6%A0%87%E8%AE%BE%E7%BD%AE3"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">刷新屏幕与光标设置3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E7%82%B9"><span class="toc-number">3.1.2.6.</span> <span class="toc-text">绘制一个点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E8%89%B2"><span class="toc-number">3.1.2.7.</span> <span class="toc-text">反色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.8.</span> <span class="toc-text">区域化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E7%BD%AE%E4%BD%8D"><span class="toc-number">3.1.2.8.1.</span> <span class="toc-text">区域置位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E5%8F%8D%E8%89%B2"><span class="toc-number">3.1.2.8.2.</span> <span class="toc-text">区域反色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E6%9B%B4%E6%96%B0"><span class="toc-number">3.1.2.8.3.</span> <span class="toc-text">区域更新</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E6%B8%85%E7%A9%BA"><span class="toc-number">3.1.2.9.</span> <span class="toc-text">区域清空</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%88%91%E4%BB%AC%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">3.1.3.</span> <span class="toc-text">测试我们的抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E7%90%86%E4%B8%80%E4%B8%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">整理一下，我们应该如何使用？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6%EF%BC%88%E7%BB%98%E5%9B%BE%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（绘图设备抽象）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%B1%82%E7%9A%84%E5%BA%95%E5%B1%82%E6%8A%BD%E8%B1%A1%E2%80%94%E2%80%94%E7%BB%98%E5%9B%BE%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">图像层的底层抽象——绘图设备抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E4%B8%80%E4%B8%AA%E7%BB%98%E5%9B%BE%E8%AE%BE%E5%A4%87%EF%BC%9F"><span class="toc-number">4.1.1.</span> <span class="toc-text">如何抽象一个绘图设备？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E7%BB%98%E5%9B%BE%E8%AE%BE%E5%A4%87%EF%BC%8C%E7%89%B9%E5%8C%96%E4%B8%BAOLED%E8%AE%BE%E5%A4%87"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">桥接绘图设备，特化为OLED设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%B8%8E%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%9B%B8%E4%BC%BC%E5%87%BD%E6%95%B0%E5%8C%96%E7%AE%80%E7%9A%84%E9%80%9A%E7%94%A8%E5%8A%9E%E6%B3%95"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">题外话：设备的属性，与设计一个相似函数化简的通用办法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%9D%A5%E6%93%8D%E4%BD%9C%E8%AE%BE%E5%A4%87"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">使用函数指针来操作设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">总结一下</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2%E5%BA%93%E7%9A%84%E6%8A%BD%E8%B1%A1%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础图形库的抽象）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2%E5%BA%93%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">5.1.</span> <span class="toc-text">基础图形库的抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%9B%BE%E5%BD%A2"><span class="toc-number">5.2.</span> <span class="toc-text">抽象图形</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%82%B9"><span class="toc-number">5.2.1.</span> <span class="toc-text">抽象点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%88%91%E4%BB%AC%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">设计我们的抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%88%91%E4%BB%AC%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">实现我们的抽象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%BA%BF"><span class="toc-number">5.2.3.</span> <span class="toc-text">抽象线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%88%91%E4%BB%AC%E7%9A%84%E6%8A%BD%E8%B1%A1-1"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">设计我们的抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%88%91%E4%BB%AC%E7%9A%84%E6%8A%BD%E8%B1%A1-1"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">实现我们的抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9E%82%E7%9B%B4%E7%9A%84%E5%92%8C%E6%B0%B4%E5%B9%B3%E7%9A%84%E7%BA%BF"><span class="toc-number">5.2.3.2.1.</span> <span class="toc-text">绘制垂直的和水平的线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Bresenham%E7%AE%97%E6%B3%95%E5%AE%8C%E6%88%90%E4%BB%BB%E6%84%8F%E6%96%9C%E7%8E%87%E7%9A%84%E7%BB%98%E5%88%B6"><span class="toc-number">5.2.3.2.2.</span> <span class="toc-text">使用Bresenham算法完成任意斜率的绘制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%E5%92%8C%E7%9F%A9%E5%BD%A2"><span class="toc-number">5.2.4.</span> <span class="toc-text">绘制三角形和矩形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E5%BD%A2"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">矩形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">三角形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.4.3.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9C%86%EF%BC%8C%E5%9C%86%E5%BC%A7%E5%92%8C%E6%A4%AD%E5%9C%86"><span class="toc-number">5.2.5.</span> <span class="toc-text">绘制圆，圆弧和椭圆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E6%88%91%E4%BB%AC%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.6.</span> <span class="toc-text">继续我们的测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6%EF%BC%88%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（基础组件实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.</span> <span class="toc-text">基础组件实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%9B%BE%E5%83%8F%E5%92%8C%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA%E5%88%B0OLED%E4%B8%8A"><span class="toc-number">6.1.1.</span> <span class="toc-text">如何将图像和文字显示到OLED上</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">如何绘制图像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E6%96%87%E5%AD%97"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">如何绘制文字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AD%97%E4%BD%93%EF%BC%9F"><span class="toc-number">6.1.1.2.1.</span> <span class="toc-text">如何获取字体？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AD%97%E4%BD%93"><span class="toc-number">6.1.1.2.2.</span> <span class="toc-text">如何正确的访问字体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E5%AD%97%E4%BD%93"><span class="toc-number">6.1.1.2.3.</span> <span class="toc-text">如何抽象字体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.1.1.2.4.</span> <span class="toc-text">如何绘制字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%96%B9%E6%A1%88"><span class="toc-number">6.1.1.2.5.</span> <span class="toc-text">绘制方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BB%98%E5%88%B6"><span class="toc-number">6.1.1.2.6.</span> <span class="toc-text">文本绘制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E5%8A%A0%E6%96%B9%E4%BE%BF%E7%9A%84%E7%BB%98%E5%88%B6"><span class="toc-number">6.1.1.2.7.</span> <span class="toc-text">更加方便的绘制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E4%BD%93%E9%99%84%E5%BD%95"><span class="toc-number">6.2.</span> <span class="toc-text">字体附录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ascii-6x8%E5%AD%97%E4%BD%93"><span class="toc-number">6.2.1.</span> <span class="toc-text">ascii 6x8字体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ascii-8-x-16%E5%AD%97%E4%BD%93"><span class="toc-number">6.2.2.</span> <span class="toc-text">ascii 8 x 16字体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6%EF%BC%88%E5%8A%A8%E6%80%81%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架（动态菜单组件实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E8%8C%83%E4%BE%8B%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">面对对象C的程序设计（范例）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%BA%94%E7%94%A8%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">面对对象C的程序设计（应用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%B0%88%E8%AE%BA%E6%88%91%E4%B8%8A%E9%9D%A2%E7%BB%99%E5%87%BA%E7%9A%84%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF"><span class="toc-number">7.3.</span> <span class="toc-text">进一步谈论我上面给出的代码——继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text">实现一个面对对象的文本编辑器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF"><span class="toc-number">7.3.2.</span> <span class="toc-text">所以，什么是继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%94%B3%E6%88%91%E4%BB%AC%E5%AF%B9%E8%8F%9C%E5%8D%95%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">7.4.</span> <span class="toc-text">重申我们对菜单的抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E8%8F%9C%E5%8D%95%E9%A1%B9%E7%9B%AE"><span class="toc-number">7.4.1.</span> <span class="toc-text">抽象菜单项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E8%8F%9C%E5%8D%95%E5%8A%A8%E7%94%BB"><span class="toc-number">7.4.2.</span> <span class="toc-text">抽象菜单动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%8F%9C%E5%8D%95%E5%8A%9F%E8%83%BD"><span class="toc-number">7.4.3.</span> <span class="toc-text">实现菜单功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%91%E4%BB%AC%E7%9A%84%E8%8F%9C%E5%8D%95"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">初始化我们的菜单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC%E7%9A%84%E5%9B%BE%E6%A0%87%E8%AE%BE%E7%BD%AE%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%92%8C%E9%9A%90%E8%97%8F"><span class="toc-number">7.4.3.2.</span> <span class="toc-text">关于我们的图标设置，显示和隐藏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E6%9C%AC%E4%BD%93%E5%8A%9F%E8%83%BD"><span class="toc-number">7.4.3.3.</span> <span class="toc-text">菜单本体功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%88%87%E6%8D%A2focus%E7%9A%84%E8%8F%9C%E5%8D%95%E5%92%8C%E8%BF%9B%E5%85%A5%E7%88%B6%E5%AD%90%E8%8F%9C%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.3.4.</span> <span class="toc-text">关于切换focus的菜单和进入父子菜单的函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6"><span class="toc-number">7.5.</span> <span class="toc-text">完整的测试文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/03/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="快速入门C++并发编程"><img src="/img/loading.gif" data-original="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快速入门C++并发编程"/></a><div class="content"><a class="title" href="/2025/02/03/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="快速入门C++并发编程">快速入门C++并发编程</a><time datetime="2025-02-03T10:42:25.000Z" title="发表于 2025-02-03 18:42:25">2025-02-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6/" title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架"><img src="/img/loading.gif" data-original="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架"/></a><div class="content"><a class="title" href="/2025/01/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1C%E8%AF%AD%E8%A8%80%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EOLED%E7%9A%84%E5%9B%BE%E5%BD%A2%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6/" title="从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架">从0开始使用面对对象C语言搭建一个基于OLED的图形显示框架</a><time datetime="2025-01-30T08:23:20.000Z" title="发表于 2025-01-30 16:23:20">2025-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/13/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E8%BF%9C%E7%A8%8B%E4%B8%8B%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E7%A8%8B%E5%BA%8F%E5%8A%9E%E6%B3%95-VSCode%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%95%8C%E9%9D%A2%E8%B0%83%E8%AF%95%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87/" title="关于使用GDB调试远程下位机开发板的应用层程序办法 + VSCode更好的界面调试体验提升"><img src="/img/loading.gif" data-original="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于使用GDB调试远程下位机开发板的应用层程序办法 + VSCode更好的界面调试体验提升"/></a><div class="content"><a class="title" href="/2024/12/13/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E8%BF%9C%E7%A8%8B%E4%B8%8B%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E7%A8%8B%E5%BA%8F%E5%8A%9E%E6%B3%95-VSCode%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%95%8C%E9%9D%A2%E8%B0%83%E8%AF%95%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87/" title="关于使用GDB调试远程下位机开发板的应用层程序办法 + VSCode更好的界面调试体验提升">关于使用GDB调试远程下位机开发板的应用层程序办法 + VSCode更好的界面调试体验提升</a><time datetime="2024-12-13T04:13:10.000Z" title="发表于 2024-12-13 12:13:10">2024-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/15/WSL2%E4%B8%8B%E4%BD%BF%E7%94%A8miniconda-cuda-cudnn%E6%96%B9%E6%A1%88%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/" title="WSL2下使用miniconda+cuda+cudnn方案进行机器/深度学习环境配置方案"><img src="/img/loading.gif" data-original="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="WSL2下使用miniconda+cuda+cudnn方案进行机器/深度学习环境配置方案"/></a><div class="content"><a class="title" href="/2024/11/15/WSL2%E4%B8%8B%E4%BD%BF%E7%94%A8miniconda-cuda-cudnn%E6%96%B9%E6%A1%88%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/" title="WSL2下使用miniconda+cuda+cudnn方案进行机器/深度学习环境配置方案">WSL2下使用miniconda+cuda+cudnn方案进行机器/深度学习环境配置方案</a><time datetime="2024-11-15T13:11:50.000Z" title="发表于 2024-11-15 21:11:50">2024-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/15/STM32%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8B%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%B0%8F%E8%AE%BA-II/" title="STM32单片机之分析启动文件小论(II)"><img src="/img/loading.gif" data-original="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STM32单片机之分析启动文件小论(II)"/></a><div class="content"><a class="title" href="/2024/11/15/STM32%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8B%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%B0%8F%E8%AE%BA-II/" title="STM32单片机之分析启动文件小论(II)">STM32单片机之分析启动文件小论(II)</a><time datetime="2024-11-15T13:05:50.000Z" title="发表于 2024-11-15 21:05:50">2024-11-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>