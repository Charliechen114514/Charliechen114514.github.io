<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言数据结构模拟（1）：动态数组API详解</title>
      <link href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="动态数组——API思路详解"><a href="#动态数组——API思路详解" class="headerlink" title="动态数组——API思路详解"></a>动态数组——API思路详解</h1><p>​        写在前面：这里是动态数组API简介：版本是v1.0.0!这篇API博客我写了4个小时，匆匆忙忙。但却是我第一个过一万字的博客！</p><p>​        我第一次手搓大型的小项目，也是我第一次单个程序突破1000行！这个前言就算小小的纪念一下这个成就吧！</p><p>​        鄙人编程年龄仅仅就7个月，还是一枚小白，这个项目里面肯定还有许多不足！如果你对它感兴趣！可以到我的GitHub上下载，测试！如果发现了Bug，麻烦及时反馈给我！（如果还有解决方案我会直接磕头叫声Daddy（逃））</p><p>​                                                                                                                                                                                        —-2023/2.7/21：47</p><h3 id="动态数组入门"><a href="#动态数组入门" class="headerlink" title="动态数组入门"></a>动态数组入门</h3><p>​        首先，作为入门级别的数据结构，我们毫无疑问的：这个数据结构必须满足增删查改！其中，增加就必须要有一个一个增加的，还有直接加入一大群的，删除也是如此。此外，这个数组可以查询是否有目标元素存在，这就需要我们也写一些相关的函数来支持我们的操作！就是这些，我们还可以为了使我们的打印更加清晰，（有点难过的是：C语言必须多增加一个参数来存放它，使得看起来相当的拥挤），可以自定义打印方式。事实上，这就是我们C++里面的vector容器（我就是想要复刻API哈哈哈）</p><p>​        我们的数据结构首先已经被框死：他是一个数组，存储的是相同类型的元素：要不全是整形，要不全是字符，要不全是指针，要么就是同一个类型的结构体！于是，我们不妨这样设想：他必须还是数组，那就说明内存的物理结构还是连续的，但是又要不停的扩展或者伸缩！那就把我们的数组（严肃的讲是静态数组）做一些改动，使之可以自由扩展不就好了嘛？这就需要我们使用头文件,来引入malloc函数群就好了</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;&#x2F;&#x2F;IO流交互#include&lt;stdlib.h&gt;&#x2F;&#x2F;标准库：里面有我们想要的函数#include&lt;string.h&gt;&#x2F;&#x2F;memory函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基于上面的思路，我们很快就搓出来一个这个玩意：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;void* data &#x3D; NULL;    int current_size&#x3D;0;    &#x2F;&#x2F;...Do something and the size need to increase        data&#x3D;realloc(data,current_size+1);    current_size++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不错，这就是我们动态数组的雏形了！不过，这样散架着太捞了，后续也不好维护与处理。那很简单了：结构体用起来嘛！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _DynamicArray_ &#123;&#x2F;&#x2F;_HHH_是为了后续智能提示不会产生冲突void* DataPiece; &#x2F;&#x2F;连续内存块size_t current_size; &#x2F;&#x2F;当前的大小如何！不过，使用size_t其实更是说明我们的程序变量是非负的而已！&#125;DynamicArray;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        好像也不太好，我们后续要知道，访问起来是void*！这个特殊的指针不能帮我们锁定目标，是一个未确定类型的指针，所以。。。我们不妨加上一个常量，在数据首次入动态数组的时候直接将这样的值初始化！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _DynamicArray_ &#123;&#x2F;&#x2F;_HHH_是为了后续智能提示不会产生冲突void* DataPiece; &#x2F;&#x2F;连续内存块size_t current_size; &#x2F;&#x2F;当前的大小如何！不过，使用size_t其实更是说明我们的程序变量是非负的而已！size_t total_usable_size;&#x2F;&#x2F;用来调整数组的大小，同时又允许我们在一定范围内自由插入size_t Single_Data_size;&#x2F;&#x2F;相当于类型名了，这个数据在我们后面十分的重要&#125;DynamicArray;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，我想我们的动态数组就具有了极强的通用性：可以像一般的数组那样存储任何数据！</p><h3 id="工厂函数与基本调整函数系列"><a href="#工厂函数与基本调整函数系列" class="headerlink" title="工厂函数与基本调整函数系列"></a>工厂函数与基本调整函数系列</h3><p>​        什么是工厂函数？就是产生对象并且返回它供我们程序员使用的函数，比如说，C语言的malloc函数就是一个代表性的工厂函数。他返回一个任意大小的堆空间：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">(void*)malloc(bit_malloc)&#x2F;&#x2F;开辟多少字节自己制定，是一个操作性很强的函数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们的函数就必须使用它来开辟我们的内存：但是，直接让用户制定是麻烦的，极易出错的，所以：</p><h4 id="默认工厂函数"><a href="#默认工厂函数" class="headerlink" title="默认工厂函数"></a>默认工厂函数</h4><p>​        我们首先需要一个可以产生一个这样的结构体并且还要返回它的函数，为了初始化这样的结构体，我们需要知道我们要开辟多少个元素，元素多大，否则我们不会开辟。函数的原型可以轻而易举的给出：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* Init_A_DynamicArray(size_texpected_number, size_tdatasize);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        首先，作为动态数组，灵活性是重要的，用户（也就是咱们），往往压根就不知道我们会有多少个数据入列。于是，我们可能需要自己指定一个默认的大小，一旦我们的数据超过了指标，我们就马上调用一个自己手动写的函数，如你所见，就是这个功能的封装：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;...Do something and the size need to increase        data&#x3D;realloc(data,current_size+1);&#x2F;&#x2F; Adjustment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>来立马调用起来防止指针越界！我们稍后在调整函数里会再次阐述！回到初始化函数$Init_A_DynamicArray$上来！我们首先初始化一个结构体：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* pro_usable_space &#x3D; (DynamicArray*)malloc(sizeof(DynamicArray))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果屏幕前的你有一定编程经验，马上就会意识到如果仅是止步如此会大错特错！因为我们的malloc函数一旦开辟失败就会返回一个NULL指针，如果我们不对它进行空判断就会闹出程序崩溃的笑话，这里我们看到，一般的教程是直接这么写的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if(!pro_usable_space)&#123;  return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        如果只是随意教教，这样写可以；工程开发中如此书写很不负责任！首先，我们的程序不可以直接return！后续我们的操作一旦再次拿起甚至时使用返回出去的NULL指针，马上又会闹起报错的笑话！既然如此，我们做一点报错友善处理！·</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if(pro_usable_space &#x3D;&#x3D; NULL)&#123;  printf(&quot;Sorry! Failed to malloc a new space! Program exits!&quot;);    exit(-1);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​         这样好些了！我们后续开发还会反复用到，何不直接使用宏定义直接节省反复车轮子的工作呢？还是相信智能提示的好！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;Sorry! Failed to malloc a new space! Program exits!&quot;) &#x2F;&#x2F;宏定义的重要作用之一：代替代码块#define DynamicArray_ERROR_IN_MALLOCING_SPACE 1 &#x2F;&#x2F;编写异常程序可以这样写，使之错误码和错误信息完全对应起来&#x2F;&#x2F;  Do Something ...     if(pro_usable_space &#x3D;&#x3D; NULL) &#123;  SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         随后顺手初始化，回到刚刚的问题，我们需要给数据结构一个默认的大小，我们不妨设置成5！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define Dyarr_DEFAULT_MALLOC 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">pro_usable_space-&gt;DataPiece &#x3D; NULL;&#x2F;&#x2F;赋予空指针，防止成为野指针修改其他内存块pro_usable_space-&gt;Single_Data_size &#x3D; datasize;&#x2F;&#x2F;初始化单位元素大小if (expected_number &gt;&#x3D; Dyarr_DEFAULT_MALLOC)&#x2F;&#x2F;大于默认的就用户指定的那个大小pro_usable_space-&gt;total_usable_size &#x3D; expected_number;elsepro_usable_space-&gt;total_usable_size &#x3D; Dyarr_DEFAULT_MALLOC;&#x2F;&#x2F;顺手处理异常的数字大小pro_usable_space-&gt;current_size &#x3D; 0;&#x2F;&#x2F;当下就没有元素在，赋0！return pro_usable_space;&#x2F;&#x2F;返回产生的堆区开辟的结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        有的时候我们可能需要直接拿起一个静态数组直接转化，很简单，我们可以这样写：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;int arr[10]&#x3D;&#123;1,2,3,4,5,6,7,8,9,10&#125;;    for(int i &#x3D; 0; i &lt; 10; i++)&#123;        &#x2F;&#x2F;插入    &#125;    &#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但这样我们需要反复调用函数，导致程序性能很差，我们为什么不直接提供一个接口，一边创造结构体一边入列呢？</p><h4 id="升级工厂函数"><a href="#升级工厂函数" class="headerlink" title="升级工厂函数"></a>升级工厂函数</h4><p>​        很简单明了，我们的函数的原型是很容易想到的：你这个数组：是什么？（Single_Data_size），有多少个元素？（current_size），在哪里（Datapiece）的问题！我们产生的结构体还是要返回给用户使用的！</p><p>​        所以，我们的参数需要：数组地址（在哪里），数组元素大小（是什么），数组元素个数（有几个）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(void*data, size_tdatasize,size_tdatanum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意，这个时候要多想！data会不会是空？我们是要看看的！类似的，我们再次构造一个错误码模块：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        之后的流程相比就很简单了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F;。。。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Ok，到这里，我们要开始准备初始化了，不同于标准的，默认的工厂函数，我们这里直接就是有数据的！因此，需要直接开始拷贝！</p><p>​        <strong>注意：不建议直接把data的地址交给DataPiece直接托管！！！！！！！！！！！！之后的我们的操作可能会使数据抹除，但是DataPiece还记得，贸然的直接托管会导致非法访问内存！</strong></p><p>​        所以：我们单独为数据准备一块空间：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* pro_usable_data &#x3D; malloc(datasize * datanum*1.5);&#x2F;&#x2F;预留一些空间if(!pro_usable_data)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        养成随手判断空的好习惯（乐）。</p><p>​        然后，拿出我们的memcpy，这是因为我们的数据可能啥都是，指定一个类型会使得我们的动态数组丧失通用性！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">memcpy(    pro_usable_data,     &#x2F;&#x2F;dst : 我们的预留空间    data,         &#x2F;&#x2F;rsc : 我们的来源：静态数组    datasize * datanum&#x2F;&#x2F;多大？很是显然！个数乘上大小      );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后初始化</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">pro_usable_space-&gt;DataPiece         &#x3D; pro_usable_data; &#x2F;&#x2F;将拷贝的空间交给dataPiece托管pro_usable_space-&gt;current_size      &#x3D; datanum;pro_usable_space-&gt;Single_Data_size  &#x3D; datasize;pro_usable_space-&gt;total_usable_size &#x3D; 1.5 * datanum;&#x2F;&#x2F;开辟多大就给多大return pro_usable_space;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复制工厂函数"><a href="#复制工厂函数" class="headerlink" title="复制工厂函数"></a>复制工厂函数</h4><p>​            我们可以模仿C++ STL里面的复制构造：协同上面的升级函数一样，这里不过多的废话！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* Init_A_DynamicArray_by_CopyADyarr(DynamicArray*dyarr_copied)&#123;&#x2F;&#x2F;检查来源是否合法    if (!dyarr_copied)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;             &#x2F;&#x2F;准备空间并检查DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;    void* pro_usable_data &#x3D; MALLOCDYARR(        char, &#x2F;&#x2F;一个字节单位        (dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size)&#x2F;&#x2F;多大？还是一样嘛！    );if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;    &#x2F;&#x2F;拷贝数据pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;memcpy(        pro_usable_space-&gt;DataPiece, &#x2F;&#x2F;dst : 我们的预留空间        dyarr_copied-&gt;DataPiece, &#x2F;&#x2F; rsc: 来源：显然是被拷贝的dataPiece        dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size    );    &#x2F;&#x2F;初始化与托管数据pro_usable_space-&gt;current_size &#x3D; dyarr_copied-&gt;current_size;pro_usable_space-&gt;Single_Data_size &#x3D; dyarr_copied-&gt;Single_Data_size;pro_usable_space-&gt;total_usable_size &#x3D; dyarr_copied-&gt;total_usable_size;return pro_usable_space;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，我们的三个基本工厂函数已经做好：可以一览了</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;1 默认的工厂函数DynamicArray* Init_A_DynamicArray(size_texpected_number,size_tdatasize)&#123;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;pro_usable_space-&gt;DataPiece &#x3D; NULL;pro_usable_space-&gt;Single_Data_size &#x3D; datasize;if (expected_number &gt;&#x3D; Dyarr_DEFAULT_MALLOC)pro_usable_space-&gt;total_usable_size &#x3D; expected_number;elsepro_usable_space-&gt;total_usable_size &#x3D; Dyarr_DEFAULT_MALLOC;pro_usable_space-&gt;current_size &#x3D; 0;return pro_usable_space;&#125;&#x2F;&#x2F;2.拷贝工厂函数DynamicArray* Init_A_DynamicArray_by_CopyADyarr(DynamicArray*dyarr_copied)&#123;if (!dyarr_copied)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;void* pro_usable_data &#x3D; MALLOCDYARR(char, (dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size));if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;memcpy(pro_usable_space-&gt;DataPiece, dyarr_copied-&gt;DataPiece, dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size);pro_usable_space-&gt;current_size &#x3D; dyarr_copied-&gt;current_size;pro_usable_space-&gt;Single_Data_size &#x3D; dyarr_copied-&gt;Single_Data_size;pro_usable_space-&gt;total_usable_size &#x3D; dyarr_copied-&gt;total_usable_size;return pro_usable_space;&#125;&#x2F;&#x2F;3.升级工厂函数DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(void*data, size_tdatasize,size_tdatanum)&#123;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;void* pro_usable_data &#x3D; malloc(datasize * datanum*1.5);if(!pro_usable_data)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(pro_usable_data, data, datasize * datanum);pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;pro_usable_space-&gt;current_size &#x3D; datanum;pro_usable_space-&gt;Single_Data_size &#x3D; datasize;pro_usable_space-&gt;total_usable_size &#x3D; 1.5 * datanum;return pro_usable_space;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们已经有了基本的工厂函数，已经有了一个可以可以操作的对象了！不过，我们还提到，动态数组必须有必要的调整函数，防止大量的插入导致空间不足或者是删除导致大量的空间浪费！</p><h4 id="基本调整函数"><a href="#基本调整函数" class="headerlink" title="基本调整函数"></a>基本调整函数</h4><p>​        调整大小，我们首先要拿到希望调整的动态数组，以及我们想要调成多大！函数的原型，显然易见：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        为了使程序更加健壮，我们还是返回一个NORMAL的FLAG值表示程序逻辑正常，从而更好的调整程序，这里，我先把enum列举列齐：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Error Code Meaning&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0&#x2F;&#x2F;When Error in mallocing Space the program return 1&#x2F;&#x2F;when inputing a NULL we returns -1&#x2F;&#x2F;when inputing a invalid input we returns -2&#x2F;&#x2F;Locations UnFind we returns -3 &#x2F;&#x2F;typedef enum _DynamicFunctionStatues_ &#123;DynamicArray_Normal &#x3D; 0,&#x2F;&#x2F;正常返回DynamicArray_ERROR_IN_MALLOCING_SPACE&#x3D;1,&#x2F;&#x2F;错误1：开辟空间失败DynamicArray_NULL_INPUT&#x3D;-1,&#x2F;&#x2F;错误-1：传入空值DynamicArray_Invalid_Input&#x3D;-2,&#x2F;&#x2F;错误-2： 传入不合法的值DynamicArray_UnFind&#x3D;-3, &#x2F;&#x2F;错误值-3 没有找到（后面没有使用，这里就算遗留了）DynamicArray_Invalid_Free&#x3D;-4&#x2F;&#x2F;错误值-4 不合法的释放，后面删减的时候会用到&#125;DynamicArrayFunctionStatues;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        以及错误提示宏：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define SHOW_ERROR_DynamicArray_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)#define SHOW_ERROR_DynamicArray_UnFind printf(&quot;\nPositions unfind!\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        其他所有的空返回函数全部就会升级成状态标识函数：只需要我们返回的是：DynamicArrayFunctionStatues枚举下的值（有点伤心，如果是C++11以上，我们可以使用Enum 作用域这个概念了）就好了。函数就改成了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，我们的框架又可以搭建起来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)&#123;    &#x2F;&#x2F;经典检查if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;    ...&#x2F;&#x2F;Do something     return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于调整函数，我们实际上就是在调整数组的堆空间，这下马上就知道函数的核心是什么了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* newspace &#x3D; realloc(dataPiece, new_size)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不错，就是realloc函数！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;调整void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, wished_new_space_size * (dyarr-&gt;Single_Data_size));&#x2F;&#x2F;检查空间是否合法if (newspace &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         然后就是托管，和调整结构体参数：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">dyarr-&gt;DataPiece &#x3D; newspace;&#x2F;&#x2F;空间托管dyarr-&gt;total_usable_size &#x3D; wished_new_space_size;&#x2F;&#x2F;调整usable space<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        别跑，还先别返回正常状态，我们想一个问题，万一，我们的函数当前数据大于了可用空间怎么办？既然是就想要这么多，我们何不妨：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (dyarr-&gt;current_size &gt; dyarr-&gt;total_usable_size)&#123;    dyarr-&gt;current_size &#x3D; dyarr-&gt;total_usable_size;&#x2F;&#x2F;调整至正好满溢的状态，后面的数据直接截断归还给操作系统&#125;&#x2F;&#x2F;Used when still unable to contain data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        活干完了，返回正常状态！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="总体一览工厂函数与基本调整函数："><a href="#总体一览工厂函数与基本调整函数：" class="headerlink" title="总体一览工厂函数与基本调整函数："></a>总体一览工厂函数与基本调整函数：</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, wished_new_space_size * (dyarr-&gt;Single_Data_size));if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;total_usable_size &#x3D; wished_new_space_size;if (dyarr-&gt;current_size &gt; dyarr-&gt;total_usable_size)dyarr-&gt;current_size &#x3D; dyarr-&gt;total_usable_size;&#x2F;&#x2F;Used when still unable to contain datareturn DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增（加）函数一览"><a href="#增（加）函数一览" class="headerlink" title="增（加）函数一览"></a>增（加）函数一览</h3><p>​        终于，我们可以进行增删查改了！先来看增函数！</p><p>​        增加：一个数据？一堆数据？是往后面加，还是插入式的加？这就引出了四个基本函数：我们先来最简单的追加一个数据！</p><h4 id="追加单个"><a href="#追加单个" class="headerlink" title="追加单个"></a>追加单个</h4><p>​        我们仔细问问自己，追加的数据，有多大？玩意要满溢了，要不要调整？OK！我们一个一个按照程序的进行考虑！首先思考函数的原型：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tdatasize);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        很容易想到吧！我们往哪里插入，插入什么！就是我们的参数列表吧！</p><p>​        好，检查来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        完事了？肯定没有！我们试想一下，用户可能在不知情的情况下，传入一个完全不是本类型的数据进来：怎么办？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (sizeof(data) !&#x3D; dyarr-&gt;Single_Data_size) &#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        挺好，我们进一步想啊，数据进来了：万一溢出来，怎么办？</p><p>​        别怕，我们不是已经有了调整函数了嘛！调整一下就好了！（不过这里没有用，开销不必要）</p><p>​        现在，数据准备入列！我们准备一块空间：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* Afteradd_piece &#x3D; realloc(    dyarr-&gt;DataPiece,     (dyarr-&gt;current_size + 1)*dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        入列咯！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;拷贝memcpy(       &#x2F;&#x2F;注意：我们插入到尾部：那就是第I-1的后面，(char*)Afteradd_piece + dyarr-&gt;current_size * dyarr-&gt;Single_Data_size, &#x2F;&#x2F;拷贝Data        data,        &#x2F;&#x2F;拷贝Single_Data_size大小，或者sizeof(data)，这个随意！dyarr-&gt;Single_Data_size);&#x2F;&#x2F;刷新结构体值dyarr-&gt;DataPiece &#x3D; Afteradd_piece;dyarr-&gt;current_size++;&#x2F;&#x2F;任务完成，返回状态Flagreturn DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="尾插多个数据函数1：尾插相同数据"><a href="#尾插多个数据函数1：尾插相同数据" class="headerlink" title="尾插多个数据函数1：尾插相同数据"></a>尾插多个数据函数1：尾插相同数据</h4><p>​        那插入一堆值，也是如此了！我们在尾插的时候，可以开发出来两个函数：一个是尾插一堆一样的值！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        一个是尾插一个数组，有点像Update升级函数了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data_array, size_tarray_num, size_tpos,size_tdata_inarray_size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        一个个来！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;检查if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)    &#123;        &#x2F;&#x2F;先预备好空间，因为大量数据准备入场        Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面是扩展多大空间的问题：我们扩展是按照比例扩展的，那就需要计算比例：再传入调整函数！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)&#123;    Resize_The_Dynamic_Array(        dyarr,         (datarate + 1) * dyarr-&gt;total_usable_size    );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        预留，托管和拷贝：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* newspace &#x3D; realloc(    dyarr-&gt;DataPiece,     (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;for (int i &#x3D; 0; i &lt; n_repeat; i++)&#123;    &#x2F;&#x2F;逐个拷贝    memcpy(        &#x2F;&#x2F;插入到后面的第I+cur_size个位置上，第一个插入结束就要插入到后面一个(char*)newspace + (dyarr-&gt;current_size+i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);&#125;dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="尾插一个数组函数"><a href="#尾插一个数组函数" class="headerlink" title="尾插一个数组函数"></a>尾插一个数组函数</h4><p>​        而同类型的数组拷贝推入逻辑上是一样的：但是我们不得不遍历目标数组，再逐个插入</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data_array, size_tarray_num, size_tpos,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (data_inarray_size !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)&#123;        Resize_The_Dynamic_Array(            dyarr,             (DataRate + 1) * dyarr-&gt;total_usable_size        );    &#125;void* newspace &#x3D; realloc(        dyarr-&gt;DataPiece,         (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size    );if(!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;for (int i &#x3D; 0; i &lt; array_num; i++)memcpy(        &#x2F;&#x2F;插入到后面的第I+cur_size个位置上，第一个插入结束就要插入到后面一个(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,        &#x2F;&#x2F;这个是数组的，写成&amp;data_array[i]也是无伤大雅的(char*)data_array + i * (dyarr-&gt;Single_Data_size),        &#x2F;&#x2F;拷贝的大小dyarr-&gt;Single_Data_size);    &#x2F;&#x2F;调整大小dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面就是有点难度的插入增函数了：我们这样想，我们需要把一个元素插入到目标动态数组的pos位置上。那：使用memmove把想要插入的位置后面的所有数据挪动一个元素大小的位置，那么，目标位置就空出来了一个位置虚以待坐了！前面的工作不再多说了：</p><h4 id="插入一个元素函数"><a href="#插入一个元素函数" class="headerlink" title="插入一个元素函数"></a>插入一个元素函数</h4><p>​        函数的原型：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data, size_tpos)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        检查：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * (dyarr-&gt;total_usable_size));void* Afteradd_piece&#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F;。。。    return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        OK，我们开始让后面的数据挪动他们的屁股！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">memcpy(    &#x2F;&#x2F;拷贝到pos+1位置处(char*)dyarr-&gt;DataPiece + (pos + 1) * dyarr-&gt;Single_Data_size,    &#x2F;&#x2F;从pos往后的数据(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,    &#x2F;&#x2F;大小计算是个数学问题：不过就是那种从i到j有几个数字的问题：j-i+1个！dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - pos + 1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后把数据请进来：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">memmove((char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;current_size++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         然后嘞：宣布我们干完活了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="插入若干数据函数1：插入数组"><a href="#插入若干数据函数1：插入数组" class="headerlink" title="插入若干数据函数1：插入数组"></a>插入若干数据函数1：插入数组</h4><p>​        于是，插入一堆数据，还是一个原理的！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(DynamicArray*dyarr,size_tpos,void*data_array, size_tarray_num,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (!dyarr-&gt;current_size)&#123;Push_Back_Some_data_Into_A_Dynamic_Array(dyarr, data_array, array_num, pos,data_inarray_size);return DynamicArray_Normal;&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove(        &#x2F;&#x2F;预留array_num个位置(char*)dyarr-&gt;DataPiece + (pos + array_num) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*array_num);for (int i &#x3D; 0; i &lt; array_num; i++)memcpy(        &#x2F;&#x2F;从目标位往后拷贝(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,        &#x2F;&#x2F;这个是数组的，写成&amp;data_array[i]也是无伤大雅的(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="插入若干数据：相同数据"><a href="#插入若干数据：相同数据" class="headerlink" title="插入若干数据：相同数据"></a>插入若干数据：相同数据</h4><p>​        还是一样，直接上代码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)&#x2F;&#x2F;DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize,size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + n_repeat) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * n_repeat);for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (pos + i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拼接动态数组"><a href="#拼接动态数组" class="headerlink" title="拼接动态数组"></a>拼接动态数组</h4><p>​        欸嘿！我们可不可以拼接一下两个动态数组呢？可以啊！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray*dyarr_be_appended,DynamicArray*exp_append_array)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这下很容易了：我们的dataPiece直接延后exp_append_array-&gt;current_size个，再拷贝就完事咯！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray*dyarr_be_appended,DynamicArray*exp_append_array)&#123;if (!dyarr_be_appended &amp;&amp; !exp_append_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;&#x2F;&#x2F;跟插入大量数据是一个道理的！int datarate &#x3D; exp_append_array-&gt;current_size &#x2F; dyarr_be_appended-&gt;total_usable_size;if (        dyarr_be_appended-&gt;current_size         &#x3D;&#x3D;         dyarr_be_appended-&gt;total_usable_size    )&#123;        Resize_The_Dynamic_Array(            dyarr_be_appended,             2 * dyarr_be_appended-&gt;total_usable_size        );    &#125;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr_be_appended, (datarate + 1) * dyarr_be_appended-&gt;total_usable_size);void* AfterAppend &#x3D; realloc(dyarr_be_appended-&gt;DataPiece,        &#x2F;&#x2F;这一大长串就是两个动态数组一共的大小！        (dyarr_be_appended-&gt;current_size + exp_append_array-&gt;current_size) * dyarr_be_appended-&gt;Single_Data_size);if (!AfterAppend)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr_be_appended-&gt;DataPiece &#x3D; AfterAppend;memcpy(&#x2F;&#x2F;目标地：被追加的数组的尾部        (char*)dyarr_be_appended-&gt;DataPiece +         dyarr_be_appended-&gt;current_size * dyarr_be_appended-&gt;Single_Data_size,        &#x2F;&#x2F;源头：被拷贝的数组(char*)exp_append_array-&gt;DataPiece,        &#x2F;&#x2F;大小：被拷贝数组的大小exp_append_array-&gt;current_size * exp_append_array-&gt;Single_Data_size);    &#x2F;&#x2F;调整大小dyarr_be_appended-&gt;current_size +&#x3D; exp_append_array-&gt;current_size;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一览增（加）函数"><a href="#一览增（加）函数" class="headerlink" title="一览增（加）函数"></a>一览增（加）函数</h4><p>OK，我们再一览我们的成果就好了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a data into the Dynamic Array&#x2F;&#x2F;Use like this: Push_Back_Into_A_Dynamic_Array(dyarr,data)&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data,size_tdatasize)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size) &#123;printf(&quot;%d &quot;, sizeof(data));SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 1.3 * (dyarr-&gt;total_usable_size));void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1)*dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy((char*)Afteradd_piece + dyarr-&gt;current_size * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; Afteradd_piece;dyarr-&gt;current_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(dyarr,data,the_time_data_repeated,sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (dyarr-&gt;current_size+i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has a organiztion with static array&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(&#x2F;&#x2F;dyarr,&#x2F;&#x2F;data,&#x2F;&#x2F;how_many_data_are_there_in_static_array,&#x2F;&#x2F;sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data_array, size_tarray_num, size_tpos,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (data_inarray_size !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if(!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;for (int i &#x3D; 0; i &lt; array_num; i++)memcpy((char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Insert back a data &#x2F;&#x2F; use like this: &#x2F;&#x2F; Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; data, &#x2F;&#x2F; where_to_insert,&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data, size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * (dyarr-&gt;total_usable_size));void* Afteradd_piece&#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy((char*)dyarr-&gt;DataPiece + (pos + 1) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos+1));memmove((char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;current_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)&#x2F;&#x2F;DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize,size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + n_repeat) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * n_repeat);for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (pos + i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back some data that organized in static array&#x2F;&#x2F;use like this: Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; where_to_insert, &#x2F;&#x2F; data, &#x2F;&#x2F; how_many_data_are_there_in_static_array,&#x2F;&#x2F; sizeof(data)&#x2F;&#x2F;)&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(DynamicArray*dyarr,size_tpos,void*data_array, size_tarray_num,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (!dyarr-&gt;current_size)&#123;Push_Back_Some_data_Into_A_Dynamic_Array(dyarr, data_array, array_num, pos,data_inarray_size);return DynamicArray_Normal;&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + array_num) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*array_num);for (int i &#x3D; 0; i &lt; array_num; i++)memcpy((char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Append another dynamic Array&#x2F;&#x2F; use like this:&#x2F;&#x2F; AppendByMergeDynamicArray(dyarr_be_appended, exp_append_array)&#x2F;&#x2F;DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray*dyarr_be_appended,DynamicArray*exp_append_array)&#123;if (!dyarr_be_appended &amp;&amp; !exp_append_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;int datarate &#x3D; exp_append_array-&gt;current_size &#x2F; dyarr_be_appended-&gt;total_usable_size;if (dyarr_be_appended-&gt;current_size &#x3D;&#x3D; dyarr_be_appended-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr_be_appended, 2 * dyarr_be_appended-&gt;total_usable_size);if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr_be_appended, (datarate + 1) * dyarr_be_appended-&gt;total_usable_size);void* AfterAppend &#x3D; realloc(dyarr_be_appended-&gt;DataPiece,(dyarr_be_appended-&gt;current_size + exp_append_array-&gt;current_size) * dyarr_be_appended-&gt;Single_Data_size);if (!AfterAppend)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr_be_appended-&gt;DataPiece &#x3D; AfterAppend;memcpy((char*)dyarr_be_appended-&gt;DataPiece + dyarr_be_appended-&gt;current_size * dyarr_be_appended-&gt;Single_Data_size,(char*)exp_append_array-&gt;DataPiece,exp_append_array-&gt;current_size * exp_append_array-&gt;Single_Data_size);dyarr_be_appended-&gt;current_size +&#x3D; exp_append_array-&gt;current_size;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删减函数"><a href="#删减函数" class="headerlink" title="删减函数"></a>删减函数</h3><p>​        就像人生需要做减法一样，我们也要给我们的数据结构提供删减操作！</p><h4 id="尾删除函数（删减一个）"><a href="#尾删除函数（删减一个）" class="headerlink" title="尾删除函数（删减一个）"></a>尾删除函数（删减一个）</h4><p>​        不删减多个，不水代码！</p><p>​        很简单，我们只需要size—就好了！之后再次增加的时候会直接覆盖，同时，若是删减过多可以在后续直接调用Resize函数！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray*dyarr)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="直接清除函数（直接清空）"><a href="#直接清除函数（直接清空）" class="headerlink" title="直接清除函数（直接清空）"></a>直接清除函数（直接清空）</h4><p>​        一个思路，但是，这次由于是清空，我们直接free掉数据！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Clear_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size &#x3D; 0;if (!dyarr-&gt;DataPiece)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;printf(&quot;VOID DATA SHOULDN&#39;T BE FREE!&quot;);exit(DynamicArray_Invalid_Free);&#125;    &#x2F;&#x2F;预留一个位置，便于后期操作！void* pro_usable_space&#x3D; realloc(dyarr-&gt;DataPiece, dyarr-&gt;Single_Data_size);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece&#x3D;pro_usable_space;dyarr-&gt;total_usable_size &#x3D; 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除一个数据（指定一个位置）"><a href="#删除一个数据（指定一个位置）" class="headerlink" title="删除一个数据（指定一个位置）"></a>删除一个数据（指定一个位置）</h4><p>​        我们怎么删除数组里的一个数据呢？只需要回顾到Insert函数的操作，我们反过来，让pos后面的数据往前移动一个！不久把数据盖上了嘛！随后size—就是我们想要的结果！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tpos)&#123;    &#x2F;&#x2F;检查if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;    &#x2F;&#x2F;直接拷贝覆盖跑路！memcpy((char*)dyarr-&gt;DataPiece+pos*dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece+(pos+1)*dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos-1));    &#x2F;&#x2F;size--，防止访问到奇怪的数据！dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除一些数据"><a href="#删除一些数据" class="headerlink" title="删除一些数据"></a>删除一些数据</h4><p>​        这个难度稍大一点：关键在于，如果我们删除了大量的数据，我们需要调用Resize函数来释放多余的空间，这样可以优化内存占用！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase some specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tBeginpos, size_tEndpos)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Beginpos &lt; 0 || Beginpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (Endpos &lt; 0 || Endpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece + Beginpos * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (Endpos + 1) * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - Endpos + 1));dyarr-&gt;current_size -&#x3D; Endpos - Beginpos + 1;    &#x2F;&#x2F;开始调整大小！if (dyarr-&gt;current_size &lt;&#x3D; dyarr-&gt;total_usable_size &#x2F; 4 &amp;&amp; dyarr-&gt;total_usable_size &gt; 5)&#123;Resize_The_Dynamic_Array(dyarr, dyarr-&gt;total_usable_size &#x2F; 2);dyarr-&gt;total_usable_size &#x2F;&#x3D; 2;&#125;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="直接删掉整个动态数组的函数："><a href="#直接删掉整个动态数组的函数：" class="headerlink" title="直接删掉整个动态数组的函数："></a>直接删掉整个动态数组的函数：</h4><p>​        注意：我们先释放数据，再释放本身！不然会造成内存泄漏！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;exit(DynamicArray_Invalid_Free);&#125;free(dyarr-&gt;DataPiece);free(dyarr);return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一览删除函数："><a href="#一览删除函数：" class="headerlink" title="一览删除函数："></a>一览删除函数：</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray*dyarr)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Clear_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Clear_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size &#x3D; 0;if (!dyarr-&gt;DataPiece)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;printf(&quot;VOID DATA SHOULDN&#39;T BE FREE!&quot;);exit(DynamicArray_Invalid_Free);&#125;void* pro_usable_space&#x3D; realloc(dyarr-&gt;DataPiece, dyarr-&gt;Single_Data_size);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece&#x3D;pro_usable_space;dyarr-&gt;total_usable_size &#x3D; 1;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements! and unable to be used again!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Destroy_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;exit(DynamicArray_Invalid_Free);&#125;free(dyarr-&gt;DataPiece);free(dyarr);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tpos)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece+pos*dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece+(pos+1)*dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos-1));dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase some specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tBeginpos, size_tEndpos)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Beginpos &lt; 0 || Beginpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (Endpos &lt; 0 || Endpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece + Beginpos * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (Endpos + 1) * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - Endpos + 1));dyarr-&gt;current_size -&#x3D; Endpos - Beginpos + 1;if (dyarr-&gt;current_size &lt;&#x3D; dyarr-&gt;total_usable_size &#x2F; 4 &amp;&amp; dyarr-&gt;total_usable_size &gt; 5)&#123;Resize_The_Dynamic_Array(dyarr, dyarr-&gt;total_usable_size &#x2F; 2);dyarr-&gt;total_usable_size &#x2F;&#x3D; 2;&#125;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打印内容与处理其内数据函数系列"><a href="#打印内容与处理其内数据函数系列" class="headerlink" title="打印内容与处理其内数据函数系列"></a>打印内容与处理其内数据函数系列</h3><h4 id="打印操作"><a href="#打印操作" class="headerlink" title="打印操作"></a>打印操作</h4><p>​        打印数据是我们常用的与数据交互的操作，我们正是需要这个东西来看看我们的数据如何：注意到，我们打印的可能不是整数，可能不是字符，而是任何东西！那么，我们所作的，只是提供一个函数接口！至于怎么打印，让用户自己看着办！为了方便打字，为了防止用户花式整出来奇形八怪的Print接口，我们统一 一个！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void(* MyPrint )(void*)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个是函数指针别名的经典写法，如果你不熟悉，可以从这里看：比若说，我要指定一个类型，给他起个别名便于我们后续写程序提醒与应用（工程上常常这么做！提醒自己这个是干嘛的的）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef int MyInt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这就是说：MyInt是我自己起的一个类型，但是本质上就是Int！它可以跟int 起到完全一致的效果！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    int a &#x3D; 1;    MyInt b &#x3D; 1;&#x2F;&#x2F; Legal!&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        而这个：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void(* MyPrint )(void*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        就是一个函数指针（说白了，就是一个接受一个任意数据啥都不返回的函数！）的别名，这样写，你可能会更有感觉：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void(*)(void*) MyPrint ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        于是，我们的打印函数就有了点可行的想法了！</p><h4 id="打印一个数据（指定位置）"><a href="#打印一个数据（指定位置）" class="headerlink" title="打印一个数据（指定位置）"></a>打印一个数据（指定位置）</h4><p>​        这个函数可以和后面的返回位置的查找函数搭配使用！我们的这个函数打印动态数组里的一个元素！函数肯定的：需要一个动态数组！需要位置！需要打印方式！原型直接出来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray*dyarr, MyPrint&#x2F;*就是函数指针，说白了就是打印方式传进来*&#x2F;user_print, size_tpos) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是检查：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;    ...        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为了让打印好看点，我们加入表示语句：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;\nSpecific Data is Shown:\n&quot;);...&#x2F;&#x2F;here we printprintf(&quot;\nSpecific Data Finished Showing!\n&quot;);return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于函数的调用，我们使用（）调用！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">user_print(    (char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        为什么这样写？注意，我们必须转化void* 为具体的指针来对指针进行加减操作！否则不合法！，而操作程度最小的指针就是char指针！于是，我们使用：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">(char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定位到我们想要打印到的位置！之后解引用的方式（决定访问步长，这是指针的一个应用本质）是由用户决定的！</p><p>​        看看成品：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray*dyarr, MyPrintuser_print, size_tpos) &#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;printf(&quot;\nSpecific Data is Shown:\n&quot;);user_print((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));printf(&quot;\nSpecific Data Finished Showing!\n&quot;);return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="打印所有数据"><a href="#打印所有数据" class="headerlink" title="打印所有数据"></a>打印所有数据</h4><p>​        我说停！先别开工！我们引入一个enum，让用户传入一个参数来决定要不要更好的打印我们的数据！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;A switch that used in better Print in Dynamic Array!&#x2F;&#x2F;Often use OPEN to beautify the control table&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_dyarr_ &#123;Dyarr_OPEN &#x3D; 1,Dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_dyarr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        之后？就是遍历咯！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print All data&#x2F;&#x2F; use like this&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(DynamicArray*dyarr,MyPrintuser_print,BetterPrintSwitch_for_dyarrwhether_better_print)&#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;    &#x2F;&#x2F;要不要更好的打印？if(whether_better_print&#x3D;&#x3D;Dyarr_OPEN)&#123;printf(&quot;\nStart Printing\n&quot;);&#125;    &#x2F;&#x2F;遍历！for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;        &#x2F;&#x2F;函数名跟数组名一样！本质上还是指针，所以，无所谓解不解引用(*user_print)(            &#x2F;&#x2F;打印第I个            (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)        );&#125;if (whether_better_print &#x3D;&#x3D; Dyarr_OPEN)&#123;printf(&quot;\nFinish Printing\n&quot;);&#125;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="处理数据（单个多个）"><a href="#处理数据（单个多个）" class="headerlink" title="处理数据（单个多个）"></a>处理数据（单个多个）</h4><p>​        仿照Print思路，这一次，我们使用Do_Specific_Change函数指针！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void*(*Do_Specific_Change)(void*);&#x2F;&#x2F;返回void也行，主要考虑扩展接口的问题，后续可能自己定义函数要继续操作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这次不在多说！一样的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in all data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change) &#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)user_change(        &#x2F;&#x2F;处理第I个数据        (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)    );return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change, size_tpos)&#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;user_change((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="打印内容与处理其内数据函数系列一览"><a href="#打印内容与处理其内数据函数系列一览" class="headerlink" title="打印内容与处理其内数据函数系列一览"></a>打印内容与处理其内数据函数系列一览</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray*dyarr, MyPrintuser_print, size_tpos) &#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;printf(&quot;\nSpecific Data is Shown:\n&quot;);user_print((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));printf(&quot;\nSpecific Data Finished Showing!\n&quot;);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print All data&#x2F;&#x2F; use like this&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(DynamicArray*dyarr,MyPrintuser_print,BetterPrintSwitch_for_dyarrwhether_better_print)&#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;    &#x2F;&#x2F;要不要更好的打印？if(whether_better_print&#x3D;&#x3D;Dyarr_OPEN)&#123;printf(&quot;\nStart Printing\n&quot;);&#125;    &#x2F;&#x2F;遍历！for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;        &#x2F;&#x2F;函数名跟数组名一样！本质上还是指针，所以，无所谓解不解引用(*user_print)(            &#x2F;&#x2F;打印第I个            (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)        );&#125;if (whether_better_print &#x3D;&#x3D; Dyarr_OPEN)&#123;printf(&quot;\nFinish Printing\n&quot;);&#125;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in all data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change) &#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)user_change(        &#x2F;&#x2F;处理第I个数据        (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)    );return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change, size_tpos)&#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;user_change((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询状况与数据函数一览"><a href="#查询状况与数据函数一览" class="headerlink" title="查询状况与数据函数一览"></a>查询状况与数据函数一览</h3><h4 id="查询动态数组是否为空函数"><a href="#查询动态数组是否为空函数" class="headerlink" title="查询动态数组是否为空函数"></a>查询动态数组是否为空函数</h4><p>​        呃，最简单了哈哈：不过注意，在C89的时候还没有布尔类型！我们需要自己手搓一个：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Mybool defined&#x2F;&#x2F;typedef enum _bool_ &#123;True &#x3D; 1,False &#x3D; 0&#125;Bool;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        用起来咯！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in judging whether the dynamic array is empty&#x2F;&#x2F; use like this:&#x2F;&#x2F; isEmpty_InDynamicArray(dyarr)&#x2F;&#x2F;Bool isEmpty_InDynamicArray(DynamicArray*dyarr) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (dyarr-&gt;current_size&#x3D;&#x3D;0)return True;return False;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询特定元素是否存在"><a href="#查询特定元素是否存在" class="headerlink" title="查询特定元素是否存在"></a>查询特定元素是否存在</h4><p>​        咳咳，难度来了：对于任意的数据，我们怎么知道他们符不符合要求：相等呢？嘛！这个简单，用户决定嘛！</p><p>​        还是一样，我们统一一个函数指针：其返回值类型是专门用来标记是否存在的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef unsigned int Is_Used_Compared_Int;&#x2F;&#x2F;返回类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这下函数原型好说了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues isLocateinDyarr(DynamicArray* dyarr,void*data,LocateFuncuser_func)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        老老老样子，判判判判断！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遍历一下咯！不过为了提高程序可阅读性质：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;this type of int is specifically used in Returning Find Or Unfind.&#x2F;&#x2F;Recommmend to be used as a nickname:)&#x2F;&#x2F;Can use Find or Unfind to return the result&#x2F;&#x2F;typedef enum _DynamicArray_isFind_ &#123;Find&#x3D; 1,Unfind&#x3D; -1&#125;DynamicArray_isFind;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if (user_func(        &#x2F;&#x2F;check the Ith one        (char*)dyarr-&gt;DataPiece +        i * dyarr-&gt;Single_Data_size,         data    )&#x2F;&#x2F;if found return Find)&#123;return Find;&#125;&#125;return Unfind;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="返回第一次遇到的位置"><a href="#返回第一次遇到的位置" class="headerlink" title="返回第一次遇到的位置"></a>返回第一次遇到的位置</h4><p>​        跟上面很类似捏：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues returnAElembyPos_inDyarr(DynamicArray*dyarr, void*data, LocateFuncuser_func) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if ( &#x2F;&#x2F;check the Ith one            user_func            (            (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size,            data            )        )&#123;&#x2F;&#x2F; if found return i(the position)return i;&#125;&#125;return Unfind;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="存储位置的动态数组及其API"><a href="#存储位置的动态数组及其API" class="headerlink" title="存储位置的动态数组及其API"></a>存储位置的动态数组及其API</h4><p>​        这个是为了下面做铺垫！原理一致，只展现API！</p><h6 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h6><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _Dyarrposarr_ &#123;int* posSpace;size_t pos_size;&#125;Position_Stored_Dynamic_ArrayFordyarr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="更好的打印开关枚举定义："><a href="#更好的打印开关枚举定义：" class="headerlink" title="更好的打印开关枚举定义："></a>更好的打印开关枚举定义：</h6><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Want a better Print to beutify your control table? try this one&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;PSDA_dyarr_OPEN &#x3D; 1,PSDA_dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_pos_dyarr;&#x2F;&#x2F;can use this type when indicating the type&#x2F;&#x2F;typedef unsigned int BetterPrintfor_PosDyarr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-1：创造一个存储位置的动态数组"><a href="#API-1：创造一个存储位置的动态数组" class="headerlink" title="API 1：创造一个存储位置的动态数组"></a>API 1：创造一个存储位置的动态数组</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr()&#123;Position_Stored_Dynamic_ArrayFordyarr* pro_usable_space         &#x3D;         MALLOCDYARR(Position_Stored_Dynamic_ArrayFordyarr, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;  pro_usable_space-&gt;posSpace &#x3D; NULL;pro_usable_space-&gt;pos_size &#x3D; 0;return pro_usable_space;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-2：打印所有的位置："><a href="#API-2：打印所有的位置：" class="headerlink" title="API 2：打印所有的位置："></a>API 2：打印所有的位置：</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;DynamicArrayFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarr   Whether_Better_Print)&#123;if (!posarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nPositions are shown! :\n&quot;);for (int i &#x3D; 0; i &lt; posarr-&gt;pos_size; i++)printf(&quot;%u &quot;, posarr-&gt;posSpace[i]);if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nFinish Printing!\n&quot;);return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-3：推入一个位置"><a href="#API-3：推入一个位置" class="headerlink" title="API 3：推入一个位置"></a>API 3：推入一个位置</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to push back a position into the Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_a_locations_in_PSDA_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr, intpos_acquired)&#123;int* pro_usable_space &#x3D; (int*)realloc(posarr-&gt;posSpace, sizeof(int) * (posarr-&gt;pos_size + 1));if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;posarr-&gt;posSpace &#x3D; pro_usable_space;posarr-&gt;posSpace[posarr-&gt;pos_size] &#x3D; pos_acquired;posarr-&gt;pos_size++;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API4：统计个数"><a href="#API4：统计个数" class="headerlink" title="API4：统计个数"></a>API4：统计个数</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to return the number of locations&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;size_t Get_pos_size_From_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarrWhether_Shown_Print )&#123;if (!posarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Whether_Shown_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nCurrent targeted data&#39;s total num is:%u!\n&quot;,posarr-&gt;pos_size);return posarr-&gt;pos_size;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-5：销毁一个存储位置的动态数组"><a href="#API-5：销毁一个存储位置的动态数组" class="headerlink" title="API 5：销毁一个存储位置的动态数组"></a>API 5：销毁一个存储位置的动态数组</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;Erase a dynamic Array when donot using it!&#x2F;&#x2F;DynamicArrayFunctionStatues DesTroy_A_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*pointer_to_wishedfreeposarr)&#123;if (!pointer_to_wishedfreeposarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_Invalid_Free);&#125;free(pointer_to_wishedfreeposarr-&gt;posSpace);free(pointer_to_wishedfreeposarr);pointer_to_wishedfreeposarr &#x3D; NULL;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-6：返回指定位置的标记位置"><a href="#API-6：返回指定位置的标记位置" class="headerlink" title="API 6：返回指定位置的标记位置"></a>API 6：返回指定位置的标记位置</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;return a pos that is targeted!&#x2F;&#x2F;DynamicArrayFunctionStatues getPosbyPosinPSDA(Position_Stored_Dynamic_ArrayFordyarr*getter,size_t pos) &#123;if (!getter) &#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_Invalid_Free);&#125;if (pos &gt; getter-&gt;pos_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;for (int i &#x3D; 0; i &lt; pos; i++)return (char*)getter-&gt;posSpace + i * sizeof(size_t);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这些API很简单，我不阐述原理了！</p><h4 id="返回多个位置函数"><a href="#返回多个位置函数" class="headerlink" title="返回多个位置函数"></a>返回多个位置函数</h4><p>​        返回一个简单，返回多个怎么办？存储位置的动态数组嘛！不过，这个是只记载位置的：那就好说了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Position_Stored_Dynamic_ArrayFordyarr* returnABunchofData_inDyarr(DynamicArray*dyarr, Position_Stored_Dynamic_ArrayFordyarr*posArr, void*data, LocateFuncuser_func)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if (                (*user_func)(                    data,                     (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size)            )&#123;                &#x2F;&#x2F;类似于return i，这次往PSDA里return！Push_back_a_locations_in_PSDA_dyarr(posArr，i)&#125;&#125;if (posArr-&gt;pos_size!&#x3D;0)return posArr;return Unfind;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="交换于排序函数系列"><a href="#交换于排序函数系列" class="headerlink" title="交换于排序函数系列"></a>交换于排序函数系列</h3><p>​        我们的排序只涉及冒泡排序！</p><h4 id="交换函数"><a href="#交换函数" class="headerlink" title="交换函数"></a>交换函数</h4><p>​        回忆一下基本的交换方法：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void swapInt(int* e1, int*e2)&#123;    int temp &#x3D; *e1 ;    *e1 &#x3D; *e2;    *e2 &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        基于此：我们还是一样的仿照设计出函数原型：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray*dyarr, size_tpos1, size_tpos2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一次，我们的交换使用memcpy（memmove都可以）(为了演示我交叉使用了)</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;准备空间char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);if(!swapbit)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F; int temp &#x3D; *e1 ;memcpy(swapbit,(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);&#x2F;&#x2F;*e1 &#x3D; *e2;memmove((char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);&#x2F;&#x2F; *e2 &#x3D; temp;memcpy((char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,swapbit,dyarr-&gt;Single_Data_size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        别忘了释放空间：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">free(swapbit);return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>整合看看：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in swap data&#x2F;&#x2F; use like this:&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)&#x2F;&#x2F;DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray*dyarr, size_tpos1, size_tpos2)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);if(!swapbit)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(swapbit,(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memmove((char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memcpy((char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,swapbit,dyarr-&gt;Single_Data_size);free(swapbit);return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="冒泡排序交换函数："><a href="#冒泡排序交换函数：" class="headerlink" title="冒泡排序交换函数："></a>冒泡排序交换函数：</h4><p>​        仿照经典冒泡排序。。。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void bubbleSort(int* arr, int arr_size)&#123;    if(arr&#x3D;&#x3D;NULL)&#123;        return;    &#125;           if(arr_size&lt;&#x3D;1)&#123;        return;    &#125;        for(int i&#x3D;0; i&lt;arr_size-1; i++)    &#123;        for(int j &#x3D; 0;j&lt;arr_size-i-1; j++)        &#123;            if(arr[j]&gt; arr[j+1])            &#123;                swap(arr[j],arr[j+1]);&#x2F;&#x2F;swap不实现了，上面就有            &#125;        &#125;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; sadly that is bubblesort :(&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol&#x2F;&#x2F; use like this:&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues sort_In_Dynamic_Array(DynamicArray*dyarr,CompareFunccompfunc) &#123;    &#x2F;&#x2F;检查if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!compfunc)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size-1; i++)&#123;for (int j &#x3D; 0; j &lt; dyarr-&gt;current_size - i-1; j++)&#123;if (&#x2F;&#x2F;if(arr[j]&gt; arr[j+1])compfunc                ((char*)dyarr-&gt;DataPiece + j * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (j + 1) * dyarr-&gt;Single_Data_size))                &#x2F;&#x2F;swap(arr[j],arr[j+1])swapData_in_DynamicArray(dyarr, j, j + 1);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="交换于排序函数系列一览"><a href="#交换于排序函数系列一览" class="headerlink" title="交换于排序函数系列一览"></a>交换于排序函数系列一览</h4><p>OK，集合一下</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in swap data&#x2F;&#x2F; use like this:&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)&#x2F;&#x2F;DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray*dyarr, size_tpos1, size_tpos2)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);if(!swapbit)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(swapbit,(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memmove((char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memcpy((char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,swapbit,dyarr-&gt;Single_Data_size);free(swapbit);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; sadly that is bubblesort :(&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol&#x2F;&#x2F; use like this:&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues sort_In_Dynamic_Array(DynamicArray*dyarr,CompareFunccompfunc) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!compfunc)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size-1; i++)&#123;for (int j &#x3D; 0; j &lt; dyarr-&gt;current_size - i-1; j++)&#123;if (compfunc((char*)dyarr-&gt;DataPiece + j * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (j + 1) * dyarr-&gt;Single_Data_size))swapData_in_DynamicArray(dyarr, j, j + 1);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试一下子咯！"><a href="#测试一下子咯！" class="headerlink" title="测试一下子咯！"></a>测试一下子咯！</h3><p>测试代码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#include&quot;standard_dynamic_array.h&quot;MyPrint print(int* e1) &#123;printf(&quot;%d &quot;, *e1);&#125;Do_Specific_Change dochange(int* e1) &#123;*e1 &#x3D; *e1 + 1;&#125;LocateFunc loc(int* e1, int* e2) &#123;if (*e1 &#x3D;&#x3D; *e2) &#123;return Find;&#125;return Unfind;&#125;int main()&#123;int data1 &#x3D; 10;    &#x2F;&#x2F;test InitingDynamicArray* testDyarr1 &#x3D; Init_A_DynamicArray(10, Dyarr_SIGINT);    &#x2F;&#x2F;test a Sigdata pushed:Push_Back_Into_A_Dynamic_Array(testDyarr1, &amp;data1);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;test pushing the same dataPush_back_Same_data_Into_A_Dynamic_Array(testDyarr1, &amp;data1, 10, Dyarr_SIGINT);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;Test ClearingClear_A_Dynamic_Array(testDyarr1);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;test updateint data2[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;DynamicArray* test2&#x3D;Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);Print_ALL_Data_In_A_Dynamic_Array(test2, print, Dyarr_OPEN);    &#x2F;&#x2F;test copy:DynamicArray* copyone &#x3D; Init_A_DynamicArray_by_CopyADyarr(test2);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test insertprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Insert_Into_A_Dynamic_Array(copyone, &amp;data1, 1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test insert bunchprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Insert_Some_Data_Into_A_Dynamic_Array(copyone, 1, data2, 10, Dyarr_SIGINT);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Erasing sigoneprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Delete_A_Specific_Data_From_the_DynamicArray(copyone, 1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Erasing bunch oneprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Delete_Some_Specific_Data_From_the_DynamicArray(copyone,1,10);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Do changeprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Do_Specific_Change_To_Specific_Data(copyone,dochange,1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);printf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Do_Specific_Change_To_All_Data(copyone, dochange);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test location:DynamicArray* test3 &#x3D; Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);if (isLocateinDyarr(test3, &amp;data2[2], loc)) &#123;printf(&quot;\nI have found it!\n&quot;);&#125;int where &#x3D; returnAElembyPos_inDyarr(test3, &amp;data2[2], loc);printf(&quot;\nIn dyarr the %d place\n&quot;, where);    &#x2F;&#x2F;test Position Stored Dynamic Array and returnBunchClear_A_Dynamic_Array(test3);Push_back_Same_data_Into_A_Dynamic_Array(test3, &amp;data2[2], 10, Dyarr_SIGINT);Position_Stored_Dynamic_ArrayFordyarr* p1 &#x3D; Init_A_Postion_Stored_Dynamic_ArrayFordyarr();returnABunchofData_inDyarr(test3, p1, &amp;data2[2], loc);Print_ALL_Data_In_A_Dynamic_Array(test3, print, Dyarr_OPEN);Show_All_Locations_In_PSDAfor_dyarr(p1, PSDA_dyarr_OPEN);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">4Start Printing10Finish PrintingStart Printing10 10 10 10 10 10 10 10 10 10 10Finish PrintingStart PrintingFinish PrintingStart Printing1 2 3 4 5 6 7 8 9 10Finish PrintingStart Printing1 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 10 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 10 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 3 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 3 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing2 4 4 5 6 7 8 9 10 11Finish PrintingI have found it!In dyarr the 2 placeStart Printing3 3 3 3 3 3 3 3 3 3Finish PrintingPositions are shown! :0 1 2 3 4 5 6 7 8 9Finish Printing!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230207221151700.png" alt="image-20230207221151700"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据结构模拟：动态数组（1）头文件+源代码+测试</title>
      <link href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="动态数组（1）源代码阅读-注释"><a href="#动态数组（1）源代码阅读-注释" class="headerlink" title="动态数组（1）源代码阅读+注释"></a>动态数组（1）源代码阅读+注释</h1><h4 id="开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））"><a href="#开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））" class="headerlink" title="开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））"></a>开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））</h4><p>​        请注意：使用和调用环境为C语言环境，不！要！用！在！CPP文件里！函数指针返回逻辑不一样lol</p><p>​        下载源文件和MD文件（有代码高亮）可以去我的GitHub上下载！</p><h5 id="头文件一览："><a href="#头文件一览：" class="headerlink" title="头文件一览："></a>头文件一览：</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#defineOPENUPPOSARR 1#define OPENUPDEFAULTSIZE 1#defineQUICKMALLOC 1&#x2F;&#x2F;(General Version)#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;&#x2F;&#x2F;Error Code Meaning&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0&#x2F;&#x2F;When Error in mallocing Space the program return 1&#x2F;&#x2F;when inputing a NULL we returns -1&#x2F;&#x2F;when inputing a invalid input we returns -2&#x2F;&#x2F;Locations UnFind we returns -3 &#x2F;&#x2F;typedef enum _DynamicFunctionStatues_ &#123;DynamicArray_Normal &#x3D; 0,DynamicArray_ERROR_IN_MALLOCING_SPACE &#x3D; 1,DynamicArray_NULL_INPUT &#x3D; -1,DynamicArray_Invalid_Input &#x3D; -2,DynamicArray_UnFind &#x3D; -3,DynamicArray_Invalid_Free &#x3D; -4&#125;DynamicArrayFunctionStatues;&#x2F;&#x2F;Mybool defined&#x2F;&#x2F;typedef enum _bool_ &#123;True &#x3D; 1,False &#x3D; 0&#125;Bool;#define SHOW_ERROR_DynamicArray_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)#define SHOW_ERROR_DynamicArray_UnFind printf(&quot;\nPositions unfind!\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)&#x2F;&#x2F;this type of int is specifically used in Returning Find Or Unfind.&#x2F;&#x2F;Recommmend to be used as a nickname:)&#x2F;&#x2F;Can use Find or Unfind to return the result&#x2F;&#x2F;typedef enum _DynamicArray_isFind_ &#123;Find &#x3D; 1,Unfind &#x3D; 0&#125;DynamicArray_isFind;&#x2F;&#x2F;A switch that used in better Print in Dynamic Array!&#x2F;&#x2F;Often use OPEN to beautify the control table&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_dyarr_ &#123;Dyarr_OPEN &#x3D; 1,Dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_dyarr;&#x2F;&#x2F;Main Definitions about DynamicArray&#x2F;&#x2F;When Programing , not recommend to Change the data directly! &#x2F;&#x2F;typedef struct _DynamicArray_ &#123;void* DataPiece;size_t current_size;size_t total_usable_size;size_t Single_Data_size;&#125;DynamicArray;&#x2F;&#x2F;--------------------------------Default_size_Type--------------------------------------------&#x2F;&#x2F;These abstractions are used to reduce the input&#x2F;&#x2F;used as Dyarr_Default_TYPE(type_number) to replace the code:sizeof(Typename)*type_number#if OPENUPDEFAULTSIZE&#x2F;&#x2F;Single Type size&#x2F;&#x2F;#define Dyarr_SIGINT sizeof(int)#define Dyarr_SIGCHAR sizeof(char)#define Dyarr_SIGFLOAT sizeof(float)#define Dyarr_SIGDOUBLE sizeof(double)#define Dyarr_SIG(dataType) sizeof(dataType)&#x2F;&#x2F;Mutiply type size&#x2F;&#x2F;#define Dyarr_INT_SIZE(X) sizeof(int)*X#define Dyarr_CHAR_SIZE(X) sizeof(char)*X#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X#endif&#x2F;&#x2F;-------------------------------------------QuickMalloc----------------------------------------&#x2F;&#x2F;As the name goes lol&#x2F;&#x2F;#if QUICKMALLOC #define Dyarr_DEFAULT_MALLOC 5#define MALLOCDYARR(datatype,data_num) (datatype*)malloc(sizeof(datatype)*data_num)#endif&#x2F;&#x2F;----------------------------------------STD_FUNC_AND_INT_TYPE----------------------------------&#x2F;&#x2F; Return type of compared functions&#x2F;&#x2F;typedef unsigned int Is_Used_Compared_Int;&#x2F;&#x2F; the pointer type of Print !&#x2F;&#x2F; When Printing , type :&#x2F;&#x2F; MyPrint user_print_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F; &#123;&#x2F;&#x2F;print in your way for your data!&#x2F;&#x2F; &#125;&#x2F;&#x2F;typedef void(*MyPrint)(void*);&#x2F;&#x2F; the pointer type of Making change for the data that has been locates in the Dynamic Array!&#x2F;&#x2F; When want to make some change, type like this:&#x2F;&#x2F; Do_Specific_Change user_dochange_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;do some change here for your data!&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef void* (*Do_Specific_Change)(void*);&#x2F;&#x2F; the pointer type of using when comparing for your data&#x2F;&#x2F; When want to make a comparisons, type like this:&#x2F;&#x2F; CompareFunc user_comp_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;return &#x2F;&#x2F;the wishing compare!&#x2F;&#x2F;&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef Is_Used_Compared_Int(*CompareFunc)(void*, void*);&#x2F;&#x2F; the pointer type of using when checking iflocated for your data&#x2F;&#x2F; When want to make a comparisons, type like this:&#x2F;&#x2F; LocateFunc user_loc_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;return data1&#x3D;&#x3D;data2(define by yourself! if complicated, just return Find or unfind to show whether is found)&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------#if OPENUPPOSARR&#x2F;&#x2F;Main data structure!&#x2F;&#x2F;Used in returning multitude locations&#x2F;&#x2F;typedef struct _Dyarrposarr_ &#123;int* posSpace;size_t pos_size;&#125;Position_Stored_Dynamic_ArrayFordyarr;&#x2F;&#x2F;Want a better Print to beutify your control table? try this one&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;PSDA_dyarr_OPEN &#x3D; 1,PSDA_dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_pos_dyarr;&#x2F;&#x2F;can use this type when indicating the type&#x2F;&#x2F;typedef unsigned int BetterPrintfor_PosDyarr;&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;DynamicArrayFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(Position_Stored_Dynamic_ArrayFordyarr* posarr,BetterPrintfor_PosDyarrWhether_Better_Print);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to push back a position into the Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_a_locations_in_PSDA_dyarr(Position_Stored_Dynamic_ArrayFordyarr* posarr,intpos_acquired);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to return the number of locations&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;size_t Get_pos_size_From_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr* posarr,BetterPrintfor_PosDyarrWhether_Shown_Print);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;Erase a dynamic Array when donot using it!&#x2F;&#x2F;DynamicArrayFunctionStatues DesTroy_A_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr* pointer_to_wishedfreeposarr);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;return a pos that is targeted!&#x2F;&#x2F;void* getPosbyPosinPSDA(Position_Stored_Dynamic_ArrayFordyarr* getter,size_tpos);#endif&#x2F;&#x2F;----------------------------------DynamicArray----------------------------------------------------------------------&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;A Properway to init a default and empty Dynamic Array&#x2F;&#x2F;Use like this: DynamicArray* Dyarr &#x3D; Init_A_DynamicArray(expected_number, datasize)&#x2F;&#x2F;DynamicArray* Init_A_DynamicArray(size_texpected_number,size_tdatasize);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Copied up a Dyarr!&#x2F;&#x2F;Use like this: DynamicArray* copied_one &#x3D; Init_A_DynamicArray_by_CopyADyarr(be_copied)&#x2F;&#x2F;DynamicArray* Init_A_DynamicArray_by_CopyADyarr(DynamicArray* dyarr_copied);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;An update! used to transform a static array to DynamicArray&#x2F;&#x2F;use like this:  &#x2F;&#x2F;DynamicArray* update_arr &#x3D; Updata_A_Static_Array_To_Dynamic_Array(&#x2F;&#x2F;static arr,&#x2F;&#x2F;sizeof(data),&#x2F;&#x2F;how_many_data_are_there_in_the_static_array)&#x2F;&#x2F;DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(void* data,size_tdatasize,size_tdatanum);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a data into the Dynamic Array&#x2F;&#x2F;Use like this: Push_Back_Into_A_Dynamic_Array(dyarr,data)&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tdatasize);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(dyarr,data,the_time_data_repeated,sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(DynamicArray* dyarr,void* data,size_tn_repeat,size_tdatasize);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has a organiztion with static array&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(&#x2F;&#x2F;dyarr,&#x2F;&#x2F;data,&#x2F;&#x2F;how_many_data_are_there_in_static_array,&#x2F;&#x2F;sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray* dyarr,void* data_array,size_tarray_num,size_tpos,size_tdata_inarray_size);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Reshape the dynamic array&#x2F;&#x2F;NOT ROCOMMEND TO USE UNLESS YOU ARE CONCIOUS OF WHAT YOU ARE DOING&#x2F;&#x2F;DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray* dyarr,size_twished_new_space_size);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Insert back a data &#x2F;&#x2F; use like this: &#x2F;&#x2F; Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; data, &#x2F;&#x2F; where_to_insert,&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(DynamicArray* dyarr,void* data,size_tpos);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)&#x2F;&#x2F;DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(DynamicArray* dyarr,void* data,size_tn_repeat,size_tdatasize,size_tpos);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back some data that organized in static array&#x2F;&#x2F;use like this: Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; where_to_insert, &#x2F;&#x2F; data, &#x2F;&#x2F; how_many_data_are_there_in_static_array,&#x2F;&#x2F; sizeof(data)&#x2F;&#x2F;)&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(DynamicArray* dyarr,size_tpos,void* data_array,size_tarray_num,size_tdata_inarray_size);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Append another dynamic Array&#x2F;&#x2F; use like this:&#x2F;&#x2F; AppendByMergeDynamicArray(dyarr_be_appended, exp_append_array)&#x2F;&#x2F;DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray* dyarr_be_appended,DynamicArray* exp_append_array);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Gain a copy of targeted array from the dynamic array&#x2F;&#x2F;use like this&#x2F;&#x2F; type* datawanna &#x3D; Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(dyarr, datawanna, sizeof(datawanna))&#x2F;&#x2F;void* Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(DynamicArray* dyarr,size_tpos,void* container,size_tcontainer_size);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Clear_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Clear_A_Dynamic_Array(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements! and unable to be used again!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Destroy_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print All data&#x2F;&#x2F; use like this&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(DynamicArray* dyarr,MyPrintuser_print,BetterPrintSwitch_for_dyarr whether_better_print);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray* dyarr,MyPrintuser_print,size_tpos);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in all data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(DynamicArray* dyarr,Do_Specific_Changeuser_change);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(DynamicArray* dyarr,Do_Specific_Changeuser_change,size_tpos);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(DynamicArray* dyarr,size_tpos);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase some specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(DynamicArray* dyarr,size_tBeginpos,size_tEndpos);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues reverse_Data_In_DynamicArray(DynamicArray* dyarr);&#x2F;&#x2F;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in judging whether the dynamic array is empty&#x2F;&#x2F; use like this:&#x2F;&#x2F; isEmpty_InDynamicArray(dyarr)&#x2F;&#x2F;Bool isEmpty_InDynamicArray(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in swap data&#x2F;&#x2F; use like this:&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)&#x2F;&#x2F;DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray* dyarr,size_tpos1,size_tpos2);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; sadly that is bubblesort :(&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol&#x2F;&#x2F; use like this:&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues sort_In_Dynamic_Array(DynamicArray* dyarr,CompareFunccompfunc);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; check if located in the dynamic array&#x2F;&#x2F; use like this:&#x2F;&#x2F; isLocateinDyarr(dyarr, data, comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues isLocateinDyarr(DynamicArray* dyarr,void* data,LocateFuncuser_func);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; return the position of data that is targeted &#x2F;&#x2F; use like this:&#x2F;&#x2F; returnAElembyPos_inDyarr(dyarr, data, comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues returnAElembyPos_inDyarr(DynamicArray* dyarr,void* data,LocateFuncuser_func);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Using the function when Posarr is enable to use!&#x2F;&#x2F; return a bunch of position of data that is targeted &#x2F;&#x2F; use like this:&#x2F;&#x2F; Position_Stored_Dynamic_ArrayFordyarr* pos &#x3D;r eturnAElembyPos_inDyarr(dyarr, posArr,data, comparision_funcuntional_pointer)&#x2F;&#x2F;#if OPENUPPOSARRPosition_Stored_Dynamic_ArrayFordyarr* returnABunchofData_inDyarr(DynamicArray* dyarr,Position_Stored_Dynamic_ArrayFordyarr* posArr,void* data,LocateFuncuser_func);#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.源文件：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#defineOPENUPPOSARR 1#define OPENUPDEFAULTSIZE 1#defineQUICKMALLOC 1&#x2F;&#x2F;(General Version)&#x2F;&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;&#x2F;&#x2F;Error Code Meaning&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0&#x2F;&#x2F;When Error in mallocing Space the program return 1&#x2F;&#x2F;when inputing a NULL we returns -1&#x2F;&#x2F;when inputing a invalid input we returns -2&#x2F;&#x2F;Locations UnFind we returns -3 &#x2F;&#x2F;typedef enum _DynamicFunctionStatues_ &#123;DynamicArray_Normal &#x3D; 0,DynamicArray_ERROR_IN_MALLOCING_SPACE&#x3D;1,DynamicArray_NULL_INPUT&#x3D;-1,DynamicArray_Invalid_Input&#x3D;-2,DynamicArray_UnFind&#x3D;-3,DynamicArray_Invalid_Free&#x3D;-4&#125;DynamicArrayFunctionStatues;&#x2F;&#x2F;Mybool defined&#x2F;&#x2F;typedef enum _bool_ &#123;True &#x3D; 1,False &#x3D; 0&#125;Bool;#define SHOW_ERROR_DynamicArray_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)#define SHOW_ERROR_DynamicArray_UnFind printf(&quot;\nPositions unfind!\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)&#x2F;&#x2F;this type of int is specifically used in Returning Find Or Unfind.&#x2F;&#x2F;Recommmend to be used as a nickname:)&#x2F;&#x2F;Can use Find or Unfind to return the result&#x2F;&#x2F;typedef enum _DynamicArray_isFind_ &#123;Find&#x3D;1,Unfind&#x3D;-1&#125;DynamicArray_isFind;&#x2F;&#x2F;A switch that used in better Print in Dynamic Array!&#x2F;&#x2F;Often use OPEN to beautify the control table&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_dyarr_ &#123;Dyarr_OPEN &#x3D; 1,Dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_dyarr;&#x2F;&#x2F;Main Definitions about DynamicArray&#x2F;&#x2F;When Programing , not recommend to Change the data directly! &#x2F;&#x2F;typedef struct _DynamicArray_ &#123;void* DataPiece;size_t current_size;size_t total_usable_size;size_t Single_Data_size;&#125;DynamicArray;&#x2F;&#x2F;--------------------------------Default_size_Type--------------------------------------------&#x2F;&#x2F;These abstractions are used to reduce the input&#x2F;&#x2F;used as Dyarr_Default_TYPE(type_number) to replace the code:sizeof(Typename)*type_number#if OPENUPDEFAULTSIZE&#x2F;&#x2F;Single Type size&#x2F;&#x2F;#define Dyarr_SIGINT sizeof(int)#define Dyarr_SIGCHAR sizeof(char)#define Dyarr_SIGFLOAT sizeof(float)#define Dyarr_SIGDOUBLE sizeof(double)#define Dyarr_SIG(dataType) sizeof(dataType)&#x2F;&#x2F;Mutiply type size&#x2F;&#x2F;#define Dyarr_INT_SIZE(X) sizeof(int)*X#define Dyarr_CHAR_SIZE(X) sizeof(char)*X#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X#endif&#x2F;&#x2F;-------------------------------------------QuickMalloc----------------------------------------&#x2F;&#x2F;As the name goes lol&#x2F;&#x2F;#if QUICKMALLOC #define Dyarr_DEFAULT_MALLOC 5#define MALLOCDYARR(datatype,data_num) (datatype*)malloc(sizeof(datatype)*data_num)#endif&#x2F;&#x2F;----------------------------------------STD_FUNC_AND_INT_TYPE----------------------------------&#x2F;&#x2F; Return type of compared functions&#x2F;&#x2F;typedef unsigned int Is_Used_Compared_Int;&#x2F;&#x2F; the pointer type of Print !&#x2F;&#x2F; When Printing , type :&#x2F;&#x2F; MyPrint user_print_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F; &#123;&#x2F;&#x2F;print in your way for your data!&#x2F;&#x2F; &#125;&#x2F;&#x2F;typedef void(*MyPrint)(void*);&#x2F;&#x2F; the pointer type of Making change for the data that has been locates in the Dynamic Array!&#x2F;&#x2F; When want to make some change, type like this:&#x2F;&#x2F; Do_Specific_Change user_dochange_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;do some change here for your data!&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef void*(*Do_Specific_Change)(void*);&#x2F;&#x2F; the pointer type of using when comparing for your data&#x2F;&#x2F; When want to make a comparisons, type like this:&#x2F;&#x2F; CompareFunc user_comp_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;return &#x2F;&#x2F;the wishing compare!&#x2F;&#x2F;&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef Is_Used_Compared_Int(*CompareFunc)(void*,void*);&#x2F;&#x2F; the pointer type of using when checking iflocated for your data&#x2F;&#x2F; When want to make a comparisons, type like this:&#x2F;&#x2F; LocateFunc user_loc_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;return data1&#x3D;&#x3D;data2(define by yourself! if complicated, just return Find or unfind to show whether is found)&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------#if OPENUPPOSARR&#x2F;&#x2F;Main data structure!&#x2F;&#x2F;Used in returning multitude locations&#x2F;&#x2F;typedef struct _Dyarrposarr_ &#123;int* posSpace;size_t pos_size;&#125;Position_Stored_Dynamic_ArrayFordyarr;&#x2F;&#x2F;Want a better Print to beutify your control table? try this one&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;PSDA_dyarr_OPEN &#x3D; 1,PSDA_dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_pos_dyarr;&#x2F;&#x2F;can use this type when indicating the type&#x2F;&#x2F;typedef unsigned int BetterPrintfor_PosDyarr;&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr()&#123;Position_Stored_Dynamic_ArrayFordyarr* pro_usable_space &#x3D; MALLOCDYARR(Position_Stored_Dynamic_ArrayFordyarr, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;  pro_usable_space-&gt;posSpace &#x3D; NULL;pro_usable_space-&gt;pos_size &#x3D; 0;return pro_usable_space;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;DynamicArrayFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarrWhether_Better_Print)&#123;if (!posarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nPositions are shown! :\n&quot;);for (int i &#x3D; 0; i &lt; posarr-&gt;pos_size; i++)printf(&quot;%u &quot;, posarr-&gt;posSpace[i]);if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nFinish Printing!\n&quot;);return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to push back a position into the Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_a_locations_in_PSDA_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr, intpos_acquired)&#123;int* pro_usable_space &#x3D; (int*)realloc(posarr-&gt;posSpace, sizeof(int) * (posarr-&gt;pos_size + 1));if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;posarr-&gt;posSpace &#x3D; pro_usable_space;posarr-&gt;posSpace[posarr-&gt;pos_size] &#x3D; pos_acquired;posarr-&gt;pos_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to return the number of locations&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;size_t Get_pos_size_From_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarrWhether_Shown_Print )&#123;if (!posarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Whether_Shown_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nCurrent targeted data&#39;s total num is:%u!\n&quot;,posarr-&gt;pos_size);return posarr-&gt;pos_size;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;Erase a dynamic Array when donot using it!&#x2F;&#x2F;DynamicArrayFunctionStatues DesTroy_A_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*pointer_to_wishedfreeposarr)&#123;if (!pointer_to_wishedfreeposarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_Invalid_Free);&#125;free(pointer_to_wishedfreeposarr-&gt;posSpace);free(pointer_to_wishedfreeposarr);pointer_to_wishedfreeposarr &#x3D; NULL;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;return a pos that is targeted!&#x2F;&#x2F;void* getPosbyPosinPSDA(Position_Stored_Dynamic_ArrayFordyarr*getter,size_tpos) &#123;if (!getter) &#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_Invalid_Free);&#125;if (pos &gt; getter-&gt;pos_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;for (int i &#x3D; 0; i &lt; pos; i++)return (char*)getter-&gt;posSpace + i * sizeof(size_t);&#125;#endif&#x2F;&#x2F;----------------------------------DynamicArray----------------------------------------------------------------------&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;A Properway to init a default and empty Dynamic Array&#x2F;&#x2F;Use like this: DynamicArray* Dyarr &#x3D; Init_A_DynamicArray(expected_number, datasize)&#x2F;&#x2F;DynamicArray* Init_A_DynamicArray(size_texpected_number,size_tdatasize)&#123;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;pro_usable_space-&gt;DataPiece &#x3D; NULL;pro_usable_space-&gt;Single_Data_size &#x3D; datasize;if (expected_number &gt;&#x3D; Dyarr_DEFAULT_MALLOC)pro_usable_space-&gt;total_usable_size &#x3D; expected_number;elsepro_usable_space-&gt;total_usable_size &#x3D; Dyarr_DEFAULT_MALLOC;pro_usable_space-&gt;current_size &#x3D; 0;return pro_usable_space;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Copied up a Dyarr!&#x2F;&#x2F;Use like this: DynamicArray* copied_one &#x3D; Init_A_DynamicArray_by_CopyADyarr(be_copied)&#x2F;&#x2F;DynamicArray* Init_A_DynamicArray_by_CopyADyarr(DynamicArray*dyarr_copied)&#123;if (!dyarr_copied)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;void* pro_usable_data &#x3D; MALLOCDYARR(char, (dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size));if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;memcpy(pro_usable_space-&gt;DataPiece, dyarr_copied-&gt;DataPiece, dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size);pro_usable_space-&gt;current_size &#x3D; dyarr_copied-&gt;current_size;pro_usable_space-&gt;Single_Data_size &#x3D; dyarr_copied-&gt;Single_Data_size;pro_usable_space-&gt;total_usable_size &#x3D; dyarr_copied-&gt;total_usable_size;return pro_usable_space;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;An update! used to transform a static array to DynamicArray&#x2F;&#x2F;use like this:  &#x2F;&#x2F;DynamicArray* update_arr &#x3D; Updata_A_Static_Array_To_Dynamic_Array(&#x2F;&#x2F;static arr,&#x2F;&#x2F;sizeof(data),&#x2F;&#x2F;how_many_data_are_there_in_the_static_array)&#x2F;&#x2F;DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(void*data, size_tdatasize,size_tdatanum)&#123;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;void* pro_usable_data &#x3D; malloc(datasize * datanum*1.5);if(!pro_usable_data)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(pro_usable_data, data, datasize * datanum);pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;pro_usable_space-&gt;current_size &#x3D; datanum;pro_usable_space-&gt;Single_Data_size &#x3D; datasize;pro_usable_space-&gt;total_usable_size &#x3D; 1.5 * datanum;return pro_usable_space;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a data into the Dynamic Array&#x2F;&#x2F;Use like this: Push_Back_Into_A_Dynamic_Array(dyarr,data)&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data,size_tdatasize)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size) &#123;printf(&quot;%d &quot;, sizeof(data));SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 1.3 * (dyarr-&gt;total_usable_size));void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1)*dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy((char*)Afteradd_piece + dyarr-&gt;current_size * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; Afteradd_piece;dyarr-&gt;current_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(dyarr,data,the_time_data_repeated,sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (dyarr-&gt;current_size+i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has a organiztion with static array&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(&#x2F;&#x2F;dyarr,&#x2F;&#x2F;data,&#x2F;&#x2F;how_many_data_are_there_in_static_array,&#x2F;&#x2F;sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data_array, size_tarray_num, size_tpos,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (data_inarray_size !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if(!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;for (int i &#x3D; 0; i &lt; array_num; i++)memcpy((char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Reshape the dynamic array&#x2F;&#x2F;NOT ROCOMMEND TO USE UNLESS YOU ARE CONCIOUS OF WHAT YOU ARE DOING&#x2F;&#x2F;DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, wished_new_space_size * (dyarr-&gt;Single_Data_size));if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;total_usable_size &#x3D; wished_new_space_size;if (dyarr-&gt;current_size &gt; dyarr-&gt;total_usable_size)dyarr-&gt;current_size &#x3D; dyarr-&gt;total_usable_size;&#x2F;&#x2F;Used when still unable to contain datareturn DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Insert back a data &#x2F;&#x2F; use like this: &#x2F;&#x2F; Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; data, &#x2F;&#x2F; where_to_insert,&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data, size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * (dyarr-&gt;total_usable_size));void* Afteradd_piece&#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy((char*)dyarr-&gt;DataPiece + (pos + 1) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos+1));memmove((char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;current_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)&#x2F;&#x2F;DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize,size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + n_repeat) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * n_repeat);for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (pos + i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back some data that organized in static array&#x2F;&#x2F;use like this: Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; where_to_insert, &#x2F;&#x2F; data, &#x2F;&#x2F; how_many_data_are_there_in_static_array,&#x2F;&#x2F; sizeof(data)&#x2F;&#x2F;)&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(DynamicArray*dyarr,size_tpos,void*data_array, size_tarray_num,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (!dyarr-&gt;current_size)&#123;Push_Back_Some_data_Into_A_Dynamic_Array(dyarr, data_array, array_num, pos,data_inarray_size);return DynamicArray_Normal;&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + array_num) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*array_num);for (int i &#x3D; 0; i &lt; array_num; i++)memcpy((char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Append another dynamic Array&#x2F;&#x2F; use like this:&#x2F;&#x2F; AppendByMergeDynamicArray(dyarr_be_appended, exp_append_array)&#x2F;&#x2F;DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray*dyarr_be_appended,DynamicArray*exp_append_array)&#123;if (!dyarr_be_appended &amp;&amp; !exp_append_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;int datarate &#x3D; exp_append_array-&gt;current_size &#x2F; dyarr_be_appended-&gt;total_usable_size;if (dyarr_be_appended-&gt;current_size &#x3D;&#x3D; dyarr_be_appended-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr_be_appended, 2 * dyarr_be_appended-&gt;total_usable_size);if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr_be_appended, (datarate + 1) * dyarr_be_appended-&gt;total_usable_size);void* AfterAppend &#x3D; realloc(dyarr_be_appended-&gt;DataPiece,(dyarr_be_appended-&gt;current_size + exp_append_array-&gt;current_size) * dyarr_be_appended-&gt;Single_Data_size);if (!AfterAppend)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr_be_appended-&gt;DataPiece &#x3D; AfterAppend;memcpy((char*)dyarr_be_appended-&gt;DataPiece + dyarr_be_appended-&gt;current_size * dyarr_be_appended-&gt;Single_Data_size,(char*)exp_append_array-&gt;DataPiece,exp_append_array-&gt;current_size * exp_append_array-&gt;Single_Data_size);dyarr_be_appended-&gt;current_size +&#x3D; exp_append_array-&gt;current_size;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Gain a copy of targeted array from the dynamic array&#x2F;&#x2F;use like this&#x2F;&#x2F; type* datawanna &#x3D; Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(dyarr, datawanna, sizeof(datawanna))&#x2F;&#x2F;void* Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(DynamicArray*dyarr, size_tpos,void*container,size_tcontainer_size)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;Single_Data_size&gt; container_size)&#123;printf(&quot;Specifically unable to contain your data! Try Larger one!\nNull pointer is returned!&quot;);return NULL;&#125;if (dyarr-&gt;Single_Data_size &lt; container_size)&#123;printf(&quot;Warning:Be Cautious the size doesn&#39;t fit!Please change your pointer step from %u to %u\nElse Error will be occurred&quot;, container_size, dyarr-&gt;Single_Data_size);exit(DynamicArray_Invalid_Input);&#125;memcpy(container, (char*)dyarr-&gt;DataPiece + pos * (dyarr-&gt;Single_Data_size), container_size);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray*dyarr)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Clear_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Clear_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size &#x3D; 0;if (!dyarr-&gt;DataPiece)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;printf(&quot;VOID DATA SHOULDN&#39;T BE FREE!&quot;);exit(DynamicArray_Invalid_Free);&#125;void* pro_usable_space&#x3D; realloc(dyarr-&gt;DataPiece, dyarr-&gt;Single_Data_size);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece&#x3D;pro_usable_space;dyarr-&gt;total_usable_size &#x3D; 1;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements! and unable to be used again!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Destroy_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;exit(DynamicArray_Invalid_Free);&#125;free(dyarr-&gt;DataPiece);free(dyarr);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print All data&#x2F;&#x2F; use like this&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(DynamicArray*dyarr,MyPrintuser_print,BetterPrintSwitch_for_dyarrwhether_better_print)&#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if(whether_better_print&#x3D;&#x3D;Dyarr_OPEN)&#123;printf(&quot;\nStart Printing\n&quot;);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;(*user_print)((char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size));&#125;if (whether_better_print &#x3D;&#x3D; Dyarr_OPEN)&#123;printf(&quot;\nFinish Printing\n&quot;);&#125;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray*dyarr, MyPrintuser_print, size_tpos) &#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;printf(&quot;\nSpecific Data is Shown:\n&quot;);user_print((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));printf(&quot;\nSpecific Data Finished Showing!\n&quot;);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in all data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change) &#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)user_change((char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size));return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change, size_tpos)&#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;user_change((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tpos)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece+pos*dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece+(pos+1)*dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos-1));dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase some specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tBeginpos, size_tEndpos)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Beginpos &lt; 0 || Beginpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (Endpos &lt; 0 || Endpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece + Beginpos * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (Endpos + 1) * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - Endpos + 1));dyarr-&gt;current_size -&#x3D; Endpos - Beginpos + 1;if (dyarr-&gt;current_size &lt;&#x3D; dyarr-&gt;total_usable_size &#x2F; 4 &amp;&amp; dyarr-&gt;total_usable_size &gt; 5)&#123;Resize_The_Dynamic_Array(dyarr, dyarr-&gt;total_usable_size &#x2F; 2);dyarr-&gt;total_usable_size &#x2F;&#x3D; 2;&#125;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues reverse_Data_In_DynamicArray(DynamicArray*dyarr) &#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size &#x2F; 2; i++)&#123;memcpy(swapbit, (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size, dyarr-&gt;Single_Data_size);&#x2F;&#x2F;原型：int temp&#x3D;*a,*a&#x3D;*b,*b&#x3D;tempmemmove((char*)dyarr-&gt;DataPiece + i*dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (dyarr-&gt;current_size - i-1) * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memcpy((char*)dyarr-&gt;DataPiece + (dyarr-&gt;current_size - i - 1) * dyarr-&gt;Single_Data_size, swapbit, dyarr-&gt;Single_Data_size);&#125;free(swapbit);return DynamicArray_Normal;&#125;&#x2F;&#x2F;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in judging whether the dynamic array is empty&#x2F;&#x2F; use like this:&#x2F;&#x2F; isEmpty_InDynamicArray(dyarr)&#x2F;&#x2F;Bool isEmpty_InDynamicArray(DynamicArray*dyarr) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!dyarr-&gt;current_size)return True;return False;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in swap data&#x2F;&#x2F; use like this:&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)&#x2F;&#x2F;DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray*dyarr, size_tpos1, size_tpos2)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);if(!swapbit)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(swapbit,(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memmove((char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memcpy((char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,swapbit,dyarr-&gt;Single_Data_size);free(swapbit);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; sadly that is bubblesort :(&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol&#x2F;&#x2F; use like this:&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues sort_In_Dynamic_Array(DynamicArray*dyarr,CompareFunccompfunc) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!compfunc)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size-1; i++)&#123;for (int j &#x3D; 0; j &lt; dyarr-&gt;current_size - i-1; j++)&#123;if (compfunc((char*)dyarr-&gt;DataPiece + j * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (j + 1) * dyarr-&gt;Single_Data_size))swapData_in_DynamicArray(dyarr, j, j + 1);&#125;&#125;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; check if located in the dynamic array&#x2F;&#x2F; use like this:&#x2F;&#x2F; isLocateinDyarr(dyarr, data, comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues isLocateinDyarr(DynamicArray*dyarr,void*data,LocateFuncuser_func)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if (user_func((char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size, data))&#123;return Find;&#125;&#125;return Unfind;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; return the position of data that is targeted &#x2F;&#x2F; use like this:&#x2F;&#x2F; returnAElembyPos_inDyarr(dyarr, data, comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues returnAElembyPos_inDyarr(DynamicArray*dyarr, void*data, LocateFuncuser_func) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if (user_func((char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size, data))&#123;return i;&#125;&#125;return Unfind;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Using the function when Posarr is enable to use!&#x2F;&#x2F; return a bunch of position of data that is targeted &#x2F;&#x2F; use like this:&#x2F;&#x2F; Position_Stored_Dynamic_ArrayFordyarr* pos &#x3D;r eturnAElembyPos_inDyarr(dyarr, posArr,data, comparision_funcuntional_pointer)&#x2F;&#x2F;#if OPENUPPOSARRPosition_Stored_Dynamic_ArrayFordyarr* returnABunchofData_inDyarr(DynamicArray*dyarr, Position_Stored_Dynamic_ArrayFordyarr*posArr, void*data, LocateFuncuser_func)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;int possible_count &#x3D; 0;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if ((*user_func)(data, (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size))&#123;int* pro_usable_stored_space &#x3D; (int*)realloc(posArr-&gt;posSpace, sizeof(int) * (possible_count + 1));if (!pro_usable_stored_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;posArr-&gt;posSpace &#x3D; pro_usable_stored_space;posArr-&gt;posSpace[possible_count] &#x3D; i;possible_count++;posArr-&gt;pos_size &#x3D; possible_count;&#125;&#125;if (posArr-&gt;pos_size)return posArr;return Unfind;&#125;&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试文档：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#include&quot;standard_dynamic_array.h&quot;MyPrint print(int* e1) &#123;printf(&quot;%d &quot;, *e1);&#125;Do_Specific_Change dochange(int* e1) &#123;*e1 &#x3D; *e1 + 1;&#125;LocateFunc loc(int* e1, int* e2) &#123;if (*e1 &#x3D;&#x3D; *e2) &#123;return Find;&#125;return Unfind;&#125;int main()&#123;int data1 &#x3D; 10;printf(&quot;%d &quot;, sizeof(data1));    &#x2F;&#x2F;test InitingDynamicArray* testDyarr1 &#x3D; Init_A_DynamicArray(10, Dyarr_SIGINT);    &#x2F;&#x2F;test a Sigdata pushed:Push_Back_Into_A_Dynamic_Array(testDyarr1, &amp;data1,sizeof(int));Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;test pushing the same dataPush_back_Same_data_Into_A_Dynamic_Array(testDyarr1, &amp;data1, 10, Dyarr_SIGINT);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;Test ClearingClear_A_Dynamic_Array(testDyarr1);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;test updateint data2[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;DynamicArray* test2&#x3D;Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);Print_ALL_Data_In_A_Dynamic_Array(test2, print, Dyarr_OPEN);    &#x2F;&#x2F;test copy:DynamicArray* copyone &#x3D; Init_A_DynamicArray_by_CopyADyarr(test2);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test insertprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Insert_Into_A_Dynamic_Array(copyone, &amp;data1, 1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test insert bunchprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Insert_Some_Data_Into_A_Dynamic_Array(copyone, 1, data2, 10, Dyarr_SIGINT);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Erasing sigoneprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Delete_A_Specific_Data_From_the_DynamicArray(copyone, 1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Erasing bunch oneprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Delete_Some_Specific_Data_From_the_DynamicArray(copyone,1,10);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Do changeprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Do_Specific_Change_To_Specific_Data(copyone,dochange,1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);printf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Do_Specific_Change_To_All_Data(copyone, dochange);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test location:DynamicArray* test3 &#x3D; Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);if (isLocateinDyarr(test3, &amp;data2[2], loc)) &#123;printf(&quot;\nI have found it!\n&quot;);&#125;int where &#x3D; returnAElembyPos_inDyarr(test3, &amp;data2[2], loc);printf(&quot;\nIn dyarr the %d place\n&quot;, where);    &#x2F;&#x2F;test Position Stored Dynamic Array and returnBunchClear_A_Dynamic_Array(test3);Push_back_Same_data_Into_A_Dynamic_Array(test3, &amp;data2[2], 10, Dyarr_SIGINT);Position_Stored_Dynamic_ArrayFordyarr* p1 &#x3D; Init_A_Postion_Stored_Dynamic_ArrayFordyarr();returnABunchofData_inDyarr(test3, p1, &amp;data2[2], loc);Print_ALL_Data_In_A_Dynamic_Array(test3, print, Dyarr_OPEN);Show_All_Locations_In_PSDAfor_dyarr(p1, PSDA_dyarr_OPEN);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv-in-Pycharm （3）</title>
      <link href="/2023/02/06/Opencv-in-Pycharm-%EF%BC%883%EF%BC%89/"/>
      <url>/2023/02/06/Opencv-in-Pycharm-%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="腐蚀操作"><a href="#腐蚀操作" class="headerlink" title="腐蚀操作"></a>腐蚀操作</h3><p>​        对于这样的一些图片：</p><p><img src="1.png" alt="1"></p><p>​        我们可以使用腐蚀操作来钝化特征：删除掉一些边界的像素点（置黑色）。其中：腐蚀的大小，范围是由kernel决定的。在Python中，我们需要这样指定一个核：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kernel<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        还是需要指定一个迭代次数的参数，这行代码完成了这样的工作：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">erosion<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>                  kernel<span class="token punctuation">,</span>                  iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#迭代次数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们首先看看效果怎么样：</p><p><img src="erosion.png" alt="erosion"></p><p>​        可以看到，腐蚀核在检测到边界条件的时候（白转黑and黑转白）自动将这些像素点填充成黑色，除非核内的像素点都是统一的，否则都会腐蚀！</p><p>​        可以来点控制变量！比如说指定不同的腐蚀核来观察效果</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> nppath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion33<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion55<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>erosion33<span class="token punctuation">,</span>erosion55<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"comp"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Kernel Diff compararison.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Kernel Diff compararison.png" alt="Kernel Diff compararison"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion33<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion55<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>imgs_ero1<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>erosion33<span class="token punctuation">,</span>erosion55<span class="token punctuation">]</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original'</span><span class="token punctuation">,</span><span class="token string">'3 times 3 '</span><span class="token punctuation">,</span><span class="token string">'5 times t '</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>imgs_ero1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_1-16756699063337.png" alt="Figure_1"></p><p>​        可以看到，核越大，就越会腐蚀图像！</p><p>​        下面看看图像迭代影响：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> nppath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>erosion1<span class="token punctuation">,</span>erosion2<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"comp"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Iterator Diff comparasion.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Iterator Diff comparasion.png" alt="Iterator Diff comparasion"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>imgs_ero1<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>erosion1<span class="token punctuation">,</span>erosion2<span class="token punctuation">]</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original'</span><span class="token punctuation">,</span><span class="token string">'1 '</span><span class="token punctuation">,</span><span class="token string">'2 '</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>imgs_ero1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_2.png" alt="Figure_2"></p><p>可以看见：越是迭代，图像腐蚀的越严重！</p><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>​        这个操作可以视作腐蚀操作的反操作：就是将特征明显化：</p><p><img src="dilate.png" alt="dilate"></p><p>​        老规矩：还是看看改变核大小和迭代次数产生的效果如何：</p><p>​        先看核大小：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> nppath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>dilate1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>dilate2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>dilate1<span class="token punctuation">,</span>dilate2<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"comp"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"kernel_in_dilate Diff comparasion.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="kernel_in_dilate Diff comparasion.png" alt="kernel_in_dilate Diff comparasion"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>dilate1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>dilate2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'org'</span><span class="token punctuation">,</span><span class="token string">'3 times 3'</span><span class="token punctuation">,</span><span class="token string">'5 times 5'</span><span class="token punctuation">]</span>img_group<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>dilate1<span class="token punctuation">,</span>dilate2<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img_group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_3.png" alt="Figure_3"></p><p>​        再来看看迭代器的影响：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>dilate1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>dilate2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'org'</span><span class="token punctuation">,</span><span class="token string">'3 times 3'</span><span class="token punctuation">,</span><span class="token string">'5 times 5'</span><span class="token punctuation">]</span>img_group<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>dilate1<span class="token punctuation">,</span>dilate2<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img_group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_4.png" alt="Figure_4"></p><p>​        还是很容易看出来：核越大，迭代次数越多，图片的特征就被放大的越明显！</p><h4 id="扩展阅读1"><a href="#扩展阅读1" class="headerlink" title="扩展阅读1"></a>扩展阅读1</h4><p>​        版权声明：本文为CSDN博主「我有一個夢想」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>​        原文链接：<a href="https://blog.csdn.net/B08370108/article/details/118028678">https://blog.csdn.net/B08370108/article/details/118028678</a></p><p>​        <strong>图像的腐蚀过程与图像的卷积操作类似，都需要模板矩阵来控制运算的结果</strong>，在图像的腐蚀和膨胀中这个模板矩阵被称为结构元素。与图像卷积相同，结构元素可以任意指定图像的中心点，并且结构元素的尺寸和具体内容都可以根据需求自己定义。定义结构元素之后，将结构元素的中心点依次放到图像中每一个非0元素处，如果此时结构元素内所有的元素所覆盖的图像像素值均不为0，则保留结构元素中心点对应的图像像素，否则将删除结构元素中心点对应的像素。图像的腐蚀过程示意图如图6-12所示，图6-12中左侧为待腐蚀的原图像，中间为结构元素，<strong>首先将结构元素的中心与原图像中的A像素重合，此时结构元素中心点的左侧和上方元素所覆盖的图像像素值均为0，因此需要将原图像中的A像素删除</strong>；<strong>当把结构元素的中心点与B像素重合时，此时结构元素中所有的元素所覆盖的图像像素值均为1</strong>，因此保留原图像中的B像素。将结构元素中心点依次与原图像中的每个像素重合，判断每一个像素点是否保留或者删除，最终原图像腐蚀的结果如图中下侧图像所示。</p><p>​        <img src="2021011613033220.png" alt="img"></p><p>​        图像腐蚀可以用“Θ”表示，其数学表示形式如式(6.4)所示，通过公式可以发现，其实对图像A的腐蚀运算就是寻找图像中能够将结构元素B全部包含的像素点。</p><p>​        生成常用的矩形结构元素、十字结构元素和椭圆结构：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat getStructuringElement(int shape, Size ksize, Point anchor &#x3D; Point(-1,-1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;shape：结构元素的种类，可以选择的参数及含义在表6-5中给出。&#x2F;&#x2F;ksize：结构元素的尺寸大小&#x2F;&#x2F;anchor：中心点的位置，默认参数为结构元素的几何中心点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>     该函数用于生成图像形态学操作中常用的矩形结构元素、十字结构元素和椭圆结构元素。函数第一个参数为生成结构元素的种类，可以选择的参数及含义在表给出，函数第二个参数是结构元素的尺寸大小，能够影响到图像腐蚀的效果，一般情况下，结构元素的种类相同时，结构元素的尺寸越大腐蚀效果越明显。函数的最后一个参数是结构元素的中心点，只有十字结构元素的中心点位置会影响图像腐蚀后的轮廓形状，其他种类的结构元素的中心点位置只影响形态学操作结果的平移量。</code></pre><p><img src="20210116131530359.png" alt="表6-5 getStructuringElement()函数结构元素形状可选择参数"></p><p>腐蚀函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void erode( InputArray src,            OutputArray dst,            InputArray kernel,           Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,           int borderType &#x3D; BORDER_CONSTANT,           const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue()           );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;src：输入的待腐蚀图像，图像的通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。&#x2F;&#x2F;dst：腐蚀后的输出图像，与输入图像src具有相同的尺寸和数据类型。&#x2F;&#x2F;kernel：用于腐蚀操作的结构元素，可以自己定义，也可以用getStructuringElement()函数生成。&#x2F;&#x2F;anchor：中心点在结构元素中的位置，默认参数为结构元素的几何中心点&#x2F;&#x2F;iterations：腐蚀的次数，默认值为1。&#x2F;&#x2F;borderType：像素外推法选择标志，取值范围在表3-5中给出。默认参数为BORDER_DEFAULT，表示不包含边界值倒序填充。&#x2F;&#x2F;borderValue：使用边界不变外推法时的边界值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        该函数根据结构元素对输入图像进行腐蚀，在腐蚀多通道图像时每个通道独立进行腐蚀运算。<br>​        函数的第一个参数为待腐蚀的图像，图像通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。<br>​        函数第二个参数为腐蚀后的输出图像，与输入图像具有相同的尺寸和数据类型。<br>​        函数第三个和第四个参数都是与结构元素相关的参数，第三个参数为结构元素，第四个参数为结构元素的中心位置，第四个参数的默认值为Point(-1,-1)，表示结构元素的几何中心处为结构元素的中心点。<br>​        函数第五个参数是使用结构元素腐蚀的次数，腐蚀次数越多效果越明显，参数默认值为1，表示只腐蚀1次。<br>​        函数第六个参数是图像像素外推法的选择标志，<br>​        第七个参数为使用边界不变外推法时的边界值，这两个参数对图像中主要部分的腐蚀操作没有影响，因此在多数情况下使用默认值即可。</p><p>​        需要注意的是该函数的腐蚀过程只针对图像中的非0像素，因此如果图像是以0像素为背景，那么腐蚀操作后会看到图像中的内容变得更瘦更小；如果图像是以255像素为背景，那么腐蚀操作后会看到图像中的内容变得更粗更大。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">   简单示例&#x2F;&#x2F;&#x2F;&#x2F; Created by smallflyfly on 2021&#x2F;6&#x2F;18.&#x2F;&#x2F;#include &quot;opencv2&#x2F;opencv.hpp&quot;#include &lt;iostream&gt;using namespace std;using namespace cv;void drawResult(Mat im, int num, Mat stats, Mat centroids, const string&amp; name) &#123;    for (int i &#x3D; 1; i &lt; num; ++i)     &#123;        int x &#x3D; centroids.at&lt;double&gt;(i, 0);        int y &#x3D; centroids.at&lt;double&gt;(i, 1);        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;        circle(im, Point(x, y), 2, Scalar(0, 0, 255), -1);        int xmin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_LEFT);        int ymin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_TOP);        int w &#x3D; stats.at&lt;int&gt;(i, CC_STAT_WIDTH);        int h &#x3D; stats.at&lt;int&gt;(i, CC_STAT_HEIGHT);Rect rect(xmin, ymin, w, h);    rectangle(im, rect, Scalar(255, 255, 255), 2);    putText(            im,                 to_string(i),                 Point(x+5, y),                 FONT_HERSHEY_SCRIPT_SIMPLEX,                 0.3,                 Scalar(0, 0, 255),                 1);&#125;imshow(name, im);&#125;int main() &#123;Mat src &#x3D; (            Mat_&lt;uchar&gt;(6, 6) &lt;&lt;                    0, 0, 0, 0, 255, 0,                    0, 255, 255, 255, 255, 255,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 0, 0, 0, 255, 0        );resize(src, src, Size(0, 0), 50, 50, INTER_NEAREST);Mat m1, m2;m1 &#x3D; getStructuringElement(0, Size(3, 3));m2 &#x3D; getStructuringElement(1, Size(3, 3)); Mat erodeM1, erodeM2;erode(src, erodeM1, m1, Point(-1, -1), 10);erode(src, erodeM2, m2, Point(-1, -1), 10); imshow(&quot;src&quot;, src);imshow(&quot;erodeM1&quot;, erodeM1);imshow(&quot;erodeM2&quot;, erodeM2); Mat xbim &#x3D; imread(&quot;xiaobai.jpg&quot;);Mat xbM1, xbM2;erode(xbim, xbM1, m1, Point(-1, -1), 2);erode(xbim, xbM2, m2, Point(-1, -1), 2); imshow(&quot;xb&quot;, xbim);imshow(&quot;xbM1&quot;, xbM1);imshow(&quot;xbM2&quot;, xbM2); Mat im &#x3D; imread(&quot;rice.jfif&quot;);Mat im1 &#x3D; im.clone();Mat im2 &#x3D; im.clone();Mat im3 &#x3D; im.clone(); Mat gray;cvtColor(im, gray, CV_BGR2GRAY);Mat riceBin;threshold(gray, riceBin, 125, 255, THRESH_BINARY); Mat out, stats, centroids;int count1 &#x3D; connectedComponentsWithStats(riceBin, out, stats, centroids, 8, CV_16U);drawResult(im1, count1, stats, centroids, &quot;no erode&quot;); Mat erodeIm1, erodeIm2;erode(riceBin, erodeIm1, m1, Point(-1, -1), 5);erode(riceBin, erodeIm2, m2, Point(-1, -1), 5); int count2 &#x3D; connectedComponentsWithStats(erodeIm1, out, stats, centroids, 8, CV_16U);drawResult(erodeIm1, count2, stats, centroids, &quot;erode1&quot;);int count3 &#x3D; connectedComponentsWithStats(erodeIm2, out, stats, centroids, 8, CV_16U);drawResult(erodeIm2, count3, stats, centroids, &quot;erode2&quot;); waitKey(0);destroyAllWindows();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0IwODM3MDEwOA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="扩展阅读2"><a href="#扩展阅读2" class="headerlink" title="扩展阅读2"></a>扩展阅读2</h4><p>​        版权声明：本文为CSDN博主「我有一個夢想」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>​        原文链接：<a href="https://blog.csdn.net/B08370108/article/details/118029682">https://blog.csdn.net/B08370108/article/details/118029682</a></p><p>​        图像的膨胀与图像腐蚀是一对相反的过程，与图像腐蚀相似，图像膨胀同样需要结构元素用于控制图像膨胀的效果。结构元素可以任意指定结构的中心点，并且结构元素的尺寸和具体内容都可以根据需求自己定义。<strong>定义结构元素之后，将结构元素的中心点依次放到图像中每一个非0元素处，如果原图像中某个元素被结构元素覆盖，但是该像素的像素值不与结构元素中心点对应的像素点的像素值相同，那么将原图像中的该像素的像素值修改为结构元素中心点对应点的像素值。</strong>图像的膨胀过程示意图如图所示，图中左侧为待膨胀的原图像，中间为结构元素，首先将结构元素的中心与原图像中的A像素重合，将结构元素覆盖的所有像素的像素值都修改为1，将结构元素中心点依次与原图像中的每个像素重合，判断是否有需要填充的像素。原图像膨胀的结果如图中右侧图像所示。</p><p><img src="20210117230235852.png" alt="在这里插入图片描述"></p><pre><code>     图像膨胀数学表示形式如式(6.5)所示，通过公式可以发现，其实图像A的膨胀运算就是生成能够将结构元素B全部包含的图像。</code></pre><p><img src="20210117230534606.png" alt="在这里插入图片描述"></p><p>膨胀函数</p><pre class="line-numbers language-none"><code class="language-none">void dilate( InputArray src, OutputArray dst, InputArray kernel,Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,int borderType &#x3D; BORDER_CONSTANT,const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue() );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;src：输入的待膨胀图像，图像的通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。&#x2F;&#x2F;dst：膨胀后的输出图像，与输入图像src具有相同的尺寸和数据类型。&#x2F;&#x2F;kernel：用于膨胀操作的结构元素，可以自己定义，也可以用getStructuringElement()函数生成。&#x2F;&#x2F;anchor：中心点在结构元素中的位置，默认参数为结构元素的几何中心点&#x2F;&#x2F;iterations：膨胀的次数，默认值为1。&#x2F;&#x2F;borderType：像素外推法选择标志，取值范围在表3-5中给出。默认参数为BORDER_DEFAULT，表示不包含边界值倒序填充。&#x2F;&#x2F;borderValue：使用边界不变外推法时的边界值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     该函数根据结构元素对输入图像进行膨胀，在膨胀多通道图像时每个通道独立进行膨胀运算。函数的第一个参数为待膨胀的图像，图像通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。</code></pre><p>​        函数第二个参数为膨胀后的输出图像，与输入图像具有相同的尺寸和数据类型。函数第三个和第四个参数都是与结构元素相关的参数，</p><p>​        第三个参数为结构元素，膨胀时使用的结构元素尺寸越大效果越明显，第四个参数为结构元素的中心位置，</p><p>​        第四个参数的默认值为Point(-1,-1)，表示结构元素的几何中心处为结构元素的中心点。</p><p>​        函数第五个参数是使用结构元素膨胀的次数，膨胀次数越多效果越明显，默认参数为1，表示只膨胀1次。</p><p>​        函数第六个参数是图像像素外推法的选择标志，</p><p>​        第七个参数为使用边界不变外推法时的边界值，这两个参数对图像中主要部分的膨胀操作没有影响，因此在多数情况下使用默认值即可。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">    简单示例&#x2F;&#x2F;&#x2F;&#x2F; Created by smallflyfly on 2021&#x2F;6&#x2F;18.&#x2F;&#x2F;#include &quot;opencv2&#x2F;opencv.hpp&quot;#include &lt;iostream&gt;using namespace cv;using namespace std;void drawResult(Mat im, int num, Mat stats, Mat centroids, const string&amp; name) &#123;    for (int i &#x3D; 1; i &lt; num; ++i) &#123;        int x &#x3D; centroids.at&lt;double&gt;(i, 0);        int y &#x3D; centroids.at&lt;double&gt;(i, 1);        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;        circle(im, Point(x, y), 2, Scalar(0, 0, 255), -1);        int xmin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_LEFT);        int ymin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_TOP);        int w &#x3D; stats.at&lt;int&gt;(i, CC_STAT_WIDTH);        int h &#x3D; stats.at&lt;int&gt;(i, CC_STAT_HEIGHT);    Rect rect(xmin, ymin, w, h);   rectangle(im, rect, Scalar(255, 255, 255), 2);    putText(    im,     to_string(i),     Point(x+5, y),     FONT_HERSHEY_SCRIPT_SIMPLEX,     0.3,        Scalar(0, 0, 255),         1);&#125;imshow(name, im);&#125;int main() &#123;    Mat src &#x3D; (            Mat_&lt;uchar&gt;(6, 6) &lt;&lt;                              0, 0, 0, 0, 255, 0,                    0, 255, 255, 255, 255, 255,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 0, 0, 0, 255, 0    );    resize(src, src, Size(0, 0), 50, 50, INTER_NEAREST);    Mat m1, m2;    m1 &#x3D; getStructuringElement(0, Size(3, 3));    m2 &#x3D; getStructuringElement(1, Size(3, 3));Mat dilateM1, dilateM2;dilate(src, dilateM1, m1, Point(-1, -1), 5);dilate(src, dilateM2, m2, Point(-1, -1), 5); imshow(&quot;src&quot;, src);imshow(&quot;dilateM1&quot;, dilateM1);imshow(&quot;dilateM2&quot;, dilateM2); Mat xbim &#x3D; imread(&quot;xiaobai.jpg&quot;);Mat xbM1, xbM2;dilate(xbim, xbM1, m1, Point(-1, -1), 2);dilate(xbim, xbM2, m2, Point(-1, -1), 2); imshow(&quot;xbim&quot;, xbim);imshow(&quot;xbM1&quot;, xbM1);imshow(&quot;xbM2&quot;, xbM2); Mat im &#x3D; imread(&quot;rice.jfif&quot;);resize(im, im, Size(0, 0), 0.6, 0.6);Mat im1 &#x3D; im.clone(); Mat gray;cvtColor(im, gray, CV_BGR2GRAY);Mat riceBin;threshold(gray, riceBin, 125, 255, THRESH_BINARY); Mat out, stats, centroids;int count1 &#x3D; connectedComponentsWithStats(riceBin, out, stats, centroids, 8, CV_16U);drawResult(im, count1, stats, centroids, &quot;no dilate&quot;); Mat dilateIm1, dilateIm2;dilate(riceBin, dilateIm1, m1, Point(-1, -1), 5);dilate(riceBin, dilateIm2, m2, Point(-1, -1), 5); int count2 &#x3D; connectedComponentsWithStats(dilateIm1, out, stats, centroids, 8, CV_16U);drawResult(dilateIm1, count2, stats, centroids, &quot;dilateIm1&quot;);int count3 &#x3D; connectedComponentsWithStats(dilateIm2, out, stats, centroids, 8, CV_16U);drawResult(dilateIm2, count3, stats, centroids, &quot;dilateIm2&quot;); waitKey(0);destroyAllWindows();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="xiaobaixueshijue.png" alt="img"></p><h3 id="开运算与闭运算"><a href="#开运算与闭运算" class="headerlink" title="开运算与闭运算"></a>开运算与闭运算</h3><p>​        刚刚我们整完了腐蚀和膨胀,现在我们一起用：</p><p>​        开运算指的是：<strong>先腐蚀后膨胀</strong></p><p>​        闭运算指的是：<strong>先膨胀后腐蚀</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath <span class="token operator">=</span> <span class="token string">"1.png"</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33 <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>opening <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_OPEN<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"opening"</span><span class="token punctuation">,</span>opening<span class="token punctuation">)</span>closing <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"closing"</span><span class="token punctuation">,</span>closing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"open.png"</span><span class="token punctuation">,</span>opening<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"close.png"</span><span class="token punctuation">,</span>closing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        开运算：</p><p><img src="open.png" alt="open"></p><p>​        闭运算：</p><p><img src="close.png" alt="close"></p><h3 id="梯度运算"><a href="#梯度运算" class="headerlink" title="梯度运算"></a>梯度运算</h3><p>​        放大边界信息！很简单：膨胀的减去腐蚀的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">import cv2import numpy as npfrom matplotlib import pyplot as pltpath &#x3D; &quot;1.png&quot;img &#x3D; cv2.imread(path)kernel33 &#x3D; np.ones((3,3),np.uint8)gradient&#x3D;cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel33)cv2.imshow(&quot;gra&quot;,gradient)cv2.imwrite(&quot;gradient.png&quot;,gradient)cv2.waitKey(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="gradient.png" alt="gradient"></p><h3 id="礼貌与黑帽"><a href="#礼貌与黑帽" class="headerlink" title="礼貌与黑帽"></a>礼貌与黑帽</h3><p>​        <strong>礼貌就是原始输入-开运算结果！</strong></p><p>​        <strong>黑猫就是闭运算-原始输入！</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath <span class="token operator">=</span> <span class="token string">"1.png"</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33 <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>tophat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>blackhat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_BLACKHAT<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"to"</span><span class="token punctuation">,</span>tophat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"bl"</span><span class="token punctuation">,</span>blackhat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"tophat.png"</span><span class="token punctuation">,</span>tophat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"blackhat.png"</span><span class="token punctuation">,</span>blackhat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tophat：</p><p><img src="tophat.png" alt="tophat"></p><p>blackhat:</p><p><img src="blackhat.png" alt="blackhat"></p><h3 id="扩展阅读1-1"><a href="#扩展阅读1-1" class="headerlink" title="扩展阅读1"></a>扩展阅读1</h3><p>阅读链接：<a href="https://zhuanlan.zhihu.com/p/541851526">数字图像处理(c++ opencv)：形态学图像处理-开运算与闭运算 - 知乎 (zhihu.com)</a></p><h4 id="开运算与闭运算-1"><a href="#开运算与闭运算-1" class="headerlink" title="开运算与闭运算"></a>开运算与闭运算</h4><p>（1）开运算</p><p>原理方法：先腐蚀后膨胀；</p><p>功能作用：平滑物体轮廓、断开狭窄的狭颈、消除细长的突出和物体。</p><p>（2）闭运算</p><p>原理方法：先膨胀后腐蚀；</p><p>功能作用：弥合狭窄的狭颈或断裂处、消除小孔、填补轮廓缝隙。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;int main()&#123;Mat image, image_gray, image_bw;   &#x2F;&#x2F;定义输入图像，灰度图像，二值图像image &#x3D; imread(&quot;开运算闭运算.png&quot;);  &#x2F;&#x2F;读取图像；if (image.empty())&#123;cout &lt;&lt; &quot;读取错误&quot; &lt;&lt; endl;return -1;&#125;imshow(&quot;image&quot;, image);&#x2F;&#x2F;转换为灰度图像cvtColor(image, image_gray, COLOR_BGR2GRAY);&#x2F;&#x2F;转换为二值图threshold(image_gray, image_bw, 120, 255, 1); &#x2F;&#x2F;通过0，1调节二值图像背景颜色imshow(&quot;image_bw&quot;, image_bw);&#x2F;&#x2F;闭运算Mat se &#x3D; getStructuringElement(0, Size(3, 3)); &#x2F;&#x2F;构造矩形结构元素dilate(image_bw, image_bw, se, Point(-1, -1), 5); &#x2F;&#x2F;执行膨胀操作erode(image_bw, image_bw, se, Point(-1, -1), 5); &#x2F;&#x2F;执行腐蚀操作&#x2F;&#x2F;开运算&#x2F;&#x2F;Mat se &#x3D; getStructuringElement(0, Size(3, 3)); &#x2F;&#x2F;构造矩形结构元素&#x2F;&#x2F;erode(image_bw, image_bw, se, Point(-1, -1), 2); &#x2F;&#x2F;执行腐蚀操作&#x2F;&#x2F;dilate(image_bw, image_bw, se, Point(-1, -1), 2); &#x2F;&#x2F;执行膨胀操作imshow(&quot;image_bw&quot;, image_bw);waitKey(0);  &#x2F;&#x2F;暂停，保持图像显示，等待按键结束return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="v2-996d420c6bd384ca11957a8745f672b4_1440w.png" alt="img"></p><hr><p><strong>除了使用腐蚀膨胀的函数组合来进行开运算闭运算，还可以通过opencv函数进行处理（morphologyex函数）</strong></p><h3 id="扩展阅读2-1"><a href="#扩展阅读2-1" class="headerlink" title="扩展阅读2"></a>扩展阅读2</h3><p>版权声明：本文为CSDN博主「念980」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_62343847/article/details/122604497">https://blog.csdn.net/weixin_62343847/article/details/122604497</a></p><p>腐蚀与膨胀</p><p>​        图像的腐蚀与膨胀互为逆向操作，通常用于处理二值图像（黑白图，以黑色为底面背景），因此需要先进行二值化处理，腐蚀和膨胀通俗的理解就是，在指定大小的卷积核内，如果该卷积核内全为黑色或全为白色，则该卷积核内像素值不变，但若是既有黑色又有白色，即在图像边缘处，那么膨胀操作则会将该卷积核内所有白色像素点都赋值变为黑色，以此将图像向内腐蚀掉一圈，而膨胀操作则相反，会将卷积核内的黑色像素点赋值成2白色，以此让图像膨胀一圈。</p><p>​        膨胀与腐蚀的函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>uint8<span class="token punctuation">)</span> <span class="token comment">#定义要处理的卷积核大小和卷积核的类型。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">erosion <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#对图像进行膨胀操作，img_test是要进行处理的图像，kernel是通过上一个函数定义好的卷积核，而iterations则是腐蚀操作的循环次数（可以将卷积核设置为（1，1），然后不断调整循环次数来实现精细化的腐蚀，以达到更好的腐蚀效果）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">dilate_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img_test<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#对图像进行膨胀操作，这里的参数跟上面的参数作用一样，只是改了函数名而已。（同样可以将卷积核设置为（1，1），不断改变循环次数，以达到更好的膨胀效果）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        应用：腐蚀操作一般用于消去图像中不需要的粘连部分，而膨胀操作则用于填充图像内的空白部分，同时也可以恢复图像由于进行腐蚀操作后缩小的面积，在下面的代码实例中会有体现。</p><p>代码实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment">#导入包</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span><span class="token comment">#读入图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定处理的内核</span>erosion <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#腐蚀操作</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"erosion"</span><span class="token punctuation">,</span>erosion<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>pie <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"pie.png"</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"pie"</span><span class="token punctuation">,</span>pie<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>erosion_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#循环腐蚀1次</span>erosion_2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#循环腐蚀2次</span>erosion_3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#循环腐蚀3次</span>All <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>erosion_1<span class="token punctuation">,</span>erosion_2<span class="token punctuation">,</span>erosion_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#拼接图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"All"</span><span class="token punctuation">,</span>All<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>img_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>erosion_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#腐蚀图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"erosion_test3"</span><span class="token punctuation">,</span>erosion_test3<span class="token punctuation">)</span><span class="token comment">#展示腐蚀后的图像</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>dilate_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>erosion_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#对腐蚀过的图像进行膨胀处理</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"dilate"</span><span class="token punctuation">,</span>dilate_test3<span class="token punctuation">)</span><span class="token comment">#展示膨胀后的图像</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>dilate_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#循环膨胀一次后的图像</span>dilate_2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#循环膨胀两次后的图像</span>dilate_3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#循环膨胀三次后的图像</span>All <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>dilate_1<span class="token punctuation">,</span>dilate_2<span class="token punctuation">,</span>dilate_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#拼接以上三幅图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"All"</span><span class="token punctuation">,</span>All<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        运行结果</p><p>​        这是原图，可以看到上面有一些多出来的粘连部分</p><p><img src="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-1OTgw,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>​        进行腐蚀操作后的图像，可以看到，我们用腐蚀操作成功去除了边缘的粘连部分，但同时字体笔画也由于受到了腐蚀而变细了</p><p><img src="qdwd.png" alt="img"></p><p>​        对上图进行膨胀操作，可以看到，我们恢复了被腐蚀前笔画的粗细，同时也去除掉了原图的粘连部分，这种操作称为开运算，能够在尽量不改变原图的情况下去除图像的粘连。（在下面会有详细的介绍）</p><p><img src="ss.png" alt="img"></p><pre><code>     以下是循环腐蚀1~3次之后的图像对比</code></pre><p><img src="wq.png" alt="img"></p><pre><code>     以下是循环膨胀1~3次之后的图像对比</code></pre><p><img src="das.png" alt="img"></p><p>​        通过上面两幅图可以看出，不管是腐蚀还是膨胀，都不是等比例的进行，它们最终都会趋近于矩形（因为卷积核就是矩形的），并且进行腐蚀再膨胀后的图像跟原图是存在细微差别的，比如中间的部分空洞可能已经消失了等等。</p><p>​        开运算和闭运算 </p><p>​        所谓开运算在上面的代码其实已经使用过了，只是opencv本身便带有可以进行腐蚀后再膨胀的函数，不需要我们自己写那么多代码。开运算在原图的基础上就是用于消除图像的一些粘连部分的一种方式。</p><p>​        而闭运算则相反，是先进行膨胀，再进行腐蚀的一种操作。它主要用于填充图像中的空洞部分，在opencv中同样有一个专门的函数进行闭运算。</p><p>​        函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">opening <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_OPEN<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#开运算，img_test3是要进行处理的图片，cv2.MORPH_OPEN表示要进行的是开运算（先腐蚀后膨胀），kernel则跟上面的函数一样，是定义好的卷积核。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"> closing <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#闭运算，这里的函数参数跟上一个函数作用一样，cv2.MORPH_OPEN表示要进行的是闭运算（先膨胀后腐蚀）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span><span class="token comment">#读入图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>opening <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_OPEN<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#开运算，先腐蚀后膨胀，能够去除图像中粘连的部分</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">,</span>opening<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的卷积核大小</span>closing <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#闭运算，先膨胀后腐蚀，能够填补图像中间的空隙</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"close"</span><span class="token punctuation">,</span>closing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><p>​        开运算:</p><p><img src="dqwdqew.png" alt="img"></p><p>​        闭运算：效果不明显，但是如果该图像中间有空洞存在，那么我们可以明显的看到空洞被填上了。</p><p> <img src="ceacergaefr.png" alt="img"></p><pre><code>     梯度运算</code></pre><p>​        原理：将图像分别进行膨胀和腐蚀，然后两者相减，则可以得到该图像的轮廓，而opencv中同样提供了进行梯度运算的函数。</p><p>​        函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">gradient <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_GRADIENT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#这里的pie是将要进行处理的二值图像，cv2.MORPH_GRADIENT表示进行梯度运算，kernel则是定义好的卷积核。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        代码示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltpie <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"pie.png"</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"pie"</span><span class="token punctuation">,</span>pie<span class="token punctuation">)</span><span class="token comment">#展示原图</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span class="token comment">#梯度运算，通过膨胀减去腐蚀得到轮廓</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定卷积核大小</span>gradient <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_GRADIENT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#梯度运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"gradient"</span><span class="token punctuation">,</span>gradient<span class="token punctuation">)</span><span class="token comment">#展示处理后的图像</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        运行结果</p><p>​        原图</p><p><img src="ewaVQERWEFWRVA.png" alt="img"></p><p>​        处理后得到的图像轮廓</p><p><img src="ce.PNG" alt="img"></p><pre><code>     礼帽与黑帽</code></pre><p>​        礼帽：将图像先进行开运算，再以原始图像减去开运算的结果，我们就可以得到图像被腐蚀掉的粘连部分，或者说原图中灰度较亮的区域，所以也称白顶帽变换。</p><p>​        黑帽：将图像先进行闭运算，再将闭运算的结果减去原始图像，作用我们就可以得到原图像中被填充的空洞部分，也就是图像中件较暗的空洞区域，所以又称黑底帽变换。</p><p>​        函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">tophat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#礼帽运算，cv2.MORPH_TOPHAT表示进行的是礼帽运算，即原图像-开运算。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">blackhat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_BLACKHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#黑帽运算，cv2.MORPH_BLACKHAT表示进行的是黑帽运算，即闭运算-原图像。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        代码示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span><span class="token comment">#读入图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span class="token comment">#礼帽，原始图像-开运算，得到的就是被腐蚀掉的粘连部分</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定卷积核大小</span>tophat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#礼帽运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"tophat"</span><span class="token punctuation">,</span>tophat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#黑帽运算，闭运算-原始图像，得到的是膨胀之前原始图像中比较暗的部分，即中间的空洞</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定卷积核大小</span>blackhat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_BLACKHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#黑帽运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"blackhat"</span><span class="token punctuation">,</span>blackhat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        运行结果</p><p>​        原图</p><p><img src="QWDQWD.png" alt="img"></p><p>​        礼帽，可以看到图像粘连部分被剔除出来了</p><p><img src="wdqqwdqw.png" alt="img"></p><p>​        黑帽，我们得到了迪哥中间微小的空洞部分</p><p><img src="sqwdw.png" alt="img"></p><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 （1）</title>
      <link href="/2023/02/06/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%EF%BC%881%EF%BC%89/"/>
      <url>/2023/02/06/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><h3 id="确定性现象-必然现象"><a href="#确定性现象-必然现象" class="headerlink" title="确定性现象/必然现象"></a>确定性现象/必然现象</h3><p>​        确定性：一定发生/一定不发生</p><p>​        随机/偶然：可能发生，可能不发生</p><p>​        统计规律：事件发生的规律</p><p>​        实验：观测，测量，实验</p><p>​        随机试验：1）在相同的条件下可以重复</p><p>​                            2）结果不止一个</p><p>​                            3）无法预测</p><p>​        结果用E来表示</p><p>​        事件：每一种结果就叫一个事件</p><p>​        随机事件：随机发生的事件</p><p>​        基本事件：一个事件不能再分或者没有必要再分（相对于实验目的来说）</p><p>​        复合事件：基本事件组成复合事件</p><p>​        必然事件：一定发生（$\Omega$）</p><p>​        不可能事件：一定不发生（$\phi$）</p><p>​        样本空间：所有的基本事件的集合</p><p>​        样本点：样本空间的元素</p><h3 id="事件之间的关系"><a href="#事件之间的关系" class="headerlink" title="事件之间的关系"></a>事件之间的关系</h3><h4 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h4><p>​        定义A发生必然导致B发生就是A包含于B，或者B包含A</p><script type="math/tex; mode=display">A \subset B或写作B\supset A</script><p><img src="image-20230206134525647.png" alt="image-20230206134525647"></p><p>​        <strong>注意这两个符号：$\subset$和$\in$的区别：前者地位平等，阐述的是集合与集合的关系；后者地位不平等，阐述的是集合于元素之间的关系！</strong></p><h4 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h4><p>​        如果</p><script type="math/tex; mode=display">A\subset B,B\supset A \rightarrow A=B</script><h4 id="并（和）"><a href="#并（和）" class="headerlink" title="并（和）"></a>并（和）</h4><p>​        定义他们是A或者B发生：</p><script type="math/tex; mode=display">A \cup B或记作A+B</script><p><img src="image-20230206134547279.png" alt="image-20230206134547279"></p><p>注意这样的一些性质值得我们的注意：</p><script type="math/tex; mode=display">A+B \supset A,A+A=A,A+\emptyset=A,A+\Omega=\Omega</script><h4 id="交（积）"><a href="#交（积）" class="headerlink" title="交（积）"></a>交（积）</h4><p>​        定义A，B同时发生为他们的交：</p><script type="math/tex; mode=display">A\cap B或记作AB</script><p><img src="image-20230206135414625.png" alt="image-20230206135414625"></p><script type="math/tex; mode=display">AB \subset A,AA=A,A\emptyset=\emptyset,A\Omega=A</script><h4 id="差"><a href="#差" class="headerlink" title="差"></a>差</h4><p>​        定义一个发生另一个不发生的区域叫两个事件的差：</p><p><img src="image-20230206135456654.png" alt="image-20230206135456654"></p><script type="math/tex; mode=display">A-B</script><script type="math/tex; mode=display">A-B=A-AB</script><h4 id="多个事件"><a href="#多个事件" class="headerlink" title="多个事件"></a>多个事件</h4><p>多个事件的和：</p><script type="math/tex; mode=display">A_1 \cup A_2\cup A_3\cup ...\cup A_n=\cup_{i=1}^nA_i</script><p>多个事件的并：</p><script type="math/tex; mode=display">A_1 \cap A_2\cap A_3\cap ...\cap A_n=\cap_{i=1}^nA_i</script><p><strong>无限可列：能按一个规律拍成一个序列就叫无限可列</strong></p><h3 id="互不相容与对立事件"><a href="#互不相容与对立事件" class="headerlink" title="互不相容与对立事件"></a>互不相容与对立事件</h3><p>​        如果A，B不同时发生，就有以下简记：</p><script type="math/tex; mode=display">AB=\emptyset</script><p>​        如果一个集合下，不是A就是B，那就称呼A,B是对立事件</p><script type="math/tex; mode=display">A \cap B=\emptyset,A \cup B = \Omega \rightarrow A=\bar{B}</script><p>​        于是又有新的性质</p><p>1)</p><script type="math/tex; mode=display">A-B=A-AB=A\bar{B}</script><p>2)互相对立的事件一定互不相容</p><p>3）互不相容适用于多个事件，对立却只用于描述两个事件的关系</p><h3 id="完备事件组"><a href="#完备事件组" class="headerlink" title="完备事件组"></a>完备事件组</h3><p>​        如果我们列举出来的一些互不相容的事件把所有情况说全了：</p><script type="math/tex; mode=display">\cup_{i=1}^n A_i=\Omega</script><h3 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h3><p>1）交换律：</p><script type="math/tex; mode=display">A\cup B=B\cup A \\ A\cap B=B\cap A</script><p>2）结合律：</p><script type="math/tex; mode=display">(A\cup B)\cup C=A\cup(B\cup C)\\(A\cap B)\cap C=A\cap(B\cap C)</script><p>3)分配律</p><script type="math/tex; mode=display">(A \cup B)\cap C=(A\cap C)\cup(B\cap C)</script><p><img src="image-20230206140705953.png" alt="image-20230206140705953"></p><script type="math/tex; mode=display">(A \cap B)\cup C=(A\cup C)\cap(B\cup C)</script><p><img src="image-20230206140849230.png" alt="image-20230206140849230"></p><p>4)德摩根律</p><script type="math/tex; mode=display">\overline{A\cup B}=\bar A \cap\bar B</script><p><img src="image-20230206141037146.png" alt="image-20230206141037146"></p><script type="math/tex; mode=display">\overline{A\cap B}=\bar A \cup\bar B</script><p>例子：ABC都是试验随机事件：</p><p>1）A发生：A</p><p>2）只有A发生：$A \bar B\bar C$</p><p>3)有A，B，C卡有一个发生：$A \bar B\bar C+\bar A B\bar C+\bar A \bar B C$</p><p>4)ABC同时发生：ABC</p><p>5）ABC至少一个发生：A+B+C</p><p>6)至多一个发生：$\bar A \bar B\bar C+A \bar B\bar C+\bar A B\bar C+\bar A \bar B C$</p><p>7)恰有两个：$A  B\bar C+A B\bar C+A \bar B C$</p><p>8)至少两个：$A  B\bar C+A B\bar C+A \bar B C+ABC$或者$AB+BC+AC$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数基本教程 （1）</title>
      <link href="/2023/02/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B-%EF%BC%881%EF%BC%89/"/>
      <url>/2023/02/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B-%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>这个科目，我们将要讨论矩阵，矩阵有很多不同于基础代数的东西。</p><p>​        比如说，将矩阵不满足交换率，不可以作分母$\frac{1}{A}$</p><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>​        现在我们注意，这门学科起步于线性方程组</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}5x+6y & = & 7 \\9x+4y & = & 3\end{aligned}\right.\end{equation}</script><p>​        我们只解不化简：</p><p><img src="image-20230116173337212.png" alt="image-20230116173337212"></p><p>​        </p><p>我们引入这样的符号：</p><script type="math/tex; mode=display">\left |\begin{array}{cccc}a &b   \\c &d  \\\end{array}\right|</script><p>我们使之这个表示为$ad-bc$，这就是行列式</p><script type="math/tex; mode=display">\left| \begin{array}{} a_{11}& a_{12}\\a_{21}& a_{22}\\\end{array} \right|</script><p>​        其$a_{ij}$中i , j表示行标，列标。那么：</p><script type="math/tex; mode=display">\left| \begin{array}{} a_{11}& a_{12}\\a_{21}& a_{22}\\\end{array} \right|=a_{11}a_{22}-a_{12}a_{21}</script><p><img src="image-20230116174009469.png" alt="image-20230116174009469"></p><h3 id="三阶行列式"><a href="#三阶行列式" class="headerlink" title="三阶行列式"></a>三阶行列式</h3><p>​        </p><script type="math/tex; mode=display">\left | \begin{array}{}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{array}\right |</script><p> 这是一个三阶行列式，他的求法是这样的：</p><p><img src="image-20230116174744466.png" alt="image-20230116174744466"></p><p><img src="image-20230116174752643.png" alt="image-20230116174752643"></p><p><img src="image-20230116174917249.png" alt="image-20230116174917249"></p><p><img src="image-20230116174924145.png" alt="image-20230116174924145"></p><p>​        不过，还有别的方法，不推荐这种方法计算</p><h3 id="排列与逆序"><a href="#排列与逆序" class="headerlink" title="排列与逆序"></a>排列与逆序</h3><p>​        排列：由1，2，3，4，…n组成的一个有序数组叫N级排列</p><p>​                                                        123,132,213,231,312,321</p><p>​        这是一个三级排列</p><p>​        而3145不是一个五级排列。因为少了2.</p><p>​        N级排列有n!种</p><p>​        </p><p>​        逆序：</p><p>​        大数排在了小数前面，构成了一个逆序：</p><p>​        4213：4排在了2的前面，故这是一个逆序</p><p>​        逆序数：逆序的总数</p><p>​        4213：4后面3个，2：一个，之后没有了，故是4个</p><p>​        可以记作：N(4213)=4</p><p>​        偶排列和奇排列：排列数奇偶</p><p>​        若N(1234…n)=0则称之为标准排列（自然排列）</p><p>​        对于完全逆序的排列：N(n(n-1)(n-2)…321)=$\frac{n(n-1)}{2}$</p><p>​        </p><p>​        对换：交换两个数</p><p>​        我们对一个排序进行对换：可以发现奇偶性改变一次（后面行列式会用到）</p><p>​        N排列中，奇偶排列个数相等，各占一半</p><h3 id="基本求解"><a href="#基本求解" class="headerlink" title="基本求解"></a>基本求解</h3><p>​        我们是这样求解N阶的行列式：</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &a_{12}&...&a_{1n-1}&a_{1n} \\a_{21} &a_{22}&...&a_{2n-1}&a_{2n}\\a_{31} &a_{32}&...&a_{3n-1}&a_{3n}\\...&...&...&...&...\\a_{n1}&a_{n2}&...&a_{nn-1}&a_{nn}\end{array} \right|\end{array}=\sum_{j_1j_2j_3...j_n}(-1)^{N(j_1j_2j_3...j_n)}a_{1j_1}a_{2j_2}a_{3j_3}...a_n{j_n}</script><p>这是按行展开的。</p><p>太抽象了，我们后面使用别的办法求解：是这样的—-我们的j_n求所有可能排列</p><p>我们有这样的一些特殊的矩阵值得注意：</p><p>1）下三角行列式</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &0&...&0&0 \\a_{21} &a_{22}&...&0&0\\a_{31} &a_{32}&...&0 &0\\...&...&...&...&...\\a_{n1}&a_{n2}&...&a_{nn-1}&a_{nn}\end{array} \right|\end{array}</script><p>这是有趣的：因为我们这个行列式的值就是$a_{11}a_{22}a_{33}…a_{nn}$</p><p>2)上三角行列式</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &a_{12}&...&a_{1n-1}&a_{1n} \\0 &a_{22}&...&a_{2n-1}&a_{2n}\\0 &0&...&a_{3n-1}&a_{3n}\\...&...&...&...&...\\0&0&...&0&a_{nn}\end{array} \right|\end{array}</script><p>这是有趣的：因为我们这个行列式的值就是$a_{11}a_{22}a_{33}…a_{nn}$，跟上面的一样</p><p>3）对角行列式</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &0&...&0&0 \\0 &a_{22}&...&0&0\\0 &0&...&0&0\\...&...&...&...&...\\0&0&...&0&a_{nn}\end{array} \right|\end{array}</script><p>这个行列式的值还是上面我提到的那个</p><p>但是下面的有些不同。</p><p>反下三角行列式</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}0 &0&...&0&a_{1n} \\0 &0&...&a_{2n-1}&a_{2n}\\0 &0&...&a_{3n-1}&a_{3n}\\...&...&...&...&...\\a_{n1}&a_{n2}&...&a_{nn-1}&a_{nn}\end{array} \right|\end{array}=(-1)^{\frac{n(n-1)}{2}}a_{1n}a_{2n-1}...a_{n1}</script><p>还有这种：</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &a_{12}&...&a&a_{1n} \\a_{21} &a_{22}&...&a_{2n-1}&0\\a_{31} &a_{32}&...&0&0\\...&...&...&...&...\\a_{n1}&0&...&0&0\end{array} \right|\end{array}=(-1)^{\frac{n(n-1)}{2}}a_{1n}a_{2n-1}...a_{n1}</script><p>总结看来就是这样的：</p><p><img src="image-20230124183544432.png" alt="image-20230124183544432"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​        现在来看一个行列式：</p><script type="math/tex; mode=display">D=\left |\begin{matrix}1&2&3\\1&1&1\\8&8&8\\\end{matrix}\right |</script><p>​        现在，我们把行写出列，列写成行，那就是：</p><script type="math/tex; mode=display">D^T=\left | \begin{matrix}1&1&8\\2&1&8\\3&1&8\\\end{matrix}\right |</script><p>那显然：</p><script type="math/tex; mode=display">(D^T)^T=D</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>1）$D^T=D$</p><p>2)两行交换，行列式只<strong>变号</strong></p><p>3）两行（列）相等，D=0\</p><p>4)某一行都有公因子k,那就提N次：</p><script type="math/tex; mode=display">\left| \begin{matrix} ...&...&...&...\\ka &kb&kc&...\\...&...&...&...\\\end{matrix} \right |=k^n\left| \begin{matrix} ...&...&...&...\\a &b&c&...\\...&...&...&...\\\end{matrix} \right |</script><p>5)两行对应成比例：那还是行列式的值是0！</p><p>6）对于这样的行列式：</p><script type="math/tex; mode=display">\left| \begin{matrix} ...&...&...&...\\a+d &b+e&c+f&...\\...&...&...&...\\\end{matrix} \right |=\left| \begin{matrix} ...&...&...&...\\a &b&c&...\\...&...&...&...\\\end{matrix} \right |+\left| \begin{matrix} ...&...&...&...\\d &e&f&...\\...&...&...&...\\\end{matrix} \right |</script><p>其余行都不动</p><p>7）某一行乘上一个数加到另一行上，行列式的值还是不变！</p><p>我们可以使用这些性质来求解行列式的值：</p><p>1）<strong>先处理第一行，在处理第二行。。。依次处理即可！不要随意处理！</strong></p><p>或者：</p><p>2）<strong>先处理第一列，在处理第二列。。。依次处理即可！不要随意处理！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab 入门 （1）</title>
      <link href="/2023/02/02/Matlab-%E5%85%A5%E9%97%A8-%EF%BC%881%EF%BC%89/"/>
      <url>/2023/02/02/Matlab-%E5%85%A5%E9%97%A8-%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab入门（1）"><a href="#Matlab入门（1）" class="headerlink" title="Matlab入门（1）"></a>Matlab入门（1）</h1><h3 id="1-matlab（2014a）的界面介绍"><a href="#1-matlab（2014a）的界面介绍" class="headerlink" title="1.matlab（2014a）的界面介绍"></a>1.matlab（2014a）的界面介绍</h3><p><img src="image-20221224193149319.png" alt="image-20221224193149319"></p><p>​        左边是Current Folders:也就是文件区，正中心是命令窗口：输入命令的地方。右上角的WorkSpace（工作区）是储存变量的地方，而右下角的Command History则是命令的历史记录。</p><p><img src="image-20221224193538040.png" alt="image-20221224193538040"></p><p>​        这是2021A版的界面，不过，默认是没有命令历史窗口，需要从布局&gt;&gt;命令历史记录&gt;&gt;勾选停靠，才可以调出历史记录。</p><h3 id="2-matlab的运算符"><a href="#2-matlab的运算符" class="headerlink" title="2.matlab的运算符"></a>2.matlab的运算符</h3><p>​        运算符有以下几种：+，-，*，/，^(这是次方)</p><p><img src="image-20221224193919840.png" alt="image-20221224193919840"></p><p>​                                                                                             （实例）</p><p>​        Precedence Rules（运算优先级规则）</p><p>​        1.在同一级上从左到右</p><p>​        2.从高到底：</p><p>​            1.括号（）</p><p>​            2.次方（^）</p><p>​            3.乘除（*，/）</p><p>​            4.加减（+，-）</p><p>下面可以做一些练习：</p><ol><li><script type="math/tex; mode=display"></script><script type="math/tex; mode=display">cos(\sqrt{\frac{(1+2+3+4)^3}5})2.</script></li></ol><p>2.</p><script type="math/tex; mode=display">sin(\sqrt{\pi})+ln(tan(1))</script><p>3.</p><script type="math/tex; mode=display">2^{3.5\times1.7}</script><p>4.</p><script type="math/tex; mode=display">e^{sin(10)}</script><p>答案：<img src="ans.png" alt="ans"></p><p>​        函数可以嵌条调用，由此，我们可以分布，减少错误</p><p>​        如：</p><p><img src="1.png" alt="1"></p><p>​        对于非常复杂的运算，下面的那个是推介的</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>​        在Matlab里面，我们不需要声明变量的类型，就可以创造一个变量（LHS=RHS）</p><p><img src="image-20221224201954977.png" alt="image-20221224201954977"></p><p>​        此时，我们的WorkSpace：</p><p><img src="image-20221224202037986.png" alt="image-20221224202037986"></p><p>​        注意：</p><p>​        （1）大小写是敏感的，A与a是不一样的</p><p>​        （2）不要以数字开头，但是可以变量里有数字</p><p>​            变量的种类：</p><p><img src="image-20221224202401689.png" alt="image-20221224202401689"></p><p>​        我们默认创造的数字类型是double(不是int!)</p><p>​        查看变量的种类的方法：</p><p>​        双击workspace变量跳出表格：其名字为1 * 1 double,或者,在命令窗口打whos:</p><p><img src="image-20221224202650334.png" alt="image-20221224202650334"></p><p>​        注意：下面是一些特殊的关键字（Keyword）：</p><p><img src="image-20221224202919711.png" alt="image-20221224202919711"></p><p>​    （iskeyword查看已有关键字）</p><p>​        这是Matlab调用的优先级：</p><p><img src="image-20221224203437595.png" alt="image-20221224203437595"></p><h3 id="标准输出调整"><a href="#标准输出调整" class="headerlink" title="标准输出调整"></a>标准输出调整</h3><p>​        Format格式有以下几种</p><p><img src="image-20221224203627494.png" alt="image-20221224203627494"></p><p><img src="image-20221224203819131.png" alt="image-20221224203819131"></p><p><img src="image-20221224203840545.png" alt="image-20221224203840545"></p><p>​        （rat让一个小数以分数形式表示）</p><p>​        a=10;打上分号让matlab不会显示这句话的运算结果。</p><p>​        回溯历史指令：按上回到之前的指令</p><p><img src="image-20221224204349793.png" alt="image-20221224204349793"></p><p>​         vector and matrix</p><p>​        向量（vector）</p><p>​        行向量（row vector）</p><p>​        格式：var=[(num num2 …) ]或者是var=[num,num2,num3,…]</p><p>​        a=[1 2 3 4] or a=[1,2,3,4]</p><p><img src="image-20221224204934420.png" alt="image-20221224204934420"></p><p>​        列向量（column vector）</p><p>​        var=[num1;num2;num3;…]</p><p>​        a=[1;2;3;4]</p><p><img src="image-20221224205359229.png" alt="image-20221224205359229"></p><p>​        当然：a<em>b与b</em>a显然是不太一样的</p><p><img src="image-20221224205457245.png" alt="image-20221224205457245"></p><p>​        输入一个矩阵是这样的：</p><p>​        matrix=[num11,num12,num13…(Row1);num21,num22,…]</p><p>​        m=[1,2,3;4,5,6;7,8,9]</p><p><img src="image-20221224205752715.png" alt="image-20221224205752715"></p><p>​        索引方法</p><p>​        vector（index）(直接取第index个数)</p><p>​        matrix:</p><p>​        法一：matrix（rownum,colnum）</p><p>​        如m(1,2)</p><p><img src="image-20221224210140942.png" alt="image-20221224210140942"></p><p>​        法二：matrix([num1 num2],[num3 num4])</p><p>​        (取其排列组合的组合下表的数组成新的矩阵)</p><p>​        m([1 3],[1 3])</p><p><img src="image-20221224210443939.png" alt="image-20221224210443939"></p><p>​        方法三：matrix(a)</p><p>​        矩阵按列存储，故：m(1)=1,m(2)=4,m(4)=2…</p><p><img src="image-20221224210642070.png" alt="image-20221224210642070"></p><p>​        方法四：matrix([num1 num2 num3…（row1）；num4 num5,num6,…(row n)])</p><p>​        以方法三的排列为基础，取出m(num i)构成一个矩阵</p><p><img src="image-20221224211142755.png" alt="image-20221224211142755"></p><p>​        于是，我们也可以用如此的索引更改矩阵的数</p><h3 id="矩阵里有规律的快速输入"><a href="#矩阵里有规律的快速输入" class="headerlink" title="矩阵里有规律的快速输入"></a>矩阵里有规律的快速输入</h3><p>​    colon operator(:)</p><p>​    用于声明等差的vector</p><p>​    （1）a=num1:num2;(差为1的等差数列)</p><p><img src="image-20221224211635032.png" alt="image-20221224211635032"></p><p>​        (2)a=num1:num2:num3(差为num2的等差数列)</p><p><img src="image-20221224211754286.png" alt="image-20221224211754286"></p><p>​        (3)a=[num1:num2;num3:num4:num5;…]生成矩阵</p><p>​        (4)a=((num1,):)(表示全部)</p><p><img src="image-20221224212148933.png" alt="image-20221224212148933"></p><p>​        空[]去掉一行or一列</p><p><img src="image-20221224212232261.png" alt="image-20221224212232261"></p><p>​        对于可以合并为[A|B]的矩阵，matlab支持[A B]或者[A;B]的操作</p><p><img src="image-20221224212455824.png" alt="image-20221224212455824"></p><p>​        matlab的矩阵运算</p><p><img src="image-20221224212731039.png" alt="image-20221224212731039"></p><p>​        点乘点除是对应位置的数直接乘or除</p><p>​        特殊矩阵：</p><p><img src="image-20221224212922825.png" alt="image-20221224212922825"></p><p>​        matlab的特殊函数：</p><p><img src="image-20221224213011614.png" alt="image-20221224213011614"></p><h2 id="Matlab程序书写"><a href="#Matlab程序书写" class="headerlink" title="Matlab程序书写"></a>Matlab程序书写</h2><p>1.新建一个脚本程序</p><p>单击新建脚本后开始编写</p><p><img src="image-20221225192111703.png" alt="image-20221225192111703"></p><p>之后按F5或者是单击运行。</p><p>在一句最前面加上%表明这是注解</p><p>%%之间划分“节”，让脚本可以分块执行（其中变黄区块表面选中节）</p><p><img src="image-20221225193608481.png" alt="image-20221225193608481"></p><p>（Run：全部执行与Run Section：选中节执行）</p><p>Breaking point：对想检查的语句的下一句和行数处单击产生断点，从而在这一句停下来，随后可以再按continue或者是F5继续。</p><p>在Debug模式下可以将光标停在变量上查看具体属性</p><h3 id="基本的程序结构"><a href="#基本的程序结构" class="headerlink" title="基本的程序结构"></a>基本的程序结构</h3><p><img src="image-20221225194455880.png" alt="image-20221225194455880"></p><h3 id="基本的逻辑符号"><a href="#基本的逻辑符号" class="headerlink" title="基本的逻辑符号"></a>基本的逻辑符号</h3><p><img src="image-20221225194615602.png" alt="image-20221225194615602"></p><p>1.if/elseif/else结构</p><p>if condition1</p><p>​        statement1</p><p>elseif condition2</p><p>​        statement2</p><p>else</p><p>​        statement3</p><p>end</p><p>2.switch结构</p><p><img src="image-20221225195627982.png" alt="image-20221225195627982"></p><p>注意这里不同于C/C++:这里不需要break.</p><p>3.while</p><p><img src="image-20221225195751347.png" alt="image-20221225195751347"></p><p>(prod(1:n)表示阶乘)</p><p>4.for循环</p><p><img src="image-20221225200500864.png" alt="image-20221225200500864"></p><p>注意：</p><p>对于大矩阵要先初始化：</p><p>如A=zeros(2000,2000)</p><p>5.break</p><p>在while里break以中断while循环</p><p><img src="image-20221225201538350.png" alt="image-20221225201538350"></p><p>一些小提示：</p><p><img src="image-20221225201616354.png" alt="image-20221225201616354"></p><p>补充：clc：清空历史</p><h2 id="Matlab的自定义函数"><a href="#Matlab的自定义函数" class="headerlink" title="Matlab的自定义函数"></a>Matlab的自定义函数</h2><p>对于一个function文件：分为三个部分</p><p>function y=func()</p><p>comment：表明这个func的功能</p><p>功能代码</p><p><img src="image-20221225202351453.png" alt="image-20221225202351453"></p><p>为了可以使用自定义代码：请跳转到工作文件夹</p><p>Matlab可以定义多输入与多输出的函数：</p><p><img src="image-20221225203129714.png" alt="image-20221225203129714"></p><p>Matlab也支持定义匿名函数：</p><p><img src="image-20221225203836565.png" alt="image-20221225203836565"></p><h3 id="基本的变量结构"><a href="#基本的变量结构" class="headerlink" title="基本的变量结构"></a>基本的变量结构</h3><p><img src="image-20221226155045231.png" alt="image-20221226155045231"></p><p>这是常见的种类</p><h5 id="char-character"><a href="#char-character" class="headerlink" title="char:character"></a>char:character</h5><p>这是字符变量</p><h5 id="string：字符串"><a href="#string：字符串" class="headerlink" title="string：字符串"></a>string：字符串</h5><p>可以理解 为用数组储存的若干的char</p><p>于是可以这样加长：</p><p>s3=[s1 s2];</p><p>s4=[s1;s2];</p><h5 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct:结构"></a>struct:结构</h5><p><img src="image-20221226160704872.png" alt="image-20221226160704872"></p><h5 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h5><p><img src="image-20221226161005675.png" alt="image-20221226161005675"></p><p>Cell可以是一个大杂烩：里面可以储存不一样的数据</p><p><img src="image-20221226161237213.png" alt="image-20221226161237213"></p><p>一些函数：</p><p><img src="image-20221226161752014.png" alt="image-20221226161752014"></p><h1 id="matlab使用教程"><a href="#matlab使用教程" class="headerlink" title="matlab使用教程"></a>matlab使用教程</h1><p>如何把我们的数据存成文件：</p><p>save 文件名.mat（把文件以二进制的形式存储）</p><p>save 文件名.mat -ascii（把文件以ASCII的形式存储）</p><p>从excel中读取信息：</p><p>xlsread(‘filename.xlsx’,’列与行’)</p><p>xlswrite向Excel写入数据</p><p>（‘filename.xlsx’,数据,sheet,location）</p><p><img src="image-20221226163047228.png" alt="image-20221226163047228"></p><h3 id="Basic绘图"><a href="#Basic绘图" class="headerlink" title="Basic绘图"></a>Basic绘图</h3><p>​        我们怎么绘制一个函数呢？首先啊，我们知道函数是由足够密集的点连成的。也就是说，我们只需要把一个区间段的函数的X—Y点连起来就好了</p><p>​        我们使用plot函数来绘制图像：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>#<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>是一对点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        也可以这样使用</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>#where xx<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token function">length</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        如：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0</span>：<span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230122201210020.png" alt="image-20230122201210020"></p><p>​        运行上面的这句话，这就是结果</p><p>​        可不可以两个图像叠在一起嘞？可以</p><p><img src="image-20230122202456650.png" alt="image-20230122202456650"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold on<span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以绘制多个图像了：hold on表明重复画不刷新画布</p><p>我们当然可以设置函数曲线的格式：</p><p><img src="image-20230122203054085.png" alt="image-20230122203054085"></p><p>​        这样：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold on<span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'or'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'xg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230122203329996.png" alt="image-20230122203329996"></p><p>字符串里的格式顺序没有要求，有什么需求就塞。</p><p>有的时候，我们的函数很多很乱，</p><p>比如说在脚本里运行如下的代码：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold onx<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">4</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">;</span>y<span class="token operator">=</span><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>h<span class="token operator">=</span><span class="token function">cos</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token operator">=</span><span class="token number">1.</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>g<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token operator">.*</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.</span><span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token operator">.^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">./</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'bd-'</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>h<span class="token punctuation">,</span><span class="token string">'gp:'</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>w<span class="token punctuation">,</span><span class="token string">'ro-'</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>g<span class="token punctuation">,</span><span class="token string">'c^-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230122204242509.png" alt="image-20230122204242509"></p><p>我们可不可以做一点注记嘞？可以，使用legend函数就好了</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'L1'</span><span class="token punctuation">,</span><span class="token punctuation">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，这需要和你依次绘制函数的图像的顺序是一致的：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">#<span class="token punctuation">...</span><span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'sin(x)'</span><span class="token punctuation">,</span><span class="token string">'cos(x)'</span><span class="token punctuation">,</span><span class="token string">'Sigmoid'</span><span class="token punctuation">,</span><span class="token string">'Gauss Functions'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230122204721499.png" alt="image-20230122204721499"></p><p>那。。。可不可以多上一个坐标轴的标记</p><p>使用函数xlabel(‘showstr’),ylabel(“showstr”)和图像标题title(‘showstr’)</p><p><img src="image-20230122205415466.png" alt="image-20230122205415466"></p><p>text()和annotation()</p><p>我们有的时候需要在图片上来打一些字符：这需要我们来使用$LaTex$实现！比如说：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token operator">=</span>x<span class="token operator">.^</span><span class="token number">2.</span><span class="token operator">*</span><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token number">i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">:</span><span class="token number">0.01</span><span class="token operator">:</span><span class="token number">2</span>    <span class="token function">line</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token operator">^</span><span class="token number">i</span><span class="token operator">*</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span>str<span class="token operator">=</span><span class="token string">'$$\int_&#123;0&#125;^&#123;2&#125;x^2\sin(x) dx$$'</span><span class="token punctuation">;</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token number">0.25</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span><span class="token string">'Interpreter'</span><span class="token punctuation">,</span><span class="token string">'latex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#固定用法<span class="token function">annotation</span><span class="token punctuation">(</span><span class="token string">'arrow'</span><span class="token punctuation">,</span><span class="token string">'X'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.32</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'Y'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230202185243199.png" alt="image-20230202185243199"></p><h4 id="图像字体的调整："><a href="#图像字体的调整：" class="headerlink" title="图像字体的调整："></a>图像字体的调整：</h4><p>​        我们的绘图本身就是由很多个元素构成：图像本身，线条，文字等等。我们现在想办法使用代码去更改他们！</p><p><img src="image-20230202190117981.png" alt="image-20230202190117981"></p><p>​        类似于C指针的，我们的操作也可以返回这些对象的句柄（指针），比如说：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">h<span class="token operator">=</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        返回了函数画布的句柄！</p><p><img src="image-20230202190810805.png" alt="image-20230202190810805"></p><p>​        相关的可以了解对象树的概念！</p><p>​        我们使用get()方法来取回对象！set()来设定对象属性。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token operator">=</span><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>h<span class="token operator">=</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">get</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们的控制台返回了这样一串东西：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">AlignVertexCenters<span class="token operator">:</span> off           Annotation<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> matlab<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>eventdata<span class="token punctuation">.</span>Annotation<span class="token punctuation">]</span>         BeingDeleted<span class="token operator">:</span> off           BusyAction<span class="token operator">:</span> <span class="token string">'queue'</span>        ButtonDownFcn<span class="token operator">:</span> <span class="token string">''</span>             Children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>             Clipping<span class="token operator">:</span> on                Color<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">0.4470</span> <span class="token number">0.7410</span><span class="token punctuation">]</span>            ColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>          ContextMenu<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>            CreateFcn<span class="token operator">:</span> <span class="token string">''</span>      DataTipTemplate<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> matlab<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>datatip<span class="token punctuation">.</span>DataTipTemplate<span class="token punctuation">]</span>            DeleteFcn<span class="token operator">:</span> <span class="token string">''</span>          DisplayName<span class="token operator">:</span> <span class="token string">''</span>     HandleVisibility<span class="token operator">:</span> <span class="token string">'on'</span>              HitTest<span class="token operator">:</span> on        Interruptible<span class="token operator">:</span> on             LineJoin<span class="token operator">:</span> <span class="token string">'round'</span>            LineStyle<span class="token operator">:</span> <span class="token string">'-'</span>        LineStyleMode<span class="token operator">:</span> <span class="token string">'auto'</span>            LineWidth<span class="token operator">:</span> <span class="token number">0.5000</span>               Marker<span class="token operator">:</span> <span class="token string">'none'</span>      MarkerEdgeColor<span class="token operator">:</span> <span class="token string">'auto'</span>      MarkerFaceColor<span class="token operator">:</span> <span class="token string">'none'</span>        MarkerIndices<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1000</span> uint64<span class="token punctuation">]</span>           MarkerMode<span class="token operator">:</span> <span class="token string">'auto'</span>           MarkerSize<span class="token operator">:</span> <span class="token number">6</span>               Parent<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Axes<span class="token punctuation">]</span>        PickableParts<span class="token operator">:</span> <span class="token string">'visible'</span>             Selected<span class="token operator">:</span> off   SelectionHighlight<span class="token operator">:</span> on          SeriesIndex<span class="token operator">:</span> <span class="token number">1</span>                  Tag<span class="token operator">:</span> <span class="token string">''</span>                 Type<span class="token operator">:</span> <span class="token string">'line'</span>             UserData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>              Visible<span class="token operator">:</span> on                XData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1000</span> double<span class="token punctuation">]</span>            XDataMode<span class="token operator">:</span> <span class="token string">'manual'</span>          XDataSource<span class="token operator">:</span> <span class="token string">''</span>                YData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1000</span> double<span class="token punctuation">]</span>          YDataSource<span class="token operator">:</span> <span class="token string">''</span>                ZData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">0</span> double<span class="token punctuation">]</span>          ZDataSource<span class="token operator">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后运行:get(gca)</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ALim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>                    ALimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                  AlphaScale<span class="token operator">:</span> <span class="token string">'linear'</span>                    Alphamap<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">64</span> double<span class="token punctuation">]</span>           AmbientLightColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                BeingDeleted<span class="token operator">:</span> off                         Box<span class="token operator">:</span> on                    BoxStyle<span class="token operator">:</span> <span class="token string">'back'</span>                  BusyAction<span class="token operator">:</span> <span class="token string">'queue'</span>               ButtonDownFcn<span class="token operator">:</span> <span class="token string">''</span>                        CLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>                    CLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>              CameraPosition<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3.5000</span> <span class="token number">0</span> <span class="token number">17.3205</span><span class="token punctuation">]</span>          CameraPositionMode<span class="token operator">:</span> <span class="token string">'auto'</span>                CameraTarget<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3.5000</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">]</span>            CameraTargetMode<span class="token operator">:</span> <span class="token string">'auto'</span>              CameraUpVector<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">]</span>          CameraUpVectorMode<span class="token operator">:</span> <span class="token string">'auto'</span>             CameraViewAngle<span class="token operator">:</span> <span class="token number">6.6086</span>         CameraViewAngleMode<span class="token operator">:</span> <span class="token string">'auto'</span>                    Children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Line<span class="token punctuation">]</span>                    Clipping<span class="token operator">:</span> on               ClippingStyle<span class="token operator">:</span> <span class="token string">'3dbox'</span>                       Color<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                  ColorOrder<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">7</span>×<span class="token number">3</span> double<span class="token punctuation">]</span>             ColorOrderIndex<span class="token operator">:</span> <span class="token number">2</span>                  ColorScale<span class="token operator">:</span> <span class="token string">'linear'</span>                    Colormap<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">256</span>×<span class="token number">3</span> double<span class="token punctuation">]</span>                 ContextMenu<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>                   CreateFcn<span class="token operator">:</span> <span class="token string">''</span>                CurrentPoint<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">2</span>×<span class="token number">3</span> double<span class="token punctuation">]</span>             DataAspectRatio<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3.5000</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>         DataAspectRatioMode<span class="token operator">:</span> <span class="token string">'auto'</span>                   DeleteFcn<span class="token operator">:</span> <span class="token string">''</span>                   FontAngle<span class="token operator">:</span> <span class="token string">'normal'</span>                    FontName<span class="token operator">:</span> <span class="token string">'Helvetica'</span>                    FontSize<span class="token operator">:</span> <span class="token number">10</span>                FontSizeMode<span class="token operator">:</span> <span class="token string">'auto'</span>               FontSmoothing<span class="token operator">:</span> on                   FontUnits<span class="token operator">:</span> <span class="token string">'points'</span>                  FontWeight<span class="token operator">:</span> <span class="token string">'normal'</span>                   GridAlpha<span class="token operator">:</span> <span class="token number">0.1500</span>               GridAlphaMode<span class="token operator">:</span> <span class="token string">'auto'</span>                   GridColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>               GridColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>               GridLineStyle<span class="token operator">:</span> <span class="token string">'-'</span>            HandleVisibility<span class="token operator">:</span> <span class="token string">'on'</span>                     HitTest<span class="token operator">:</span> on               InnerPosition<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1300</span> <span class="token number">0.1100</span> <span class="token number">0.7750</span> <span class="token number">0.8150</span><span class="token punctuation">]</span>                Interactions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> matlab<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>interaction<span class="token punctuation">.</span>interface<span class="token punctuation">.</span>DefaultAxesInteractionSet<span class="token punctuation">]</span>               Interruptible<span class="token operator">:</span> on     LabelFontSizeMultiplier<span class="token operator">:</span> <span class="token number">1.1000</span>                       Layer<span class="token operator">:</span> <span class="token string">'bottom'</span>                      Layout<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> matlab<span class="token punctuation">.</span>ui<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>LayoutOptions<span class="token punctuation">]</span>                      Legend<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>              LineStyleOrder<span class="token operator">:</span> <span class="token string">'-'</span>         LineStyleOrderIndex<span class="token operator">:</span> <span class="token number">1</span>                   LineWidth<span class="token operator">:</span> <span class="token number">0.5000</span>              MinorGridAlpha<span class="token operator">:</span> <span class="token number">0.2500</span>          MinorGridAlphaMode<span class="token operator">:</span> <span class="token string">'auto'</span>              MinorGridColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1000</span> <span class="token number">0.1000</span> <span class="token number">0.1000</span><span class="token punctuation">]</span>          MinorGridColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>          MinorGridLineStyle<span class="token operator">:</span> <span class="token string">':'</span>                    NextPlot<span class="token operator">:</span> <span class="token string">'replace'</span>             NextSeriesIndex<span class="token operator">:</span> <span class="token number">2</span>               OuterPosition<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                      Parent<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Figure<span class="token punctuation">]</span>               PickableParts<span class="token operator">:</span> <span class="token string">'visible'</span>          PlotBoxAspectRatio<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">0.7896</span> <span class="token number">0.7896</span><span class="token punctuation">]</span>      PlotBoxAspectRatioMode<span class="token operator">:</span> <span class="token string">'auto'</span>                    Position<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1300</span> <span class="token number">0.1100</span> <span class="token number">0.7750</span> <span class="token number">0.8150</span><span class="token punctuation">]</span>          PositionConstraint<span class="token operator">:</span> <span class="token string">'outerposition'</span>                  Projection<span class="token operator">:</span> <span class="token string">'orthographic'</span>                    Selected<span class="token operator">:</span> off          SelectionHighlight<span class="token operator">:</span> on                  SortMethod<span class="token operator">:</span> <span class="token string">'childorder'</span>                    Subtitle<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>          SubtitleFontWeight<span class="token operator">:</span> <span class="token string">'normal'</span>                         Tag<span class="token operator">:</span> <span class="token string">''</span>                     TickDir<span class="token operator">:</span> <span class="token string">'in'</span>                 TickDirMode<span class="token operator">:</span> <span class="token string">'auto'</span>        TickLabelInterpreter<span class="token operator">:</span> <span class="token string">'tex'</span>                  TickLength<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.0100</span> <span class="token number">0.0250</span><span class="token punctuation">]</span>                  TightInset<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.0512</span> <span class="token number">0.0540</span> <span class="token number">0.0071</span> <span class="token number">0.0206</span><span class="token punctuation">]</span>                       Title<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>     TitleFontSizeMultiplier<span class="token operator">:</span> <span class="token number">1.1000</span>             TitleFontWeight<span class="token operator">:</span> <span class="token string">'normal'</span>    TitleHorizontalAlignment<span class="token operator">:</span> <span class="token string">'center'</span>                     Toolbar<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> AxesToolbar<span class="token punctuation">]</span>                        Type<span class="token operator">:</span> <span class="token string">'axes'</span>                       Units<span class="token operator">:</span> <span class="token string">'normalized'</span>                    UserData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                        View<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">90</span><span class="token punctuation">]</span>                     Visible<span class="token operator">:</span> on                       XAxis<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> NumericRuler<span class="token punctuation">]</span>               XAxisLocation<span class="token operator">:</span> <span class="token string">'bottom'</span>                      XColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>                  XColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>                        XDir<span class="token operator">:</span> <span class="token string">'normal'</span>                       XGrid<span class="token operator">:</span> off                      XLabel<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>                        XLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">7</span><span class="token punctuation">]</span>                    XLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                XLimitMethod<span class="token operator">:</span> <span class="token string">'tickaligned'</span>                  XMinorGrid<span class="token operator">:</span> off                  XMinorTick<span class="token operator">:</span> off                      XScale<span class="token operator">:</span> <span class="token string">'linear'</span>                       XTick<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">]</span>                  XTickLabel<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token number">8</span>×<span class="token number">1</span> cell<span class="token punctuation">&#125;</span>              XTickLabelMode<span class="token operator">:</span> <span class="token string">'auto'</span>          XTickLabelRotation<span class="token operator">:</span> <span class="token number">0</span>                   XTickMode<span class="token operator">:</span> <span class="token string">'auto'</span>                       YAxis<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> NumericRuler<span class="token punctuation">]</span>               YAxisLocation<span class="token operator">:</span> <span class="token string">'left'</span>                      YColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>                  YColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>                        YDir<span class="token operator">:</span> <span class="token string">'normal'</span>                       YGrid<span class="token operator">:</span> off                      YLabel<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>                        YLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                    YLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                YLimitMethod<span class="token operator">:</span> <span class="token string">'tickaligned'</span>                  YMinorGrid<span class="token operator">:</span> off                  YMinorTick<span class="token operator">:</span> off                      YScale<span class="token operator">:</span> <span class="token string">'linear'</span>                       YTick<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">11</span> double<span class="token punctuation">]</span>                  YTickLabel<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token number">11</span>×<span class="token number">1</span> cell<span class="token punctuation">&#125;</span>              YTickLabelMode<span class="token operator">:</span> <span class="token string">'auto'</span>          YTickLabelRotation<span class="token operator">:</span> <span class="token number">0</span>                   YTickMode<span class="token operator">:</span> <span class="token string">'auto'</span>                       ZAxis<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> NumericRuler<span class="token punctuation">]</span>                      ZColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>                  ZColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>                        ZDir<span class="token operator">:</span> <span class="token string">'normal'</span>                       ZGrid<span class="token operator">:</span> off                      ZLabel<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>                        ZLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                    ZLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                ZLimitMethod<span class="token operator">:</span> <span class="token string">'tickaligned'</span>                  ZMinorGrid<span class="token operator">:</span> off                  ZMinorTick<span class="token operator">:</span> off                      ZScale<span class="token operator">:</span> <span class="token string">'linear'</span>                       ZTick<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>                  ZTickLabel<span class="token operator">:</span> <span class="token string">''</span>              ZTickLabelMode<span class="token operator">:</span> <span class="token string">'auto'</span>          ZTickLabelRotation<span class="token operator">:</span> <span class="token number">0</span>                   ZTickMode<span class="token operator">:</span> <span class="token string">'auto'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，我们很想设定GCA属性，就是使用set指令：我们找到了这个的指针（句柄）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">set</span><span class="token punctuation">(</span>gca<span class="token punctuation">,</span><span class="token string">'XLim'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">set</span><span class="token punctuation">(</span>gca<span class="token punctuation">,</span><span class="token string">'YLim'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1.2</span><span class="token punctuation">,</span><span class="token number">1.2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        当然。。。其实还有更简单的：</p><pre class="line-numbers language-none"><code class="language-none">xlim([0,2*pi]);ylim([-1.2,1.2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="多重图像展示"><a href="#多重图像展示" class="headerlink" title="多重图像展示"></a>多重图像展示</h3><p>​        我们可以使用figure来分开画图：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>y1<span class="token operator">=</span>x<span class="token operator">.^</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">;</span>y2<span class="token operator">=</span><span class="token function">exp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>figure<span class="token punctuation">,</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span>figure<span class="token punctuation">,</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230202195804959-167534035717165.png" alt="image-20230202195804959"></p><p>也可以在一个窗口上显示多个图像</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">subplot</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230202200620906.png" alt="image-20230202200620906"></p><p><img src="image-20230202200718788.png" alt="image-20230202200718788"></p><p><img src="image-20230202200912381.png" alt="image-20230202200912381"></p><p><img src="image-20230202200933449.png" alt="image-20230202200933449"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（5）</title>
      <link href="/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%885%EF%BC%89/"/>
      <url>/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%885%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="向量与线性计算"><a href="#向量与线性计算" class="headerlink" title="向量与线性计算"></a>向量与线性计算</h3><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>​        一个<strong>有大小，又有方向的量</strong> 我们有概念：模长（长度），假使 向量被记作:$\vec\alpha$，则它的长度就是它的模长：$|\vec\alpha|$,</p><p>​        我们又让长度就是1的向量成为单位向量。长度是0的向量是零向量。</p><p>​        位置关系上：有共线，垂直和相等的关系。</p><p>​        平行指的是夹角是0或者是180度。垂直就是90度等。</p><h4 id="线性运算"><a href="#线性运算" class="headerlink" title="线性运算"></a>线性运算</h4><p><img src="image-20230202144129473.png" alt="image-20230202144129473"></p><p><img src="image-20230202144231912.png" alt="image-20230202144231912"></p><p><img src="image-20230202144315494.png" alt="image-20230202144315494"></p><p><img src="image-20230202144356921.png" alt="image-20230202144356921"></p><h4 id="方向余弦"><a href="#方向余弦" class="headerlink" title="方向余弦"></a>方向余弦</h4><p>​        我们有时只考虑方向，我们可以把它归一化：这需要：</p><script type="math/tex; mode=display">\vec{e}=(\frac{x}{r},\frac{y}{r},\frac{z}{r})</script><p>其中：$r=\sqrt{x^2+y^2+z^2}$</p><p>​        有时也这样记：</p><script type="math/tex; mode=display">\vec{e}=(\cos\alpha,\cos\beta,\cos\gamma)</script><p>​        由于这样，我们可以把任意向量拆解为方向向量和长度的数量积</p><script type="math/tex; mode=display">\vec{\alpha}=L\vec{e}</script><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​        我们实际上可以使用如下的公式来计算一个向量在另一个向量的投影</p><script type="math/tex; mode=display">Prj_u\vec{a}=|\vec{a}|\cos\varphi</script><p>$\varphi$ 是两个向量的夹角</p><h5 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h5><script type="math/tex; mode=display">1)Prj_u(\vec{a}+\vec{b})=Prj_u\vec{a}+Prj_u\vec{b}</script><script type="math/tex; mode=display">2)Prj_u\lambda\vec{a}=\lambda Prj_u\vec{a}</script><h3 id="数量积"><a href="#数量积" class="headerlink" title="数量积"></a>数量积</h3><p><img src="image-20230202145138671.png" alt="image-20230202145138671"></p><p><img src="image-20230202145200044.png" alt="image-20230202145200044"></p><p><img src="image-20230202145233436.png" alt="image-20230202145233436"></p><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3><p>​        这是我们不熟悉的：</p><script type="math/tex; mode=display">\vec{c}=\vec{a}\times \vec{b}</script><p>​        首先模长是：</p><script type="math/tex; mode=display">|\vec{c}|=|\vec{a}||\vec{b}|\sin\theta</script><pre><code>     方向：右手从a到b。</code></pre><p>​        注意结果是一个向量！</p><p><img src="image-20230202145456287.png" alt="image-20230202145456287"></p><p><img src="image-20230202145504892.png" alt="image-20230202145504892"></p><h3 id="平面"><a href="#平面" class="headerlink" title="平面"></a>平面</h3><h4 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h4><p>​        曲面可以看成运动曲线的结果，我们常常使用方程：</p><script type="math/tex; mode=display">F(x,y,z)=0</script><p>来描述！</p><p>​        由此，曲线可以视作两个曲面的交：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}F(x,y,z) & = 0 \\G(x,y,z) & =  0\end{aligned}\right.\end{equation}</script><p>其法线垂直于平面。</p><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><h5 id="点法式"><a href="#点法式" class="headerlink" title="点法式"></a>点法式</h5><p>​        如果我们已知一个点和一个法线：我们可以求出方程：</p><p>​        已知：$n(A,B,C)，M(x_0,y_0,z_0)$</p><script type="math/tex; mode=display">L:A(x-x_0)+B(y-y_0)+C(z-z_0)=0</script><p>一般式</p><p>​        拆开上面的式子，将常数化作一个指标D</p><script type="math/tex; mode=display">L:Ax+By+Cz+D=0</script><p><img src="image-20230202150419737.png" alt="image-20230202150419737"></p><h3 id="平面的夹角"><a href="#平面的夹角" class="headerlink" title="平面的夹角"></a>平面的夹角</h3><p>我们回忆高中两直线的夹角：</p><script type="math/tex; mode=display">\cos \theta=|\cos(\vec{n_1},\vec{n_2})|</script><p>平面是一样的：</p><script type="math/tex; mode=display">\cos \theta=|\cos(\vec{n_1},\vec{n_2})|</script><p>只不过：</p><script type="math/tex; mode=display">\cos \theta=\frac{A_1A_2+B_1B_2+C_1C_2}{\sqrt{(A_1^2+B_1^2+C_1^2)(A_2^2+B_2^2+C_2^2)}}</script><p>推广了一个维度！</p><h3 id="空间直线与方程"><a href="#空间直线与方程" class="headerlink" title="空间直线与方程"></a>空间直线与方程</h3><p>回到这个概念：</p><p>曲线可以视作两个曲面的交：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}F(x,y,z) & = 0 \\G(x,y,z) & =  0\end{aligned}\right.\end{equation}</script><p>直线就是：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}A_1x+B_1y+C_1z+D_1 & = 0 \\A_2x+B_2y+C_2z+D_2 & =  0\end{aligned}\right.\end{equation}</script><h4 id="对称式"><a href="#对称式" class="headerlink" title="对称式"></a>对称式</h4><p>​        如果已知：$M(x_0,y_0,z_0),S(m,n,p)$则：</p><script type="math/tex; mode=display">\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}</script><h4 id="参数式"><a href="#参数式" class="headerlink" title="参数式"></a>参数式</h4><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = mt+x_0 \\y & =  nt+y_0\\y & =  pt+z_0\end{aligned}\right.\end{equation}</script><p>​        就是在对称式的基础上加上了等于T的条件！</p><h4 id="平面与直线的夹角"><a href="#平面与直线的夹角" class="headerlink" title="平面与直线的夹角"></a>平面与直线的夹角</h4><p>​        类似的，我们可以得到：</p><script type="math/tex; mode=display">\sin\varphi=|\cos(\vec{s},\vec{n})|=\frac{|Am+Bn+Cp|}{\sqrt{(A^2+B^2+C^2)(m^2+n^2+p^2)}}</script><p>​        于是：</p><script type="math/tex; mode=display">垂直: \frac{A}{m}=\frac{B}{n}=\frac{C}{p}</script><script type="math/tex; mode=display">平行:Am+Bn+Cp=0</script><h3 id="曲面-1"><a href="#曲面-1" class="headerlink" title="曲面"></a>曲面</h3><h4 id="旋转曲面"><a href="#旋转曲面" class="headerlink" title="旋转曲面"></a>旋转曲面</h4><p>​        由曲线旋转产生</p><p>​        假设我们原先的曲线的方程是：$f(y,z)=0$，他显然位于$yOz$平面上，其上有一点:$M_1(0,y_1,z_1)$</p><p>​        旋转之后：$M(x,y,z)$一定有：</p><script type="math/tex; mode=display">z=z_1且y_1=\pm\sqrt{x^2+y^2}</script><p>​        于是：</p><script type="math/tex; mode=display">f(\pm\sqrt{x^2+y^2},z)=0</script><p>​        相同的办法推理：对于$f(y,z)=0$绕Y轴旋转：</p><script type="math/tex; mode=display">f(y,\pm\sqrt{x^2+z^2})=0</script><p><img src="image-20230202152227760.png" alt="image-20230202152227760"></p><p>绕谁转，谁不变：剩下两个在旁边。</p><h4 id="曲面类型"><a href="#曲面类型" class="headerlink" title="曲面类型"></a>曲面类型</h4><h5 id="柱面："><a href="#柱面：" class="headerlink" title="柱面："></a>柱面：</h5><p>​        把一个平面作为准线，沿一条线（母线）移动：</p><script type="math/tex; mode=display">x^2+y^2=R^2</script><p>​        是一个代表</p><p><img src="image-20230202152508816.png" alt="image-20230202152508816"></p><p>​        如果是抛物线：就产生抛物面：</p><p><img src="image-20230202152605842.png" alt="image-20230202152605842"></p><p>​        缺什么以什么为准线移动！</p><h5 id="二次曲面"><a href="#二次曲面" class="headerlink" title="二次曲面"></a>二次曲面</h5><p>1）椭圆锥面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}=z^2</script><p>​        只要令$z=t$，我们马上发现这就是个椭圆</p><p><img src="image-20230202152818674.png" alt="image-20230202152818674"></p><p>​        这里引入伸缩的概念：我们对变量可以伸缩：拉长或缩短，直接是令$y’=\lambda y$带入方程来看</p><p>2）椭球面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1</script><p>3)单叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1</script><p>本质上是$\frac{x^2}{a^2}-\frac{z^2}{c^2}=1$先绕Y轴旋转，随后伸缩$\frac{b}{a}$倍数</p><p>4）双叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=-1</script><p>5）椭圆抛物面：</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}=z</script><p>​        可以看作一个$P^2=C$的类抛物线看待</p><p>6）双曲抛物面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}-\frac{y^2}{b^2}=z</script>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（4）</title>
      <link href="/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%884%EF%BC%89/"/>
      <url>/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    定积分是从求解曲边梯形的面积产生的：就是说求解类似于如下的图像的面积</p><p><img src="image-20230124151114672.png" alt="image-20230124151114672"></p><p>​        怎么搞？我们试想一下，使用如下的方式：通过把面积切成很小的小块：</p><p>由于这些面积可以近似成矩形甚至是梯形，我们可以用面积和近似代替曲边梯形的面积。</p><p><img src="image-20230124151244623.png" alt="image-20230124151244623"></p><p>数学上是这么</p><script type="math/tex; mode=display">假设分点:a=x_0<x_1<x_2...<x_{n-1}<x_n=b</script><p>产生了</p><script type="math/tex; mode=display">\Delta x_1,\Delta x_2,...,\Delta x_n,随后令\lambda=max\{\Delta x_1,\Delta x_2,...,\Delta x_n\}</script><p>​        只要切的够小，我们就可以:$S\approx \sum_{k=1}^n \Delta x_kf(\sigma_k)$</p><p>​        其中$\sigma_k$是小区间上的一个任意点。怎么逼近真实值呢？让点取的密集一些：就是令$\lambda \rightarrow 0$就好了：产生的极限就是面积。</p><p>​        我们可以引入定积分了：</p><p>​        定义：$f(x)$在[a,b]有界，在[a,b]上任意插入若干个分点（随便插入），产生N个小区间，其长度为:$x_k(0&lt;k\leq n)$,又在区间上任意取一点$\sigma_i$，现在取出这些区间内最大长度的长度值记成$\lambda$,也就是$\lambda=max\{\Delta x_1,\Delta x_2,…\Delta x_n\}$。这下有了假设和的极限：$\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)$ 假设他存在：就引入这样的记号：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        其中a,b叫积分下限和积分上限，被积函数是f(x),积分区间是[a,b],积分变量是x</p><p>​        注意，这个值（或者说这个定积分）与积分变量无关，也就是说：</p><script type="math/tex; mode=display">\int_a^b f(t)dt=\int_a^b f(x)dx</script><p>​        定理1：函数只要连续就一定可积。</p><p>​        定理2：函数<strong>有界</strong>且<strong>有有限个间断点</strong>也可积。</p><h3 id="定积分的几何意义"><a href="#定积分的几何意义" class="headerlink" title="定积分的几何意义"></a>定积分的几何意义</h3><p>​        1.$f(x)\geq0$</p><p>​        <img src="image-20230124153747909.png" alt="image-20230124153747909"></p><p>​        就是阴影部分面积</p><p>​        2.$f(x)\leq0$</p><p><img src="image-20230124153828323.png" alt="image-20230124153828323"></p><p>​        注意是阴影部分面积的相反数，这是因为：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        中：$f(\sigma_k)&lt;0$</p><h6 id="矩阵法"><a href="#矩阵法" class="headerlink" title="矩阵法"></a>矩阵法</h6><p>​        我们使用切分成矩阵的方式来计算定积分</p><p><img src="image-20230124154130711.png" alt="image-20230124154130711"></p><h6 id="梯形法"><a href="#梯形法" class="headerlink" title="梯形法"></a>梯形法</h6><p><img src="image-20230124154214737.png" alt="image-20230124154214737"></p><p>看看就好，不用他来计算</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1）a=b下：$\int_a^b f(x)dx=0$</p><p>2)$\int_a^b f(x)dx=-\int_b^a f(x)dx$</p><p>3)$\int_a^b (\alpha f(x)+\beta g(x))dx=\alpha \int_a^b f(x)dx+\beta\int_a^b g(x)dx$</p><p>4)$\int_a^b f(x)dx=\int_a^c f(x)dx+\int_c^b f(x)dx$(切成两块加)</p><p>5)$f(x)\equiv 1,\int_a^b 1dx=b-a,\int_a^b kdx=k(b-a)$</p><p>6)$f(x)\geq 0,\int_a^b f(x)dx\geq0$</p><p>7)$f(x)\leq 0,\int_a^b f(x)dx\leq0$</p><p>8)$f(x)\leq g(x),\int_a^b f(x)dx\leq\int_a^b g(x)dx$</p><p>来点推论：</p><p>1.</p><script type="math/tex; mode=display">|\int_a^b f(x)dx|\leq\int_a^b |f(x)|dx</script><p>2.函数的极大值和极小值为$M,m$</p><script type="math/tex; mode=display">m(b-a)\leq\int_a^b f(x)dx\leq M(b-a)</script><p>9)定积分中值定理：$f(x)$连续,$\exists \xi\in[a,b]$</p><script type="math/tex; mode=display">\int_a^b f(x)dx=f(\xi)(b-a)</script><p>这个定理可以用来化简带有积分的极限</p><p><img src="image-20230124155256516.png" alt="image-20230124155256516"></p><h3 id="微积分的基本公式"><a href="#微积分的基本公式" class="headerlink" title="微积分的基本公式"></a>微积分的基本公式</h3><h4 id="积分上限函数"><a href="#积分上限函数" class="headerlink" title="积分上限函数"></a>积分上限函数</h4><p>我们把一个限变成一个变量，有点像把一边可以自由滑动，这样就有一个变限积分函数，我们把目光集中在x上：</p><script type="math/tex; mode=display">\int_a^x f(t)dt</script><p>这样定积分就从一个值变成一个函数</p><script type="math/tex; mode=display">\phi(x)=\int_a^x f(t)dt</script><p>定理1：</p><script type="math/tex; mode=display">\phi'(x)=\frac{d}{dx}\int_a^x f(t)dt=f(x)</script><p>这样来看，$\phi(x)$就是$f(x)$的一个原函数。值得一提的是：</p><script type="math/tex; mode=display">(\int_x^a f(t)dt)'=-f(x)</script><script type="math/tex; mode=display">(\int_a^{\varphi(x)} f(t)dt)'=f(\varphi(x))\varphi'(x)</script><script type="math/tex; mode=display">[\int_{\varphi(x)}^{\phi(x)}f(t)dt]'=f(\phi(x))\varphi'(x)-f(\varphi(x))\phi'(x)</script><p>上面那个可能太抽象，可以使用性质2）插入一个常数点a</p><h4 id="牛顿莱布尼兹公式"><a href="#牛顿莱布尼兹公式" class="headerlink" title="牛顿莱布尼兹公式"></a>牛顿莱布尼兹公式</h4><script type="math/tex; mode=display">\int_a^bf(x)dx=F(x)|_a^b=F(b)-F(a)</script><p>​        其中$F(x)$是$f(x)$的原函数。</p><p>例如：$\int_0^1 x^2dx$</p><p>解：=$\frac{1}{3}x^3|_0^1=\frac{1}{3}$</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><h4 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h4><p>​        定理：我们令$x=\varphi(t)$使之$\varphi(\alpha)=a,\varphi(\beta)=b$</p><script type="math/tex; mode=display">\int_a^bf(x)dx=\int_\alpha^\beta(\varphi(t))\varphi'(t)dt</script><p>例题：</p><p>1）$\int_0^a\sqrt{a^2-x^2}dx$</p><p>解：$令x=a\sin t$,$dx=a\cos tdt$</p><p>$=\int_0^{\frac{\pi}{2}}a^2\cos^2tdt=\frac{\pi}{4}a^2$</p><p>一些技巧：</p><p>1）$[-a,a]$下：$f(x)$偶：$\int_{-a}^{a}f(x)dx=2\int_{0}^{a}f(x)dx$,$f(x)$奇则为0。</p><p>2）$\int_{0}^{\frac{\pi}{2}}f(\sin x)dx=\int_{0}^{\frac{\pi}{2}}f(\cos x)dx$</p><p>3)$\int_{0}^{\pi}xf(\sin x)dx=\frac{\pi}{2}\int_0^{\pi}f(\sin x)dx$</p><p>（2）（3）怎么说？</p><p>2）令：$x=\frac{\pi}{2}-t,dx=-dt$就可以了</p><p>3）令：$x=\pi-t,dx=-dt$带入之后化简一下得到：</p><script type="math/tex; mode=display">\int_{0}^{\pi}xf(\sin x)dx=\int_{0}^{\pi}(\pi-t)f(\sin t)dt=\pi\int_{0}^{\pi}f(\sin x)dx-\int_{0}^{\pi}xf(\sin x)dx</script><p>(上面中因为与积分变量无关由此可以直接替换)</p><p>例题：$\int_0^{\pi}\frac{x\sin x}{1+\cos^2x}dx=\frac{\pi}{2}\int_0^{\pi}\frac{\sin x}{1+\cos^2x}dx=-\frac{\pi}{2}\arctan(\cos x)|_0^\pi=\frac{\pi^2}{4}$</p><p>4)$\int_a^{a+T}f(x)dx=\int_0^Tf(x)dx$(f(x)是一个周期函数，周期是T)</p><p>5）$\int_a^{a+nT}f(x)dx=n\int_0^af(x)dx$</p><h4 id="分部积分"><a href="#分部积分" class="headerlink" title="分部积分"></a>分部积分</h4><p>​        首先回顾$\int udv=uv-\int vdu$这个公式，于是，在定积分的也自然就是：</p><script type="math/tex; mode=display">\int_a^b udv=uv|_a^b - \int_a^b vdu</script><p>​        例如：$\int _0^\frac{1}{2} \arcsin xdx$</p><p>​        注意到$x$也是一个函数：于是$\int _0^\frac{1}{2} \arcsin xdx=x\arcsin x|_0^\frac{1}{2} - \int_0^\frac{1}{2} \frac{x}{\sqrt {1-x^2} }dx=\frac{\pi}{12}+\frac{\sqrt 3}{2}-1$</p><p>​        也有上面提到的方法一块用的积分：</p><p>​        $\int_0^1 e^\sqrt{x}dx$</p><p>​        令:$t=\sqrt x$, 则:$2\int_0^1 te^tdt$=$2te^t|_0^1-2\int_0^1 e^tdt=2$</p><h3 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h3><h4 id="无穷限的反常积分"><a href="#无穷限的反常积分" class="headerlink" title="无穷限的反常积分"></a>无穷限的反常积分</h4><p>​        什么叫反常积分呢？就是说积分区域下函数在这一点反常。比如说，因为积分区域含有无穷的积分：</p><script type="math/tex; mode=display">\int_a^{+\infty} f(x)dx</script><p>​        或者是这样的：</p><script type="math/tex; mode=display">\int_{-\infty}^b  f(x)dx</script><p>​        这样的积分是无穷限的反常积分。我们不妨采用动态的方法：</p><script type="math/tex; mode=display">\int_a^{+\infty} f(x)dx=\lim_\limits{t\rightarrow +\infty}\int_a^t f(x)dx</script><p>​        这下也有类似的：</p><script type="math/tex; mode=display">\int_{-\infty}^b  f(x)dx=\lim_\limits{t\rightarrow -\infty}\int_t^b f(x)dx</script><p>​        牵扯到了极限，因此：如果上面的极限是存在的，那就：之人格积分是收敛的，反之发散。</p><p>​        还有上下限均是无穷的积分，仍采用上面的处理方式。在实际求值的时候，也是直接</p><script type="math/tex; mode=display">\int_a^{+\infty}f(x)dx=F(x)|_a^{+\infty}</script><p>​        一个结论：对于</p><script type="math/tex; mode=display">\int_a^{+\infty}\frac{dx}{x^p}(a>0)</script><p>​        <strong>p&gt;1收敛，p$\leq 1$手来你</strong></p><h4 id="反常积分：无界函数的反常积分"><a href="#反常积分：无界函数的反常积分" class="headerlink" title="反常积分：无界函数的反常积分"></a>反常积分：无界函数的反常积分</h4><p>​        什么意思？就是说函数在某一点没有定义，我们的积分区域却包含了它。比如说</p><script type="math/tex; mode=display">\int_0^1 \frac{1}{x}dx</script><p>​        结合上一小节的类似方法，我们得到</p><script type="math/tex; mode=display">\int_0^1 \frac{1}{x}dx=\lim\limits_{t\rightarrow 0^+}\int_t^1\frac{1}{t}dx</script><p>​        类似的： </p><script type="math/tex; mode=display">\int_{-1}^0 \frac{1}{x}dx=\lim\limits_{t\rightarrow 0^-}\int_{-1}^t\frac{1}{t}dx</script><p>​        如果这样的点在中间，我们就拆开积分区域就好了。</p><h4 id="补充：-Gamma-s-函数"><a href="#补充：-Gamma-s-函数" class="headerlink" title="补充：$\Gamma(s)$函数"></a>补充：$\Gamma(s)$函数</h4><p>​        $\Gamma(s)$函数是这样定义的：</p><script type="math/tex; mode=display">\Gamma(s)=\int_0^{+\infty}e^{-x}x^{s-1}dx(s>0)</script><p>​        具有以下非常好推导的性质：</p><script type="math/tex; mode=display">1)\Gamma(s+1)=s\Gamma(s)</script><script type="math/tex; mode=display">2)\Gamma(1)=1</script><p>基于2)，我们发现了这个函数的一个奇妙公式：</p><script type="math/tex; mode=display">\Gamma(s+1)=s!</script><h4 id="补充：比较审敛原理"><a href="#补充：比较审敛原理" class="headerlink" title="补充：比较审敛原理"></a>补充：比较审敛原理</h4><p>​        我们假设:$f(x)$和$g(x)$在[a,$\infty$ ]上连续，$60 \leq f(x)\leq g(x)$如果：</p><script type="math/tex; mode=display">1)\int_a^{+\infty}g(x)dx收敛\rightarrow\int_a^{+\infty}f(x)dx收敛</script><script type="math/tex; mode=display">1)\int_a^{+\infty}f(x)dx发散\rightarrow\int_a^{+\infty}g(x)dx发散</script><p>​        很好理解：大哥收敛小弟也收敛，小弟嚣张大哥肯定也嚣张。</p><h4 id="补充：比较审敛法"><a href="#补充：比较审敛法" class="headerlink" title="补充：比较审敛法"></a>补充：比较审敛法</h4><p>​    设$f(x)$在[a,$\infty$]连续(a&gt;0)，且$f(x)\geq 0,\exists M&gt;0,p&gt;1$</p><p>​        如果使得:$f(x)\leq \frac{M}{x^p}$那就$\int_a^{+\infty}f(x)dx$收敛</p><p>​        反之：$f(x)\geq \frac{M}{x},$那就$\int_a^{+\infty}f(x)dx$发散</p><h4 id="补充：绝对审敛法"><a href="#补充：绝对审敛法" class="headerlink" title="补充：绝对审敛法"></a>补充：绝对审敛法</h4><p>​        如果$f(x)$在设$f(x)$在[a,$\infty$]连续（a&gt;0), $\int_a^{+\infty}|f(x)|dx$收敛，那么$\int_a^{+\infty}f(x)dx$收敛。</p><p>​        最后不难得到这个定理</p><h4 id="补充：无界函数反常积分的审敛法"><a href="#补充：无界函数反常积分的审敛法" class="headerlink" title="补充：无界函数反常积分的审敛法"></a>补充：无界函数反常积分的审敛法</h4><p>​        回到这个积分</p><script type="math/tex; mode=display">\int_a^b \frac{dx}{(x-a)^q}</script><p>​        $x=a$显然是一个瑕点$q&lt;1$收敛，q$\geq$1发散。</p><p>​        基于这个积分，我们再次应用比较原理：</p><p>​        如果$f(x)$在(a,b]连续,f(x)$\geq$0,如果$\exists M&gt;0$及其$q&lt;1$使得</p><script type="math/tex; mode=display">1)f(x)\leq \frac{M}{(x-a)^q}收敛</script><script type="math/tex; mode=display">2)f(x)\geq \frac{M}{x-a}发散</script><h4 id="补充：极限审敛法"><a href="#补充：极限审敛法" class="headerlink" title="补充：极限审敛法"></a>补充：极限审敛法</h4><p>​        如果$f(x)$在(a,b]连续,f(x)$\geq$0，$x=a$为$f(x)$的瑕点</p><p>​        1）$\exists 0&lt;q&lt;1$使得$\lim\limits_{x\rightarrow a^+}(x-a)^qf(x)=A$直接说明一件事：$\int_a^b f(x)dx$收敛。</p><p>​        2）类比的$\lim\limits_{x\rightarrow a^+}(x-a)f(x)=A$或者是$\infty$，我们直接认为$\int_a^b f(x)dx$发散。</p><h3 id="定积分的元素法"><a href="#定积分的元素法" class="headerlink" title="定积分的元素法"></a>定积分的元素法</h3><p>​        回到定积分的这个定义式：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        <strong>本质上，这样的一个定积分就是描述瞬时元素在某一个维度的积累效应的量化程度</strong>，这就是说：它既可以用来描述面积，又可以描述体积，只需要我们掌握了相应的边界函数，只要对应积分即可。</p><p><img src="image-20230130163127477.png" alt="image-20230130163127477"></p><p>​        比如说，这个的体积就是面积函数A(x)对于高度x的积分</p><script type="math/tex; mode=display">V=\int_{x_1}^{x_2}A(x)dx</script><h3 id="补充一下极坐标"><a href="#补充一下极坐标" class="headerlink" title="补充一下极坐标"></a>补充一下极坐标</h3><p>​        我们重新用一种全新的角度来看待坐标系：我们改用距离原点的距离+偏离X轴正方向的描述方法描述点的坐标。</p><p><img src="image-20230130163636247.png" alt="image-20230130163636247"></p><p>这样，一个点就总是可以表示为$A=(\rho, \theta)$，比如说极坐标下(1,1)变成了$(\sqrt 2,\frac{\pi}{4})$,现在，我们试着求：</p><p><img src="image-20230130174155076.png" alt="image-20230130174155076"></p><p>这个阴影面积：怎么办？延续老方法：假设点沿着曲线挪动一丁点，那么我们的产生的微小的面积则是：</p><script type="math/tex; mode=display">dS=\frac{\rho^2d\theta}{2}</script><p>然后从哪到哪？$\alpha$到$\beta$。</p><script type="math/tex; mode=display">S=\int_\alpha^\beta \frac{\rho^2d\theta}{2}</script><p>结束。</p><h3 id="平面图形的面积"><a href="#平面图形的面积" class="headerlink" title="平面图形的面积"></a>平面图形的面积</h3><h4 id="直角坐标系"><a href="#直角坐标系" class="headerlink" title="直角坐标系"></a>直角坐标系</h4><p>​        我们说函数相交也可以产生一些面积</p><p><img src="image-20230130174758444.png" alt="image-20230130174758444"></p><p>​        这个怎么求呢？</p><p><img src="image-20230130174916021.png" alt="image-20230130174916021"></p><p>​        我们的差面积就是：</p><script type="math/tex; mode=display">S=\int_a^bf(x)dx-\int_a^b g(x)dx=\int_a^bf(x)-g(x)dx</script><p>​        这样的差是X型的面积积分，因为我们拿X作为梯形的高</p><p>​        那就还有Y型面积：</p><p><img src="image-20230130175121419.png" alt="image-20230130175121419"></p><p>​        类比的：</p><script type="math/tex; mode=display">S=\int_c^d \varphi(y)-\phi(y)dy</script><p>​        也即是：</p><p>​            X:$S=\int 上-下dx$</p><p>​            Y:$S=\int 右-左dy$</p><p>​        </p><p>​        总结一下：我们对面积先大致画出来图长什么样：如果是这样的</p><p>​        <img src="image-20230130175729566.png" alt="image-20230130175729566"></p><p>​        就这样使用X，Y对应当打，如果不好判断，就都先试试，哪个更加容易用哪个。</p><p>​        举例：求$y=\frac{1}{2}x^2$,$y=\frac{1}{1+x^2}$在$x \in [-\sqrt 3,\sqrt 3]$下的定积分。</p><p>​        我们可以做出图像：</p><p><img src="image-20230202133001296.png" alt="image-20230202133001296"></p><p>​        砍开来看：</p><script type="math/tex; mode=display">S=\int_{-\sqrt{3}}^{-1}(\frac{1}{2}x^2-\frac{1}{1+x^2})+\int_{-1}^1(\frac{1}{1+x^2}-\frac{1}{2}x^2)+\int_{1}^{\sqrt{3}}(\frac{1}{2}x^2-\frac{1}{1+x^2})</script><p>​        随后使用偶函数的对称性结束计算。</p><p>​        求椭圆的面积：$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$</p><p>​        可以拆开四分之一的部分$S_1=\int_0^aydx$</p><p>​        现在，我们引入椭圆参数方程来消去参数：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=a\cos t \\y=a\sin t \end{aligned} \right . \end{equation}</script><p>来看看变成什么了：</p><script type="math/tex; mode=display">S_1=-\int_0^{\frac{\pi}{2}}a\sin t \times a(-\sin t)dt=\frac{\pi ab}{4}</script><p>这就是为什么：</p><script type="math/tex; mode=display">S=\pi ab</script><h4 id="极坐标下"><a href="#极坐标下" class="headerlink" title="极坐标下"></a>极坐标下</h4><p>​        回忆前面所叙述的：对于方程$R=\rho (\theta)$</p><script type="math/tex; mode=display">S=\frac{1}{2}\int_{\alpha}^{\beta}(\rho (\theta))^2d\theta</script><p>​        比如说：$\rho=a\theta$</p><script type="math/tex; mode=display">S=\frac{1}{2}\int_0^{2\pi}(a\theta)^2d\theta=\frac{4}{3}a^2\pi^3</script><h3 id="旋转体体积求法"><a href="#旋转体体积求法" class="headerlink" title="旋转体体积求法"></a>旋转体体积求法</h3><p>说白了可以切成以$f(x)$为半径的圆，在叠起来（求积分）</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2}\pi f^2(x)dx</script><p> 是通过</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2} A(x)dx</script><p>​        派生来的，只是因为面积恰好是圆。</p><p>​        但是，这样的体积求解的是绕X轴的。绕Y轴的怎么办哪？</p><p>​        简单：那就改写方程为$x=x(y)$就好了：</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2}x^2(y)dy</script><h3 id="弧长的求解"><a href="#弧长的求解" class="headerlink" title="弧长的求解"></a>弧长的求解</h3><h4 id="通用："><a href="#通用：" class="headerlink" title="通用："></a>通用：</h4><p>回来看看这个参数方程：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=\varphi(t) \\y=\phi(t)\end{aligned} \right . \end{equation}</script><p>​        弧微分很容易说：</p><script type="math/tex; mode=display">ds=\sqrt{(dx)^2+(dy)^2}dt=\sqrt{(\varphi'(t))^2+(\phi'(t))^2}dt</script><p>​        于是：</p><script type="math/tex; mode=display">L=\int_\alpha^\beta \sqrt{(\varphi'(t))^2+(\phi'(t))^2}dt</script><p>​        作为积分结果，就是弧长。</p><p>​        以此为源头，开始推广其他的公式：</p><h4 id="直角坐标系下"><a href="#直角坐标系下" class="headerlink" title="直角坐标系下"></a>直角坐标系下</h4><p>​        假如参数方程很容易被表达为$y=y(x)$，那我们就：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=x \\ y=y(x)\\\end{aligned} \right . \end{equation}</script><p>​        那带入：</p><script type="math/tex; mode=display">ds=\sqrt{1+y'^2(x)}dx</script><p>​        再积分：</p><script type="math/tex; mode=display">L=\int_a^b\sqrt{1+y'^2(x)}dx</script><h4 id="极坐标系下"><a href="#极坐标系下" class="headerlink" title="极坐标系下"></a>极坐标系下</h4><p>​        如果不知道的话：科普一下</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=\rho(\theta)\cos \theta \\ y=\rho(\theta)\sin \theta\\\end{aligned} \right . \end{equation}</script><p>​        所有呢，求个导：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x'=\rho'(\theta)\cos \theta- \rho(\theta)\sin \theta\\ y'=\rho(\theta)\cos \theta+\rho'(\theta)\sin \theta\\\end{aligned} \right . \end{equation}</script><p>​        老样子：</p><script type="math/tex; mode=display">ds=\sqrt{(x'^2+y'^2)} d\theta=\sqrt{\rho^2(\theta)+\rho'^2(\theta)d\theta}</script><p>​         嘛，不就完事了！</p><script type="math/tex; mode=display">L=\int_\alpha^\beta\sqrt{\rho^2(\theta)+\rho'^2(\theta)d\theta}</script>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Pycharm（2）</title>
      <link href="/2023/01/31/Opencv-in-Pycharm%EF%BC%882%EF%BC%89/"/>
      <url>/2023/01/31/Opencv-in-Pycharm%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><h3 id="平滑操作"><a href="#平滑操作" class="headerlink" title="平滑操作"></a>平滑操作</h3><p>​        平滑平滑，取平均。我们使用卷积核来处理图像像素点。</p><p><img src="lenaNoise.png" alt="lenaNoise"></p><p>​        针对上面这个噪点图形，我们应用平均卷积操作。我们对噪点抹除，就是通过对周围像素点取平均。我们首先构造一个3$\times$3的矩阵对目标像素点为中心的内核求取内积。（不同于经典矩阵相乘，我们是一一对应的，平凡算法复杂度为$O(N^k)(k \in N^+)$的相乘）随后把结果填充到像素点的中心。</p><p>​        下面我们对这个图操作一下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_path <span class="token operator">=</span> <span class="token string">"img/lenaNoise.png"</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Noise Version"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>blur33<span class="token operator">=</span>cv2<span class="token punctuation">.</span>blur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"3 times 3"</span><span class="token punctuation">,</span>blur33<span class="token punctuation">)</span>blur55<span class="token operator">=</span>cv2<span class="token punctuation">.</span>blur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"3 times 3"</span><span class="token punctuation">,</span>blur55<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        产生的效果是令人满意的：</p><p>3$\times$3：</p><p><img src="3 times 3.png" alt="3 times 3"></p><p>5$\times$5：</p><p><img src="5 times 5.png" alt="5 times 5"></p><p>​        可以看到核越大，越是噪点不明显，但是图像也就越模糊。</p><p>​        还有一个类似的：是BoxFilter函数：（方框滤波）</p><p>​        在OpenCV中，实现方框滤波的函数是cv2.boxFilter（），其语法格式为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">   dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>boxFilter（src<span class="token punctuation">,</span>ddepth<span class="token punctuation">,</span>ksize<span class="token punctuation">,</span>anchor<span class="token punctuation">,</span>normalize<span class="token punctuation">,</span>borderType）   <span class="token comment"># 但是一般的。。。。。。</span>dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>boxFilter（src<span class="token punctuation">,</span>ddepth<span class="token punctuation">,</span>ksize）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>● dst是返回值，表示进行方框滤波后得到的处理结果。● src 是需要处理的图像，即原始图像。它能够有任意数量的通道，并能对各个通道独立处理。图像深度应该是CV_8U、CV_16U、CV_16S、CV_32F 或者 CV_64F中的一种。 ● ddepth是处理结果图像的图像深度，一般使用-1表示与原始图像使用相同的图像深度。 ● ksize 是滤波核的大小。滤波核大小是指在滤波处理过程中所选择的邻域图像的高 度和宽度。● anchor 是锚点，其默认值是（-1,-1），表示当前计算均值的点位于核的中心点位 置。该值使用默认值即可，在特殊情况下可以指定不同的点作为锚点。● normalize 表示在滤波时是否进行归一化（这里指将计算结果规范化为当前像素值范围内的值）处理，该参数是一个逻辑值，可能为真（值为1）或假（值为0）：1.当参数normalize=1时，表示要进行归一化处理，要用邻域像素值的和除以面积。此时方框滤波与均值滤波效果相同。2.当参数normalize=0时，表示不需要进行归一化处理，直接使用邻域像素值的和。当 normalize=0时，因为不进行归一化处理，因此滤波得到的值很可能超过当前像素值范围的最大值，从而被截断为最大值。这样，就会得到一幅纯白色的图像。● borderType是边界样式，该值决定了以何种方式处理边界。通常情况下，在使用方框滤波函数时，对于参数anchor、normalize和borderType，直接采用其默认值即可。因此，函数cv2.boxFilter（）的常用形式为：</code></pre><p>​        可以等效成blur，就是选择更多了而已。如果不进行归一化，就是停在255，所以图像会很白。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Filt1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>boxFilter<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>normalize<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>Filt2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>boxFilter<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>normalize<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Filt1"</span><span class="token punctuation">,</span>Filt1<span class="token punctuation">)</span><span class="token punctuation">;</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Filt2"</span><span class="token punctuation">,</span>Filt2<span class="token punctuation">)</span><span class="token punctuation">;</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Filt1.png"</span><span class="token punctuation">,</span>Filt1<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Filt2.png"</span><span class="token punctuation">,</span>Filt2<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Filt1： 归一化</p><p><img src="Filt1.png" alt="Filt1"></p><p>Filt2: 摆烂</p><p><img src="Filt2.png" alt="Filt2"></p><h4 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h4><p>​        这个改进了平均算法，就是利用空间距离远近来作为计算权重：近的权重大，反之权重小。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Gaussain<span class="token operator">=</span>cv2<span class="token punctuation">.</span>GaussianBlur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Gaussain"</span><span class="token punctuation">,</span>Gaussain<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Gaussain.png"</span><span class="token punctuation">,</span>Gaussain<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="Gaussain.png" alt="Gaussain"></p><h5 id="关于高斯滤波及其算法的扩展"><a href="#关于高斯滤波及其算法的扩展" class="headerlink" title="关于高斯滤波及其算法的扩展"></a>关于高斯滤波及其算法的扩展</h5><p>材料来源：<a href="https://blog.csdn.net/LYSSLQ2015/article/details/125110610">(46条消息) opencv———-高斯滤波_opencv高斯滤波_LYSSLQ2015的博客-CSDN博客</a>！</p><p>​        高斯滤波(Gauss Filter)是<strong>线性滤波</strong>中的一种。在OpenCV图像滤波处理中，高斯滤波用于<strong>平滑图像</strong>，或者说是图像模糊处理，因此高斯滤波是低通的。其广泛的应用在图像处理的减噪过程中，尤其是被高斯噪声所污染的图像上。高斯滤波的基本思想是: 图像上的每一个像素点的值，都由其本身和邻域内其他像素点的值经过加权平均后得到。其具体操作是，用一个核(又称为卷积核、掩模、矩阵)扫描图像中每一个像素点，将邻域内各个像素值与对应位置的权值相称并求和。从数学的角度来看，高斯滤波的过程是图像与高斯正态分布做卷积操作。<br>​        注意: 高斯滤波是将二维高斯正态分布放在图像矩阵上做卷积运算。考虑的是邻域内像素值的空间距离关系，因此对彩色图像处理时应分通道进行操作，也就是说操作的图像原矩阵时用单通道数据，最后合并为彩色图像。</p><p>一、几个概念</p><ol><li><p>什么是<a href="https://so.csdn.net/so/search?q=低通滤波&amp;spm=1001.2101.3001.7020">低通滤波</a>、平滑图像、图像模糊处理？<br>平滑图像与图像模糊处理是相同的含义。平滑处理即是通过操作后，使得图像的像素值与邻域内其他像素值的的变化程度减小。在一张图像上，边缘的像素值是变化程度最剧烈的地方，而其他相对平缓。因此，平滑图像最直观的表现是图像的上物体的边缘轮廓变得模糊。<strong>低通滤波是指仅允许低频率信号通过。一张图像上的大部分能量聚集在低频和中频上，而高频大多是图像中物体的边缘部分，也有可能是高频噪声点。在单通道中，各像素点的取值都在(0~255)中，因此，低通滤波通过一定的阙值设置，有去除高频信号和平缓边缘的效果。</strong></p></li><li><p>什么是核(又称为卷积核、掩模、矩阵)？<br><strong>核的本质其实就是一个大小固定、由数值参数组成的数学矩阵，例如一个3<em>3的核就是一个3</em>3的矩阵,而矩阵中的数据则为权值。</strong></p></li><li><p>什么是卷积运算？<br>卷积运算是指输入图像中某一像素点的邻域的各个值（包括该点）与卷积算子中的值做矩阵相乘运算，最后得到输出值。<br>卷积算子的公式:</p><script type="math/tex; mode=display">g=f*h</script><script type="math/tex; mode=display">g(i,j)=\sum_{k,l}f(i-k,j-l)h(k,l)=\sum_{k,l}f(k,l)h(i-k,j-l)</script></li></ol><p>g(i，j) 代表原图像矩阵上的(i，j)点的值，它是输出值。<br>f(i-k，j-l) 代表原图像矩阵上(i，j)点的邻域中的对应点的值。<br>h(k,，l) 代表与f(i-k ， j-l)这个值在核对应位置的点的值<br><strong>请看下图：这里用的是f(i-k,j-l)h(k,l)</strong></p><p><img src="SouthEast.png" alt="这里写图片描述"></p><p>由上图我们看到，矩阵f是将要进行操作的图像矩阵，当前的(i，j)是(2，2)点。h为核，其以中心(0，0)为参考点。因此f矩阵对应范围即为f(2，2)的邻域。矩阵g为图像输出矩阵，g(2，2)的值为输出值。<br>注意：卷积算子和相关算子在核上是180度翻转的矩阵，请不要搞混</p><p>4.核(卷积核、掩模、矩阵等)<br>在3的卷积运算中，用到的公式是：<br>g(i, j) = ∑ f(i-k, j-l)h(k, l) 。其中 k，l代表核上的坐标。而核的坐标明显与数组下标不一致。因此，我们需要做一个转换以满足用数组下标来访问该核的数据。<br>假设有3<em>3数组a，它与核的对应关系为<br>a(0, 0) ===&gt; h(-1, -1) a(0, 1) ===&gt; h(-1, 0) a(0, 2) ===&gt; h(-1, 1)<br>a(1, 0) ===&gt; h(0, -1) a(1, 1) ===&gt; h(0, 0) a(1, 2) ===&gt; h(0, 1)<br>a(2, 0) ===&gt; h(1, -1) a(2, 1) ===&gt; h(1, 0) a(2, 2) ===&gt; h(1, 1)<br>对于3</em>3数组，其下标是0开始的，假设该数组的参考点(ai, aj)为中心,则有<br>g(i, j) = ∑ f(i-(k-ai), j-(l-aj))h(k, l)<br>带入数组参考点(1, 1)，则有<br>g(i, j) = ∑ f(i-(k-1), j-(l-1))h(k, l)<br>此时，k，l可以从0开始取值<br><img src="SouthEast2.png" alt="这里写图片描述"></p><p> <strong>5.图像通道分离与合并(cv::Mat)</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; src 原图像，多通道&#x2F;&#x2F; [1] 彩色图片通道分离std::vector&lt;cv::Mat&gt; channels;cv::split(&amp;src, channels);&#x2F;&#x2F; [3] 滤波&#x2F;&#x2F; OpenCV中操作&#x2F;&#x2F; channels[0]  &#x3D;&#x3D;&gt;  B通道&#x2F;&#x2F; channels[1]  &#x3D;&#x3D;&gt;  G通道&#x2F;&#x2F; channels[2]  &#x3D;&#x3D;&gt;  R通道&#x2F;&#x2F; 省略对各个通道的处理&#x2F;&#x2F; [4] 合并返回cv::merge(channels, *dst);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二、高斯函数"><a href="#二、高斯函数" class="headerlink" title="二、高斯函数"></a>二、高斯函数</h4><p>高斯滤波，顾名思义，这是一个建立在高斯正态分布基础上的滤波器。首先我们来了解高斯函数。(图片来源于网络)<br>一维高斯函数：<br>可以看到，G(x)的跟<a href="https://so.csdn.net/so/search?q=sigma&amp;spm=1001.2101.3001.7020">sigma</a>的取值有极大的关系。sigma取值越大，图像越平缓，sigma取值越小，图像越尖锐。</p><p><img src="SouthEast10.png" alt="这里写图片描述"><br><img src="SouthEast3.png" alt="这里写图片描述"></p><p>二维高斯函数：<br>二维高斯是构建高斯滤波器的基础。可以看到，G(x,y)在x轴y轴上的分布是一个突起的帽子的形状。这里的sigma可以看作两个值，一个是x轴上的分量sigmaX，另一个是y轴上的分量sigmaY。对图像处理可以直接使用sigma并对图像的行列操作，也可以用sigmaX对图像的行操作，再用sigmaY对图像的列操作。它们是等价的。<br>当sigmaX和sigmaY取值越大，整个形状趋近于扁平；当sigmaX和sigmaY取值越小，整个形状越突起。<br><img src="SouthEast4.png" alt="这里写图片描述"></p><p>高斯滤波原理就是将上图的二维正态分布应用在二维的矩阵上，G(x,y)的值就是矩阵上的权值，将得到的权值进行<a href="https://so.csdn.net/so/search?q=归一化&amp;spm=1001.2101.3001.7020">归一化</a>，将权值的范围约束在[0,1]之间，并且所有的值的总和为1。<br>假设一个3*3的核，sigma取值1.5以及sigma取5.0，归一化后其权值分布分别是：</p><p><img src="SouthEast5.png" alt="这里写图片描述"></p><p>假设一个5*5的核，sigma取值1.5以及sigma取5.0，经归一化后其权值分布分别是：<br><img src="SouthEast6.png" alt="这里写图片描述"><br><img src="SouthEast7.png" alt="这里写图片描述"></p><p>可以看到，权值的分布是以中间高四周低来分布的。并且距离中心越远，其对中心点的影响就越小，权值也就越小。<br>因此可以总结：<br>（1）在核大小固定的情况下，sigma值越大，权值分布越平缓。因此，邻域各个点的值对输出值的影响越大，最终结果造成图像越模糊。<br>（2）在核大小固定的情况下，sigma值越小，权值分布越突起。因此，邻域各个点的值对输出值的影响越小，图像变化也越小。假如中心点权值为1，其他点权值为0，那么最终结果是图像没有任何变化。<br>（3）sigma固定时，核越大图像越模糊。<br>（4）sigma固定时，核越小图像变化越小。</p><p>三、高斯滤波器实现<br>首先看效果：<br>对于椒盐图作处理</p><p><img src="SouthEast8.png" alt="这里写图片描述"></p><p>对于高斯噪声图作处理<br><img src="SouthEast9.png" alt="这里写图片描述"></p><p>（1）main函数：读取图片 ==&gt; 高斯滤波 ==&gt; 结果显示</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// [1] src读入图片</span>    cv<span class="token double-colon punctuation">::</span>Mat src <span class="token operator">=</span> cv<span class="token double-colon punctuation">::</span><span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"Median_pic.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [2] dst目标图片</span>    cv<span class="token double-colon punctuation">::</span>Mat dst<span class="token punctuation">;</span>    <span class="token comment">// [3] 高斯滤波  sigma越大越平越模糊</span>    <span class="token function">myGaussianFilter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>src<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dst<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [4] 窗体显示</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"dst"</span><span class="token punctuation">,</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">destroyAllWindows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）彩色图像通道分离处理，每个通道都进行高斯滤波，最后合并</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void myGaussianFilter(cv::Mat *src, cv::Mat *dst, int n, double sigma)&#123;    &#x2F;&#x2F; [1] 初始化    *dst &#x3D; (*src).clone();    &#x2F;&#x2F; [2] 彩色图片通道分离    std::vector&lt;cv::Mat&gt; channels;    cv::split(*src, channels);    &#x2F;&#x2F; [3] 滤波    &#x2F;&#x2F; [3-1] 确定高斯正态矩阵    double **array &#x3D; getGaussianArray(n, sigma);    &#x2F;&#x2F; [3-2] 高斯滤波处理    for (int i &#x3D; 0; i &lt; 3; i++) &#123;        gaussian(&amp;channels[i], array, n);    &#125;    &#x2F;&#x2F; [4] 合并返回    cv::merge(channels, *dst);    return ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）生成高斯正态分布核(<a href="https://so.csdn.net/so/search?q=卷积核&amp;spm=1001.2101.3001.7020">卷积核</a>，掩模等)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;* 获取高斯分布数组               (核大小， sigma值) *&#x2F;double **getGaussianArray(int arr_size, double sigma)&#123;    int i, j;    &#x2F;&#x2F; [1] 初始化权值数组    double **array &#x3D; new double*[arr_size];    for (i &#x3D; 0; i &lt; arr_size; i++) &#123;        array[i] &#x3D; new double[arr_size];    &#125;    &#x2F;&#x2F; [2] 高斯分布计算    int center_i, center_j;    center_i &#x3D; center_j &#x3D; arr_size &#x2F; 2;    double pi &#x3D; 3.141592653589793;    double sum &#x3D; 0.0f;    &#x2F;&#x2F; [2-1] 高斯函数    for (i &#x3D; 0; i &lt; arr_size; i++ ) &#123;        for (j &#x3D; 0; j &lt; arr_size; j++) &#123;            array[i][j] &#x3D;                 &#x2F;&#x2F;后面进行归一化，这部分可以不用                &#x2F;&#x2F;0.5f *pi*(sigma*sigma) *                 exp( -(1.0f)* ( ((i-center_i)*(i-center_i)+(j-center_j)*(j-center_j))&#x2F; (2.0f*sigma*sigma) ));                                    sum +&#x3D; array[i][j];        &#125;    &#125;    &#x2F;&#x2F; [2-2] 归一化求权值    for (i &#x3D; 0; i &lt; arr_size; i++) &#123;        for (j &#x3D; 0; j &lt; arr_size; j++) &#123;            array[i][j] &#x2F;&#x3D; sum;            printf(&quot; [%.15f] &quot;, array[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return array;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）进行高斯滤波操作</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;* 高斯滤波 (待处理单通道图片, 高斯分布数组， 高斯数组大小(核大小) ) *&#x2F;void gaussian(cv::Mat *_src, double **_array, int _size)&#123;    cv::Mat temp &#x3D; (*_src).clone();    &#x2F;&#x2F; [1] 扫描    for (int i &#x3D; 0; i &lt; (*_src).rows; i++) &#123;        for (int j &#x3D; 0; j &lt; (*_src).cols; j++) &#123;            &#x2F;&#x2F; [2] 忽略边缘            if (i &gt; (_size &#x2F; 2) - 1 &amp;&amp; j &gt; (_size &#x2F; 2) - 1 &amp;&amp;                i &lt; (*_src).rows - (_size &#x2F; 2) &amp;&amp; j &lt; (*_src).cols - (_size &#x2F; 2)) &#123;                &#x2F;&#x2F; [3] 找到图像输入点f(i,j),以输入点为中心与核中心对齐                &#x2F;&#x2F;     核心为中心参考点 卷积算子&#x3D;&gt;高斯矩阵180度转向计算                &#x2F;&#x2F;     x y 代表卷积核的权值坐标   i j 代表图像输入点坐标                &#x2F;&#x2F;     卷积算子     (f*g)(i,j) &#x3D; f(i-k,j-l)g(k,l)          f代表图像输入 g代表核                &#x2F;&#x2F;     带入核参考点 (f*g)(i,j) &#x3D; f(i-(k-ai), j-(l-aj))g(k,l)   ai,aj 核参考点                &#x2F;&#x2F;     加权求和  注意：核的坐标以左上0,0起点                double sum &#x3D; 0.0;                for (int k &#x3D; 0; k &lt; _size; k++) &#123;                    for (int l &#x3D; 0; l &lt; _size; l++) &#123;                        sum +&#x3D; (*_src).ptr&lt;uchar&gt;(i-k+(_size&#x2F;2))[j-l+(_size&#x2F;2)] * _array[k][l];                    &#125;                &#125;                &#x2F;&#x2F; 放入中间结果,计算所得的值与没有计算的值不能混用                temp.ptr&lt;uchar&gt;(i)[j] &#x3D; sum;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 放入原图    （*_src） &#x3D; temp.clone();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>​        什么是中值？就是排序取中间的中位数。那就直接把目标像素点直接换成中位数跑路！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">median<span class="token operator">=</span>cv2<span class="token punctuation">.</span>medianBlur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"median"</span><span class="token punctuation">,</span>median<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"median.png"</span><span class="token punctuation">,</span>median<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <img src="median.png" alt="median"></p><p>​        可以看到效果很好。令人满意。</p><h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><pre><code>    一、概述    使用中值滤波器模糊图像。    该函数使用具有 ksize×ksize 孔径的中值滤波器对图像进行平滑处理。 多通道图像的每个通道都是独立处理的。    中值滤波器在内部使用 BORDER_REPLICATE 来处理边界像素，请参阅 BorderTypes。    下图描述了一个ksize=3×3的滑动窗口（或称滤波器模板、kernel），如黄色部分所示。用这个ksize=3×3的窗口作用于原始图像上的每一个像素，如下图的绿色部分所示，被这个窗口覆盖的9个像素点都参与计算，这样在该像素点上就会得到一个新的像素值，当窗口沿着图像逐个像素进行计算，就会得到一幅新的图像。</code></pre><p><img src="https://img-blog.csdnimg.cn/9f8842b4f8da4836a54e1b6a66ab13fa.png" alt="img"></p><pre><code>     上图中滤波器模板的不同就构成了滤波算法的差异，比如均值平滑算法中滑动窗口中各个像素点的系数均为1/(窗口高*窗口宽)，高斯平滑中系数和中心点的距离满足高斯分布。    中值平滑和均值平滑一样也用到了滑动窗口，但是它并不是计算滑动窗口中的某种加权和，而是使用原图像滑动窗口中所有像素值排序后的中值作为新图像的像素值。    从上图也可以看到，当滑动窗口作用于图像边沿的时候，滑动窗口的某些像素并没有和图像重合，这时就需要对边沿做特殊处理，常用的方法有填0、填1、复制边沿等方式。</code></pre><p>二、medianBlur函数<br>1、函数原型<br>cv::medianBlur (InputArray src, OutputArray dst, int ksize)<br>2、参数详解<br>src    ：输入 1、3 或 4 通道图像； ksize 为 3 或 5 时，图像深度应为 CV_8U、CV_16U 或 CV_32F，对于较大的光圈尺寸，只能为 CV_8U。</p><p>dst    ：与 src 大小和类型相同的目标数组。</p><p>ksize    ：孔径线性尺寸； 它必须是奇数且大于 1，例如：3、5、7 …<br>三、OpenCV源码<br>1、源码路径</p><pre class="line-numbers language-none"><code class="language-none">opencv\modules\imgproc\src\median_blur.dispatch.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、源码代码</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void medianBlur( InputArray _src0, OutputArray _dst, int ksize )&#123;    CV_INSTRUMENT_REGION();CV_Assert(!_src0.empty()); CV_Assert( (ksize % 2 &#x3D;&#x3D; 1) &amp;&amp; (_src0.dims() &lt;&#x3D; 2 )); if( ksize &lt;&#x3D; 1 || _src0.empty() )&#123;   _src0.copyTo(_dst);    return;&#125; CV_OCL_RUN(_dst.isUMat(),         ocl_medianFilter(_src0,_dst, ksize)         ) Mat src0 &#x3D; _src0.getMat();_dst.create( src0.size(), src0.type() );Mat dst &#x3D; _dst.getMat(); CALL_HAL(medianBlur, cv_hal_medianBlur, src0.data, src0.step, dst.data, dst.step, src0.cols, src0.rows, src0.depth(),    src0.channels(), ksize    ); CV_OVX_RUN(true,           openvx_medianFilter(_src0, _dst, ksize)) &#x2F;&#x2F;CV_IPP_RUN_FAST(ipp_medianFilter(src0, dst, ksize)); CV_CPU_DISPATCH(medianBlur, (src0, dst, ksize),    CV_CPU_DISPATCH_MODES_ALL    );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>四、效果图像示例</p><p>原图：</p><p><img src="https://img-blog.csdnimg.cn/7a3c9fa7cb44463cb9c29ea0e1def515.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/9d19f5513c46421094abc1e260e2352d.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/9173c63503904f4eb03c876c4048cfa1.png" alt="img"></p><p>版权声明：本才来哦为CSDN博主「坐望云起」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/bashendixie5/article/details/125255049">https://blog.csdn.net/bashendixie5/article/details/125255049</a></p><h3 id="图像拼接"><a href="#图像拼接" class="headerlink" title="图像拼接"></a>图像拼接</h3><p>​        现在我们使用Numpy的hstack方法拼接一下图片：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>blur33<span class="token punctuation">,</span>Gaussain<span class="token punctuation">,</span>median<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Compare!"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Compare.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="Compare.png" alt="Compare"></p><p>​        起到对比效果（显然不是那么好。。。）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（3）</title>
      <link href="/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%883%EF%BC%89/"/>
      <url>/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学教程（8）不定积分"><a href="#高等数学教程（8）不定积分" class="headerlink" title="高等数学教程（8）不定积分"></a>高等数学教程（8）不定积分</h1><p>​        这一章内容通俗的说：就是求导的反向操作：我们需要求出谁求导的到现在的东西</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​        假设一个函数$f(x)$是一个函数$F(x)$求导的结果，那么称$F(x)$是$f(x)$的一个愿函数</p><p>这是因为$F(x)+C$(C是一个常数)求导也是$f(x)$</p><p>​        原函数存在定理：<strong>连续的函数一定有原函数</strong></p><p>​        说了这么多，我们又该怎么表示一个函数的原函数呢</p><script type="math/tex; mode=display">\int f(x)dx=F(x)+C</script><p>​        比如说：$\int x^2dx=\frac{x^3}{3}+C$</p><p>​        但是注意：这个容易错：$\int \frac{1}{x}dx=\ln{|x|}+C$</p><p>​        因为（x&lt;0）下$\ln{x}$无定义，可以把$\frac{-1}{-x}$看，这样就好了。</p><p>​        下面来看一些式子：</p><script type="math/tex; mode=display">\frac{d}{dx}[\int f(x)dx]=f(x)</script><script type="math/tex; mode=display">d[\int f(x)dx]=f(x)dx</script><p>​        说明了积分号在内微分号在外的式子，没有常数C（本质是$df(x)=f’(x)dx$）</p><p>​        </p><script type="math/tex; mode=display">\int F'(x)dx=F(x)+C</script><p>​        说明了积分号在外微分号在内的式子，有常数C（本质是$\int f(x)dx=F(x)+C$）</p><h3 id="积分表"><a href="#积分表" class="headerlink" title="积分表"></a>积分表</h3><p>​        幂函数的积分</p><script type="math/tex; mode=display">\int x^\mu dx=\frac{x^{\mu+1}}{\mu+1}+C</script><p>​        常数的不定积分：</p><script type="math/tex; mode=display">\int kdx=kx+C</script><p>​        </p><script type="math/tex; mode=display">\int \frac{dx}{1+x^2}dx=\arctan{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\sqrt {1-x^2}}dx=\arcsin{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\cos^2{x}}=\int \sec^2{x}=\tan{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\sin^2{x}}=\int \csc^2{x}=-\cot{x}+C</script><script type="math/tex; mode=display">\int \sec{x}\tan xdx=\sec{x}+C</script><script type="math/tex; mode=display">\int \csc{x}\cot{x}dx=-\csc{x}+C</script><script type="math/tex; mode=display">\int \frac{1}{x}dx=\ln |x|+C</script><script type="math/tex; mode=display">\int \cos{x}dx=\sin{x}+C</script><script type="math/tex; mode=display">\int \sin{x}dx=-\cos{x}+C</script><script type="math/tex; mode=display">\int e^xdx=e^x+C</script><script type="math/tex; mode=display">\int a^xdx=\frac{a^x}{\ln{a}}+C</script><h3 id="不定积分的性质"><a href="#不定积分的性质" class="headerlink" title="不定积分的性质"></a>不定积分的性质</h3><p>​        1）$\int [f(x)\pm g(x)]dx=\int f(x)dx \pm \int g(x)dx$</p><p>​        2)$\int kf(x)dx=k\int f(x)dx$</p><h3 id="第一类换元积分（凑微分法）"><a href="#第一类换元积分（凑微分法）" class="headerlink" title="第一类换元积分（凑微分法）"></a>第一类换元积分（凑微分法）</h3><p>​        首先回到这里：$\int 1 dF(u)=F(u)+C$,现在假设$u=\varphi (x)$,这样，我们就有$\int 1dF(\varphi(x))=F(\varphi(x))+C$,进一步的：$\int f(\varphi(x))\varphi ‘(x)dx=F(\varphi(x))+C$</p><p>说白了，就是复合求导的逆过程，我们的核心过程就是通过合并至d后面从而化简函数：</p><p>1）$\int 2\cos 2xdx$</p><p>解：$\int \cos 2xd(2x)=sin(2x)+C$</p><p>2)$\int \frac{1}{3+2x}dx$</p><p>解：$\int \frac{1}{2}\frac{1}{3+2x}d(2x+3)=\frac{1}{2}\ln|(2x+3)|+C$</p><p>3)$\int 2x e^{x^2}dx$</p><p>解：$\int  e^{x^2}dx^2= e^{x^2}+C$</p><p>4)$\int x\sqrt{1-x^2}dx$</p><p>解：$-\frac{1}{2}\int \sqrt{1-x^2}d(1-x^2)=-\frac{1}{3}(1-x^2)^{1.5}+C$</p><p>5)$\int \frac{x^2}{(x+2)^3}dx$</p><p>解:</p><p>$令:x+2=u$,$\int \frac{(u-2)^2}{u^3}du=\int (\frac{1}{u}-\frac{4}{u^2}+\frac{4}{u^3})du=\ln |u|+\frac{4}{u}-2\frac{1}{u^2}$</p><p>于是:$\ln |x+2|+\frac{4}{x+2}-2\frac{1}{(x+2)^2}$</p><p>6)$\int \frac{1}{a^2+x^2}dx(a\neq 0)$</p><p>解：$=\frac{1}{a}\int \frac{1}{1+(\frac{x}{a})^2}d(\frac{x}{a})=\frac{1}{a}\arctan \frac{x}{a}+C$</p><p>7)$\int \frac{dx}{\sqrt{a^2-x^2}}$</p><p>解：$\frac{1}{a}\int \frac{dx}{\sqrt{1-(\frac{x}{a})^2}}=\arcsin \frac{x}{a}+C$</p><p>8)$\int \frac{dx}{x^2-a^2}$</p><p>解：$\frac{1}{2a}\int (\frac{1}{x-a}-\frac{1}{x+a})dx=\frac{1}{2a}\ln|\frac{x-a}{x+a}|+C$</p><p>9)$\int \frac{dx}{x(1+2\ln x)}$</p><p>解：$\int \frac{d\ln{x}}{1+2\ln x}=\frac{1}{2}\ln|1+2\ln x|+C$</p><p>10）$\int \frac{e^{3\sqrt{x}}}{\sqrt{x}}dx$</p><p>解：$=2\int e^{3\sqrt{x}}d{\sqrt{x}}=\frac{2}{3}e^{3\sqrt{x}}+C$</p><p>11)$\int \sin^3xdx$</p><p>解：$\int sin^2xd\cos x=\int (1-cos^2x)d\cos x=-\cos x-\frac{1}{3}\cos^3x+C$</p><p>12)$\int \sin^2x\cos^5xdx$</p><p>解：$\int \sin^2\cos^4xd\sin x=\int \sin^2x(1-\sin^2x)^2d\sin x=\frac{\sin^3x}{3}-\frac{2\sin^5x}{5}+\frac{\sin^7x}{7}+C$</p><p>13)$\int \tan xdx$</p><p>解：</p><p>$\int \frac{\sin x}{\cos x}dx=-\int \frac{1}{\cos x}d\cos x=-\ln|cos(x)|+C$</p><p>14)$\int \cos^2xdx$</p><p>解：$\int \frac{1+\cos2x}{2}dx=\frac{x}{2}+\frac{\sin 2x}{4}+C$</p><p>15)$\int \sin^2x\cos^4xdx$</p><p>解：$\int \frac{1-\cos{2x}}{2}(\frac{1+\cos{2x}}{2})^2dx=\frac{1}{8}(x+\frac{1}{2}\sin 2x-\frac{1}{2}x-\frac{1}{8}\sin 4x-\frac{1}{2}(\sin 2x-\frac{sin^3 2x}{3}))+C$</p><p>16)$\int \sec^6xdx$</p><p>解：$\int \sec^4xd\tan x=\int (\tan^2x+1)^2d\tan x=\frac{\tan^5x}{5}+\frac{2\tan^3x}{3}+\tan x+C$</p><p>17)$\int \csc xdx$</p><p>解：$\int \frac{1}{\sin x}dx=\frac{\cos \frac{x}{2}dx}{2\sin \frac{x}{2}\cos^2\frac{x}{2}}=\int \frac{\sec^2\frac{x}{2}}{\tan\frac{x}{2}}d(\frac{x}{2})=\int \frac{d\tan\frac{x}{2}}{\tan \frac{x}{2}}=\ln|\tan \frac{x}{2}|+C$</p><p>总结下：三角函数者：奇次提，偶次被倍角公式替换</p><h3 id="第二类换元积分"><a href="#第二类换元积分" class="headerlink" title="第二类换元积分"></a>第二类换元积分</h3><p>​        我们把d()内的东西往外提，化而言之：就是换元$x=\varphi(t)$再求积分：</p><p>$\int f(x)dx=\int f(\varphi(t))\varphi’(t)dt$</p><p>1)$\int \sqrt{a^2-x^2}dx(a&gt;0)$</p><p>解:令：$x=a\sin t,t\in(-\frac{\pi}{2},\frac{\pi}{2})$</p><p>故：$\int \sqrt{a^2-x^2}dx=a\cos tdx$</p><p>$dx=a\cos t$</p><p>因此：$\int a^2\cos^2tdt=a^2(\frac{t}{2}+\frac{\sin2t}{4})+C=a^2t+a^2\frac{\sin t\cos t}{2}+C$</p><p>又$\sin t=\frac{x}{a},\cos t=\frac{\sqrt{a^2-x^2}}{a}$</p><p>这样：$\frac{a^2}{2}\arcsin\frac{x}{a}+\frac{x}{2}\sqrt{a^2-x^2}+C$</p><p>2)$\int \frac{dx}{\sqrt{x^2+a^2}}(a&gt;0)$</p><p>现令：$x=a\tan t$</p><p>则：$\int \frac{dx}{a\sec x}$</p><p>又：$dx=a\sec^2 tdt$</p><p>那么：$\int \sec tdt=\ln|\sec t+\tan t|+C$</p><p>我们可以使用三角形法来看：</p><p><img src="image-20230120122352772.png" alt="image-20230120122352772"></p><p>这下，我们找到了：$\tan t=\frac{x}{a},\sec t= \frac{\sqrt{x^2+a^2}}{a}$</p><p>于是：$=\ln|\frac{\sqrt{x^2+a^2}}{a}+\frac{x}{a}|+C=\ln(\sqrt{x^2+a^2}+x)+C’$</p><p>3)$\int \frac{dx}{\sqrt{x^2-a^2}}$</p><p>解：</p><p>令：$x=a\sec t,则：\int \frac{dx}{a\tan t}$</p><p>$dx=a\sec t\tan tdt$</p><p>于是：$\int \sec tdt=\ln(x+\sqrt{x^2-a^2})+C$</p><p><strong>小总结：</strong></p><p>$\sqrt{a^2-x^2}\longrightarrow x=a\sin t,|a\cos t|$</p><p><strong>$\sqrt{x^2-a^2}\longrightarrow x=a\sec t,|a\tan t|$</strong></p><p>$\sqrt{a^2+x^2}\longrightarrow x=a\tan t,|a\sec t|$</p><p>4)$\int \frac{\sqrt{a^2-x^2}}{x^4}dx$</p><p>解：令：$x=\frac{1}{t}$得：</p><p>$dx=-\frac{1}{t^2}dt,-\int (a^2t^2-1)^{0.5}|t|dt$</p><p>由此：$x&gt;0下 ,=-\frac{(a^2-x^2)^{1.5}}{2a^2x^3}+C$</p><p>或者使用三角函数也可以：</p><p><img src="image-20230120124326362.png" alt="image-20230120124326362"></p><h3 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h3><p>​        我们来看：$\int udv=uv-\int vdu$</p><p>我们就可以化简积分了：如：</p><p>1)$\int xe^xdx=\int xde^x=xe^x-e^x=(x-1)e^x+C$</p><p>有的时候，我们可以尝试的去试试看谁做微分是简单的</p><p>往往$e^x$要放到微分里。</p><p>2)$\int x\cos xdx=\int xd\sin x=x\sin x-\int \sin xdx=x\sin x+\cos x+C$</p><p>往往三角函数要放到微分里。</p><p>那这样呢：</p><p>$\int \sin x e^xdx$</p><p>注意：$=\sin xe^x-\int e^x\cos xdx=\sin x e^x-\cos xe^x-\int \sin x e^xdx$</p><p>居然出现了我们要求的东西：</p><p>于是：$\int \sin x e^xdx=\frac{1}{2}(\sin x e^x-\cos xe^x)$</p><p>3)$\int \arccos xdx=x\arccos x-\frac{1}{2}\int \frac{d(1-x^2)}{\sqrt{1-x^2}}=x\arccos x-\sqrt{1-x^2}+C$</p><h3 id="有理函数"><a href="#有理函数" class="headerlink" title="有理函数"></a>有理函数</h3><p>​        这是针对$\frac{P(x)}{Q(x)}$的有理分式的积分方法：我们主要是添项拆项从而分离成若干简单分式的和差，从而方便我们的积分</p><p>1）P(x)的阶高于Q(x)</p><p>​        我们分离常数使之所有的子分式的分母阶比分子高：</p><p>2）P(x)的阶低于Q(x)</p><p>i.分母一阶的，直接$\ln$</p><p>ii.分母二阶的：</p><p>可以因式分解的：分解因式化简</p><p>不可以因式分解的：配方后变成$(ax+b)^2+C$的$\arctan$类型积分</p><p><img src="image-20230120130430538.png" alt="image-20230120130430538"></p><p>iii.分子分母差一次、</p><p>把分子扔进d里面升次</p><p><img src="image-20230120130642841.png" alt="image-20230120130642841"></p><p>iv.一般的</p><p>我们假设一个式子可以分解成若干的分式和，其分式的特点是：分子比分母底一阶，分子假设为全项的多项式：</p><p>如</p><p><img src="image-20230120130943140.png" alt="image-20230120130943140"></p><p>根式：</p><p>令t为根式，换元即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（2）</title>
      <link href="/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
      <url>/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学基础教程：导数的定义与使用"><a href="#高等数学基础教程：导数的定义与使用" class="headerlink" title="高等数学基础教程：导数的定义与使用"></a>高等数学基础教程：导数的定义与使用</h1><h2 id="一-基本定义和性质"><a href="#一-基本定义和性质" class="headerlink" title="一.基本定义和性质"></a>一.基本定义和性质</h2><h3 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h3><p>​        恭喜！你来到了导数这一章！现在，我们可以使用它来更精确的描述函数是怎么增长变动的！！！</p><p>​        首先，引入一个场景：讨论速度与位移，并且我们都用时间来表示：</p><p>那么，一个平均速度可以用如下这个式子来表达：$v=\frac{f(t)-f(t_0)}{t-t_0}$</p><p>​        这是我们中学就已经熟知的。</p><p>​        现在，让我们让$t\rightarrow{t_0}$ 也就是让t逼近$t_0$。这样，回到高中物理，我们就知道我们得到了瞬时速度。</p><p>​        其实，很多函数变化，都可以类比的使用这种办法得到函数在一个点的变化情况，下面，让我们统一一下，使用一个定义来综述：</p><p>$定义 y=f(x)在x_0的领域内有定义，对x_0取增量\Delta{x}，那么函数的增量就是\Delta{y}=f(x_0+\Delta{x})-f(x_0)，如果\lim\limits_{\Delta{x}\rightarrow{0}}\frac{\Delta{y}}{\Delta{x}}=\lim\limits_{\Delta{x}\rightarrow{0}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}$ $是存在的，我们就称呼y=f(x)在x_0处可导，且这个极限值就是y=f(x)在x_0处的导数$</p><p>​        记作$y’| _{x=x_0},f’(x_0),\frac{dy}{dx}|_{x=x_0}，\frac{df(x)}{dx}|_{x=x_0}$上面四个选一个</p><p>当然，导数还有另一个定义：就是</p><p>​      $如果\lim\limits_{x\rightarrow{x_0}}\frac{\Delta{y}}{\Delta{x}}=\lim\limits_{x\rightarrow{x_0}}\frac{f(x)-f(x_0)}{x-x_0}是存在的，我们就称呼y=f(x)在x_0处可导，且这个极限值就是y=f(x)在x_0处的导数$ </p><p>​        如果函数在一个区间内处处可导，我们就可以再用一个函数刻画导数：导函数$f’(x)$</p><p>​        下面来看一些函数的导（函）数（方便起见使用h代替$\Delta{x}$）</p><p>（1）$f(x)=C$</p><p>则：$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=0$</p><p>故$C’=0$</p><p>(2)$f(x)=x^n$</p><p>1.当n=1时:$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=1$</p><p>2.当n&gt;1时：$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\rightarrow{0}}\frac{(x+h)^n-x^n}{h}$</p><p>而：$(x+y)^n=x^n+nx^{n-1}y+\frac{n(n-1)}{2}x^{n-2}y^{2}+…+ny^{n-1}x+y^n$</p><p>于是$极限=\lim\limits_{h\rightarrow{0}}nx^{n-1}+(…)\times{h}=nx^{n-1}$</p><p>3.当$f(x)=x^{\mu},\mu\in{R}，(x\neq{0})$</p><p>于是：</p><p><img src="image-20221230201314473.png" alt="image-20221230201314473"></p><p>$(x^\mu)’=\mu{x^{\mu-1}}$</p><p>4.$f(x)=\sin{x}$</p><p>$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\rightarrow{0}}\frac{\sin{(x+h)}-\sin{x}}{h}=\lim\limits_{h\rightarrow{0}}\frac{\cos(x+\frac{h}{2})\times{\sin{\frac{h}{2}}}}{\frac{h}{2}}=\cos{x}$</p><p>所以：$\sin’{x}=\cos{x}$</p><p>类似的$\cos’{x}=-\sin{x}$</p><p>5.$(a^x)’=a^x\ln{a},特别的(e^x)’=e^x$</p><p>6.$\log’_{a}{x}=\frac{1}{x\ln{a}},特别的\ln’x=\frac{1}{x}$</p><h3 id="单侧导数"><a href="#单侧导数" class="headerlink" title="单侧导数"></a>单侧导数</h3><p>​        导数也有单侧导数的这一概念，直观的讲，正是导数以不同的方式逼近一个点所产生的：</p><p>​        回忆我们先前的类似概念，左侧导数的定义是这样的：</p><p>​        </p><script type="math/tex; mode=display">f'_{-}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^-} }\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        更容易理解的：右导数的定义是这样的：</p><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^+}}\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        当然，也有第二定义</p><p>​        左导数：</p>$$f'_{-}(x_0)=\lim \limits_{ { x } \rightarrow{x_0^-} } \frac{f(x_0+h)-f(x_0)} {h}$$<p>​        右导数：</p><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{ { x} \rightarrow{x_0^+} }\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        于是，可导的一种判断方式有了：在一个点的左右导数存在相等。</p><p>​        对于$y=|x|$ ，在$x_0$左侧的左导数为-1，右导数为1，这两个不相等，故$|x|$在$x=0$处不存在导数。</p><h3 id="导数也有几何意义"><a href="#导数也有几何意义" class="headerlink" title="导数也有几何意义"></a>导数也有几何意义</h3><p>​        导数也有几何意义，不错。那么，导数的几何意义是什么呢？直接说：导数的几何意义就是函数图像在某一点上的切线的斜率，一个处处可导的曲线必然光滑。</p><p><img src="image-20230104153906913.png" alt="image-20230104153906913"></p><p>​        于是，切线方程可以这样给出</p><script type="math/tex; mode=display">l:y-y_0=f'(x_0)(x-x_0)</script><p>​        有切线了，法线也会有：法线就是过切点的，垂直于切线的线：</p><script type="math/tex; mode=display">l':y-y_0=-\frac{1}{f'(x_0)}(x-x_0)</script><p>​        比如说，让我们求$y=\frac{1}{x}$在$(\frac{1}{2},2)$上的切线：</p><script type="math/tex; mode=display">证明:显然在x_0=\frac{1}{2}这个点上，f'(x_0)=-4</script><script type="math/tex; mode=display">于是切线方程为:y-2=-4(x-\frac{1}{2})</script><script type="math/tex; mode=display">法线方程为：y-2=\frac{1}{4}(x-\frac{1}{2})</script><h3 id="联系起来：探寻可导与连续的关系"><a href="#联系起来：探寻可导与连续的关系" class="headerlink" title="联系起来：探寻可导与连续的关系"></a>联系起来：探寻可导与连续的关系</h3><p>​        我们可以简单的理解认为可导就说明函数曲线的光滑，连续就是函数图像不产生间断。看来：函数如果光滑，则一定没有间断，函数没有间断却不一定光滑。那我们认为：<strong>可导必然连续，连续不一定可导。</strong></p><p>​        对于这件事情：可以想象一排自行车：如果他们想多米诺骨牌一样倒下了 （可 倒（导））说明他们一定连续的放置，反之，如果不去动他们，则他们就算连续放置也不会倒下，可以这样记。</p><p>​        回到数学的定义上，我们对比一下：</p><script type="math/tex; mode=display">连续:\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=0</script><script type="math/tex; mode=display">可导:\lim\limits_{\Delta{x}\rightarrow{0}}\frac{\Delta{y}}{\Delta{x}}=C(const)</script><p>​        于是，如果一个$\Delta{x}\rightarrow{0}$，同时，可导定义比出来的比值还必须是一个常数，由同阶无穷小的定义，我们不得不得出$\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=0$的结论，也就是连续。</p><p>​        反之，我们的$\Delta{y}$可能并不会与$\Delta{x}$属于同阶无穷小，因此，我们的可导定义极限可能发散。于是：就可能并不可导</p><h3 id="求导法则：和差商积"><a href="#求导法则：和差商积" class="headerlink" title="求导法则：和差商积"></a>求导法则：和差商积</h3><p>​        高中我们就接触过了：</p><p>​        首先定义$u,v$是两个可导函数，其值为$u’,v’$</p><script type="math/tex; mode=display">法则1: (u+v)'=u'+v'</script><script type="math/tex; mode=display">法则2:(u-v)'=u'-v'</script><script type="math/tex; mode=display">法则3:(uv)'=uv'+vu'</script><script type="math/tex; mode=display">法则4:(cu)'=cu'(c是常数)</script><script type="math/tex; mode=display">法则5:(\frac{u}{v})'=\frac{u'v-uv'}{v^2}</script><p>法则1234都可以扩展：</p><p>对于有限个$u_i$的可导函数：他们的和的导数为各自导数的和</p><script type="math/tex; mode=display">(u+v+w+...+...+s)'=u'+v'+w'+...+...+s'</script><p>对于有限个$u_i$的可导函数：他们的积的导数为所有$u_i$的积中轮流取出一个$u_k(k\in{(1,i)})$求一次导</p><script type="math/tex; mode=display">(uvw...s)'=u'vw...s+uv'w...s+uvw'...s+...+uvw...s'</script><h3 id="反函数的求导法则"><a href="#反函数的求导法则" class="headerlink" title="反函数的求导法则"></a>反函数的求导法则</h3><p>​        反函数也能求导。</p><script type="math/tex; mode=display">定理:x=f(y)在I_y内单调且可导，同时f'(y)\neq{0},</script><script type="math/tex; mode=display">那么反函数y=f^{-1}(x)的导函数如下：</script><script type="math/tex; mode=display">[f^{-1}(x)]'=\frac{1}{f'(y)}</script><p>​        超前一点，可以引入记号$\frac{dy}{dx}$表达$f(x)$的导数，而$\frac{dx}{dy}$就是反函数，于是：</p><script type="math/tex; mode=display">\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}</script><p>​        他让我们的导数公式可以扩充了：</p><p>​        例如:$x=\sin{y}$作为$y=\sin{x}$的反函数的公式</p><script type="math/tex; mode=display">因为:\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}=\frac{1}{\cos{y}}</script><script type="math/tex; mode=display">且:\sin^2{y}+\cos^2{y}=1\Longrightarrow{\cos{y}=\sqrt{1-\sin^2{y}}=\sqrt{1-x^2}}</script><p>​        于是：$y=\arcsin{x}$的导数公式正是：$\arcsin{x}’=\frac{1}{\sqrt{1-x^2}}$.</p><p>​        这样，我们也还可以求出其他公式：</p><script type="math/tex; mode=display">\arccos{x}'=-\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arctan{x}'=\frac{1}{1+x^2}</script><h3 id="复合函数的求导法则"><a href="#复合函数的求导法则" class="headerlink" title="复合函数的求导法则"></a>复合函数的求导法则</h3><p>​        下面，我们先从严肃的讲起：</p><p>​        假设，我说假设：$f(x)$是一个很复杂的东西：但好消息是，可以是做若干函数的嵌套：比如说$\ln{\sqrt{\frac{1}{cos{\ln{\sin^2{x}}}}}{sin{x}}}$云者，那这样的函数这么求导呢？复合求导法来力！</p><p>​        </p><script type="math/tex; mode=display">法则:简单的，视函数f(x)是由f(u),u=g(x)嵌套，那么它的导数是:</script><script type="math/tex; mode=display">f'(x)=f'(u)\times{g'(x)}</script><p>​        就是说，我们可以视$u$作一个整体，先想象成单一函数$f(x)$求导，不过$x$是$u$,随后对$u$求导，乘起来的时候u要换成x.</p><p>​        使用微分语言是这样描述的：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{dy}{du}\times\frac{du}{dx}</script><p>​        想象成分式乘法，我们自然可以：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{dy}{du}\times\frac{du}{dk}\times\frac{dk}{dw}...\times\frac{ds}{dx}</script><p>​        例如说：对$e^{x^{3}}$求导</p><p>​        我们首先设$u=x^3$，而$e^u$对$u$求导显然是$e^u$，那么$u$对$x$是$3x^2$根据法则，我们要把连着直接相乘$3e^u{x^2}$，但是还没换回来$x$,因此将$u=x^3$换回来得到结果$3e^{x^3}{x^2}$</p><p>​        那么：$y=\ln{\cos{e^x}}$如何？</p><p>​        直接设置$y=\ln{u},u=\cos{v},v=e^x$结合复合函数求导法则。</p><p>​        $y’=\frac{1}{u}\times{-\sin{v}}\times{e^x}$</p><p>​        换元：$y’=\frac{-\sin{e^x}\times{e^x}}{\cos{e^x}}$</p><h3 id="导数公式表"><a href="#导数公式表" class="headerlink" title="导数公式表"></a>导数公式表</h3><p>​        介绍完导数的求导法则，我们也就可以引入一系列的求导表了：</p><script type="math/tex; mode=display">(C)'=0</script><script type="math/tex; mode=display">(x^{\mu})'=\mu{x^{\mu-1}}</script><script type="math/tex; mode=display">\sin{x}'=\cos{x}</script><script type="math/tex; mode=display">\cos{x}'=-\sin{x}</script><script type="math/tex; mode=display">\tan{x}'=\sec^2{x}</script><script type="math/tex; mode=display">\cot{x}'=-\csc^2{x}</script><script type="math/tex; mode=display">\sec{x}'=\sec{x}\tan{x}</script><script type="math/tex; mode=display">\csc{x}'=-\csc{x}\cot{x}</script><script type="math/tex; mode=display">(a^x)'=\ln{a}\times{a^x},(e^x)'={e^x}</script><script type="math/tex; mode=display">\log_a{x}'=\frac{1}{x\ln{a}}</script><script type="math/tex; mode=display">\ln{x}'=\frac{1}{x}</script><script type="math/tex; mode=display">\arcsin{x}'=\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arccos{x}'=-\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arctan{x}'=\frac{1}NaN</script><script type="math/tex; mode=display">arccot{x}'=-\frac{1}NaN</script><h3 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h3><p>​        就是对一个函数求有限次导数：比如说</p><script type="math/tex; mode=display">y=x^3,y'=3x^2,y''=6x,y'''=6,y^{(4)}=0</script><p>​        在微分学里也有专门的符号表示</p><script type="math/tex; mode=display">一阶导数:\frac{dy}{dx}</script><script type="math/tex; mode=display">二阶导数:\frac{d}{dx}(\frac{dy}{dx})=\frac{d^2y}{dx^2}</script><script type="math/tex; mode=display">N阶导数:\underbrace{\frac{d}{dx}\frac{d}{dx}...\frac{d}{dx}\frac{dx}{dy}}_{Ntimes}=\frac{d^ny}{dx^n}</script><p>一些常见的N阶导数公式是如下的：</p><script type="math/tex; mode=display">\sin^{(x)}x=\sin{(x+\frac{n}{2}{\pi})}</script><script type="math/tex; mode=display">\cos^{(x)}x=\cos{(x+\frac{n}{2}{\pi})}</script><script type="math/tex; mode=display">\ln^{(n)}{(x+1)}=(-1)^{n-1}\frac{(n-1)!}{(1+x)^n}</script><script type="math/tex; mode=display">x^{\mu{(n)}}=\mu{(\mu-1)}{(\mu-2)}...{(\mu-n+1)}x^{\mu-n}</script><p>一些法则也是成立的：</p><script type="math/tex; mode=display">(u+v)^{(n)}=u^{(n)}+v^{(n)}</script><p>但是乘法不是，是莱布尼兹公式：</p><script type="math/tex; mode=display">(uv)^{(n)}=\sum^{n}_{k=0}C^{k}_{n}u^{(u-k)}v^{k}</script><h3 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h3><p>​        我们现在接触的函数都是显函数，$y$与$x$都是显然分离的，比如说$y=\sin{x}$云者，有一些函数是$x$和$y$混在一起的，比如说如下的几个式子</p><p>​                                                $                e^{xy}+\sin{y^2}+x^3+8=0$</p><p>​                                                    $e^y-xy-e=0$</p><p>云者。这些被称为隐函数，或者说：关于x的一个方程。</p><p>​        下面，我们介绍这样函数的求导方式：</p><p>​        我们假设$y=y(x)$是一个x的函数，于是，这样的方程成为了一个恒等式：一个关于x的一个大函数$F(x,f(x))=0$的式子。，现在我们求导，就是使用求导法则运算解决问题：右侧作为常数，导数恒为0，对左侧求导即可。下面对：</p><p>​                                                    $e^y-xy-e=0$</p><p>求导</p><p>​        左侧：$e^y\cdot{y’}+y+xy’$</p><p>​        右侧：0</p><p>​        现在参数分离：$y’=-\frac{y}{e^y+x}$</p><p>​                                            $y^5+2y-x-3x^7=0$</p><p>求导：</p><p>​        左侧：$5y^4y’+2y’-1-21x^6=0$</p><p>​        右侧：0</p><p>​        现在参数分离：$y’=\frac{1+21x^6}{5y^4+2}$</p><h3 id="参数方程求导"><a href="#参数方程求导" class="headerlink" title="参数方程求导"></a>参数方程求导</h3><p>​        我们说一些函数可以用</p><script type="math/tex; mode=display">\begin{align*}\begin{split}\left \{\begin{array}{ll}  x= \psi{(t)}                    \\  y=  \varphi{(t)}                               \end{array}\right.\end{split}\end{align*}</script><p>表示，这个时候，可以使用微分形式的公式更好的表达求导：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{\frac{dy}{dt}}{\frac{dx}{dt}}=\frac{\varphi{(x)}'}{\psi{(x)}'}</script><p>微分可以视作增量的一种表达：</p><p>​        回顾增量公式$\Delta{y}=f(x_0+\Delta{x})-f(x_0)$,我们常常发现以这种形式表达的$\Delta{y}$经常可以被写成$A\Delta{x}+o(\Delta{x})$的形式，注意到$A$与$\Delta{x}$是无关的。如果函数的增量可以这样表达：</p><script type="math/tex; mode=display">\Delta{y}=A\Delta{x}+o(\Delta{x})</script><p>​        $A$与$\Delta{x}$是无关,</p><p>​        那么，我们就改写成这样的形式：</p><script type="math/tex; mode=display">dy=Adx</script><p>​        同时，我们还说这样的函数在这一点是可微的：并且，可微一定可导，可导也一定可微：事实上，以此为基准</p><script type="math/tex; mode=display">dy=f'(x_0)dx</script><p>​        微分与导数就是变化率问题的等价表达</p><p>​        于是任何微分公式都可以由上述公式给出：</p><p>​        比如说：$y=x^2,dy=2xdx$</p><h3 id="微分在近似计算的应用"><a href="#微分在近似计算的应用" class="headerlink" title="微分在近似计算的应用"></a>微分在近似计算的应用</h3><p>​        回到上面讲的公式：</p><script type="math/tex; mode=display">\Delta{y}=f(x_0+\Delta{x})-f(x_0)</script><p>​        这个公式，我们可以对一个已知临近量的函数值求另一点相近的函数值的近似值，我们对公式移项：</p><script type="math/tex; mode=display">f(x_0+\Delta{x})=f'(x_0)\Delta{x}+f(x_0)</script><p><img src="image-20230104175543374.png" alt="image-20230104175543374"></p><h2 id="二-导数的应用"><a href="#二-导数的应用" class="headerlink" title="二.导数的应用"></a>二.导数的应用</h2><h4 id="Rolle（罗尔）定理"><a href="#Rolle（罗尔）定理" class="headerlink" title="Rolle（罗尔）定理"></a>Rolle（罗尔）定理</h4><p>​        事实上，为了更好的证明罗尔定理，一般我们需要严格的引入费马定理：</p><h4 id="费马定理"><a href="#费马定理" class="headerlink" title="费马定理"></a>费马定理</h4><p><strong>$f(x)$在$x_0$及其领域有定义，且在$x_0$处可导，如果$f(x)\leqslant{f(x_0)}$(或者$f(x)\geqslant{f(x_0)}$)</strong></p><p><strong>则$\forall{x}\in \cup(x_0)$(这表示领域)，$f’(x_0)=0$</strong></p><p><img src="image-20230106084644861.png" alt="image-20230106084644861"></p><p>​        看起来容易，怎么证明？我们不妨从$x_0$可导入手：</p><p>证明：以$f(x_0)$是最大值为例：函数$f(x)$在$x_0$处可导，那就要求：</p><script type="math/tex; mode=display">x\in \cup(x_0),f(x)\leqslant{f(x_0)}</script><p>​        同时注意到$x_0+\Delta{x}$也是在$\cup(x_0)$上的，于是也有：</p><script type="math/tex; mode=display">x_0+\Delta{x} \in \cup(x_0),f(x_0+\Delta{x})\leqslant{f(x_0)}</script><p>​        同时函数$f(x)$在$x_0$处可导：</p><script type="math/tex; mode=display">f'_{-}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^-}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}\leqslant{0}</script><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^+}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}\geqslant{0}</script><p>​        </p><script type="math/tex; mode=display">f'_{-}(x_0)=f'_{+}(x_0)</script><p>​        上面的三个式子联立：得到$f’_{-}(x_0)=f’_{+}(x_0)=f’(x_0)=0$</p><p>证毕。</p><p>​        于是：又把导数为0的点成为驻点，因为函数在这一点停靠在$y=f(x_0)$上不变化，他们是可能的极值点（会在后面阐述为什么是可能）</p><h4 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h4><p><strong>首先函数$f(x)$满足</strong></p><p><strong>1）在$[a,b]$上连续 2)在$(a,b)$上可导 3）$f(a)=f(b)$</strong></p><p><strong>则至少存在一点$\xi\in(a,b),f’(\xi)=0$</strong></p><p><img src="image-20230106090148355.png" alt="image-20230106090148355"></p><p>这个定理说明了在端点值相等的区间里函数必有<strong>至少</strong>一个驻点。</p><h4 id="拉格朗日中值定理"><a href="#拉格朗日中值定理" class="headerlink" title="拉格朗日中值定理"></a>拉格朗日中值定理</h4><p><strong>要求：1)$[a,b]$连续          2)$(a,b)$可导：</strong></p><p><strong>则函数$f(x)$在$(a,b)$上至少有一个点$\xi$,使得下面的式子成立：</strong></p><script type="math/tex; mode=display">f'(\xi)=\frac{f(b)-f(a)}{b-a}</script><p><img src="image-20230106090806236.png" alt="image-20230106090806236"></p><p>​        说白了，就是罗尔定理的扩展，我们链接两个端点，产生的直线称为函数的一条<strong>弦</strong>在函数上我们至少可以找到一个点的切线斜率等于这条线的斜率的大小。</p><h4 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h4><p>如果$f(x)$和$F(x)$满足：</p><p>1）$[a,b]$连续          2)$(a,b)$可导          3）$\forall{x}\in(a,b),F’(x)\neq{0}$</p><p>则至少有一个点$\xi$,使得$\frac{f(b)-f(a)}{F(b)-F(a)}=\frac{f’(\xi)}{F’(\xi)}$</p><p>​        这又是拉格朗日中值定理的推广。</p><h4 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h4><p>​        这玩意干嘛的？求解未定式$\frac{0}{0}$,$\frac{\infty}{\infty}$的式子</p><p>注意：法则内容如下：</p><p>1）两个函数$f(x),F(x)$在$x\rightarrow a$都同时倾向于$0$或者$\infty$ </p><p>2）在$a$的去心领域内$f’(x),F’(x)$都存在且$F’(x)\neq 0$</p><p>3）$\lim\limits_{x\rightarrow a}\frac{f’(x)}{F’(x)}$存在（或者无穷大）</p><p>则$\lim\limits_{x\rightarrow a}\frac{f(x)}{F(x)}=\lim\limits_{x\rightarrow a}\frac{f(x)}{F(x)}$</p><p>例子：</p><script type="math/tex; mode=display">1)\lim\limits_{x\rightarrow 0}\frac{\sin{ax}}{\sin bx}=\lim\limits_{x\rightarrow 0}\frac{a\cos ax}{b \cos bx}=\frac{a}{b}</script><p>注意：如果使用完一次洛必达后的式子<strong>仍满足洛必达的条件</strong>可以继续使用</p><p>比如说</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow 1}\frac{x^3-3x+2}{x^3-x^2-x+1}=\lim\limits_{x\rightarrow 1}\frac{3x^2-3}{3x^2-2x-1}=\lim\limits_{x\rightarrow 1}\frac{6x}{6x-2}</script><p>​        到这里就不能再使用洛必达法则了：因为$\lim\limits_{x\rightarrow 1}\frac{6x}{6x-2}$不满足条件1)，所以：直接带值得到$\frac{3}{2}$结束</p><p>​        注意，我们可以使用这个法则分析一些常见函数的发散速度：</p><p>命题：比较$\ln x,x^n,e^{\lambda{x}}$的发散速度</p><p>比较$\ln x,x^n$</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{\ln x}{x^n}=\lim\limits_{x\rightarrow \infty}\frac{1}{nx^{n-1}\cdot{x}}=0</script><p>​        这意味这$\ln{x}$的发散速度小于$x^n$的发散速度。</p><p>比较$x^n，e^{\lambda{x}}$</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{x^n}{e^{\lambda{x}}}=\lim\limits_{x\rightarrow \infty}\frac{nx^{n-1}}{\lambda e^{\lambda{x}}}=\lim\limits_{x\rightarrow \infty}\frac{n(n-1)x^{n-2}}{\lambda ^2e^{\lambda{x}}}=...=\lim\limits_{x\rightarrow \infty}\frac{n!}{\lambda ^ne^{\lambda{x}}}=0</script><p>​    这意味这$x^n$的发散速度小于$e^{\lambda{x}}$的发散速度。</p><h4 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h4><p>​        泰勒公式是用若干多项式近似描述函数的一个公式：</p><script type="math/tex; mode=display">P_n(x)=\sum_{k=0}^{n} a_k(x-x_0)^k +R(x)=f(x)</script><p>​        这样一个过程。$R(x)$是高于n阶的一个误差数。</p><p>​        我们求$x_0$一阶导数得到：$f’(x_0)=a_1$</p><p>​        类似的$f’’(x_0)=1\cdot 2a_2$</p><p>​        $f’’’(x_0)=1\cdot 2 \cdot 3a_3$</p><p>​        …</p><p>​        $f^{(n)}(x)=n!a_n$</p><p>​        这样多项式的系数就确定了！替换一下：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)</script><p>其中$R_n(x)=o(x-x_0)^n$当然，由拉格朗日中值定理，$R_n(x)$也可以这样表达：</p><script type="math/tex; mode=display">R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}</script><p>当然还有更紧凑的形式：</p><script type="math/tex; mode=display">f(x)=\sum_{k=0}^{n}\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k+R_n(x)</script><p>我们使用泰勒公式看看一些函数的近似,为了简便，我们自然取$x_0=0$</p><script type="math/tex; mode=display">e^x=1+x+\frac{x^2}{2}+\frac{x^3}{6}+...+\frac{x^n}{n!}+R_n(x)=\sum_{k=0}^{n}\frac{(x-x_0)^k}{k!}+R_n(x)</script><script type="math/tex; mode=display">\sin{x}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-...(-1)^{(m-1)}\frac{x^{(2m-1)}}{(2m-1)!}+R_{2m}(x)=\sum_{k=0}^{n}\frac{(-1)^{(m-1)}(x-x_0)^k}{(2m-1)!}+R_{2m}(x)</script><script type="math/tex; mode=display">\cos{x}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-...(-1)^{(m-1)}\frac{x^{2m}}{(2m)!}+R_{2m}(x)=\sum_{k=0}^{n}\frac{(-1)^{(m-1)}(x-x_0)^k}{(2m)!}+R_{2m}(x)</script><script type="math/tex; mode=display">\ln{(x+1)}=x-\frac{x^2}{2}+\frac{x^3}{3}-...+(-1)^{(n-1)}\frac{x^n}{n}+\sum_{k=1}^{n}(-1)^{(n-1)}\frac{x^n}{n}+R_n(x)</script><script type="math/tex; mode=display">(1+x)^\alpha=1+\alpha{x}+\frac{\alpha(\alpha-1)}{2!}x^2+...+\frac{\alpha(\alpha-1)...(\alpha-n+1)}{n!}(x-x_0)^n=\sum_{k=0}^{n}\frac{C_k^{\alpha}}{k!}(x-x_0)^k</script><h4 id="函数的单调性"><a href="#函数的单调性" class="headerlink" title="函数的单调性"></a>函数的单调性</h4><p>​        现在，我们可以系统的分析函数的单调性了：</p><p>​        函数的单调性分为单调递增和单调递减：( x 在区间 I ,且函数连续)</p><script type="math/tex; mode=display">函数单调递增:f'(x)>0</script><script type="math/tex; mode=display">函数单调递减:f'(x)<0</script><p>​        于是下面给出定理：</p><script type="math/tex; mode=display">y=f(x)在[a,b]连续,(a,b)可导 且f'(x)\geqslant{0},更进一步的等号在有限个点取到</script><script type="math/tex; mode=display">那么我们说：函数在区间(a,b)上单调递增</script><p>​        同理：单调递减的也是类似的</p><script type="math/tex; mode=display">y=f(x)在[a,b]连续,(a,b)可导 且f'(x)\leqslant{0},更进一步的等号在有限个点取到</script><script type="math/tex; mode=display">那么我们说：函数在区间(a,b)上单调递减</script><p>​        函数的单调性与一阶导数息息相关，看一些例题 </p><script type="math/tex; mode=display">分析y=x-\sin x [-\pi,\pi]的单调性</script><p>​        </p><p>​        因为：</p><script type="math/tex; mode=display">y'=1-\cos{x}\geqslant 0</script><p>​        故函数总在$[-\pi,\pi]$单调递增。</p><p>​        这样的一些点是我们在求解一阶导数的时候需要注意的：</p><p>1）$f’(x)=0$  的点：又叫驻点。</p><p>2)导数不存在的点</p><p>例题：</p><script type="math/tex; mode=display">分析f(x)=2x^3-9x^2+12x-3 的单调性</script><script type="math/tex; mode=display">f'(x)=6x^2-18x+12=6(x-1)(x-2)</script><script type="math/tex; mode=display">所以：x<1单增，1\leqslant{x}\leqslant{2}单减，x\geqslant{2} 单增</script><h4 id="函数的凹凸性"><a href="#函数的凹凸性" class="headerlink" title="函数的凹凸性"></a>函数的凹凸性</h4><p>​        我们还要关注函数是怎样的单调递增或者单调递减，这就需要我们使用二阶导数分析函数的凹凸性。</p><p>​        首先我们来看定义：</p><p>​        <strong>仍对于$f(x)$在区间$I$上连续，如果对任意的$x_1,x_2 \in I (x_1\neq{x_2})$</strong></p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2})<\frac{f(x_1)+f(x_2)}{2}</script><p>​        <strong>我们就称呼$f(x)$在区间$I$上的图像是凹的（上凹）</strong></p><p>​        <strong>类比的：如果：</strong></p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2})>\frac{f(x_1)+f(x_2)}{2}</script><p>​        <strong>那么我们又称呼$f(x)$在区间I上的图像是凸的（下凹的）</strong></p><p><img src="image-20230107152418652.png" alt="image-20230107152418652"></p><p>​        函数$f(x)$如果在$I$上是凹（凸）的，那么$-f(x)$是凸(凹)的。</p><p><img src="image-20230107152556639.png" alt="image-20230107152556639"></p><p>​        我们先前就提到过：函数的凸凹性和函数的二阶导数密切相关，下面我们来一睹定理的芳容：</p><p>​        <strong>设$f(x)$在区间$I$上二阶可导，那么：</strong></p><p>​        <strong>（1）若在$I$上$f’’(x)&gt;0$，那么我们说函数是凹的</strong></p><p>​        <strong>（2）若在$I$上$f’’(x)&lt;0$，那么我们说函数是凹的</strong></p><h4 id="极值及其求法"><a href="#极值及其求法" class="headerlink" title="极值及其求法"></a>极值及其求法</h4><p>​        首先我们需要区分一下极值和最值：</p><p>​        极值：邻域内函数的最大最小值</p><p>​        最值：在全函数的定义域内函数的最大最小值</p><p>下面给出严肃的定义：</p><p>​        定义：$f(x)$在$x_0$的领域$\cup (x_0)$下有定义且连续,$\forall{x}\in\mathring{U}(x_0)$,$f(x)<f(x_0)(或者)(f(x)>f(x_0))$那么我们说$f(x_0)$是函数的极大值 or 极小值。</p><p>​        极值的定理 I:(必要条件)函数可导，且在此点$x_0$的导数 $f’(x_0)=0$</p><p>​        极值的定理 II:(第一充分条件)：$f(x)$在$x_0$处连续,且在$\mathring{U}(x_0)$处可导</p><p>（1）$x \in(x_0-\delta,x_0)$ 且$f’(x)&gt;0$,而$x \in(x_0,x_0+\delta)$ 且$f’(x)&lt;0$我们说函数在此点取上极大值</p><p>（2）$x \in(x_0-\delta,x_0)$ 且$f’(x)&lt;0$,而$x \in(x_0,x_0+\delta)$ 且$f’(x)&gt;0$我们说函数在此点取上极小值</p><p>如果不变号，那就不是极值点。</p><p>​        下面总结流程：</p><p>​        （1）求$f’(x)$</p><p>​        （2）求驻点和不可导点</p><p>​        （3）考察上面这些点的变号情况</p><p>例题：$f(x)=(x-4)\sqrt[3]{(x+1)^2}$的极值点.</p><p>$f’(x)=\frac{5(x-1)}{3\sqrt[3]{x+1}}$令$f’(x)=0$</p><p>得到 $x=1$是驻点，$x=-1$是不可导点</p><p>1)$x=-1$,$x&lt;-1$时，$f’(x)&gt;0$, $x&gt;-1$时，$f’(x)&lt;0$,所以这是一个极大值点</p><p>2）$x=1$,$x<1$时，$f'(x)<0$, $x>-1$时，$f'(x)>0$,所以这是一个极小值点</p><p>当然还有别的判断方式：</p><p>​        定理 II’（第二充分条件）函数$f(x)$二阶可导，$f’(x_0)=0,f’’(x_0)\neq{0}$</p><p>当：</p><p>1)$f’’(x)&lt;0$在$x_0$处取极大值</p><p>2)$f’’(x)&gt;0$,在$x_0$处极小值</p><h4 id="函数图像的绘制"><a href="#函数图像的绘制" class="headerlink" title="函数图像的绘制"></a>函数图像的绘制</h4><p>​        下面我们开始绘制函数的图像！这也是系统分析函数的步骤</p><p>​        1）分析函数的定义域，以及可能的奇偶性，周期性</p><p>​        2)求出一阶导数，二阶导数，和他们等于0的点</p><p>​        3)找出函数的间断点（从定义域得到），以及一阶导数，二阶导数不存在的点</p><p>​        4）由此求出函数的单调性凹凸性</p><p>​        5）看看是否有渐近线（铅锤，水平，斜的渐近线）</p><p>​        6）确定极值（带点）</p><p>例如：$y=x^3-x^2-x+1$</p><p>​        显然函数的定义域为$R$，且无奇偶性，周期性</p><p>​        $f’(x)=3x^2-2x-1,f’’(x)=2(3x-1)$</p><p>​        令$f’(x)=0,x=-\frac{1}{3}或x=1$,当$f’’(x)=0,x=\frac{1}{3}$</p><p>​        确定函数的分间断是：$(-\infty,-\frac{1}{3}),[-\frac{1}{3},\frac{1}{3}],[\frac{1}{3},1],[1,+\infty]$</p><p>​        并且列表时按照如下格式列</p><p>![image-20230107161122390]image-20230107161122390.png)</p><p>补充：函数的渐近线是如下公式确定的：</p><script type="math/tex; mode=display">if :\lim{\frac{f(x)}{x}}=k存在，那就有斜渐近线存在</script><script type="math/tex; mode=display">如果存在:则b=\lim{(f(x)-kx)},直线的方程就是y=kx+b</script><p>至于水平渐近线就是$\lim\limits_{x\rightarrow{\infty}}(f(x)-b)=0$那么就是$y=b$</p><p>铅锤渐近线:$\lim\limits_{x\rightarrow{a}}f(x)\rightarrow\infty$则就是$x=a$</p><h4 id="曲率分析："><a href="#曲率分析：" class="headerlink" title="曲率分析："></a>曲率分析：</h4><p>​        我们使用曲率来分析曲线的弯曲程度：</p><p><img src="image-20230107161834749.png" alt="image-20230107161834749"></p><p>​        这样看</p><p><img src="image-20230107161907141.png" alt="image-20230107161907141"></p><p>​        可以看到，如果$M$移动相同单位，其倾角变化越大，那就称之曲率越大：</p><script type="math/tex; mode=display">\overline{K}=|\frac{\Delta{\alpha}}{\Delta s}|</script><p>​        如果我们让图片里的$M,M’$靠拢，不久类比的得到一个点的曲率了吗 ？（ds是弧微分，后面有图片展示）</p><p>​        </p><script type="math/tex; mode=display">K=\lim\limits_{\Delta s \rightarrow 0}|\frac{\Delta{\alpha}}{\Delta s}|=|\frac{d\alpha}{ds}|</script><p>​        这样：直线的曲率:$K=0$</p><p>​        圆的曲率:$K=\frac{1}{r}$（ r 是圆的半径）</p><p><img src="image-20230107162607705.png" alt="image-20230107162607705"></p><p>​        曲率的公式在直角坐标系的公式可以从定义得到:</p><p>​        $y’=\tan{\alpha}$,$y’’=\sec^2{\alpha}$,于是:</p><script type="math/tex; mode=display">|\frac{d\alpha}{dx}|=\frac{y''}{\sec^2{x}}=\frac{y''}{1+\tan^2{\alpha}}=\frac{y''}{1+y'^2}</script><p>​        而$ds=$$\sqrt{1+y’^2}$</p><p><img src="image-20230107163229852.png" alt="image-20230107163229852"></p><p>​                                                                        弧微分</p><p>​        于是：</p><script type="math/tex; mode=display">|\frac{d\alpha}{ds}|=|\frac{\frac{y''}{1+y'^2}}{\sqrt{1+y'^2}}|=|\frac{y''}{(1+y'^2)^\frac{3}{2}}|</script><p>​        类比的，在参数方程下：</p><p><img src="image-20230107163642181.png" alt="image-20230107163642181"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（1）</title>
      <link href="/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h3 id="认识时间复杂度"><a href="#认识时间复杂度" class="headerlink" title="认识时间复杂度"></a>认识时间复杂度</h3><p>​        我们有一些操作是常数时间完成的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int a &#x3D;arr[i];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为我们直接计算偏移量直接取出的</p><p>​        但是这个不是</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int t&#x3D;list.get(i);&#x2F;&#x2F;链表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为链表必须遍历，才能找到元素</p><p>​        以及加减乘除的操作是常数操作。</p><p>​        总而言之：涉及到数据量的操作都是<strong>非常数操作</strong></p><p>​        举个例子，选择排序：这个排序是一种选择某一个数与前面已经排好的数组开始对比。怎么保证前面的已经有序了呢？我们把算法作用在第一个元素上，这个时候那他与第二个元素排序，成功后就是一个有序小数组，这样就满足了递归的条件：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Part I:C version without recurssion#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;&#x2F;&#x2F;using Choose sort to sort the array&#x2F;&#x2F;rand num getterint getRandNum(int maxRange)&#123;    srand((unsigned int)clock());    Sleep(10);    return rand()% maxRange;&#125;void printCurrentArray(int* array,int arraySize)&#123;    printf(&quot;Current array is shown:\n&quot;);    for(int i&#x3D;0; i&lt;arraySize; i++)    &#123;        printf(&quot;%d &quot;,array[i]);    &#125;    printf(&quot;\n&quot;);&#125;void swapInt(int* e1, int* e2)&#123;    int temp&#x3D;*e1;    *e1&#x3D;*e2;    *e2&#x3D;temp;&#125;int main()&#123;    &#x2F;&#x2F;get a rand array    int arr[10]&#x3D;&#123;0&#125;;    for(int i&#x3D;0; i&lt;10; i++)    &#123;        arr[i]&#x3D; getRandNum(100);    &#125;    &#x2F;&#x2F;Sort starts!    for(int i&#x3D;1; i&lt;10; i++)    &#123;        &#x2F;&#x2F;from the second one        &#x2F;&#x2F;Compared with the previous one and the front one        for(int j&#x3D;i;j&gt;0;j--)        &#123;            &#x2F;&#x2F;If inverted,invert them back            if(arr[j]&lt;arr[j-1])            &#123;                swapInt(&amp;arr[j], &amp;arr[j - 1]);            &#125;        &#125;        &#x2F;&#x2F;Target the Current Key and show:        printf(&quot;Current key is:%d\n&quot;,arr[i]);        printCurrentArray(arr,10);        printf(&quot;Enter the newline to go forward!&quot;);        getchar();    &#125;    printf(&quot;Eventually...\n&quot;);    printCurrentArray(arr,10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Or Recussion type#define _CRT_SECURE_NO_WARNINGS 1#include&lt;windows.h&gt;#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;&#x2F;&#x2F;using Choose sort to sort the array&#x2F;&#x2F;rand num getterint getRandNum(int maxRange)&#123;    srand((unsigned int)clock());    Sleep(10);    return rand() % maxRange;&#125;void printCurrentArray(int* array, int arraySize)&#123;    printf(&quot;Current array is shown:\n&quot;);    for (int i &#x3D; 0; i &lt; arraySize; i++)    &#123;        printf(&quot;%d &quot;, array[i]);    &#125;    printf(&quot;\n&quot;);&#125;void swapInt(int* e1, int* e2)&#123;    int temp &#x3D; *e1;    *e1 &#x3D; *e2;    *e2 &#x3D; temp;&#125;void insertSort(int* array, int arraySize, int cur_sort_place)&#123;    if (cur_sort_place &gt; arraySize-1)        return;    int j &#x3D; cur_sort_place;    while (j &gt; 0)    &#123;        if (array[j] &lt; array[j - 1])            swapInt(&amp;array[j], &amp;array[j - 1]);        j--;    &#125;    choiceSort(array, arraySize, cur_sort_place + 1);&#125;int main()&#123;    int arr[10] &#x3D; &#123; 0 &#125;;    for (int i &#x3D; 0; i &lt; 10; i++)    &#123;        arr[i] &#x3D; getRandNum(100);    &#125;    insertSort(arr, 10, 1);    printCurrentArray(arr, 10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个算法的时间复杂度就是O($N^2$)，这是因为操作表达式的最高阶是$N^2$.</p><p>​        注意到O(N)表达的是表达式的最高此项，是衡量巨大数量下算法的优良度</p><p><img src="image-20230126193633933.png" alt="image-20230126193633933"></p><p>​        当时间复杂度相同时，通过==比较常数项==作出判断是否可靠。更多的时候我们选择直接开跑看看怎么样：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void Process1()&#123;    int N&#x3D;1000;    int a&#x3D;1;    for(int i&#x3D;0 ; i&lt;N; i++)    &#123;        a*&#x3D;10;        a&#x3D;a+10;        a&#x3D;6127*9876;    &#125;&#125;public static void Process2()&#123;     int N&#x3D;1000;    int a&#x3D;1;    for(int i&#x3D;0 ; i&lt;N; i++)    &#123;        a&#x3D;10|1;        a^&#x3D;10;        a&#x3D;a&amp;9876;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对，就是这种。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>​        回顾上面的实例代码：我们使用Java写出另一个版本：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">seletionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minIndex<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            minIndex<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token operator">?</span>j<span class="token operator">:</span>minIndex<span class="token punctuation">;</span><span class="token comment">//直接找到最小的地方</span>        <span class="token punctuation">&#125;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Using in swap minindex with arr[i]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>​        我们也可以使用冒泡排序排数，就像大的泡泡向下沉，小的泡泡向上浮。就好了。值得注意的是，我们换完产生的最值区已经换好了，没有必要再参与排序。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>N<span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>conditions<span class="token punctuation">)</span>            swap data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="交换的离奇写法"><a href="#交换的离奇写法" class="headerlink" title="交换的离奇写法"></a>交换的离奇写法</h3><p>请看这个</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>异或：相同为0，不同为1：</p><p>例如：</p><p>A:1011110101001</p><p>B:1000101011001</p><p>  A^B: 0011011110000                        </p><p>也可以理解为无进位相加：</p><p>性质1：0^N=N,N^N=0</p><p>性质2：满足交换律和结合律</p><p>那这是怎么交换的？</p><p>a=a^b  1)</p><p>b=a^b</p><p>a=a^b</p><p>假设a= A,b=B;</p><p>1)a=A^B b=B</p><p>2)a=A^B,b=(A^B)^B =A^(B^B)=A</p><p>3)a=A^B^A=B b=A</p><p>交换完毕</p><p>但是注意：这样的方法不适用于同一块内存，否则会洗成0.</p><p>例题：1）现在有一个整型数组：里面有诺干出现了偶数次的数和一个出现奇数次的数，找出那个奇数次数的数：</p><p>EG：[2,1,3,1,3,1,3,2,1]——-&gt;3</p><p>Solutions：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int ero&#x3D;0;for(int i&#x3D;0;i&lt;arr.length;i++)&#123;ero^&#x3D;arr[i];&#125;printf(&quot;%d &quot;,ero);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是因为异或顺序无关，偶数次数的全消成了0.于是可以引用在奇偶相关次序无关的题目。</p><p>2）现在有一个整型数组：里面有诺干出现了偶数次的数和两个出现奇数次的数，找出那两个奇数次数的数：</p><p>Ok，当我们依旧沿袭上面的方法的时候，我们发现：eor=a^b,这是因为一切出现了偶数次的异或为0，a和b也最后削成一个a^b。下面怎么办？</p><p>注意到a$\neq$b，这样的话：因为最右边的1是a,b作为二进制的特征数（用它来区分a,b），我们就可以提取出来：int rightOne=eor&amp;(~eor+1)，也就是源码与上补码，提取eor上的第右边的1，随后只与这个位置上是1的数，就得到a或者是b了</p><p>​        <img src="image-20230127113335433.png" alt="image-20230127113335433"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printOddTimeNum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> eor<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        eor<span class="token operator">^</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> rightOne<span class="token operator">=</span>eor<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>eor<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找出来最右边的数</span>    <span class="token keyword">int</span> onlyOne<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//eor'</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token operator">:</span>arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cur<span class="token operator">&amp;</span>rightOne<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//别写1，因为出来的只能是0或者是rightOne，如果想要另一个就!=0;</span>            onlyOne<span class="token operator">^=</span>cur<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>onlyOne<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span><span class="token punctuation">(</span>ero<span class="token operator">^</span>onlyOne<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>​        这个就是最上面的代码，就是相当于插牌。这个算法的表现是波动较大的：O(N)~O($N^2$)。</p><p>​        但是算法的复杂度是看最差情况的，所以是O($N^2$).</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><p>​        注意，这个只使用于有序数组。这个数组使用二分查找是最快的。主要思想：找中间，比大小，挪边界，继续二分。这个算法的复杂度因此是$O(\log n)$.</p><h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h3><p>​        假设我们要进行测试方法A，我们使用随机样本产生器，我们随机的产生数据放到多个方法，他们结果要是不一样，那要不就是A错，要不就是B错，要不就是都错了。这个时候人工干预的方式修改方法。</p><h3 id="递归行为下时间复杂度的计算"><a href="#递归行为下时间复杂度的计算" class="headerlink" title="递归行为下时间复杂度的计算"></a>递归行为下时间复杂度的计算</h3><h4 id="求取中点的方法"><a href="#求取中点的方法" class="headerlink" title="求取中点的方法"></a>求取中点的方法</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int mid&#x3D;L+((R-L)&gt;&gt;1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    为什么这样书写：防止R+L溢出int上限、</p><h4 id="使用递归求解数组最大值："><a href="#使用递归求解数组最大值：" class="headerlink" title="使用递归求解数组最大值："></a>使用递归求解数组最大值：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">L</span><span class="token operator">==</span><span class="token class-name">R</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token class-name">L</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> leftMax<span class="token operator">=</span><span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token class-name">L</span><span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightMax<span class="token operator">=</span><span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">,</span>rightMax<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个写法我们是在二分类是常用的：先处理递归左边，再递归处理右边，最后从小到大的返回各层的最大值，最后得到整体的最大值。下面也有C++版本的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;Windows.h&gt;class Finder &#123;public:int getMax(std::vector&lt;int&gt; s) &#123;return Dofindmax(s, 0, s.size()-1);&#125;int Dofindmax(std::vector&lt;int&gt; s, int left, int right)&#123;if (left &#x3D;&#x3D; right)return s[left];int mid &#x3D; left + ((right - left) &gt;&gt; 1);int leftMax &#x3D; Dofindmax(s, left, mid);int rightMax &#x3D; Dofindmax(s, mid + 1, right);return leftMax &gt; rightMax ? leftMax : rightMax;&#125;&#125;;void PrintVector(std::vector&lt;int&gt; s)&#123;for (std::vector&lt;int&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;std::cout&lt;&lt;std::endl;&#125;int getRandNum()&#123;srand((unsigned int)clock());Sleep(10);return rand() % 100;&#125;int main()&#123;std::vector&lt;int&gt; s;for (int i &#x3D; 0; i &lt; 10; i++)s.push_back(getRandNum());PrintVector(s);Finder f;int t &#x3D; f.getMax(s);std::cout &lt;&lt; t;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，别太常用，因为容易把栈搞炸</p><p><img src="image-20230127160815732.png" alt="image-20230127160815732"></p><p>画个递归树</p><h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><script type="math/tex; mode=display">if:T(N)=a*T(\frac{N}{b})+O(N^d)</script><script type="math/tex; mode=display">then:1)\log_ba>d->T(N^{\log_ba})</script><script type="math/tex; mode=display">2)\log_ba=d->T(N^{d}log N)</script><script type="math/tex; mode=display">3)\log_ba<d->T(N^{d})</script><p>有人话版本吗？有的：就是说我们的一次递归可以拆分一个问题为b个子问题，当然右额外开销$N^d$,这样，我们就有分层级讨论：比较$\log_ba$与d的大小从而一步写出公式。</p><p>以上面为例：上面的问题把问题拆成两个子问题：b=2,并且在单个函数体内调用了两次：a=2,剩下的时间复杂度为O(1).这下，我们的公式就是：</p><script type="math/tex; mode=display">T(N)=2*T(N/2)+O(1)</script><p>这样就直接带入公式:T(N)=O(logn).</p><h3 id="补充Reading"><a href="#补充Reading" class="headerlink" title="补充Reading"></a>补充Reading</h3><p>​        平时设计或者阅读一个算法的时候，必然会提到算法的复杂度（包括时间复杂度和空间复杂度）。比如我们说一个二分查找算法的平均时间复杂度为 O(log n)，快速排序可能是 O(n log n)。那这里的 O 是什么意思？这样的表达是否准确呢？</p><p>​        今天来复习一下与算法复杂度相关的知识：函数渐进阶，记号 O、Ω、θ和 o；Master 定理。</p><p>​        先插一句，在算法复杂度分析中，log 通常表示以 2 为底的对数。</p><p>​        算法复杂度（算法复杂性）是用来衡量算法运行所需要的计算机资源（时间、空间）的量。通常我们利用渐进性态来描述算法的复杂度。</p><p>​        用 n 表示问题的规模，T(n) 表示某个给定算法的复杂度。所谓渐进性态就是令 n→∞ 时，T(n) 中增长最快的那部分。严格的定义是：如果存在 $T’(n)$，当 n→∞ 时，有:</p><script type="math/tex; mode=display">\frac{T(n)-T'(n)}{T(n)}\rightarrow 0</script><p>​        我们就说$T’(n)$是 T(n) 当 n→∞ 时的渐进性态。</p><p>​        比如 T(n) = 2 <em> n ^ 2 + n log n + 3，那么显然它的渐进性态是 2 </em> n ^ 2，因为当 n→∞ 时，后两项的增长速度要慢的多，可以忽略掉。引入渐进性态是为了简化算法复杂度的表达式，只考虑其中的主要因素。当比较两个算法复杂度的时候，如果他们的渐进复杂度的阶不相同，那只需要比较彼此的阶（忽略常数系数）就可以了。</p><p>​        总之，分析算法复杂度的时候，并不用严格演算出一个具体的公式，而是只需要分析当问题规模充分大的时候，复杂度在渐进意义下的阶。记号 O、Ω、θ和 o 可以帮助我们了解函数渐进阶的大小。</p><p>​        假设有两个函数 f(n) 和 g(n)，都是定义在正整数集上的正函数。上述四个记号的含义分别是：</p><ul><li>f(n) = O(g(n))：$∃c&gt;0,n_0∈N,∀n≥n_0,f(n)≤cg(n)$；f 的阶<strong>不高于</strong> g 的阶。</li><li>f(n) = Ω(g(n))：$∃c&gt;0,n_0∈N,∀n≥n_0,f(n)≥cg(n)$；f 的阶<strong>不低于</strong> g 的阶。</li><li>f(n) = θ(g(n))：⟺$f(n)=O(g(n))\&amp;\&amp;f(n)=Ω(g(n))$；f 的阶<strong>等于</strong> g 的阶。</li><li>f(n) = o(g(n))：$∀\varepsilon&gt;0,∃n_0∈N,∀n≥n_0,f(n)/g(n)&lt;\varepsilon$；f 的阶<strong>低于</strong> g 的阶。</li></ul><p>​        可见，记号 O 给出了函数 f(n) 在渐进意义下的上界（但不一定是最小的），相反，记号Ω给出的是下界（不一定是最大的）。如果上界与下界相同，表示 f(n) 和 g(n) 在渐进意义下是同阶的（θ），亦即复杂度一样。</p><p>​        列举一些常见的函数之间的渐进阶的关系：</p><p><img src="image-20230127163435272.png" alt="image-20230127163435272"></p><p>​        有些人可能会把这几个记号跟算法的最坏、最好、平均情况复杂度混淆，它们有区别，也有一定的联系。</p><p>​        即使问题的规模相同，随着输入数据本身属性的不同，算法的处理时间也可能会不同。于是就有了最坏情况、最好情况和平均情况下算法复杂度的区别。它们从不同的角度反映了算法的效率，各有用处，也各有局限。</p><p>​        有时候也可以利用最坏情况、最好情况下算法复杂度来粗略地估计算法的性能。比如某个算法在最坏情况下时间复杂度为θ(n ^ 2)，最好情况下为θ(n)，那这个算法的复杂度一定是 O(n ^ 2)、Ω(n) 的。也就是说 n ^ 2 是该算法复杂度的上界，n 是其下界。</p><p>​        接下来看看 Master 定理。</p><p>​        有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的：</p><p>​        设常数 a &gt;= 1，b &gt; 1，f(n) 为函数，T(n) 为非负整数，T(n) = a T(n / b) + f(n)，则有：</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230127163457999.png" alt="image-20230127163457999"></p><p>​        比如常见的二分查找算法，时间复杂度的递推方程为 T(n) = T(n / 2) + θ(1)，显然有 $n^{\log _b^a}⁡=n^0=Θ(1)$，满足 Master 定理第二条，可以得到其时间复杂度为 T(n) = θ(log n)。</p><p>​        再看一个例子，T(n) = 9 T(n / 3) + n，可知 $n^{\log_b^a}=n^2$，令ε取 1，显然满足 Master 定理第一条，可以得到 T(n) = θ(n ^ 2)。</p><p>​        来一个稍微复杂一点儿例子，T(n) = 3 T(n / 4) + n log n。$n^{\log_b^a}=O(n^{0.793})$，取ε = 0.2，显然当 c = 3 / 4 时，对于充分大的 n 可以满足 a <em> f(n / b) = 3 </em> (n / 4) <em> log(n / 4) &lt;= (3 / 4) </em> n <em> log n = c </em> f(n)，符合 Master 定理第三条，因此求得 T(n) = θ(n log n)。</p><p>​        运用 Master 定理的时候，有一点一定要<strong>特别注意</strong>，就是第一条和第三条中的ε必须<strong>大于零</strong>。如果无法找到大于零的ε，就不能使用这两条规则。</p><p>​        举个例子，T(n) = 2 T(n / 2) + n log n。可知 $n^{\log_b^a}=n$，而 f(n) = n log n，显然不满足 Master 定理第二条。但对于第一条和第三条，也无法找到大于零的ε使得 nlog⁡n=O$(n^{1−\varepsilon})$ 或者Ω$(n^{1−\varepsilon})$，因此不能用 Master 定理求解，只能寻求别的方式求解。比如可以利用递归树求出该算法的复杂度为 $T(n)=O(n\log^2n)$。简单的说一下计算过程：</p><p>​        递归树的建立过程，就像是模拟算法的递推过程。树根对应的是输入的规模为 n 的问题，在递归处理子问题之外，还需要 n log n 的处理时间。然后根据递推公式给根节点添加子节点，每个子节点对应一个子问题。这里需要两个子节点，每个节点处理规模为 n / 2 的问题，分别需要 (n / 2) <em> log(n / 2) 的时间。因此在第二层一共需要 n </em> (log n - 1) 的时间。第三层节点就是将第二层的两个节点继续分裂开，得到四个各需要 (n / 4) <em> log(n / 4) 时间的节点，总的时间消耗为 n </em> (log n - 2)。依此类推，第 k（设树根为 k = 0）层有 2 ^ k 的节点，总的时间为 n * (log n - k)。而且可以知道，这棵树总共有 log n 层（最后一层每个节点只处理规模为 1 的子问题，无须再分治）。最后将每一层消耗的时间累加起来，得到：</p><p><img src="image-20230127163854294.png" alt="image-20230127163854294"></p><h3 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h3><p>​        1）整体就很简单，就是一个简单的递归，左边排好序，右边排好序，然后整体就有序。</p><p>​        2）让其整体有序的方式用了排外序方法</p><p>​        3）继续使用master公式求解:$O(N\log N)$，空间复杂度O(N)</p><p>​        4）归并排序的实质</p><p>思路</p><p><img src="image-20230127164408704.png" alt="image-20230127164408704"></p><p>​        对于一块区域，我们使用指针访问：左右双指针法。开辟一块小空间，如果左边的大于右边的，左边指针拷贝同时指针后移一个，右边大于左边的同理。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Solution&#123;    public static void mergeSort(int[] arr)    &#123;        if(arr&#x3D;&#x3D;null||arr.length&lt;2)            return;        process(arr,0,arr.length-1);    &#125;    public static void process(int[] arr,int L, int R)    &#123;        if(L&#x3D;&#x3D;R)            return;      int mid &#x3D; left + ((right - left) &gt;&gt; 1);        process(arr,L,mid);        process(arr,mid+1,R);        merge(arr,L,mid,R);    &#125;    public static void merge(int[] arr,int L,int M,int R)&#123;        int[] helpSort&#x3D;new int[R-L+1];&#x2F;&#x2F;这是辅助空间        int i&#x3D;0;        int p1&#x3D;L;        int p2&#x3D;M+1;&#x2F;&#x2F;划分区域        while(p1&lt;&#x3D;M&amp;&amp;p2&lt;&#x3D;R)&#123;            helpSort[i++]&#x3D;arr[p1]&lt;&#x3D;arr[p2]?arr[p1++]:arr[p2++];            &#125;        while(p1&lt;&#x3D;M)&#123;           helpSort[i++]&#x3D;arr[p1++];        &#125;        while(p2&lt;&#x3D;R)&#123;            helpSort[i++]&#x3D;arr[p2++];        &#125;        for(i&#x3D;0;i&lt;helpSort.length;i++)&#123;            arr[L+i]&#x3D;helpSort[i];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std; void Merge(int arr[],int low,int mid,int high)&#123;    &#x2F;&#x2F;low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素    int i&#x3D;low,j&#x3D;mid+1,k&#x3D;0; &#x2F;&#x2F;mid+1为第2有序区第1个元素，j指向第1个元素    int *temp&#x3D;new(nothrow) int[high-low+1]; &#x2F;&#x2F;temp数组暂存合并的有序序列    if(!temp)&#123; &#x2F;&#x2F;内存分配失败        cout&lt;&lt;&quot;error&quot;;        return;    &#125;    while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;high)&#123;        if(arr[i]&lt;&#x3D;arr[j]) &#x2F;&#x2F;较小的先存入temp中            temp[k++]&#x3D;arr[i++];        else            temp[k++]&#x3D;arr[j++];    &#125;    while(i&lt;&#x3D;mid)&#x2F;&#x2F;若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中        temp[k++]&#x3D;arr[i++];    while(j&lt;&#x3D;high)&#x2F;&#x2F;同上        temp[k++]&#x3D;arr[j++];    for(i&#x3D;low,k&#x3D;0;i&lt;&#x3D;high;i++,k++)&#x2F;&#x2F;将排好序的存回arr中low到high这区间arr[i]&#x3D;temp[k];    delete []temp;&#x2F;&#x2F;删除指针，由于指向的是数组，必须用delete []&#125; &#x2F;&#x2F;用递归应用二路归并函数实现排序——分治法void MergeSort(int arr[],int low,int high)&#123;    if(low&lt;high)&#123;        int mid&#x3D;(low+high)&#x2F;2;        MergeSort(arr,low,mid);        MergeSort(arr,mid+1,high);        Merge(arr,low,mid,high);    &#125;&#125; int main()&#123;    int a[10]&#x3D;&#123;5,1,9,3,7,4,8,6,2,0&#125;;    MergeSort(a,0,9);    for(int i&#x3D;0;i&lt;10;i++)        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展我们的归并排序问题"><a href="#扩展我们的归并排序问题" class="headerlink" title="扩展我们的归并排序问题"></a>扩展我们的归并排序问题</h3><p>​        小和问题：对一个数组中，每个数左边比当前数小的数累加起来，叫做这个数的小和：请写一个程序：求解一个数组的小和。</p><p>Example:[1,3,4,2,5]产生的单个小和是[0,1,4,1,10],故数组的小和是16.</p><p>​        逆序问题：在一个数组中，左边的数如果比右边的数大，则这连哥哥数构成一个逆序对，请打印所有的逆序对。</p><p>​        （1）暴力解法是很简单的：对于位置i直接暴力遍历，但是$O(N^2)$</p><p>​        有没有更快的：有！</p><p>​        仔细思考一下：我们的小和可以这样产生！看一个数右边走，如果有别的数大于它就加一次这个数本身。如[1,3,4,2,5]：看1，右边四个数比他大，就加四次1，看3，右边两个数比他大，就加两个3，依次类推。。。</p><p>​        现在，我们对全数组进行二分。针对拆分后的数组一级一级使用我们新的求小和的过程，我们在比较的同时也排序：如：[1，3，4，2，5]下，拆分成2级[1,3,4]和[2,5]，然后又是:[1,3] [4]  和[2]  [5]最后是:[1] [3] [4] [2] [5]，现在返回去合并：[1,3]产生小和1，[1,3,4]产生1个1，1个3，（左侧小，左侧加小和，左侧移动指针到下一个，于是产生）[2,5]合并产生一个2，之后再次合并产生一个1，一个3，一个4，现在完事了：1+1+1+3+2+1+3+4=16</p><p>​        这个算法为什么是O(NlogN),就是因为排序的时候不需要在暴力遍历之后才知道有几个数比当前的数小。这才省略了新的遍历。</p><p>​        可能不一样的是：在这题里面，我们必须在左右数字相等的时候先拷贝右边的，再拷贝左边的.</p><p>​        （2）类似的，仍可以使用mergeSort，也就是说，只要产生小和操作就是说明产生了逆序。我们只要统计这个就好了</p><p>​        荷兰国旗问题：指定一个数，比他大的放右边，小的放左边，但是注意空间复杂度O(1)</p><p>​        思路：我们把使用两个指针。把小于num的放到左边，与小于区的下一个数字直接交换就好了。这样小于区右扩，否则指针直接右移。</p><p>​        荷兰国旗问题（2）：指定一个数，比他大的放右边，小的放左边，相等的放中间。但是注意空间复杂度O(1)</p><p>​        </p><p>​        还是类似，只不过有趣的是我们可以：</p><p>​        小于：[i]和小于区域的下一个交换，小于区东扩</p><p>​        相等：直接++</p><p>​        大于：[i]和大于区域的上一个交换，大于区西扩，但是i不动（我们还没排序那个交换过来的数嘞！）。</p><p>看看代码实现（看2就好了）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void swap(int* e1, int* e2)&#123;int temp &#x3D; *e1;*e1 &#x3D; *e2;*e2 &#x3D; temp;&#125;typedef struct Pair_ &#123;int pair1;int pair2;&#125;Pair;void arrangeArray(Pair* pair, int* arr, int arrsize,int sortnum)&#123;if (!pair &amp;&amp; !arr)return;if (arrsize &lt; 0)return;int* smaller &#x3D; &amp;arr[-1];int* bigger &#x3D; &amp;arr[10];int* check &#x3D; arr;while (check &lt; bigger)&#123;if (*check &lt; sortnum)&#123;swap(check, smaller + 1);check++;smaller++;&#125;else if (*check &#x3D;&#x3D; sortnum)&#123;check++;&#125;else&#123;swap(check, bigger - 1);bigger--;&#125;&#125;pair-&gt;pair1 &#x3D; smaller - arr;pair-&gt;pair2 &#x3D; bigger - arr;&#125;void PrintArr(int* arr, int arr_size)&#123;for (int i &#x3D; 0; i &lt; arr_size; i++)&#123;printf(&quot;%d &quot;, arr[i]);&#125;printf(&quot;\n&quot;);&#125;int main()&#123;int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;PrintArr(arr, 10);Pair* p&#x3D;(Pair*)malloc(sizeof(Pair));p-&gt;pair1 &#x3D; 0;p-&gt;pair2 &#x3D; 0;arrangeArray(p, arr, 10, 5);PrintArr(arr, 10);printf(&quot;%d\n&quot;, arr[p-&gt;pair1]);printf(&quot;%d\n&quot;, arr[p-&gt;pair2]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        C++:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;class Array &#123;public:void initVal(int* arr, int size) &#123;int* arrayData &#x3D; new int[size];for (int i &#x3D; 0; i &lt; size; i++)&#123;arrayData[i] &#x3D; arr[i];&#125;arraydata &#x3D; arrayData;arraysize &#x3D; size;&#125;void swapPartialData(int swap1,int swap2)&#123;int temp &#x3D; arraydata[swap1];arraydata[swap1] &#x3D; arraydata[swap2];arraydata[swap2] &#x3D; temp;&#125;void arrangeandSort(int sortnum)&#123;int smaller &#x3D; -1;int bigger &#x3D; arraysize;int check &#x3D; 0;while (check &lt; bigger)&#123;if (arraydata[check] &lt; sortnum)&#123;swapPartialData(check, smaller + 1);check++;smaller++;&#125;else if (arraydata[check] &#x3D;&#x3D; sortnum)&#123;check++;&#125;else&#123;swapPartialData(check, bigger - 1);bigger--;&#125;&#125;&#125;void PrintVal()&#123;for (int i &#x3D; 0; i &lt; arraysize; i++)&#123;std::cout &lt;&lt; arraydata[i] &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl;&#125;private:int* arraydata;int arraysize;&#125;;int main()&#123;int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;Array a;a.initVal(arr, 10);a.PrintVal();a.arrangeandSort(5);a.PrintVal();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>​        快速排序请先把上面的代码琢磨明白：快速排序使得我们以一个数区分好了左右，排除掉标杆数我们只要对左右再次区分直到一个尽头结束。这次我们直接拿最后一个数当作标杆进行快排，这样我们就使得整个数组有序了。</p><p>​        这个思想还可以进一步优化：直接把标杆数（最后一个）直接放到中间，左右再递归。</p><p>​        当然，这个时间复杂度很不稳定：当划分值再中间的时候：</p><script type="math/tex; mode=display">T(n)=2T(\frac{T}{2})+O(N)</script><p>​        但是如果划分值再最左边和最右边：则就是经典排序为O($N^2$)。</p><p>​        我们继续改进：如果我们在一个划分区域随机选一个数，是不是就更多的避免了总是遇到最差情况？是的，这就是随机快速排序。这下，我们就可以</p><p><img src="image-20230130193038830.png" alt="image-20230130193038830"></p><p>​        对所有的情况求时间期望:$O(N\log N)$</p><h3 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h3><p>​        堆在逻辑结构上是一个完全二叉树。也就是说，每个非叶子节点必有左节点。怎么实现呢？我们可以将天然的一维数组视作一棵完全二叉树。</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230131092857709.png" alt="image-20230131092857709"></p><p>我们可以使用这个公式快速找到左孩子的节点下标：(i是当前节点的下标)</p><script type="math/tex; mode=display">I_{left}=2i+1</script><p>类似的：</p><script type="math/tex; mode=display">I_{right}=2i+2</script><p>父节点：</p><script type="math/tex; mode=display">I_{father}=\frac{i-1}{2}</script><p>完全二叉树的高度也可以求解：</p><script type="math/tex; mode=display">H=logN+1</script><p>堆在这个概念上派生：他是一个特殊的完全二叉树。大根堆中其父节点总是大于子节点，比如说</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230131093338557.png" alt="image-20230131093338557"></p><p>类比的：小根堆就是父节点总是小于子节点。怎么创建一个堆呢？</p><p>​        假设：我们有一个干净的数组，现在往数组里放数。现在，标记一下一个heapsize:他描述我们现在已经成型的堆的大小。显然刚开始heapsize一定是0！因为压根数没来呢！随着数进来，如果一个数比父节点大，那就准备交换父节点！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">swap(arr[i],arr[(i-1)&#x2F;2]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果作为上一级的子节点还是比父节点大，那不就是又要交换？是的。这就是一个递归算法。但是如果相等呢？没关系，就停在那里就好了！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//不用担心0位置的问题，因为根节点的父节点还是他自己，取等依旧跳出循环</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">></span>add<span class="token punctuation">[</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>index<span class="token punctuation">,</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        index<span class="token operator">=</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><p>​        这下很容易了：arr[0]就是我们的最大值，返回出去就好了。那如果我们要把它抹掉，然后还是一个大根堆。这又如何？很简单，与最后一个数交换，或者是被覆盖。然后heapsize—.然后，我们让父节点和子节点比较。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index，<span class="token keyword">int</span> heapsize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//得到左孩子下标</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> index<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//一旦left&lt;heapsize那显然我们的当前节点就没有孩子节点了</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>heapsize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//比较两个孩子节点谁大，把大的那个下标给largest</span>        <span class="token keyword">int</span> largest<span class="token operator">=</span>            <span class="token comment">//万一没右孩子嘞？判断一下！</span>            left<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>heapsize            <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            <span class="token operator">?</span> left<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">:</span> left <span class="token punctuation">;</span>        <span class="token comment">//父亲和孩子之间谁大？谁大把谁的下表交给largest</span>        largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>        <span class="token comment">//如果到位了，退出循环！</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span> largest<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//反之，交换，继续跑路</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>largest<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        index<span class="token operator">=</span>largest<span class="token punctuation">;</span>        left <span class="token operator">=</span> index<span class="token operator">*</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        OK，现在我们的用户又抽风了，现在它随即指定一个节点变成?，那怎么怎么让他成为一个新的堆？很简单！如果变大了，只能往上走，就像上heapify,变小了那就是向下走。</p><p>​        算法复杂度如何？我们发现他就是遍历了树的高度：也就是说</p><script type="math/tex; mode=display">T(N)=O(\log N)</script><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>​        现在我们拿到一个数组，想要进行堆排序，就首先需要构建堆。使用heapInsert就好了。然后怎么排序？我们想到，heap总是确定最大值，只需要：最大值和最后一个值交换，在heapsize—再堆排序。这是一个逐步弹出最大值的算法排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Array</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> heapsize<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">--</span>heapsize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>heapSize<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">--</span>heapsize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            这个算法：空间复杂度:O(1) 时间复杂度: O(nlogn)</p><p>下面是C++版本：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Array &#123;public:void Updatearray(int* arr, int size) &#123;int* trans &#x3D; new int[size];for (int i &#x3D; 0; i &lt; size; i++) &#123;trans[i] &#x3D; arr[i];&#125;this-&gt;array &#x3D; trans;this-&gt;arraysize &#x3D; size;&#125;void swap(int i1, int i2) &#123;int temp &#x3D; array[i1];array[i1] &#x3D; array[i2];array[i2] &#x3D; temp;&#125;int* getArrayDataPointer() &#123;return this-&gt;array;&#125;int getsize()&#123;return this-&gt;arraysize;&#125;void printArray() &#123;for (int i &#x3D; 0; i &lt; arraysize; i++)&#123;std::cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl;&#125;private:int* array;int arraysize;&#125;;class heapSort &#123;public:void heapInsert(Array a, int index) &#123;while (            a.getArrayDataPointer()[index]             &gt;             a.getArrayDataPointer()[(index - 1) &#x2F; 2]              )         &#123;a.swap(index, (index - 1) &#x2F; 2);index &#x3D; (index - 1) &#x2F; 2;&#125;&#125;void heapify(Array a, int index, int heapsize) &#123;int left &#x3D; 2 * index + 1;while (left &lt; heapsize) &#123;int largest &#x3D;left + 1 &lt; heapsize&amp;&amp;a.getArrayDataPointer()[left + 1] &gt; a.getArrayDataPointer()[left]? left + 1 : left;largest &#x3D; a.getArrayDataPointer()[largest] &gt; a.getArrayDataPointer()[index] ? largest : index;if (index &#x3D;&#x3D; largest)&#123;break;&#125;a.swap(largest, index);index &#x3D; largest;left &#x3D; index * 2 + 1;&#125;&#125;void heapsort(Array a) &#123;if (a.getArrayDataPointer() &#x3D;&#x3D; NULL || a.getsize() &lt; 2)&#123;return;&#125;for (int i &#x3D; 0; i &lt; a.getsize(); i++)heapInsert(a, i);int heapsize &#x3D; a.getsize();a.swap(0, --heapsize);while (heapsize &gt; 0) &#123;heapify(a, 0, heapsize);a.swap(0, --heapsize);&#125;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于几乎排好序的（向我保证在-K~K内有序）数组，我们可以使用小根堆来排序，把小数往前弹就可以了。</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>​        这个算法跟之前的不一样，之前的算法都是基于比较的排序算法，现在介绍一个更逆天的算法：计数排序。这个算法的局限性极大：就是必须为整形，同时空间复杂度为O(N)，这样，我们得知了一个数据范围[K1,K2]，我们创造一个大小为[k2-k1+1]的数组，遇到一个数就在这个数对应的位置上+1，使用位置来衡量这个值的大小。随后，根据值来覆写数组。比如说统计到1的个数10，那就在数组里写10个1.但是，一旦数据量大起来就是寄！</p><p>​        现在，引入一个全新的算法：基数算法：我们首先确定数据的最大几位，对其他数字补齐0操作：如[72,100]-&gt;[072,100]就好了。然后基于个位数，创造10个桶。个位数是0的去0，1去1.。。以此类推，然后，从小到大导倒出来，随后比十位，再百位。。。以此类推</p><p>​        比如说：[17,13,25,100,72]-&gt;[ 017 , 013 , 025 , 100 , 072 ],然后个位入桶。再导出来</p><p><img src="image-20230131115105002.png" alt="image-20230131115105002"></p><p>然后把这个数组再倒入桶，这次按十位数</p><p><img src="image-20230131115241365.png" alt="image-20230131115241365"></p><p>然后把这个数组再倒入桶，这次按百位数</p><p><img src="image-20230131115325430.png" alt="image-20230131115325430"></p><p>倒出来，排好序了</p><p><img src="image-20230131115343881.png" alt="image-20230131115343881"></p><p>本质上，我们是按照位数排序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> _RadixSort<span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token function">radixsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">maxbits</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>       <span class="token comment">//这个函数的本质是求解digit 表示最大的数有几个十进制位数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">maxbits</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> max<span class="token operator">=</span><span class="token class-name">Interger</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            max<span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>max<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            max<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">//digit 表示最大的数有几个十进制位数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">,</span><span class="token keyword">int</span> digit<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> radix<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//准备空间</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>d<span class="token operator">&lt;=</span>digit<span class="token punctuation">;</span>d<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token comment">//有多少位就进出多少次，从个位起步</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count <span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>radix<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//这个代码统计数字频率，改进后则是统计小于等于该位置数的个数</span>             <span class="token comment">//这个count[i]表示小于等于i有count[i]个，数组代替了队列使得我们保证了后进后出</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token class-name">L</span><span class="token punctuation">,</span>i<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                j<span class="token operator">=</span><span class="token function">getDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>                count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>radix<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//改进count</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>count<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token class-name">L</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//取出位数</span>            j<span class="token operator">=</span><span class="token function">getDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//放到辅助数组</span>             bucket<span class="token punctuation">[</span>count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">//我们放置一个,就在频数上减一</span>            count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//出桶</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token class-name">L</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">/</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>d<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Pycharm</title>
      <link href="/2023/01/29/Opencv-in-Pycharm/"/>
      <url>/2023/01/29/Opencv-in-Pycharm/</url>
      
        <content type="html"><![CDATA[<h1 id="Pycharm下的opencv使用1：基本图像操作导论"><a href="#Pycharm下的opencv使用1：基本图像操作导论" class="headerlink" title="Pycharm下的opencv使用1：基本图像操作导论"></a>Pycharm下的opencv使用1：基本图像操作导论</h1><h3 id="在Pycharm中导入opencv"><a href="#在Pycharm中导入opencv" class="headerlink" title="在Pycharm中导入opencv"></a>在Pycharm中导入opencv</h3><p>​        笔者被C++实现的opencv干到心态炸裂了，所以这里先整一篇基于python的opencv的博客。</p><p>​        在pycharm中导入opencv很容易：只需要在Project的setting里给解释器安装上opencv-python库就好了。使用这个程序跑一下看看可不可以读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#向工程文件下新建一个img文件夹,放好你的图片，我这里放的是test.png</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230129194508512.png" alt="image-20230129194508512"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2img_path<span class="token operator">=</span><span class="token string">"img/test.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Test img can be shown below!"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        跳出这个即为成功！开始你的opencv的欢乐时间！</p><p><img src="image-20230129194919800.png" alt="image-20230129194919800"></p><h3 id="计算机眼中的图片"><a href="#计算机眼中的图片" class="headerlink" title="计算机眼中的图片"></a>计算机眼中的图片</h3><p>​        在计算机眼中，图像由矩阵构成</p><p><img src="image-20230115212443109.png" alt="image-20230115212443109"></p><p>​        </p><p>​        数值的大小表明了图像的亮度，而通道表明了一个颜色：一个R通道上的255表明这是在Red上很亮</p><p>​        下面，我们来介绍一下我们应该怎么读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment">#不同于RGB，我们读取的格式是BGR</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#caution:the input should be the addr of the img</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取的结果是：一个nd array</p><p>好抽象：可不可以直接展示图片啊：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们试一下这个：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> showimg <span class="token keyword">as</span> simg<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'1.png'</span><span class="token punctuation">)</span>simg<span class="token punctuation">.</span>imgshow<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以封装一个函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cv_show</span><span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span>     cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以查看一个图片的大小：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>shape<span class="token comment">#(175, 286, 3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以设置读入的方式：比如说读入灰度图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span>，cv2<span class="token punctuation">.</span>IMREAD_GREYSCALE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存我们产出的图像</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">'savedfilename'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 可以计算像素点的个数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>​        视频由图像组成，也就是说，我们可以读取视频：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">vc<span class="token operator">=</span>cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">'videofilepath'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们是不是读取成功了？这个看如下的代码判断：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> vc<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">open</span><span class="token punctuation">.</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token builtin">open</span><span class="token operator">=</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们来运行的读取视频</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> <span class="token builtin">open</span><span class="token punctuation">:</span>ret<span class="token punctuation">,</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> frame <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">if</span> ret<span class="token operator">==</span><span class="token boolean">True</span><span class="token punctuation">:</span>        gray<span class="token operator">=</span>cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>frame<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">,</span>gray<span class="token punctuation">)</span>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token operator">==</span><span class="token number">27</span><span class="token punctuation">:</span><span class="token comment">#按下ESC退出或者视频播放完毕</span>            <span class="token keyword">break</span>vc<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="截取部分图片（ROI）"><a href="#截取部分图片（ROI）" class="headerlink" title="截取部分图片（ROI）"></a>截取部分图片（ROI）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imgread<span class="token punctuation">(</span><span class="token string">'Path'</span><span class="token punctuation">)</span>cat<span class="token operator">=</span>img<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">]</span>cv_show<span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span>cat<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样我们就利用切片截取了部分图片了.</p><h3 id="颜色通道提取"><a href="#颜色通道提取" class="headerlink" title="颜色通道提取"></a>颜色通道提取</h3><p>我们可以分离图片，通过不同的颜色通道提取：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token operator">=</span>cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是效果：1，2，3分别代表b,g,r</p><p><img src="2.png" alt="2"> </p><p>1:</p><p><img src="b.png" alt="b"></p><p>2:</p><p><img src="g.png" alt="g"></p><p>3:<img src="r.png" alt="r"></p><p>当然也可以合回去：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以单独保留，直接修改：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#只保留R</span>cur_img<span class="token operator">=</span>img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span>cur_img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><p>我们可以扩充图像，通过一些方式来对图像进行扩充：请看这里：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token comment">#定位点</span>replicate<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REPLICATE<span class="token punctuation">)</span>reflect<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT<span class="token punctuation">)</span>reflect101<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT_101<span class="token punctuation">)</span>wrap<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_WRAP<span class="token punctuation">)</span>constant<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span>value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们得到了五张图像，随后，我们使用imwrite输出图像，同时导入matplotlib的pyplot子库进行观察：</p><p>​        这是总的效果：</p><p><img src="matplot_version.png" alt="matplot_version"></p><p>​         仔细观察：</p><p><img src="replicate.png" alt="replicate"></p><p><img src="reflect.png" alt="reflect"></p><p><img src="reflect101.png" alt="reflect101"></p><p><img src="wrap.png" alt="wrap"></p><p><img src="constant.png" alt="constant"></p><p>​        第一张图是展示了</p><p>​        replicate：这个单词是复制的意思：直接复制最边缘的像素</p><p>​        reflect：对感兴趣的部分进行两边复制：fedcba|abcdef|fedcba</p><p>​        reflect101:但是是对最边缘的像素为对称轴进行复制:gfedcba|abcdefgh|gfedcba</p><p>​        wrap:外包装：cdefgh|abcdefgh|abcdefg</p><p>​        constant:对图像以默认黑值填充</p><h3 id="对图像进行数值操作"><a href="#对图像进行数值操作" class="headerlink" title="对图像进行数值操作"></a>对图像进行数值操作</h3><p>​        我们可以对numpy进广播操作。人话翻译成C++就是cv2库重载了运算符号，使之我们可以对矩阵进行广义的加法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'cat.jpg'</span><span class="token punctuation">)</span>img_cat_GeneralAdd<span class="token operator">=</span>img_cat<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>img_cat<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>img_cat2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        在控制台上输出就可以发现矩阵里每一个数值都加上了一个10。</p><p><img src="image-20230129191422226.png" alt="image-20230129191422226"></p><p>​        （懒得自己跑，截个图）</p><p>​        那可不可以狭义相加呢？当然可以，结合线性代数的常识，相加的矩阵必须满足大小完全一致。假设我们已经满足了这个前提，直接相加得到的结果是不是就是放到矩阵的值呢？</p><p>​        显然不是！因为RGB有界，不可以超过255.在重载的+中，矩阵的RGB值自动%256，就是除以2256取它的余数放到矩阵里。那还有别的加法吗？有：使用方法add，传入cv2.add(img_cat,img_cat2)就可以了，达到255之后就不会取模，只会停在255不动</p><h3 id="图像叠加"><a href="#图像叠加" class="headerlink" title="图像叠加"></a>图像叠加</h3><p>​        我们也可以对图像进行叠加。但是注意，我们首先要调整图像大小一致：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token punctuation">.</span>shapeimg_dog<span class="token operator">=</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token comment"># path是路径</span>img_dog<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_dog<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token operator">*</span>size required to resize<span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230129192417117.png" alt="image-20230129192417117"></p><p>​        同样的还有其他resize方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">required_pic<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_required_resize<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>fx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>fy<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是个什么玩意呢？指的是我们依照某个点把图像在X轴上拉长3倍数，Y轴不变。</p><p>​        现在，我们使用addWeighted来叠加图像，以混合图片特征。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res<span class="token operator">=</span>cv2<span class="token punctuation">.</span>addWeighted<span class="token punctuation">(</span>img_cat<span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">,</span>img_dog<span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#img_cat*0.4+img_dog*0.6+0//最后一项是亮度提升</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h3><p>​        我们可以使用一些参数，对图像进行有条件的处理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ret<span class="token punctuation">,</span>dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>src<span class="token punctuation">,</span>thresh<span class="token punctuation">,</span>maxval<span class="token punctuation">,</span><span class="token builtin">type</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>src:输入，只能输入单通道图像，通常是灰度图</p><p>dst：输出图</p><p>thresh:执行阈值</p><p>maxval:超过或小于阈值后所赋予的值</p><p>type:方法，如下：</p><p>1.cv2.THRESH_BINARY：超过阈值的取maxval,否则取0</p><p>2.cv2.THRESH_BINARY_INV反过来</p><p>3.THRESH_TRUNC大于阈值的设置成阈值</p><p>4.THRESH_TOZERO大于阈值的不变，否则设置成0</p><p>5.THRESH_TOZERO_INV反转</p><p>我们依旧使用matplotlib的pyplot库放送一下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'2.png'</span><span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY_INV<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh3<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TRUNC<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh4<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh5<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO_INV<span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original Image'</span><span class="token punctuation">,</span><span class="token string">'BINARY'</span><span class="token punctuation">,</span><span class="token string">'BINARY_INV'</span><span class="token punctuation">,</span><span class="token string">'THRESH_TRUNC'</span><span class="token punctuation">,</span><span class="token string">'TOZERO'</span><span class="token punctuation">,</span><span class="token string">'TOZERO_INV'</span><span class="token punctuation">]</span>images<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>thresh1<span class="token punctuation">,</span>thresh2<span class="token punctuation">,</span>thresh3<span class="token punctuation">,</span>thresh4<span class="token punctuation">,</span>thresh5<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看：</p><p><img src="Figure_1.png" alt="Figure_1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（1）</title>
      <link href="/2023/01/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学教程笔记1"><a href="#高等数学教程笔记1" class="headerlink" title="高等数学教程笔记1"></a>高等数学教程笔记1</h1><h2 id="极限运算与函数分析基础"><a href="#极限运算与函数分析基础" class="headerlink" title="极限运算与函数分析基础"></a>极限运算与函数分析基础</h2><h4 id="函数与极限"><a href="#函数与极限" class="headerlink" title="函数与极限"></a>函数与极限</h4><p>函数部分主要是奠基于高中的一些基础，这里做一些简单的复习</p><p>1.映射与函数</p><p>首先来了解以下映射：4</p><p>​        先定义X，Y是两个非空集合。现在有一个法则f，使得X中的每个元素$x$（$X$={$x_0$,$x_1$,$x_2$,…}）,都有<strong>唯一</strong>的y($Y$={$y_0$,$y_1$,$y_2$,$y_3$,…})与之对应。那么，我们称f是一个<strong>映射</strong>。</p><p>​        也就是说，这个定义是围绕f的。他是一个这样的法则（或者说规则）让两个非空的集合建立起如定义所言的联系，仅此而已。</p><p>​        也不必太过担心，映射在这本笔记里大概不会再次出现了。</p><p>不过，我们把它引出来必有我们的目的：回过头来，我们实际上用一大长串定义干了这样一件事：</p><script type="math/tex; mode=display">{X}\xrightarrow{f}Y</script><p>现在，让我们开始取其名字：</p><p>X：是一个定义域，有写法D,或者写法更明确一些：$D_f$</p><p>实际上这是Domain的意思</p><p>Y：是一个值域，有写法R,或者同样更明确一些：$R_f$</p><p>实际上这是Range的意思。</p><p>至于：f，我们刚刚讲过了，这就是一个法则，表明一种对应关系。</p><p>依然有这样的更简单的写法：</p><script type="math/tex; mode=display">X\xrightarrow{f}R_f</script><p>重复一些以下的要点：</p><p>（1）上述定义阐述了三要素：X（定义域），f(法则)，Rf(对应值域)</p><p>（2）对于x属于X这回事，对应的y是唯一的。不可以又对应y1同时对应y2.</p><p>Q:可以多个x对应一个y吗？可以！事实上，用图片表示是这样的：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221226141035208.png" alt="image-20221226141035208"></p><p>（3）Rf属于Y，但不是Y！！！但特别的：当Rf=Y下，我们又称这样厉害的f叫满射。</p><p>（4）在众多的映射中，还有一种特殊的映射：单射。人话就是一一对应</p><p>（5）那么，又是单射又是满射如何？这又有名字：一一映射（一夫一妻）因为必须全部对应且一一对应。</p><p>正过来叫映射，倒过来又如何？</p><p>设 f有如下关系：</p><script type="math/tex; mode=display">X\longrightarrow{Y}</script><p>是一个单射，那么，我们可以倒过来：对于Y属于Rf而言都有唯一的一个$x$属于$X$.这又是一组对应关系，不过是倒过来的。记作如下：</p><script type="math/tex; mode=display">g:R_f\longrightarrow{X}</script><p>这样看不出什么联系，我们采用与 f 相关的表示：</p><script type="math/tex; mode=display">f^-1:D_{f^-1}\longrightarrow{D_f}</script><p>好吧，太复杂了，好好回味一下，我们继续折磨：</p><p>现在我们来看这样一个内容：</p><p>在学习完映射之后，我们来看这样的一个D(定义域),且</p><script type="math/tex; mode=display">D\subset{R}</script><p>换而言之，这个数集是R里的一部分，而f是一个使得：</p><script type="math/tex; mode=display">f:D\longrightarrow{R}</script><p>的映射。</p><p>那么，这样来看我们构造了一个映射使得一个实数集映射到了另一个实数集上。这样的映射有一个大家熟悉的名字：函数，简记作：</p><script type="math/tex; mode=display">y=f(x),x\in{D}</script><p>这下看懂了：</p><p>x是一个自变量，y是一个因变量 ，定义域为D，值域是R（不是实数集的R！！！）</p><p>构成一个函数的两要素，就可以从动态的角度来看了，这使得我们信息的表达可以更为浓缩：$D_f$ ,$ f$ 就可以了</p><p>函数的表达有三种：表格法，图形法，解析法。这个是大家高中就已经熟知的了</p><p>说完了定义和表示，我们来看一个函数最广泛的几个性质：</p><h4 id="1-有界性"><a href="#1-有界性" class="headerlink" title="1.有界性"></a>1.有界性</h4><p>听名字就知道：表明的是一些函数可能是有界限的。但这样的表达不规范。</p><p>仔细思考，函数的界限分为两种：不大于一个数和不小于一个数（当然，也可以说是小于一个数或者是大于一个数）</p><p>那么，我们说：对于总是一个小于一个数或者是不大于一个数的函数，我们说他有上界。表达是这样的：</p><script type="math/tex; mode=display">\exists{k_1},f(x)\leqslant{k_1}</script><p>这是什么东西呢？先别急，它还有另一个符号，也是在数学中相当常见的：$\exists$ , $\forall$</p><p>上面的两个符号，一个表示：存在；另一个表示任意。</p><p>那么，上界是唯一的吗？不是的。比如说：</p><script type="math/tex; mode=display">f(x)=x , x\in{(-\infty,1]}</script><p>这就有无穷个上界：可以是1，可以是2，可以是$\pi$…总而言之，并不唯一。</p><p>那么与之对应的，还会有一个下界：</p><script type="math/tex; mode=display">\exists{k_2} ,f(x)\geqslant{k_2}</script><p>我们说：对于总是一个大于一个数或者是不小于一个数的函数，我们说他有下界。</p><p>同样的，下界也不唯一。</p><p>这在我们后面证明极限的存在时是很有必要的！！！</p><p>统称起来，我们就可以说：函数是有界的：上下界都有！总而言之，这种情况称为有界的。反之，一个函数若是既没有上界有没有下界，或者是只有上界，或者是只有下界，则称这个函数无界。用数学符号定义有界是这样的：</p><script type="math/tex; mode=display">\exists M>0,|f(x)|\leqslant{M}</script><p>那么，无界的是这样定义的：</p><script type="math/tex; mode=display">\forall{M}>0,\exists x_1\in{x},|f(x)|>M</script><h4 id="2-单调性"><a href="#2-单调性" class="headerlink" title="2.单调性"></a>2.单调性</h4><p>这个性质是讨论函数的变化趋势的：是增加还是减少？我们用这个性质衡量：</p><p>当在一个区间里：</p><script type="math/tex; mode=display">x_1<x_2,f(x_1)<f(x_2)</script><p>这样的性质叫单调递增，</p><p>反之：</p><script type="math/tex; mode=display">x_1 < x_2,f( x_1 )>f( x_2 )</script><p>这样的性质叫单调递减，但是注意，这称之为严格单调，后面我们会讲述什么是严格单调什么是广义单调的。</p><h4 id="3-奇偶性"><a href="#3-奇偶性" class="headerlink" title="3.奇偶性"></a>3.奇偶性</h4><p>首先声明一点：我们的函数的定义域必须对称：也就是说：函数的$D_f$必须关于原点对称：</p><p>实数域$R$是对称的，$[-1,1]$是对称的，以此类推。当：$f(x)=f(-x)$时，我们称呼这样的函数是一个偶函数，反之：$f(-x)=-f(x)$或者$-f(-x)=f(x)$ 则称之为奇函数。</p><p>有趣的是：在图像法表达函数时：奇函数关于原点对称，偶函数关于$y$轴对称。</p><h4 id="4-周期性"><a href="#4-周期性" class="headerlink" title="4.周期性"></a>4.周期性</h4><p>有一些函数很有意思，伴随$x$的增大，我们甚至可以看到$f(x)$会有周期的重现。这时候，我们说这个函数具有周期性，用数学语言的表达是如下的：</p><script type="math/tex; mode=display">\exists l>0 , f(x+l)=f(x)</script><p>这个$l$就是周期，同时，我们讨论的周期常常是最小正周期。</p><p>比如说：</p><script type="math/tex; mode=display">y=\sin(x)</script><p>这个函数的（最小正）周期就是2$\pi$。</p><p>但是，不是所有的函数都有最小的正周期。如</p><script type="math/tex; mode=display">D(x)=\begin{cases}1 &  x\in{Q}\\ 0 & x\in{Q^C} \\\end{cases}</script><h4 id="5-反函数"><a href="#5-反函数" class="headerlink" title="5.反函数"></a>5.反函数</h4><p>有点像逆映射的感觉了：</p><p>设$f:D\rightarrow{f(D)}$是一个单射，且$f$单调 则有$f^-1:f(D)\rightarrow{D}$ ，且$f^-1$单调，单调性跟 $f$一致</p><p>那么称$x=f^-1(y)$ 是$y=f(x)$的反函数，且这两个函数的图像是关于$y=x$对称的</p><h4 id="6-复合函数"><a href="#6-复合函数" class="headerlink" title="6.复合函数"></a>6.复合函数</h4><p>引入两个函数：$y=f(t) , t=g(x)$ ,把$t$换成$g(x)$，我们就得到了一个复合函数$f(g(x))$。</p><p>值得注意的是：我们如此操作是把 $t =g(x)$视作了一个自变量， $t$的取值范围（f(x)的自变量范围）由我们的$g(x)$决定了，这就是$g(x)$的值域决定了$f(x)$的定义域， 于是，复合函数想要有定义，其$g(x)$的值域必须在$f(x)$的定义域内部才可以。</p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>下面引入两个函数：$f(x),g(x)$ 其中：其定义域以次为$D_f,D_g$ ，产生的新函数的定义域为$D=D_f\cap{D_g}$</p><p>函数的和差：</p><script type="math/tex; mode=display">(f\pm{g})(x)=f(x)\pm{g(x)}</script><p>函数的乘积：</p><script type="math/tex; mode=display">(f\cdot{g})(x)=f(x)\cdot{g(x)}</script><p>函数的相除：</p><script type="math/tex; mode=display">(\frac{f}{g})(x)=\frac{f(x)}{g(x)}, g(x)\neq0</script><h4 id="常见的初等函数"><a href="#常见的初等函数" class="headerlink" title="常见的初等函数"></a>常见的初等函数</h4><p>幂函数：$y=a^{\mu}$</p><p>指数函数:$y=a^x$</p><p>对数函数$y=log_a{x}$, 当$a=e$时，记作：$y=e^x$</p><p>特别的：当$a=e$时，又记成$y=\ln(x)$，当$a=10$时，又记成 $y=\lg(x)$.</p><p>三角函数：$\sin(x)$</p><p>反三角函数:$\arcsin(x)$</p><p>所有的这些函数经过有限次数的组合，运算得到的函数都是初等函数。</p><h2 id="极限定义与使用"><a href="#极限定义与使用" class="headerlink" title="极限定义与使用"></a>极限定义与使用</h2><h4 id="数列的极限的定义"><a href="#数列的极限的定义" class="headerlink" title="数列的极限的定义"></a>数列的极限的定义</h4><p>​            数列可以简单的理解为一列数：按照一定的规律排放：{$x_1,x_2,x_3,x_4,x_5…$}，我们简记作：$\{x_n\}$（注意到N是无穷大的）,比如说：</p><p>​                                                        $\{\frac{1}{2^n}\}$:$\{\frac{1}{2},\frac{1}{4},\frac{1}{8},\frac{1}{16}…\}$</p><p>其中，我们单取出来一项：这是数列的一个项。对于$\frac{1}{2^n}$这个东西，则我们叫做一般项：因为我们可以通过带入N的值来求得第N项的值来。</p><p>​        再来看一些数列：</p><p>​                                            $\{\frac{1}{n}\}$:{1,$\frac{1}{2},\frac{1}{3},\frac{1}{4},\frac{1}{5},\frac{1}{6},\frac{1}{7}$…}</p><p>​        这些数列似乎都随着N的增大逼近一个数，比如说，上面的这些数列都在$N\rightarrow\infty$下，{$x_n$}都在逼近一个数，比如和上面两个都在向0逼近。</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221227094255924.png" alt="image-20221227094255924"></p><p>​        这是$\{\frac{1}{n}\}$在数轴上的表示：当N越来越大下，数代表的点越来越靠近0代表的点。</p><p>我们称数列随着$N\rightarrow\infty$下，逼近的那一个数称之为这个数列的极限。</p><p>​        大概如此，所以我们来看看数学分析下定义的极限：</p><p>​        定义：$\{x_n\}$作为一个数列，$\forall \varepsilon&gt;0$，总$\exists{N},$当$n&gt;N$下，$|x_n-a|&lt;\varepsilon$</p><p>​        好吧，看一脸懵逼。那这个是什么意思呢？为什么引出这个抽象的定义？</p><p>​        注意到：$\forall \varepsilon&gt;0$ :这个是表明任意的一个$ \varepsilon$，只要它大于0都算，都要让上面的式子成立。</p><p>​        这就是说，我的$ \varepsilon$可以取得任意的小，多小都得行！，而$\exists{N},$表明了存在数列的一个项：使得在之后的项（这在$n&gt;N$已经说明白了）都与一个数a的差的绝对值（嘛，就是之后的项与这个数a的距离）为任意小。还不是相等，是一个动态的过程，因为如同</p><p>$\{\frac{1}{n}\}$中$n=10000000000000$一样，只是$x_n=\frac{1}{10000000000000}$罢了，但绝对不是0！但是，伴随这N取的越来越大，我们的{$x_n$}会越来越逼近0的。这描述的是一个动态的过程。</p><p>下面我们来引入一道经典例题：</p><p>​                                                            $2,\frac{1}{2},\frac{4}{3},\frac{3}{4}…\frac{n+(-1)^{n-1}}{n}$</p><p>​        这个数列的极限如何？</p><p>​        首先分析以下大通项：$\frac{n+(-1)^{n-1}}{n}$，它可以做出分离：$1+\frac{(-1)^{n-1}}{n}$ 注意到$(-1)^{n-1}$是一个震荡的数，在-1与1之间震荡，如果看作是一个函数的话，他是有界的，而$\frac{1}{n}$或者是$-\frac{1}{n}$无论如何都会随N增大而趋向于0.那么，这个数列的极限很明了了：</p><p>​    那我们使用数列的极限来证明：</p><p>​    $证明：$</p><p>​    $    因为 |x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}$</p><p>​    $于是\forall \varepsilon&gt;0,取{N=[\frac{1}{n}]+1}, 此时|x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}&lt;\varepsilon$</p><p>​    于是数列的极限是1.</p><p>​    我们再来看一个例题：</p><p>​    证明：$x_n=\frac{(-1)^n}{(n+1)^2}$的极限是0：</p><p>​    这是好说的：我们照猫画虎：</p><p>​    $证明：$</p><p>​    $    因为：|x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}$</p><p>​    $于是\forall \varepsilon&gt;0，取N=[\frac{1}{\sqrt{ \varepsilon}}]+1,此时有 |x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}&lt;\varepsilon$</p><p>​    于是数列的极限为0.</p><p>​    收敛数列的性质：</p><p>​    我们讨论一个收敛数列，是要关注他有什么特性的：</p><p>​    显然：</p><p>（1）收敛数列的极限唯一。</p><p>​    不太好证，所以我们来引入反证法：</p><p>​    证明：假设$x_n\rightarrow{a}同时x_n\rightarrow{b}$ ($a\neq{b}$),我们取$\varepsilon=\frac{b-a}{2}$（1）,</p><p>​    $于是：\exists{N_1},当n&gt;N_1下 |x_n-a|&lt;\frac{b-a}{2}$（2）</p><p>​    同时，又有$\exists{N_2},当n&gt;N_2下 |x_n-b|&lt;\frac{b-a}{2}$</p><p>​    这个时候，我们处理一下上面的式子：（展开我们的绝对值写成不等式）</p><p>​    此时由（1）得到的是：$x_n&lt;\frac{a+b}{2}$</p><p>​    由（2）得到的是：$x_n&gt;\frac{a+b}{2}$</p><p>​    毫无疑问这是矛盾的。所以，我们的极限不可以同时趋近于两个数。</p><p>​    （2）收敛数列一定有界。</p><p>​    证明：设$\lim\limits_{n\to+\infty}{x_n}=a$，此时此刻，我们可以随意的取一个$\varepsilon=1,\exists {N},当n&gt;N下，|x_n-a|&lt;1$</p><p>​    这个时候：</p><p>​    $    |x_n|=|x_n-a+a|\leqslant|x_n-a|+|a|&lt;1+|a|$</p><p>​        这显然符合有界的定义。但是呢？这是保证了$x&gt;N$的形况下，这个时候，我们只需要取出$M=max\{x_1,x_2,…x_N,1+|a|\}$（取出前N个里中最大的与1+$|a|$中还要大的那个，此时，M就是$\{x_n\}$下最大的一项了），这下子：$x_n\leqslant{M}$肯定有界了</p><p>（3）收敛数列具有保号性</p><p>​        这是什么意思呢？就是说：如果一个数列的极限为正（为负），那么，我们的数列在某一项之后肯定都是正的（负的）</p><p>​        数学的表达是这样的：</p><p>​        $\lim\limits_{n\to+\infty}{x_n}=a$,且$a&gt;0$，$\exists{N},$当$n&gt;N下,x_n&gt;0$</p><p>证明：</p><p>​        $a&gt;0$时，取$\varepsilon=\frac{a}{2}&gt;0,\exists{N},$当$n&gt;N$下,$|x_n-a|&lt;\frac{a}{2},$此后，我们的$0&lt;\frac{a}{2}&lt;x_n&lt;\frac{3a}{2}$</p><p>证毕。</p><p>​        反过来讲，如果数列从一项起都大于（小于）0，并且：$\lim\limits_{n\to+\infty}{x_n}=a$，那么：$a\geqslant0(\leqslant0)$</p><p>​    （4）收敛数列的任意子数列都收敛于同一极限</p><p>子数列：就是从原本的数列中抽取一些元素组成一个全新的数列。</p><p>$x_{n_k}$就是一种表示。</p><p>​        证明:</p><p>记：$\{x_{n_k}\}$是$\{x_{n}\}$的一个子数列，并且$\lim\limits_{n\to+\infty}{x_n}=a$</p><p>则$\forall \varepsilon&gt;0,\exists N&gt;0,n&gt;N下$</p><p>$|x_n-a|&lt;\varepsilon,这时，我们取K=N,k&gt;K时，n_k&gt;n_K=n_N\geqslant{N}$</p><p>${|x_{n_k}-a|}&lt;\varepsilon$</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145330449.png" alt=""></p><p>​        于是，我们又多了一种证明方式：如果一个数列中，存在两个子数列收敛于不同的极限，则我们说这个数列是发散。</p><p>补充：</p><p>​        反三角函数：三角函数的反函数时反三角函数。有如下的对应关系：</p><p>$sin(x)\rightarrow{arcsin(x)}$</p><p>$cos(x)\rightarrow{arccos(x)}$</p><p>$tan(x)\rightarrow{arctan(x)}$</p><p>​        实际上，就是$x=siny$的离谱写法我们看不惯，于是我们选择用一个全新的表达来表达一个全新的函数</p><p>​        图像上，回忆第一小节的笔记，图像关于$y=x$对称，做出来的图像就如下图所示：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145914221.png" alt="image-20221228145914221"></p><p>​        同时，为了保证是函数（还是第一小节的知识），截取我们的函数得到：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145933050.png" alt="image-20221228145933050"></p><p>​        于是：$x\in[-1,1],y\in[-\frac{\pi}{2},\frac{\pi}{2}]$</p><p>​        一些常见的函数值对应表：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228150223124.png" alt="image-20221228150223124"></p><p>其他的：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228150313511.png" alt="image-20221228150313511"></p><h5 id="（二）函数的极限"><a href="#（二）函数的极限" class="headerlink" title="（二）函数的极限"></a>（二）函数的极限</h5><p>​        1）$x\rightarrow{a}$下的函数极限</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.这一大长串，简记成如下：</p><p>法1）$\lim\limits_{x\rightarrow{x_0}}f(x)=A$</p><p>法2)$f(x)\rightarrow{A}(x\rightarrow{x_0})$</p><p>​        这定义还是很抽象：我们用人话讲：就是只要$x到{x_0}$是充分接近的，$f(x)$到$A$的距离可以为任意小。</p><p>​        但是，我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>下面我们就使用这个定义来证明一些命题：</p><p>$(1)\lim\limits_{x\rightarrow x_0}C=C$</p><p>证明：$\forall\varepsilon&gt;0,\exists\delta=N(N&gt;0)$</p><p>使得$0&lt;|x-x_0|&lt;\delta,|f(x)-A|=0,这明显小于\varepsilon$</p><p>证毕</p><p>$(2)\lim\limits_{x\rightarrow{1}}(2x-1)=1$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta=\frac{\varepsilon}{2}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=2|x-1|&lt;\varepsilon$</p><p>$(3)\lim\limits_{x\rightarrow{1}}\frac{x^2-1}{x-1}=2$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta={\varepsilon}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=|x-1|&lt;\varepsilon$</p><p>证毕</p><p>​        回到我刚刚讲到的：因为我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。为了方便描述，我们引入左，右极限的概念来描述从左侧右侧来逼近函数一点时产生的极限</p><p>左极限:$\lim\limits_{x\rightarrow{x_0^-}}f(x)=A$</p><p>右极限:$\lim\limits_{x\rightarrow{x_0^+}}f(x)=A$</p><p>那么，回到这个定义：</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.</p><p>​    其中$x$怎么趋近的方式是已经确定的，于是上面的$|x-x_0|$就可以拆成$x-x_0$或者是$x_0-x$了</p><p>那么，我们再次阐述：</p><p>​        我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>这个定理：$x\rightarrow{x_0}$,$f(x)$的极限存在$\Leftrightarrow$ 左右极限存在且相等</p><p>比如说</p><p>$\begin{equation}f(x)=\left\{\begin{array}{cl}x+1 &amp;  x &gt; 0 \\0  &amp;  x = 0 \\x-1 &amp;  x &lt; 0 \\\end{array} \right.\end{equation}$</p><p>$\lim\limits_{x\rightarrow{0^-}}f(x)=-1$</p><p>$\lim\limits_{x\rightarrow{0^+}}f(x)=1$</p><p>两者不相等，于是$f(x)$在0处的极限是不存在的。</p><p>​        2）$x\rightarrow{\infty}$下的函数极限</p><p>​        假设啊，我们的函数在无穷远处有定义的：这个时候，我们的$x$越远，我们的函数值越是接近某一个数。用数学语言表达是这样的：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X&gt;0,\mbox{使得}|x|&gt;X时，|f(x)-A|&lt;\varepsilon$</p><p>此时，我们简记作$\lim\limits_{x\rightarrow{\infty}}=A$</p><p>例题：</p><p>​        $(1)\lim\limits_{x\rightarrow{\infty}}{\frac{1}{x}=0}$</p><p>证明：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X=\frac{1}{\varepsilon},\mbox{使得}|x|&gt;X时，|\frac{1}{x}|&lt;\varepsilon$</p><p>证明完毕</p><p>​        </p><p>​        说完了，让我们谈谈性质</p><p>​        1)函数的极限唯一性</p><p>​        2)函数的局部有界限：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\exists{M&gt;0},\forall{\delta&gt;0},0&lt;|x-x_0|&lt;\delta时，|f(x)|\leqslant{M}$</p><p>​        3)局部保号性：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,A&gt;0,\exists{\delta&gt;0}则在0&lt;|x-x_0|&lt;\delta,f(x)&gt;0$</p><p>​        4）$Henn$定理：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\{x_n\}\rightarrow{x_0},\lim\limits_{n\rightarrow{\infty}}f(x_n)=\lim\limits_{x\rightarrow{x_0}}f(x)$</p><h6 id="无穷小和无穷大"><a href="#无穷小和无穷大" class="headerlink" title="无穷小和无穷大"></a>无穷小和无穷大</h6><p>​        无穷小：趋于0的一个量（动态的！），是正是负和0都叫无穷小。同时，无穷小除了0意外，无穷小都不确定。具体的定义是这样的：</p><p>​        定义：$x\rightarrow{x_0}(x\rightarrow{\infty})$时，$f(x)$ 的极限为0，称$f(x)$是当$x\rightarrow{x_0}(x\rightarrow{\infty})$下的无穷小</p><p>​        这么说来，无穷小并不唯一，有无穷多个无穷小</p><p>下面介绍以下无穷小的一些性质:</p><p>​        定义$a,b$是两个无穷小</p><p>​        $a+b$是一个无穷小；</p><p>​        $a-b$是一个无穷小;</p><p>​        $a\times b$是一个无穷小;</p><p>​        $c\times{a}$是一个无穷小;</p><p>​        注意！！！$a\div{b}$是未定式，在没有给定a,b的具体情况，我们是不知道这个值究竟是多少的！它本身可以是任何数！！！</p><p>​        无穷大：这个有特定的符号：$\infty$</p><p>​        他也是有定义的：$\lim\limits_{ {x\rightarrow{x_0} } }f(x)= \infty$或者$\lim\limits_{ {x\rightarrow{\infty} } }f(x)=\infty$</p><p>​        注意！！！注意！！！无穷大可以是正无穷大或者是负无穷大！！！于是</p><p>​        引入两个无穷大记作$a,b$</p><p>​        无论是$a+b还是a-b$都是未定义的</p><p>​        但是$a\times{b}$一定是无穷大，$c\times{ \infty }(c\neq{ 0 })$一定是无穷大</p><p>​        $a\div{ b }$结果未知</p><p>​        定理：$f(x)$如果是无穷大，那么$\frac{1}{f(x)}$是无穷小。</p><p>​        $f(x)$如果是无穷小，那么$\frac{1}{f(x)}$是无穷大。（$f(x)\neq{0}$）</p><p>​        极限运算法则</p><p>​        法则1：两个甚至是若干有限个的无穷小的和是无穷小的</p><p>​        <strong>法则2：有界函数与无穷小的乘积是无穷小</strong></p><p>​        推论：常数乘以无穷小还是无穷小</p><p>​                    有限个无穷小的乘积还是无穷小</p><p>​        定理：记：$\lim{f(x)}=A,\lim{g(x)}=B$</p><p>​        1)$\lim{f(x)\pm{g(x)}}=A\pm{B}$</p><p>​        2)$\lim{f(x)\times{g(x)}}=A\times{B}$</p><p>​        3)$\lim{\frac{f(x)}{g(x)}}=\frac{A}{B}(B\neq{0})$</p><p>​        4)$\lim{cf(x)}=c\lim{f(x)}$</p><p>​        5)$\lim{ {f(x)}^n}=[{\lim{f(x) } }]^n$</p><p>对于数列还是一样的</p><p>​        定理:$\psi(x)\geqslant\varphi(x)$,$\lim{\psi(x)}&gt;\lim{\varphi(x)}$</p><p>哎，这后面这么没有等号了呢?举个例子:$\frac{1}{x}$,$-\frac{1}{x}$</p><h5 id="极限存在准则，两个重要极限"><a href="#极限存在准则，两个重要极限" class="headerlink" title="极限存在准则，两个重要极限"></a>极限存在准则，两个重要极限</h5><p>准则I：对于数列$\{x_n\},\{y_n\}$,${z_n}$ (1)$\exists {n_0}\in{N},y_n\leqslant{x_n}\leqslant{z_n}$(2)$\lim{y_n}=lim{z_n}=a$那么：$\lim{x_n}=a$</p><p>准则I’ :对于函数f(x),g(x),h(x),且(1)$g(x)\leqslant{f(x)}\leqslant{h(x)}$(2)$\lim{g(x)}=\lim{h(x)}=A$那么：$lim{f(x)}=A$</p><p>两个重要极限：</p><h6 id="I-lim-limits-x-rightarrow-0-frac-sin-x-x-1"><a href="#I-lim-limits-x-rightarrow-0-frac-sin-x-x-1" class="headerlink" title="I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$"></a>I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$</h6><p>注意一定是$x\rightarrow{0}$！！！</p><p>同时！！！也可以有推广：</p><h6 id="I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1"><a href="#I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1" class="headerlink" title="I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$"></a>I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$</h6><p>其他派生的极限：</p><p>$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=1$</p><p>这是因为：$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=\lim\limits_{x\rightarrow{0}}(\frac{\sin{x}}{x})\times(\frac{1}{\cos{x}})$=1</p><p>例题：$\lim\limits_{x\rightarrow{0}}\frac{1-\cos{x}}{x^2}$</p><p>解：<img src="C:\Users\陈冠豪\Desktop\image-20221229164852173.png" alt="image-20221229164852173"></p><p>等价无穷小：（I派生）</p><p>$\sin{x}\backsim{x}$ , $\tan{x}\backsim{x}$, $\arcsin{x}\backsim{x}$</p><h4 id="准则II：单调有界数列必有极限！"><a href="#准则II：单调有界数列必有极限！" class="headerlink" title="准则II：单调有界数列必有极限！"></a>准则II：单调有界数列必有极限！</h4><p>性质：收敛必有界，而有界不一定收敛</p><p>为什么有界不一定收敛呢？举个反例：$\{(-1)^{N}\}$就可以了，这个数列显然有界：</p><p>II:$\lim\limits_{x\rightarrow{\infty}}(1+\frac{1}{x})^{x}=e$</p><p>注意$x$一定是趋于无穷！！！</p><p>派生的还有。。。</p><p>II’$\lim\limits_{\Box\rightarrow{\infty}}(1+\frac{1}{\Box})^{\Box}=e$</p><p>II’’$\lim\limits_{x\rightarrow{0}}(1+{x})^\frac{1}{x}=e$</p><p>补充：Cauchy极限审敛法：</p><p>$\{x_n\}收敛\Leftrightarrow \forall{\varepsilon&gt;0},\exists N,当m&gt;N时，|x_n-x_m|&lt;\varepsilon$</p><p>无穷小的比较：</p><p>​        不同无穷小趋于0的速度不一样，我们比较无穷小就是比较不同无穷小趋于0的速度：</p><p>方法是简单的，看他们的商的极限即可：</p><p>如：$\lim\limits_{x\rightarrow{0}}x=0,\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$,而$\lim\limits_{x\rightarrow{0}}\frac{x}{\sqrt{x}}=\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$</p><p>于是：我们发现这个极限为0，说明在趋近速度上$x&gt;\sqrt{x}$</p><p>这样，我们就比较出来了</p><p>定义：</p><p>$若\lim\frac{\beta}{\alpha}=0,则称\beta是\alpha的高阶无穷小，记作\beta=o(\alpha)$</p><p>$若\lim\frac{\beta}{\alpha}=\infty,则称\beta是\alpha的低阶无穷小$</p><p>$若\lim\frac{\beta}{\alpha}=c(c\neq{0}),则称\beta是\alpha的同阶无穷小,特别的，当c=1时，又称等价无穷小,记作{\beta}\backsim{\alpha}$</p><p>$若\lim\frac{\beta}{\alpha^k}=c(c\neq{0}),则称\beta是\alpha的k阶无穷小$</p><p>下面是一些常见的等价无穷小：</p><p>1)$x\rightarrow{0}时，\sqrt[n]{1+x}-1\backsim\frac{x}{n},\sin(x)\sim{x}$</p><p>定理：</p><p>1）$\beta于\alpha等价\Leftrightarrow \beta=\alpha+o(\alpha)$</p><p>2)$\alpha\sim\widetilde{\alpha},\beta\sim\widetilde{\beta},且\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}是存在的，则:\lim\frac {\alpha}{\beta}=\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}$</p><p>于是：</p><p>2)$\tan{x}\sim{x},\arcsin{x}\sim{x}$</p><p>上面的$x$都可以被替换成$\Box$</p><p>定理：</p><p>1）两个无穷小相比的极限时，分子分母可以用等价无穷小替换</p><p>2）如果分子或分母是若干因子的乘积，则我们可以对其中一个或者几个无穷小做替换，但是因子用加减法是不可以的！！！！！！！！！！！！！！！！</p><h4 id="函数的连续性"><a href="#函数的连续性" class="headerlink" title="函数的连续性"></a>函数的连续性</h4><p>对于函数增量的定义：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221229174949222.png" alt="image-20221229174949222"></p><p>则增量$\Delta f(x)=f(x+\Delta{x})-f(x)$</p><p>实际上，叫做改变量更切合实际，因为函数也可以递减</p><p>那么，连续的定义由此引出：</p><p>若$\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=\lim\limits_{\Delta{x}\rightarrow{0}}(f(x_0+\Delta{x})-f(x_0))=0$时，则函数在$x_0$处连续</p><p>或者</p><p>$\lim\limits_{x\rightarrow{x_0}}f(x)=f(x_0)$时，则函数在$x_0$处连续</p><p>总结而言，一个函数若是想在$x_0$ 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！</p><p>既然有左右极限，于是也使得函数也有左右连续。函数的左右极限就是由$x$以不同的方向逼近产生的。</p><p>左连续：$\lim\limits_{x\rightarrow{x_0^-}}f(x)=f(x_0)$</p><p>右连续：$\lim\limits_{x\rightarrow{x_0^+}}f(x)=f(x_0)$</p><p>类似的：函数的连续的充要条件是函数即左连续又右连续。</p><h4 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h4><p>回到连续需要满足的条件：</p><p>一个函数若是想在x_0 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！于是，间断点也就有三种产生原因：</p><p>1)在$x_0$无定义</p><p>2)$\lim\limits_{x\rightarrow{x_0}}f(x)$不存在</p><p>3）$\lim\limits_{x\rightarrow{x_0}}f(x)\neq{f(x_0)}$</p><p>举例子：</p><p>1)$y=\tan{x}在x=\frac{\pi}{2}$处无定义，所以在这一点上不连续这是可去间断点.</p><p>2)$y=\sin{\frac{1}{x}}$在x=0处极限不存在，所以在这一点上不连续.</p><p>3）</p><script type="math/tex; mode=display">\begin{equation}f(x)=\left\{\begin{array}{cl}\frac{x^2-1}{x-1} &  x \neq 0 \\0  & x = 0 \\\end{array} \right.\end{equation}</script><p>，这个函数在x=1处不连续。这个间断点叫跳跃间断点</p><p>间断点有两类：</p><p>第一类：左右极限都存在</p><p>有可去间断点，跳跃间断点</p><p>第二类：左右极限不都存在</p><p>有震荡间断点</p><p>连续函数的性质：</p><p>对于$[a,b]$上，且$f(a)f(b)&lt;0$时，则其中至少存在一个点$\xi \in[a,b]，$使得$f(\xi)=0$</p><p>推广：</p><p>定理：$f(x)在[a,b]$上连续,$f(a)=A,f(b)=B$,则$\exists C\in[A ,B]$,至少有一个$\xi \in [a,b]$使得，$f(\xi)=C$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C简单教程（1）</title>
      <link href="/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简单C教程1"><a href="#简单C教程1" class="headerlink" title="简单C教程1"></a>简单C教程1</h1><p>​        首先打开你的VS，或者是已经配置好GCC和相关插件的Vscode,亦或者Dev C++这个东西，以及切换到英文输入法！！！！！！！！！！！！小心中文的分号给你小小的计算机震撼</p><p>​        我们首先明确：C语言是一个人和计算机交流的语言。语言既然有发展的历史，那么，计算机语言也有发展的过程</p><p>​        最开始的时候：我们使用0，1来代表正电负电，后来用助记符 ，而后有用更高级的语言表达一些固定的助记符。C语言由此诞生。</p><p>​        C语言也有标准：C89/C90是我们这个时候学习的主力。</p><h3 id="My-Fisrt-C-Project"><a href="#My-Fisrt-C-Project" class="headerlink" title="My Fisrt C Project"></a>My Fisrt C Project</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression"><span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h</span><span class="token comment">//1</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//2</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//3</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        //1:首先，我们首先引入头文件stdio.h，这个文件里包含了我们以后要使用的函数，我需要把他们包含进来才可以使用，否则编译器不认识他们。</p><p>​        //2:接着，main是主函数的意思，这是我们程序的入口：只能有一个main函数不可以有第二个，更不可以没有main函数，int是integer的缩写，表明的是整形。这个表达的是这个函数返回的是一个整形。这个函数负责完成任务</p><p>​        //3：返回0：这是因为函数需要返回东西，我们返回0表达的是成功完成任务</p><p>​        //4：printf:print formatly标准的打印，里面放进去的是一个字符串”hello world\n”,\n是一个换行符</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><div class="table-container"><table><thead><tr><th style="text-align:left">char</th><th>short</th><th>long</th><th>int</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">long long</td><td>float</td><td>double</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>​    数据类型有上面这几种，生活中无非就是小数，整数。上面就是引申出来的七种类型</p><p>1.char类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;char ch&#x3D;&#39;A&#39;;&#x2F;&#x2F;存放一个字符，我们起了一个名字ch，里面放了一个A    printf(&quot;%c&quot;,ch);&#x2F;&#x2F;使用%c来输出一个字符变量的内容，函数以这样的方式取出一个字符    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.int类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;int stdint&#x3D;114514;&#x2F;&#x2F;存储一个整形，我们起了一个名字叫stdint，里面放了一个114514printf(&quot;%d&quot;,stdint);&#x2F;&#x2F;使用%d来输出一个整形变量的内容，函数以这样的方式取出一个整形return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.long, long long（C99）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;long stdint&#x3D;114514;&#x2F;&#x2F;存储一个长整形，我们起了一个名字叫stdint，里面放了一个114514printf(&quot;%ld&quot;,stdint);&#x2F;&#x2F;使用%ld来输出一个长整形变量的内容，函数以这样的方式取出一个长整形return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.float，double</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;float stdflt&#x3D;114514.1919810;&#x2F;&#x2F;存储一个浮点型，我们起了一个名字叫stdflt，里面放了一个114514.1919810printf(&quot;%f&quot;,stdflt);&#x2F;&#x2F;使用%f来输出一个浮点型变量的内容，函数以这样的方式取出一个浮点型    double stddbl&#x3D;114514.1919810;&#x2F;&#x2F;存储一个双精度浮点型，我们起了一个名字叫stddbl，里面放了一个114514.1919810    printf(&quot;%lf&quot;,stddbl);&#x2F;&#x2F;使用%lf来输出一个双精度浮点型变量的内容，函数以这样的方式取出一个双精度浮点型return 0;&#125;&#x2F;&#x2F;打印还有其他方式访问：%p声明打印地址，%x以十六进制的方式打印，%o以八进制的方式打印<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        问题来了，为什么整这么多花里胡哨的东西呢？一个不香吗？</p><p>​        首先我们区分他们在计算机在内存中占用的内存。使用一个运算符叫做sizeof(),我们的括号里面放的就是类型。大伙看一看，有什么区别</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    printf(&quot;%d\n&quot;,sizeof(char));&#x2F;&#x2F;char申请内存的大小    printf(&quot;%d\n&quot;,sizeof(short));&#x2F;&#x2F;short申请内存的大小    printf(&quot;%d\n&quot;,sizeof(int));&#x2F;&#x2F;int申请内存的大小    printf(&quot;%d\n&quot;,sizeof(long));&#x2F;&#x2F;long申请内存的大小    printf(&quot;%d\n&quot;,sizeof(float));&#x2F;&#x2F;float申请内存的大小    printf(&quot;%d\n&quot;,sizeof(double));&#x2F;&#x2F;double申请内存的大小&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230129173130931.png" alt="image-20230129173130931"></p><p>​        等等，我们是得到了数，单位是什么呢？字节（byte）。下面插一个小科普：计算机的单位有以下几个层级：</p><p>​        bit                    byte            kb            mb            gb            tb            pb </p><p>​        计算机力最小的单位是怎么定义的呢？</p><p>​        计算机通电工作，这些硬件下通过的电流分为正电和负电，分别代表0和1。（高低电平）这就是2进制的来源，我们用一系列的0和1来表达数据或者物体的状态。1个比特位就可以存储一个0或者是1，8个比特位构成一个字节，随后k,m,g,t,p的进位关系是1024倍数的关系。就是说：一个char的大小是8个比特位，一个int由32个比特位构成。我们的这些类型就是为了更加方便和丰富的表达生活的类型，所以才产生的。</p><h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p>​        我们针对数据变不变来区分出来数据是常量还是变量。</p><p>​        比如说：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int age&#x3D;10;&#x2F;&#x2F;向内存申请4个字节存放一个20，而这个字节表达的含义是age<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个age是可以变动的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int age&#x3D;10;printf(&quot;%d\n&quot;,age);age&#x3D;20;printf(&quot;%d\n&quot;,age);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的代码打出来了10和20 。</p><p>​        定义变量的方法是这样的：</p><pre class="line-numbers language-none"><code class="language-none">类型 变量名 &#x3D; 值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        变量自身也有分类：局部变量和全局变量，区别又是什么呢？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int num1&#x3D;20;int main()&#123;    int num2&#x3D;10;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不难猜到：num1是全局变量，num2是局部变量。全局变量指的是定义在代码块{ }之外的变量。反之，在{ }内的是全局变量。问题来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int global &#x3D;2023;int main()&#123;    int local&#x3D;2022;    &#x2F;&#x2F;?So what about the next line?int global&#x3D;2022;    printf(&quot;global here is %d\n&quot;,global);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         当你在VS2022一敲出来，高亮颜色就告诉你，答案是2022：</p><p>​        <img src="image-20230129180112913.png" alt="image-20230129180112913"></p><p>​        能同时共存，而且：<strong>局部变量优先</strong> 这里给出建议：</p><p>​        <strong>打代码的时候不要使用同名的局部变量和全局变量，如果相同了，记住一件事情：局部变量优先！</strong></p><p>​        下面我们继续玩一个新的函数：scanf函数。</p><p>​        我说停停！！！先别函数玩的欢乐，这是因为在新标准下，C标准委员会嫌这东西不安全（为什么不安全这里先不扯，简单来讲就是这个函数读到什么东西就往里塞，实在读不进去就直接扔回一个-1摆烂，导致程序安全性很差）, 所以整了一个船新函数scanf_s ,这个函数我的评价是VS用用行，但是移植到别的编译器还要切换标准，怎么办呢？在VS编译器下面使用一个宏定义#define _CRT_SECURE_NO_WARNINGS 1 让编译器赶紧闭嘴通过就完事，这个宏（可以先不追究这是什么东西）扔到程序的最前面就可以了</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Example#define _CRT_SECURE_NO_WARNINGS 1&#x2F;&#x2F;Looking here#include&lt;stdio.h&gt;int global &#x3D; 2023;int main()&#123;    int local &#x3D; 2022;    &#x2F;&#x2F;?So what about the next line?    int global &#x3D; 2022;    printf(&quot;global here is %d\n&quot;, global);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个函数读取键盘的输入，使用方法如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;A basic program that reads two numbers then returns the sum of themint num1&#x3D;0;int num2&#x3D;0;scanf(&quot;%d%d&quot;,&amp;num1,&amp;num2);&#x2F;&#x2F;字符串里面不要塞上空格！不要塞上空格int sum&#x3D;num1+num2;printf(&quot;%d&quot;,sum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对了，这个&amp;是什么捏？取地址符号，后面我们提到指针的时候我们会天天见到他。人话就是这样讲：告诉这个函数，这两个变量在计算机的哪里。</p><p>​        认真的讲，计算机有巨大的内存，那么多数据，我们的计算机怎么哪里是哪里？使用地址，就像你们家的门牌号一样。</p><p>​        变量也有作用域：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int global&#x3D;10;int main()&#123;    int numlevel1&#x3D;10;    &#123;        int numlevel2&#x3D;20;    &#125;    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel1);    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你的编译器很快（也很不幸的）告诉你，我不到numlevel2是什么啊。那就对了，因为每个变量都有它的作用域：范围就是从他定义的位置到当前它在的大括号区域}结束处：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int global&#x3D;10;int main()&#123;printf(&quot;%d&quot;,numlevel1);&#x2F;&#x2F;NOOOO,变量还没被声明，不要用:(    int numlevel1&#x3D;10;&#x2F;&#x2F;----init numlevel1    &#123;       int numlevel2&#x3D;20;&#x2F;&#x2F;----init numlevel2    &#125;&#x2F;&#x2F;----destroy numlevel2 Sadly    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel1);   &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel2);&#125;&#x2F;&#x2F;----destroy numlevel1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的图就表示了程序变量的生命周期或者说作用域：创建完之后到被回收之前，变量才是被允许使用的。所以，当你的编译器不知道你想要使用的变量的时候，他会指出错误：未声明的标识符。这个时候回去看看你的代码哪里出现了问题⑧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
