<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Deep Qt Learn-1</title>
      <link href="/2023/09/05/Deep-Qt-Learn-1/"/>
      <url>/2023/09/05/Deep-Qt-Learn-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Qt"><a href="#Deep-Qt" class="headerlink" title="Deep Qt"></a><code>Deep Qt</code></h1><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>​        这个文档是为了正儿八经的学习Qt开开设的，本次Qt文档将会严肃的基于Qt5开发实例这本书，展开对Qt的学习。值得注意到是，当你阅读此文档时，我们将默认您有一定的Qt基础</p><h1 id="Start-all"><a href="#Start-all" class="headerlink" title="Start all"></a><code>Start all</code></h1><p>​        让我们先从写一个对话框——其可以返回圆的大小开始！我们首先构建一个基于QDialog的项目，在Ui编辑窗口处拖一个LineEdit，拖一个QTextBrowser，拖一个QPushButton出来，嗯，对了，为了让他美观一些，我们整一个QGridLayout上去。以及，限制一下FixedSize，至少，我们并不需要他托的太离谱</p><p><img src="image-20230827210357007.png" alt="image-20230827210357007"></p><p>​        我想这不能再简单了。现在，我们的目光就聚集在这三个控件上，围绕他们完成我们的功能，在下面</p><h2 id="计算圆的大小"><a href="#计算圆的大小" class="headerlink" title="计算圆的大小"></a>计算圆的大小</h2><p>​        我们老规矩，程序经过预处理和符号加载后，从main处开始运行代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; main.cpp#include &quot;dialog.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    Dialog w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们逐行分析</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;dialog.h&quot;#include &lt;QApplication&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这个dialog.h，可能你的不是，是什么别的名字，但是你摁住Ctrl + 鼠标进去一看，果然，正是你自己的头文件。在这里，我们对我们的窗口完成的功能实现预定义</p><p>​        第二行的QApplication则是引入了QApllication类，我们的各式各样的GUI广泛资源，基本设置和事件处理都由他负责</p><pre class="line-numbers language-none"><code class="language-none">int main(int argc, char *argv[])&#123; QApplication a(argc, argv);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        命令行程序，我们的程序接受了一个命令行，同时值得注意是，创建了一个QApplication，处理我们的命令行。</p><pre class="line-numbers language-none"><code class="language-none">Dialog w;w.show();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        创建了一个Dialog，并且显示它——我们的工作结束！</p><pre class="line-numbers language-none"><code class="language-none">return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        程序进入消息循环，等待可能的输入响应</p><p>​        好了，扯完了，我们下面来写代码：</p><p>​        这是我们的头文件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef DIALOG_H#define DIALOG_H#include &lt;QDialog&gt;#include &lt;QKeyEvent&gt;namespace Ui &#123;class Dialog;&#125;class Dialog : public QDialog&#123;    Q_OBJECTpublic:    explicit Dialog(QWidget *parent &#x3D; nullptr);    void caculateArea();&#x2F;&#x2F; 核心处理函数    ~Dialog();private slots:    void on_pushButton_clicked();     &#x2F;&#x2F; 摁下摁扭的响应    void on_lineEdit_returnPressed(); &#x2F;&#x2F; 摁Enter键的响应private:    Ui::Dialog *ui;&#125;;#endif &#x2F;&#x2F; DIALOG_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        按照逻辑顺序，我们先写核心代码：</p><pre class="line-numbers language-none"><code class="language-none">void caculateArea();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们先拿出两个宏，第一个是衡量PI的精度</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const double PI &#x3D; 3.1415926; &#x2F;&#x2F; #define PI 3.1415926<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        第二个是衡量面积大小</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define Area(X) ( X*X*PI )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        好，现在，我们写核心：很简单，我们触发了这个函数表示开始算，拿到LineEdit的结果，然后投射到TextBrowser上</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; dialog.cppvoid Dialog::caculateArea()&#123;    bool isAbleTransform;    double radius &#x3D; static_cast&lt;double&gt;(ui-&gt;lineEdit-&gt;text().toFloat(&amp;isAbleTransform));    if(!isAbleTransform)&#123;        QMessageBox::critical(this,&quot;错误！&quot;, &quot;输入不是数字！&quot;);        return;    &#125;    ui-&gt;textBrowser-&gt;setText(&quot;面积大小：&quot; + QString::number(Area(radius)));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们使用的是GUI的revelant API，啥呢，</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Dialog::on_pushButton_clicked()&#123;    caculateArea();&#125;void Dialog::on_lineEdit_returnPressed()&#123;    caculateArea();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        出乎意料的简单——这是因为本质上我们的响应的目的就只有一个——调用函数，显示在桌面上！</p><h1 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h1><p>​        这个，可是Qt的一大特色，我们使用了这个东西，来化简了窗口的通信！在比较早期的Qt中，我们总是这样书写信号与曹的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">connect(Object1, SIGNAL(signal1), Object2, SLOT(slot1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        现在，我们则是抛弃掉了SIGNAL和SLOT宏，转向了传递函数的地址（或者说函数指针），我们现在这样写代码：</p><pre class="line-numbers language-none"><code class="language-none">connect(ui-&gt;pushbutton, &amp;QPushButton::pressed, this, &amp;MainWindow::doSomething);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这句话的意思是：绑定摁扭点击和主窗口某个方法。只要点击他，就会调用doSomething.</p><h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><h3 id="一、桌面程序的结构"><a href="#一、桌面程序的结构" class="headerlink" title="一、桌面程序的结构"></a>一、桌面程序的结构</h3><p><a href="https://blog.csdn.net/ifeng12358/article/details/120880153">Qt 信号和槽的机制（逻辑清晰的来说清楚信号和槽，呕心沥血之作）_qt的信号与槽机制原理_冯一川的博客-CSDN博客</a></p><p>​        Qt的使用场景，主要是应用于桌面程序来使用，不管你使用的操作系统平台是什么。对于桌面程序来说，最重要的就是交互了。既然有交互，就需要一个窗口系统了。</p><p>​        窗口系统实现了桌面程序的主要逻辑，并提供了一套基于事件驱动的编程框架。Qt同样也提供了这样的一套逻辑。</p><p>​        我们常见的桌面程序的结构，如下图所示：</p><p><img src="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yav5LiA5bed,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yav5LiA5bed,size_20,color_FFFFFF,t_70,g_se,x_16"></p><p> 所以，我们可以看到，在桌面程序中我们需要对窗口系统的一些操作作出相应，也就是事件。</p><h3 id="二、事件"><a href="#二、事件" class="headerlink" title="二、事件"></a>二、事件</h3><p>实现事件的机制通常有两种。</p><p>一种是事件处理类，是用回调函数来实现。</p><p>另一种叫委托，就是事件的处理不是收到事件的人自己来做，而是把它委托给了别人来做。Qt就提供了这样的一种机制：信号和槽。</p><h3 id="三、信号和槽"><a href="#三、信号和槽" class="headerlink" title="三、信号和槽"></a>三、信号和槽</h3><p>信号与槽是Qt特有的的消息传输机制，在Qt中信号与槽用得十分广泛。在编程的过程中，我们都会遇到消息传递的事情，本质上就是发出命令（信号、消息），执行命令（相应的执行）。</p><p>比如单击窗口上一个按钮然后弹出一个对话框，那么就可以将这个按钮的单击信号和自定义的槽关联起来，信号是按钮的单击信号，槽实现了创建一个对话框并显示的功能。</p><p>信号与槽就是实现对象之间通信的一种机制，在其他编程语言中也有通过回调机制来实现对象之间的通信。</p><ul><li>信号：当对象改变其状态时，信号就由该对象发射 (emit) 出去，而且对象只负责发送信号，它不知道另一端是谁在接收这个信号。</li><li>槽：用于接收信号，而且槽只是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。</li></ul><p>信号槽是设计模式<a href="https://so.csdn.net/so/search?q=观察者模式&amp;spm=1001.2101.3001.7020">观察者模式</a>的一种实现：</p><p>A、一个信号就是一个能够被观察的事件，或者至少是事件已经发生的一种通知；<br>B、一个槽就是一个观察者，通常就是在被观察的对象发生改变的时候——也可以说是信号发出的时候——被调用的函数；<br>C、信号与槽的连接，形成一种观察者-被观察者的关系；<br>D、当事件或者状态发生改变的时候，信号就会被发出；同时，信号发出者有义务调用所有注册的对这个事件（信号）感兴趣的函数（槽）。</p><p>信号和槽是多对多的关系。一个信号可以连接多个槽，而一个槽也可以监听多个信号。</p><p>然后，实现信号和槽，就要说一下Qt的元对象系统。</p><h3 id="四、Qt元对象系统"><a href="#四、Qt元对象系统" class="headerlink" title="四、Qt元对象系统"></a>四、Qt元对象系统</h3><p>Qt 的元对象系统叫 Mate-Object-System，提供了对象之间通信的信号与槽机制、运行时类型信息和动态属性系统。</p><p>但是，元对象是基于三个条件的：</p><p> 1、该类必须继承自Qobject类</p><p> 2、必须在类的私有声明区声明<a href="https://so.csdn.net/so/search?q=Q_OBJECT&amp;spm=1001.2101.3001.7020">Q_OBJECT</a>宏（在类定义的时候，如果没有指定public，<br>则默认为private，用来启用元对象功能，比如动态属性、信号和槽）。 </p><p> 3、 元对象编译器Meta-Object Compiler（moc）为 QObject的子类实现元对象<br>特性提供必要的代码。</p><p>有了元对象系统后，我们就可以使用Qt的信号和槽了。</p><h3 id="五、信号和槽的格式"><a href="#五、信号和槽的格式" class="headerlink" title="五、信号和槽的格式"></a>五、信号和槽的格式</h3><p>信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">QObject</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span>sender<span class="token punctuation">,</span> <span class="token function">SIGNAL</span><span class="token punctuation">(</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> receiver<span class="token punctuation">,</span> <span class="token function">SLOT</span><span class="token punctuation">(</span><span class="token function">slot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在Qt 5中提供了一种新的格式：</p><pre class="line-numbers language-lisp" data-language="lisp"><code class="language-lisp">connect<span class="token punctuation">(</span><span class="token car">sender</span>, &amp;Sender:<span class="token lisp-property property">:valueChanged</span><span class="token splice symbol variable">,receiver</span>, &amp;Receiver:<span class="token lisp-property property">:updateValue</span><span class="token punctuation">)</span><span class="token comment">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具体的使用哪种格式，就看个人的喜好了。</p><p>注：在日常的项目编程中，如果第一种的connect方式出现报错，你可以尝试使用第二种connect方式。</p><h3 id="六、connect的第五个参数"><a href="#六、connect的第五个参数" class="headerlink" title="六、connect的第五个参数"></a>六、connect的第五个参数</h3><p>在connect函数中除了上面介绍的四个参数外，还有第五个参数，是缺省的参数。我们打开qobject.h文件可以看到它的定义，如下所示：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">static QMetaObject::Connection connect(const QObject *sender, const char *signal,            const QObject *receiver, const char *member, Qt::ConnectionType &#x3D; Qt::AutoConnection); static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod &amp;signal,            const QObject *receiver, const QMetaMethod &amp;method,            Qt::ConnectionType type &#x3D; Qt::AutoConnection); inline QMetaObject::Connection connect(const QObject *sender, const char *signal,            const char *member, Qt::ConnectionType type &#x3D; Qt::AutoConnection) const;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一个参数所表示的意思：</p><p>Qt::AutoConnection：信号的发送者与信号的接收者在同一线程，则默认使用Qt::DirectConnection：如果不在同一线程，则默认  使用Qt::QueuedConnection。<br>Qt::DirectConnection：信号的发送者与信号的接收者在同一线程中执行，当发出信号后，会马上进入槽函数，看上去就像在信号  发送位置调用了槽函数，在多线程下会比较危险，容易造成崩溃。<br>Qt::QueuedConnection：信号的发送者与信号的接收者不在同一线程中执行，槽函数运行于信号的接收者线程，当发送信号后，  槽函数不会马上被调用，等待信号的接收者把当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。<br>Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。<br>Qt::UniqueConnection：可以通过按位或（|）与以上四个结合在一起使用。当设置此参数时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是避免了重复连接。</p><p>介绍到这里，信号和槽的基本内容就写完了。但是，还是得说下Qt事件（你可以结合着上面第2节一起看）。</p><h3 id="七、Qt事件"><a href="#七、Qt事件" class="headerlink" title="七、Qt事件"></a>七、Qt事件</h3><p>无论是什么桌面操作系统，每个进程都有一个全局的事件队列（Event Queue）。当我们在键盘上按了一个键、移动或者点击鼠标、触摸屏幕等等，都会产生一个事件（Event），并由操作系统负责将它扔到进程的事件队列。</p><p>扔到事件队列后，它会等待以后的某一个时刻发送。分配器（dispatcher ）会遍历事件队列，并且将入栈的事件发送到它们的目标对象当中，因此它们被称为<strong>事件循环（Event loop</strong>）。</p><p>Qt中是通过运行QCoreApplication::exec()来进入Qt的主体事件循环的；这会引发阻塞，直至QCoreApplication::exit() 或者 QCoreApplication::quit() 被调用，进而结束循环。</p><h1 id="Qt5模板库，工具类和基本控件"><a href="#Qt5模板库，工具类和基本控件" class="headerlink" title="Qt5模板库，工具类和基本控件"></a>Qt5模板库，工具类和基本控件</h1><h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>​        我们很难逃过字符串这个东西，为什么？无论是做什么，我们都要使用字符串来传递信息。无论是网络编程还是GUI显示，很多地方都需要字符串可以灵活的正确的按照我们的想法表达。</p><p>​        QString提供了一个非常完善的方法来供我们使用字符串。我们先来看一个简单的操作：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QCoreApplication&gt;#include &lt;QString&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    QString str1 &#x3D; &quot;Welcome &quot;;    QString str2 &#x3D; &quot;Qt!&quot;;    qDebug() &lt;&lt; str1 + str2;    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们很自然的想到+号使得字符串自然的拼接。我们毫不意外的看到输出是：</p><p><img src="image-20230829180312755.png" alt="image-20230829180312755"></p><p>​        我们为什么可以直接这样写：</p><pre class="line-numbers language-none"><code class="language-none">QString str1 &#x3D; &quot;Welcome &quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        而不是</p><pre class="line-numbers language-none"><code class="language-none">QString str1(&quot;Welcome &quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        呢，答案是，我们调用了这个构造函数</p><pre class="line-numbers language-none"><code class="language-none">inline QT_ASCII_CAST_WARN QString(const char *ch)   : d(fromAscii_helper(ch, ch ? int(strlen(ch)) : -1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        实际上，我们还可以到—他不是QString直接跟const char*对接，而是用一个fromAscii对象处理：这是为了方便程序员更加高级的处理字符串的（翻译成Unicode字符串还是其他？）</p><p>​        如果不喜欢用 + （我没见过），可以使用等价的接口<code>append</code>，</p><pre class="line-numbers language-none"><code class="language-none">QString str;str.append(str1);str.append(str2);qDebug() &lt;&lt; str;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230829181923523.png" alt="image-20230829181923523"></p><p>​        我们甚至可以使用一个sprintf来生成我们的字符串，这跟我们的C++字符串库一样</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString Str;   Str.sprintf(&quot;%s&quot;,&quot;str1&quot;);   qDebug() &lt;&lt; Str;   Str.sprintf(&quot;%s&quot;,&quot;str2&quot;);   qDebug() &lt;&lt; Str;   Str.sprintf(&quot;%s %s&quot;,&quot;str1&quot;, &quot;str2&quot;);   qDebug() &lt;&lt; Str;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230829182354324.png" alt="image-20230829182354324"></p><p>​        熟悉格式化输出的话，还可以使用arg函数。相较于sprintf，她更有类型安全，且支持处理的类型更多</p><pre class="line-numbers language-none"><code class="language-none">QString argtest;argtest &#x3D; QString(&quot;%1 was in %2&quot;).arg(&quot;Charlie&quot;).arg(&quot;cc&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230829183053685.png" alt="image-20230829183053685"></p><p>​        还有其他的接口，如insert等，可以看后面翻译的文档：</p><p>​        更加值得一提的是：QString还有一些方法如：trimmed（移除两端的空白字符）和simplified方法（用空格代表空白字符）</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>​        startsWith方法判定的是某一个字符串是不是以另一个指定的字符串开头</p><pre class="line-numbers language-none"><code class="language-none">if(argtest.startsWith(&quot;charlie&quot;,Qt::CaseInsensitive))    qDebug() &lt;&lt; &quot; yep &quot;;if(argtest.startsWith(&quot;Charlie&quot;,Qt::CaseInsensitive))    qDebug() &lt;&lt; &quot; yep &quot;;qDebug() &lt;&lt; &quot;We see that in Qt::CaseInsensitive mode, both judgement can be true&quot;;if(!argtest.startsWith(&quot;charlie&quot;,Qt::CaseSensitive))    qDebug() &lt;&lt; &quot; nope &quot;;if(argtest.startsWith(&quot;Charlie&quot;,Qt::CaseSensitive))    qDebug() &lt;&lt; &quot; yep &quot;;qDebug() &lt;&lt; &quot;but CaseSensitive don&#39;t&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230829183957089.png" alt="image-20230829183957089"></p><p>​        可以一瞥，对了，CaseSensitive是QT下的一个Enumeration，一个枚举值，可以看到当我们指定大小写敏感的时候，charlie就找不到了，默认的讲，我们不指定的话，自然是CaseSensitive，这一点可以在默认参数看到：</p><pre class="line-numbers language-none"><code class="language-none">#if QT_STRINGVIEW_LEVEL &lt; 2    bool startsWith(const QString &amp;s, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const;    bool startsWith(const QStringRef &amp;s, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const;#endif    Q_REQUIRED_RESULT bool startsWith(QStringView s, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const Q_DECL_NOTHROW    &#123; return QtPrivate::startsWith(*this, s, cs); &#125;    bool startsWith(QLatin1String s, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const;    bool startsWith(QChar c, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还有个类似的是endsWith，这里不在讲述了！</p><p>​        contains方法则是上述两个的通用算法，查询的是子字符串在不在我们的字符串内，返回的是boolean类型</p><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>​        比较函数用于比较两个 QString，并返回整数值 0、小于 0 或大于 0，具体取决于两个 QString 分别相等、小于或大于彼此。</p><p>示例 1：比较两个 QStrings</p><pre class="line-numbers language-none"><code class="language-none">QString str1 &#x3D; “Hello”;QString str2 &#x3D; “World”;int result &#x3D; str1.compare（str2）&#x2F;&#x2F; 结果将小于 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        在这个例子中，我们比较两个QStrings“Hello”和“World”。由于“Hello”按字母顺序排在“World”之前，因此结果将小于 0。</p><p>示例 2：使用区分大小写</p><pre class="line-numbers language-none"><code class="language-none">QString str1 &#x3D; “Hello”;QString str2 &#x3D; “HELLO”;int result &#x3D; str1.compare（str2， Qt：：CaseInsensitive ）&#x2F;&#x2F; 结果将为 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        在这里，我们使用比较函数的可选第二个参数来指定比较应该不区分大小写。</p><p>​        由于“Hello”和“HELLO”仅在大小写上有所不同，因此结果将为0，表示两个QString相等。</p><p>​        我们最建议使用的是Compare函数，他速度很快。</p><h3 id="字符串向其他类型转化"><a href="#字符串向其他类型转化" class="headerlink" title="字符串向其他类型转化"></a>字符串向其他类型转化</h3><p>​        我们可以把字符串在可以的情况下转化为其他类型：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString str &#x3D; &quot;125&quot;;bool ok;int dec &#x3D; str.toInt(&amp;ok);if(!ok)qDebug() &lt;&lt; &quot;Failed to translate&quot;;else    qDebug() &lt;&lt; dec;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230829191643468.png" alt="image-20230829191643468"></p><p>​        也可以转化为其他格式的字符串：</p><ol><li>toAscii转化为一个八位字符串</li><li>toLatin1转化为一个Latin-1(ISO8859-1)编码的8位字符串</li><li>toUtf8转化为utf8字符串</li><li>toLocal8Bit字符串</li></ol><h1 id="Related-Docs"><a href="#Related-Docs" class="headerlink" title="Related Docs"></a>Related Docs</h1><p><a href="http://qt5.digitser.top/5.15/zh-CN/classes.html">所有类 | Qt 5.15 - 中文文档编制,帮助,手册,教程 (digitser.top)</a></p><p>​        也可以查看我的github仓库：<a href="https://github.com/Charliechen114514/MyTranslatedQtDocument-CN/tree/master/Basic C%2B%2B Class/S">MyTranslatedQtDocument-CN/Basic C++ Class/S at master · Charliechen114514/MyTranslatedQtDocument-CN (github.com)</a></p><h1 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h1><p>​        我们下面要谈到的是容器类！容器！我想大伙第一反应就是STL的容器。正确的！Qt的容器类是类似的。</p><p>​        他可以存储我们<strong>绝大部分</strong>的容器（意味深长），基本的数据类型，Qt的简单的数据类型，都可以存放在容器里，但是，<strong>类似于QWidget和QDialog</strong>一类的玩意不可以存储，更详细的讲：一切<strong>QObject和他的派生子类</strong>都不可以存在容器里：他们甚至没法通过编译：</p><pre class="line-numbers language-none"><code class="language-none">QList&lt;QToolBar&gt; list; &#x2F;&#x2F; compiling Fails!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        但是，这不是意味着存不了，而是转向存储他们的指针</p><pre class="line-numbers language-none"><code class="language-none">QList&lt;QToolBar*&gt; list; &#x2F;&#x2F; Accessible!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="QList-QLinkedList-QVector"><a href="#QList-QLinkedList-QVector" class="headerlink" title="QList, QLinkedList, QVector"></a><code>QList, QLinkedList, QVector</code></h1><h2 id="QList"><a href="#QList" class="headerlink" title="QList"></a><code>QList</code></h2><p>​        这是真的很常用，本人开发的一些小工具的首选容器！他们之间的对比如下：</p><div class="table-container"><table><thead><tr><th>容器类</th><th>查找</th><th>插入</th><th>头插</th><th>尾插</th></tr></thead><tbody><tr><td><code>QList</code></td><td><code>O(1)</code></td><td><code>O(n)</code></td><td><code>Amort O(1)</code></td><td><code>Amort O(1)</code></td></tr><tr><td><code>QLinkedList</code></td><td><code>O(1)</code></td><td><code>O(1)</code></td><td><code>O(1)</code></td><td><code>O(1)</code></td></tr><tr><td><code>QVector</code></td><td><code>O(1)</code></td><td><code>O(n)</code></td><td><code>O(n)</code></td><td><code>Amort O(1)</code></td></tr></tbody></table></div><p>​        我们来看一个demo:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QCoreApplication&gt;#include &lt;QList&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    QList&lt;QString&gt; myList;    for(int i &#x3D; 0; i &lt; 10; i++)    &#123;        QString tmp &#x3D; &quot;this is number: &quot; + QString::number(i);        myList &lt;&lt; tmp;    &#125;    for (int i &#x3D; 0; i &lt; myList.size();i++) &#123;        qDebug () &lt;&lt; myList[i];    &#125;    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们使用了list 的 &lt;&lt; 方法， 他等价于<code>push_back</code>方法！</p><h2 id="QLinkedList"><a href="#QLinkedList" class="headerlink" title="QLinkedList"></a><code>QLinkedList</code></h2><p>​        如名称一致——链表，正儿八经的链表！我建议——当你的元素需要频繁的插取的时候，直接使用这个容器会好得多！</p><h2 id="QVector"><a href="#QVector" class="headerlink" title="QVector"></a><code>QVector</code></h2><p>​        STL 的vector，这里是一样的，我们还有QPolygon, QPolygonF, QStack等容器来自这个容器！</p><h2 id="一些迭代器"><a href="#一些迭代器" class="headerlink" title="一些迭代器"></a>一些迭代器</h2><p>​        这里不打算讲，但是可以注意的是，迭代器分为Java风格的和STL风格的，Java风格的迭代器可以参看Qt官网</p><h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><p>​        下面我们开始讲点新东西——也就是控件！</p><h2 id="摁扭类"><a href="#摁扭类" class="headerlink" title="摁扭类"></a>摁扭类</h2><p>​        我们常见的基础类摁扭有：</p><ul><li>PushButton 普通按钮</li><li>ToolButton 工具按钮</li><li>RadioButton 单选按钮</li><li>CheckBox 复选框</li><li>Command Link Button 命令链接摁扭</li><li>对话框按钮盒</li></ul><p>​        拖出来给大伙看一眼</p><p><img src="image-20230831165050603.png" alt="image-20230831165050603"></p><p>​        我们下面来设计一下，构建一个自定义的按钮，这一次我们构建的项目是QWidget(控件)， 我们构建一个叫做MyWidget的类，头文件记得添加这些头文件</p><pre class="line-numbers language-none"><code class="language-none">#include&lt;QPushButton&gt;#include&lt;QFont&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        头文件就可以不用动了</p><p>​        然后就是书写代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;myidget.h&quot;Myidget::Myidget(QWidget *parent)    : QWidget(parent)&#123;    setMinimumSize(200,120);    setMaximumSize(200,120);    QPushButton* quit &#x3D; new QPushButton(&quot;Quit&quot;, this);    quit-&gt;setGeometry(60,40,75,30);    quit-&gt;setFont(QFont(&quot;Times&quot;, 18, QFont::Bold));    connect(quit, &amp;QPushButton::clicked, this, &amp;QWidget::close);&#125;Myidget::~Myidget()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        以及为了显示窗口不让他失踪，我们在main.cpp中有必要指定一下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;myidget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    Myidget w;    w.setGeometry(100,100,200,120); &#x2F;&#x2F; 设置一下大小    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230831170310308.png" alt="image-20230831170310308"></p><p>​        点击它，程序就结束了。</p><h2 id="输入部件"><a href="#输入部件" class="headerlink" title="输入部件"></a>输入部件</h2><p>​        常见的输入部件在这里：</p><ol><li>Combo Box 组合框</li><li>Font Combo Box 字体编辑框 （可以获得用户选择的字体！）</li><li>Line Edit 行编辑框</li><li>Text Edit 文本编辑框</li><li>Plain Text Edit 纯文本编辑框</li><li>Spin Box 数字显示框</li><li>Double Spin Box 双自旋盒</li><li>Time Edit 时间编辑</li><li>Date Edit 日期编辑</li><li>Date/Time Edit 时间日期编辑</li><li>Dial 拨号</li><li>Horizontal Scroll Bar 横向滚动条</li><li>Vertical Scroll Bar 纵向滚动条</li><li>Horizontal Slider 横向滑块</li><li>Vertical Slider 纵向滑块</li><li>Key Sequence Edit 按键序编辑框</li></ol><p><img src="image-20230831171224388.png" alt="image-20230831171224388"></p><p>​        还是一样，相关的设计已经集成在我的Qt CN Document仓库了</p><h2 id="显示控件"><a href="#显示控件" class="headerlink" title="显示控件"></a>显示控件</h2><p>​        下面的这些控件主要是用来展示内容的（Display）</p><ul><li>Label: 标签</li><li>TextBrowser 文本浏览器</li><li>Graphic View 图形视图</li><li>Calendar Widget 日历</li><li>LCD Number 液晶数字</li><li>Process Bar 进度条</li><li>Horizontal Line水平线</li><li>Vertical Line 铅垂线</li><li>OpenGL Widget OpenGL控件</li><li>QQuick Widget QML模块</li></ul><h2 id="容器组"><a href="#容器组" class="headerlink" title="容器组"></a>容器组</h2><ul><li>GroupBox</li><li>Scroll Area</li><li>Tool Box</li><li>Tab Widget</li><li>Stacked Widget</li><li>Frame</li><li>Widget</li><li>MDI Area</li><li>Dock Widget</li><li>QAxWidget</li></ul><h1 id="Qt5-布局"><a href="#Qt5-布局" class="headerlink" title="Qt5 布局"></a>Qt5 布局</h1><p>我们下面来看看布局问题：</p><h2 id="分割类QSpitter"><a href="#分割类QSpitter" class="headerlink" title="分割类QSpitter"></a>分割类QSpitter</h2><p><img src="image-20230904222839497.png" alt="image-20230904222839497"></p><p>​        我们可以这样应用QSplitter类帮助我们做这样的事情：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt;#include &lt;QSplitter&gt;#include &lt;QTextEdit&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    QFont font(&quot;ZYSong18030&quot;, 12);    a.setFont(font);    QSplitter *splitMainWindow &#x3D; new QSplitter(Qt::Horizontal, 0);    &#x2F;&#x2F; 主分割    QTextEdit* textLeft &#x3D; new QTextEdit(QObject::tr(&quot;Left Widget&quot;), splitMainWindow);    textLeft-&gt;setAlignment(Qt::AlignCenter);    &#x2F;&#x2F; right 分割    QSplitter* rightSplit &#x3D; new QSplitter(Qt::Vertical, splitMainWindow);    rightSplit-&gt;setOpaqueResize(false);    QTextEdit* textUp &#x3D;new QTextEdit(QObject::tr(&quot;Top Widget&quot;), rightSplit);    textUp-&gt;setAlignment(Qt::AlignCenter);    QTextEdit* textDown &#x3D;new QTextEdit(QObject::tr(&quot;bottom Widget&quot;), rightSplit);    textDown-&gt;setAlignment(Qt::AlignCenter);    splitMainWindow-&gt;setStretchFactor(1,1);    splitMainWindow-&gt;setWindowTitle(QObject::tr(&quot;Splitter&quot;));    splitMainWindow-&gt;show();&#x2F;&#x2F;    MainWindow w;&#x2F;&#x2F;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，我们仔细瞧瞧代码：</p><pre class="line-numbers language-none"><code class="language-none">QSplitter *splitMainWindow &#x3D; new QSplitter(Qt::Horizontal, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        主分割窗口，我们并且还对窗口呈现主水平分割：人话如下：</p><p><img src="image-20230904223113085.png" alt="image-20230904223113085"></p><p>​        然后，在主窗口左侧插入一个TextEdit类，至于文本的对齐方式是：</p><div class="table-container"><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>Qt::AlignLeft</code></td><td>左对齐</td></tr><tr><td><code>Qt::AlignRight</code></td><td>右对齐</td></tr><tr><td><code>Qt::AlignCenter</code></td><td>居中对齐</td></tr><tr><td><code>Qt::AlignUp</code></td><td>顶对齐</td></tr><tr><td><code>Qt::AlignBottom</code></td><td>底对齐</td></tr></tbody></table></div><p>​        而<code>rightSplit-&gt;setOpaqueResize(false);</code>这句话的意思是：拖拽时不会实时更新显示，直接一条灰线。</p><h2 id="QDockWidget类"><a href="#QDockWidget类" class="headerlink" title="QDockWidget类"></a>QDockWidget类</h2><p>​        我们下面来看一个QDockWidget类的例子：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)&#123;    setWindowTitle(tr(&quot;DockWindows&quot;));    QTextEdit* text &#x3D; new QTextEdit(this);    text-&gt;setText(tr(&quot;Main Windows&quot;));    text-&gt;setAlignment(Qt::AlignCenter);    setCentralWidget(text);    &#x2F;&#x2F; Dock1    QDockWidget* dock &#x3D; new QDockWidget(tr(&quot;Dock1&quot;), this);    dock-&gt;setFeatures(QDockWidget::DockWidgetMovable);    dock-&gt;setAllowedAreas(Qt::LeftDockWidgetArea| Qt::RightDockWidgetArea);    QTextEdit* text1 &#x3D; new QTextEdit();    text1-&gt;setText(tr(&quot;Window1, the dock widget can be moved between docks by the user&quot;));    dock-&gt;setWidget(text1);    addDockWidget(Qt::RightDockWidgetArea, dock);    QDockWidget* dock1 &#x3D; new QDockWidget(tr(&quot;DockWindow2&quot;),this);\    dock1-&gt;setFeatures(QDockWidget::DockWidgetFloatable | QDockWidget::DockWidgetClosable);    QTextEdit* text2 &#x3D; new QTextEdit();    text2-&gt;setText(tr(&quot;Windows2, the dock widget can be detached from the mainWindow, and floated as an independent window&quot;));    dock1-&gt;setWidget(text2);    addDockWidget(Qt::RightDockWidgetArea, dock1);    QDockWidget* dock2 &#x3D; new QDockWidget(tr(&quot;DockWindow2&quot;),this);    dock2-&gt;setFeatures(QDockWidget::AllDockWidgetFeatures);    QTextEdit* text3 &#x3D; new QTextEdit();    text2-&gt;setText(tr(&quot;Windows2, the dock widget can be detached from the mainWindow, and floated as an independent window&quot;));    dock1-&gt;setWidget(text3);    addDockWidget(Qt::RightDockWidgetArea, dock2);&#125;MainWindow::~MainWindow()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230905200515557.png" alt="image-20230905200515557"></p><p>​        看起来不错！</p><h2 id="QStackedWidget类"><a href="#QStackedWidget类" class="headerlink" title="QStackedWidget类"></a>QStackedWidget类</h2><p><img src="image-20230905201906477.png" alt="image-20230905201906477"></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; mainWindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QListWidget&gt;#include &lt;QLabel&gt;#include &lt;QStackedWidget&gt;#include &lt;QHBoxLayout&gt;class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    MainWindow(QWidget *parent &#x3D; 0);    ~MainWindow();private:    QListWidget* list;    QStackedWidget* stack;    QList&lt;QLabel*&gt; labelList;&#125;;#endif &#x2F;&#x2F; MAINWINDOW_H#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)&#123;    QWidget* widget &#x3D; new QWidget(this);    setCentralWidget(widget);    this-&gt;setWindowTitle(&quot;Stacked Test&quot;);    list &#x3D; new QListWidget(widget);    list-&gt;insertItem(0, tr(&quot;window1&quot;));    list-&gt;insertItem(1, tr(&quot;window2&quot;));    list-&gt;insertItem(2, tr(&quot;window3&quot;));    labelList.push_back(new QLabel(tr(&quot;WindowTest1&quot;)));    labelList.push_back(new QLabel(tr(&quot;WindowTest2&quot;)));    labelList.push_back(new QLabel(tr(&quot;WindowTest3&quot;)));    stack &#x3D; new QStackedWidget(widget);    for(int i &#x3D; 0; i &lt; 3; i++)       stack-&gt;addWidget(labelList[i]);    QHBoxLayout *mainLay &#x3D; new QHBoxLayout(widget);    mainLay-&gt;setMargin(5); &#x2F;&#x2F; 设置边距    mainLay-&gt;setSpacing(5);    mainLay-&gt;addWidget(list);    mainLay-&gt;addWidget(stack,0,Qt::AlignCenter);    mainLay-&gt;setStretchFactor(list, 1);    mainLay-&gt;setStretchFactor(stack, 3);    connect(list, &amp;QListWidget::currentRowChanged, stack, &amp;QStackedWidget::setCurrentIndex);&#125;MainWindow::~MainWindow()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Qt基本布局"><a href="#Qt基本布局" class="headerlink" title="Qt基本布局"></a>Qt基本布局</h2><p>​        简单的讲，我们的QT布局如下：</p><p><img src="image-20230905202309121.png" alt="image-20230905202309121"></p><p>​        好了，常见的基本控件和其他的定西都说完了</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux漫游——时间与系统限制</title>
      <link href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E4%B8%8E%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6/"/>
      <url>/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E4%B8%8E%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>​        </p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><p>程序可能会关注两种时间类型。</p><ul><li>真实时间：度量这一时间的起点有二：一为某个标准点；二为进程生命周期内的某个固定时点（通常为程序启动）。前者为日历（calendar）时间，适用于需要对数据库记录或文件打上时间戳的程序；后者则称之为流逝（elapsed）时间或挂钟（wall clock）时间，主要针对需要周期性操作或定期从外部输入设备进行度量的程序。</li><li>进程时间：一个进程所使用的 CPU 时间总量，适用于对程序、算法性能的检查或优化。大多数计算机体系结构都内置有硬件时钟，使内核得以计算真实时间和进程时间。本章将介绍系统调用对这两种时间的处理，以及在可读时间和机器时间之间互相转换的库函数。由于可读时间的表现形式与地理位置、语言和文化习俗有关，讨论这一话题自然引出对时区和地区的研究。</li></ul><h2 id="10-1-日历时间（Calendar-Time）"><a href="#10-1-日历时间（Calendar-Time）" class="headerlink" title="10.1 日历时间（Calendar Time）"></a>10.1 日历时间（Calendar Time）</h2><p>​        无论地理位置如何，UNIX 系统内部对时间的表示方式均是以自 Epoch 以来的秒数来度量的，Epoch 亦即通用协调时间（UTC，以前也称为格林威治标准时间，或 GMT）的 1970 年 1月 1 日早晨零点。这也是 UNIX 系统问世的大致日期。日历时间存储于类型为 time_t 的变量中，此类型是由 SUSv3 定义的整数类型。</p><p>​        在 32 位 Linux 系统，time_t 是一个有符号整数，可以表示的日期范围从 1901 年 12 月13 日 20 时 45 分 52 秒至 2038 年 1 月 19 号 03:14:07。（SUSv3 未定义 time_t 值为负数时的含义。）因<strong>此，当前许多 32 位 UNIX 系统都面临一个 2038 年的理论问题，如果执行的计算工作涉及未来日期，那么在 2038 年之前就会与之遭遇。事实上，到了 2038 年，可能所有的 UNIX 系统都早已升级为 64 位或更多位数的系统，这一问题也许会随之而大为缓解。</strong>然而，32 位嵌入式系统，由于其寿命较之台式机硬件更长，故而仍然会受此问题的困扰。此外，对于依然以 32 位 time_t 格式保存时间的历史数据和应用程序，这个问题将依然存在。</p><p>​        系统调用 gettimeofday()，可于 tv 指向的缓冲区中返回日历时间。</p><p><img src="image-20230804163619916.png" alt="image-20230804163619916"></p><p>​        参数 tv 是指向如下数据结构的一个指针：</p><p><img src="image-20230804163626068.png" alt="image-20230804163626068"></p><p>​        虽然 tv_usec 字段能提供微秒级精度，但其返回值的准确性则由依赖于构架的具体实现来决定。tv_usec 中的 u 源于与之形似的希腊字母 μ（读音“mu”），在公制系统中表示百万分之一。在现代 X86-32 系统上，gettimeofday()的确可以提供微秒级的准确度（例如， Pentium 系统内置有时间戳计数寄存器，随每个 CPU 时钟周期而加一）。</p><p>​        gettimeofday()的参数 tz 是个历史产物。早期的 UNIX 实现用其来获取系统的时区信息，目前已遭废弃，应始终将其置为 NULL。如果提供了 tz 参数，那么将返回一个 timezone 的结构体，其内容为上次调用 settimeofday()时传入的 tz 参数（已废弃）值。该结构包含两个字段 tz_minuteswest 和 tz_dsttime。tz_minuteswest字段表示欲将本时区时间转换为 UTC 时间所必须增加的分钟数，如为负值，则表示此时区位于 UTC 以东（例如，如为欧洲中部时间，会提前 UTC 一小时，则将此字段设置为−60）。tz_dsttime 字段内为一个常量，意在表示这个时区是否强制施行夏令时（DST）制。正由于夏令时制度无法用一个简单算法加以表达，故而 tz 参数已遭废弃。（Linux 从未支持过此参数。）详情请参考 gettimeofday(2)手册页。time()系统调用返回自 Epoch 以来的秒数（和函数 gettimeofday()所返回的 tv 参数中 tv_sec字段的数值相同）。如果 timep 参数不为 NULL，那么还会将自 Epoch 以来的秒数置于 timep 所指向的位置。由于 time()会以两种方式返回相同的值，而使用时唯一可能出错的地方是赋予 timep 参数一个无效地址（EFAULT），因此往往会简单地采用如下调用（不做错误检查）：</p><pre class="line-numbers language-none"><code class="language-none">t &#x3D; time(NULL)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">之所以存在两个本质上目的相同的系统调用（time()和 gettimeofday()），自有其历史原因。早期的 UNIX 实现提供了 time()。而 4.3BSD 又补充了更为精确的 gettimeofday()系统调用。这时，再将 time()作为系统调用就显得多余，可以将其实现为一个调用 gettimeofday()的库函数。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="10-2-时间转换函数"><a href="#10-2-时间转换函数" class="headerlink" title="10.2 时间转换函数"></a>10.2 时间转换函数</h2><p>图 10-1 所示为用于在 time_t 值和其他时间格式之间相互转换的函数，其中包括打印输图 10-1：获取和使用日历时间的函数出。</p><p><img src="image-20230804163743895.png" alt="image-20230804163743895"></p><p>​        这些函数屏蔽了因时区、夏令时（DST）制和本地化等问题给转换所带来的种种复杂性。10.3 节将讨论时区（timezone），10.4 节将讨论地区（locale）。</p><h3 id="10-2-1-将-time-t-转换为可打印格式"><a href="#10-2-1-将-time-t-转换为可打印格式" class="headerlink" title="10.2.1 将 time_t 转换为可打印格式"></a>10.2.1 将 time_t 转换为可打印格式</h3><p>​        为了将 time_t 转换为可打印格式，ctime()函数提供了一个简单方法。把一个指向 time_t 的指针作为 timep 参数传入函数 ctime()，将返回一个长达 26 字节的字符串，内含标准格式的日期和时间，如下例所示：</p><p><img src="image-20230804163806321.png" alt="image-20230804163806321"></p><p>​        该字符串包含换行符和终止空字节各一。 ctime()函数在进行转换时，会自动对本地时区和 DST 设置加以考虑（10.3 节将解释这些设置的确定过程）。返回的字符串经由静态分配，下一次对 ctime()的调用会将其覆盖。SUSv3 规定，调用 ctime()、gmtime()、localTime()或 asctime()中的任一函数，都可能会覆盖由其他函数返回，且经静态分配的数据结构。换言之，这些函数可以共享返回的字符数组和 tm 结构体，某些版本的 glibc 也正是这样实现的。如果有意在对这些函数的多次调用间维护返回的信息，那么必须将其保存在本地副本中。ctime_r()是 ctime()的可重入版本。（21.1.2 节将解释重入。）该函数允许调用者额外指定一个指针参数，所指向的缓冲区（由调用者提供）用于返回时间字符串。本章所论及的其他函数的可重入版，其操作方式与之类似。</p><h3 id="10-2-2-time-t-和分解时间之间的转换"><a href="#10-2-2-time-t-和分解时间之间的转换" class="headerlink" title="10.2.2 time_t 和分解时间之间的转换"></a>10.2.2 time_t 和分解时间之间的转换</h3><p>​        函数 gmtime()和 localtime()可将一 time_t 值转换为一个所谓的分解时间（broken-down time)。分解时间被置于一个经由静态分配的结构中，其地址则作为函数结果返回。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;time.h&gt;struct tm* gmtime(const time_t *timep);struct tm* localtime(const time_t *timep);C <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        函数 gmtime()能够把日历时间转换为一个对应于 UTC 的分解时间。（字母 GM 源于格林威治标准时间）。相形之下，函数 localtime()需要考虑时区和夏令时设置，返回对应于系统本地时间的一个分解时间。gmtime_r()和 localtime_r()分别是这些函数的可重入版。在这些函数所返回的 tm 结构中，日期和时间被分解为多个独立字段，其形式如下：</p><p><img src="image-20230804163838144.png" alt="image-20230804163838144"></p><p>​        将字段 tm_sec 的上限设为 60（而非 59）以考虑闰秒，偶尔会用其将人类日历调整至精确的天文年（所谓的回归年）。</p><p>​        如果定义了_BSD_SOURCE 功能测试宏，那么由 glibc 定义的 tm 结构还会包含两个额外字段，以描述关于所示时间的深入信息。第一个字段 long int tm_gmtoff，包含所示时间超出UTC 以东的秒数。第二个字段 const char* tm_zone，是时区名称的缩写（例如，CEST 为欧洲中部夏令时间）。SUSv3 并未定义这些字段，它们只见诸于少数其他 UNIX 实现（主要为 BSD衍生版本）。函数 mktime() 将一个本地时区的分解时间翻译为 time_t 值，并将其作为函数结果返回。调用者将分解时间置于一个 tm 结构，再以 timeptr 指针指向该结构。这一转换会忽略输入 tm结构中的 tm_wday 和 tm_yday 字段。</p><p>​        函数 mktime()可能会修改 timeptr 所指向的结构体，至少会确保对 tm_wday 和 tm_yday 字段值的设置，会与其他输入字段的值能对应起来。此外，mktime()不要求 tm 结构体的其他字段受到前述范围的限制。任何一个字段的值超出范围，mktime()都会将其调整回有效范围之内，并适当调整其他字段。所有这些调整，均发生于 mktime()更新 tm_wday 和 tm_yday 字段并计算返回值 time_t 之前。例如，如果输入字段 tm_sec 的值为 123，那么在返回时此字段的值将为 3，且 tm_min 字段值会在其之前值的基础上加 2。（如果这一改动造成 tm_min 溢出，那么将调整 tm_min 的值，并且递增 tm_hour 字段，以此类推。）这些调整甚至适用于字段负值。例如，指定 tm_sec 为−1 即意味着前一分钟的第 59 秒。此功能允许以分解时间来计算日期和时间，故而非常有用。mktime()在进行转换时会对时区进行设置。此外，DST 设置的使用与否取决于输入字段tm_isdst 的值。</p><ul><li>若 tm_isdst 为 0，则将这一时间视为标准间（即，忽略夏令时，即使实际上每年的这一时刻处于夏令时阶段）。</li><li>若 tm_isdst 大于 0，则将这一时间视为夏令时（即，夏令时生效，即使每年的此时不处于夏令时阶段）。</li><li>若 tm_isdst 小于 0，则试图判定 DTS 在每年的这一时间是否生效。这往往是众望所归的设置。</li></ul><p>​        （无论 tm_isdst 的初始设置如何）在转换完成时，如果针对给定的时间，DST 生效，mktime()会将 tm_isdst 字段置为正值，若 DST 未生效，则将 tm_isdst 置为 0。</p><h3 id="10-2-3-分解时间和打印格式之间的转换"><a href="#10-2-3-分解时间和打印格式之间的转换" class="headerlink" title="10.2.3 分解时间和打印格式之间的转换"></a>10.2.3 分解时间和打印格式之间的转换</h3><p>​        本节会介绍将分解时间和打印格式相互进行转换的函数。从分解时间转换为打印格式在参数 tm 中提供一个指向分解时间结构的指针，asctime()则会返回一指针，指向经由静态分配的字符串，内含时间，格式则与 ctime ()相同。相形于 ctime()，本地时区设置对 asctime()没有影响，因为其所转换的是一个分解时间，该时间通常要么已然通过 localtime()作了本地化处理，要么早已经由 gmtime()转换成了 UTC。如同 ctime()一样，asctime()也无法控制其所生成字符串的格式。asctime()的可重入版为 asctime_r()。</p><p>​        程序清单 10-1 演示 asctime()以及直到本章结尾所述时间转换函数的用法。该程序获取当前的日历时间，随后使用各种时间转换函数并显示其结果。下例为冬季在德国慕尼黑运行此程序的结果，该地区处于欧洲中部时间这一时区，比 UTC 要早一小时。</p><p><img src="image-20230804164006234.png" alt="image-20230804164006234"></p><p>​        程序清单 10-1：获取和转换日历时间 </p><p><img src="image-20230804164020690.png" alt="image-20230804164020690"></p><p><img src="image-20230804164027751.png" alt="image-20230804164027751"></p><p>​        当把一个分解时间转换成打印格式时，函数 strftime()可以提供更为精确的控制。令 timeptr指向分解时间，strftime()会将以 null 结尾、由日期和时间组成的相应字符串置于 outstr 所指向的缓冲区中。</p><p><img src="image-20230804164107729.png" alt="image-20230804164107729"></p><p>​        outstr 中返回的字符串按照 format 参数定义的格式做了格式化。Maxsize 参数指定 outstr 的最大长度。不同于 ctime()和 asctime()，strftime()不会在字符串的结尾包括换行符（除非 format 中定义有换行符）。如果成功，strftime()返回 outstr 所指缓冲区的字节长度，且不包括终止空字节。如果结果字符串的总长度，含终止空字节，超过了 maxsize 参数，那么 strftime()会返回 0 以示出错，且此时无法确定 outstr 的内容。strftime()的 format 参数是一字符串，与赋予 printf()的参数相类似。冠以百分号（%）的字符序列是对转换的定义，函数会将百分号后的说明符字符一一替换为日期和时间的组成部分。这是一套相当丰富的转换说明符，表 10-1 中所列的是其一个子集。（完整的列表可见诸于strftime(3)手册页。）除非特别注明，所有这些转换说明符都符合 SUSv3 标准。%U 和%W 说明符都生成一年中的周数。%U 的周数按以下方法计算。含有星期日的第一周编号为 1，此周的前一周编号为 0。如果星期天恰巧是当年的第一天，那么就没有第 0 周，当年的最后一天则属于第 53 周。%W 的周数编号以同样的方式来计算，只不过计算对象是周一而非周日。通常情况下，我们希望在本书的各种示范程序中显示当前时间。为此，本书提供了函数currTime()，其返回一字符串，内含 strftime()按 format 参数格式化的当前时间。</p><p><img src="image-20230804164236600.png" alt="image-20230804164236600"></p><p><img src="image-20230804164247494.png" alt="image-20230804164247494"></p><p><img src="image-20230804164258094.png" alt="image-20230804164258094"></p><p>​        函数strptime()按照参数format内的格式要求，对由日期和时间组成的字符串str加以解析，并将转换后的分解时间置于指针 timeptr 所指向的结构体中。如果成功，strptime()返回一指针，指向 str 中下一个未经处理的字符。（如果字符串中还包含有需要应用程序处理的额外信息，这一特性就能派上用场。）如果无法匹配整个格式字符串，strptime()返回 NULL，以示出现错误。strptime()的格式规范类似于 scanf(3)，包含以下类型的字符。</p><ul><li>转换字符串冠以一个百分号（%）字符。</li><li>如包含空格字符，则意味着其可匹配零个或多个空格。</li><li>（%之外的）非空格字符必须和输入字符串中的相同字符严格匹配。</li></ul><p>​        转换说明类似于之前为 strftime()给出的内容（表 10-1）。主要的区别在于，此处的说明符更为通用。例如，不拘于星期名称的全称或简称，%a 和%A 都可接受，而且%d 和%e 均可用于读取月中的个位天数，无论该数字前面是否有 0。此外，不区分大小写，例如，May 和 MAY是相同的月份名称。使用字符串%%来匹配输入字符串中的百分号字符。 strptime(3)手册页提供有更多的细节。glibc 在实现 strptime()时，并不修改 tm 结构体中那些未获 format 说明符初始化的字段。这也意味着可以根据多个字符串，例如，一个日期字符串和一个时间字符串，发起多次 strptime()调用，来创建一个 tm 结构体。SUSv3 虽然允许这一行为，但并不强制要求实现，因此在其他UNIX 实现上不能对其有所依赖。要保证应用的可移植性，就必须确保，要么 str 和 format 中所含输入信息足以设置最终 tm 结构的所有字段，要么在调用 strptime()之前对 tm 结构体已经做了适当的初始化处理。在大多数情况下，用 memset()把整个结构体置为 0 也就足够了，但要留心，在 glibc 和许多其他时间转换函数的实现中，m_mday 字段值为 0，意为上月的最后一天。最后还要注意，strptime()从不设置 tm 结构体的 tm_isdst 字段。\</p><pre class="line-numbers language-none"><code class="language-none">GNU C 库还提供有与 strptime()功能类似的两个函数：getdate()（已由 SUSv3 规范，且应用广泛）及其可重入版 getdate_r()（SUSv3 中未定义，仅获少数 UNIX 实现支持）。此处将不会介绍这些函数，因为在指定用于扫描日期的格式时，它们所采用的是外部文件（由环境变量 DATEMSK 定义），这不但令其难以使用，而且会在 set-user-ID 程序中造成安全漏洞。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        程序清单 10-3 演示了 strptime()和 strftime()的用法。该程序从命令行参数中接受日期和时间，然后用 strptime()将其转换为一分解时间，接着使用 strftime()执行逆向转换并显示结果。该程序接收至多 3 个参数，其中前两个为必需提供。第一个参数是包含日期和时间的字符串。第二个参数指定了 strptime()在解析第一个参数时所采用的格式。可选的第三个参数是格式字符串，用于 strftime()的逆向转换。如果省略此参数，将使用一个默认的格式字符串。（本程序中使用的 setLocale()函数将在 10.4 节中加以介绍。）以下 shell 会话日志显示了使用该程序的一些例子：以下用法与之相似，只不过这次为 strftime()明确指定了格式：</p><h2 id="10-3-时区"><a href="#10-3-时区" class="headerlink" title="10.3 时区"></a>10.3 时区</h2><p>​        不同的国家（有时甚至是同一国家内的不同地区）使用不同的时区和夏时制。对于要输入和输出时间的程序来说，必须对系统所处的时区和夏时制加以考虑。所幸的是，所有这些细节都已经由 C 语言函数库包办了。</p><h3 id="时区定义"><a href="#时区定义" class="headerlink" title="时区定义"></a>时区定义</h3><p>​        时区信息往往是既浩繁又多变的。出于这一原因，系统没有将其直接编码于程序或函数库中，而是以标准格式保存于文件中，并加以维护。这些文件位于目录/usr/share/zoneinfo 中。该目录下的每个文件都包含了一个特定国家或地区内时区制度的相关信息，且往往根据其所描述的时区来加以命名，诸如 EST（美国东部标准时间）、CET（欧洲中部时间）、UTC、Turkey 和 Iran。此外，可以利用子目录对相关时区进行有层次的分组。例如，Pacific 目录就可能包含文件 Auckland、Port_Moresby 和 Galapagos。在程序中指定使用的时区，实际上是指定该目录下某一时区文件的相对路径名。系统的本地时间由时区文件/etc/localtime 定义，通常链接到/usr/share/zoneinfo 下的一个文件。时区文件的格式记述于 tzfile(5)手册页，其创建可通过 zic(8)（时区信息编译器，zoone information compiler）工具来完成。zdump(8)命令可根据指定时区文件中的时区来显示当前时间。为程序指定时区为运行中的程序指定一个时区，需要将 TZ 环境变量设置为由一冒号(:)和时区名称组成的字符串，其中时区名称定义于/usr/share/zoneinfo 中。设置时区会自动影响到函数 ctime()、localtime()、mktime()和 strftime()。为了获取当前的时区设置，上述函数都会调用 tzset(3)，对如下 3 个全局变量进行了初始化：</p><p><img src="image-20230804164549688.png" alt="image-20230804164549688"></p><p>​        函数 tzset()会首先检查环境变量 TZ。如果尚未设置该变量，那么就采用<code>/etc/localtime</code> 中定义的默认时区来初始化时区。如果 TZ 环境变量的值为空，或无法与时区文件名相匹配，那么就使用 UTC。还可将 TZDIR 环境变量（非标准的 GNU 扩展）设置为搜寻时区信息的目录名称，以替代默认的/usr/share/zoneinfo 目录。可以通过运行程序清单 10-4 中的程序来观察 TZ 变量的影响力。第一次运行输出的是相应系统的默认时区（欧洲中部时间，CET）。在第二次运行时，由于指定的时区为 New Zealand，其在每年此时已进入夏令时，时区要比 CET 提前 12 个小时。</p><p><img src="image-20230804164511390.png" alt="image-20230804164511390"></p><p>​        程序清单 10-4：演示时区和地区的效果 </p><p><img src="image-20230804164606144.png" alt="image-20230804164606144"></p><p>​        SUSv3 为设置 TZ 环境变量定义了两个通用方法。如前所述，可将 TZ 设置为由冒号外加字符串组成的字符序列，其中的字符串用以标识时区，并随系统实现的不同而不同，通常为时区描述文件的路径名。（在采用这种形式时，Linux 和其他一些 UNIX 实现允许将冒号省略，但 SUSv3 并未规范这一行为。为了保证代码的可移植性，应当始终包含冒号。）设置 TZ 的另一种方法在 SUSv3 中有完整的定义。使用此方法，可以将如下形式的字符串赋给 TZ：</p><p><img src="image-20230804164615780.png" alt="image-20230804164615780"></p><p>​        为了便于阅读，在上面这行字符串中加入了空格，但实际上任何空格都不应出现在 TZ 中。方括号（[]）用来表示可选项。std 和 dst 部分是用以标识标准和 DST 时区名称的字符串。例如，CET 和 CEST 分别为欧洲中部时间和欧洲中部夏令时间。各种情况下的 offset 分别表示欲转换为 UTC，需要叠加在本地时间上的正、负调整值。最后四部分则提供了一个规则，描述何时从标准时间变更为夏令时。可以多种格式指定 date，其中之一是 Mm.n.d，意即：m(1～12)月中，第 n（1～5，每月的最后 d 天总为第 5 周）周，星期 d（0=星期一，6=星期天）。如果省略 time，则无论何种情况下均默认为 02:00:00（上午 2 点）。以下将 TZ 定义为 Central Europe ，该时区的标准时间比 UTC 提前 1 小时，且 DST 始于3 月的最后一个星期日，直至 10 月的最后一个星期日结束，提前 UTC 2 小时。</p><p><img src="image-20230804164639081.png" alt="image-20230804164639081"></p><p>​        此处省略了对 DST 转换时间的指定，因为默认其发生于 02:00:00。显然，较之于如下的Linux 专有格式，上述形式的确缺乏可读性：</p><p><img src="image-20230804164647783.png" alt="image-20230804164647783"></p><h2 id="10-4-地区（Locale）"><a href="#10-4-地区（Locale）" class="headerlink" title="10.4 地区（Locale）"></a>10.4 地区（Locale）</h2><p>​        世界各地在使用数千种语言，其中在计算机系统上经常使用的占了相当比例。此外，在显示诸如数字、货币金额、日期和时间之类的信息时，不同国家的习俗也不同。例如，大多数欧洲国家使用逗号，而非小数点来分隔实数的整数和小数部分，大多数国家日期的书写格式也与美国所采用的 MM/DD/ YY 格式并不相同。SUSv3 对 locale 的定义为：用户环境中依赖于语言和文化习俗的一个子集。理想情况下，意欲在多个地理区位运行的任何程序都应处理地区（locales）概念，以期以用户的语言和格式来显示和输入信息。这也构成了一个相当复杂的课题——国际化（internationalization)。在理想情况下，程序只要一次经编写，则不论运行于何处，总会自动以正确方式来执行 I/O 操作，也就是说，完成本地化（localization)任务。尽管存在各种支持工具，程序国际化工作依然耗时不菲。诸如 glibc 之类的程序库也提供有工具，来帮助程序支持国际化。经常将术语 internationalization 写为 I18N，意即：I 加上 18 个字母再加 N。这一形式既便于快速书写，又避免了单词本身在英语和美语间拼写方式不同的问题。</p><h3 id="地区定义"><a href="#地区定义" class="headerlink" title="地区定义"></a>地区定义</h3><p>​        和时区信息一样，地区信息同样是既浩繁且多变的。出于这一原因，与其要求各个程序和函数库来存储地区信息，还不如由系统按标准格式将地区信息存储于文件中，并加以维护。地区信息维护于/usr/share/local（在一些发行版本中为/usr/lib/local）之下的目录层次结构中。该目录下的每个子目录都包含一特定地区的信息。这些目录的命名约定如下：language 是双字母的 ISO 语言代码。territory 是双字母的 ISO 国家代码。codeset 表示字符编码集。modifier 则提供了一种方法，用以区分多个地区目录下 language、territory 和 codeset均相同的状况。de_DE.utf-8@euro 是完整地区目录名称的例子之一，代表地区如下：德语，德国，UTF - 8 字符编码，并采用欧元作为货币单位。正如命名格式中的方括号所示，可以将地区目录名称中的相应部分省略。通常情况下，命名只包括语言和国家。因此，en_US 是（说英语的）美国的地区目录，而 fr_CH 则是瑞士法语区的地区目录。这里 CH 代表 Confoederatio Helvetica，在拉丁语（本地中性语言，locally language-neutra)中意即“瑞士”。由于有 4 门官方语言，瑞士在地区上类似于跨多个时区的国家。当在程序中指定要使用的地区时，实际上是指定了/usr /share/locale 下某个子目录的名称。如果程序指定地区不与任何子目录名称相匹配，那么 C 语言函数库将按如下顺序将各部分从指定地区（locale）中剥离，以寻求匹配：</p><p>1.codeset </p><p>2.normalized codeset </p><p>3.territory </p><p>4.modifier </p><p>​        标准化字符编码集（normalized codeset）是一个特定版本字符编码集的名称，剔除了所有非字母、非数字的字符，且将所有字母转换为小写，最终字符串前冠以 ISO 三个字符。标准化的目的，在于排除字符集名称中因大小写和标点符号（例如，额外的连字符）而发生的变化。这里是剥离过程的一个例子，假设为一程序指定的地区为 fr_CH.utf- 8，但并不存在以该名称命名的地区目录，那么如果 fr_CH 目录存在，则与之匹配。如果 fr_CH 目录也不存在，那么将采用 fr 地区目录。万一 fr 目录也不存在，那么简而言之，setLocale()函数将会报错。/user/share/locale/locale.alias 文件定义了为程序设定地区的替代方法。详见locale.aliases(5)手册页。每个地区子目录中包括有标准的一套文件，指定了此地区的约定设置，如表 10-2 所示。关于本表中的信息，还要注意以下几点。</p><ul><li>文件 LC_COLLATE 定义了一套规则，描述了如何在一字符集内对字符排序（例如alphabetical“按字母顺序排列的”字符集顺序）。这些规则将决定函数 strcoll(3)和strxfrm(3)的动作。即便是同属拉丁语系的语言，其遵循的排序规则也不相同。例如，一些欧洲语言有额外字母，在某些情况下排在字母 Z 之后。另外还有特殊情况，西班牙语的双字母序列 ll，排序时位于字母 l 之后。又比如德语的元音变音字符 ä，对应于ae，并与该双字母排在相同位置。</li><li>目录 LC_MESSAGES 是程序显示信息迈向国际化的步骤之一。要实现更为全面的程序信息国际化，可以采用消息目录（参考 catopen(3)和 catgets(3)手册页）或是 GNU 的gettext API（参见 <a href="http://www.gnu.org/）。">http://www.gnu.org/）。</a></li></ul><pre class="line-numbers language-none"><code class="language-none">Glibc 的 2.2.2 版引入了一系列非标准的地区新类别。LC_ADDRESS 定义了特定于地区的邮政地址表示规则。LC_IDENTIFICATION 指定了识别地区的信息。LC_MEASUREMENT定义了地区的度量系统（例如，公制&#x2F;英制）。LC_NAME 定义了特定于地区的人名及头衔表示规则。LC_PAPER 定义了该地区的标准纸张尺寸（例如，美国信纸&#x2F;其他大多数国家所使用的 A4 纸）。LC_TELEPHONE 则定义了特定于地区的国内及国际电话号码表示规则，以及国际长途国家代码和国际拨号前缀。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230804165050326.png" alt="image-20230804165050326"></p><p>​        系统中实际定义的地区可能会各有不同。除了必须定义一个名为 POSIX（与 C 同义，后者的存在是由于历史原因）的标准地区外，SUSv3 没有对此作出任何要求。POSIX 折射出 UNIX系统的历史渊源。因之，系统建立于 ASCII 字符集之上，使用英文来描述日期，并以“yes/no”来响应。该地区的货币和数字格式则处于未定义状态。</p><p>​        locale 命令显示当前地区环境（本 shell 内）的相关信息。命令 locale – a 则将列出系统上定义的整套地区。</p><h4 id="为程序设置地区"><a href="#为程序设置地区" class="headerlink" title="为程序设置地区"></a>为程序设置地区</h4><p>​        函数 setlocale()既可设置也可查询程序的当前地区。</p><p><img src="image-20230804165059134.png" alt="image-20230804165059134"></p><p>​        category 参数选择设置或查询地区的哪一部分，它仅能使用表 10-2 中列出的地区类别的常量名称。因此，它可以设置地区的时间显示格式是德国，而地区的货币符号是美元。或者，更常见的是，我们可以利用 LC_ALL 来指定我们要设置的地区的所有部分的值。使用 setLocale()设置地区有两种不同的方法。locale 参数可能是一个字符串，指定系统上已定义的一个地区（例如，/usr /lib /locale 中的子目录的名称），如 de_DE 或 en_US。另外，地区可能被指定为空字符串，这意味着从环境变量取得地区的设置。我们必须这样调用才能使程序使用环境变量中的地区。如果调用被省略，这些环境变量将不会对程序生效。当运行程序调用了 setLocale(LC_ALL，” “)，我们能够使用一系列环境变量来控制地区的各部分内容，环境变量的名称也是对应于表 10-2 中列出的类型：LC_CTYPE、LC_COLLATE、LC_MONETARY、LC_NUMERIC、LC_TIME、LC_MESSAGES。另外，我们可以使用 LC_ALL或 LANG 环境变量指定整个地区的设置。如果设置了多个先前的环境变量，那么 LC_ALL会覆盖所有其他的 LC_ *环境变量，同时 LANG 的优先级最低。因此，通常使用 LANG 为地区所有内容设置默认值，然后用单独的 LC_*变量，设置地区的各个方面内容来覆盖默认值。</p><p>​        最后，setLocale()返回一个指针指向标识这一类地区设置的字符串（通常是静态分配的）。如果我们仅需要查看地区的设置而不需要改变它，那么我们可以指定 locale 参数为NULL。</p><p>​        地区设置影响众多 GNU/ Linux 实用程序，以及 glibc 的许多函数的功能。其中有函数strftime()和 strptime()（10.2.3 节），当我们在不同的地区运行程序清单 10-4，strftime 返回的结果如下：</p><p><img src="image-20230804165231764.png" alt="image-20230804165231764"></p><p>​        下一个运行演示 LC_TIME 比 LANG 的优先级高：</p><p><img src="image-20230804165221818.png" alt="image-20230804165221818"></p><p>而这个运行结果表明，LC_ALL 超过 LC_TIME 的优先级：</p><p><img src="image-20230804165313746.png" alt="image-20230804165313746"></p><h2 id="10-5-更新系统时钟"><a href="#10-5-更新系统时钟" class="headerlink" title="10.5 更新系统时钟"></a>10.5 更新系统时钟</h2><p>​        我们现在来看两个更新系统时钟的接口：settimeofday()和 adjtime()。这些接口都很少被应用程序使用，因为系统时间通常是由工具软件维护，如网络时间协议（Network Time Protocol）守护进程，并且它们需要调用者已被授权（CAP_SYS_TIME）。系统调用 settimeofday()是 gettimeofday()的逆向操作（这是我们在 10.1 节中描述的）。它将 tv 指向 timeval 结构体里的秒数和微秒数，设置到系统的日历时间。</p><p><img src="image-20230804165325752.png" alt="image-20230804165325752"></p><p>​        和函数 gettimeofday()一样，tz 参数已被废弃，这个参数应该始终指定为 NULL。tv.tv_usec 字段的微秒精度并不意味着我们以微秒精度来设置系统时钟，因为时钟的精度可能会低于微秒。虽然 SUSv3 没有定义 settimeofday()，但它在其他 UNIX 实现中被广泛使用。Linux 还提供了 stime()系统调用来设置系统时钟。settimeofday()和 stime()之间的区别是，后者调用允许使用秒的精度来表示新的日历时间。和函数 time()与 gettimeofday()相同，stime()和 settimeofday()的并存是由历史原因造成的：拥有更高精确度的后一个函数，是由4.3BSD 添加的。</p><p>​        settimeofday()调用所造成的那种系统时间的突然变化，可能会对依赖于系统时钟单调递增的应用造成有害的影响（例如，make(1)，数据库系统使用的时间戳或包含时间戳记的日志文件）。出于这个原因，当对时间做微小调整时（几秒钟误差），通常是推荐使用库函数 adjtime()，它将系统时钟逐步调整到正确的时间。</p><p><img src="image-20230804165359114.png" alt="image-20230804165359114"></p><p>​        delta 参数指向一个 timeval 结构体，指定需要改变时间的秒和微秒数。如果这个值是正数，那么每秒系统时间都会额外拨快一点点，直到增加完所需的时间。如果 delta 值为负时，时钟以类似的方式减慢。Linux/x86-32 以每 2000 秒变化 1 秒（或每天 43.2 秒）的频率调整时钟。在 adjtime()函数执行的时间里，它可能无法完成时钟调整。在这种情况下，剩余未经调整的时间存放在 olddelta 指向的 timeval 结构体内。如果我们不关心这个值，我们可以指定olddelta 为 NULL。相反，如果我们只关心当前未完成时间校正的信息，而并不想改变它，我们可以指定 delta 参数为 NULL。虽然 SUSv3 未定义 adjtime()，可大多数 UNIX 实现提供了这个函数。adjtime()在 Linux 上，基于更通用和复杂的特定于 Linux 的系统调用 adjtimex()来完成功能。这个系统调用也同时被网络时间协议（NTP）守护进程调用。如需进一步信息，请参阅 Linux 的源代码，Linux adjtimex(2)帮助手册页和 NTP 规范（[Mills，1992]）。</p><h2 id="10-6-软件时钟（jiffies）"><a href="#10-6-软件时钟（jiffies）" class="headerlink" title="10.6 软件时钟（jiffies）"></a>10.6 软件时钟（jiffies）</h2><p>​        在本书中所描述的时间相关的各种系统调用的精度是受限于系统软件时钟（software clock)的分辨率，它的度量单位被称为 jiffies。jiffies 的大小是定义在内核源代码的常量 HZ。这是内核按照 round-robin 的分时调度算法（35.1 节）分配 CPU 进程的单位。在 2.4 或以上版本的 Linux/x86-32 内核中，软件时钟速度是 100 赫兹，也就是说，一个 jiffy是 10 毫秒。自 Linux 面世以来，由于 CPU 的速度已大大增加，Linux / x86- 32 2.6.0 内核的软件时钟速度已经提高到 1000 赫兹。更高的软件时钟速率意味着定时器可以有更高的操作精度和时间可以拥有更高的测量精度。然而，这并非可以任意提高时钟频率，因为每个时钟中断会消耗少量的 CPU 时间，这部分时间 CPU 无法执行任何操作。经过内核开发人员之间的的讨论，最终导致软件时钟频率成为一个可配置的内核的选项（包括处理器类型和特性，定时器的频率）。自 2.6.13 内核，时钟频率可以设置到 100、250（默认）或 1000 赫兹，对应的 jiffy 值分别为 10、4、1 毫秒。自内核 2.6.20，增加了一个频率：300 赫兹，它可以被两种常见的视频帧速率 25 帧每秒（PAL）和 30 帧每秒（NTSC）整除。</p><h2 id="10-7-进程时间"><a href="#10-7-进程时间" class="headerlink" title="10.7 进程时间"></a>10.7 进程时间</h2><p>进程时间是进程创建后使用的 CPU 时间数量。出于记录的目的，内核把 CPU 时间分成以下两部分。</p><ul><li>用户 CPU 时间是在用户模式下执行所花费的时间数量。有时也称为虚拟时间（virtual time），这对于程序来说，是它已经得到 CPU 的时间。</li><li>系统 CPU 时间是在内核模式中执行所花费的时间数量。这是内核用于执行系统调用或代表程序执行的其他任务（例如，服务页错误）的时间。</li></ul><p>​        有时候，进程时间是指处理过程中所消耗的总 CPU 时间。当我们运行一个 shell 程序，我们可以使用的 time(1)命令，同时获得这两个部分的时间值，以及运行程序所需的实际时间。</p><p><img src="image-20230804165443242.png" alt="image-20230804165443242"></p><p>​        系统调用 times()，检索进程时间信息，并把结果通过 buf 指向的结构体返回。</p><p><img src="image-20230804165452857.png" alt="image-20230804165452857"></p><p>​        buf 指向的 TMS 结构体有下列格式：</p><p><img src="image-20230804165500664.png" alt="image-20230804165500664"></p><p>​        tms 结构体的前两个字段返回调用进程到目前为止使用的用户和系统组件的 CPU 时间。最后两个字段返回的信息是：父进程（比如，times()的调用者）执行了系统调用 wait()的所有已经终止的子进程使用的 CPU 时间。数据类型 clock_t 是用时钟计时单元（clock tick）为单位度量时间的整型值，习惯用于计算 tms 结构体的 4 个字段。我们可以调用 sysconf(_SC_CLK_TCK)来获得每秒包含的时钟计时单元数，然后用这个数字除以 clock_t 转换为秒。（我们在 11.2 节叙述 sysconf()。）在大多数 Linux 的硬件架构，sysconf(_SC_CLK_TCK)返回 100。与此对应的内核常量是 USER_HZ。然而 USER_HZ 在其他几个架构下可以被定义超过 100，如 Alpha 和 IA - 64。如果成功，times()返回自过去的任意点流逝的以时钟计时单元为单位的（真实的）时间。SUSv3特别未定义这点是什么，只是说，这将是在调用进程的生命周期内的一个固定点。因此，这个返回值唯一的用法是通过计算一对 times()调用返回的值的差，来计算进程执行消耗的时间。然而，即使是这种用法，times()的返回值仍然不可靠的，因为它可能会溢出clock_t的有效范围，这时times()的返回值将再次从 0 开始计算（也就是说，一个稍后的 times()的调用返回的数值可能会低于一个更早的 times()调用）。可靠的测量经过时间的方法是使用函数 gettimeofday()（10.1 节所述）。在 Linux 上，我们可以指定 buf 参数为 NULL。在这种情况下，times()只是简单地返回一个函数结果。然而，这是没有意义的。 SUSv3 并未定义 buf 可以使用 NULL，因此许多其他UNIX 实现需要这个参数必须为一个非 NULL 值。函数 clock()提供了一个简单的接口用于取得进程时间。它返回一个值描述了调用进程使用的总的 CPU 时间（包括用户和系统）。</p><p><img src="image-20230804165534863.png" alt="image-20230804165534863"></p><p>​        time()的返回值的计量单位是 CLOCKS_PER_SEC，所以我们必须除以这个值来获得进程所使用的 CPU 时间秒数。在 POSIX.1，CLOCKS_PER_SEC 是常量 10000，无论底层软件时钟（10.6 节）的分辨率是多少。clock()的精度最终仍然受限于软件时钟的分辨率。虽然 clock()和 times()返回相同的数据类型 clock_t，这两个接口使用的测量单位却并不相同。这是历史原因造成了 clock_t 定义的冲突，一个是 POSIX.1 标准，而另一个是 C 编程语言标准。即使 CLOCKS_PER_SEC 是常量 10000，SUSv3 注明，这个常量在不兼容 XSI（non-XSI￾conformant)的系统上可以为整型变量，所以，我们不能简单地把它作为一个编译时常量（即，我们不能够使用＃ifdef 预处理表达式）。它可能会被定义为一个长整数（即 1000000L），我们总是将这个常量转换为 long，因此我们可以简单地用 printf() 把它打印输出（见 3.6.2 节）。SUSv3 描述 clock()应该返回“进程所使用的处理器时间”时有不同的解释。在一些 UNIX的实现中，clock()返回的时间包含所有等待子进程使用的 CPU 时间。而在 Linux 上，它不包括。</p><h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><p>​        在程序清单 10-5 中的程序演示了如何使用本节中描述的功能。函数 displayProcessTimes()首先打印由调用者提供的信息，然后使用 clock()和 times()来获得和显示进程时间。主程序首先调用函数 displayProcessTimes()，然后执行一个循环，通过重复调用 getppid()消耗一些 CPU时间，再次调用 displayProcessTimes()来查看这个循环会消耗多少 CPU 时间。当我们使用这个程序调用 getppid()十万次，这就是我们看到的：程序清单 10-5：获取进程 CPU 时间 </p><h2 id="10-8-总结"><a href="#10-8-总结" class="headerlink" title="10.8 总结"></a>10.8 总结</h2><p>​        真实时间对应于时间定义的每一天。当真实时间通过一些标准点计算的时候，我们称它为日历时间。和经过的时间相对，它是度量一个进程生命周期中的一些点（通常是开始）。进程时间是由一个进程使用的 CPU 时间量，并划分为用户时间和系统时间。多种系统调用允许我们获取和设置系统时钟值（即日历时间，以秒为单位从 Epoch 计算），以及一系列的库函数能够完成从日历时间到其他时间格式之间的转换，包括分解时间和具有可读性字符串。描述这种转换把我们引入了地区和国际化的讨论。使用和显示时间和日期是许多应用程序的一个重要组成部分，我们会在这本书后面的章节中经常使用到本节描述的功能。我们也会在第 23 章更多地介绍时间的度量。</p><h1 id="系统限制和选项"><a href="#系统限制和选项" class="headerlink" title="系统限制和选项"></a>系统限制和选项</h1><p>​        但凡 UNIX 实现，无不对各种系统特性和资源加以限制，并提供（或者选择不提供）由各种标准所定义的选项，例如：</p><ul><li>一个进程能同时拥有多少已打开的文件？</li><li>系统是否支持实时信号？</li><li>int 类型变量可存储的最大值是多少？</li><li>一个程序的参数列表能有多大？</li><li>路径名的最大长度是多少？</li></ul><p>​        尽管可以把假定的限制和选项硬性写入程序编码，但这将破坏程序的可移植性，因为限制和选项可能会有所不同。</p><ul><li>在 UNIX 实现之间：虽然限制和选项在某个特定 UNIX 实现中可能是固定的，但在不同的 UNIX 实现之间，可能会有所不同。int 变量可存储的最大值就是此类限制的例子之一。</li><li>特定实现的运行环境：例如，可能重新配置了内核，改变了某个限制。又或者，在某个系统上编译的应用程序，却在另一个限制和选项有所不同的系统中运行。</li><li>从一个文件系统到另外一个文件系统：例如，传统的 System V 文件系统允许文件名长达 14 个字节，而传统的 BSD 文件系统和大多数“原生”Linux 文件系统则允许文件名高达 255 个字节。</li></ul><p>​        因为系统限制和选项会影响应用程序的行为，所以可移植应用程序需要获取限制值，弄清系统对选项的支持情况。C 语言标准和 SUSv3 为此而提供了两种重要途径。y 在编译程序时能够获得一些限制和选项。例如，int 类型的最大值取决于硬件结构和编译器的设计选择。此类限制可在头文件中记录。y 另外一些限制和选项在程序运行时可能会有变化。对此，SUSv3 定义了 3 个函数sysconf()、pathconf()和 fpathconf()，供应用程序调用以检查系统实现的限制和选项。SUSv3 规定有一系列限制，要求符合规范的实现必须支持，同时还规定了一套选项，特定系统可以有选择地对其中各个选项予以支持。本章介绍了部分限制和选项，其余则会在后续章节中适时加以描述。</p><h2 id="11-1-系统限制"><a href="#11-1-系统限制" class="headerlink" title="11.1 系统限制"></a>11.1 系统限制</h2><p>​        SUSv3 要求，针对其所规范的每个限制，所有实现都必须支持一个最小值。在大多数情况下，会将这些最小值定义为<limits.h>文件中的常量，其命名则冠以字符串_POSIX_，而且（通常）还包含字符串_MAX，因此，常量命名形如_POSIX_XXX_MAX。</p><p>​        如果应用程序将本身限制在 SUSv3 对每个限制所要求的最小值之内，那么该程序对符合标准的所有实现都具有可移植性。然而，这一做法阻碍了应用程序去利用特定实现可提供的更高限制。因此，在特定系统上获取限制，通常更为可取的方法是使用<limits.h>文件、sysconf()或 pathconf()。</p><p>​        SUSv3 将其所定义的各类限制描述为最小值，但命名却使用了字符串_MAX，这可能颇令人疑惑。换一种思路，将此类常量中的每一个都视为对某类资源或特性的上限，且标准要求这些上限都必须拥有一个确定的最小值，这种命名的用意也就不言自明了。在某些情况下，会为某个限制提供最大值，并且在对这些值的命名中包含字符串_MIN。对于这些常量，道理正好反过来；它们代表了对某些资源的下限，按照标准规定，在符合标准的实现中，该下限不能高于某个值。例如，限制 FLT_MIN(1E-37)为某个实现中所能表征的最小浮点数定义了最大值。所有满足标准的实现至少能够表征如此之小的浮点数。</p><p>​        每个限制都有一个名称，与上述最小值的名称相对应，但缺少了_POSIX_前缀。某个实现可以在<limits.h>文件中以该名称定义一个常量，用以表示该实现的相应限制。若已然定义，则该限制值总是至少等同于前述最大值（即 XXX_MAX &gt;= _POSIX_XXX_MAX）。SUSv3 将其规定的限制归为 3 类：运行时恒定值、路径名变量值和运行时可增加值。在下列段落中将描述这些类别并提供一些例子. </p><h4 id="运行时恒定值（可能不确定）"><a href="#运行时恒定值（可能不确定）" class="headerlink" title="运行时恒定值（可能不确定）"></a>运行时恒定值（可能不确定）</h4><p>​        所谓运行时恒定值是指某一限制，若已然在<limits.h>文件中定义，则对于实现而言固定不变。然而该值可能是不确定的（因为该值可能依赖于可用的内存空间），因而在<limits.h>文件中会忽略对其定义。在这种情况下（即使在<limits.h>文件中已然定义了该限制），应用程序可以使用 sysconf()来获取运行时的值。</p><p>​        MQ_PRIO_MAX 限制就是运行时恒定值的例子之一。正如 52.5.1 节所述，针对 POSIX 消息队列中的消息，存在着优先级方面的限制。SUSv3 定义了值为 32 的常量_POSIX_MQ_ PRIO_MAX，将其作为符合规范的实现为该限制所必须提供的最小值。这意味着，所有符合规范的实现，其对消息优先级的支持至少应为从 0～31。一个 UNIX 实现可以为此限制设定更高值，并将该值在<limits.h>文件中以常量 MQ_PRIO_MAX 加以定义。例如，Linux 就将MQ_PRIO_MAX 的值定义为 32768。也可以通过下列调用在运行时获取该值：</p><p><img src="image-20230807110654895.png" alt="image-20230807110654895"></p><h4 id="路径名变量值"><a href="#路径名变量值" class="headerlink" title="路径名变量值"></a>路径名变量值</h4><p>​        所谓路径名变量值是指与路径名（文件、目录、终端等）相关的限制，每个限制可能是相对于某个系统实现的常量，也可能随文件系统的不同而不同。在限制可能因路径名而发生变化的情况下，应用程序可以使用 pathconf()或 fpathconf()来获取该值。NAME_MAX 限制是路径名变量值的例子之一。此限制定义了在一个特定文件系统中文件名的最大长度。SUSv3 定义了值为 14 （老版本的 System V 文件系统限制）的常量_POSIX_NAME_MAX，作为系统实现必须支持的最小限制值。系统实现可以定义一个高于此值的 NAME_MAX 限制，并/或向应用开放如下形式的调用，以获取特定文件系统的相关信息：参数 directory_path 是目标文件系统上的目录路径名。</p><h4 id="运行时可增加值"><a href="#运行时可增加值" class="headerlink" title="运行时可增加值"></a>运行时可增加值</h4><p>​        运行时可增加值是指某一限制，相对于特定实现其值固定，且运行此实现的所有系统至少都应支持这一最小值。然而，特定系统在运行时可能会增加该值，应用程序可以使用 sysconf()来获得系统所支持的实际值。运行时可增加值的例子之一是 NGROUPS_MAX，该限制定义了一进程可同时从属的辅助组 ID（9.6 节）的最大数量。SUSv3 定义了相应的最小值_POSIX_NGROUPS_MAX，其值为8。应用可在运行时通过调用 sysconf(_SC_NGROUPS_MAX)来获取此限制值。</p><h4 id="对选定-SUSv3-限制的总结"><a href="#对选定-SUSv3-限制的总结" class="headerlink" title="对选定 SUSv3 限制的总结"></a>对选定 SUSv3 限制的总结</h4><p>​        表 11-1 列举了与本书有关，由 SUSv3 所定义的部分限制（其他限制将在后续章节中加以介绍）。</p><div class="table-container"><table><thead><tr><th style="text-align:left">限制名称(<limits.h>)</th><th style="text-align:left">最小值</th><th style="text-align:left">（sysconf() / pathconf()入参 name 名）</th><th style="text-align:left">描 述</th></tr></thead><tbody><tr><td style="text-align:left">ARG<em>MAX</em></td><td style="text-align:left">4096</td><td style="text-align:left">_SC_ARG_MAX</td><td style="text-align:left">提供给 exec()的参数(argv)与环境变量(environ)所占存储空间之和的最大字节数</td></tr><tr><td style="text-align:left">none</td><td style="text-align:left">none</td><td style="text-align:left">_SC_CLK_TCK</td><td style="text-align:left">为 times()提供的度量单位</td></tr><tr><td style="text-align:left">LOGIN_NAME MAX</td><td style="text-align:left">9</td><td style="text-align:left">_SC_LOGIN_NAME_MAX</td><td style="text-align:left">登录名的最大长度（含终止空字符）</td></tr><tr><td style="text-align:left">OPEN_MAX</td><td style="text-align:left">20</td><td style="text-align:left">_SC_OPEN_MAX</td><td style="text-align:left">进程同时可打开的文件描述符的最大数量，比可用文件描述符的最大数量多 1 个</td></tr><tr><td style="text-align:left">NGROUPS_MAX</td><td style="text-align:left">8</td><td style="text-align:left">_SC_NGROUPS_MAX</td><td style="text-align:left">进程所属辅助组 ID 数量的最大值</td></tr><tr><td style="text-align:left">none</td><td style="text-align:left">1</td><td style="text-align:left">_SC_PAGESIZE</td><td style="text-align:left">一个虚拟内存页的大小 （_SC_PAGE_SIZE 与其同义）</td></tr><tr><td style="text-align:left">RTSIG_MAX</td><td style="text-align:left">8</td><td style="text-align:left">_SC_RTSIG_MAX</td><td style="text-align:left">单一实时信号的最大数量</td></tr><tr><td style="text-align:left">SIGQUEUE_MAX</td><td style="text-align:left">32</td><td style="text-align:left">_SC_SIGQUEUE_MAX</td><td style="text-align:left">排队实时信号的最大数量</td></tr><tr><td style="text-align:left">STREAM_MAX</td><td style="text-align:left">8</td><td style="text-align:left">_SC_STREAM_MAX</td><td style="text-align:left">同时可打开的 stdio 流的最大数量</td></tr><tr><td style="text-align:left">NAME_MAX</td><td style="text-align:left">14</td><td style="text-align:left">_PC_NAME_MAX</td><td style="text-align:left">排除终止空字符外，文件名称可达的最大字节长度</td></tr><tr><td style="text-align:left">PATH_MAX</td><td style="text-align:left">256</td><td style="text-align:left">_PC_PATH_MAX</td><td style="text-align:left">路径名称可达的最大字节长度，含尾部空字符</td></tr><tr><td style="text-align:left">PIPE_BUF</td><td style="text-align:left">512</td><td style="text-align:left">_PC_PIPE_BUF</td><td style="text-align:left">一次性（原子操作）写入管道或 FIFO中的最大字节数</td></tr></tbody></table></div><ul><li>getdtablesize()函数是确定进程文件描述符（OPEN_MAX）限制的备选方法，已遭弃用，该函数曾一度为 SUSv2 所定义（标记为 LEGACY），但 SUSv3 将其剔除</li><li>getpagesize()函数是确定系统页大小（＿SC_PAGESIZE）的备选方法，已然废弃。该函数一度曾为 SUSv2 所定义（标记为 LEGACY），但 SUSv3 将其剔除。</li><li>定义于文件中的常量 FOPEN_MAX，等同于常量 STREAM_MAX</li><li>NAME_MAX 不包含终止空字符，而 PATH_MAX 则包括。POSIX.1 标准在定义PATH_MAX 时，对于是否包含终止空字符始终含糊不清，而上述差异则恰好弥补了这一缺陷。定义 PATH_MAX 中包含终止符也意味着，为路径名称分配了 PATH_MAX个字节的应用程序依然符合标准。</li></ul><h2 id="11-2-在运行时获取系统限制（和选项）"><a href="#11-2-在运行时获取系统限制（和选项）" class="headerlink" title="11.2 在运行时获取系统限制（和选项）"></a>11.2 在运行时获取系统限制（和选项）</h2><p>​        sysconf()函数允许应用程序在运行时获得系统限制值。</p><p><img src="image-20230807111016524.png" alt="image-20230807111016524"></p><p>​        参数 name 应为定义于<unistd.h>文件中的_SC_系列常量之一，其中部分在表 11-1 中已有所罗列。限制值将作为函数结果返回。若无法确定某一限制，则 sysconf()返回−1。若调用 sysconf()函数时发生错误，也会返回−1。（唯一指定的错误是 EINVAL，表示 name 无效。）为区别上述两种情况，必须在调用函数前将 errno 设置为 0，如果调用返回−1，且调用后 errno 值不为 0，那么调用 sysconf()函数时发生了错误。由 sysconf()函数所返回的限制值类型总是（长）整型（pathconf()和 fpathconf()也是如此）。在对 sysconf()函数的原理描述中，SUSv3 特意指出，一度曾考虑将字符串作为可能的返回值，但由于实现和使用的复杂性而最终放弃了这一构想。程序清单 11-1 所示为调用 sysconf()来展示各种系统限制。在某一 Linux 2.6.31/x86-32 系统上运行该程序，将产生如下结果：</p><p><img src="image-20230807111028469.png" alt="image-20230807111028469"></p><p>SUSv3 要求，针对特定限制，调用 sysconf()所获取的值在调用进程的生命周期内应保持不变。例如，就可以这样认定：针对_SC_PAGESIZE 限制的返回值在进程运行期间不会改变。</p><pre class="line-numbers language-none"><code class="language-none">在 Linux 系统中，对于上述要求，有一些（合理的）例外。进程能够使用 setrlimit()（见 36.2节）修改进程的各种资源限制，这会波及由 sysconf()所报告的限制值：RLIMIT_NOFILE，该限制确定进程能够打开的文件数量（_SC_OPEN_MAX）；RLIMIT_NPROC(实际并未纳入SUSv3 中 ) ，即允许进程基于每用户所创建的子进程限额（ _SC_CHILD_MAX ）；RLIMIT_STACK，始于 Linux 2.6.23 版本，该限制确定了进程的命令行参数和环境变量所占存储空间的限额（_SC_ARG_MAX，具体参见 execve(2)手册页）。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-3-运行时获取与文件相关的限制（和选项）"><a href="#11-3-运行时获取与文件相关的限制（和选项）" class="headerlink" title="11.3 运行时获取与文件相关的限制（和选项）"></a>11.3 运行时获取与文件相关的限制（和选项）</h2><p>​        pathconf()和 fpathconf()函数允许应用程序在运行时获取文件相关的限制值。</p><p><img src="image-20230807111111866.png" alt="image-20230807111111866"></p><p>​        pathconf()和 fpathconf()之间唯一的区别在于对文件或目录的指定方式。pathconf()采用路径名方式来指定，而 fpathconf()则使用（之前已经打开的）文件描述符。参数 name 则是定义于<unistd.h>文件中的_PC_系列常量之一，在表 11-1 中已经列举了其中的一部分。表 11-2 又针对表 11-1 中展示的_PC_*常量，提供了更深入的细节。限制的值将作为函数结果返回。如要区分限制值不确定与发生错误的情况，应对方式与sysconf()相同。有别于 sysconf()函数，SUSv3 并不要求 pathconf()和 fpathconf()的返回值在进程的生命周期内保持恒定。这是因为，例如，在进程运行期间，可能会卸载一个文件系统，然后再以不同特性重新装载该文件系统。</p><div class="table-container"><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">_PC_NAME_MAX</td><td style="text-align:left">针对目录，返回该目录下文件命名的最大长度，对于其他文件类型，则未作规定</td></tr><tr><td style="text-align:left">_PC_PATH_MAX</td><td style="text-align:left">对于目录，返回该目录中相对路径名的最大长度，对于其他文件类型，则未作规定</td></tr><tr><td style="text-align:left">_PC_PIPE_BUF</td><td style="text-align:left">对于 FIFO 或者管道，返回一个应用于引用文件的值。对于目录，返回的值应用于在该目录下创建的一 FIFO。对于其他文件类型，则未作规定</td></tr></tbody></table></div><p><img src="image-20230807111155579.png" alt="image-20230807111155579"></p><p><img src="image-20230807111202553.png" alt="image-20230807111202553"></p><h2 id="不确定的限制"><a href="#不确定的限制" class="headerlink" title="不确定的限制"></a>不确定的限制</h2><p>​        有时，系统实现并未将一些系统限制定义为限制常量（比如：PATH_MAX），并且 sysconf()或 pathconf()在返回相应限制(比如_PC_PATH_MAX)时会将其归为不确定。对此，可采用如下策略之一。</p><ul><li>当编写一个可在多个 UNIX 实现间移植的应用程序时，可选择使用 SUSv3 所规定的最低限制值。此类以_POSIX_*_MAX 形式命名的常量。此方法有时并不可行，因为该限制之低已经超乎实际情况，正如_POSIX_PATH_MAX 和_POSIX_OPEN_MAX 的情况</li><li>在某些情况下，切实可行的解决方法是省去对限制的检查，取而代之以执行相关的系统调用或库函数。如果调用失败，且 errno 表明出错是由于超出了系统限制时，那么可以根据需要调整应用的行为，并再次尝试调用。例如，对于可发送给进程的实时信号队列长度，大多数 UNIX实现都进行了强制限制。一旦达到限额，试图进一步发送信号（使用 sigqueue()函数）将以失败告终，且会将错误号 errorno 置为 EAGAIN。这时，发送进程只需简单重试即可，或许是在等待片刻之后。与之相类似，试图打开一个文件时，若文件命名过长，将会产生 ENAMETOOLONG 错误，之后应用程序可以一个更加简短的命名进行重试。</li><li>自行编写程序或函数，以推断或估算限制值。无论在哪一种情况下，都会调用相关的sysconf()或pathconf()，若限制不确定，则函数将返回一合理估值。虽然有欠完美，但这种解决方案往往在实践中是可行的</li><li>也可以利用诸如 GNU Autoconf 之类的扩展工具，该工具能够确定各种系统特性及限制存在与否、如何设置。Autoconf 程序可基于其收集到的信息而生成头文件，并能在C 程序中将其包含在内</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux漫游——用户与组，进程凭证</title>
      <link href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%87%AD%E8%AF%81/"/>
      <url>/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%87%AD%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="用户与组，进程凭证"><a href="#用户与组，进程凭证" class="headerlink" title="用户与组，进程凭证"></a>用户与组，进程凭证</h1><h2 id="8-1-密码文件：-etc-passwd"><a href="#8-1-密码文件：-etc-passwd" class="headerlink" title="8.1 密码文件：/etc/passwd"></a>8.1 密码文件：/etc/passwd</h2><p>​        针对系统的每个用户账号，系统密码文件/etc/passwd 会专列一行进行描述。每行都包含 7个字段，之间用冒号分隔，如下所示：</p><p><img src="image-20230804123414878.png" alt="image-20230804123414878"></p><p>​        接下来，将按顺序介绍这 7 个字段。</p><ul><li>登录名：<strong>登录系统时，用户所必须输入的唯一名称。</strong>通常，也将其称为用户名。此外，也可将登录名视为人类可读的（符号）标识符，与数字用户标识符（稍后介绍）相对应。当使用诸如 ls(1)这样的程序去显示文件的所有权时（比如，执行 ls –l 时），会显示出登录名，而非与文件关联的数值型用户 ID。</li><li>经过加密的密码：<strong>该字段包含的是经过加密处理的密码，长度为 13 个字符</strong>，8.5 节会对此做深入讨论。如果密码字段中包含了任何其他字符串，特别是，当字符串长度超过 13 个字符时，将禁止此账户登录，原因是此类字符串不能代表一个经过加密的有效密码。不过，请注意，要是启用了 shadow 密码（这是常规做法），系统将会不解析该字段。这时，/etc/passwd 中的密码字段通常会包含字母“x”（当然，也可以是任何非空字串），而经过加密处理的密码实际上却存储到 shadow 密码文件中（参见 8.2 节）。若/etc/passwd 中密码字段为空，则该账户登录时无需密码（即便启用了 shadow 密码，也是如此）。</li></ul><pre class="line-numbers language-none"><code class="language-none">本章假定对密码的加密算法为 DES（数据加密标准），这也是一直为 UNIX 所广泛使用的密码加密算法。还可用其他加密算法（比如，MD5）来替代 DES，针对输入生成 128 位的消息摘要（hash 的一种）。在密码（或 shadow 密码）文件中，该消息摘要会以长度为 34 字符的字符串形式存储。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>用户 ID（UID）：<strong>用户的数值型 ID。如果该字段的值为 0，那么相应账户即具有特权级权限。</strong>这种账号一般只有一个，其登录名为 root。在 Linux 2.2 或更早的版本中，用户 ID 为 16 位值，其范围为 0～65535。而 Linux 2.4 及其以后的版本则以 32 位值来存储用户 ID，因此能够支持更多的用户数。</li></ul><pre class="line-numbers language-none"><code class="language-none">在密码文件中，允许（但不常见）同一用户 ID 拥有多条记录，从而使得同一用户 ID拥有多个登录名。如此一来，多个用户便能以不同密码（登录）去访问相同资源（比如，文件等）。此外，不同的登录名还可以关联一系列不同的组 ID。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>组 ID（GID）：用户属组中首选属组的数值型 ID。关于用户与属组之间从属关系的进一步信息，会在系统组文件中加以定义。</li><li>注释：该字段存放关于用户的描述性文字。诸如 finger(1)之类的各种程序会显示此信息。</li><li>主目录：<strong>用户登录后所处的初始路径。会以该字段内容来设置 HOME 环境变量。</strong></li><li>登录 shell：<strong>一旦用户登录，便交由该程序控制。通常，该程序为 shell 的一种（比如，bash），但也可以是其他任何程序。如果该字段为空，那么登录 shell 默认为/bin/sh（Bourne shell）。</strong>会以该字段值来设置 SHELL 环境变量。</li></ul><p>​        在单机系统中，所有密码信息都存储在/etc/passwd 文件中1。然而，如果使用了 NIS（网络信息系统）或 LDAP（轻型目录访问协议）在网络环境中分发密码，那么部分密码信息可能会由远端系统保存。只要访问密码信息的程序采用的是本章稍后描述的函数（getpwnam()、getpwuid()等），那么无论是使用 NIS 还是 LDAP，对应用程序来说都是透明的。类似论断同样适用于本章随后几节所讨论的 shadow 密码文件和组文件。</p><h2 id="8-2-shadow-密码文件：-etc-shadow"><a href="#8-2-shadow-密码文件：-etc-shadow" class="headerlink" title="8.2 shadow 密码文件：/etc/shadow"></a>8.2 shadow 密码文件：/etc/shadow</h2><p>​        很久以来，UNIX 一直在/etc/passwd 中维护所有的用户信息，这其中包括经过加密处理的密码。但这一举措也带来了安全问题。由于许多非特权级别系统工具需要读取密码文件中的其他信息，密码文件因而不得不对所有用户开放可读权限。这就为密码破解工具提供了可乘之机，它们会尝试对可能成为密码的大量词汇（比如，字典中的标准单词或人名）进行加密，然后再将结果与经过加密处理的用户密码进行比对。作为防范此类攻击的手段之一，shadow密码文件/etc/shadow 应运而生。其理念是用户的所有非敏感信息存放于“人人可读”的密码文件中，而经过加密处理的密码则由 shadow 密码文件单独维护，仅供具有特权的程序读取。shadow 密码文件包含有登录名（用来匹配密码文件中的相应记录）、经过加密的密码，以及其他若干与安全性相关的字段。shadow(5)手册页对这些字段作了详细描述。本章将着重关注经过加密的密码字段，将在 8.5 节介绍 crypt()库函数时做深入讨论。SUSv3 并未对 shadow 密码作出规范，也并非所有的 UNIX 实现都提供这一特性，即使是都支持这一特性的各种实现，在关于 API 和文件位置上的细节也不尽相同。</p><h2 id="8-3-组文件：-etc-group"><a href="#8-3-组文件：-etc-group" class="headerlink" title="8.3 组文件：/etc/group"></a>8.3 组文件：/etc/group</h2><p>​        出于各种管理方面的考虑，尤其是要控制对文件和其他系统资源的访问，对用户进行编组极具实用价值。对用户所属各组信息的定义由两部分组成：一，密码文件中相应用户记录的组 ID 字段；二，组文件列出的用户所属各组。这种将信息分置于两个文件中的奇怪现状，自有其历史渊源。在早期 UNIX 实现中，一个用户同时只能从属于一个组。登录时，用户最初的属组关系由密码文件的组 ID 字段决定，在此之后，可使用 newgrp(1)命令去改变用户属组，但需要用户提供组密码（若该组处于密码的保护之下）。4.2BSD 引入了并发多属组（multiple simultaneous group memberships）的概念，POSIX.1-1990 随后对其进行了标准化。采用这种方案，组文件会列出每个用户所属的其他属组。（groups(1)命令会显示当前 shell 进程所属各组的信息，如果将一个或多个用户名作为其命令行参数，那么该命令将显示相应用户所属各组的信息。）系统中的每个组在组文件/etc/group 中都对应着一条记录。每条记录包含 4 个字段，之间以冒号分隔，如下所示：</p><p><img src="image-20230804123732226.png" alt="image-20230804123732226"></p><p>​        本节将依次介绍这 4 个字段。</p><ul><li>组名：<strong>组的名称。与密码文件中的登录名相似，可以将其视为与数值型组标识符相对应的人类可读（符号）标识符。</strong></li><li>经过加密处理的密码：组密码属于非强制特性，对应于该字段。随着多属组的出现，当今的 UNIX 系统已经很少使用组密码。不过，依然可以为组设置密码（特权用户可使用 gpasswd 命令来设置组密码）。如果用户并非某组的成员，那么在使用 newgrp(1)启动新 shell 之前（新 shell 的属组包括该组），就需要用户提供此密码。如果启用了shadow 密码，那么系统将不解析该字段（这时，该字段通常只包含字母 x，但也允许其内容为包括空字符串在内的任何字符串），而经过加密的密码实际上则存放于shadow 组文件/etc/gshadow 中，仅供具有特权的用户和程序访问。组密码的加密方式类似于用户密码（8.5 节）。</li><li>组 ID（GID）：<strong>该组的数值型 ID。正常情况下，对应于组 ID 号 0，只定义一个名为 root的组（与/etc/passwd 中用户 ID 为 0 的记录相近）。</strong>在 Linux 2.2 或更早的版本中，组ID 为 16 位值，其范围为 0～65535；而自 Linux 2.4 以后的版本则以 32 位值来存储组 ID。</li><li>用户列表：属于该组的用户名列表，之间以逗号分隔。（这份列表包含的是用户名，而非用户 ID，原因在于如前所述，在密码文件的各条记录中，用户 ID 并不一定唯一。）为了证明用户 avr 是 users、staff 以及 teach 各组的成员，应能从密码文件中查看到如下记录：</li></ul><p><img src="image-20230804123804123.png" alt="image-20230804123804123"></p><p>​        且在组文件中应有如下记录：</p><p><img src="image-20230804123813867.png" alt="image-20230804123813867"></p><p>​        在密码文件记录的第 4 个字段中，组 ID 为 100，这说明 avr 是 users 组的成员之一。其他属组关系，则见诸于组文件内包含 avr 的各条相关记录。</p><h2 id="8-4-获取用户和组的信息"><a href="#8-4-获取用户和组的信息" class="headerlink" title="8.4 获取用户和组的信息"></a>8.4 获取用户和组的信息</h2><p>​        本节所要介绍的库函数，其功能包括从密码文件、shadow 密码文件和组文件中获取单条记录，以及扫描上述各个文件的所有记录。</p><h3 id="从密码文件获取记录"><a href="#从密码文件获取记录" class="headerlink" title="从密码文件获取记录"></a>从密码文件获取记录</h3><p>​        函数 getpwnam()和 getpwuid()的作用是<strong>从密码文件中获取记录</strong>。</p><p><img src="image-20230804123846590.png" alt="image-20230804123846590"></p><p>​        为 name 提供一个登录名，getpwnam()函数就会返回一个指针，指向如下类型的结构，其中包含了与密码记录相对应的信息：</p><p><img src="image-20230804123853934.png" alt="image-20230804123853934"></p><p>​        passwd 结构的 pw_gecos 和 pw_passwd 字段虽未在 SUSv3 中定义，但获得了所有 UNIX实现的支持。仅当未启用 shadow 密码的情况下，pw_passwd 字段才会包含有效信息。要确定是否启用了 shadow 密码，最简单的编程方法是在成功调用 getpwnam()之后，紧接着调用getspnam()（稍后介绍），并观察后者是否能为同一用户名返回一条 shadow 密码记录。某些其他实现还会在该结构中定义额外的非标准字段。pw_gecos 字段，其命名源于早期的 UNIX 实现，该字段所含信息原用于与运行 GECOS（通用电器综合操作系统）的计算机进行通信。虽然这一用途早已过时，但其名称却得以沿用至今，只是将字段用途转而用于记录用户的相关信息。函数 getpwuid()的返回结果与 getpwnam()完全一致，但会使用提供给 uid 参数的数值型用户 ID 作为查询条件。getpwnam()和 getpwuid()均会返回一个指针，指向一个静态分配的结构。对此二者下文描述的 getpwent()函数）的任何一次调用都会改写该数据结构。</p><pre class="line-numbers language-none"><code class="language-none">由于 getpwnam()和 getpwuid()返回的指针指向由静态分配而成的内存，故而二者都是不可重入的（not reentrant）。实际上，情况甚至要更加复杂，因为返回的 passwd 结构还包含了指向其他信息（比如，pw_name）的指针，而这些信息同样也是由静态分配而成的。21.1.2节会解释可重入（reentrancy）概念。类似的论断同样适用于 getgrnam()和 getgrgid()函数（稍后介绍）。SUSv3 为该组函数定义了与之等价的一组可重入函数：getpwnam_r()、getpwuid_r()、getgrnam_r()以及 getgrgid_r()。其参数包括 passwd（或 group）结构，以及一个缓冲区。这一缓冲区专门用来保存 passwd(group)结构中各字段所指向的其他结构。可使用系统函数sysconf(_SC_GETPW_R_SIZE_MAX)（若为与组相关的函数，则使用 sysconf(_SC_GETGR_ R_SIZE_MAX)），来获得此缓冲区所需的字节数。以上函数的详细信息请查阅手册页。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        SUSv3 规定，如果在 passwd 文件中未发现匹配记录，那么 getpwnam()和 getpwuid()将返回 NULL，且不会改变 errno。这意味着，可以使用如下代码，对出错和“未发现匹配记录”这两种情况加以区分：</p><p><img src="image-20230804123939247.png" alt="image-20230804123939247"></p><p>​        然而，不少 UNIX 实现在这一点上并未遵守 SUSv3 规范。如果未能在 passwd 文件中发现一条匹配记录，那么两个函数均会返回 NULL，并将 errno 设置为非零值，比如，ENOENT 或ESRCH。针对这种情况，2.7 版本之前的 glibc 会产生 ENOENT 错误，而从 2.7 版本开始，glibc开始遵守 SUSv3 规范。实现之间之所以存在上述差异，部分原因是由于 POSIX.1-1990 不但不要求两个函数在出错时设置 errno，而且还允许它们针对“未发现匹配记录”的情况去设置errno。总而言之，在使用这两个函数时，若要区分上述这两种情况（出错和“未发现匹配记录”），实际上将无法保证代码的可移植性。</p><h3 id="从组文件获取记录"><a href="#从组文件获取记录" class="headerlink" title="从组文件获取记录"></a>从组文件获取记录</h3><p>​        函数 getgrnam()和 getgrgid()的作用是从组文件中获取记录。函数 getgrnam()和 getgrgid()分别通过组名和组 ID 来查找属组信息。两个函数都会返回一个指针，指向如下类型结构：</p><p><img src="image-20230804124010175.png" alt="image-20230804124010175"></p><p>​        SUSv3 并未就 group 结构中的 gr_passwd 字段做明确定义，但大多数 UNIX 实现都支持该字段。与前述密码相关函数一样，对这两个函数的任何一次调用都会改写该结构的内容。如果未能在 group 文件中发现匹配记录，那么这两个函数的行为变化与前述 getpwnam()和 getpwuid()函数相同2。程序示例对本节所述的函数来说，最常见的用法之一是在符号型用户名和组名与数值型 ID 之间进行相互转换。程序清单 8-1 以 userNameFromId()、userIdFromName()、groupNameFromId()以及 groupIdFromName()这 4 个函数的形式，演示了上述转换。为方便调用，userIdFromName()和 groupIdFromName()还允许 name 参数接受（纯）数值的字符串形式3。对于这种情况，会直接将字符串转换为数字返回给调用者。在本书后面的一些程序实例中，还会用到这几个函数。</p><p>​        程序清单 8-1：在用户名/组名和用户 ID/组 ID 之间互相转换的函数  </p><p><img src="image-20230804124040710.png" alt="image-20230804124040710"></p><p><img src="image-20230804124046760.png" alt="image-20230804124046760"></p><h3 id="扫描密码文件和组文件中的所有记录"><a href="#扫描密码文件和组文件中的所有记录" class="headerlink" title="扫描密码文件和组文件中的所有记录"></a>扫描密码文件和组文件中的所有记录</h3><p>​        函数 setpwent()、getpwent()和 endpwent()的作用是按顺序扫描密码文件中的记录。函数 getpwent()能够从密码文件中逐条返回记录，当不再有记录1（或出错）时，该函数返回 NULL。getpwent()一经调用，会自动打开密码文件。当密码文件处理完毕后，可调用endpwent()将其关闭。可使用以下代码遍历整个密码文件，并打印出登录名和用户 ID。</p><p><img src="image-20230804124107268.png" alt="image-20230804124107268"></p><p>​        如果需要让后续的 getpwent()调用（也许是在程序的其他代码中，也许是在所调用的其他库函数中，该函数再次出现）再次打开密码文件并重启扫描过程，此处的 endpwent()调用就必不可少。此外，如果对该文件处理到中途时，还可以调用 setpwent()函数重返文件起始处。函数 getgrent()、setgrent()和 endgrent()针对组文件执行类似的任务。由于这 3 个函数与前述的密码文件函数功能相似，故而其函数原型也就不再列出，详细信息请参考手册页。</p><h3 id="从-shadow-密码文件中获取记录"><a href="#从-shadow-密码文件中获取记录" class="headerlink" title="从 shadow 密码文件中获取记录"></a>从 shadow 密码文件中获取记录</h3><p>​        下列函数的作用包括从 shadow 密码文件中获取个别记录，以及扫描该文件中的所有记录。</p><p><img src="image-20230804124131923.png" alt="image-20230804124131923"></p><p>​        由于上述函数在操作上类似于相应的密码文件函数，故而此处对它们的介绍也就点到为止。（上述函数既未在 SUSv3 中明确定义，也未获得所有 UNIX 实现的支持。）函数 getspnam()和 getspent()会返回指向 spwd 类型结构的指针。该结构的形式如下：</p><p><img src="image-20230804124123804.png" alt="image-20230804124123804"></p><p>​        在程序清单 8-2 中，将会演示对 getspnam()的使用。</p><h2 id="8-5-密码加密和用户认证"><a href="#8-5-密码加密和用户认证" class="headerlink" title="8.5 密码加密和用户认证"></a>8.5 密码加密和用户认证</h2><p>​        某些应用程序会要求用户对自身进行认证，通常会采取用户名（登录名）/密码的认证方式。出于这一目的，应用程序可能会维护其自有的用户名和密码数据库。然而，或许是由于势所必然，或许是为了方便起见，有时需要让用户输入标准的用户名/密码（定义于/etc/passwd和/etc/shadow 之中）。（本节的剩余部分将假定系统启用了 shadow 密码，经过加密处理的密码也因此存储于/etc/shadow 中。）需要登录到远程系统的网络应用程序，诸如 ssh 和 ftp，就是此类程序的典范，必须按标准的 login 程序那样，对用户名和密码加以验证。由于安全方面的原因，UNIX 系统采用单向加密算法对密码进行加密，这意味着由密码的加密形式将无法还原出原始密码。因此，验证候选密码的唯一方法是使用同一算法对其进行加密，并将加密结果与存储于/etc/shadow 中的密码进行匹配。加密算法封装于 crypt()函数之中。</p><p><img src="image-20230804124149389.png" alt="image-20230804124149389"></p><p>​        crypt()算法会接受一个最长可达 8 字符的密钥（即密码），并施之以数据加密算法（DES）的一种变体。salt 参数指向一个两字符的字符串，用来扰动（改变）DES 算法，设计该技术，意在使得经过加密的密码更加难以破解。该函数会返回一个指针，指向长度为 13 个字符的字符串，该字符串为静态分配而成，内容即为经过加密处理的密码。DES 的详细信息请参考 <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm。如前所述，除">http://www.itl.nist.gov/fipspubs/fip46-2.htm。如前所述，除</a> DES以外，也可以使用其他的加密算法。例如，使用 MD5 算法可以生成一个 34 字符的字符串，其首字符为美元符号（$），这便于让 crypt()将 DES 加密密码和 MD5 加密密码区分开来。在关于密码加密的讨论中，本书对“加密”一词的使用相对宽松。确切说来，DES 会以给定的密码字符串作为加密密钥，编码得出固定位长的字符串，而 MD5 则是一种复杂的哈希函数。以上两种方法其实殊途同归，对输入密码的加密变换既不可逆又难以破解。salt 参数和经过加密的密码，其组成成员均取自同一字符集合，范围在[a-zA-Z0-9/.]之间，共计 64 个字符。因此，两个字符的 salt 参数可使加密算法产生 4096（64×64）种不同变化。这意味着，预先对整部字典进行加密，再以其中的每个单词与经过加密处理的密码进行比对的做法并不可行，破解程序需要对照字典的 4096 种加密版本来检查密码。由 crypt()所返回的经过加密的密码中，头两个字符是对原始 salt 值的拷贝。也就是说，加密候选密码时，能够从已加密密码（存储于/etc/shadow 内）中获取 salt 值。（加密新密码时，passwd(1)这样的程序会生成一个随机 salt 值。）事实上，在 salt 字符串中，只有前两个字符对crypt()函数有意义。因此，可以直接将已加密密码指定为 salt 参数。要想在 Linux 中使用 crypt()，在编译程序时需开启–lcrypt 选项，以便程序链接 crypt 库。</p><h3 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h3><p>​        程序清单 8-2 演示了如何使用 crypt()来验证用户。该程序首先读取用户名，然后会获取相应的密码记录以及（如开启了 shadow 密码功能）shadow 密码记录。若未能发现密码记录，或程序没有权限读取 shadow 密码文件（需要超级用户权限，或具有 shadow 组成员资格），该程序会打印一条错误消息并退出。接下来，该程序会使用 getpass()函数，读取用户密码。getpass()函数首先会屏蔽回显功能，并停止对终端特殊字符的处理（诸如中断字符，一般为 Control-C）。（第 62 章将论述如何更改这些终端设置。）然后，该函数会打印出 prompt 所指向的字符串，读取一行输入，返回以 NULL 结尾的输入字符串（剥离尾部的换行符）作为函数结果。（该字符串由静态分配而成，故而后续对 getpass()的调用会覆盖其原有内容。）返回结果之前，getpass()会将终端设置还原。使用 getpass()读取密码之后，程序清单 8-2 所示程序会对密码进行验证—使用 crypt()加密密码，并将结果与 shadow 密码文件中经过加密的密码记录进行比对。若两者匹配，则显示用户 ID，如下所示：</p><p><img src="image-20230804124413855.png" alt="image-20230804124413855"></p><p>​        程序清单 8-2 中，以调用 sysconf(_SC_LOGIN_NAME_MAX)的返回值作为存放用户名字符串数组的大小，该调用获取了主机系统上用户名字符串的最大长度。11.2 节将介绍sysconf()的使用。</p><p>​        程序清单 8-2：根据 shadow 密码文件验证用户</p><p><img src="image-20230804124424511.png" alt="image-20230804124424511"></p><p><img src="image-20230804124433999.png" alt="image-20230804124433999"></p><p>​        程序清单 8-2 展示了一个安全要点。读取密码的程序应立即加密密码，并尽快将密码的明文从内存中抹去。只有这样，才能基本杜绝如下事件的发生：恶意之徒借程序崩溃之机，读取内核转储文件以获取密码。仍有可能采用其他方法曝光未经加密的密码。例如，如果包含密码的虚拟内存页执行了换出操作，那么特权级程序就能交换文件中读取密码。此外，拥有足够权限的进程可通过读取/dev/mem（虚拟设备之一，将计算机物理内存表示为有序字节流），来尝试发现密码。SUSv2 将 getpass()函数标记为 LEGACY，并特别指出该函数名容易产生误导，且其所提供的功能无论在何种情况下都极易于实现。SUSv3 摒弃了 getpass()，但在大多数 UNIX实现中依然保留了对它的支持。</p><h2 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h2><p>​        每个用户都有一个唯一的用户名和一个与之对应的数值型用户 ID。用户可以隶属于一个或多个组，每个组都有一个唯一的名称和一个与之对应的数字标识符。这些标识符的主要用途在于确立各种系统资源（比如，文件）的所有权和访问这些资源的权限。用户名和 ID 在/etc/passwd 文件中加以定义，该文件也包含有关用户的其他信息。用户的属组则由/etc/passwd 和/etc/group 文件中的相关字段来定义。还有一个只能由特权级进程所读取的文件/etc/shadow，其作用在于将敏感的密码信息与/etc/passwd 中共用的用户信息分离开来。系统还提供有不同的库函数，用于从上述各个文件中获取信息。crypt()函数加密密码的方式与标准的 login 程序相同，这对需要认证用户的程序来说极为有用。</p><h1 id="进-程-凭-证"><a href="#进-程-凭-证" class="headerlink" title="进 程 凭 证"></a>进 程 凭 证</h1><h2 id="9-1-实际用户-ID-和实际组-ID"><a href="#9-1-实际用户-ID-和实际组-ID" class="headerlink" title="9.1 实际用户 ID 和实际组 ID"></a>9.1 实际用户 ID 和实际组 ID</h2><p>​        <strong>实际用户 ID 和实际组 ID 确定了进程所属的用户和组。</strong>作为登录过程的步骤之一，登录shell 从/etc/passwd 文件中读取相应用户密码记录的第三字段和第四字段，置为其实际用户 ID和实际组 ID（8.1 节）。当创建新进程（比如，shell 执行一程序）时，将从其父进程中继承这些 ID。</p><h2 id="9-2-有效用户-ID-和有效组-ID"><a href="#9-2-有效用户-ID-和有效组-ID" class="headerlink" title="9.2 有效用户 ID 和有效组 ID"></a>9.2 有效用户 ID 和有效组 ID</h2><p>​        在大多数 UNIX 实现（Linux 实现略有差异，具体参见 9.5 节的说明）中，当进程尝试执行各种操作（即系统调用）时，将结合有效用户 ID、有效组 ID，连同辅助组 ID 一起来确定 1 译者注：即标识符。授予进程的权限。例如，当进程访问诸如文件、System V 进程间通信（IPC）对象之类的系统资源时，此类 ID 会决定系统授予进程的权限，而这些资源的属主则另由与之相关的用户 ID和组 ID 来决定。如 20.5 节所述，内核还会使用有效用户 ID 来决定一个进程是否能向另一个进程发送信号。<strong>有效用户 ID 为 0（root 的用户 ID）的进程拥有超级用户的所有权限。这样的进程又称为特权级进程（privileged process）。而某些系统调用只能由特权级进程执行。</strong>第 39 章描述了 Linux 实现的能力（capability）方案，即把授予给超级用户的特权划分为若干不同单元，且能独立启用和禁用这些单元。通常，有效用户 ID 及组 ID 与其相应的实际 ID 相等，但有两种方法能够致使二者不同。其一是使用 9.7 节中所讨论的系统调用，其二是执行 set-user-ID 和 set-group-ID 程序。</p><h2 id="9-3-Set-User-ID-和-Set-Group-ID-程序"><a href="#9-3-Set-User-ID-和-Set-Group-ID-程序" class="headerlink" title="9.3 Set-User-ID 和 Set-Group-ID 程序"></a>9.3 Set-User-ID 和 Set-Group-ID 程序</h2><p>​        <strong>set-user-ID 程序会将进程的有效用户 ID 置为可执行文件的用户 ID（属主）</strong>，从而获得常规情况下并不具有的权限。set-group-ID 程序对进程有效组 ID 实现类似任务。（术语 set-user-ID程序和 set-group-ID 程序有时也简称为 set-UID 程序和 set-GID 程序。）与其他文件一样，可执行文件的用户 ID 和组 ID 决定了该文件的所有权。另外，可执行文件还拥有两个特别的权限位 set-user-ID 位和 set-group-ID 位。（实际上，任何文件都是如此，但此处只关注可执行文件的这两个权限位。）可使用 chmod 命令来设置这些权限位。非特权用户能够对其拥有的文件进行设置，而特权级用户（CAP_FOWNER）能够对任何文件进行设置。例如：</p><p><img src="image-20230804162430618.png" alt="image-20230804162430618"></p><p>​        正如本例所示，也有可能对这两个权限位都进行设置，虽然这一做法并不常见。当使用ls –l 命令查看文件权限时，如果为程序设置了 set-user-ID 权限位和 set-group-ID 权限位，那么通常用来表示文件可执行权限的 x 标识会被 s 标识所替换。</p><p><img src="image-20230804162438627.png" alt="image-20230804162438627"></p><p>​        当运行 set-user-ID 程序（即通过调用 exec()将 set-user-ID 程序载入进程的内存中）时，内核会将进程的有效用户 ID 设置为可执行文件的用户 ID。set-group-ID 程序对进程有效组 ID 的操作与之类似。通过这种方法修改进程的有效用户 ID 或者组 ID，能够使进程（换言之，执行该程序的用户）获得常规情况下所不具有的权限。例如，如果一个可执行文件的属主为 root（超级用户），且为此程序设置了 set-user-ID 权限位，那么当运行该程序时，进程会取得超级用户权限。也可以利用程序的 set-user-ID 和 set-group-ID 机制，将进程的有效 ID 修改为 root 之外的其他用户。例如，为提供对一个受保护文件（或其他系统资源）的访问， 采用如下方案就绰绰有余：创建一个具有对该文件访问权限的专用用户（组）ID，然后再创建一个 set-user-ID（set-group-ID）程序，将进程有效用户（组）ID 变更为这个专用 ID。这样，无需拥有超级用户的所有权限，程序就能访问该文件。有时会使用术语 set-user-ID-root 来表示 root 用户所拥有的 set-user-ID 程序，以示与由其他用户所拥有的 set-user-ID 程序有所区别，后者仅为进程提供其属主所具有的权限。</p><p>​        术语 privileged（特权级）有两种不同含义，其一是为早期定义而成的，有效用户 ID为 0 的进程，拥有 root 用户的所有特权。然而，当 set-user-ID 程序的属主并非 root 用户时，进程也会获得 set-user-ID 程序属主的特权。各种情况下术语 privileged 的具体含义，可通过上下文来加以辨别。出于 38.3 节所给出的理由，在 Linux 系统中，set-user-ID 和 set-group-ID 权限位对 shell脚本无效。</p><p>​        Linux 系统中经常使用的 set-user-ID 程序包括：passwd(1)，用于更改用户密码；mount(8) 和 umount(8)，用于加载和卸载文件系统；su(1)，允许用户以另一用户的身份运行 shell。set-group-ID 程序的例子之一为 wall(1)，用来向 tty 组下辖的所有终端（通常情况下，所有终端都属于该组）写入一条消息。</p><p>​        8.5 节曾特别指出，程序清单 8-2 中的程序需要以 root 用户身份运行，以便获取对/etc/shadow 文件的访问权限。欲使该程序可为任一用户执行，必须将其设置为 set-user-ID-root程序，如下所示：set-user-ID/set-group-ID 技术集实用性与强大的功能于一身，但一旦设计欠佳也可能造成安全隐患。第 38 章总结了一整套良好的编程习惯，编写 set-user-ID 和 set-group-ID 程序时应多加参考。</p><h2 id="9-4-保存-set-user-ID-和保存-set-group-ID"><a href="#9-4-保存-set-user-ID-和保存-set-group-ID" class="headerlink" title="9.4 保存 set-user-ID 和保存 set-group-ID"></a>9.4 保存 set-user-ID 和保存 set-group-ID</h2><p>​        设计保存 set-user-ID（saved set-user-ID）和保存 set-group-ID (saved set-group-ID)，意在与set-user-ID 和 set-group-ID 程序结合使用。当执行程序时，将会（依次）发生如下事件（在诸多事件之中）。</p><p>1． 若可执行文件的 set-user-ID (set-group-ID)权限位已开启，则将进程的有效用户（组）ID置为可执行文件的属主。若未设置 set-user-ID (set-group-ID)权限位，则进程的有效用户（组）ID 将保持不变。</p><p>2． 保存 set-user-ID 和保存 set-group-ID 的值由对应的有效 ID 复制而来。无论正在执行的文件是否设置了 set-user-ID 或 set-group-ID 权限位，这一复制都将进行。举例说明上述操作的效果，假设某进程的实际用户 ID、有效用户 ID 和保存 set-user-ID 均为 1000，当其执行了 root 用户（用户 ID 为 0）拥有的 set-user-ID 程序后，进程的用户 ID 将发生如下变化：</p><p><img src="image-20230804162657912.png" alt="image-20230804162657912"></p><p>​        有不少系统调用，<strong>允许将 set-user-ID 程序的1有效用户 ID 在实际用户 ID 和保存 set-user-ID之间切换</strong>。针对 set-group-ID 程序对其进程有效组 ID 的修改，也有与之相类似的系统调用来支持。如此一来，对于与执行文件用户（组）ID 相关的任何权限，程序能够随时 “收放自如”。（换言之，程序可以游走于两种状态之间：具备获取特权的潜力和以特权进行实际操作。）正如 38.2 节所述，只要 set-user-ID 程序和 set-group-ID 程序没有执行与特权级 ID（亦即实际 ID）相关的任何操作，就应将其置于非特权（即实际）ID 的身份之下，这是一种安全的编程手法。有时也将保存 set-user-ID 和保存 set-group-ID 称之为保存用户 ID（saved user ID）和保存组 ID（saved group ID）。保存设置 ID 由 System V 首创，后为 POSIX 所采用。4.4 之前的 BSD 版本不提供对此特性的支持。最初的 POSIX.1 标准将对这些 ID 的支持列为可选，但之后的版本（始于 1988年诞生的 FIPS 151-1 标准）则强制要求提供这一特性。</p><h2 id="9-5-文件系统用户-ID-和组-ID"><a href="#9-5-文件系统用户-ID-和组-ID" class="headerlink" title="9.5 文件系统用户 ID 和组 ID"></a>9.5 文件系统用户 ID 和组 ID</h2><p>​        在 Linux 系统中，要进行诸如打开文件、改变文件属主、修改文件权限之类的文件系统操作时，决定其操作权限的是文件系统用户 ID 和组 ID（结合辅助组 ID），而非有效用户 ID 和组ID。（和其他 UNIX 实现一样，有效用户 ID 和组 ID 仍在使用，其用途在前面章节已有论述。）通常，文件系统用户 ID 和组 ID 的值等同于相应的有效用户 ID 和组 ID（因而一般也等同于相应的实际用户 ID 和组 ID）。此外，只要有效用户或组 ID 发生了变化，无论是通过系统调用，还是通过执行 set-user-ID 或者 set-group-ID 程序，则相应的文件系统 ID 也将随之改变为同一值。由于文件系统 ID 对有效 ID 如此的“亦步亦趋”，这意味着在特权和权限检查方面，Linux 实际上跟其他 UNIX 实现非常类似。只有当使用 Linux 特有的两个系统调用（setfsuid() 和 setfsgid()）时，才可以刻意制造出文件系统 ID 与相应有效 ID 的不同，因而 Linux 也不同于其他的 UNIX 实现。那么，Linux 为什么要提供文件系统 ID 呢？在何种情况下，需要使有效 ID 有别于文件系统 ID 呢？这主要是由于历史原因造成的。文件系统 ID 始见于 Linux 1.2 版本。在该版本的内核中，如果进程某甲的有效用户 ID 等同于进程某乙的实际用户 ID 或者有效用户 ID，那么发送者（某甲）就可以向目标进程（某乙）发送信号。这在当时影响到了不少程序，比如 Linux NFS（网络文件系统）服务器程序，在访问文件时就好像拥有着相应客户进程的有效 ID。然而，如果 NFS 服务器真地修改了自身的有效用户 ID，面对非特权用户进程的信号攻击，又将不堪一击。为了防范这一风险，文件系统用户 ID 和组 ID 应运而生。NFS 服务器将有效 ID 保持不变，而是通过修改文件系统 ID 伪装成另一用户，这样既达到了访问文件的目的，又避免了遭受信号攻击。自内核 2.0 起，Linux 开始在信号发送权限方面遵循 SUSv3 所强制规定的规则，且这些规则不再涉及目标进程的有效用户 ID（参考 20.5 节）。因此，从严格意义上来讲，保留文件系统 ID 特性已无必要（如今，进程可以根据需要，审慎而明智地利用本章稍后介绍的系统调用，使以非特权值对有效用户 ID 的赋值来去自由，以实现预期结果），但为了与现有软件保持兼容，这一功能得以保留了下来。由于文件系统 ID 实属异类，且一般都等同于相应的有效 ID，本书后续部分在述及各种文件权限的检查，以及设置新文件的属主时，通常将根据进程有效 ID 来加以解释。即使是出于Linux 系统的目的而真地使用了进程的文件系统 ID，但在实践中，这些标识的存在与否并不会带来显著差别。</p><h2 id="9-6-辅助组-ID"><a href="#9-6-辅助组-ID" class="headerlink" title="9.6 辅助组 ID"></a>9.6 辅助组 ID</h2><p>​        辅助组 ID 用于标识进程所属的若干附加的组。新进程从其父进程处继承这些 ID，登录shell 从系统组文件中获取其辅助的组 ID。如前所述，将这些 ID 与有效 ID 以及文件系统 ID相结合，就能决定对文件、System V IPC 对象和其他系统资源的访问权限。</p><h2 id="9-7-获取和修改进程凭证"><a href="#9-7-获取和修改进程凭证" class="headerlink" title="9.7 获取和修改进程凭证"></a>9.7 获取和修改进程凭证</h2><p>​        为了获取和变更本章已然论及的各种用户 ID 和组 ID，Linux 提供了一系列系统调用和库函数。SUSv3 仅对这些 API 中的部分做了规范，余下部分中，有一些在其他 UNIX实现中得以广泛应用，还有少量是 Linux 所特有的。在讨论每个 API 接口时，将特别指出可移植性方面的问题。在本章结尾处，表 9-1 总结了变更进程凭证的所有接口操作。可以利用 Linux 系统特有的 proc/PID/status 文件，通过对其中 Uid、Gid 和 Groups各行信息的检查，来获取任何进程的凭证，这与下面即将介绍的系统调用有异曲同工之妙。Uid 和 Gid 各行，按实际、有效、保存设置和文件系统 ID 的顺序来展示相应标识符。在下列章节中所论及的特权级进程，其定义是基于传统意义上的，即进程的有效用户 ID为 0。然而，正如第 39 章所述，Linux 将超级用户权限划分成多种各不相同的能力（capability）。在讨论修改用户 ID 和组 ID 的所有系统调用时，将涉及其中的两种。y CAP_SETUID 能力允许进程任意修改其用户 ID。y CAP_SETGID 能力允许进程任意修改其组 ID。</p><h3 id="9-7-1-获取和修改实际、有效和保存设置标识"><a href="#9-7-1-获取和修改实际、有效和保存设置标识" class="headerlink" title="9.7.1 获取和修改实际、有效和保存设置标识"></a>9.7.1 获取和修改实际、有效和保存设置标识</h3><p>​        下面段落将描述用于获取和修改实际、有效和保存设置 ID 的系统调用。能完成这些任务的系统调用有多个，有时彼此间的功能还相互重叠，这是由于各种系统调用分别源于不同的UNIX 实现。</p><h4 id="获取实际和有效-ID"><a href="#获取实际和有效-ID" class="headerlink" title="获取实际和有效 ID"></a>获取实际和有效 ID</h4><p>​        系统调用 getuid()和 getgid()分别返回调用进程的实际用户 ID 和组 ID。而系统调用geteuid()和 getegid()则对进程的有效 ID 实现类似功能。对这些系统函数的调用总会成功。</p><p><img src="image-20230804162817149.png" alt="image-20230804162817149"></p><h4 id="修改有效-ID"><a href="#修改有效-ID" class="headerlink" title="修改有效 ID"></a>修改有效 ID</h4><p>​        setuid()系统调用以给定的 uid 参数值来修改调用进程的有效用户 ID，也可能修改实际用户 ID 和保存 set-user-ID。系统调用 setgid()则对相应组 I 实现了类似功能。</p><p><img src="image-20230804162833514.png" alt="image-20230804162833514"></p><p>​        进程使用 setuid()和 setgid()系统调用能对其凭证做哪些修改呢？其规则取决于进程是否拥有特权（即有效用户 ID 为 0）。适用于 setuid()系统调用的规则如下。</p><p>1． 当非特权进程调用 setuid()时，仅能修改进程的有效用户 ID。而且，仅能将有效用户 ID修改成相应的实际用户 ID 或保存 set-user-ID。（企图违反此约束将引发 EPERM 错误。）这意味着，对于非特权用户而言，仅当执行 set-user-ID 程序时，setuid()系统调用才起作用，因为在执行普通程序时，进程的实际用户 ID、有效用户 ID 和保存 set-user-ID 三者之值均相等。在一些派生自 BSD 的实现中，非特权进程对 setuid() 或 setgid()的调用，其语义有别于与其他 UNIX 实现：系统调用会修改实际、有效和保存设置 ID（将其改为当前的实际或有效 ID 值）。</p><p>2． 当特权进程以一个非 0 参数调用 setuid()时，其实际用户 ID、有效用户 ID 和保存 set-user-ID均被置为 uid 参数所指定的值。这一操作是单向的，一旦特权进程以此方式修改了其 ID，那么所有特权都将丢失，且之后也不能再使用 setuid()调用将有效用户 ID 重置为 0。如果不希望发生这种情况，请使用稍后介绍的 seteuid()或者 setreuid()系统调用来替代 setuid()。使用 setgid()系统调用修改组 ID 的规则与之相类似，仅需要把 setuid()替换为 setgid()，把用户替换为组。因之，规则 1 与前述完全一致，但在规则 2 中，由于对组 ID 的修改不会引起进程特权的丢失（拥有特权与否由有效用户 ID 决定），特权级程序可以使用 setgid()对组 ID进行任意修改。对 set-user-ID-root 程序（即其有效用户 ID 的当前值为 0）而言，以不可逆方式放弃进程所有特权的首选方法是使用下面的系统调用（以实际用户 ID 值来设置有效用户 ID 和保存set-user-ID）。</p><p><img src="image-20230804162848913.png" alt="image-20230804162848913"></p><p>​        set-user-ID 程序的属主如果不是 root 用户，可使用 setuid()将有效用户 ID 在实际用户 ID和保存 set-user-ID 之间来回切换，其理由已在 9.4 节中予以阐述。然而，使用 seteuid()来达成这个目的则更为可取，因为无论 set-user-ID 程序是否属于 root 用户，seteuid()都能够实现同样的功能。进程能够使用 seteuid()来修改其有效用户 ID（改为参数 euid 所指定的值），还能使用setegid()来修改其有效组 ID（改为参数 egid 所指定的值）。进程使用 seteuid()和 setegid()来修改其有效 ID 时，会遵循以下规则。</p><p>1． 非特权级进程仅能将其有效 ID 修改为相应的实际 ID 或者保存设置 ID。（换言之，对非特权级进程而言，除去前面讨论的BSD可移植性问题，seteuid()和setegid()分别等效于setuid()和 setgid()。）</p><p>2． 特权级进程能够将其有效 ID 修改为任意值。若特权进程使用 seteuid()将其有效用户 ID 修改为非 0 值，那么此进程将不再具有特权（但可以根据规则 1 来恢复特权）。对于需要对特权“收放自如”的 set-user-ID 和 set-group-ID 程序，更推荐使用 seteuid()，</p><p>示例如下：</p><p><img src="image-20230804162916670.png" alt="image-20230804162916670"></p><p>​        源于 BSD 系统的 seteuid() 和 setegid()，现已纳入 SUSv3 规范，并获得大多数 UNIX 系统实现的支持。</p><pre class="line-numbers language-none"><code class="language-none">在 GNU C 语言函数库的早期版本中（glibc 2.0 及其之前的版本），将 seteuid(euid)实现为 setreuid(–1, euid)。而在新版的 glibc 库中，则将 seteuid(euid)实现为 setresuid(–1，euid，−1)。（稍后将给出对 setreuid()、setresuid()及其类似函数的描述。）这两种实现都允许将 euid参数值指定为当前有效用户 ID（即保持不变）。然而，SUSv3 并未对 seteuid()的这个行为进行规范，并且其他一些 UNIX 实现对此也不支持。总的来说，这种潜在的差异在系统实现间并不明显，因为在通常情况下，有效用户 ID 要么与实际用户 ID 相同，要么与保存set-user-ID 相同。（要想使有效用户 ID 与二者均不相同，在 Linux 系统中唯一的办法是采用非标准的 setresuid()系统调用。）在 glibc 库的所有版本（包括最新版本）中，是以 setregid(–1，egid)来实现 setegid(egid)的。如同 seteuid()一样，这意味着能够将参数 egid 指定为当前有效组 ID，尽管 SUSv3 并未规范这一行为。还有一层含义是使用 setegid()时，如果对有效组 ID 值的设置不同于当前的实际组 ID，那么还将改变保存 set-group-ID。（类似结论也适用于早期使用 setreuid()来实现的 seteuid()。）同样，SUSv3 也不支持这一行为。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改实际-ID-和有效-ID"><a href="#修改实际-ID-和有效-ID" class="headerlink" title="修改实际 ID 和有效 ID"></a>修改实际 ID 和有效 ID</h4><p>setreuid()系统调用允许调用进程独立修改其实际和有效用户 ID。setregid()系统调用对实际和有效组 ID 实现了类似功能。</p><p><img src="image-20230804162948397.png" alt="image-20230804162948397"></p><p>​        这两个系统调用的第一个参数都是新的实际 ID，第二个参数都是新的有效 ID。若只想修改其中的一个 ID，可以将另外一个参数指定为−1。目前，最初派生自 BSD 的 setreuid()和 setregid()为 SUSv3 规范所接纳，并且获得了大多数 UNIX 系统的支持。同本节介绍的其他系统调用一样，使用 setreuid()和 setregid()来作出变更也要遵循一定的规则。下面将从 setreuid()的视角来描述这些规则，除非另有说明，setregid()函数的规则也与之类似。</p><p>1． 非特权进程只能将其实际用户 ID 设置为当前实际用户 ID 值（即保持不变）或有效用户ID 值，且只能将有效用户 ID 设置为当前实际用户 ID、有效用户 ID（即无变化）或保存set-user-ID。SUSv3 声称，对于非特权进程是否能使用 setreuid()将其实际用户 ID 修改为实际用户ID、有效用户 ID 或者保存 set-user-ID 的当前值，规范不做规定。至于真正能将实际用户 ID修改成何值，这随 UNIX 实现的不同而不同。SUSv3 对 setregid()的规定稍有不同，非特权进程能够将其实际组 ID 设置为保存set-group-ID 的当前值，或者将其有效组 ID 设置为实际组 ID 或保存 set-group-ID 的当前值。但真正能对实际组 ID 做哪些修取决于具体的 UNIX 实现。</p><p>2． 特权级进程能够设置其实际用户 ID 和有效用户 ID 为任意值。</p><p>3． 不管进程拥有特权与否，只要如下条件之一成立，就能将保存 set-user-ID 设置成（新的）有效用户 ID。</p><p>a） ruid 不为-1（即设置实际用户 ID，即便是置为当前值）。</p><p>b）对有效用户 ID 所设置的值不同于系统调用之前的实际用户 ID。反过来说，如果进程使用 setreuid()仅将有效用户 ID 修改为实际用户 ID 的当前值，那么保存 set-user-ID 的值将保持不变，并且后续可调用 setreuid()（或 seteuid()）将有效用户 ID恢复为保存 set-user-ID 的值。（setreuid()和 setregid()针对保存设置 ID 的这一效果，SUSv3未做规定，但已被 SUSv4 纳入规范。）规则 3 为 set-user-ID 程序提供了一个永久放弃特权的方法，使用如下调用：</p><p><img src="image-20230804163007950.png" alt="image-20230804163007950"></p><p>​        set-user-ID-root 进程若有意将用户凭证和组凭证改变为任意值，则应首先调用 setregid()，然后再调用 setreuid()。一旦调用顺序颠倒，那么调用 setregid()将会失败，因为调用 setreuid()后，程序将不再具有特权。若使用 setresuid()和 setresgid()（详见下述）来实现此功能，上述描述也同样适用。直至 4.3BSD，BSD 发行版都不支持保存 set-user-ID 和保存 set-group-ID（如今已为SUSv3 强制要求支持）。相反，在 BSD 中，setreuid()和 setregid()允许进程通过来回交换实际 ID 和有效 ID 来“收、放”特权。这一方式的不良副作用在于为了改变有效用户 ID 而改变实际用户 ID。</p><h4 id="获取实际、有效和保存设置-ID"><a href="#获取实际、有效和保存设置-ID" class="headerlink" title="获取实际、有效和保存设置 ID"></a>获取实际、有效和保存设置 ID</h4><p>​        在大多数 UNIX 实现中，进程不能直接获取（或修改）其保存 set-user-ID 和保存set-group-ID 的值。然而，Linux 提供了两个（非标准的）系统调用来实现此项功能：getresuid() 和 getresgid()。getresuid()系统调用将调用进程的当前实际用户 ID、有效用户 ID 和保存 set-user-ID 值返回至给定 3 个参数所指定的位置。getresgid()系统调用针对相应的组 ID 实现了类似功能。修改实际、有效和保存设置 ID setresuid()系统调用允许调用进程独立修改其 3 个用户 ID 的值。每个用户 ID 的新值由系统调用的 3 个参数给定。setresgid()系统调用对相应的组 ID 实现了类似功能。若不想同时修改这些 ID，则需将无意修改的 ID 参数值指定为-1。例如，下列调用等同于seteuid(x)调用：关于 setresuid()可做何种修改的规则（setresgid()与之类似）如下所示。</p><p>1． 非特权进程能够将实际用户 ID、有效用户 ID 和保存 set-user-ID 中的任一 ID 设置为实际用户 ID、有效用户 ID 或保存 set-user-ID 之中的任一当前值。</p><p>2． 特权级进程能够对其实际用户 ID、有效用户 ID 和保存 set-user-ID 做任意设置。</p><p>3． 不管系统调用是否对其他 ID 做了任何改动，总是将文件系统用户 ID 设置为与有效用户ID（可能是新值）相同。</p><p>​        setresuid()和 setresgid()调用具有 0/1 效应，即对 ID 的修改请求要么全都成功，要么全部失败。（这也适用于本章所述其他修改多个 ID 的系统调用。）</p><p>​        虽然 setresuid()和 setresgid()为修改进程凭证提供了最为直接的 API，但在应用程序中采用这些调用会带来可移植性问题。SUSv3 规范并未包括这些调用，且其他 UNIX 实现对其也鲜有支持。</p><h3 id="9-7-2-获取和修改文件系统-ID"><a href="#9-7-2-获取和修改文件系统-ID" class="headerlink" title="9.7.2 获取和修改文件系统 ID"></a>9.7.2 获取和修改文件系统 ID</h3><p>​        前述所有修改进程有效用户 ID 或组 ID 的系统调用总是会修改相应的文件系统 ID。要想独立于有效 ID 而修改文件系统 ID，必须使用 Linux 特有的系统调用：setfsuid() 和 setfsgid()。</p><p><img src="image-20230804163117649.png" alt="image-20230804163117649"></p><p>​        setfsuid()系统调用将进程文件系统用户 ID 修改为参数 fsuid 所指定的值。setfsgid()系统调用将文件系统组 ID 修改为参数 fsgid 所指定的值。同样，此类变更也存在一些规则。setfsgid()的规则类似于 setfsuid()，下面以 setfsuid()为例。1． 非特权进程能够将文件系统用户 ID 设置为实际用户 ID、有效用户 ID、文件系统用户 ID（即保持不变）或保存 set-user-ID 的当前值。2． 特权级进程能够将文件系统用户 ID 设置为任意值。这些系统调用的实现存在一些瑕疵。首先，没有相应的系统调用来获取当前的文件系统ID。另外，这些系统调用根本不做错误检查。一旦非特权进程试图将文件系统 ID 设置为一个非法值，这一不轨企图也只是被静默地忽略掉。无论这些调用成功与否，其返回值都是之前相关文件系统的 ID。因此，这确实也是一种获得当前文件系统 ID 的方法，但却只能是在尝试修改这些值（不管是否成功）的同时进行。在 Linux 系统中，使用 setfsuid()和 setfsgid()系统调用已不是必要的，若需要将应用程序移植到其他 UNIX 实现上，则应在设计时避免使用这两个调用。</p><h3 id="9-7-3-获取和修改辅助组-ID"><a href="#9-7-3-获取和修改辅助组-ID" class="headerlink" title="9.7.3 获取和修改辅助组 ID"></a>9.7.3 获取和修改辅助组 ID</h3><p>​        getgroups()系统调用会将当前进程所属组的集合返回至由参数 grouplist 指向的数组中。</p><p><img src="image-20230804163130639.png" alt="image-20230804163130639"></p><p>​        像大多数 UNIX 实现一样，Linux 中的 getgroups()仅返回调用进程的辅助组 ID。然而，SUSv3 规范还允许 UNIX 实现在返回的 grouplist 中包含调用进程的有效组 ID。调用程序必须负责为 grouplist 数组分配存储空间，并在 gidsetsize 参数中指定其长度。若调用成功，getgroups()会返回置于 grouplist 中的组 ID 数量。若进程属组的数量超出 gidsetsize，则 getgroups()将返回错误(错误号为 EINVAL)。为了避免发生这种情况，可将 grouplist 数组的大小调整为常量 NGROUPS_MAX+1（考虑到可移植性，数组中可能包含了有效组 ID），该常量（定义于<limits.h>文件中）定义了进程属组的最大数量。因此，可声明 grouplist 如下：</p><p><img src="image-20230804163213452.png" alt="image-20230804163213452"></p><p>​        在 Linux 内核版本 2.6.4 之前，NGROUPS_MAX 的值为 32。始于内核版本 2.6.4，NGROUPS_MAX 的值为 65536。应用程序要在运行时获取 NGROUPS_MAX 的上限，还可使用如下方法。</p><ul><li>调用 sysconf(_SC_NGROUPS_MAX)。（11.2 节解释了 sysconf()的用法。）</li><li>从 Linux 特有的/proc/sys/kernel/ngroups_max 只读文件中读取该限制。系统从内核 2.6.4开始提供该文件。</li></ul><p>​        除此之外，应用程序还能在调用 getgroups()时将 gidtsetsize 参数指定为 0。这样一来，grouplist 数组未作修改，但调用的返回值却给出了进程属组的数量。通过上述任意一种运行时技术所获取的 NGROUPS_MAX 值，可用于为后续的 getgroups()调用动态分配 grouplist 数组。特权级进程能够使用 setgroups()和 initgroups()来修改其辅助组 ID 集合。</p><p><img src="image-20230804163236924.png" alt="image-20230804163236924"></p><p>​        setgroups()系统调用用 grouplist 数组所指定的集合来替换调用进程的辅助组 ID。参数gidsetsize 指定了置于参数 grouplist 数组中的组 ID 数量。initgroups()函数将扫描/etc/groups 文件，为 user 创建属组列表，以此来初始化调用进程的辅助组 ID。另外，也会将参数 group 指定的组 ID 追加到进程辅助组 ID 的集合中。initgroups()函数的主要用户是创建登录会话的程序—例如 login(1)，在用户调用登录shell 之前，为进程设置各种属性。此类程序一般通过读取密码文件中用户记录的组属性来获取参数 group 的值。这稍微有点令人费解，因为密码文件中的组 ID 实际并非辅助组 ID，而是定义了登录 shell 初始的实际组 ID、有效组 ID 和保存 set-group-ID。尽管如此，这却是 initgroups()函数的常用使用方式。虽然未纳入 SUSv3，setgroups()和 initgroups()却获得了所有 UNIX 实现的支持。9.7.4 修改进程凭证的系统调用总结表 9-1 对修改进程凭证的各种系统调用及库函数的效果进行了总结。图 9-1 提供了表 9-1 中信息的概括图示。本图内容是从修改用户 ID 的角度加以展示的，但修改组 ID 的规则与之类似。</p><p><img src="image-20230804163336265.png" alt="image-20230804163336265"></p><p><img src="image-20230804163342553.png" alt="image-20230804163342553"></p><ul><li>glibc 库对 seteuid()(setresuid(–1，e，–1))和 setegid()(setregid (–1，e，–1))函数的实现方式允许将有效 ID 设置为有效 ID 的当前值，但 SUSv3 对此未作规范。此外，若将有效组 ID 设置为当前实际组 ID 之外的值，那么 setegid()的函数实现还会修改保存设置组 ID。（对于setegid()实现这一修改保存 set-group-ID 的行为，SUSv3 也未作规范。）</li><li>针对特权级进程和非特权进程调用 setreuid()和 setregid()的情况，若 r 的值不等于−1，或者 e 的值有别于函数调用前的实际 ID，则将保存 set-user-ID 或保存 set-group-ID 设置为（新的）有效 ID。（setreuid()和 setregid()函数对保存设置 ID 的修改未获 SUSv3 支持。）</li><li>只要修改了有效用户（组）ID，就会将 Linux 特有的文件系统用户（组）ID 也修改为相同值。</li><li>不管有效用户 ID 是否改变，setresuid()系统调用总是把文件系统用户 ID 修改为有效用户 ID， setresgid()系统调用对文件系统组 ID 的效力与之类似。</li></ul><h3 id="9-7-5-示例：显示进程凭证"><a href="#9-7-5-示例：显示进程凭证" class="headerlink" title="9.7.5 示例：显示进程凭证"></a>9.7.5 示例：显示进程凭证</h3><p>​        程序清单 9-1 中的程序使用前述系统调用和库函数来获取进程的所有用户 ID 和组 ID，并显示出来。</p><p><img src="image-20230804163430283.png" alt="image-20230804163430283"></p><p><img src="image-20230804163435545.png" alt="image-20230804163435545"></p><h2 id="9-8-总结"><a href="#9-8-总结" class="headerlink" title="9.8 总结"></a>9.8 总结</h2><p>​        每个进程都有一干与之相关的用户 ID 和组 ID（凭证）。实际 ID 定义了进程所属1。在大多数的 UNIX 实现中，进程对诸如文件之类资源的访问，其许可权限由有效 ID 决定。然而，Linux 会使用文件系统 ID 来决定对文件的访问权限，而将有效 ID 用于检查其他权限。（因为文件系统 ID 一般等同于相应的有效 ID，所以 Linux 对文件权限的检查方式与其他 UNIX 实现相同。）进程辅助组 ID 则是出于权限检查目的而另行设立的进程属组集合。存在各种系统调用和库函数支持进程获取和修改其用户 ID 和组 ID。set-user-ID 程序运行时，会将进程有效用户 ID 置为文件属主的用户 ID。运行某个特殊程序时，这种机制支持用户“假借”其他用户的身份和特权。相应的，set-group-ID 程序会修改运行该程序的进程的有效组 ID。保存 set-user-ID 和保存 set-group-ID 允许 set-user-ID 和set-group-ID 程序临时性地放弃特权，并在之后恢复特权。0 在用户 ID 中可谓卓尔不群。通常仅为一个名为 root 的账号所有。有效用户 ID 为 0 的进程属特权级进程。换言之，对于进程发起的各种系统调用，可免于接受通常所要历经的诸多权限检查（比如那些能够随意修改进程各种用户 ID 和组 ID 的调用）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux漫游——进程</title>
      <link href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="6-1-进程和程序"><a href="#6-1-进程和程序" class="headerlink" title="6.1 进程和程序"></a>6.1 进程和程序</h2><p>​        <strong>进程（process）是一个可执行程序（program）的实例。</strong>本节将阐述进程定义，并澄清其与程序之间的区别。程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，所包括的内容如下所示。</p><pre><code>     二进制格式标识：**每个程序文件都包含用于描述可执行文件格式的元信息（metainformation）**。内核（kernel）利用此信息来解释文件中的其他信息。历史上，UNIX可执行文件曾有两种广泛使用的格式，分别为最初的 a.out（汇编程序输出）和更加复杂的 COFF（通用对象文件格式）。现在，大多数 UNIX 实现（包括 Linux）采用可执行连接格式（ELF），这一文件格式比老版本格式具有更多优点。</code></pre><ul><li>机器语言指令：<strong>对程序算法进行编码。</strong></li><li>程序入口地址：<strong>标识程序开始执行时的起始指令位置。</strong></li><li>数据：<strong>程序文件包含的变量初始值和程序使用的字面常量（literal constant）值（比如字符串）。</strong></li><li>符号表及重定位表：<strong>描述程序中函数和变量的位置及名称。这些表格有多种用途，其中包括调试和运行时的符号解析（动态链接）。</strong></li><li>共享库和动态链接信息：<strong>程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名。</strong></li><li>其他信息：<strong>程序文件还包含许多其他信息，用以描述如何创建进程。</strong></li></ul><p>​        可以用一个程序来创建许多进程，或者反过来说，许多进程运行的可以是同一程序。在此将本节开始时给出的进程定义重新改写为，进程是由内核定义的抽象的实体，并为该实体分配用以执行程序的各项系统资源。</p><p>​        从内核角度看，进程由用户内存空间（user-space memory）和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p><h2 id="6-2-进程号和父进程号"><a href="#6-2-进程号和父进程号" class="headerlink" title="6.2 进程号和父进程号"></a>6.2 进程号和父进程号</h2><p>​        每个进程都有一个进程号（PID），进程号是一个正数，用以唯一标识系统中的某个进程。对各种系统调用而言，进程号有时可以作为传入参数，有时可以作为返回值。比如，系统调用 kill()（20.5 节）允许调用者向拥有特定进程号的进程发送一个信号。当需要创建一个对某进程而言唯一的标识符时，进程号就会派上用场。常见的例子是将进程号作为与进程相关文件名的一部分。</p><p>系统调用 getpid()返回调用进程的进程号。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;unistd.h&gt;pid_t getpid(void);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        getpid()返回值的数据类型为 pid_t，该类型是由 SUSv3 所规定的整数类型，专用于存储进程号。除了少数系统进程外，比如 init 进程（进程号为 1），程序与运行该程序进程的进程号之间没有固定关系。Linux 内核限制进程号需小于等于 32767。新进程创建时，内核会按顺序将下一个可用的进程号分配给其使用。每当进程号达到 32767 的限制时，内核将重置进程号计数器，以便从小整数开始分配。</p><pre class="line-numbers language-none"><code class="language-none">一旦进程号达到 32767，会将进程号计数器重置为 300，而不是 1。之所以如此，是因为低数值的进程号为系统进程和守护进程所长期占用，在此范围内搜索尚未使用的进程号只会是浪费时间。在 Linux2.4 版本及更早版本中，进程号的上限 32767，由内核常量 PID_MAX 所定义。在 Linux 2.6 版本中，情况有所改变。尽管进程号的默认上限仍是 32767，但可以通过 Linux系统特有的&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max 文件来进行调整（其值&#x3D;最大进程号+1）。在 32 位平台中，pid_max 文件的最大值为 32768，但在 64 位平台中，该文件的最大值可以高达到 222（约400 万），系统可能容纳的进程数量会非常庞大。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        每个进程都有一个创建自己的父进程。使用系统调用 getppid()可以检索到父进程的进程号。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;unistd.h&gt;pid_t getppid(void);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        实际上，每个进程的父进程号属性反映了系统上所有进程间的树状关系。每个进程的父进程又有自己的父进程，以此类推，回溯到 1 号进程—init 进程，即所有进程的始祖。使用pstree(1)命令可以查看到这一“家族树”（family tree）。</p><p>​        <strong>如果子进程的父进程终止，则子进程就会变成“孤儿”，init 进程随即将收养该进程，子进程后续对 getppid()的调用将返回进程号 1（参照 26.2 节）。</strong>通过查看由 Linux 系统所特有的/proc/PID/status 文件所提供的 PPid 字段，可以获知每个进程的父进程。</p><h2 id="6-3-进程内存布局"><a href="#6-3-进程内存布局" class="headerlink" title="6.3 进程内存布局"></a>6.3 进程内存布局</h2><p>​        <strong>每个进程所分配的内存由很多部分组成，通常称之为“段（segment）”</strong>。如下所示。y 文本段包含了进程运行的程序机器语言指令。<strong>文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。</strong>因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。</p><ul><li><strong>初始化数据段包含显式初始化的全局变量和静态变量。</strong>当程序加载到内存时，从可执行文件中读取这些变量的值。</li><li><strong>未初始化数据段包含了未进行显式初始化的全局变量和静态变量。程序启动之前，系统将本段内所有内存初始化为 0。</strong>出于历史原因，此段常被称为 BSS 段，这源于老版本的汇编语言助记符“block started by symbol”。将经过初始化的全局变量和静态变量与未经初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配这一空间。</li><li><strong>栈（stack）是一个动态增长和收缩的段，由栈帧（stack frames）组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。</strong>6.5 节将深入讨论栈帧。</li><li>堆（heap）是可在运行时（为变量）动态进行内存分配的一块区域。堆顶端称作program break。</li></ul><p>​        <strong>对于初始化和未初始化的数据段而言，不太常用、但表述更清晰的称谓分别是用户初始化数据段（user-initialized data segment）和零初始化数据段（zero-initialized data segment）。</strong>size(1)命令可显示二进制可执行文件的文本段、初始化数据段、非初始化数据段（bss）的段大小。</p><pre class="line-numbers language-none"><code class="language-none">正文中使用的术语“段（segment）”不应与一些硬件体系架构，比如 x86-32 中使用的硬件分段（segmentation）相混淆。相反，本文中的段是对 UNIX 系统中进程虚拟内存的逻辑划分。有时，会使用术语“区（section）”来替代段，因为在当下风行的可执行文件格式（ELF）规范中，采用的术语与“区”更趋一致。本书会在多处涉及这种情况：库函数返回的指针指向静态分配的内存。这意味着，该内存既可在初始化数据段中分配，也可在非初始化数据段中分配。（某些情况下，库函数转而会在堆上对内存做一次性动态分配，然而，这一实现细节与这里所要表达的意思无关。）库函数有时会通过静态分配的内存来返回信息，了解这一情况至关重要，因为这片内存的存在独立于函数调用，后续对同一函数的调用可能会将其覆盖（有时，后续对相关函数的调用也有相同的效应）。使用静态分配的内存会使函数不可重入（nonreentrant）。21.1.2 节和31.1 节将深入讨论重入（reentrancy）问题。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        程序清单 6-1 展示了不同类型的 C 语言变量，并以注释说明每种变量分属于哪个段。这些说明正确的前提是假定使用了非优化的编译器，且在应用程序二进制接口（ABI）中，是通过栈来传递所有参数的。实际上，优化编译器会将频繁使用的变量分配于寄存器中，或者索性将变量彻底剔除1。此外，一些 ABI 需要通过寄存器，而不是栈，来传递函数实参和结果。尽管如此，本例只是意在展示 C 语言变量和进程各段间的映射关系。</p><p>程序清单 6-1：程序变量在进程内存各段中的位置 </p><p><img src="image-20230803185306027.png" alt="image-20230803185306027"></p><pre class="line-numbers language-none"><code class="language-none">应用程序二进制接口（ABI）是一套规则，规定了二进制可执行文件在运行时应如何与某些服务（诸如内核或函数库所提供的服务）交换信息。ABI 特别规定了使用哪些寄存器 1 译者注：例如，以寄存器取代变量。和栈地址来交换信息以及所交换值的含义，一旦针对某个特定 ABI 进行了编译，其二进制可执行文件应能在 ABI 相同的任何系统上运行。与之相反，标准化的 API（如 SUSv3）仅能通过编译源代码来保证应用程序的可移植性。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        虽然 SUSv3 未作规定，但在大多数 UNIX 实现（包括 Linux）中 C 语言编程环境提供了 3个全局符号（symbol）：etext、edata 和 end，可在程序内使用这些符号以获取相应程序文本段、初始化数据段和非初始化数据段结尾处下一字节的地址。使用这些符号，必须显式声明如下：</p><p><img src="image-20230803185331778.png" alt="image-20230803185331778"></p><p>​        图 6-1 展示了各种内存段在 x86-32 体系结构中的布局，该图的顶部标记为 argv、environ的空间用来存储程序命令行实参（通过 C 语言中 main()函数的 argv 参数获得）和进程环境列表（稍后讨论），图中十六进制的地址会因内核配置和程序链接选项差异而有所不同。图中标灰的区域表示这些范围在进程虚拟地址空间中不可用，也就是说，没有为这些区域创建页表（page table）（参考以下关于虚拟内存管理的讨论）。</p><p><img src="image-20230803185354125.png" alt="image-20230803185354125"></p><p>​        48.5 节将更为详细地重新讨论进程内存布局的课题，还将论及共享内存和共享库在进程虚拟内存中的放置位置。</p><h2 id="6-4-虚拟内存管理"><a href="#6-4-虚拟内存管理" class="headerlink" title="6.4 虚拟内存管理"></a>6.4 虚拟内存管理</h2><p>​        上述关于进程内存布局的讨论忽略了一个事实：这一布局存在于虚拟内存中。因为对虚拟内存的理解将有助于后续对诸如 fork()系统调用、共享内存和映射文件之类主题的阐述，所以这里将探讨一些有关虚拟内存的详细内容。</p><p>​        Linux，像多数现代内核一样，采用了虚拟内存管理技术。该技术利用了大多数程序的一个典型特征，即访问局部性（locality of reference），以求高效使用 CPU 和 RAM（物理内存）资源。大多数程序都展现了两种类型的局部性。</p><ul><li>空间局部性（Spatial locality）：<strong>是指程序倾向于访问在最近访问过的内存地址附近的内存（由于指令是顺序执行的，且有时会按顺序处理数据结构）。</strong></li><li>时间局部性（Temporal locality）：<strong>是指程序倾向于在不久的将来再次访问最近刚访问过的内存地址（由于循环）。</strong></li></ul><p>​        正是由于访问局部性特征，使得程序即便仅有部分地址空间存在于 RAM 中，依然可能得以执行。虚拟内存的规划之一是将每个程序使用的内存切割成小型的、固定大小的“页”（page）单元。相应地，将 RAM 划分成一系列与虚存页尺寸相同的页帧。任一时刻，每个程序仅有部分页需要驻留在物理内存页帧中。这些页构成了所谓驻留集（resident set）。程序未使用的页拷贝保存在交换区（swap area）内—这是磁盘空间中的保留区域，作为计算机 RAM 的补充— 仅在需要时才会载入物理内存。若进程欲访问的页面目前并未驻留在物理内存中，将会发生页面错误（page fault），内核即刻挂起进程的执行，同时从磁盘中将该页面载入内存。</p><pre class="line-numbers language-none"><code class="language-none">在 x86-32 中，页面大小为 4096 个字节。其他一些 Linux 实现使用的页面比 4096 个字节更大。例如，Alpha 使用的页面大小为 8192 个字节，IA-64 使用的页面大小是可变的，默认为 16384 个字节。程序可调用 sysconf(_SC_PAGESIZE)来获取系统虚拟内存的页面大小，具体参见 11.2 节的描述。_<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        为支持这一组织方式，内核需要为每个进程维护一张页表（page table）（见图 6-2）。该页表描述了每页在进程虚拟地址空间（virtual address space）中的位置（可为进程所用的所有虚拟内存页面的集合）。页表中的每个条目要么指出一个虚拟页面在 RAM 中的所在位置，要么表明其当前驻留在磁盘上。在进程虚拟地址空间中，并非所有的地址范围都需要页表条目。通常情况下，由于可能存在大段的虚拟地址空间并未投入使用，故而也无必要为其维护相应的页表条目。若进程试图访问的地址并无页表条目与之对应，那么进程将收到一个 SIGSEGV 信号。由于内核能够为进程分配和释放页（和页表条目），所以进程的有效虚拟地址范围在其生命周期中可以发生变化。这可能会发生于如下场景。</p><ul><li>由于栈向下增长超出之前曾达到的位置。</li><li>当在堆中分配或释放内存时，通过调用 brk()、sbrk()或 malloc 函数族（第 7 章）来提升 program break 的位置。</li><li>当调用 shmat()连接 System V 共享内存区时，或者当调用 shmdt()脱离共享内存区时（第48 章）。</li><li>当调用 mmap()创建内存映射时，或者当调用 munmap()解除内存映射时（第 49 章）。</li></ul><p><img src="image-20230803185529409.png" alt="image-20230803185529409"></p><pre class="line-numbers language-none"><code class="language-none">虚拟内存的实现需要硬件中分页内存管理单元（PMMU）的支持。PMMU 把要访问的每个虚拟内存地址转换成相应的物理内存地址，当特定虚拟内存地址所对应的页没有驻留于 RAM 中时，将以页面错误通知内核。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        虚拟内存管理使进程的虚拟地址空间与 RAM 物理地址空间隔离开来，这带来许多优点。</p><ul><li>进程与进程、进程与内核相互隔离，所以一个进程不能读取或修改另一进程或内核的内存。这是因为每个进程的页表条目指向 RAM（或交换区）中截然不同的物理页面集合。</li><li>适当情况下，两个或者更多进程能够共享内存。这是由于内核可以使不同进程的页表条目指向相同的 RAM 页。内存共享常发生于如下两种场景。 –执行同一程序的多个进程，可共享一份（只读的）程序代码副本。当多个程序执 行相同的程序文件（或加载相同的共享库）时，会隐式地实现这一类型的共享。 –进程可以使用 shmget()和 mmap()系统调用显式地请求与其他进程共享内存区。 这么做是出于进程间通信的目的。</li><li>便于实现内存保护机制；也就是说，可以对页表条目进行标记，以表示相关页面内容是可读、可写、可执行亦或是这些保护措施的组合。多个进程共享 RAM 页面时，允许每个进程对内存采取不同的保护措施。例如，一个进程可能以只读方式访问某页面，而另一进程则以读写方式访问同一页面。</li><li>程序员和编译器、链接器之类的工具无需关注程序在 RAM 中的物理布局。</li><li>因为需要驻留在内存中的仅是程序的一部分，所以程序的加载和运行都很快。而且，一个进程所占用的内存（即虚拟内存大小）能够超出 RAM 容量。</li></ul><p>​        虚拟内存管理的最后一个优点是：由于每个进程使用的 RAM 减少了，RAM 中同时可以容纳的进程数量就增多了。这增大了如下事件的概率：在任一时刻，CPU 都可执行至少一个进程，因而往往也会提高 CPU 的利用率。</p><h2 id="6-5-栈和栈帧"><a href="#6-5-栈和栈帧" class="headerlink" title="6.5 栈和栈帧"></a>6.5 栈和栈帧</h2><p>​        函数的调用和返回使栈的增长和收缩呈线性。X86-32 体系架构之上的 Linux（和多数其他 Linux 和 UNIX 实现），栈驻留在内存的高端并向下增长（朝堆的方向）。专用寄存器—栈指针（stack pointer），用于跟踪当前栈顶。每次调用函数时，会在栈上新分配一帧，每当函数返回时，再从栈上将此帧移去。虽然栈向下增长，但仍将栈的增长端称为栈顶，因为抽象地说来，情况本就如此。栈的实际增长方向是个（属于硬件范畴的）实现细节。在 HP PA-RISC 的 Linux 实现中，<strong>栈的增长方向就是向上的。就虚拟内存而言，分配栈帧后，栈段的大小将会增长，</strong>但在大多数（Linux）实现中，释放这些栈帧后，栈的大小并未减少（在分配新的栈帧时，会对这些内存重新加以利用）。当谈论栈段的增长和收缩时，只是从逻辑视角来看待栈帧在栈中的增减情况。</p><p>​        有时，会用用户栈（user stack）来表示此处所讨论的栈，以便与内核栈区分开来。内核栈是每个进程保留在内核内存中的内存区域，在执行系统调用的过程中供（内核）内部函数调用使用。（由于用户栈驻留在不受保护的用户内存中，所以内核无法利用用户栈来达成这一目的。）每个（用户）栈帧包括如下信息。</p><ul><li>函数实参和局部变量：<strong>由于这些变量都是在调用函数时自动创建的，因此在 C 语言中称其为自动变量。函数返回时将自动销毁这些变量（因为栈帧会被释放），这也是自动变量与静态（以及全局）变量主要的语义区别：后者与函数执行无关，且长期存在。</strong></li><li>（函数）调用的链接信息：<strong>每个函数都会用到一些 CPU 寄存器，比如程序计数器，其指向下一条将要执行的机器语言指令。每当一函数调用另一函数时，会在被调用函数的栈帧中保存这些寄存器的副本，以便函数返回时能为函数调用者将寄存器恢复原状。</strong></li></ul><p>​        因为函数能够嵌套调用，所以栈中可能有多个栈帧。（若一函数递归调用自身，则该函数在栈中将有多个栈帧。）参考程序清单 6-1，在 square()函数执行期间，栈中包含的帧如图 6-3 所示。</p><p><img src="image-20230803190347601.png" alt="image-20230803190347601"></p><h2 id="6-6-命令行参数（argc-argv）"><a href="#6-6-命令行参数（argc-argv）" class="headerlink" title="6.6 命令行参数（argc, argv）"></a>6.6 命令行参数（argc, argv）</h2><p>​        每个 C 语言程序都必须有一个称为 main()的函数，作为程序启动的起点。当执行程序时，命令行参数（command-line argument）（由 shell 逐一解析）通过两个入参提供给 main()函数。第一个参数 int argc，表示命令行参数的个数。第二个参数 char *argv[]，是一个指向命令行参数的指针数组，每一参数又都是以空字符（null）1结尾的字符串。第一个字符串，亦即 argv[0] 指向的，（通常）是该程序的名称。argv 中的指针列表以 NULL 指针结尾（即 argv[argc]为 NULL）。argv[0]包含了调用程序的名称，可以利用这一特性玩个实用的小技巧。首先为同一程序创建多个链接（即名称不同），然后让该程序查看 argv[0]，并根据调用程序的名称来执行不同任务。gzip(1)、gunzip(1)和 zcat(1)命令是该技术应用的一个例子，这些命令链接的都是同一可执行文件。（使用该技术，必须小心处理如下情况：用户通过链接调用程序，但链接名又在该程序的意料之外。）图 6-4 展示了执行程序清单 6-2 中程序所传入参 argc 和 argv 的数据结构。该图使用 C 语言符号“\0”来表示每个字符串末尾的终止空字节。程序清单 6-2 中的程序回显了其命令行参数，逐一按行输出，前面还冠以要显示的 argv成员名称。</p><p><img src="image-20230803190423282.png" alt="image-20230803190423282"></p><p>​        程序清单 6-2：回显命令行参数</p><p><img src="image-20230803190443495.png" alt="image-20230803190443495"></p><p>​        因为 argv 列表以 NULL 值终止，所以可以将程序清单 6-2 中的程序主体改写如下，且每行只输出一个命令行实参：</p><p><img src="image-20230803190455956.png" alt="image-20230803190455956"></p><p>​        argc/argv 参数机制的局限之一在于这些变量仅对 main()函数可用。<strong>在保证可移植性的同时，为使这些命令行参数能为其他函数所用，必须把 argv 以参数形式传递给这些函数，或是设置一个指向 argv 的全局变量。</strong>要想从程序内任一位置访问这些信息的部分或者全部内容，还有两个方法，但是会破坏程序的可移植性。</p><ul><li>通过 linux 系统专有的/proc/PID/cmdline 文件可以读取任一进程的命令行参数，每个参数都以空（null）字节终止。（程序可以通过/proc/self/cmdline 文件访问自己的命令行参数。）</li><li>GNU C 语言库提供有两个全局变量，可在程序内任一位置使用以获取调用该程序时的程序名称（即命令行的第一个参数）。第一个全局变量 program_invocation_ name，提供了用于调用该程序的完整路径名。第二个全局变量 program_invocation_ short_name，提供了不含目录的程序名称，即路径名的基本名称（basename）部分，定义_GNU_SOURCE宏后即可从<errno.h>中获得对这两个全局变量的声明。</li></ul><p>​        正如图 6-1 所示，argv 和 environ 数组，以及这些参数最初指向的字符串，都驻留在进程栈之上的一个单一、连续的内存区域。（下一节将描述 environ 参数，该参数用于存储程序的环境列表。）此区域可存储的字节数有上限要求，SUSv3 规定使用 ARG_MAX 常量（定义于<limits.h>）或者调用sysconf（_SC_ARG_MAX）函数以确定该上限值（将在11.2节描述sysconf()函数），并且 SUSv3 还要求 ARG_MAX 常量的下限为_POSIX_ARG_MAX（4096）个字节，而大多数 UNIX 实现的限制都远高于此。但 SUSv3 并未规定对 ARG_MAX 限制的实现中是否要将一些开销字节计算在内（比如终止空字符、字节对齐、argv 和 environ 指针数组）。Linux 中的 ARG_MAX 参数值曾一度固定为 32 个页面（在 Linux/x86-32 中即为 131072个字节），且包含了开销字节。自内核 2.6.23 版本开始，可以通过资源限制 RLIMIT_STACK来控制 argv 和 environ 参数所使用的空间总量上限，在这种情况下，允许 argv 和 environ 参数使用的空间上限要比以前大出许多，具体限额为资源软限制 RLIMIT_ STACK 的四分之一，RLIMIT_STACK 在调用 execve()时已经生效。更多详细信息请参照 execve(2)手册页。许多程序（包括本书中的几个例子）使用 getopt()库函数解析命令行选项（即以“-”符号开头的参数）。附录（Appendix）B 将描述 getopt()函数。</p><h2 id="6-7-环境列表"><a href="#6-7-环境列表" class="headerlink" title="6.7 环境列表"></a>6.7 环境列表</h2><p>​        <strong>每一个进程都有与其相关的称之为环境列表（environment list）的字符串数组，或简称为环境（environment）。其中每个字符串都以名称=值（name=value）形式定义。</strong>因此，环境是<strong>“名称-值”</strong>的成对集合，可存储任何信息。常将列表中的名称称为环境变量（environment variables）。新进程在创建之时，会继承其父进程的环境副本。这是一种原始的进程间通信方式，却颇为常用。环境（environment）提供了将信息从父进程传递给子进程的方法。由于子进程只有在创建时才能获得其父进程的环境副本，所以这一信息传递是单向的、一次性的。子进程创建后，父、子进程均可更改各自的环境变量，且这些变更对对方而言不再可见。环境变量的常见用途之一是在 shell 中。<strong>通过在自身环境中放置变量值，shell 就可确保把这些值传递给其所创建的进程，并以此来执行用户命令。</strong>例如，环境变量 SHELL 被设置为 shell程序本身的路径名，如果程序需要执行 shell 时，大多会将此变量视为需要执行的 shell 名称。可以通过设置环境变量来改变一些库函数的行为。正因如此，用户无需修改程序代码或者重新链接相关库，就能控制调用该函数的应用程序行为。getopt()函数就是其中一例（附录 B），可通过设置 POSIXLY_CORRECT 环境变量来改变此函数的行为。<strong>大多数 shell 使用 export 命令向环境中添加变量值。</strong></p><p>​        <img src="image-20230803190600194.png" alt="image-20230803190600194">        在 bash         shell 和 Korn shell 中，可以简写为：</p><pre class="line-numbers language-none"><code class="language-none">export SHELL&#x3D;&#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在 C shell 中，使用的则是 setenv 命令：</p><p><img src="image-20230803190628428.png" alt="image-20230803190628428"></p><p>​        上述命令把一个值永久地添加到 shell 环境中，此后这个 shell 创建的所有子进程都将继承此环境。在任一时刻，可以使用 unset 命令撤销一个环境变量（在 C shell 中则使用 unsetenv 命令）。在 Bourne shell 和其衍生 shell（诸如 bash shell 和 Korn shell）中，可使用下列语法向执行某应用程序的环境中添加一个变量值，而不影响其父 shell（和后续命令）：</p><pre class="line-numbers language-none"><code class="language-none">NAME&#x3D;value program<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        此命令仅向执行特定程序的子进程环境添加了一个（环境变量）定义。如果希望（多个变量对该程序有效），可以在 program 前放置多对赋值（以空格分隔）。env 命令在运行程序时使用了一份经过修改的 shell 环境列表副本。可同时为 shell 环境列表副本增加和移除环境变量定义，以修改此环境列表。</p><p><img src="image-20230830142458839.png" alt="image-20230830142458839"></p><p>​        详细内容请参阅 env(1)手册。printenv 命令显示当前的环境列表，此处是其输出的一例：后续章节中将适时描述大多数上述环境变量的用途（也可参阅 environ(7)手册）。由以上输出可知，环境列表的排列是无序的，列表中的字符串顺序不过是最易于实现的排列形式。一般而言，无序的环境列表不是问题，因为通常都是访问单个的环境变量，而非环境列表中按序排列的一串。通过 Linux 专有的/proc/PID/environ 文件检查任一进程的环境列表，每一个“NAME=value”对都以空字节终止。</p><h4 id="从程序中访问环境"><a href="#从程序中访问环境" class="headerlink" title="从程序中访问环境"></a>从程序中访问环境</h4><p>​        在 C 语言程序中，可以使用全局变量 char **environ 访问环境列表。（C 运行时启动代码定义了该变量并以环境列表位置为其赋值。）environ 与 argv 参数类似，指向一个以 NULL 结尾的指针列表，每个指针又指向一个以空字节终止的字符串。图 6-5 所示为与上述 printenv 命令输出环境相对应的环境列表数据结构。</p><p><img src="image-20230803190757419.png" alt="image-20230803190757419"></p><p>​        程序清单 6-3 中的程序通过访问 environ 变量来展示该进程环境中的所有值。该程序的输出结果与 printenv 命令的输出结果相同。程序中的循环利用指针来遍历 environ 变量。虽然可以把 environ 当成数组来使用（正如程序清单 6-2 中 argv 的用法），但这多少有些生硬，因为环境列表中各项的排列不分先后，而且也没有变量（相当于 argc）用来指定环境列表的长度。（出于同样原因，也没有对图 6-5 中的 environ 数组诸元素进行编号。）</p><p>​        程序清单 6-3：显示进程环境 </p><p><img src="image-20230803190812189.png" alt="image-20230803190812189"></p><p>​        另外，还可以通过声明 main()函数中的第三个参数来访问环境列表：</p><p><img src="image-20230803190841535.png" alt="image-20230803190841535"></p><p>​        该参数随即可被视为 environ 变量来使用，所不同的是，该参数的作用域在 main()函数内。虽然 UNIX 系统普遍实现了这一特性，但还是要避免使用，因为除了局限于作用域限制外，该特性也不在 SUSv3 的规范之列。</p><p>​        getenv()函数能够从进程环境中检索单个值。</p><p><img src="image-20230803190827543.png" alt="image-20230803190827543"></p><p>​        向 getenv()函数提供环境变量名称，该函数将返回相应字符串指针。因此，就前面所示的环境（列表）示例来看，如果指定 SHELL 为参数 name，那么将返回/bin/bash。如果不存在指定名称的环境变量，那么 getenv()函数将返回 NULL。以下是使用 getenv()函数时可移植性方面的注意事项。</p><ul><li>SUSv3 规定应用程序不应修改 getenv()函数返回的字符串，这是由于（在大多数 UNIX实现中）该字符串实际上属于环境的一部分（即 name=value 字符串的 value 部分）。若需要改变一个环境变量的值，可以使用 setenv()函数或 putenv()函数（见下文）。</li><li>SUSv3 允许 getenv()函数的实现使用静态分配的缓冲区返回执行结果，后续对 getenv()、setenv()、putenv()或者 unsetenv()的函数调用可以重写该缓冲区。虽然 glibc 库的 getenv()函数实现并未这样使用静态缓冲区，但具备可移植性的程序如需保留 getenv()调用返回的字符串，就应先将返回字符串复制到其他位置，之后方可对上述函数发起调用。</li></ul><h4 id="修改环境"><a href="#修改环境" class="headerlink" title="修改环境"></a>修改环境</h4><p>​        有时，对进程来说，修改其环境很有用处。原因之一是这一修改对该进程后续创建的所有子进程均可见。另一个可能的原因在于设定某一变量，以求对于将要载入进程内存的新程序（“execed”）可见。从这个意义上讲，环境不仅是一种进程间通信的形式，还是程序间通信的方法。（第 27 章将深入描述这一点，还将解释在同一进程中 exec()函数如何使当前程序被一新程序所替代。）</p><p>​        putenv()函数向调用进程的环境中添加一个新变量，或者修改一个已经存在的变量值。</p><p><img src="image-20230803191007995.png" alt="image-20230803191007995"></p><p>​        参数 string 是一指针，指向 name=value 形式的字符串。调用 putenv()函数后，该字符串就成为环境的一部分，换言之，putenv 函数将设定 environ 变量中某一元素的指向与 string 参数的指向位置相同，而非 string 参数所指向字符串的复制副本。因此，如果随后修改 string 参数所指的内容，这将影响该进程的环境。出于这一原因，string 参数不应为自动变量（即在栈中分配的字符数组1），因为定义此变量的函数一旦返回，就有可能会重写这块内存区域。注意，putenv()函数调用失败将返回非 0 值，而非−1。putenv()函数的 glibc 库实现还提供了一个非标准扩展。如果 string 参数内容不包含一个等号（=），那么将从环境列表中移除以 string 参数命名的环境变量。</p><p>​        setenv()函数可以代替 putenv()函数，向环境中添加一个变量。</p><p><img src="image-20230803191255035.png" alt="image-20230803191255035"></p><p>​        setenv()函数为形如 name=value 的字符串分配一块内存缓冲区，并将 name 和 value 所指向的字符串复制到此缓冲区，以此来创建一个新的环境变量。注意，不需要（实际上，是绝对不要）在 name 的结尾处或者 value 的开始处提供一个等号字符，因为 setenv()函数会在向环境添加新变量时添加等号字符。若以 name 标识的变量在环境中已经存在，且参数 overwrite 的值为 0，则 setenv()函数将不改变环境，如果参数 overwrite 的值为非 0，则 setenv()函数总是改变环境。这一事实—setenv()函数复制其参数（到环境中）—意味着与 putenv()函数不同，之后对 name 和 value 所指字符串内容的修改将不会影响环境。此外，使用自动变量作为 setenv()函数的参数也不会有任何问题。unsetenv()函数从环境中移除由 name 参数标识的变量。</p><p><img src="image-20230803191315202.png" alt="image-20230803191315202"></p><p>​        同 setenv()函数一样，参数 name 不应包含等号字符。setenv()函数和 unsetenv()函数均来自 BSD，不如 putenv()函数使用普遍。尽管起初的POSIX.1 标准和 SUSv2 并未定义这两个函数，但 SUSv3 已将其纳入规范。在 glibc 2.2.2 之前版本中，unsetenv()函数原型的返回值为 void 类型，这与最初的 BSD实现中 unsetenv 的函数原型相同，一些 UNIX 实现目前仍然沿用 BSD 原型。有时，需要清除整个环境，然后以所选值进行重建。例如，为了以安全方式执行 set-user-ID程序（38.8 节），就需要这样做。可以通过将 environ 变量赋值为 NULL 来清除环境。</p><p>​        这也正是 clearenv()库函数的工作内容。</p><p><img src="image-20230803191341230.png" alt="image-20230803191341230"></p><p>​        在某些情况下，<strong>使用 setenv()函数和 clearenv()函数可能会导致程序内存泄露。</strong>前面已然提及：setenv()函数所分配的一块内存缓冲区，随之会成为进程环境的一部分。而调用 clearenv()时则没有释放该缓冲区（clearenv()调用并不知晓该缓冲区的存在，故而也无法将其释放）。反复调用这两个函数的程序，会不断产生内存泄露。实际上，这不大可能成为一个问题，因为程序通常仅在启动时调用 clearenv()函数一次，用于移除继承自其父进程（即调用 exec()函数来启动当前程序的程序）环境中的所有条目。</p><pre class="line-numbers language-none"><code class="language-none">许多 UNIX 实现都支持 clearenv()函数，但是 SUSv3 没有对此函数进行规范。SUSv3 规定如果应用程序直接修改 environ 变量，正如 clearenv()函数所做的那样，则不对 setenv()、unsetenv()和 getenv()的行为进行定义。（这一作法的根本原因在于禁止符合 SUSv3 标准的应用程序直接修改环境，意在使 UNIX 实现能完全控制其实现环境变量时所采用的数据结构。）SUSv3 允许应用程序清空自身环境的唯一方法是首先获取所有环境变量的列表（通过environ 变量获得所有环境变量的名称），然后逐一调用 unsetenv()移除每个环境变量。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h4><p>​        程序清单 6-4 展示了本节讨论的所有函数的用法。该应用程序首先清空环境，然后向环境中逐一添加命令行参数所提供的环境变量定义；之后，如果环境中尚无名为 GREET 的变量，就向环境中添加该变量；接着，从环境中移除名为 BYE 的变量；最后打印当前环境列表。此处为该程序运行时输出结果的一例：</p><p><img src="image-20230803191358487.png" alt="image-20230803191358487"></p><p>​        如果将 environ 参数赋值为 NULL（正如程序清单 6-4 中 clearenv()函数调用的所作所为），那么可以预见如下形式的循环（如程序清单 6-4 中使用的循环）将失败，因为*environ 是无效的。</p><p><img src="image-20230803191426575.png" alt="image-20230803191426575"></p><p>​        然而，如果 setenv()函数和 putenv()函数发现 environ 参数为 NULL，则会创建一个新的环境列表，并使 environ 参数指向此列表，结果上面的循环操作又将正确运行。</p><p>程序清单 6-4：修改进程环境</p><p><img src="image-20230803191451901.png" alt="image-20230803191451901"></p><h2 id="6-8-执行非局部跳转：setjmp-和-longjmp"><a href="#6-8-执行非局部跳转：setjmp-和-longjmp" class="headerlink" title="6.8 执行非局部跳转：setjmp()和 longjmp()"></a>6.8 执行非局部跳转：setjmp()和 longjmp()</h2><p>​        使用库函数 setjmp()和 longjmp()可执行非局部跳转（nonlocal goto）。术语“非局部（nonlocal）”是指跳转的目标为当前执行函数之外的某个位置。C 语言，像许多其他编程语言一样，包含 goto 语句。这就好比打开了潘多拉的魔盒。若无止境的滥用，将使程序难以阅读和维护。不过偶尔也能一显身手，令程序更简单、更快速，或是兼而有之。C 语言的 goto 语句存在一个限制，即不能从当前函数跳转到另一函数。然而，偶尔还是需要这一功能的。考虑错误处理中经常出现的如下场景：<strong>在一个深度嵌套的函数调用中发生了错误，需要放弃当前任务，从多层函数调用中返回，并在较高层级的函数中继续执行（也许甚至是在 main()中）。要做到这一点，可以让每个函数都返回一个状态值，由函数的调用者检查并做相应处理。这一方法完全有效，而且，在许多情况下，是处理这类场景的理想方法。然而，有时候如果能从嵌套函数调用中跳出，返回该函数的调用者之一（当前调用者或者调用者的调用者，等等），编码会更为简单。</strong>setjmp()和 longjmp()就提供了这一功能。</p><pre class="line-numbers language-none"><code class="language-none">由于在 C 语言中，所有函数作用域的层级相同（即标准 C 语言不支持嵌套函数申明，尽管 gcc 将此功能作为其扩展功能），所以 goto 语句不能应用于函数间跳转。给定两个函数X 和 Y，编译器无从知晓当调用 Y 时，X 函数的栈帧是否在栈上，所以也无法判断从 Y 函数跳转（goto）到 X 函数是否可行。支持嵌套函数声明的语言，比如 Pascal 语言，允许 goto从一个嵌套函数跳转到其调用者，编译器得以根据函数的静态作用域来确定函数动态作用域的某些信息。因此，编译器若在词法解析时获悉函数 Y 嵌套于函数 X 之内1，也必然能够推断当调用 Y 时，X 函数的栈帧一定已然在栈中存在（即动态作用域），并能为函数 Y 产生 goto 代码，从 Y 中跳转到 X 函数的某处。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        setjmp()调用为后续由 longjmp()调用执行的跳转确立了跳转目标。该目标正是程序发起setjmp()调用的位置。从编程角度看来，调用 longjmp()函数后，看起来就和从第二次调用 setjmp()返回时完全一样。通过查看 setjmp()返回的整数值，可以区分 setjmp 调用是初始返回还是第二次“返回”。初始调用返回值为 0，后续“伪”返回的返回值为 longjmp()调用中 val 参数所指定的任意值。通过对 val 参数使用不同值，能够区分出程序中跳转至同一目标的不同起跳位置。如果指定 longjmp()函数的 val 参数值为 0，而 longjmp 函数对此又不做检查，就会导致模拟 setjmp()时返回值为 0，如同初次调用 setjmp()函数返回时一样。出于这一原因，如果指定val 参数值为 0，则 longjmp()调用实际会将其替换为 1。</p><p>​        这两个函数的入参 env 为成功实现跳转提供了黏合剂。setjmp()函数把当前进程环境的各种信息保存到 env 参数中。调用 longjmp()时必须指定相同的 env 变量，以此来执行“伪”返回。由于对 setjmp()函数和 longjmp()函数的调用分别位于不同函数（否则，使用简单的 goto 即可），所以应该将 env 参数定义为全局变量，或者将 env 作为函数入参来传递，后一种做法较为少见。</p><p>​        调用 setjmp()时，env 除了存储当前进程的其他信息外，还保存了程序计数寄存器（指向当前正在执行的机器语言指令）和栈指针寄存器（标记栈顶）的副本。这些信息能够使后续的 longjmp()调用完成两个关键步骤的操作。</p><ul><li>将发起 longjmp()调用的函数与之前调用 setjmp()的函数之间的函数栈帧从栈上剥离。有时又将此过程称为“解开栈（unwinding the stack）”，这是通过将栈指针寄存器重置为 env 参数内的保存值来实现的。</li><li>重置程序计数寄存器，使程序得以从初始的 setjmp()调用位置继续执行。同样，此功能是通过 env 参数中的保存值（程序计数寄存器）来实现的。</li></ul><h4 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h4><p>​        程序清单 6-5 展示了 setjmp()和 longjmp()函数的用法。该程序通过 setjmp()的初始调用建立 了一个跳转目标，接下来的 switch（针对 setjmp()调用的返回值）用于检测是初次从 setjmp()调用返回还是在调用 longjmp()后返回。当 setjmp()调用返回值为 0 时，亦即对 setjmp()的初始调用完成后，将调用 f1()函数，f1()函数根据 argc 参数值（即命令行参数个数）来决定是立刻调用longjmp()函数还是继续去调用 f2()函数。如果是调用 f2()函数，则 f2()函数将马上调用 longjmp()函数。两处对 longjmp()的调用都会使进程恢复到调用 setjmp()的位置。程序在两处调用中为 val参数设定了不同值，以供 main()函数的 switch 语句区分发生跳转的函数，并打印相应信息。在不带任何命令行参数的情况下运行程序清单 6-5 中的程序，结果如下所示：</p><p><img src="image-20230803191702583.png" alt="image-20230803191702583"></p><p>​        指定命令行参数，会使程序跳转发生在函数 f2()中：</p><p><img src="image-20230803191707036.png" alt="image-20230803191707036"></p><p>​        程序清单 6-5：展示函数 setjmp()和 longjmp()的用法 </p><p><img src="image-20230803191713410.png" alt="image-20230803191713410"></p><p><img src="image-20230803191717945.png" alt="image-20230803191717945"></p><h4 id="对-setjmp-函数的使用限制"><a href="#对-setjmp-函数的使用限制" class="headerlink" title="对 setjmp()函数的使用限制"></a>对 setjmp()函数的使用限制</h4><p>​        SUSv3 和 C99 规定，对 setjmp()的调用只能在如下语境中使用。</p><ul><li>构成选择或迭代语句中（if、switch、while 等）的整个控制表达式。</li><li>作为一元操作符!（not）的操作对象，其最终表达式构成了选择或迭代语句的整个控制表达式。</li><li>作为比较操作（==、!=、&lt;等）的一部分，另一操作对象必须是一个整数常量表达式，且其最终表达式构成选择或迭代语句的整个控制表达式。</li><li>作为独立的函数调用，且没有嵌入到更大的表达式之中。</li></ul><p>​        注意：C 语言赋值语句不在上述列表之列。</p><p>​        以下形式的语句是不符合标准的：</p><p><img src="image-20230803191822936.png" alt="image-20230803191822936"></p><p>​        之所以规定这些限制，是因为作为常规函数的 setjmp()实现无法保证拥有足够信息来保存所有寄存器值和封闭表达式中用到的临时栈位置，以便于在 longjmp()调用后此类信息能得以正确恢复。因此，仅允许在足够简单且无需临时存储的表达式中调用 setjmp()。</p><h4 id="滥用-longjmp"><a href="#滥用-longjmp" class="headerlink" title="滥用 longjmp()"></a>滥用 longjmp()</h4><p>​        如果将 env 缓冲区定义为全局变量，对所有函数可见（这也是通常用法），那么就可以执行如下操作序列。</p><p>1． 调用函数 x()，使用 setjmp()调用在全局变量 env 中建立一个跳转目标。</p><p>2． 从函数 x()中返回。</p><p>3． 调用函数 y()，使用 env 变量调用 longjmp()函数。</p><p>​        这是一个严重错误，因为 longjmp()调用不能跳转到一个已经返回的函数中。思考一下，在这种情况下，longjmp()函数会对栈打什么主意—尝试将栈解开，恢复到一个不存在的栈帧位置，这无疑将引起混乱。如果幸运的话，程序会一死（crash）了之。然而，取决于栈的状态，也可能会引起调用与返回间的死循环，而程序好像真地从一个当前并未执行的函数中返回了。（在多线程程序中有与之相类似的滥用，在线程某甲中调用 setjmp()函数，却在线程某乙中调用 longjmp()。）SUSv3 规定，如果从嵌套的信号处理器（signal handler）（即信号某甲的处理器正在运行时，又发起对信号某乙处理器的调用）中调用 longjmp()函数，则该程序的行为未定义。</p><h4 id="优化编译器的问题"><a href="#优化编译器的问题" class="headerlink" title="优化编译器的问题"></a>优化编译器的问题</h4><p>​        优化编译器会重组程序的指令执行顺序，并在 CPU 寄存器中，而非 RAM 中存储某些变量。这种优化一般依赖于反映了程序词法结构的运行时（run-time）控制流程。由于 setjmp()和 longjmp()的跳转操作需在运行时才能得以确立和执行，并未在程序的词法结构中有所反映，故而编译器在进行优化时也无法将其考虑在内。此外，某些应用程序二进制接口（ABI）实现的语义要求 longjmp()函数恢复先前 setjmp()调用所保存的 CPU 寄存器副本。这意味着 longjmp()操作会致使经过优化的变量被赋以错误值。程序清单 6-6 中的程序行为就是其中一例。</p><p>​        程序清单 6-6：编译器的优化和 longjmp()函数相互作用的示例 </p><p><img src="image-20230803191925486.png" alt="image-20230803191925486"></p><p>​        以常规方式编译程序清单 6-6 中的程序，输出结果符合预期。</p><p><img src="image-20230803191933066.png" alt="image-20230803191933066"></p><p>​        然而，若以优化方式编译该程序，结果就有些出乎预料了。</p><p><img src="image-20230803191940112.png" alt="image-20230803191940112"></p><p>​        此处，在 longjmp()调用后，nvar 和 rvar 参数被重置为 setjmp()初次调用时的值。起因是优化器对代码的重组受到 longjmp()调用的干扰。作为候选优化对象的任一局部变量可能都难免会遇到这类问题，一般包含指针变量和 char、int、float、long 等任何简单类型的变量。</p><p>​        将变量声明为 volatile，是告诉优化器不要对其进行优化，从而避免了代码重组。在上面的程序输出中，无论编译优化与否，声明为 volatile 的变量 vvar 都得到了正确处理。因为不同的优化器有着不同的优化方法，具备良好移植性的程序应在调用 setjmp()的函数中，将上述类型的所有局部变量都声明为 volatile。若在 GNU C 语言编译器中加入–Wextra（产生额外的警告信息）选项，setjmp_vars.c 程序的编译结果将显示有帮助的警告信息如下：</p><p><img src="image-20230803191954909.png" alt="image-20230803191954909"></p><p>​        无论优化与否，查看编译 setjmp_vars.c 程序所产生的汇编语言输出都是有益的。cc –S命令产生一个以.s 为扩展名的文件，内容为程序的汇编代码。尽可能避免使用 setjmp()函数和 longjmp()函数如果说 goto 语句会使程序难以阅读，那么非局部跳转会让事情的糟糕程度增加一个数量级，因为它能在程序中任意两个函数间传递控制。因此，应当慎用 setjmp()函数和 longjmp()函数。在设计和编码时花点心思来避免使用这两个函数，这通常是值得的。程序更具可读性，可能会更具可移植性。话虽如此，但在编写信号处理器时，这些函数偶尔还会派上用场—讨论信号时将重新论及这些函数的变体（参见21.2.1节中的sigsetjmp()函数和siglongjmp()函数）。</p><h2 id="6-9-总结"><a href="#6-9-总结" class="headerlink" title="6.9 总结"></a>6.9 总结</h2><p>每个进程都有一个唯一进程标识号（process ID），并保存有对其父进程号的记录。进程的虚拟内存逻辑上被划分成许多段：文本段、（初始化和非初始化的）数据段、栈和堆。栈由一系列帧组成，随函数调用而增，随函数返回而减。每个帧都包含有函数局部变量、函数实参以及单个函数调用的调用链接信息。程序调用时，命令行参数通过 argc 和 argv 参数提供给 main()函数。通常，argv[0]包含调用程序的名称。每个进程都会获得其父进程环境列表的一个副本，即一组“名称-值”键值对。全局变量environ 和各种库函数允许进程访问和修改其环境列表中的变量。setjmp()函数和 longjmp()函数提供了从函数某甲执行非局部跳转到函数某乙（栈解开)的方法。在调用这些函数时，为避免编译器优化所引发的问题，应使用 volatile 修饰符声明变量。非局部跳转会使程序难于阅读和维护，应尽量避免使用。</p><h1 id="内-存-分-配"><a href="#内-存-分-配" class="headerlink" title="内 存 分 配"></a>内 存 分 配</h1><h2 id="7-1-在堆上分配内存"><a href="#7-1-在堆上分配内存" class="headerlink" title="7.1 在堆上分配内存"></a>7.1 在堆上分配内存</h2><p>​        进程可以通过增加堆的大小来分配内存，所谓堆是一段长度可变的连续虚拟内存，始于进程的未初始化数据段末尾，随着内存的分配和释放而增减（见图 6-1）。通常将堆的当前内存边界称为“program break”。稍后将介绍 C 语言程序分配内存所惯用的 malloc 函数族，但首先还要从 malloc 函数族所基于的 brk()和 sbrk()开始谈起。</p><h3 id="7-1-1-调整-program-break：brk-和-sbrk"><a href="#7-1-1-调整-program-break：brk-和-sbrk" class="headerlink" title="7.1.1 调整 program break：brk()和 sbrk()"></a>7.1.1 调整 program break：brk()和 sbrk()</h3><p>​        改变堆的大小（即分配或释放内存），其实就像命令内核改变进程的 program break 位置一样简单。最初，program break 正好位于未初始化数据段末尾之后（如图 6-1 所示，与&amp;end 位置相同）。在 program break 的位置抬升后，程序可以访问新分配区域内的任何内存地址，而此时物理内存页尚未分配。内核会在进程首次试图访问这些虚拟内存地址时自动分配新的物理内存页。传统的 UNIX 系统提供了两个操纵 program break 的系统调用：brk()和 sbrk()，在 Linux 中依然可用。虽然代码中很少直接使用这些系统调用，但了解它们有助于弄清内存分配的工作过程。</p><p><img src="image-20230803192137220.png" alt="image-20230803192137220"></p><p>​        系统调用 brk()会将 program break 设置为参数 end_data_segment 所指定的位置。由于虚拟内存以页为单位进行分配，end_data_segment 实际会四舍五入到下一个内存页的边界处。当试图将 program break 设置为一个低于其初始值（即低于&amp;end）的位置时，有可能会导致无法预知的行为，例如，当程序试图访问的数据位于初始化或未初始化数据段中当前尚不存在的部分时，就会引发分段内存访问错误（segmentation fault）（SIGSEGV 信号，在 20.2 节描述）。program break 可以设定的精确上限取决于一系列因素，这包括进程中对数据段大小的资源限制（36.3 节中描述的 RLIMIT_DATA），以及内存映射、共享内存段、共享库的位置。调用 sbrk()将 program break 在原有地址上增加从参数 increment 传入的大小。（在 Linux 中，sbrk()是在 brk()基础上实现的一个库函数。）用于声明 increment 的 intptr_t 类型属于整数数据类型。若调用成功，sbrk()返回前一个 program break 的地址。换言之，如果 program break 增加，那么返回值是指向这块新分配内存起始位置的指针。调用 sbrk(0)将返回 program break 的当前位置，对其不做改变。在意图跟踪堆的大小，或是监视内存分配函数包的行为时，可能会用到这一用法。SUSv2 定义了 brk()和 sbrk()，标记为 Legacy（传统）。但 SUSv3 删除了这些定义。</p><h3 id="7-1-2-在堆上分配内存：malloc-和-free"><a href="#7-1-2-在堆上分配内存：malloc-和-free" class="headerlink" title="7.1.2 在堆上分配内存：malloc()和 free()"></a>7.1.2 在堆上分配内存：malloc()和 free()</h3><p>​        一般情况下，C 程序使用 malloc 函数族在堆上分配和释放内存。较之 brk()和 sbrk()，这些函数具备不少优点，如下所示。</p><ul><li>属于 C 语言标准的一部分。</li><li>更易于在多线程程序中使用。</li><li>接口简单，允许分配小块内存。</li><li>允许随意释放内存块，它们被维护于一张空闲内存列表中，在后续内存分配调用时循环使用。</li></ul><p>​        malloc( )函数在堆上分配参数 size 字节大小的内存，并返回指向新分配内存起始位置处的指针，其所分配的内存未经初始化。</p><p><img src="image-20230803192414611.png" alt="image-20230803192414611"></p><p>​        由于 malloc()的返回类型为 void*，因而可以将其赋给任意类型的 C 指针。malloc()返回内存块所采用的字节对齐方式，总是适宜于高效访问任何类型的 C 语言数据结构。在大多数硬件架构上，这实际意味着 malloc 是基于 8 字节或 16 字节边界来分配内存的。1SUSv3 规定：调用 malloc(0)要么返回 NULL，要么是一小块可以（并且应该）用 free()释放的内存。Linux 的 malloc(0)行为遵循后者。若无法分配内存（或许是因为已经抵达 program break 所能达到的地址上限），则 malloc()返回 NULL，并设置 errno 以返回错误信息。虽然分配内存失败的可能性很小，但所有对 malloc()以及后续提及的相关函数的调用都应对返回值进行错误检查。free()函数释放 ptr 参数所指向的内存块，该参数应该是之前由 malloc()，或者本章后续描述的其他堆内存分配函数之一所返回的地址。一般情况下，free()并不降低 program break 的位置，而是将这块内存填加到空闲内存列表中，供后续的 malloc()函数循环使用。这么做是出于以下几个原因。</p><ul><li>被释放的内存块通常会位于堆的中间，而非堆的顶部，因而降低 porgram break 是不可能的。</li><li>它最大限度地减少了程序必须执行的 sbrk()调用次数。（正如 3.1 节指出的，系统调用的开销虽小，却也颇为可观。）</li><li>在大多数情况下，降低 program break 的位置不会对那些分配大量内存的程序有多少帮助，因为它们通常倾向于持有已分配内存或是反复释放和重新分配内存，而非释放所有内存后再持续运行一段时间。</li></ul><p>​        如果传给 free()的是一个空指针，那么函数将什么都不做。（换句话说，给 free()传入一个空指针并不是错误代码。）在调用 free()后对参数 ptr 的任何使用，例如将其再次传递给 free()，将产生错误，并可能导致不可预知的结果。</p><h4 id="程序示例-2"><a href="#程序示例-2" class="headerlink" title="程序示例"></a>程序示例</h4><p>​        程序清单 7-1 中的程序说明了 free()函数对 program break 的影响。该程序在分配了多块内存后，根据（可选）命令行参数来释放其中的部分或全部。前两个命令行参数指定了分配内存块的数量和大小。第三个命令行参数指定了释放内存块的循环步长。如果是 1（这也是省略此参数时的默认值），那么程序将释放每块已分配的内存，如果为 2，那么每隔一块释放一块已分配内存，以此类推。第四个和第五个命令行参数指定需要释放的内存块范围。如果省略这两个参数，那么将（以第三个命令行参数所指定的步长）释放全部范围内的已分配内存。程序清单 7-1：示范释放内存时 program break 的行为 </p><p><img src="image-20230803192556711.png" alt="image-20230803192556711"></p><p><img src="image-20230803192605244.png" alt="image-20230803192605244"></p><p>​        用下面的命令行运行程序清单 7-1 的程序，将会分配 1000 个内存块，且每隔一个内存块释放一个内存块。</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;free_and_sbrk 1000 10240 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        输出结果显示，释放所有内存块后，program break 的位置仍然与分配所有内存块后的水平相当。</p><p><img src="image-20230803192839512.png" alt="image-20230803192839512"></p><p>​        下面的命令行要求除了最后一块内存块，释放所有已分配的内存块。再一次，program break保持在了“高水位线”。</p><p><img src="image-20230803192844280.png" alt="image-20230803192844280"></p><p>​        但是，如果在堆顶部释放完整的一组连续内存块，会观察到 program break 从峰值上降下来，这表明 free()使用了 sbrk()来降低 program break。在这里，命令行释放了已分配内存的最后 500 个内存块。</p><p><img src="image-20230803192901094.png" alt="image-20230803192901094"></p><p>​        在这种情况下，free()函数的 glibc 实现会在释放内存时将相邻的空闲内存块合并为一整块更大的内存（这样做是为了避免在空闲内存列表中包含大量的小块内存碎片，这些碎片会因空间太小而难以满足后续的 malloc()请求），因而也有能力识别出堆顶部的整个空闲区域。仅当堆顶空闲内存“足够”大的时候，free()函数的 glibc 实现会调用 sbrk()来降低 program break 的地址，至于“足够”与否则取决于 malloc 函数包行为的控制参数（128 KB 为典型值）。这减少了必须对 sbrk()发起的调用次数（亦即对 brk()系统调用的调用次数）。</p><h4 id="调用-free-还是不调用-free"><a href="#调用-free-还是不调用-free" class="headerlink" title="调用 free()还是不调用 free()"></a>调用 free()还是不调用 free()</h4><p>​         当进程终止时，其占用的所有内存都会返还给操作系统，这包括在堆内存中由 malloc 函数包内一系列函数所分配的内存。基于内存的这一自动释放机制，对于那些分配了内存并在进程终止前持续使用的程序而言，通常会省略对 free()的调用。这在程序中分配了多块内存的情况下可能会特别有用，因为加入多次对 free()的调用不但会消耗大量的 CPU 时间，而且可能会使代码趋于复杂。虽然依靠终止进程来自动释放内存对大多数程序来说是可以接受的，但基于以下几个原因，最好能够在程序中显式释放所有的已分配内存。y 显式调用 free()能使程序在未来修改时更具可读性和可维护性。y 如果使用 malloc 调试库（如下所述）来查找程序的内存泄漏问题，那么会将任何未经显式释放处理的内存报告为内存泄漏。这会使发现真正内存泄漏的工作复杂化。</p><h3 id="7-1-3-malloc-和-free-的实现"><a href="#7-1-3-malloc-和-free-的实现" class="headerlink" title="7.1.3 malloc()和 free()的实现"></a>7.1.3 malloc()和 free()的实现</h3><p>​        尽管 malloc()和 free()所提供的内存分配接口比之 brk()和 sbrk()要容易许多，但在使用时仍然容易犯下各种编程错误。理解 malloc()和 free()的实现，将使我们洞悉产生这些错误的原因以及如何才能避免此类错误。malloc()的实现很简单。它首先会扫描之前由 free()所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存。（取决于具体实现，采用的扫描策略会有所不同。例如，first-fit 或 best-fito。）如果这一内存块的尺寸正好与要求相当，就把它直接返回给调用者。如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中。如果在空闲内存列表中根本找不到足够大的空闲内存块，那么 malloc()会调用 sbrk()以分配更多的内存。为减少对 sbrk()的调用次数，malloc()并未只是严格按所需字节数来分配内存，而是以更大幅度（以虚拟内存页大小的数倍）来增加 program break，并将超出部分置于空闲内存列表。至于 free()函数的实现则更为有趣。当 free()将内存块置于空闲列表之上时，是如何知晓内存块大小的？这是通过一个小技巧来实现的。当 malloc()分配内存块时，会额外分配几个字节来存放记录这块内存大小的整数值。该整数位于内存块的起始处，而实际返回给调用者的内存地址恰好位于这一长度记录字节之后，如图 7-1 所示。</p><p><img src="image-20230803193009241.png" alt="image-20230803193009241"></p><p>​        当将内存块置于空闲内存列表（双向链表）时，free()会使用内存块本身的空间来存放链表指针，将自身添加到列表中，如图 7-2 所示。</p><p><img src="image-20230803193020145.png" alt="image-20230803193020145"></p><p>​        随着对内存不断地释放和重新分配，空闲列表中的空闲内存会和已分配的在用内存混杂在一起，如图 7-3 所示。图 7-3：包含有已分配内存和空闲内存列表的堆应该认识到，C 语言允许程序创建指向堆中任意位置的指针，并修改其指向的数据，包括由 free()和 malloc()函数维护的内存块长度、指向前一空闲块和后一空闲块的指针。辅之以之前的描述，一旦推究起隐晦难解的编程缺陷来，这无疑形同掉进了火药桶。例如，假设经由一个错误指针，程序无意间增加了冠于一块已分配内存的长度值，并随即释放这块内存，free()因之会在空闲列表中记录下这块长度失真的内存。随后，malloc()也许会重新分配这块内存，从而导致如下场景：程序的两个指针分别指向两块它认为互不相干的已分配内存，但实际上这两块内存却相互重叠。至于其他的出错情况则数不胜数。要避免这类错误，应该遵守以下规则。</p><ul><li>分配一块内存后，应当小心谨慎，不要改变这块内存范围外的任何内容。错误的指针运算，或者循环更新内存块内容时出现的“off-by-one”（一字之偏）错误，都有可能导致这一情况。</li><li>释放同一块已分配内存超过一次是错误的。Linux 上的 glibc 库经常报出分段错误（SIGSEGV 信号）。这是好事，因为它提醒我们犯下了一个编程错误。然而，当两次释放同一块内存时，更常见的后果是导致不可预知的行为。</li><li>若非经由 malloc 函数包中函数所返回的指针，绝不能在调用 free()函数时使用。</li><li>在编写需要长时间运行的程序（例如，shell 或网络守护进程）时，出于各种目的，如果需要反复分配内存，那么应当确保释放所有已使用完毕的内存。如若不然，堆将稳步增长，直至抵达可用虚拟内存的上限，在此之后分配内存的任何尝试都将以失败告终。这种情况被称之为“内存泄漏”。</li></ul><h4 id="malloc-调试的工具和库"><a href="#malloc-调试的工具和库" class="headerlink" title="malloc 调试的工具和库"></a>malloc 调试的工具和库</h4><p>​        如果不遵循上述准则，可能会在代码中引入既难以理解又难以重现的缺陷。而使用 glibc提供的 malloc 调试工具或者任何一款 malloc 调试库，都会显著降低发现这些缺陷的难度，这也是设计它们的目的所在。以下是 glibc 提供的 malloc 调试工具的部分功能。</p><ul><li>mtrace()和 muntrace()函数分别在程序中打开和关闭对内存分配调用进行跟踪的功能。这些函数要与环境变量 MALLOC_TRACE 搭配使用，该变量定义了写入跟踪信息的文件名。在被调用时，mtrace()会检查是否定义了该文件，又是否可以打开文件并写入。如果一切正常，那么会在文件里跟踪和记录所有对 malloc 函数包中函数的调用。由于生成文件不易于理解，还提供有一个脚本（mtrace）用于分析文件，并生成易于理解的汇总报告。出于安全原因，设置用户 ID 和设置组 ID 的程序会忽略对 mtrace()的调用。</li><li>mcheck()和 mprobe()函数允许程序对已分配内存块进行一致性检查。例如，当程序试图在已分配内存之外进行写操作时，它们将捕获这个错误。这些函数提供的功能和下述 malloc 调试库有重叠之处。使用这些函数的程序，必须使用 cc-lmcheck 选项与mcheck 库链接。</li><li>MALLOC_CHECK_环境变量（注意结尾处的下划线）提供了类似于 mcheck()和mprobe()函数的功能。（两者之间的一个显著区别在于使用：MALLOC_CHECK_无需对程序进行修改和重新编译。）通过为此变量设置不同的整数值，可以控制程序对内存分配错误的响应方式。可能的设置有：0，意即忽略错误；1，意即在标准错误输出（stderr）中打印诊断错误；2，意即调用 abort()来终止程序。并非所有的内存分配和释放错误都是由 MALLOC_CHECK_检测出的，它所发现的只是常见错误。但是，这种技术快速、易用，较之于 malloc 调试库具有较低的运行时开销。出于安全原因，设置用户 ID 和设置组 ID 的程序将忽略 MALLOC_CHECK_设置。</li></ul><p>​        关于以上所有功能更为详细的信息可以参考 glibc 手册。</p><p>​        而就 malloc 调试库而言，其提供了和标准 malloc 函数包相同的 API，但附加了捕获内存分配错误的功能。要使用调试库，需要在编译时链接调试库，而非标准 C 函数库的 malloc 函数包。由于调试库通常会降低运行速度，增加内存消耗，或是两者兼而有之，应当仅在调试时使用，而在正式发布产品时链接标准库的 malloc 包。这些库分别是：Electric Fence（<a href="http://www">http://www</a>. perens.com/FreeSoftware/）、dmalloc（<a href="http://dmalloc.com/）、Valgrind（http://valgrind">http://dmalloc.com/）、Valgrind（http://valgrind</a>. org/）、Insure++（<a href="http://www.parasoft.com/）。Valgrind">http://www.parasoft.com/）。Valgrind</a> 和 Insure++能够发现许多堆内存分配之外的其他类型错误。可以访问其各自网站，以获取详细信息。</p><h4 id="控制和监测-malloc-函数包"><a href="#控制和监测-malloc-函数包" class="headerlink" title="控制和监测 malloc 函数包"></a>控制和监测 malloc 函数包</h4><p>​        glibc 手册介绍了一系列非标准函数，可用于监测和控制 malloc 包中函数的内存分配，其中包括如下几个函数。</p><ul><li>函数 mallopt()能修改各项参数，以控制 malloc()所采用的算法。例如，此类参数之一就指定了在调用 sbrk()函数进行堆收缩之前，在空闲列表尾部必须保有的可释放内存空间的最小值。另一参数则规定了从堆中分配的内存块大小的上限，超出上限的内存块则使用 mmap()系统调用（参见 49.7 节）来分配。</li><li>mallinfo()函数返回一个结构，其中包含由 malloc()分配内存的各种统计数据。众多 UNIX 实现提供各种版本的 mallopt()和 mallinfo()。然而，这些函数所提供的接口却随实现而不同，因而也无法移植。</li></ul><h3 id="7-1-4-在堆上分配内存的其他方法"><a href="#7-1-4-在堆上分配内存的其他方法" class="headerlink" title="7.1.4 在堆上分配内存的其他方法"></a>7.1.4 在堆上分配内存的其他方法</h3><p>​        除了 malloc()，C 函数库还提供了一系列在堆上分配内存的其他函数，在这里将逐一介绍。</p><p>​        用 calloc()和 realloc()分配内存</p><p>​        函数 calloc()用于给一组相同对象分配内存。</p><p><img src="image-20230803193514158.png" alt="image-20230803193514158"></p><p>​        参数 mumitems 指定分配对象的数量，size 指定每个对象的大小。在分配了适当大小的内存块后，calloc()返回指向这块内存起始处的指针（如果无法分配内存，则返回 NULL）。与 malloc()不同，calloc()会将已分配的内存初始化为 0。下面是 calloc()的一个使用范例：</p><p><img src="image-20230803193548281.png" alt="image-20230803193548281"></p><p>​        realloc()函数用来调整（通常是增加）一块内存的大小，而此块内存应是之前由 malloc 包中函数所分配的。参数 ptr 是指向需要调整大小的内存块的指针。参数 size 指定所需调整大小的期望值。如果成功，realloc()返回指向大小调整后内存块的指针。与调用前的指针相比，二者指向的位置可能不同。如果发生错误，realloc()返回 NULL，对 ptr 指针指向的内存块则原封不动（SUSv3 要求满足这一约定）。若 realloc()增加了已分配内存块的大小，则不会对额外分配的字节进行初始化。</p><p><img src="image-20230803193612107.png" alt="image-20230803193612107"></p><p>​        使用 calloc()或 realloc()分配的内存应使用 free()来释放。调用 realloc(ptr,0)等效于在 free(ptr)之后调用 malloc(0)。若 ptr 为 NULL，则 realloc(NULL, size)相当于调用 malloc(size)。通常情况下，当增大已分配内存时，realloc()会试图去合并在空闲列表中紧随其后1且大小满足要求的内存块。若原内存块位于堆的顶部，那么 realloc()将对堆空间进行扩展。如果这块内存位于堆的中部，且紧邻其后的空闲内存空间大小不足，realloc()会分配一块新内存，并将原有数据复制到新内存块中。最后这种情况最为常见，还会占用大量 CPU资源。一般情况下，应尽量避免调用 realloc()。既然 realloc()可能会移动内存，对这块内存的后续引用就必须使用 realloc()的返回指针。可以用 realloc()来重新定位由变量 ptr 指向的内存块，代码如下：</p><p><img src="image-20230803193732775.png" alt="image-20230803193732775"></p><p>​        本例并没有把 realloc()的返回值直接赋给 ptr，因为一旦调用 realloc()失败，那么 ptr 会被置为 NULL，从而无法访问现有内存块。由于 realloc()可能会移动内存块，任何指向该内存块内部的指针在调用 realloc()之后都可能不再可用。仅有一种内存块内的位置引用方法依然有效，即以指向此块内存起始处的指针再加上一个偏移量来进行定位，这将在 48.6 节中详细讨论。</p><h4 id="分配对齐的内存：memalign-和-posix-memalign"><a href="#分配对齐的内存：memalign-和-posix-memalign" class="headerlink" title="分配对齐的内存：memalign()和 posix_memalign()"></a>分配对齐的内存：memalign()和 posix_memalign()</h4><p>​         设计函数 memalign()和 posix_memalign()的目的在于分配内存时，<strong>起始地址要与 2 的整数次幂边界对齐</strong>，该特征对于某些应用非常有用（例如程序清单 13-1）。\</p><p><img src="image-20230803193801722.png" alt="image-20230803193801722"></p><p>​        函数 memalign()分配 size 个字节的内存，起始地址是参数 boundary 的整数倍，而 boundary必须是 2 的整数次幂。函数返回已分配内存的地址。函数 memalign()并非在所有 UNIX 实现上都存在。大多数提供 memalign()的其他 UNIX 实现都要求引用<stdlib.h>而非<malloc.h>以获得函数声明。SUSv3 并未纳入 memalign()，而是规范了一个类似函数，名为 posix_memalign()。该函数由标准委员会于近期创制，只是出现在了少数 UNIX 实现上。</p><p><img src="image-20230803193831250.png" alt="image-20230803193831250"></p><p>​        函数 posix_memalign()与 memalign()存在以下两方面的不同。</p><ul><li>已分配的内存地址通过参数 memptr 返回。</li><li>内存与 alignment 参数的整数倍对齐1，alignment 必须是 sizeof（void*）（在大多数硬件架构上是 4 或 8 个字节）与 2 的整数次幂两者间的乘积。</li></ul><p>​        还要注意该函数与众不同的返回值，出错时不是返回−1，而是直接返回一个错误号（即通常在 errno 中返回的正整数）。</p><p>​        如果 SizeOf(void *)为 4，就可以使用 posix_memalign()分配 65536 字节的内存，并与 4096字节的边界对齐，代码如下：</p><p><img src="image-20230803193932442.png" alt="image-20230803193932442"></p><p>​        由 memalign()或 posix_memalign()分配的内存块应该调用 free()来释放。在一些 UNIX 实现中，无法通过调用 free()来释放由 memalign()分配的内存，因为此类memalign()在实现时使用 malloc()来分配内存块，然后返回一个指针，指向该块内已对齐的适当地址。glibc 的 memalign()则不受此限制。</p><h2 id="7-2-在堆栈上分配内存：alloca"><a href="#7-2-在堆栈上分配内存：alloca" class="headerlink" title="7.2 在堆栈上分配内存：alloca()"></a>7.2 在堆栈上分配内存：alloca()</h2><p>​        和 malloc 函数包中的函数功能一样，<strong>alloca()也可以动态分配内存，不过不是从堆上分配内存，</strong>而是通过增加栈帧的大小从堆栈上分配。根据定义，当前调用函数的栈帧位于堆栈的顶部，故而这种方法是可行的。因此，帧的上方存在扩展空间，只需修改堆栈指针值即可。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;alloca.h&gt;void* alloca(size_t size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230803194003679.png" alt="image-20230803194003679"></p><p>​        参数 size 指定在堆栈上分配的字节数。函数 alloca()将指向已分配内存块的指针作为其返回值。不需要（实际上也绝不能）调用 free()来释放由 alloca()分配的内存。同样，也不可能调用realloc()来调整由 alloca()分配的内存大小。虽然 alloca()不是 SUSv3 的一部分，但大多数 UNIX 实现都提供了此函数，因而也具备可移植性。旧版本的 glibc 和其他一些 UNIX 实现（主要是 BSD 的衍生版本），要获取 alloca()声明需引入<stdlib.h>而非<alloca.h>。若调用alloca()造成堆栈溢出，则程序的行为无法预知，特别是在没有收到一个NULL 返回值通知错误的情况下。（事实上，在此情况下，可能会收到一个SIGSEGV 信号。详情参见21.3 节。）请注意，不能在一个函数的参数列表中调用 alloca()，如下所示： </p><pre class="line-numbers language-none"><code class="language-none">func(x, alloca(size), z);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这会使 alloca()分配的堆栈空间出现在当前函数参数的空间内（函数参数都位于栈帧内的固定位置）。相反，必须采用这样的代码：</p><pre class="line-numbers language-none"><code class="language-none">void* y &#x3D; alloca(size);func(x, y, z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        使用 alloca()来分配内存相对于 malloc()有一定优势。其中之一是，alloca()分配内存的速度要快于 malloc()，因为编译器将 alloca()作为内联代码处理，并通过直接调整堆栈指针来实现。此外，alloca()也不需要维护空闲内存块列表。另一个优点在于，由 alloca()分配的内存随栈帧的移除而自动释放，亦即当调用 alloca 的函数返回之时。之所以如此，是因为函数返回时所执行的代码会重置栈指针寄存器，使其指向前一帧的末尾（即，假设堆栈向下增长，则指向恰好位于当前栈帧起始处之上的地址）。由于在函数的所有返回路径中都无需确保去释放所有的已分配内存，一些函数的编码也变得简单得多。在信号处理程序中调用 longjmp()（6.8 节）或 siglongjmp()（21.2.1 节）以执行非局部跳转时，alloca()的作用尤其突出。此时，在“起跳”函数和“落地”函数之间的函数中，如果使用了 malloc()来分配内存，要想避免内存泄漏就极其困难，甚至是不可能的。与之相反，alloca()完全可以避免这一问题，因为堆栈是由这些调用展开的，所以已分配的内存会被自动释放</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux漫游 更深层次的文件IO</title>
      <link href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8-%E6%9B%B4%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%9A%84%E6%96%87%E4%BB%B6IO/"/>
      <url>/2023/08/30/Linux%E6%BC%AB%E6%B8%B8-%E6%9B%B4%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%9A%84%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<h1 id="深入探究文件IO"><a href="#深入探究文件IO" class="headerlink" title="深入探究文件IO"></a>深入探究文件IO</h1><h2 id="原子操作和竞争条件"><a href="#原子操作和竞争条件" class="headerlink" title="原子操作和竞争条件"></a>原子操作和竞争条件</h2><p>​        我们下面要要谈到的是高级一些的文件IO，这里，我们就需要考虑到原子操作和竞争条件.也就是说,我们现在来考虑一下多进程下的文件IO函数行为</p><h3 id="举个例子-以独占方式创建一个文件"><a href="#举个例子-以独占方式创建一个文件" class="headerlink" title="举个例子:以独占方式创建一个文件"></a>举个例子:以独占方式创建一个文件</h3><p>​        当同时指定 O_EXCL 与 O_CREAT 作为 open()的标志位时，如果要打开的文件已然存在，则 open()将返回一个错误。这提供了一种机制，保证进程是打开文件的创建者。</p><p>​        下面的这个程序是有问题的:</p><p><img src="image-20230803174458278.png" alt="image-20230803174458278"></p><p>​        在多进程条件下,我们如果不加原子操作,非文件开创的进程会认为是自己开创的进程.</p><p><img src="image-20230803174619051.png" alt="image-20230803174619051"></p><p>​        从而埋下隐患.结合 O_CREAT 和 O_EXCL 标志来一次性地调用 open()可以防止这种情况，因为这确保了检查文件和创建文件的步骤属于一个单一的原子（即不可中断的）操作。</p><h3 id="再举个例子-向文件尾部追加数据"><a href="#再举个例子-向文件尾部追加数据" class="headerlink" title="再举个例子:向文件尾部追加数据"></a>再举个例子:向文件尾部追加数据</h3><p>​        还有一个例子,就是多个进程同时向某一个文件追加数据</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if(lseek(fd, 0, SEEK_END) &#x3D;&#x3D; -1)&#123;    errExit(-1);&#125;if(write(fd,buf,len) !&#x3D; len)&#123;    fatal(&quot;Partially write or failed write!&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是，这段代码存在的缺陷与前一个例子如出一辙。<strong>如果第一个进程执行到 lseek()和 write()之间，被执行相同代码的第二个进程所中断，那么这两个进程会在写入数据前，将文件偏移量设为相同位置，而当第一个进程再次获得调度时，会覆盖第二个进程已写入的数据。此时再次出现了竞争状态，因为执行的结果依赖于内核对两个进程的调度顺序。</strong></p><p>​        需要将文件偏移量的移动与数据写操作纳入同一原子操作。在打开文件时加入 O_APPEND 标志就可以保证这一点。有些文件系统（例如 NFS）不支持 O_APPEND 标志。</p><h2 id="文件控制操作：fcntl"><a href="#文件控制操作：fcntl" class="headerlink" title="文件控制操作：fcntl()"></a>文件控制操作：fcntl()</h2><p>​    fcntl()系统调用对一个打开的文件描述符执行一系列控制操作。</p><p><img src="image-20230803174720241.png" alt="image-20230803174720241"></p><p>​        cmd 参数所支持的操作范围很广。本章随后各节会对其中的部分操作加以研讨，剩下的操作将在后续各章中进行论述。</p><p>​        fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。</p><h2 id="打开文件的状态标志"><a href="#打开文件的状态标志" class="headerlink" title="打开文件的状态标志"></a>打开文件的状态标志</h2><p>​        这个函数有一个用途:<strong>针对打开的文件,获取或修改其访问模式和状态标志（这些值是通过指定 open()调用的 flag 参数来设置的）。要获取这些设置，应将 fcntl()的 cmd 参数设置为F_GETFL。</strong></p><p><img src="image-20230803174744205.png" alt="image-20230803174744205"></p><p>​        在上述代码之后，可以以如下代码测试文件是否以同步写方式打开：</p><p><img src="image-20230803174814491.png" alt="image-20230803174814491"></p><p>​        当然,判断访问模式就有些复杂了</p><p>​        这是因为 O_RDONLY(0)、O_WRONLY(1)和 O_RDWR(2)这 3 个常量并不与打开文件状态标志中的单个比特位对应。因此，要判定访问模式，需使用掩码 O_ACCMODE 与 flag 相与，将结果与 3 个常量进行比对，示例代码如下：</p><p><img src="image-20230803174834715.png" alt="image-20230803174834715"></p><p>​        可以使用 fcntl()的 F_SETFL 命令来修改打开文件的某些状态标志。允许更改的标志有O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和 O_DIRECT。系统将忽略对其他标志的修改操作。（有些其他的 UNIX 实现允许 fcntl()修改其他标志，如 O_SYNC。）使用 fcntl()修改文件状态标志，尤其适用于如下场景。</p><ul><li>文件不是由调用程序打开的，所以程序也无法使用 open()调用来控制文件的状态标志（例如，文件是 3 个标准输入输出描述符中的一员，这些描述符在程序启动之前就被打开）。</li><li>文件描述符的获取是通过 open()之外的系统调用。比如 pipe()调用，该调用创建一个管道，并返回两个文件描述符分别对应管道的两端。再比如 socket()调用，该调用创建一个套接字并返回指向该套接字的文件描述符。</li></ul><p>​        为了修改打开文件的状态标志，可以使用 fcntl()的 F_GETFL 命令来获取当前标志的副本，然后修改需要变更的比特位，最后再次调用 fcntl()函数的 F_SETFL 命令来更新此状态标志。因此，为了添加 O_APPEND 标志，可以编写如下代码：</p><p><img src="image-20230803174904937.png" alt="image-20230803174904937"></p><h2 id="文件描述符和打开文件之间的关系"><a href="#文件描述符和打开文件之间的关系" class="headerlink" title="文件描述符和打开文件之间的关系"></a>文件描述符和打开文件之间的关系</h2><p>​        多个文件描述符当然可以指向同一个文件</p><p>这些文件描述符可在相同或不同的进程中打开。要理解具体情况如何，需要查看由内核维护的 3 个数据结构。</p><ul><li>进程级的文件描述符表。</li><li>系统级的打开文件表。</li><li>文件系统的 i-node 表。</li></ul><p>​        针对每个进程，<strong>内核为其维护打开文件的描述符（open file descriptor）表</strong>。该表的每一条目都记录了单个文件描述符的相关信息，如下所示。</p><ul><li><strong>控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即 close-on-exec 标志，将在 27.4 节予以介绍。）</strong></li><li><strong>对打开文件句柄的引用。</strong></li></ul><p>​        内核对所有打开的文件维护有一个系统级的描述表格（open file description table）。<strong>有时，也称之为打开文件表（open file table），并将表中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示。</strong></p><ul><li>当前文件偏移量（调用 read()和 write()时更新，或使用 lseek()直接修改）。</li><li>打开文件时所使用的状态标志（即，open()的 flags 参数）。</li><li>文件访问模式（如调用 open()时所设置的只读模式、只写模式或读写模式）。</li><li>与信号驱动 I/O 相关的设置（见 63.3 节）。</li><li>对该文件 i-node 对象的引用。</li></ul><p>​        每个文件系统都会为驻留其上的所有文件建立一个 i-node 表。第 14 章将详细讨论 i-node 结构和文件系统的总体结构。这里只是列出每个文件的 i-node 信息，具体如下。</p><ul><li>文件类型（例如，常规文件、套接字或 FIFO）和访问权限。</li><li>一个指针，指向该文件所持有的锁的列表。</li><li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳。</li></ul><p>​        打开的文件句柄以及 i-node 之间的关系。在下图中，两个进程拥有诸多打开的文件描述符。在进程 A 中，文件描述符 1 和 20 都指向同一个打开的文件句柄（标号为 23）。这可能是通过调用 dup()、dup2()或 fcntl()而形成的（参见 5.5 节）。进程A的文件描述符2和进程B的文件描述符2都指向同一个打开的文件句柄（标号为73）。这种情形可能在调用 fork()后出现（即，进程 A 与进程 B 之间是父子关系），或者当某进程通过UNIX 域套接字将一个打开的文件描述符传递给另一进程时，也会发生（参见 61.13.3 节）。此外，进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件句柄，但这些句柄均指向 i-node 表中的相同条目（1976），换言之，指向同一文件。发生这种情况是因为每个进程各自对同一文件发起了 open()调用。同一个进程两次打开同一文件，也会发生类似情况。上述讨论揭示出如下要点。</p><ul><li>两个不同的文件描述符，若指向同一打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用 read()、write()或 lseek()所致），那么从另一文件描述符中也会观察到这一变化。无论这两个文件描述符分属于不同进程，还是同属于一个进程，情况都是如此。</li><li>要获取和修改打开的文件标志（例如，O_APPEND、O_NONBLOCK 和 O_ASYNC），可执行 fcntl()的 F_GETFL 和 F_SETFL 操作，其对作用域的约束与上一条颇为类似。</li><li>相形之下，文件描述符标志（亦即，close-on-exec 标志）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符。</li></ul><p><img src="image-20230803175434477.png" alt="image-20230803175434477"></p><h2 id="复制文件描述符"><a href="#复制文件描述符" class="headerlink" title="复制文件描述符"></a>复制文件描述符</h2><p>​        Bourne shell 的 I/O 重定向语法 2&gt;&amp;1，意在通知 shell 把标准错误（文件描述符 2）重定向到标准输出（文件描述符 1）。因此，下列命令将把（因为 shell 按从左至右的顺序处理 I/O 重定向语句）标准输出和标准错误写入 result.log 文件：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;myscript 2&gt;&amp;1 | less<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        shell 通过复制文件描述符 21实现了标准错误的重定向操作，因此文件描述符 2 与文件描述符 1 指向同一个打开文件句柄（类似于图 5-2 中进程 A 的描述符 1 和 20 指向同一打开文件句柄的情况）。可以通过调用 dup()和 dup2()来实现此功能。</p><p>​        请注意，要满足 shell 的这一要求，仅仅简单地打开 results.log 文件两次是远远不够的（第一次在描述符 1 上打开，第二次在描述符 2 上打开）。首先两个文件描述符不能共享相同的文件偏移量指针，因此有可能导致相互覆盖彼此的输出。再者打开的文件不一定就是磁盘文件。在如下命令中，标准错误就将和标准输出一起送达同一管道：</p><p><img src="image-20230803175629749.png" alt="image-20230803175629749"></p><p>​        <strong>dup()调用复制一个打开的文件描述符 oldfd，并返回一个新描述符，二者都指向同一打开的文件句柄。系统会保证新描述符一定是编号值最低的未用文件描述符。</strong></p><p><img src="image-20230803175616029.png" alt="image-20230803175616029"></p><p>​        假设发起如下调用：</p><pre class="line-numbers language-none"><code class="language-none">newfd &#x3D; dup(1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        再假定在正常情况下，shell 已经代表程序打开了文件描述符 0、1 和 2，且没有其他描述符在用，dup()调用会创建文件描述符 1 的副本，返回的文件描述符编号值为 3。如果希望返回文件描述符 2，可以使用如下技术：</p><p><img src="image-20230803175648334.png" alt="image-20230803175648334"></p><p>​        <strong>只有当描述符 0 已经打开时，这段代码方可工作。如果想进一步简化上述代码，同时总是能获得所期望的文件描述符，可以调用 dup2()。</strong></p><p><img src="image-20230803175701621.png" alt="image-20230803175701621"></p><p>​        dup2()系统调用会为 oldfd 参数所指定的文件描述符创建副本，其编号由 newfd 参数指定。<strong>如果由 newfd 参数所指定编号的文件描述符之前已经打开，那么 dup2()会首先将其关闭。（dup2()调用会默然忽略 newfd 关闭期间出现的任何错误。</strong>故此，编码时更为安全的做法是：<strong>在调用dup2()之前，若 newfd 已经打开，则应显式调用 close()将其关闭。</strong>）</p><p>​        前述调用 close()和 dup()的代码可以简化为：</p><pre class="line-numbers language-none"><code class="language-none">dup2(1,2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        若调用 dup2()成功，则将返回副本的文件描述符编号（即 newfd 参数指定的值）。如果 oldfd 并非有效的文件描述符，那么 dup2()调用将失败并返回错误 EBADF，且不关闭 newfd。如果 oldfd 有效，且与 newfd 值相等，那么 dup2()将什么也不做，不关闭 newfd，并将其作为调用结果返回。</p><p>​        fcntl()的 F_DUPFD 操作是复制文件描述符的另一接口，更具灵活性。</p><p>​        该调用为 oldfd 创建一个副本，且将使用大于等于 startfd 的最小未用值作为描述符编号。该调用还能保证新描述符（newfd）编号落在特定的区间范围内。总是能将 dup()和 dup2()调用改写为对 close()和 fcntl()的调用，虽然前者更为简洁。（还需注意，正如手册页中所描述的，dup2()和 fcntl()二者返回的 errno 错误码存在一些差别。）</p><p>​        由图 5-2 可知，文件描述符的正、副本之间共享同一打开文件句柄所含的文件偏移量和状态标志。然而，新文件描述符有其自己的一套文件描述符标志，且其 close-on-exec 标志（FD_CLOEXEC）总是处于关闭状态。下面将要介绍的接口，可以直接控制新文件描述符的close-on-exec 标志。</p><p>​        <strong>dup3()系统调用完成的工作与 dup2()相同，只是新增了一个附加参数 flag，这是一个可以修改系统调用行为的位掩码。</strong></p><p><img src="image-20230803181405591.png" alt="image-20230803181405591"></p><p>​        目前，dup3()只支持一个标志 O_CLOEXEC，这将促使内核为新文件描述符设置 close-on-exec标志（FD_CLOEXEC）。设计该标志的缘由，类似于 4.3.1 节对 open()调用中 O_CLOEXEC 标志的描述。dup3()系统调用始见于 Linux 2.6.27，为 Linux 所特有。Linux 从 2.6.24 开始支持 fcntl()用于复制文件描述符的附加命令：F_DUPFD_CLOEXEC。该标志不仅实现了与 F_DUPFD 相同的功能，还为新文件描述符设置 close-on-exec 标志。同样，此命令之所以得以一显身手，其原因也类似于 open()调用中的 O_CLOEXEC 标志。SUSv3 并未论及 F_DUPFD_CLOEXEC 标志，但 SUSv4 对其作了规范。</p><h2 id="在文件特定偏移量处的-I-O：pread-和-pwrite"><a href="#在文件特定偏移量处的-I-O：pread-和-pwrite" class="headerlink" title="在文件特定偏移量处的 I/O：pread()和 pwrite()"></a>在文件特定偏移量处的 I/O：pread()和 pwrite()</h2><p>​        系统调用 pread()和 pwrite()完成与 read()和 write()相类似的工作，只是前两者会在 offset 参数所指定的位置进行文件 I/O 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。</p><p><img src="image-20230803181548445.png" alt="image-20230803181548445"></p><p>​        pread()调用等同于将如下调用纳入同一原子操作：对 pread()和 pwrite()而言，fd 所指代的文件必须是可定位的（即允许对文件描述符执行lseek()调用）。</p><p>​        多线程应用为这些系统调用提供了用武之地。正如第 29 章所述，进程下辖的所有线程将共享同一文件描述符表。这也意味着每个已打开文件的文件偏移量为所有线程所共享。当调用pread()或 pwrite()时，多个线程可同时对同一文件描述符执行 I/O 操作，且不会因其他线程修改文件偏移量而受到影响。如果还试图使用 lseek()和 read()(或 write())来代替 pread()（或pwrite()），那么将引发竞争状态，这类似于 5.1 节讨论 O_APPEND 标志时的描述（当多个进程的文件描述符指向相同的打开文件句柄时，使用 pread()和 pwrite()系统调用同样能够避免进程间出现竞争状态）。</p><pre class="line-numbers language-none"><code class="language-none">如果需要反复执行 lseek()，并伴之以文件 I&#x2F;O，那么 pread()和 pwrite()系统调用在某些情况下是具有性能优势的。这是因为执行单个 pread()（或 pwrite()）系统调用的成本要低于执行 lseek()和 read()（或 write()）两个系统调用。然而，较之于执行 I&#x2F;O 实际所需的时间，系统调用的开销就有些相形见绌了。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分散输入和集中输出（Scatter-Gather-I-O）：readv-和-writev"><a href="#分散输入和集中输出（Scatter-Gather-I-O）：readv-和-writev" class="headerlink" title="分散输入和集中输出（Scatter-Gather I/O）：readv() 和 writev()"></a>分散输入和集中输出（Scatter-Gather I/O）：readv() 和 writev()</h2><p>​        readv()和 writev()系统调用分别实现了分散输入和集中输出的功能。</p><p><img src="image-20230803181750097.png" alt="image-20230803181750097"></p><p>​        这些系统调用并非只对单个缓冲区进行读写操作，而是一次即可传输多个缓冲区的数据。数组 iov 定义了一组用来传输数据的缓冲区。整型数 iovcnt 则指定了 iov 的成员个数。iov 中的每个成员都是如下形式的数据结构。</p><p><img src="image-20230803181801884.png" alt="image-20230803181801884"></p><pre class="line-numbers language-none"><code class="language-none">SUSv3 标准允许系统实现对 iov 中的成员个数加以限制。系统实现可以通过定义&lt;limits.h&gt;文件中 IOV_MAX 来通告这一限额，程序也可以在系统运行时调用 sysconf (_SC_ IOV_MAX)来获取这一限额。（11.2 节将介绍 sysconf()。）SUSv3 要求该限额不得少于 16。Linux将 IOV_MAX 的值定义为 1024，这是与内核对该向量大小的限制（由内核常量 UIO_MAXIOV定义）相对应的。然而，glibc 对 readv()和 writev()的封装函数1还悄悄做了些额外工作。若系统调用因iovcnt 参数值过大而失败，外壳函数将临时分配一块缓冲区，其大小足以容纳 iov 参数所有成员所描述的数据缓冲区，随后再执行 read()或 write()调用（参见后文对使用 write()实现writev()功能的讨论）。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>图 5-3 展示的是一个关于 iov、iovcnt 以及 iov 指向缓冲区之间关系的示例。</p><p><img src="image-20230803181844559.png" alt="image-20230803181844559"></p><h4 id="分散输入"><a href="#分散输入" class="headerlink" title="分散输入"></a>分散输入</h4><p>​        readv()系统调用实现了分散输入的功能：从文件描述符 fd 所指代的文件中读取一片连续的字节，然后将其散置（“分散放置”）于 iov 指定的缓冲区中。这一散置动作从 iov[0]开始，依次填满每个缓冲区。原子性是 readv()的重要属性。换言之，从调用进程的角度来看，当调用 readv()时，内核在 fd 所指代的文件与用户内存之间一次性地完成了数据转移。这意味着，假设即使有另一进程（或线程）与其共享同一文件偏移量，且在调用 readv()的同时企图修改文件偏移量，readv()所读取的数据仍将是连续的。调用 readv()成功将返回读取的字节数，若文件结束1将返回 0。调用者必须对返回值进行检查，以验证读取的字节数是否满足要求。若数据不足以填充所有缓冲区，则只会占用2部分缓冲区，其中最后一个缓冲区可能只存有部分数据。程序清单 5-2 展示了 readv()的用法。在本书中，当以函数名称冠以“t_”来命名示例程序时（例如：程序清单 5-2 中的程序t_readv.c），意在表明该程序主要用于展示单个系统调用或库函数的用法。程序清单 5-2：使用 readv()执行分散输入 _</p><p><img src="image-20230803181920503.png" alt="image-20230803181920503"></p><p><img src="image-20230803181925983.png" alt="image-20230803181925983"></p><h4 id="集中输出"><a href="#集中输出" class="headerlink" title="集中输出"></a>集中输出</h4><p>​        writev()系统调用实现了集中输出：将 iov 所指定的所有缓冲区中的数据拼接（“集中”）起来，然后以连续的字节序列写入文件描述符 fd 指代的文件中。对缓冲区中数据的“集中”始于iov[0]所指定的缓冲区，并按数组顺序展开。像 readv()调用一样，writev()调用也属于原子操作，即所有数据将一次性地从用户内存传输到 fd 指代的文件中。因此，在向普通文件写入数据时，writev()调用会把所有的请求数据连续写入文件，而不会在其他进程（或线程）写操作的影响下1分散地写入文件2。</p><p>​        如同 write()调用，writev()调用也可能存在部分写的问题。因此，必须检查 writev()调用的返回值，以确定写入的字节数是否与要求相符。</p><p>​        readv()调用和 writev()调用的主要优势在于便捷。如下两种方案，任选其一都可替代对writev()的调用。</p><ul><li>编码时，首先分配一个大缓冲区，随即再从进程地址空间的其他位置将数据复制过来，最后调用 write()输出其中的所有数据。</li><li>发起一系列 write()调用，逐一输出每个缓冲区中的数据。</li></ul><p>​        尽管方案一在语义上等同于 writev()调用，但需要在用户空间内分配缓冲区，进行数据复制，很不方便（效率也低）。方案二在语义上就不同于单次的 writev()调用，因为发起多次 write()调用将无法保证原子性。更何况，执行一次 writev()调用比执行多次 write()调用开销要小（参见 3.1 节关于系统调用的讨论）。</p><h4 id="在指定的文件偏移量处执行分散输入-集中输出"><a href="#在指定的文件偏移量处执行分散输入-集中输出" class="headerlink" title="在指定的文件偏移量处执行分散输入/集中输出"></a>在指定的文件偏移量处执行分散输入/集中输出</h4><p>​        Linux 2.6.30 版本新增了两个系统调用：preadv()、pwritev()，将分散输入/集中输出和于指定文件偏移量处的 I/O 二者集于一身。它们并非标准的系统调用，但获得了现代 BSD 的支持。 </p><p><img src="image-20230803182034792.png" alt="image-20230803182034792"></p><p>​        preadv()和 pwritev()系统调用所执行的任务与 readv()和 writev()相同，但执行 I/O 的位置将由 offset 参数指定（类似于 pread()和 pwrite()系统调用）1。对于那些既想从分散-集中 I/O 中受益，又不愿受制于当前文件偏移量的应用程序（比如，多线程的应用程序）而言，这些系统调用恰好可以派上用场。</p><h2 id="截断文件：truncate-和-ftruncate-系统调用"><a href="#截断文件：truncate-和-ftruncate-系统调用" class="headerlink" title="截断文件：truncate()和 ftruncate()系统调用"></a>截断文件：truncate()和 ftruncate()系统调用</h2><p>​        truncate()和 ftruncate()系统调用将文件大小设置为 length 参数指定的值。</p><p><img src="image-20230803183805730.png" alt="image-20230803183805730"></p><p>​        <strong>若文件当前长度大于参数 length，调用将丢弃超出部分，若小于参数 length，调用将在文件尾部添加一系列空字节或是一个文件空洞。</strong>两个系统调用之间的差别在于如何指定操作文件。truncate()以路径名字符串来指定文件，并要求可访问该文件2，且对文件拥有写权限。若文件名为符号链接，那么调用将对其进行解引用。而调用 ftruncate()之前，需以可写方式打开操作文件，获取其文件描述符以指代该文件，该系统调用不会修改文件偏移量。若 ftruncate()的 length 参数值超出文件的当前大小，SUSv3 允许两种行为：要<strong>么扩展该文件（如 Linux），要么返回错误。而符合 XSI 标准的系统则必须采取前一种行为。相同的情况，对于 truncate()系统调用，SUSv3 则要求总是能扩展文件。truncate()无需先以 open()（或是一些其他方法）来获取文件描述符，却可修改文件内容，在系统调用中可谓独树一帜。</strong></p><h2 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h2><p>​        在打开文件时指定 O_NONBLOCK 标志，目的有二。</p><ul><li>若 open()调用未能立即打开文件，则返回错误，而非陷入阻塞。有一种情况属于例外，调用 open()操作 FIFO 可能会陷入阻塞（参见 44.7 节）。</li><li>调用 open()成功后，后续的 I/O 操作也是非阻塞的。若 I/O 系统调用未能立即完成，则可能会只传输部分数据，或者系统调用失败，并返回 EAGAIN 或 EWOULDBLOCK 错误。具体返回何种错误将依赖于系统调用。Linux 系统与许多 UNIX 实现一样，将两个错误常量视为同义。</li></ul><p>​        管道、FIFO、套接字、设备（比如终端、伪终端）都支持非阻塞模式。（因为无法通过 open()来获取管道和套接字的文件描述符，所以要启用非阻塞标志，就必须使用 5.3 节所述 fcntl()的F_SETFL 命令。）正如 13.1 节所述，由于内核缓冲区保证了普通文件 I/O 不会陷入阻塞，故而打开普通文件时一般会忽略 O_NONBLOCK 标志。然而，当使用强制文件锁时（55.4 节），O_NONBLOCK标志对普通文件也是起作用的。更多关于非阻塞 I/O 的信息请参见 44.9 节和第 63 章。</p><pre class="line-numbers language-none"><code class="language-none">历史上，派生自 System V 的系统提供有 O_NDELAY 标志，语义上类似于 O_ NONBLOCK标志。二者主要的区别在于：在 System V 系统中，若非阻塞的 write()调用未能完成写操作，或者非阻塞的 read()调用无输入数据可读时，则两个调用将返回 0。这对于 read()调用来说会有问题，因为程序将无法区分返回 0 的 read()到底是没有可用的输入数据，还是遇到了文件结尾1。故而 POSIX.1 标准在初版中引入了 O_NONBLOCLK 标志。有些UNIX 实现一直还在支持旧语义的 O_NDELAY 标志。Linux 系统虽然也定义了 O_NDELAY常量，但其与 O_NONBLOCK 标志同义。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-10-大文件-I-O"><a href="#5-10-大文件-I-O" class="headerlink" title="5.10 大文件 I/O"></a>5.10 大文件 I/O</h2><p>​        通常将存放文件偏移量的数据类型 off_t 实现为一个有符号的长整型。（之所以采用有符号数据类型，是要以−1 来表示错误情况。）在 32 位体系架构中（比如 x86-32），这将文件大小置于 $2^{31}−1 $个字节（即 2GB）的限制之下。</p><p>​        然而，磁盘驱动器的容量早已超出这一限制，因此 32 位 UNIX 实现有处理超过 2GB 大小文件的需求，这也在情理之中。由于问题较为普遍，UNIX 厂商联盟在大型文件峰会（Large File Summit）上就此进行了协商，并针对必需的大文件访问功能，形成了对 SUSv2 规范的扩展。</p><p>​        始于内核版本 2.4，32 位 Linux 系统开始提供对 LFS 的支持（glibc 版本必须为 2.2 或更高）。另一个前提是，相应的文件系统也必须支持大文件操作。大多数“原生”Linux 文件系统提供了 LFS 支持，但一些“非原生”文件系统则未提供该功能（微软的 VFAT 和 NFSv2 系统是其中较为知名的范例，无论系统是否启用了 LFS 扩展功能，2GB 的文件大小限制都是硬杠杠）。</p><pre class="line-numbers language-none"><code class="language-none">由于 64 位系统架构（例如，Alpha、IA-64）的长整型类型长度为 64 位，故而 LFS 增强特性所要突破的限制对其而言并不是问题。然而，即便在64 位系统中，一些“原生”Linux 文件系统的实现细节还是将文件大小的理论值默认为不会超过 2^63−1 个字节。在大多数情况下，此限额远远超出了目前的磁盘容量，故而这一对文件大小的限制并无实际意义。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        应用程序可使用如下两种方式之一以获得 LFS 功能。</p><ul><li>使用支持大文件操作的备选 API。该 API 由 LFS 设计，意在作为 SUS 规范的“过渡型扩展”。因此，尽管大部分系统都支持这一 API，但这对于符合 SUSv2 或 SUSv3 规范的系统其实并非必须。这一方法现已过时。</li><li>在编译应用程序时，将宏_FILE_OFFSET_BITS 的值定义为 64。这一方法更为可取，因为符合 SUS 规范的应用程序无需修改任何源码即可获得 LFS 功能。</li></ul><h4 id="过渡型-LFS-API"><a href="#过渡型-LFS-API" class="headerlink" title="过渡型 LFS API"></a>过渡型 LFS API</h4><p>​        要使用过渡型的 LFS API，必须在编译程序时定义_LARGEFILE64_SOURCE 功能测试宏，该定义可以通过命令行指定，也可以定义于源文件中包含所有头文件之前的位置。该 API 所属函数具有处理 64 位文件大小和文件偏移量的能力。这些函数与其 32 位版本命名相同，只是尾部缀以 64 以示区别。其中包括：fopen64()、open64()、lseek64()、truncate64()、stat64()、mmap64()和 setrlimit64()。（针对这些函数的 32 位版本，本书前面已然讨论了一部分，还有一些将在后续章节中描述。）要访问大文件，可以使用这些函数的 64 位版本。例如，打开大文件的编码示例如下：调用 open64()，相当于在调用 open()时指定 O_LARGEFILE 标志。</p><p><img src="image-20230803184224033.png" alt="image-20230803184224033"></p><p>​        若调用 open()时未指定此标志，且欲打开的文件大小大于 2GB，那么调用将返回错误。另外，除去上述提及的函数之外，过渡型 LFS API 还增加了一些新的数据类型，如下所示 </p><p>struct stat64：类似于 stat 结构（参见 15.1 节），支持大文件尺寸。</p><p>off64_t：64 位类型，用于表示文件偏移量。</p><p>​        如程序清单 5-3 所示，除去使用了该 API 中的其他 64 位函数之外，lseek64()就用到了数据类型 off64_t。该程序接受两个命令行参数：欲打开的文件名称和给定的文件偏移量（整型）值。程序首先打开指定的文件，然后检索至给定的文件偏移量处，随即写入一串字符。如下所示的 shell会话中，程序检索到一个超大的文件偏移量处（超过 10GB），再写入一些字节：</p><p><img src="image-20230803184308492.png" alt="image-20230803184308492"></p><p>​        程序清单 5-3：访问大文件 </p><p><img src="image-20230803184333790.png" alt="image-20230803184333790"></p><p><img src="image-20230803184344338.png" alt="image-20230803184344338"></p><h4 id="FILE-OFFSET-BITS-宏"><a href="#FILE-OFFSET-BITS-宏" class="headerlink" title="_FILE_OFFSET_BITS 宏"></a>_FILE_OFFSET_BITS 宏</h4><p>​        要获取 LFS 功能，推荐的作法是：在编译程序时，将宏_FILE_OFFSET_BITS 的值定义为64。做法之一是利用 C 语言编译器的命令行选项：</p><p><img src="image-20230803184359092.png" alt="image-20230803184359092"></p><p>另外一种方法，是在 C 语言的源文件中，在包含所有头文件之前添加如下宏定义：</p><p><img src="image-20230803184405206.png" alt="image-20230803184405206"></p><p>​        所有相关的 32 位函数和数据类型将自动转换为 64 位版本。因而，例如，实际会将 open()转换为 open64()，数据类型 off_t 的长度也将转而定义为 64 位。换言之，无需对源码进行任何修改，只要对已有程序进行重新编译，就能够实现大文件操作。</p><p>​        显然，使用宏_FILE_OFFSET_BITS 要比采用过渡型的 LFS API 更为简单，但这也要求应用程序的代码编写必须规范（例如，声明用于放置文件偏移量的变量，应正确地使用 off_t，而不能使用“原生”的 C 语言整型）。</p><p>​        LFS 规范对于支持_FILE_OFFSET_BITS 宏未作硬性规定，仅仅提及将该宏作为指定数据类型 off_t 大小的可选方案。一些 UNIX 实现使用不同的特性测试宏来获取此功能。</p><pre class="line-numbers language-none"><code class="language-none">若试图使用 32 位函数访问大文件（即在编译程序时，未将宏_FILE_OFFSET_BITS 的值设置为 64），调用可能会返回 EOVERFLOW 错误。例如，为获取大小超过 2G 文件的信息，若使用 stat 的 32 位版本时就会遇到这一错误。_<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="向-printf-调用传递-off-t-值"><a href="#向-printf-调用传递-off-t-值" class="headerlink" title="向 printf()调用传递 off_t 值"></a>向 printf()调用传递 off_t 值</h4><p>​        LFS 扩展功能没有解决的问题之一是，如何向 printf()调用传递 off_t 值。3.6.2 节曾特别指出，对于预定义的系统数据类型（诸如 pid_t、uid_t），展示其值的可移植方法是将该值强制转换为 long 型，并在 printf()中使用限定符%ld。然而，一旦使用了 LFS 扩展功能，%ld 将不足以处理 off_t 数据类型，因为对该数据类型的定义可能会超出 long 类型的范围，一般为 long long类型。据此，若要显示 off_t 类型的值，则先要将其强制转换为 long long 类型，然后使用 printf()函数的%lld 限定符显示，如下所示：</p><p><img src="image-20230803184515230.png" alt="image-20230803184515230"></p><p>​        在处理 stat 结构所使用的 blkcnt_t 数据类型时，也应予以类似关注（参见 15.1 节的描述）。如需在独立的编译模块之间传递 off_t 或 stat 类型的参数值，则需确保在所有模块中，这些数据类型的大小相同（即编译这些模块时，要么将宏_FILE_OFFSET_BITS 的值都定义为 64，要么都不做定义）。</p><h2 id="dev-fd-目录"><a href="#dev-fd-目录" class="headerlink" title="/dev/fd 目录"></a>/dev/fd 目录</h2><p>​        对于每个进程，内核都提供有一个特殊的虚拟目录/dev/fd。该目录中包含“/dev/fd/n”形式的文件名，其中 n 是与进程中的打开文件描述符相对应的编号。因此，例如，/dev/fd/0 就对应于进程的标准输入。（SUSv3 对/dev/fd 特性未做规定，但有些其他的 UNIX 实现也提供了这一特性。）</p><p>​        打开/dev/fd 目录中的一个文件等同于复制相应的文件描述符，所以下列两行代码是等价的：</p><p><img src="image-20230803184537756.png" alt="image-20230803184537756"></p><p>​        在为 open()调用设置 flag 参数时，需要注意将其设置为与原描述符相同的访问模式。这一场景下，在 flag 标志的设置中引入其他标志，诸如 O_CREAT，是毫无意义的（系统会将其忽略）。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;dev&#x2F;fd 实际上是一个符号链接，链接到 Linux 所专有的&#x2F;proc&#x2F;self&#x2F;fd 目录。后者又是 Linux特有的&#x2F;proc&#x2F;PID&#x2F;fd 目录族的特例之一，此目录族中的每一目录都包含有符号链接，与一进程所打开的所有文件相对应。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        程序中很少会使用/dev/fd 目录中的文件。其主要用途在 shell 中。许多用户级 shell 命令将文件名作为参数，有时需要将命令输出至管道，并将某个参数替换为标准输入或标准输出。出于这一目的，有些命令（例如，diff、ed、tar 和 comm）提供了一个解决方法，使用“-”符号作为命令的参数之一，用以表示标准输入或输出（视情况而定）。所以，要比较 ls 命令输出的文件名列表与之前生成的文件名列表，命令就可以写成：</p><pre class="line-numbers language-none"><code class="language-none">ls | diff - oldfilelist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这种方法有不少问题。首先，该方法要求每个程序都对“-”符号做专门处理，但是许多程序并未实现这样的功能，这些命令只能处理文件，不支持将标准输入或输出作为参数。</p><p>​        其次，有些程序还将单个“-”符解释为表征命令行选项结束的分隔符。使用/dev/fd 目录，上述问题将迎刃而解，可以把标准输入、标准输出和标准错误作为文件名参数传递给任何需要它们的程序。所以，可以将前一个 shell 命令改写成如下形式：</p><pre class="line-numbers language-none"><code class="language-none">ls | diff &#x2F;dev&#x2F;fd&#x2F;0 oldfilelist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        方便起见，系统还提供了 3 个符号链接：/dev/stdin、/dev/stdout 和/dev/stderr，分别链接到/dev/fd/0、/dev/fd/1 和/dev/fd/2。</p><h2 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h2><p>​        有些程序需要创建一些临时文件，仅供其在运行期间使用，程序终止后即行删除。例如，很多编译器程序会在编译过程中创建临时文件。GNU C 语言函数库为此而提供了一系列库函数。（之所以有“一系列”的库函数，部分原因是由于这些函数分别继承自各种 UNIX 实现。）本节将介绍其中的两个函数：mkstemp()和 tmpfile()。</p><p>​        <strong>基于调用者提供的模板，mkstemp()函数生成一个唯一文件名并打开该文件，返回一个可用于 I/O 调用的文件描述符。</strong></p><p><img src="image-20230803184721401.png" alt="image-20230803184721401"></p><p>​        模板参数采用路径名形式，其中最后 6 个字符必须为 XXXXXX。这 6 个字符将被替换，以保证文件名的唯一性，且修改后的字符串将通过 template 参数传回。因为会对传入的 template参数进行修改，所以必须将其指定为字符数组，而非字符串常量。</p><p>​        文件拥有者对 mkstemp()函数建立的文件拥有读写权限（其他用户则没有任何操作权限），且打开文件时使用了 O_EXCL 标志，以保证调用者以独占方式访问文件。</p><p>​        通常，打开临时文件不久，程序就会使用 unlink 系统调用（参见 18.3 节）将其删除。故而，mkstemp()函数的示例代码如下所示：</p><p><img src="image-20230803184801020.png" alt="image-20230803184801020"></p><p>​        使用 tmpnam()、tempnam()和 mktemp()函数也能生成唯一的文件名。然而，由于这会导致应用程序出现安全漏洞，应当避免使用这些函数。关于这些函数的进一步细节请参考手册页。tmpfile()函数会创建一个名称唯一的临时文件，并以读写方式将其打开。（打开该文件时使用了 O_EXCL 标志，以防一个可能性极小的冲突，即另一个进程已经创建了一个同名文件。）tmpfile()函数执行成功，将返回一个文件流供 stdio 库函数使用。文件流关闭后将自动删除临时文件。为达到这一目的，tmpfile()函数会在打开文件后，从内部立即调用 unlink()来删除该文件名1。 1 译者注：进程终止时会关闭所有打开的文件描述符，关闭文件就会删除这些临时文件（参考 mkstmp 代码示例中的注释），由此可以推导出，进程退出时将自动删除临时文件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        本章介绍了原子操作的概念，这对于一些系统调用的正确操作至关重要。特别是，指定O_EXCL 标志调用 open()，这确保了调用者就是文件的创建者。而指定 O_APPEND 标志来调用 open()，还确保了多个进程在对同一文件追加数据时不会覆盖彼此的输出。系统调用 fcntl()可以执行许多文件控制操作，其中包括：修改打开文件的状态标志、复制文件描述符。使用 dup()和 dup2()系统调用也能实现文件描述符的复制功能。本章接着研究了文件描述符、打开文件句柄和文件 i-node 之间的关系，并特别指出这 3个对象各自包含的不同信息。文件描述符及其副本指向同一个打开文件句柄，所以也将共享打开文件的状态标志和文件偏移量。之后描述的诸多系统调用，是对常规 read()和 write()系统调用的功能扩展。pread()和pwrite()系统调用可在文件的指定位置处执行 I/O 功能，且不会修改文件偏移量。readv()和writev()系统调用实现了分散输入和集中输出的功能。preadv()和 pwritev()系统调用则集上述两对系统调用的功能于一身。使用 truncate() 和 ftruncate()系统调用，既可以丢弃多余的字节以缩小文件大小，又能使用填充为 0 的文件空洞来增加文件大小。本章还简单介绍了非阻塞 I/O 的概念，后续章节中还将继续讨论。LFS 规范定义了一套扩展功能，允许在 32 位系统中运行的进程来操作无法以 32 位表示的大文件。运用虚拟目录/dev/fd 中的编号文件，进程就可以通过文件描述符编号来访问自己打开的文件，这在 shell 命令中尤其有用。mkstemp()和 tmpfile()函数允许应用程序去创建临时文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP 网络编程笔记——1，2，3</title>
      <link href="/2023/08/23/TCP-IP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%EF%BC%8C2%EF%BC%8C3/"/>
      <url>/2023/08/23/TCP-IP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%EF%BC%8C2%EF%BC%8C3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-理解网络和套接字"><a href="#1-理解网络和套接字" class="headerlink" title="1. 理解网络和套接字"></a>1. 理解网络和套接字</h1><p>​        网络编程实在很简单，其实就是一句话： 研究编写使得两台联网的计算机通信的程序！没了！</p><p>​        计算机提供一个叫做socket的东西，实际上就是“套接字”的意思。难以理解？其实就是插头！说白了就是通信的软件接口。</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>​        快速的讲一些常见的接口——先把流程梳理明白了——</p><p>​        假装我们是一台计算机（倒不如假设我们的计算机是人），想要跟别的计算机通信，就务必需要——有——电话机</p><p>​        好吧，现在手无寸铁，先整个电话机玩玩</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;socket.h&gt;int scoket(int domain, int type, int protocol);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        第一个参数说的是用的是什么套接字类型</p><p>​        而这里的type指的是协议面向的种类， 也就是说“type”参数指的是套接字类型，常用的类型有：</p><ul><li>SOCK_STREAM（TCP流）</li><li>SOCK_DGRAM（UDP数据报）</li><li>SOCK_RAW（原始套接字）</li></ul><p>​        协议“protocol”一般设置为“0”，就是说在已经确定套接字使用的协议簇和类型时，这个参数的值就为0</p><p>​        我们将会在稍后看到，作为我们已知使用的协议种类后，只需要这里置0即可。（对于那些无法确定协议种类的才会在这里设置其他东西）</p><p>​        随后，就是bind，有电话机，就需要有电话号码——这个函数就是确定套接字的地址信息，告诉这个套接字要去哪里（IP和端口）</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;socket.h&gt;int bind(int sockfd,struct sockaddr* myaddr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        接下来就是接听（相当于打了电话号码等）</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;socket.h&gt;int listen(int sockfd, int backlog);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>值得一提的sockfd这个fd, 在Linux下指的是file discriptor（描述符，不理解的话可以认为是Windows下的文件句柄）</p></blockquote><p>​        等到客户端有了响应之后，我们就要摁下同意表示愿意接听</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;socket.h&gt;int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        总结一下：</p><blockquote><p>第一步：调用socket创建套接字</p><p>第二步：调用bind函数分配IP和端口号</p><p>第三步：调用listen函数转化为可接受请求的状态</p><p>第四步：调用accept受理链接请求</p></blockquote><p>​        方便起见，这里就扔下代码：</p><blockquote><p>TIPS: 你的电脑绝对没有SC.h这个文件，因为这是我自己写的，对于那些常见的函数给封装在同一个头文件而不需要反复写，在这个节段：</p></blockquote><h3 id="SC-c"><a href="#SC-c" class="headerlink" title="SC.c"></a>SC.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;SC.h&quot;&#x2F;&#x2F; error handlevoid showError(const char* message)&#123;fputs(message,stdout);fputc(&#39;\n&#39;,stdout);exit(-1);&#125;&#x2F;&#x2F; show argc helpvoid showHelp(int argc_n, int agrc_r ,const char* msgHelp)&#123;    if(argc_n !&#x3D; agrc_r)&#123;        printf(&quot;%s&quot;,msgHelp);        exit(1);    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sc-h"><a href="#Sc-h" class="headerlink" title="Sc.h"></a>Sc.h</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef _SC_H_#define _SC_H_#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; &#x2F;&#x2F; 提供Linux文件IO#include &lt;arpa&#x2F;inet.h&gt;#include &lt;sys&#x2F;socket.h&gt;#include &lt;errno.h&gt;typedef struct sockaddr_in Sockaddr_in;typedef struct sockaddr Sockaddr;&#x2F;&#x2F; pre-announcedvoid showError(const char* message);void showHelp(int argc_n, int agrc_r, const char* msgHelp);&#x2F;&#x2F; setMemZero#define ZERO 0#define ZeroMem(buf) memset(buf, ZERO, sizeof(buf))#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// include basic files</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"SC.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> serv_sock<span class="token punctuation">;</span><span class="token keyword">int</span> clnt_sock<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv_addr<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> clnt_addr<span class="token punctuation">;</span><span class="token class-name">socklen_t</span> clnt_addr_size<span class="token punctuation">;</span><span class="token keyword">char</span> message<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello, world\n"</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: &lt;port>\n"</span><span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>serv_sock <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>PF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>serv_sock <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">showError</span><span class="token punctuation">(</span><span class="token string">"socket Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>serv_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>serv_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>serv_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">bind</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>errno<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">showError</span><span class="token punctuation">(</span><span class="token string">"bind() Error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">listen</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">showError</span><span class="token punctuation">(</span><span class="token string">"listen() error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>clnt_addr_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>clnt_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>clnt_sock <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>clnt_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>clnt_addr_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>clnt_sock <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">showError</span><span class="token punctuation">(</span><span class="token string">"accept() error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">write</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">,</span> message<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>clnt_sock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>serv_sock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于客户端，我们只需要给出链接的地址和端口，就可以了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;sys&#x2F;socket.h&gt;int connect(int sockfd, struct sockaddr* serv_addr, socklen_t addrlen);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>第一步：创建套接字（调用socket函数）</p><p>第二步：调用connect函数</p></blockquote><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;SC.h&quot;int main(int argc, char* argv[])&#123;    int sock;    Sockaddr_in serv_addr;    char message[30];    int str_len;    showHelp(3,argc,&quot;Usage: argv[0] &lt;IP&gt; &lt;port&gt;\n&quot;);    sock &#x3D; socket(PF_INET,SOCK_STREAM,0);    if(sock &#x3D;&#x3D; -1)&#123;        showError(&quot;socket() Error&quot;);    &#125;    ZeroMem(&amp;serv_addr);    serv_addr.sin_family &#x3D; AF_INET;    serv_addr.sin_addr.s_addr &#x3D; inet_addr(argv[1]);    serv_addr.sin_port &#x3D; htons(atoi(argv[2]));    if(connect(sock, (Sockaddr*)&amp;serv_addr,sizeof(serv_addr)) &#x3D;&#x3D; -1)&#123;    printf(&quot;%d\n&quot;,errno);        showError(&quot;connect() Error&quot;);    &#125;    str_len &#x3D; read(sock,message,sizeof(message) - 1);    if(str_len &#x3D;&#x3D; -1)&#123;        showError(&quot;read() error&quot;);    &#125;      printf(&quot;Message from server:&gt; %s\n&quot;,message);    close(sock);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>运行</p></blockquote><pre class="line-numbers language-none"><code class="language-none">gcc -o client client.c SC.c SC.h # 产生客户端的可执行代码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">gcc -o server server.c SC.c SC.h # 产生服务端的可执行代码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后运行（额，假定你对Linux操作系统是用过的情况下）</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;server 9190             # 运行在自己家电脑，IP是127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">.&#x2F;client 127.0.0.1 9190 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230823081013006.png" alt="image-20230823081013006"></p><h3 id="Windows实现"><a href="#Windows实现" class="headerlink" title="Windows实现"></a>Windows实现</h3><p>​        在Windows底下，我们同样可以干这样的事情。这里未来方便于网络而不是环境配置，我们使用VS</p><p>​        不过首先，我们需要链接ws2_32.lib（项目-&gt;属性-&gt;链接器-&gt;输入-&gt;附加依赖项）</p><p>​        先来就是初始化相关的库——</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;winsock2.h&gt;int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>第一个参数：Winsock的版本（高情商：兼容）</p><p>第二个参数：WSADATA这个结构体的地址（相信我，Windows喜欢通过传参数的方式初始化，这是为了可以返回状态而设置的！）</p></blockquote><p>​        设置版本是使用一个十六位数实现的。咋搞呢？举个例子</p><p>​        我现在的函数有主版本和副版本之称：Winsock 1.1和Winsock 2.1之类的。那么，我就用低8位表达主版本，高8位表达副版本。 那： <code>v</code>$1.2$  $\leftrightarrow$ $0x0201$</p><p>​        啥？别自己手写了</p><pre class="line-numbers language-none"><code class="language-none">MAKEWORD(1, 2) -&gt; 0x0201MAKEWORD(2, 2) -&gt; 0x0202<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        同理：我们来看看Windows 的</p><h3 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;winsock2.h&gt;void ErrorHandling(const char* msg);int main(int argc, char* argv[])&#123;WSADATA wsadata;SOCKET hServSock, hClntSock;SOCKADDR_IN servAddr, clntAddr;int szClntAddr;char message[] &#x3D; &quot;HelloWorld\n&quot;;if (argc !&#x3D; 2) &#123;printf(&quot;Usage : %s &lt;port&gt;\n&quot;, argv[0]);exit(1);&#125;if (WSAStartup(MAKEWORD(2, 2), &amp;wsadata) !&#x3D; 0)ErrorHandling(&quot;WSAStartUp Error&quot;);hServSock &#x3D; socket(PF_INET, SOCK_STREAM, 0);if (hServSock &#x3D;&#x3D; INVALID_SOCKET)ErrorHandling(&quot;socket error&quot;);memset(&amp;servAddr, 0, sizeof(servAddr));servAddr.sin_family &#x3D; AF_INET;servAddr.sin_addr.s_addr&#x3D;htonl(INADDR_ANY);servAddr.sin_port &#x3D; htons(atoi(argv[1]));if (bind(hServSock, (SOCKADDR*)&amp;servAddr, sizeof(servAddr)) &#x3D;&#x3D; SOCKET_ERROR)ErrorHandling(&quot;bind error&quot;);if (listen(hServSock, 5) &#x3D;&#x3D; SOCKET_ERROR)ErrorHandling(&quot;listen error&quot;);szClntAddr &#x3D; sizeof(clntAddr);hClntSock &#x3D; accept(hServSock, (SOCKADDR*)&amp;clntAddr, &amp;szClntAddr);if (hClntSock &#x3D;&#x3D; INVALID_SOCKET)ErrorHandling(&quot;accept error&quot;);send(hClntSock, message, sizeof(message), 0);closesocket(hClntSock);closesocket(hServSock);WSACleanup();return 0;&#125;void ErrorHandling(const char* msg)&#123;fputs(msg, stderr);fputc(&#39;\n&#39;, stderr);exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;winsock2.h&gt;void ErrorHandling(const char *message);int main(int argc, char* argv[])&#123;WSADATA wsaData;SOCKET hSocket;SOCKADDR_IN servAddr;char message[30];int strLen &#x3D; 0;int idx &#x3D; 0, readLen &#x3D; 0;if (argc !&#x3D; 3)&#123;printf(&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;, argv[0]);exit(1);&#125;if (WSAStartup(MAKEWORD(2, 2), &amp;wsaData) !&#x3D; 0)&#123;printf(&quot;%d\n&quot;,GetLastError());ErrorHandling(&quot;WSAStartup() error!&quot;);&#125;hSocket &#x3D; socket(PF_INET, SOCK_STREAM, 0);if (hSocket &#x3D;&#x3D; INVALID_SOCKET) ErrorHandling(&quot;socket() error!&quot;);memset(&amp;servAddr, 0, sizeof(servAddr));servAddr.sin_family &#x3D; AF_INET;servAddr.sin_addr.s_addr &#x3D; inet_addr(argv[1]); &#x2F;&#x2F; IP addressservAddr.sin_port &#x3D; htons(atoi(argv[2])); &#x2F;&#x2F; portif (connect(hSocket, (SOCKADDR*)&amp;servAddr, sizeof(servAddr)) &#x3D;&#x3D; SOCKET_ERROR)ErrorHandling(&quot;connect() error!&quot;);elseputs(&quot;Connected...........&quot;);while (readLen &#x3D; recv(hSocket, &amp;message[idx++], 1, 0))&#123;if (readLen &#x3D;&#x3D; -1)ErrorHandling(&quot;read() error!&quot;);strLen +&#x3D; readLen;&#125;printf(&quot;Message from server: %s \n&quot;, message);printf(&quot;Function read call count: %d \n&quot;, strLen);closesocket(hSocket);WSACleanup();return 0;&#125;void ErrorHandling(const char* message)&#123;fputs(message, stderr);fputc(&#39;\n&#39;, stderr);exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="套接字类型和协议设置"><a href="#套接字类型和协议设置" class="headerlink" title="套接字类型和协议设置"></a>套接字类型和协议设置</h1><h2 id="啥是协议"><a href="#啥是协议" class="headerlink" title="啥是协议"></a>啥是协议</h2><p>​        你用你的语法说，我用我的语法说，两个人互相听不懂对方说什么，这不无效沟通吗？是的，这玩意的出现就是为了规范通信。</p><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>​        回忆下我们刚刚体验过的socket函数。。。啥，不记得了？这里：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;sys&#x2F;socket.h&gt;int scoket(int domain, int type, int protocol);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我们第一个参数，就是说的用的什么套接字类型，你可以翻看一下sys/socket.h提供的接口</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* Protocol families.  *&#x2F;#define PF_UNSPEC0&#x2F;* Unspecified.  *&#x2F;#define PF_LOCAL1&#x2F;* Local to host (pipes and file-domain).  *&#x2F;#define PF_UNIXPF_LOCAL &#x2F;* POSIX name for PF_LOCAL.  *&#x2F;#define PF_FILEPF_LOCAL &#x2F;* Another non-standard name for PF_LOCAL.  *&#x2F;#define PF_INET2&#x2F;* IP protocol family.  *&#x2F;#define PF_AX253&#x2F;* Amateur Radio AX.25.  *&#x2F;#define PF_IPX4&#x2F;* Novell Internet Protocol.  *&#x2F;#define PF_APPLETALK5&#x2F;* Appletalk DDP.  *&#x2F;#define PF_NETROM6&#x2F;* Amateur radio NetROM.  *&#x2F;#define PF_BRIDGE7&#x2F;* Multiprotocol bridge.  *&#x2F;#define PF_ATMPVC8&#x2F;* ATM PVCs.  *&#x2F;#define PF_X259&#x2F;* Reserved for X.25 project.  *&#x2F;#define PF_INET610&#x2F;* IP version 6.  *&#x2F;#define PF_ROSE11&#x2F;* Amateur Radio X.25 PLP.  *&#x2F;#define PF_DECnet12&#x2F;* Reserved for DECnet project.  *&#x2F;#define PF_NETBEUI13&#x2F;* Reserved for 802.2LLC project.  *&#x2F;#define PF_SECURITY14&#x2F;* Security callback pseudo AF.  *&#x2F;#define PF_KEY15&#x2F;* PF_KEY key management API.  *&#x2F;#define PF_NETLINK16#define PF_ROUTEPF_NETLINK &#x2F;* Alias to emulate 4.4BSD.  *&#x2F;#define PF_PACKET17&#x2F;* Packet family.  *&#x2F;#define PF_ASH18&#x2F;* Ash.  *&#x2F;#define PF_ECONET19&#x2F;* Acorn Econet.  *&#x2F;#define PF_ATMSVC20&#x2F;* ATM SVCs.  *&#x2F;#define PF_RDS21&#x2F;* RDS sockets.  *&#x2F;#define PF_SNA22&#x2F;* Linux SNA Project *&#x2F;#define PF_IRDA23&#x2F;* IRDA sockets.  *&#x2F;#define PF_PPPOX24&#x2F;* PPPoX sockets.  *&#x2F;#define PF_WANPIPE25&#x2F;* Wanpipe API sockets.  *&#x2F;#define PF_LLC26&#x2F;* Linux LLC.  *&#x2F;#define PF_IB27&#x2F;* Native InfiniBand address.  *&#x2F;#define PF_MPLS28&#x2F;* MPLS.  *&#x2F;#define PF_CAN29&#x2F;* Controller Area Network.  *&#x2F;#define PF_TIPC30&#x2F;* TIPC sockets.  *&#x2F;#define PF_BLUETOOTH31&#x2F;* Bluetooth sockets.  *&#x2F;#define PF_IUCV32&#x2F;* IUCV sockets.  *&#x2F;#define PF_RXRPC33&#x2F;* RxRPC sockets.  *&#x2F;#define PF_ISDN34&#x2F;* mISDN sockets.  *&#x2F;#define PF_PHONET35&#x2F;* Phonet sockets.  *&#x2F;#define PF_IEEE80215436&#x2F;* IEEE 802.15.4 sockets.  *&#x2F;#define PF_CAIF37&#x2F;* CAIF sockets.  *&#x2F;#define PF_ALG38&#x2F;* Algorithm sockets.  *&#x2F;#define PF_NFC39&#x2F;* NFC sockets.  *&#x2F;#define PF_VSOCK40&#x2F;* vSockets.  *&#x2F;#define PF_KCM41&#x2F;* Kernel Connection Multiplexor.  *&#x2F;#define PF_QIPCRTR42&#x2F;* Qualcomm IPC Router.  *&#x2F;#define PF_SMC43&#x2F;* SMC sockets.  *&#x2F;#define PF_XDP44&#x2F;* XDP sockets.  *&#x2F;#define PF_MAX45&#x2F;* For now..  *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我去，这可太多了，我们现在，主要聚焦在如下的几个协议族</p><div class="table-container"><table><thead><tr><th>名称</th><th>协议族</th></tr></thead><tbody><tr><td><code>PF_INET</code></td><td>IPv4互联网协议族</td></tr><tr><td><code>PF_INET6</code></td><td>IPv6互联网协议族</td></tr><tr><td><code>PF_LOCAL</code></td><td>本地通信的互联网协议族</td></tr><tr><td><code>PF_PACKET</code></td><td>底层套接字的协议族</td></tr><tr><td><code>PF_IPX</code></td><td>IPX Novell协议族</td></tr></tbody></table></div><p>​        那为什么还要有第二个参数呢？答案很简单，就算是我们选定了协议族，其内部还是有很多其他的数据通信方式。我们怎么传？是安全优先还是速度优先呢？</p><pre class="line-numbers language-none"><code class="language-none">enum __socket_type&#123;  SOCK_STREAM &#x3D; 1,&#x2F;* Sequenced, reliable, connection-based   byte streams.  *&#x2F;#define SOCK_STREAM SOCK_STREAM  SOCK_DGRAM &#x3D; 2,&#x2F;* Connectionless, unreliable datagrams   of fixed maximum length.  *&#x2F;#define SOCK_DGRAM SOCK_DGRAM  SOCK_RAW &#x3D; 3,&#x2F;* Raw protocol interface.  *&#x2F;#define SOCK_RAW SOCK_RAW  SOCK_RDM &#x3D; 4,&#x2F;* Reliably-delivered messages.  *&#x2F;#define SOCK_RDM SOCK_RDM  SOCK_SEQPACKET &#x3D; 5,&#x2F;* Sequenced, reliable, connection-based,   datagrams of fixed maximum length.  *&#x2F;#define SOCK_SEQPACKET SOCK_SEQPACKET  SOCK_DCCP &#x3D; 6,&#x2F;* Datagram Congestion Control Protocol.  *&#x2F;#define SOCK_DCCP SOCK_DCCP  SOCK_PACKET &#x3D; 10,&#x2F;* Linux specific way of getting packets   at the dev level.  For writing rarp and   other similar things on the user level. *&#x2F;#define SOCK_PACKET SOCK_PACKET  &#x2F;* Flags to be ORed into the type parameter of socket and socketpair and     used for the flags parameter of paccept.  *&#x2F;  SOCK_CLOEXEC &#x3D; 02000000,&#x2F;* Atomically set close-on-exec flag for the   new descriptor(s).  *&#x2F;#define SOCK_CLOEXEC SOCK_CLOEXEC  SOCK_NONBLOCK &#x3D; 00004000&#x2F;* Atomically mark descriptor(s) as   non-blocking.  *&#x2F;#define SOCK_NONBLOCK SOCK_NONBLOCK&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SOCK-STREAM：面向链接的套接字"><a href="#SOCK-STREAM：面向链接的套接字" class="headerlink" title="SOCK_STREAM：面向链接的套接字"></a>SOCK_STREAM：面向链接的套接字</h3><ul><li>这个传输过程中的数据不会消失，</li><li>并且，会按照顺序依次传输数据，</li><li>传输的数据不会存在数据的边界</li></ul><h3 id="SOCK-DGRAM"><a href="#SOCK-DGRAM" class="headerlink" title="SOCK_DGRAM"></a>SOCK_DGRAM</h3><ul><li>强调快速传输而不是顺序传输</li><li>传输的数据可能丢失</li><li>传输的数据是有边界的</li><li>限制每次传输的数据大小</li></ul><h3 id="第三个参数…"><a href="#第三个参数…" class="headerlink" title="第三个参数…"></a>第三个参数…</h3><p>​        我们还会需要第三个参数，为什么呢？</p><blockquote><p>遇到了同一协议族下多个数据传输方式相同的协议</p></blockquote><p>​        这个时候，第三个参数就可以用来指定特定的一个——不过大可以放心，一般用不到，我们会置成0</p><p>​        我们使用TCP来做个例子</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;SC.h&quot;int main(int argc, char* argv[])&#123;    int sock;    Sockaddr_in serv_addr;    char message[30];    int str_len &#x3D; 0;    int idx &#x3D; 0, read_len &#x3D; 0;    showHelp(3,argc,&quot;Usage: argv[0] &lt;IP&gt; &lt;port&gt;\n&quot;);    sock &#x3D; socket(PF_INET,SOCK_STREAM,0);    if(sock &#x3D;&#x3D; -1)&#123;        showError(&quot;socket() Error&quot;);    &#125;    ZeroMem(&amp;serv_addr);    serv_addr.sin_family &#x3D; AF_INET;    serv_addr.sin_addr.s_addr &#x3D; inet_addr(argv[1]);    serv_addr.sin_port &#x3D; htons(atoi(argv[2]));    if(connect(sock, (Sockaddr*)&amp;serv_addr,sizeof(serv_addr)) &#x3D;&#x3D; -1)&#123;    printf(&quot;%d\n&quot;,errno);        showError(&quot;connect() Error&quot;);    &#125;    &#x2F;&#x2F; MODIFY THIS BLOCK TO THIS in client.c    while(read_len &#x3D; read(sock, &amp;message[idx++],1))&#123;        if(read_len &#x3D;&#x3D; -1)&#123;            showError(&quot;read() Error&quot;);        &#125;        str_len +&#x3D; read_len;    &#125;      printf(&quot;Message from server:&gt; %s\n&quot;,message);    printf(&quot;Function read call count: %d\n&quot;,str_len);    close(sock);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        只需要调整一下</p><h1 id="地址组与数据序列"><a href="#地址组与数据序列" class="headerlink" title="地址组与数据序列"></a>地址组与数据序列</h1><h2 id="分配给套接字的IP和端口"><a href="#分配给套接字的IP和端口" class="headerlink" title="分配给套接字的IP和端口"></a>分配给套接字的IP和端口</h2><p>​        IP地址现在分两类：</p><div class="table-container"><table><thead><tr><th>IP地址种类</th><th>说明</th></tr></thead><tbody><tr><td>IPv4</td><td>4字节地址序列</td></tr><tr><td>IPv6</td><td>16字节地址序列</td></tr></tbody></table></div><p>只需通过IP地址的第一个字节可判断网络地址占用的字节数，因为我们根据IP地址的边界区分网络地址：</p><blockquote><p>A类地址的首字节范围：0-127<br>B类地址的首字节范围：128-191<br>C类地址的首字节范围：192-223</p></blockquote><p>还有以下表述方式：</p><blockquote><p>A类地址的首位以0开始<br>B类地址的前2位以10开始<br>C类地址的前3位以110开始</p></blockquote><p>​        简单的说:IPv4地址是由两个部分构成的</p><p>​        网络号码字段（Net-id）：IP 地址的网络号码字段用来标识一个网络，网络号码字段的前几位用来区分 IP 地址的类型。</p><p>​        主机号码字段（Host-id）：主机号码字段用来区分一个网络内的不同主机。对于网络号相同的设备，无论实际所处的物理位置如何，它们都是处在同一个网络中。</p><pre><code>   IP用于区分计算机，只要有IP地址就能向目标主机传输数据，但仅凭这些无法传输给最终的应用程序。如网上看视频的同时网上聊天，这时至少需要1个接收视频数据的套接字和一个接收聊天信息的套接字。如何区分这些套接字呢？   计算机中一般有网络接口卡数据传输设备，通过NIC向计算机内部传输数据时会用到IP。操作系统负责把传递到内部的数据适当分配给套接字，这时就要利用端口号。通过NIC接收的数据内有端口号，操作系统正是参考此端口号把数据传输给相应端口的套接字。   端口号就是在同一操作系统内为区分不同套接字而设置的，因此无法将1个端口号分配给不同的套接字。端口号由16位构成，可分配的端口号范围是0-65535。但0-1023是知名端口，一般分配给特定应用程序。虽然端口号不能重复，但TCP套接字和UDP套接字不会共用端口号，所以允许重复。例如：如果某TCP套接字使用9190号端口，则其他TCP套接字就无法使用该端口号，但UDP套接字可以使用。   数据传输目标地址同时包含IP地址和端口号。</code></pre><h2 id="地址信息表示"><a href="#地址信息表示" class="headerlink" title="地址信息表示"></a>地址信息表示</h2><p>​        好,当你看完上面的一节了,我们就可以产生如下的对话</p><blockquote><p>用啥地址组？</p><p>IPv4的</p><p>IP地址呢</p><p>114.5.1.4</p><p>端口号？</p><p>1919</p></blockquote><p>​        于是，直接用一个结构体，回答上面的所有问题</p><pre class="line-numbers language-none"><code class="language-none">struct sockaddr_in  &#123;    __SOCKADDR_COMMON (sin_);&#x2F;&#x2F; 本质上是 sa_family_t sin_family    in_port_t sin_port;&#x2F;* Port number.  *&#x2F;    struct in_addr sin_addr;&#x2F;* Internet address.  *&#x2F;    &#x2F;* Pad to size of &#96;struct sockaddr&#39;.  *&#x2F;    unsigned char sin_zero[sizeof (struct sockaddr)   - __SOCKADDR_COMMON_SIZE   - sizeof (in_port_t)   - sizeof (struct in_addr)];  &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        哦对了，这个</p><pre class="line-numbers language-none"><code class="language-none">struct in_addr sin_addr;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        是对IP地址的封装，其实他是</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;* Internet address.  *&#x2F;typedef uint32_t in_addr_t;struct in_addr  &#123;    in_addr_t s_addr;  &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>TIPS: 在Linux（倒不如说是POSIX）下，系统定义的数据类型会在后面加上一个_t表示系统定义的</p></blockquote><h3 id="sin-family"><a href="#sin-family" class="headerlink" title="sin_family"></a>sin_family</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;* Address families.  *&#x2F;#define AF_UNSPECPF_UNSPEC#define AF_LOCALPF_LOCAL#define AF_UNIXPF_UNIX#define AF_FILEPF_FILE#define AF_INETPF_INET#define AF_AX25PF_AX25#define AF_IPXPF_IPX#define AF_APPLETALKPF_APPLETALK#define AF_NETROMPF_NETROM#define AF_BRIDGEPF_BRIDGE#define AF_ATMPVCPF_ATMPVC#define AF_X25PF_X25#define AF_INET6PF_INET6#define AF_ROSEPF_ROSE#define AF_DECnetPF_DECnet#define AF_NETBEUIPF_NETBEUI#define AF_SECURITYPF_SECURITY#define AF_KEYPF_KEY#define AF_NETLINKPF_NETLINK#define AF_ROUTEPF_ROUTE#define AF_PACKETPF_PACKET#define AF_ASHPF_ASH#define AF_ECONETPF_ECONET#define AF_ATMSVCPF_ATMSVC#define AF_RDSPF_RDS#define AF_SNAPF_SNA#define AF_IRDAPF_IRDA#define AF_PPPOXPF_PPPOX#define AF_WANPIPEPF_WANPIPE#define AF_LLCPF_LLC#define AF_IBPF_IB#define AF_MPLSPF_MPLS#define AF_CANPF_CAN#define AF_TIPCPF_TIPC#define AF_BLUETOOTHPF_BLUETOOTH#define AF_IUCVPF_IUCV#define AF_RXRPCPF_RXRPC#define AF_ISDNPF_ISDN#define AF_PHONETPF_PHONET#define AF_IEEE802154PF_IEEE802154#define AF_CAIFPF_CAIF#define AF_ALGPF_ALG#define AF_NFCPF_NFC#define AF_VSOCKPF_VSOCK#define AF_KCMPF_KCM#define AF_QIPCRTRPF_QIPCRTR#define AF_SMCPF_SMC#define AF_XDPPF_XDP#define AF_MAXPF_MAX<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是在Linux下定义的，当然，我们常常使用的：就是下面三个</p><div class="table-container"><table><thead><tr><th>地址组<code>(Address Family) AF</code></th><th>含义</th></tr></thead><tbody><tr><td><code>AF_INET</code></td><td>IPv4地址组</td></tr><tr><td><code>AF_INET6</code></td><td>IPv6地址组</td></tr><tr><td><code>AF_LOCAL</code></td><td>本地通信采用的UNIX协议地址组</td></tr></tbody></table></div><h3 id="sin-port"><a href="#sin-port" class="headerlink" title="sin_port"></a>sin_port</h3><p>​        保存16位端口</p><h3 id="sin-addr"><a href="#sin-addr" class="headerlink" title="sin_addr"></a>sin_addr</h3><p>​        保存32位IP地址信息</p><h3 id="sin-zero"><a href="#sin-zero" class="headerlink" title="sin_zero"></a>sin_zero</h3><p>​        为了跟sockaddr结构体保持一致，必须填充0</p><h2 id="网络字节序和地址变换"><a href="#网络字节序和地址变换" class="headerlink" title="网络字节序和地址变换"></a>网络字节序和地址变换</h2><p>​        CPU向内存保存数据的方式有两种：</p><ul><li>大端序：高位字节放到低位去</li><li>小端序：低位字节放到高位去</li></ul><p><img src="image-20230823093636718.png" alt="image-20230823093636718"></p><p>​        那么，我们就必须考虑传输数据的时候双方存储方式不一致的问题（解析数据可能会出错），解决的办法也是出乎意料的简单——规定传输的是大端序。</p><p>​        我们无论如何，都会把数据处理成大端序格式存储的，在进行传输——很简单吧（喜）</p><ul><li><p>uint32_t htonl(uint32_t hostlong);</p></li><li><p>uint16_t htons(uint16_t hostshort);</p></li><li><p>uint32_t ntohl(uint32_t netlong);</p></li><li><p>uint16_t ntohs(uint16_t netshort);</p></li></ul><p>​        h表示host，指小端，n表示network指大端，l表示32位长整数，s表示16位短整数。<br>​        举个例子：ntohs的意思就是吧short字节（s）从网络字节序（n）转换成主机字节序（h）</p><p>​        来个实操</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;arpa&#x2F;inet.h&gt;int main(int argc, char* argv[])&#123;    unsigned short host_port &#x3D; 0x1234;    unsigned short net_port;    unsigned long host_addr &#x3D; 0x12345678;    unsigned long net_addr;    net_port &#x3D; htons(host_port);    net_addr &#x3D; htonl(host_addr);    printf(&quot;Host ordered port:&gt; %#x\n&quot;, host_port);    printf(&quot;Network ordered port: %#x\n&quot;, net_port);    printf(&quot;Host ordered address:&gt; %#lx\n&quot;, host_addr);    printf(&quot;Network ordered address: %#lx\n&quot;, net_addr);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230823094810009.png" alt="image-20230823094810009"></p><h2 id="网络地址的初始化与分配"><a href="#网络地址的初始化与分配" class="headerlink" title="网络地址的初始化与分配"></a>网络地址的初始化与分配</h2><p>​        我们这里介绍一些接口，可以讲字符串格式的IP地址转化成整数类型的。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;arpa&#x2F;inet.h&gt;in_addr_t inet_addr(const char* string);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        这个函数转化成功就会返回转化成功后的数字，否则返回<code>INADDR_NONE</code></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;arpa&#x2F;inet.h&gt;#include &quot;SC.h&quot;int main(int argc, char* argv[])&#123;    showHelp(argc,2,&quot;USAGE: .&#x2F;file IP&quot;);    unsigned long conv_addr &#x3D; inet_addr(argv[1]);    if(conv_addr &#x3D;&#x3D; INADDR_NONE)&#123;        showError(&quot;Can not transform, IP address might be invalid anyhow!&quot;);    &#125;    else&#123;        printf(&quot;From string type:&gt; %s To network ordered integer addr: %#lx \n&quot;,argv[1],conv_addr);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230823095718064.png" alt="image-20230823095718064"></p><p>​        当然，我们更加经常使用的是inet_aton，这是因为我们常常会使用sockaddr_in这个结构体，这个函数会自动的吧结果填入到结构体当中！简单而不复杂</p><p>​        当然也可以倒过来</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;arpa&#x2F;inet.h&gt;char* inet_ntoa(struct in_addr adr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &quot;SC.h&quot;int main()&#123;    Sockaddr_in addr1, addr2;    char* pStr;    char str[20];    addr1.sin_addr.s_addr &#x3D; htonl(0x1020304);    addr2.sin_addr.s_addr &#x3D; htonl(0x1010101);    pStr &#x3D; inet_ntoa(addr1.sin_addr);    strcpy(str,pStr);    printf(&quot;Dotted-Demical notation1:&gt;%s\n&quot;,pStr);    inet_ntoa(addr2.sin_addr);    printf(&quot;Dotted-Demical notation2:&gt;%s\n&quot;,pStr);    printf(&quot;Dotted-Demical notation3:&gt;%s\n&quot;,str);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230823101239747.png" alt="image-20230823101239747"></p><h2 id="网络地址初始化"><a href="#网络地址初始化" class="headerlink" title="网络地址初始化"></a>网络地址初始化</h2><p>结合前面的内容，介绍套接字创建过程中，常见的网络信息初始化方法：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> addr<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>serv_ip <span class="token operator">=</span> <span class="token string">"211.217,168.13"</span><span class="token punctuation">;</span>          <span class="token comment">//声明IP地址族</span><span class="token keyword">char</span> <span class="token operator">*</span>serv_port <span class="token operator">=</span> <span class="token string">"9190"</span><span class="token punctuation">;</span>                  <span class="token comment">//声明端口号字符串</span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//结构体变量 addr 的所有成员初始化为0</span>addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>                 <span class="token comment">//制定地址族</span>addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>serv_ip<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//基于字符串的IP地址初始化</span>addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>serv_port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//基于字符串的IP地址端口号初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="INADDR-ANY"><a href="#INADDR-ANY" class="headerlink" title="INADDR_ANY"></a>INADDR_ANY</h3><p>每次创建服务器端套接字都要输入IP地址会有些繁琐，此时可如下初始化地址信息：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> addr<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span> serv_port <span class="token operator">=</span> <span class="token string">"9190"</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>add<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span><span class="token function">atoi</span><span class="token punctuation">(</span>serv_port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>与之前方式的区别</strong></p><blockquote><p>与之前方式最大的区别在于，利用常数INADDR_ANY分配服务器端的IP地址。<br>——若采用这种方式，则可自动获取运行服务器端的计算机IP地址，不必亲自输入。<br>——而且，若同一计算机中已分配多个IP地址(多宿主(Multi-homed)计算机，一般路由器属于这一类)，则只要端口号一致，就可以从不同IP地址接收数据。<br>因此，服务器端中优先考虑这种方式。而客户端中除非带有一部分服务器端功能，否则不会采用。</p></blockquote><p><strong>创建服务器端套接字时需要IP地址的原因</strong></p><blockquote><p><strong>问题：</strong> 初始化服务器端套接字时应分配所属计算机的IP地址，因为初始化时使用的IP地址非常明确，那为何还要进行IP初始化呢？<br><strong>答案：</strong> 同一计算机中可以分配多个IP地址，实际IP地址的个数与计算机中安装的NIC的数量相等。即使是服务器端套接字，也需要决定应接收哪个IP地址传来的(哪个NIC传来的)数据。因此，服务器端套接字初始化过程中要求IP地址信息。另外，若只有一个NIC，则直接使用INADDR_ANY。</p></blockquote><h2 id="Windows实现-1"><a href="#Windows实现-1" class="headerlink" title="Windows实现"></a>Windows实现</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;void ErrorHandling(char *message);int main(int agrc, char* agrv[])&#123;WSADATA wsaData;unsigned short host_port &#x3D; 0x1234;unsigned short net_port;unsigned long host_addr &#x3D; 0x12345678;unsigned long net_addr;if(WSAStartup(MAKEWORD(2,2),&amp;wsaData) !&#x3D; 0)ErrorHandling(&quot;WSAStartup() error!&quot;);net_port &#x3D; htons(host_port);net_addr &#x3D; htonl(host_addr);printf(&quot;Host ordered port: %#x \n&quot;, host_port);printf(&quot;Network ordered port: %#x \n&quot;, net_port);printf(&quot;Host ordered address: %#lx \n&quot;, host_addr);printf(&quot;Network ordered address: %#lx \n&quot;, net_addr);WSACleanup();return 0;&#125;void ErrorHandling(char *message)&#123;fputs(message, stderr);fputc(&#39;\n&#39;, stderr);exit(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#define _WINSOCK_DEPRECATED_NO_WARNINGS 1#define _CRT_SECURE_NO_WARNINGS 1#include&lt;stdio.h&gt;#include&lt;winsock2.h&gt;int main(int argc, char* argv[])&#123;WSADATA wsaData;if(WSAStartup(MAKEWORD(2,2),&amp;wsaData)!&#x3D;0)&#123;printf(&quot;WSAStartup failed\n&quot;);return 1;&#125;&#123;char* addr &#x3D; &quot;127.212.124.78&quot;;unsigned long conv_addr &#x3D; inet_addr(addr);if(conv_addr &#x3D;&#x3D; INADDR_NONE)printf(&quot;Error occured! \n&quot;);elseprintf(&quot;Network ordered integer addr: %#lx \n&quot;,conv_addr);&#125;&#123;struct sockaddr_in addr;char* strPtr;char strArr[20];addr.sin_addr.s_addr &#x3D; htonl(0x1020304);strPtr &#x3D; inet_ntoa(addr.sin_addr);strcpy(strArr,strPtr);printf(&quot;Dotted-Decimal notation3 %s \n&quot;,strArr);&#125;WSACleanup();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Windows 32API </tag>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective Modern C++ 1: auto And template</title>
      <link href="/2023/08/22/Effective-Modern-C-1-auto-And-template/"/>
      <url>/2023/08/22/Effective-Modern-C-1-auto-And-template/</url>
      
        <content type="html"><![CDATA[<h1 id="Effective-Modern-C"><a href="#Effective-Modern-C" class="headerlink" title="Effective Modern C++"></a><code>Effective Modern C++</code></h1><h2 id="理解模板类别推导"><a href="#理解模板类别推导" class="headerlink" title="理解模板类别推导"></a>理解模板类别推导</h2><p>​        一个良好风格程序，是可以让客户程序员对其原理一无所知但是却用的相当的satisfied的！</p><p>​        符合上述陈述的，就是模板类别推导机制。这里有一小段伪代码可以view一下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;void f(ParamType param); &#x2F;&#x2F; ParamType is a compound of T<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        一次调用：</p><pre class="line-numbers language-none"><code class="language-none">f(expr);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在编译期间，我们的编译器通过expr推导两个型别：一个是T，另一个是<code>ParamType</code>,这个<code>ParamType</code>，往往会有一些饰词：举个例子：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;void f(const T&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        调用如下：</p><pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 0;f(x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        不会违背我们常识的——我们马上拿到了T是int,而<em><code>ParamType</code></em>是<code>const T&amp;</code></p><p>​        结合我们的开发经验，可以知道<em><code>ParamType</code></em>有三种：</p><ul><li><code>ParamType</code>具有指针或者是引用型别，但不是一个万能引用</li><li><code>ParamType</code>是一个万能引用</li><li><code>ParamType</code>啥也不是</li></ul><h3 id="Case-1-ParamType具有指针或者是引用型别，但不是一个万能引用"><a href="#Case-1-ParamType具有指针或者是引用型别，但不是一个万能引用" class="headerlink" title="Case 1:ParamType具有指针或者是引用型别，但不是一个万能引用"></a><code>Case 1</code>:<code>ParamType</code>具有指针或者是引用型别，但不是一个万能引用</h3><p>​        这是最简单的！运作的步骤就是如下：</p><ol><li>若expr具有引用型别，先忽略引用</li><li>而后，对expr的型别和<code>ParamType</code>的型别进行模式匹配后，来决定T的型别</li></ol><p>举个例子</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;void f(T&amp; param);int x &#x3D; 27;&#x2F;&#x2F; x is intconst int cx &#x3D; x;&#x2F;&#x2F; cx is const intconst int&amp; rx &#x3D; x;&#x2F;&#x2F; rx is consy int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">f(x);&#x2F;&#x2F; T is int, param is int&amp;f(cx);&#x2F;&#x2F; T is const int, param is const int&amp;f(rx);&#x2F;&#x2F; T is const int, param is const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        这个时候，请注意——const关键字在类型模板推到中还是被带上了const。这就说明了模板推导是安全的。</p><p>​        当然，那如果是</p><pre class="line-numbers language-none"><code class="language-none">void f(const T&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        于是，我们没有必要繁琐的多次添加const，也就是说：</p><pre class="line-numbers language-none"><code class="language-none">f(x);&#x2F;&#x2F; T is int, param is int&amp;f(cx);&#x2F;&#x2F; T is int, param is const int&amp;f(rx);&#x2F;&#x2F; T is int, param is const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        没有必要再让T带上const修饰符了——这里的参数总会具有恒定修饰符。</p><p>​        当然，对于指针</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void f(T* param);int x &#x3D; 27;const int cx &#x3D; x;const int* px &#x3D; &amp;x;f(&amp;x);&#x2F;&#x2F; T is int, param is int*f(px);&#x2F;&#x2F; T is const int param is const int*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="case-2-param是一个万能引用"><a href="#case-2-param是一个万能引用" class="headerlink" title="case 2: param是一个万能引用"></a><code>case 2: param</code>是一个万能引用</h2><p>​        先简单谈谈什么是万能引用</p><p>C++11除了带来了右值引用以外，还引入了一种称为“万能引用”的语法；通过“万能引用”，对某型别的引用T&amp;&amp;，既可以表达右值引用，也可以表达左值引用。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>该语法有两种使用场景，最常见的一种是作为函数模板的形参：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;typename T>void f(T&amp;&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中param就是一个万能引用。<br>第二个场景则是auto声明：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">auto&amp;&amp; var2 = var1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这两种情况都涉及到了型别的推导，也就是说，如果你虽然遇到了T&amp;&amp;的形式，但是不涉及型别推导，那么它只是一个右值引用：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">void f(Widget&amp;&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同时，想要成为万能引用，变量声明的形式也必须正确无误，必须正好是形如“T&amp;&amp;”才行。比如下面这些情况就不是万能引用：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;typename T>void f1(std::vector&lt;T>&amp;&amp; param); // param是一个右值引用template&lt;typename T>void f2(const T&amp;&amp; param);      //param也是一个右值引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你向f1和f2传左值，会都是会直接报错的。<br>除此之外，像下面这种情况也不是万能引用：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;class T, class Allocator=allocator&lt;T>>class vector&#123;public:  void push_back(T&amp;&amp; x);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>push_back的形参x的型别T是受vector影响的，假设给定T为Widget，那么就会被实例化为如下代码：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;class Widget, class Allocator=allocator&lt;T>>class vector&#123;public:  void push_back(Widget&amp;&amp; x);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而作为对比，vector类中的emplace_back函数则是一个实实在在的万能引用：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;class T, class Allocator=allocator&lt;T>>class vector&#123;public:  template&lt;class...Args>  void emplace_back(Args&amp;&amp;.. args);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>args的型别Args完全独立于vector的型别形参T，Args必须在每次调用emplace_back时被推导，因此args是万能引用。</p><h2 id="为什么是“万能引用”？"><a href="#为什么是“万能引用”？" class="headerlink" title="为什么是“万能引用”？"></a>为什么是“万能引用”？</h2><p>你一定非常好奇，为什么这种形态被称作“万能引用”。原因正像前文所说的，通过“万能引用”，对某型别的引用T&amp;&amp;，既可以表达右值引用，也可以表达左值引用。<br>比如说，传入一个右值引用，一般都要给传入的参数加一个std::move操作确保变量的可移动性：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">class Widget&#123;public:  Widget(Widget&amp;&amp; rhs):name(std::move(rhs.name))&#123;&#125;private:  std::string name;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而万能引用则有所不同，它一般是通过std::forward来进行转换：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">class Widget&#123;public:  template&lt;typename T>  void setName(T&amp;&amp; newName)  &#123;name = std::forward&lt;T>(newName);&#125;private:  std::string name;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下，若newName是一个左值引用，则forward函数不会对它进行操作，它的返回值仍然是一个左值引用；若newName是一个右值，则会进行std::move的转换。用户使用时无需区分，这也正是它“万能”之处。<br>举个例子：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Widget w;std::string c = "123";w.setName(w);            //传入是一个左值，forward返回左值引用w.setName("123");        //传入是一个右值，forward返回右值引用w.setName(std::move(w)); //传入是一个右值，forward返回右值引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>​        你一定会很奇怪，为什么万能引用的形式明明是T&amp;&amp;，却既可以代表左值又可以代表右值。这就要涉及到C++的引用折叠语法了。<br>​        首先，C++不支持“引用的引用”这种概念，这样的代码在C++中是非法的：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">int x;auto&amp; &amp; rx = x;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        但是，假设我们向前面的万能引用函数f传入一个左值引用：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Widget w = w;f(w);  //T的推导型别为Widget&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        那么实例化的结果如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">void f(Widget&amp; &amp;&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        之所以这样的代码能通过，是因为在特殊的情况下（比如模板实例化），C++应用了引用折叠的语法。<br>​        有左值和右值两种引用，所以就有四种可能的组合：左值-左值、左值-右值、右值-左值、右值-右值，如果引用的引用出现在允许的语境，改双重引用会被折叠成单个引用：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">如果任一引用为左值引用，则结果为左值引用。否则（即两个都为右值引用），结果为右值引用。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因此上述例子中，最终将param推导为左值引用。<br>​        此外，auto的型别推导也会应用引用折叠的场景，例如：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Widget w;auto &amp;&amp;w1 =w;  //w1是个左值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>话说到这里，我们就可以更深入地理解万能引用，其实它就是满足了下面两个条件的语境中的右值引用：</p><ul><li>1.型别推导的过程会区别左值和右值。T型别的左值推导结果为T&amp;，而T型别的右值推导结果为T。</li><li>2.会发生引用折叠。</li></ul><p>好了，再给出大纲：</p><ul><li>如果expr 时一个左值，那么 T 和 paramType都会被推导为左值引用，这个结果仔细思考很有趣：在模板型别推到中，T被认为是引用的唯一情形。其次，尽管在声明的时候使用的是右值引用语法，它的型别推导是左值引用！</li><li>expr是右值，那就是常规的，没有什么区别了。</li></ul><h3 id="case-3-param既不是指针又不是引用"><a href="#case-3-param既不是指针又不是引用" class="headerlink" title="case 3: param既不是指针又不是引用"></a><code>case 3: param</code>既不是指针又不是引用</h3><p>​        那就是剩下值传递了</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;void f(T param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这意味：传入啥都会是副本，于是我们的param就是一个副本。也就是说：</p><pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 27;const int cx &#x3D; x;const int&amp; rx &#x3D; x;f(x);  &#x2F;&#x2F; T 和 param 都是intf(cx); &#x2F;&#x2F; T 和 param 都是intf(rx); &#x2F;&#x2F; T 和 param 都是int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不过，有一个很有趣的情况</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;void f(T param);const char* const ptr &#x3D; &quot;Fun wth pointers&quot;;f(ptr); &#x2F;&#x2F; const char* const的实参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个时候，传景区的param类型就会被推到为const char*，原因很简单，我们必须拷贝这个字符串，这就意味着不可能对原本的字符串进行更改（仍然保留了这一原则！），仍然遵循着自身的const或者volitaile属性会被忽略的问题。</p><h3 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h3><p>​        我们下面考虑的是数组实参的问题</p><pre class="line-numbers language-none"><code class="language-none">const char name[] &#x3D; &quot;J,P,Briggs&quot;;const char* ptrToName &#x3D; name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这里的ptrToName就是通过name来初始化的。后者的类型是const char[13]，前者是const char*。我们说：这里就发生了数组的退化。</p><p>​        现在，当我们把之传递给模板又如何呢？</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void f(T param);f(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我们知道，这样的传递相当的合法：</p><pre class="line-numbers language-none"><code class="language-none">void myFunc(int param[]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        同样的，我们可以按照指针的方式加以处理——等价的！</p><pre class="line-numbers language-none"><code class="language-none">void myFunc(int* param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        所以，对于值传递——param就会变成<code>const char*</code></p><p>​        那么，有没有办法传递一个真正的数组呢？答案是传递引用</p><pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;void f(T&amp; param);f(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        T在此时此刻就会变成<code>const char [13]</code>，也就是说，param这个时候是:<code>const char (&amp;) [13]</code></p><p>​        嗯，试一下：</p><p><img src="image-20230822101943592.png" alt="image-20230822101943592"></p><p>​        没有任何意外，答案是5.</p><h2 id="理解auto型别推导"><a href="#理解auto型别推导" class="headerlink" title="理解auto型别推导"></a>理解auto型别推导</h2><p>​        有人调侃，未来的C++将会是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include autoauto main()&#123;    auto;    return auto;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这确实形象的表达了auto的功能——但是没有如此的夸张。他会让你想起来模板类型推导——没有反转，原理完全一致，我甚至不打算在这里重复一遍了。但是，唯独有一个区别…</p><p>​        C++11中，引入了一个叫做统一初始化列表的东西，它的语法是这样的</p><pre class="line-numbers language-none"><code class="language-none">int x &#x3D; &#123;27&#125;;int y&#123;27&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        都被允许了！</p><pre class="line-numbers language-none"><code class="language-none">auto x1 &#x3D; 27;auto x2(27); &#x2F;&#x2F; x1 and x2 is 27auto x3 &#x3D; &#123;27&#125;; &#x2F;&#x2F; initialize_list&lt;int&gt;auto x4&#123;27&#125;; &#x2F;&#x2F; 存疑，貌似有更改，不再是initialize_list&lt;int&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;#define SHOWTYPE(X) std::cout &lt;&lt; #X &lt;&lt; &quot; is &quot; &lt;&lt; typeid(X).name() &lt;&lt; std::endl;void show1()&#123;    auto x1 &#x3D; 27;    SHOWTYPE(x1);    auto x2(27);    auto x3 &#x3D; &#123;27&#125;;    SHOWTYPE(x3);    auto x4&#123;27&#125;;    SHOWTYPE(x4);&#125;template&lt;typename T&gt;void f(T param)&#123;    std::cout &lt;&lt; &quot; In F&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;T is &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;param is &quot; &lt;&lt; typeid(param).name() &lt;&lt; std::endl;&#125;template&lt;typename T&gt;void g(std::initializer_list&lt;T&gt; listParam)&#123;    std::cout &lt;&lt; &quot; In G&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;T is &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;param is &quot; &lt;&lt; typeid(listParam).name() &lt;&lt; std::endl;&#125;int main()&#123;    auto x &#x3D; &#123;1,2,3&#125;;    &#x2F;&#x2F; f(&#123;1,2,3&#125;); &#x2F;&#x2F; can not pass compiling    f(x);    g(&#123;1,2,3&#125;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        尝试一下使用上面的代码编译一下！最终我们得出结论：auto可以识别initialize_list这个类型（推导时假定），但是模板类型推导不会。</p><p>​        C++14中，我们无法使用auto返回initialize_list这个类型：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto ErrorReturn()&#123;return &#123;1,2,3&#125;; &#x2F;&#x2F; Failed!&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>作者：Codemaxi<br>链接：<a href="https://juejin.cn/post/7090673873183571975">https://juejin.cn/post/7090673873183571975</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们都知道，现代的编程语言，不管是动态语言（JavaScript、Python 等），还是静态语言（Go、Rust 等），大都支持自动类型推导（type deduction）。自动类型推导，通俗地讲就是定义一个变量的时候不需要明确指定类型，而是让编译器根据上下文进行推导。 对于C++语言，在 C++11 之前，就只有模板（template）代码就支持编译器自动类型推导。C++11 很重要的一个特性就是加强了编译器自动类型推导的能力，使之不限于模板 —— 与此相关的关键字有两个 <code>auto</code> 和 <code>decltype</code> 。通过这两个关键字不仅能方便地获取复杂的类型，而且还能简化书写，提高编码效率。但是有利也有弊，增加简洁可能就会需要增加学习度，如果不能深入理解类型推断背后的规则与机理，很可能就会出现用法错误。基于我们上一篇文章已经介绍了模板类型推导。本节我们先讲解 auto 关键字，下节再讲解 decltype 关键字。</p><h2 id="auto用法"><a href="#auto用法" class="headerlink" title="auto用法"></a>auto用法</h2><p>通常auto的用法有下列两种：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码auto declaratorinitializer;  &#x2F;&#x2F; 普通变量声明定义auto f &#x3D; [](auto param1, auto param2) &#123;&#125;;  &#x2F;&#x2F; lambda表达式参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>我们来看看 auto 关键字在 C++ 中的使用。 最简单的用法，定义变量的时候不指定类型，通过初始化的值让编译器自动推导。在C++11标准的语法中，auto被定义为自动推断变量的类型。不过C++11的auto关键字时有一个限定条件，那就是必须给申明的变量赋予一个初始值，否则编译器在编译阶段将会报错。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token keyword">auto</span> a<span class="token punctuation">;</span>  <span class="token comment">// 编译error，initializer required</span><span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// b 是 int 类型</span><span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token number">0ull</span><span class="token punctuation">;</span>   <span class="token comment">// c 是 unsigned long long 类型  </span><span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>  <span class="token comment">// d 是 const char* 类型</span><span class="token keyword">auto</span> e <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// e 是 std::string 类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容器类型和迭代器"><a href="#容器类型和迭代器" class="headerlink" title="容器类型和迭代器"></a>容器类型和迭代器</h3><p>auto 和容器类型、迭代器一起配合使用，可以简化代码，代码也更简洁、清晰。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">auto</span> it_begin <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// std::vector&lt;int>::iterator</span><span class="token keyword">auto</span> it_end <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// std::vector&lt;int>::iterator</span><span class="token keyword">auto</span> sz <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// std::vector&lt;int>::size_type</span>std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>list<span class="token operator">&lt;</span>string<span class="token operator">>></span> m<span class="token punctuation">;</span><span class="token keyword">auto</span> i <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// std::map&lt;int,list&lt;string>>::iterator</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="引用和-cv-限定符"><a href="#引用和-cv-限定符" class="headerlink" title="引用和 cv 限定符"></a>引用和 cv 限定符</h3><p>特别要注意，使用 <strong><code>auto</code></strong> 会删除引用、 <strong><code>const</code></strong> 限定符和 <strong><code>volatile</code></strong> 限定符。如果定义的对象<strong>不是指针或者引用</strong>，则const属性会被<strong>丢弃</strong>。 请看下面示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token operator">&amp;</span> countRef <span class="token operator">=</span> count<span class="token punctuation">;</span>    <span class="token keyword">auto</span> myAuto <span class="token operator">=</span> countRef<span class="token punctuation">;</span>    countRef <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>    myAuto <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的程序中，myAuto 是一个int，而不是引用int，因此，如果引用限定符尚未被auto删除，则输出11 11，而不是11 12。如果我们希望推导出的auto类型保留<strong>上层const</strong>或引用，我们需要明确指出。例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码const int i &#x3D; 2;const auto cvAuto &#x3D; i;  &#x2F;&#x2F; save constauto&amp; ri &#x3D; i;  &#x2F;&#x2F; save reference<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><p>如果定义的对象<strong>是指针或者引用</strong>，则const属性被<strong>保留</strong>。 <strong>auto关键字与指针</strong>：设置类型为auto的指针，<strong>初始值的const属性仍然保留</strong>。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;typeinfo&gt; int main() &#123;    int i&#x3D;2;    const int ci&#x3D;i;    auto a&#x3D;&amp;i;  &#x2F;&#x2F; a是整型指针(整数的地址就是指向整数的指针)；    auto b&#x3D;&amp;ci; &#x2F;&#x2F; b是指向整型常量的指针(对const对象取地址是一种底层const)；    std::cout &lt;&lt; typeid(a).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; Pi    std::cout &lt;&lt; typeid(b).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; PKi    &#x2F;&#x2F; 用auto声明指针类型时，用auto和auto *没有任何区别;    auto *ppi&#x3D;&amp;i;    auto pi&#x3D;&amp;i;  &#x2F;&#x2F; 两种方式没有差别；    std::cout &lt;&lt; typeid(ppi).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; Pi    std::cout &lt;&lt; typeid(pi).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; Pi    &#x2F;&#x2F;用auto声明引用类型时则必须加&amp;;    auto &amp;rri&#x3D;i; &#x2F;&#x2F; rri为引用；    auto ri&#x3D;i;  &#x2F;&#x2F; ri为int；    std::cout &lt;&lt; typeid(rri).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i    std::cout &lt;&lt; typeid(ri).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>auto关键字与引用</strong>：在使用auto关键字，使用引用其实是使用引用的对象。特别是当引用被用作初始值时，真正参与初始化的其实是<strong>引用的对象的值</strong>，此时编译器以引用对象的类型作为auto的类型。另外设置类型为auto的引用，<strong>初始值的const属性仍然保留</strong>。例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;typeinfo&gt; int main() &#123;    int x &#x3D; 0, &amp;rx &#x3D; x; &#x2F;&#x2F; rx是引用    auto a1 &#x3D; rx;  &#x2F;&#x2F;使用引用其实是使用引用的对象，                &#x2F;&#x2F;此时auto以引用对象的类型作为auto的类型，                &#x2F;&#x2F;所以auto这里被推断为 int;    auto &amp;a2 &#x3D; rx; &#x2F;&#x2F;此时auto被推断为int类型，a2本身就是int &amp;类型;    const auto &amp;a3 &#x3D; rx; &#x2F;&#x2F;auto被推断为int类型，a3对象本身是const int &amp;类型;                   &#x2F;&#x2F;不能通过a3去修改rx引用的对象值;    std::cout &lt;&lt; typeid(a1).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i    std::cout &lt;&lt; typeid(a2).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i    std::cout &lt;&lt; typeid(a3).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i    int i&#x3D;2;    const int ci&#x3D;i;    auto &amp;a&#x3D;ci;  &#x2F;&#x2F; 此时auto被推断为const int类型，a本身是const int &amp;类型;    &#x2F;&#x2F; auto &amp;b&#x3D;42; &#x2F;&#x2F;错误，不能为非const引用绑定字面值；    const auto &amp;c&#x3D;43; &#x2F;&#x2F;正确，可以为const引用绑定字面值；    std::cout &lt;&lt; typeid(a).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i    std::cout &lt;&lt; typeid(c).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组和函数"><a href="#数组和函数" class="headerlink" title="数组和函数"></a>数组和函数</h3><p>在一些情况下，数组的操作实际上是<strong>指针的操作</strong>。意味着适用数组作为一个auto变量的初始值时，推断得到的类型是<strong>指针</strong>而非数组。例如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;int add(int a,int b)&#123; return a+b; &#125;  &#x2F;&#x2F; 函数声明；int main() &#123;    int ia[]&#x3D;&#123;1,2,3,4,5&#125;;    auto ia2(ia); &#x2F;&#x2F; 此时ia2是整型指针，指向ia的第一个元素，              &#x2F;&#x2F; 相当于auto ia2(&amp;ia[0])；    std::cout &lt;&lt; typeid(ia2).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; Pi    decltype(ia) ia3&#x3D;&#123;0,1,2,3,4&#125;; &#x2F;&#x2F; 此时ia3是一个数组，下一篇我们介绍decltype；    std::cout &lt;&lt; typeid(ia3).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; A5_i    const char arr[] &#x3D; &quot;I Love China&quot;;    auto r1 &#x3D; arr; &#x2F;&#x2F; 如果将数组名赋值给auto变量，那么auto推断的结果是指针类型，               &#x2F;&#x2F; 如果有const属性，则保留，auto推断的结果是const char *；    auto &amp;r2 &#x3D; arr; &#x2F;&#x2F; 如果将数组名赋值给auto &amp;变量，               &#x2F;&#x2F; auto &amp;变量的类型是一个数组引用类型，即为const char (&amp;)[14]；     std::cout &lt;&lt; typeid(r1).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; PKc    std::cout &lt;&lt; typeid(r2).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; A13_c    auto r3 &#x3D; add; &#x2F;&#x2F; r3为函数指针：int(*)(int, int)；    auto &amp;r4 &#x3D; add; &#x2F;&#x2F; r4为函数引用：int(&amp;)(int, int)；    std::cout &lt;&lt; typeid(r3).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; PFiiiE    std::cout &lt;&lt; typeid(r4).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; FiiiE&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>下面的代码示例演示如何使用大括号初始化 <strong><code>auto</code></strong> 变量。 请注意 B 和 C 与 A 与 E 之间的差异。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;int main()&#123;    &#x2F;&#x2F; auto初始化表达式可以采用多种形式：    auto a(1); &#x2F;&#x2F; 直接初始化或构造函数样式的语法，int    auto b&#123; 2 &#125;;  &#x2F;&#x2F; 通用初始化语法，int    auto c &#x3D; 3; &#x2F;&#x2F; 赋值语法，int    auto d &#x3D; &#123; 4 &#125;; &#x2F;&#x2F; 通用赋值语法，是一个列表：std::initializer_list&lt;int&gt;    std::cout &lt;&lt; typeid(a).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i    std::cout &lt;&lt; typeid(b).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i    std::cout &lt;&lt; typeid(c).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i    std::cout &lt;&lt; typeid(d).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; St16initializer_listIiE    auto A &#x3D; &#123; 1, 2 &#125;; &#x2F;&#x2F; std::initializer_list&lt;int&gt;    auto B &#x3D; &#123; 3 &#125;; &#x2F;&#x2F; std::initializer_list&lt;int&gt;    auto C&#123; 4 &#125;; &#x2F;&#x2F; int    std::cout &lt;&lt; typeid(A).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; St16initializer_listIiE    std::cout &lt;&lt; typeid(B).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; St16initializer_listIiE    std::cout &lt;&lt; typeid(C).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; St16initializer_listIiE    &#x2F;&#x2F; error: cannot deduce type for &#39;auto&#39; from initializer list&#39;    auto D &#x3D; &#123; 5, 6.3 &#125;; &#x2F;&#x2F; 不允许两种不同类型    &#x2F;&#x2F; error in a direct-list-initialization context the type for &#39;auto&#39;    &#x2F;&#x2F; can only be deduced from a single initializer expression    auto E&#123; 8, 9 &#125;; &#x2F;&#x2F; 必须要用&#x3D;号&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键字 auto 是声明具有复杂类型的变量的简单方法。 例如，可用于 auto 声明初始化表达式涉及模板、指向函数的指针或指向成员的指针的变量。 还可以用于 auto 向 lambda 表达式声明和初始化变量。 您不能自行声明变量的类型，因为仅编译器知道 lambda 表达式的类型。 这和<code>auto</code>的一种特殊类型推导有关系。当使用一对花括号来初始化一个<code>auto</code>类型的变量的时候，推导的类型是<code>std::intializer_list</code>。如果这种类型无法被推导（比如在花括号中的变量拥有不同的类型），代码会编译错误。</p><h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>以下代码片段声明变量 <code>iter</code> 的类型以及 <code>elem</code> 何时 <strong><code>for</code></strong> 启动范围 <strong><code>for</code></strong> 循环。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码#include <span class="token operator">&lt;</span>vector<span class="token operator">></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">vtDoubleData</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> vtDoubleData<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> vtDoubleData<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// prefer range-for loops with the following information in mind</span>    <span class="token comment">// (this applies to any range-for with auto, not just vector, deque, array...)</span>    <span class="token comment">// COPIES elements, not much better than the previous examples</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> vtDoubleData<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// observes and/or modifies elements IN-PLACE</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> elem <span class="token operator">:</span> vtDoubleData<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>    <span class="token comment">// observes elements IN-PLACE</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> elem <span class="token operator">:</span> vtDoubleData<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下代码片段使用 new 运算符和指针声明来声明指针：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">12.34</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> <span class="token operator">*</span><span class="token operator">*</span>z <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// d</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// Pd</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// PPd</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> v1 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> v2 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> x <span class="token operator">=</span> v1 <span class="token operator">></span> v2 <span class="token operator">?</span> v1 <span class="token operator">:</span> v2<span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// i</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="auto推导规则"><a href="#auto推导规则" class="headerlink" title="auto推导规则"></a>auto推导规则</h2><p>首先，结论是auto使用的是模板实参推断（Template Argument Deduction）的机制，也就是我们上一篇文章介绍的。auto被一个虚构的模板类型参数T替代，然后进行推断，即相当于把变量设为一个函数参数，将其传递给模板并推断为实参，auto相当于利用了其中进行的实参推断，承担了模板参数T的作用。比如：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码template&lt;typename Container&gt;void useContainer(const Container&amp; container) &#123;    auto pos &#x3D; container.begin();  &#x2F;&#x2F; 1    while (pos !&#x3D; container.end()) &#123;        auto&amp; element &#x3D; *pos++;  &#x2F;&#x2F; 2        &#x2F;&#x2F; ... 对元素进行操作    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面第一个auto的初始化相当于下面这个模板传参时的情形，T就是为auto推断的类型：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token comment">// 模板声明定义</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">deducePos</span><span class="token punctuation">(</span>T pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// auto pos = container.begin()中auto的推导等价于下列语句推导</span><span class="token function">deducePos</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而auto类型变量不会是引用类型（int&amp;， float&amp;等），所以要用<code>auto&amp;</code>，第二个auto推断对应于下面这个模板传参时的情形，同样T就是为auto推断的类型:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码template&lt;typename T&gt;void deduceElement(T&amp; element);deduceElement(*pos++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们上一篇文章把模板类型推导划分成三部分，基于在通用的函数模板的<code>ParamType</code>的特性和<code>param</code>的类型声明。在一个用<code>auto</code>声明的变量上，类型声明代替了<code>ParamType</code>的作用，所以也有三种情况：</p><ul><li>情况1：类型声明是一个指针或者是一个引用，但不是一个通用的引用</li><li>情况2：类型声明是一个通用引用</li><li>情况3：类型声明既不是一个指针也不是一个引用</li></ul><p>上面我们已经看了情况1和情况3的例子，如下类似：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>        <span class="token comment">// 情况3（x既不是指针也不是引用）</span><span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token comment">// 情况3（cx二者都不是）</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 情况1（rx是一个非通用的引用）</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">*</span> rx <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>  <span class="token comment">// 情况1（rx是一个非通用的指针）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>情况2正如你期待的那样：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref1 <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token comment">// x是int并且是左值，所以uref1的类型是int&amp;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref2 <span class="token operator">=</span> cx<span class="token punctuation">;</span>  <span class="token comment">//cx是int并且是左值，所以uref2的类型是const int&amp;</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref3 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>  <span class="token comment">// 27是int并且是右值，所以uref3的类型是int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然我们上一篇文章还介绍了数组以及函数这两种情形，这两种情形对于auto这里也是适用的，上面我们已经把这两种情形的用法介绍了，这里就不详细介绍它的推导了。</p><p>但是，唯一例外的是对初始化列表的推断，auto会将其视为<code>std::initializer_list</code>，而模板则不能对其推断</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;template&lt;typename T&gt;void deduceX(T x) &#123;&#125;int main()&#123;    auto x &#x3D; &#123; 1, 2 &#125;;  &#x2F;&#x2F; 不允许对auto用initializer_list直接初始化，必须用&#x3D;    &#x2F;&#x2F; auto x1 &#123; 1, 2 &#125;; &#x2F;&#x2F; 错误    &#x2F;&#x2F; 保留了单元素列表的直接初始化，但不会将其视为initializer_list，x2是int       auto x2 &#123; 1 &#125;;    std::cout &lt;&lt; typeid(x).name();  &#x2F;&#x2F; class std::initializer_list&lt;int&gt;    std::cout &lt;&lt; typeid(x2).name();  &#x2F;&#x2F; C++14中为int    deduceX(&#123; 1, 2 &#125;); &#x2F;&#x2F; 错误：不能推断T&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，如果你明确模板的<code>param</code>的类型是一个不知道<code>T</code>类型的<code>std::initializer_list&lt;T&gt;</code>：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;template&lt;typename T&gt;void deduceX(std::initializer_list&lt;T&gt; initList) &#123;&#125;int main()&#123;    &#x2F;&#x2F; void deduceX&lt;int&gt;(std::initializer_list&lt;int&gt;)    deduceX(&#123; 1, 2 &#125;); &#x2F;&#x2F; 正确：T是int&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以<code>auto</code>和模板类型推导的本质区别就是<code>auto</code>假设花括号初始化代表的是std::initializer_list，但是模板类型推导却不是。</p><p>你们可能对为什么<code>auto</code>类型推导有一个对花括号初始化有一个特殊的规则而模板的类型推导却没有感兴趣。可惜我也没找到答案。这可能就是规则吧，这就意味着你必须记住如果使用<code>auto</code>声明一个变量并且使用花括号来初始化它，类型推导的就是<code>std::initializer_list</code>。在C++11编程里面的一个经典的错误就是误被声明成<code>std::initializer_list</code>，而其实你是想声明另外的一种类型。这个陷阱使得一些开发者仅仅在必要的时候才会在初始化数值周围加上花括号。</p><p>C++14还允许auto作为返回类型，但此时auto仍然使用的是模板实参推断的机制，因此返回类型为auto的函数如果返回一个初始化列表，则会出错：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码auto newInitList() &#123; return &#123; 1,2 &#125;; &#125; &#x2F;&#x2F; 错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在C++14的lambda里面，当<code>auto</code>用在参数类型声明的时候也是如此：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码std::vector&lt;int&gt; v;auto resetV &#x3D; [&amp;v](const auto&amp; newValue) &#123; v &#x3D; newValue; &#125; &#x2F;&#x2F; C++14resetV(&#123; 1, 2, 3 &#125;);   &#x2F;&#x2F; 编译错误，不能推导出&#123; 1, 2, 3 &#125;的类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="什么时候用-auto"><a href="#什么时候用-auto" class="headerlink" title="什么时候用 auto"></a>什么时候用 auto</h2><p>适用的场景：</p><ul><li>一些类型长度书写很长的，可以用 auto 来简化。例如：</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token keyword">for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果使用auto可以直接写为 :</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>当函数返回的值不确定时，可以用auto作为返回值类型，更加方便。编译器会根据返回值的类型推断 auto 的类型，这种语法是在 C++14 才出现的。例如：</li></ul><pre class="line-numbers language-arduino" data-language="arduino"><code class="language-arduino">arduino复制代码auto <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不适用的场景：</p><ul><li>函数形参不能是auto类型，比如:</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">,</span> <span class="token keyword">auto</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//是不允许的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>类的非static成员变量不可以是auto类型。类的static成员变量可以是auto类型的，但需要用const修饰，而且该变量需要类内初始化。例如：</li></ul><pre class="line-numbers language-arduino" data-language="arduino"><code class="language-arduino">arduino复制代码class <span class="token punctuation">&#123;</span>auto x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// error</span>auto static const i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>auto 不能直接用来声明数组。</li><li>实例化模板时不能使用auto作为模板参数。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在C++11新标准中引进了auto类型说明符，使用它能够让编译器代替我们去分析<strong>表达式所属的类型</strong>。auto 自动类型推断发生在<strong>编译期</strong>，所以使用 auto 关键字不会降低程序的运行效率。</p><p>但是要注意，虽然auto 是一个很强大的工具，但任何工具都有它的两面性，不加选择地随意使用 auto，会带来代码可读性和维护性的严重下降。因此，在使用 auto 的时候，一定要权衡好它带来的“价值”和相应的“损失”。 总的来说, 我认为模板参数推导 (template argument deduction) 和 <code>auto</code> 其实是一回事, 是基于 C++ 类型系统的类型推导 (type inference) 的两个表现形式。</p><p>另外，decltype也是 C++11 新增的一个关键字，它和 auto 的功能一样，都是用来在编译时期进行自动类型推导。decltype比auto更确切地推断名称或表达式的类型（即原始的declared type），实现原理和auto类似，只是特殊情况不太一样，具体我们下一篇文章介绍。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式C修养——前导</title>
      <link href="/2023/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BF%AE%E5%85%BB%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/"/>
      <url>/2023/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BF%AE%E5%85%BB%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式C语言与ARM架构体系"><a href="#嵌入式C语言与ARM架构体系" class="headerlink" title="嵌入式C语言与ARM架构体系"></a>嵌入式C语言与ARM架构体系</h1><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>​        在开始我们嵌入式C语言学习的路程之前,先简单的回顾一下一些工具的简单使用.</p><p>​        在嵌入式下,我们经常会使用一些简单的工具,比如说vim, git等等.</p><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>​        vim是我们的一个常用工具,一些操作系统是默认有vim的. 但是我们常见的ubuntu是没有vim 而是只有vi的</p><p>​        啥是vi呢,就是<code>visual interface</code>的一个缩写.我们以前的文本编辑器都是使用行编辑器ex的命令, 后面,我们有了vi来增强他,但是还是会有不少的缺陷.于是我们现在又有了VI improved,就是增强版本.</p><p>​        使用如下的命令可以安装vim</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># apt-get install vim</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        在其他的Unix系统下,可能使用的包管理器不太一样,这个时候,我们就可以使用对应的包管理来下载vim</p><p>​        想查看自己有没有正常的安装,可以使用命令</p><pre class="line-numbers language-none"><code class="language-none">vim -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        查看版本信息即可</p><p>​        这是我的Ubuntu输出的信息</p><p><img src="image-20230820145727457.png" alt="image-20230820145727457"></p><h3 id="Linux-vi-vim"><a href="#Linux-vi-vim" class="headerlink" title="Linux vi/vim"></a>Linux vi/vim</h3><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><p>相关文章：<a href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">史上最全Vim快捷键键位图 — 入门到进阶</a></p><hr><h4 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h4><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (<a href="https://www.vim.org/">https://www.vim.org/</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><h4 id="vim-键盘图"><a href="#vim-键盘图" class="headerlink" title="vim 键盘图"></a>vim 键盘图</h4><p><img src="vi-vim-cheat-sheet-sch.gif" alt="img"></p><hr><h4 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h4><p>基本上 vi/vim 共分为三种模式，<strong>命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）</strong>。</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><strong>用户刚刚启动 vi/vim，便进入了命令模式。</strong></p><p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符，比如我们此时按下 <strong>i</strong>，并不会输入一个字符，<strong>i</strong> 被当作了一个命令。</p><p>以下是普通模式常用的几个命令：</p><ul><li><strong>i</strong> — 切换到输入模式，在光标当前位置开始输入文本。</li><li><strong>x</strong> — 删除当前光标所在处的字符。</li><li><strong>:</strong> — 切换到底线命令模式，以在最底一行输入命令。</li><li><strong>a</strong> — 进入插入模式，在光标下一个位置开始输入文本。</li><li><strong>o</strong>：在当前行的下方插入一个新行，并进入插入模式。</li><li><strong>O</strong> — 在当前行的上方插入一个新行，并进入插入模式。</li><li><strong>dd</strong> — 删除当前行。</li><li><strong>yy</strong> — 复制当前行。</li><li><strong>p</strong> — 粘贴剪贴板内容到光标下方。</li><li><strong>P</strong> — 粘贴剪贴板内容到光标上方。</li><li><strong>u</strong> — 撤销上一次操作。</li><li><strong>Ctrl + r</strong> — 重做上一次撤销的操作。</li><li><strong>:w</strong> — 保存文件。</li><li><strong>:q</strong> — 退出 Vim 编辑器。</li><li><strong>:q!</strong> — 强制退出Vim 编辑器，不保存修改。</li></ul><p>若想要编辑文本，只需要启动 Vim，进入了命令模式，按下 <strong>i</strong> 切换到输入模式即可。</p><p>命令模式只有一些最基本的命令，因此仍要依靠<strong>底线命令行模式</strong>输入更多命令。</p><h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>在命令模式下按下 <strong>i</strong> 就进入了输入模式，使用 <strong>Esc</strong> 键可以返回到普通模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h4 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h4><p>在命令模式下按下 <strong>:</strong>（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li><code>:w</code>：保存文件。</li><li><code>:q</code>：退出 Vim 编辑器。</li><li><code>:wq</code>：保存文件并退出 Vim 编辑器。</li><li><code>:q!</code>：强制退出Vim编辑器，不保存修改。</li></ul><p>按 <strong>ESC</strong> 键可随时退出底线命令模式。</p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p><p><img src="vim-vi-workmodel.png" alt="img"></p><hr><h4 id="vi-vim-使用实例"><a href="#vi-vim-使用实例" class="headerlink" title="vi/vim 使用实例"></a>vi/vim 使用实例</h4><h5 id="使用-vi-vim-进入一般模式"><a href="#使用-vi-vim-进入一般模式" class="headerlink" title="使用 vi/vim 进入一般模式"></a>使用 vi/vim 进入一般模式</h5><p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p><pre class="line-numbers language-none"><code class="language-none">$ vim runoob.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p><p><img src="078207F0-B204-4464-AAEF-982F45EDDAE9.jpg" alt="img"></p><h5 id="按下-i-进入输入模式-也称为编辑模式-，开始编辑文字"><a href="#按下-i-进入输入模式-也称为编辑模式-，开始编辑文字" class="headerlink" title="按下 i 进入输入模式(也称为编辑模式)，开始编辑文字"></a>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</h5><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p><p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p><p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p><p><img src="1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg" alt="img"></p><h4 id="按下-ESC-按钮回到一般模式"><a href="#按下-ESC-按钮回到一般模式" class="headerlink" title="按下 ESC 按钮回到一般模式"></a>按下 ESC 按钮回到一般模式</h4><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p><h4 id="在一般模式中按下-wq-储存后离开-vi"><a href="#在一般模式中按下-wq-储存后离开-vi" class="headerlink" title="在一般模式中按下 :wq 储存后离开 vi"></a>在一般模式中按下 <strong>:wq</strong> 储存后离开 vi</h4><p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p><p><img src="B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg" alt="img"></p><p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p><hr><h4 id="vi-vim-按键说明"><a href="#vi-vim-按键说明" class="headerlink" title="vi/vim 按键说明"></a>vi/vim 按键说明</h4><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p><h5 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h5><div class="table-container"><table><thead><tr><th style="text-align:left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td style="text-align:left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td style="text-align:left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td style="text-align:left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td style="text-align:left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td style="text-align:left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td></td></tr><tr><td style="text-align:left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td style="text-align:left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td style="text-align:left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td style="text-align:left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td style="text-align:left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td style="text-align:left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td style="text-align:left">n<space></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td style="text-align:left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td style="text-align:left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td style="text-align:left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td style="text-align:left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td style="text-align:left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td style="text-align:left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td style="text-align:left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td style="text-align:left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td style="text-align:left">n<Enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr><tr><td style="text-align:left">搜索替换</td><td></td></tr><tr><td style="text-align:left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr><td style="text-align:left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td style="text-align:left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td style="text-align:left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td style="text-align:left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td style="text-align:left">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr><td style="text-align:left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td style="text-align:left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><td style="text-align:left">删除、复制与贴上</td><td></td></tr><tr><td style="text-align:left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td style="text-align:left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td style="text-align:left">dd</td><td>剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。</td></tr><tr><td style="text-align:left">ndd</td><td>n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。</td></tr><tr><td style="text-align:left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td style="text-align:left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td style="text-align:left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td style="text-align:left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td style="text-align:left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td style="text-align:left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td style="text-align:left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td style="text-align:left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td style="text-align:left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td style="text-align:left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td style="text-align:left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td style="text-align:left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td style="text-align:left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td style="text-align:left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td style="text-align:left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td style="text-align:left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td style="text-align:left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table></div><h5 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h5><div class="table-container"><table><thead><tr><th style="text-align:left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td style="text-align:left">i, I</td><td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td style="text-align:left">a, A</td><td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td style="text-align:left">o, O</td><td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td></tr><tr><td style="text-align:left">r, R</td><td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td style="text-align:left">上面这些按键中，在 vi 画面的左下角处会出现『—INSERT—』或『—REPLACE—』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td></td></tr><tr><td style="text-align:left">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table></div><h5 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h5><div class="table-container"><table><thead><tr><th style="text-align:left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td style="text-align:left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td style="text-align:left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td style="text-align:left">:q</td><td>离开 vi (常用)</td></tr><tr><td style="text-align:left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td style="text-align:left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td style="text-align:left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td style="text-align:left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr><td style="text-align:left">ZQ</td><td>不保存，强制退出。效果等同于 <strong>:q!</strong>。</td></tr><tr><td style="text-align:left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td style="text-align:left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td style="text-align:left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td style="text-align:left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td style="text-align:left">vim 环境的变更</td><td></td></tr><tr><td style="text-align:left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td style="text-align:left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table></div><p>特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p><p>举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>​        当你学习到这里的时候,你肯定已经对IDE编译C系语言程序已经是相当的熟悉了,那么下面,我们来简单看看使用GCC编译器编译程序的流程</p><p>​        这里是嵌入式C语言学习,意味着我们可能需要交叉编译器</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install gccsudo apt-get install gcc-arm-linux-gnuabi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230820201431959.png" alt="image-20230820201431959"></p><p><img src="image-20230820201549563.png" alt="image-20230820201549563"></p><p>​        老样子，查看版本的方式检查我们的安装</p><p>​        使用GCC来编译我们的程序，很简单的：</p><p>​        好习惯，对于一个单独的测试我们开一个文件夹</p><pre class="line-numbers language-none"><code class="language-none">mkdir test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        回车ls一下，你会发现多出了一个test文件夹</p><pre class="line-numbers language-none"><code class="language-none">cd test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        上面的这个指令就是切换到test目录下， 下面尝试vim一个.c文件</p><pre class="line-numbers language-none"><code class="language-none">vim gcc-try.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        你会看到一个船新的空白的页面。记住，这个时候，显得将模式切换到插入模式：也就是摁I键。</p><p>​        你会发现左下角就会有一个INSERT的单词代表现在你可以输入东西了。掏出你的老回忆</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;&#x2F;* a default test gcc program *&#x2F;int main()&#123;printf(&quot;Hello, gcc-linux!&quot;); &#x2F;&#x2F; I decide nou to insert a slash herereturn 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你知道的，首先摁ESC键退出，然后<code>:wq</code>一顿操作退出并且保存</p><p><img src="image-20230820202610949.png" alt="image-20230820202610949"></p><p>​        这是我当时写的，可能有带你不太一样，但是——都是学过C的，这个原理懂的。</p><p>​        下面，我们就需要调用GCC连编译他。 GCC一步到位的指令是</p><pre class="line-numbers language-none"><code class="language-none">gcc -o $&#123;TARGET&#125; $&#123;SOURCE&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        试一下</p><pre class="line-numbers language-none"><code class="language-none">gcc -o gcc-try gcc-try.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果你没什么语法错误，这一步将会相当的平和和迅速。</p><p>​        ls一下：</p><p><img src="image-20230820202838867.png" alt="image-20230820202838867"></p><p>​        你瞧，多出来了一个gcc-try，就是我们指定的那样。对于可执行文件，我们所作的就是：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;gcc-try<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        呐！</p><p><img src="image-20230820203022896.png" alt="image-20230820203022896"></p><p>​        gcc当然还有其他的活！</p><h3 id="扩展GCC：常用命令"><a href="#扩展GCC：常用命令" class="headerlink" title="扩展GCC：常用命令"></a>扩展GCC：常用命令</h3><p><a href="https://zhuanlan.zhihu.com/p/606058690">Linux GCC常用命令 - 知乎 (zhihu.com)</a></p><h4 id="1简介"><a href="#1简介" class="headerlink" title="1简介"></a><strong>1简介</strong></h4><p>GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C 语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了 GNU Compiler Collection 也即是 GNU 编译器家族的意思了。另一方面，说到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在。</p><h4 id="2简单编译"><a href="#2简单编译" class="headerlink" title="2简单编译"></a><strong>2简单编译</strong></h4><p>示例程序如下：<br>//test.c<br>#include <stdio.h><br>int main(void)<br>{<br>printf(“Hello World!\n”);<br>return 0;<br>}</p><p>这个程序，一步到位的编译指令是:</p><p>gcc test.c -o test</p><p>实质上，上述编译过程是分为四个阶段进行的，即预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。</p><p><strong>2.1预处理</strong></p><p>gcc -E test.c -o test.i 或 gcc -E test.c</p><p>可以输出test.i文件中存放着test.c经预处理之后的代码。打开test.i文件，看一看，就明白了。后面那条指令，是直接在命令行窗口中输出预处理后的代码.</p><p>gcc的-E选项，可以让编译器在预处理后停止，并输出预处理结果。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。</p><p><strong>2.2编译为汇编代码(Compilation)</strong></p><p>预处理之后，可直接对生成的test.i文件编译，生成汇编代码：</p><p>gcc -S test.i -o test.s</p><p>gcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编代码文件。</p><h5 id="2-3汇编-Assembly"><a href="#2-3汇编-Assembly" class="headerlink" title="2.3汇编(Assembly)"></a><strong>2.3汇编(Assembly)</strong></h5><p>对于上一小节中生成的汇编代码文件test.s，gas汇编器负责将其编译为目标文件，如下：</p><p>gcc -c test.s -o test.o</p><h5 id="2-4连接-Linking"><a href="#2-4连接-Linking" class="headerlink" title="2.4连接(Linking)"></a><strong>2.4连接(Linking)</strong></h5><p>gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p><p>对于上一小节中生成的test.o，将其与Ｃ标准输入输出库进行连接，最终生成程序test</p><p>gcc test.o -o test</p><p>在命令行窗口中，执行./test, 让它说HelloWorld吧！</p><h4 id="3多个程序文件的编译"><a href="#3多个程序文件的编译" class="headerlink" title="3多个程序文件的编译"></a><strong>3多个程序文件的编译</strong></h4><p>通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC能够很好地管理这些编译单元。假设有一个由test1.c和 test2.c两个源文件组成的程序，为了对它们进行编译，并最终生成可执行程序test，可以使用下面这条命令：</p><p>gcc test1.c test2.c -o test</p><p>如果同时处理的文件不止一个，GCC仍然会按照预处理、编译和链接的过程依次进行。如果深究起来，上面这条命令大致相当于依次执行如下三条命令：</p><p>gcc -c test1.c -o test1.o<br>gcc -c test2.c -o test2.o<br>gcc test1.o test2.o -o test</p><h4 id="4检错"><a href="#4检错" class="headerlink" title="4检错"></a><strong>4检错</strong></h4><p>gcc -pedantic illcode.c -o illcode</p><p>-pedantic编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，-pedantic选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。</p><p>除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。</p><p>gcc -Wall illcode.c -o illcode</p><p>GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：</p><p>gcc -Werror test.c -o test</p><h4 id="5库文件连接"><a href="#5库文件连接" class="headerlink" title="5库文件连接"></a><strong>5库文件连接</strong></h4><p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。</p><p>例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so</p><p>其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib</p><h5 id="5-1编译成可执行文件"><a href="#5-1编译成可执行文件" class="headerlink" title="5.1编译成可执行文件"></a><strong>5.1编译成可执行文件</strong></h5><p>首先我们要进行编译test.c为目标文件，这个时候需要执行</p><p>gcc –c –I /usr/dev/mysql/include test.c –o test.o</p><h5 id="5-2链接"><a href="#5-2链接" class="headerlink" title="5.2链接"></a><strong>5.2链接</strong></h5><p>最后我们把所有目标文件链接成可执行文件:</p><p>gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test</p><p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p><h5 id="5-3强制链接时使用静态链接库"><a href="#5-3强制链接时使用静态链接库" class="headerlink" title="5.3强制链接时使用静态链接库"></a><strong>5.3强制链接时使用静态链接库</strong></h5><p>默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p><p>在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:</p><p>gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test</p><p>静态库链接时搜索路径顺序：</p><p>\1. ld会去找GCC命令中的参数-L<br>\2. 再找gcc的环境变量LIBRARY_PATH<br>\3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</p><p>动态链接时、执行时搜索路径顺序:</p><p>\1. 编译目标代码时指定的动态库搜索路径<br>\2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径<br>\3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径<br>\4. 默认的动态库搜索路径/lib<br>\5. 默认的动态库搜索路径/usr/lib</p><p>有关环境变量：<br>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径<br>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p><h2 id="扩展结束"><a href="#扩展结束" class="headerlink" title="扩展结束"></a>扩展结束</h2><p>​        我们来尝试一个：</p><pre class="line-numbers language-none"><code class="language-none">gcc -E -C gcc-try.c &gt; gcc-try.i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        回忆下（或者找我的博客，这里用到了文件重定向符的知识）</p><p>​        我们这行指令的意思，就是保留注释的，将<code>gcc-try.c</code>进行预处理产生的结果输出到gcc-try.i文件里去。这恰恰验证了一个事情：就是#include就是将被包含文件的代码粘贴到目标源文件上去</p><h2 id="手撸MakeFile"><a href="#手撸MakeFile" class="headerlink" title="手撸MakeFile"></a>手撸MakeFile</h2><p>​        我们尝试一下MakeFile.体验下感觉。</p><p>​        我们知道，我们往往回去编译一些大的工程：比如说Linux内核这种，不幸的是，他有大约30000个源文件，还有数不清的链接关系，那怎么编译呢。</p><p>​        所以，我们请出战神makefile!</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>​        先来整个最简单最简单的：整数相加工程</p><pre class="line-numbers language-none"><code class="language-none">vim add.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef _ADD_H_#define _ADD_H_int add(int num1, int num2);#endid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">vim add.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;add.h&quot;int add(int num1, int num2)&#123;return num1  + num2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">vim main.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &quot;add.h&quot;int main()&#123;    int a &#x3D; 1;    int b &#x3D; 2;printf(&quot;We test the function add: %d + %d &#x3D; %d&quot;,a, b, add(a, b));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        好，到这里，我们可以开始整活了，手撸一个Makefile</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> all clean<span class="token target symbol">all</span><span class="token punctuation">:</span> hello<span class="token target symbol">hello</span><span class="token punctuation">:</span> main.o add.ogcc -o hello main.o add.o<span class="token target symbol">main.o</span><span class="token punctuation">:</span> main.cgcc -c main.c<span class="token target symbol">add.o</span><span class="token punctuation">:</span> add.cgcc -c add.c<span class="token target symbol">clean</span><span class="token punctuation">:</span>rm -f main.o add.o hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        makefile是由一个个规则而来的，最通用的格式如下</p><pre class="line-numbers language-none"><code class="language-none">target: relycommand<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        我们一般说目标是我们要生成的可执行文件或者是各个源文件所对应的目标文件</p><p>​        命令可以很多样：可以是编译命令，可以是链接命令，还可以是shell命令。</p><p>​        上面的.PHONY则是声明了一个伪目标（不是一个真正的存在的文件），可以看作是一个目标，一般选择第一个目标作为默认的目标</p><p>​        我们把Makefile放到跟源码目录同级的地方，然后，你知道的：</p><pre class="line-numbers language-none"><code class="language-none">make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        MakeFile, 启动！</p><p><img src="image-20230820211236073.png" alt="image-20230820211236073"></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>​        啥是Git，简单来讲，托管代码的，我们的工程开发中常常可能会需要代码更改和管理。这玩意就是方便我们的管理而产生的。安装git 很简单</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后，我们需要声明一下，我们是谁：</p><pre class="line-numbers language-none"><code class="language-none">git config --global user_email 114514@xb.comgit config --global user_name Tiansuohaoer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        —global: 配置 ~/.gitconfig文件，对当前用户下所有的仓库都有效</p><p>​        —system: 配置 /etc/gitconfig文件，对所有系统下的用户都生效</p><p>​        不配置则是只对当前的仓库生效</p><h2 id="常用的Git命令"><a href="#常用的Git命令" class="headerlink" title="常用的Git命令"></a>常用的Git命令</h2><pre class="line-numbers language-none"><code class="language-none">git init: 创建一个本地仓库git add [FILES]: 添加文件到保护区git commit : 提交更改到本地仓库git log: 查看历史git show commit_id: 根据提交ID查看提交的详细信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        当然，我们从头讲起</p><p>​        简单的讲，我们的仓库代码分为三个部分：工作区，暂存区和版本库。现在，我们干活:</p><pre class="line-numbers language-none"><code class="language-none">mkdir gitProjectcd .&#x2F;gitProject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        我这边有个Git联系仓库，我们先把远程仓库克隆下来</p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;Charliechen114514&#x2F;git-study-lol.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们先看看看这个仓库里有什么</p><p><img src="image-20230820214600945.png" alt="image-20230820214600945"></p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>​        啥？git clone 的速度太感人了？简单：我们之所以访问github慢，是因为我们的特色的DNS污染，导致我们的访问速度感人，那么，我们只需要修改一下hosts，就可以解决问题。</p><p>​        首先可以查找一下github域名解析的结果有哪些（自行找网站查）</p><pre class="line-numbers language-none"><code class="language-none">140.82.114.3    github.com185.199.108.153    assets-cdn.github.com199.232.69.194    github.global.ssl.fastly.net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        至少这几个目前管用，听说github时常换解析。可能需要经常更新。</p><p>​        然后，记得重启一下network-manager（我的是NetWork-manager管理我的Ubuntu操作系统的网络，所以我重启这个，查看自己的网络管理器，修改就好）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;etc&#x2F;NetworkManager restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        完事。</p><pre class="line-numbers language-none"><code class="language-none">ping github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230820215241368.png" alt="image-20230820215241368"></p><p>​        应该不算太卡。</p><p>​        好，现在，我们以这个作为基底，整一个本地仓库：</p><pre class="line-numbers language-none"><code class="language-none">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <img src="image-20230820221557705.png" alt="image-20230820221557705"></p><pre class="line-numbers language-none"><code class="language-none">ls -a # 查看所有文件（.&#x2F;git是一个隐藏文件夹，所以需要这样搞）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230820221712941.png" alt="image-20230820221712941"></p><p>​        现在，我们加上一个文件，比如说——我们测试一下g++是不是正常的，我们把文件整理一下</p><pre class="line-numbers language-none"><code class="language-none">mkdir Vectormv .&#x2F;*.hpp .&#x2F;Vectormv .&#x2F;*.cpp .&#x2F;Vectormkdir GppTestcd GppTest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样就会有上面的效果了（当然现在clone  下来的就已经分类好了）</p><pre class="line-numbers language-none"><code class="language-none">vim gppTest.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iosstream&gt;int main()&#123;std::cout &lt;&lt; &quot;This is a g++ &amp;&amp; git test&quot; &lt;&lt; std::endl;&#125;&#x2F;&#x2F; ESC ,:wq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">g++ -o GPPTEST GppTest.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">.&#x2F;GPPTEST<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230820222153359.png" alt="image-20230820222153359"></p><p>​        不难的，不是吗。</p><p>​        下面，我们添加所有的文件到暂存区去</p><pre class="line-numbers language-none"><code class="language-none">git add .git status # 查看状态如何<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230820222428463.png" alt="image-20230820222428463"></p><p>​        然后，提交到git本地仓库去</p><pre class="line-numbers language-none"><code class="language-none">git commit -m &quot;MSG&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <img src="image-20230820222543504.png" alt="image-20230820222543504"></p><p>​        下面，我们指定一下本次提交的远程仓库</p><p><img src="image-20230820222728347.png" alt="image-20230820222728347"></p><p>​        欢乐push</p><pre class="line-numbers language-none"><code class="language-none">git push -u gitProject master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        完事。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><a href="https://zhuanlan.zhihu.com/p/135183491">Git 使用教程：最详细、最傻瓜、最浅显、真正手把手教！（万字长文） - 知乎 (zhihu.com)</a></p><h2 id="一：Git是什么？"><a href="#一：Git是什么？" class="headerlink" title="一：Git是什么？"></a><strong>一：Git是什么？</strong></h2><p>Git是目前世界上最先进的分布式版本控制系统。</p><p>工作原理 / 流程：</p><p><img src="v2-4f61dac0b425ebe34efc88d11a68f27b_1440w-1692537350247-379.webp" alt="img"></p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="二：SVN与Git的最主要的区别？"><a href="#二：SVN与Git的最主要的区别？" class="headerlink" title="二：SVN与Git的最主要的区别？"></a><strong>二：SVN与Git的最主要的区别？</strong></h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h2 id="三、在windows上如何安装Git？"><a href="#三、在windows上如何安装Git？" class="headerlink" title="三、在windows上如何安装Git？"></a><strong>三、在windows上如何安装Git？</strong></h2><p>msysgit是 windows版的Git,如下：</p><p><img src="v2-70a91b73789275b2b2f454c722670c3b_1440w-1692537350247-381.webp" alt="img"></p><p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git —&gt; Git Bash”会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：</p><p><img src="v2-daaedb3f59e70a1faf4dbc4446fb4bb2_1440w-1692537350247-384.webp" alt="img"></p><p>安装完成后，还需要最后一步设置，在命令行输入如下：</p><p><img src="v2-bdd873dd845c3f073849155c0963073c_1440w-1692537350247-386.webp" alt="img"></p><p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><p>注意：git config —global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><h2 id="四：如何操作？"><a href="#四：如何操作？" class="headerlink" title="四：如何操作？"></a><strong>四：如何操作？</strong></h2><h2 id="一：创建版本库。"><a href="#一：创建版本库。" class="headerlink" title="一：创建版本库。"></a><strong>一：创建版本库。</strong></h2><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p><p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p><p><img src="v2-ff7970ec6ba1fe08f2aa85d5c492d4e8_1440w-1692537350247-388.webp" alt="img"></p><p>pwd 命令是用于显示当前的目录。</p><p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p><p><img src="v2-11477dcb7b5a41ed736723bce7591ce7_1440w-1692537350248-390.webp" alt="img"></p><p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p><p><img src="v2-de09c7374f69dff1eb382c90fb5453ea_1440w-1692537350248-392.webp" alt="img"></p><p>下面先看下demo如下演示：</p><p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p><p>第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：</p><p><img src="v2-45c5f787266917a66b019ed2e527b54e_1440w-1692537350248-394.webp" alt="img"></p><p>如果和上面一样，没有任何提示，说明已经添加成功了。</p><p>第二步：用命令 git commit告诉Git，把文件提交到仓库。</p><p><img src="v2-3e7db42a3a3084b913b09d501eba4162_1440w-1692537350248-396.webp" alt="img"></p><p>现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：</p><p><img src="v2-babc2bfc4a8cab014316dd9686cb77e8_1440w-1692537350248-398.webp" alt="img"></p><p>说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：</p><p><img src="v2-6c63e31ec6931349c70b15280719ac91_1440w-1692537350248-400.webp" alt="img"></p><p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。</p><p>把文件添加到版本库中。</p><p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p><p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：</p><p>git diff readme.txt 如下：</p><p><img src="v2-de35f9aa38e4fafa28d9530b40ff4938_1440w-1692537350248-402.webp" alt="img"></p><p>如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p><p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。</p><p>如下：</p><p><img src="v2-f1b908bcd6ad00b24865de6ebbcb25fd_1440w-1692537350248-404.webp" alt="img"></p><h2 id="二：版本回退："><a href="#二：版本回退：" class="headerlink" title="二：版本回退："></a><strong>二：版本回退：</strong></h2><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行内容为33333333333333</p><p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p><p><img src="v2-cb45508f26591db4d3bf466b1c8038c9_1440w-1692537350248-406.webp" alt="img"></p><p>git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p><p><img src="v2-d93f3959e90828a564d937ea14531aae_1440w-1692537350248-408.webp" alt="img"></p><p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset —hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset —hard HEAD~100 即可。未回退之前的readme.txt内容如下：</p><p><img src="v2-9e4a6141c2b535b611370b630617aedf_1440w-1692537350248-410.webp" alt="img"></p><p>如果想回退到上一个版本的命令如下操作：</p><p><img src="v2-7068989f6728f00654f7527cb6577956_1440w-1692537350248-412.webp" alt="img"></p><p>再来查看下 readme.txt内容如下：通过命令cat readme.txt查看</p><p><img src="v2-38e4dc805a5e86793a968c515081c16a_1440w.jpeg" alt="img"></p><p>可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：</p><p><img src="v2-24f6d3f8e7a36ea0b3b935deb087c4de_1440w-1692537350248-415.webp" alt="img"></p><p>我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p><p>git reset —hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：</p><p><img src="v2-215458338ded9193d0865a0937102fba_1440w-1692537350248-417.webp" alt="img"></p><p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令</p><p>git reset —hard 6fcfc89来恢复了。演示如下：</p><p><img src="v2-5416a5b7fce0cbf525b89c79a2c79857_1440w-1692537350248-419.webp" alt="img"></p><p>可以看到 目前已经是最新的版本了。</p><h2 id="三：理解工作区与暂存区的区别？"><a href="#三：理解工作区与暂存区的区别？" class="headerlink" title="三：理解工作区与暂存区的区别？"></a><strong>三：理解工作区与暂存区的区别？</strong></h2><ul><li>工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</li><li>版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</li></ul><p>我们前面说过使用Git提交文件到版本库有两步：</p><ol><li>是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</li><li>使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</li></ol><p>我们继续使用demo来演示下：</p><p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：</p><p><img src="v2-ed23c551370326d29f13e0f662e903df_1440w-1692537350248-421.webp" alt="img"></p><p>现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：</p><p><img src="v2-a7e91944849ebc009fd25d7fe95a1e42_1440w-1692537350248-423.webp" alt="img"></p><p>接着我们可以使用git commit一次性提交到分支上，如下：</p><p><img src="v2-13d5b4db326d192d97ff4a52480a914f_1440w-1692537350248-425.webp" alt="img"></p><h2 id="四：Git撤销修改和删除文件操作"><a href="#四：Git撤销修改和删除文件操作" class="headerlink" title="四：Git撤销修改和删除文件操作"></a><strong>四：Git撤销修改和删除文件操作</strong></h2><h2 id="一：撤销修改："><a href="#一：撤销修改：" class="headerlink" title="一：撤销修改："></a><strong>一：撤销修改：</strong></h2><p>比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p><p><img src="v2-e1a53a233580c18437ddc14a2a87d7ac_1440w-1692537350248-427.webp" alt="img"></p><p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p><ol><li>如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</li><li>我可以按以前的方法直接恢复到上一个版本。使用 git reset —hard HEAD^</li></ol><p>但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p><p><img src="v2-e3c10eb402b7974609d8e2dcc74b6214_1440w-1692537350248-429.webp" alt="img"></p><p>可以发现，Git会告诉你，git checkout — file 可以丢弃工作区的修改，如下命令：</p><p>git checkout — readme.txt,如下所示：</p><p><img src="v2-b364f12ef91cc1ebb9a1ddac11e379c5_1440w-1692537350248-431.webp" alt="img"></p><p>命令 git checkout —readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p><ol><li>readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li><li>另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态</li></ol><p>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p><p><img src="v2-662af880828c52e92e355c5fbaa97d00_1440w-1692537350248-433.webp" alt="img"></p><p>注意：命令git checkout — readme.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。</p><h2 id="二：删除文件"><a href="#二：删除文件" class="headerlink" title="二：删除文件"></a><strong>二：删除文件</strong></h2><p>假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：</p><p><img src="v2-5b4a1389f02045d431fd10dfabe5e366_1440w-1692537350248-435.webp" alt="img"></p><p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，</p><p><img src="v2-d27fcfaf70c28e90d138e26badd2d6e6_1440w-1692537350248-437.webp" alt="img"></p><p>只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？</p><p>可以使用如下命令 git checkout — b.txt，如下所示：</p><p><img src="v2-b959d2af16e2779b07869353b78ecc84_1440w.jpeg" alt="img"></p><p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p><p><img src="v2-014dc55563b04b2453bcd84841072fd7_1440w-1692537350248-440.webp" alt="img"></p><h2 id="五：远程仓库"><a href="#五：远程仓库" class="headerlink" title="五：远程仓库"></a><strong>五：远程仓库</strong></h2><p>在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p><p>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p><p>ssh-keygen -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：</p><p><img src="v2-b2bd43e875e921a2d62ed6f89025919e_1440w.jpeg" alt="img"></p><p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p><p><img src="v2-6dc17124a790b2bd358dc5245da8af43_1440w-1692537350249-443.webp" alt="img"></p><p>点击 Add Key，你就应该可以看到已经添加的key。</p><p><img src="v2-e8724f6557b8efdf2dc402d76d443962_1440w-1692537350249-445.webp" alt="img"></p><h2 id="如何添加远程库？"><a href="#如何添加远程库？" class="headerlink" title="如何添加远程库？"></a><strong>如何添加远程库？</strong></h2><p>现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p><p>首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p><p><img src="v2-cf6df573d9098b8a47c87589d0705429_1440w-1692537350249-447.webp" alt="img"></p><p>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="v2-f0da99e1a8cb0f6eed619a84e72fe047_1440w-1692537350249-449.webp" alt="img"></p><p>目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git remote add origin https://github.com/tugenhua0707/testgit.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所有的如下：</p><p><img src="v2-8f745d6400ea37c25058ce4a1383e7ac_1440w-1692537350249-451.webp" alt="img"></p><p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：</p><p><img src="v2-9c100c2fe1fe45f7175f8fa2f400882e_1440w-1692537350249-453.webp" alt="img"></p><p>从现在起，只要本地作了提交，就可以通过如下命令：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p><h2 id="如何从远程库克隆？"><a href="#如何从远程库克隆？" class="headerlink" title="如何从远程库克隆？"></a><strong>如何从远程库克隆？</strong></h2><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p><p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p><p>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p><p><img src="v2-7dd99200b98a20178b4f89fe9ca66dfa_1440w-1692537350249-455.webp" alt="img"></p><p>如下，我们看到：</p><p><img src="v2-73b7641802c7801295d8b8f346165af1_1440w-1692537350249-457.webp" alt="img"></p><p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p><p><img src="v2-eed3b1479f3a70a7edf79c88d6cb3df7_1440w-1692537350249-459.webp" alt="img"></p><p>接着在我本地目录下 生成testgit2目录了，如下所示：</p><p><img src="v2-215ce5fa4304f72aab370ed949a96605_1440w-1692537350249-461.webp" alt="img"></p><h2 id="六：创建与合并分支"><a href="#六：创建与合并分支" class="headerlink" title="六：创建与合并分支"></a><strong>六：创建与合并分支</strong></h2><p>在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p><p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p><p><img src="v2-c8b668d0bac8600a6db8a187c5ef02d9_1440w-1692537350249-463.webp" alt="img"></p><p>git checkout命令加上 –b参数表示创建并切换，相当于如下2条命令</p><ol><li>git branch dev</li><li>git checkout dev</li></ol><p>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p><p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p><p><img src="v2-409a7acb8ddc28687c6406b475ab954c_1440w-1692537350249-465.webp" alt="img"></p><p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p><p><img src="v2-50074e45f108bb246a76deb9be2dc4f7_1440w-1692537350249-467.webp" alt="img"></p><p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p><p><img src="v2-df606def3d16dd7eee4728cd2a8c283b_1440w-1692537350249-469.webp" alt="img"></p><p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</p><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>合并完成后，我们可以接着删除dev分支了，操作如下：</p><p><img src="v2-c7b799a096de8ae1d7c5fb6a7787ff83_1440w-1692537350249-471.webp" alt="img"></p><p>总结创建与合并分支命令如下：</p><ul><li>查看分支：git branch</li><li>创建分支：git branch name</li><li>切换分支：git checkout name</li><li>创建+切换分支：git checkout –b name</li><li>合并某分支到当前分支：git merge name</li><li>删除分支：git branch –d name</li></ul><h2 id="如何解决冲突？"><a href="#如何解决冲突？" class="headerlink" title="如何解决冲突？"></a><strong>如何解决冲突？</strong></h2><p>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p><p><img src="v2-70a250bbf159121aa7503189c3011baa_1440w-1692537350249-473.webp" alt="img"></p><p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p><p><img src="v2-055ccea0ead91a43fbdf7573e4013956_1440w-1692537350249-475.webp" alt="img"></p><p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p><p><img src="v2-d02f5cdc0ba9bc644018ab7b4834e846_1440w-1692537350249-477.webp" alt="img"></p><p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;<HEAD是指主分支修改的内容，>&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</p><p><img src="v2-51b771544ccf5cf5480f6d32f4e082c4_1440w-1692537350249-479.webp" alt="img"></p><p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p><p><img src="v2-ccfdbe225d3882080b50be2284930e5e_1440w-1692537350249-481.webp" alt="img"></p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a><strong>分支管理策略</strong></h2><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</p><ol><li>创建一个dev分支。</li><li>修改readme.txt内容。</li><li>添加到暂存区。</li><li>切换回主分支(master)。</li><li>合并dev分支，使用命令 git merge –no-ff -m “注释” dev</li><li>查看历史记录</li></ol><p>截图如下：</p><p><img src="v2-0dfa2b3201d650e5db28a9249d564aed_1440w-1692537350249-483.webp" alt="img"></p><p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h2 id="七：bug分支"><a href="#七：bug分支" class="headerlink" title="七：bug分支"></a><strong>七：bug分支</strong></h2><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p><p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p><p><img src="v2-50c2c93d3ab1d7f727521490abc00d82_1440w-1692537350249-485.webp" alt="img"></p><p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p><p><img src="v2-6ff78e92b4936260bb81b1fc477d9aaa_1440w-1692537350249-487.webp" alt="img"></p><p>所以现在我可以通过创建issue-404分支来修复bug了。</p><p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p><p><img src="v2-491170135f7ecc5d2e318fd50fa6d98c_1440w-1692537350249-489.webp" alt="img"></p><p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p><p><img src="v2-e6d740741e4451d1ba843feb563a59b6_1440w-1692537350249-491.webp" alt="img"></p><p>现在，我们回到dev分支上干活了。</p><p><img src="v2-ba96abb9e8fe98a3945991e7ad9c0263_1440w-1692537350249-493.webp" alt="img"></p><p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：</p><p><img src="v2-219d116d0028692cba1c325eb8f85717_1440w-1692537350249-495.webp" alt="img"></p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p><ol><li>git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</li><li>另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</li></ol><p>演示如下</p><p><img src="v2-97f33bfff48c8ed0ee11afa191b9bf28_1440w-1692537350249-497.webp" alt="img"></p><h2 id="八：多人协作"><a href="#八：多人协作" class="headerlink" title="八：多人协作"></a><strong>八：多人协作</strong></h2><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p><ul><li>要查看远程库的信息 使用 git remote</li><li>要查看远程库的详细信息 使用 git remote –v</li></ul><p>如下演示：</p><p><img src="v2-055c51e840ec528db51036e63409948b_1440w-1692537350249-499.webp" alt="img"></p><h2 id="一：推送分支："><a href="#一：推送分支：" class="headerlink" title="一：推送分支："></a><strong>一：推送分支：</strong></h2><p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：使用命令 git push origin master</p><p>比如我现在的github上的readme.txt代码如下：</p><p><img src="v2-c7c9ef773753c2fb56e29ec40dbe56cc_1440w-1692537350250-501.webp" alt="img"></p><p>本地的readme.txt代码如下：</p><p><img src="v2-4c7f927c71e8b6bb7bd79f5204b55db6_1440w-1692537350250-503.webp" alt="img"></p><p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p><p><img src="v2-adb686a9a510b042741db44b7951969a_1440w-1692537350250-505.webp" alt="img"></p><p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p><p><img src="v2-e53b1b0c9f3f579fef1e39c61087161f_1440w-1692537350250-507.webp" alt="img"></p><p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev</p><p>那么一般情况下，那些分支要推送呢？</p><p>master分支是主分支，因此要时刻与远程同步。</p><p>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</p><h2 id="二：抓取分支："><a href="#二：抓取分支：" class="headerlink" title="二：抓取分支："></a><strong>二：抓取分支：</strong></h2><p>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2</p><p>但是我首先要把dev分支也要推送到远程去，如下</p><p><img src="v2-7e4940ed8054b609b9fe53a4e3e98023_1440w-1692537350250-509.webp" alt="img"></p><p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p><p><img src="v2-7ff68c6f6753b4faaf54599a2e7f81a9_1440w-1692537350250-511.webp" alt="img"></p><p>现在目录下生成有如下所示：</p><p><img src="v2-a54859d18fcce0a2f87886e09f9a5b2c_1440w-1692537350250-513.webp" alt="img"></p><p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git checkout –b dev origin/dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p><p>如下：</p><p><img src="v2-82f32fc35de5f832dc74d2896292f53c_1440w-1692537350250-515.webp" alt="img"></p><p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p><p><img src="v2-583d1e8ffd87183c6b7905f20600f296_1440w-1692537350250-517.webp" alt="img"></p><p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p><p><img src="v2-cbf0e628e26b977734d5879e2c5d743c_1440w-1692537350250-519.webp" alt="img"></p><p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p><p><img src="v2-803d356dee751407329cbaa5607dc39c_1440w-1692537350250-521.webp" alt="img"></p><p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：</p><p>我们可以先来看看readme.txt内容了。</p><p><img src="v2-944bbc1fc16551c3ec56a6be0a19feb4_1440w-1692537350250-523.webp" alt="img"></p><p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：</p><p><img src="v2-b31f58b5727346b2314b026aee673a62_1440w-1692537350250-525.webp" alt="img"></p><p>因此：多人协作工作模式一般是这样的：</p><ul><li>首先，可以试图用git push origin branch-name推送自己的修改.</li><li>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</li><li>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix网络编程——导论与三种协议</title>
      <link href="/2023/08/19/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/08/19/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Unix网络编程-三大传输协议"><a href="#Unix网络编程-三大传输协议" class="headerlink" title="Unix网络编程 三大传输协议"></a>Unix网络编程 三大传输协议</h1><h2 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h2><p>​        <strong>绝大多数客户/服务器网络应用使用TCP或UDP。</strong></p><p>​        SCTP（流控制传输协议，Stream Control Transmission Protocol）是一个较新的协议，最初设计用于通过因特网传输电话信令。这些传输层协议都使用网络层协议IP（IPv4或IPv6）。尽管可以绕过传输层直接使用IPv4或IPv6，但这种原始套接字极少使用。</p><p>​        UDP是一个简单的、不可靠的数据报协议，而TCP是一个复杂、可靠的字节流协议。</p><p>​        SCTP也是一个可靠的协议，但它还提供消息边界、传输层级别的多宿支持（即一个主机同时使用多个网络接口地址（IP地址）与其他主机进行通信，多个路径通往同一服务器，提高传输的可靠性、性能和容错性）、将队头阻塞（队头阻塞是指当一个数据包在传输过程中发生丢失或延迟时，后续的数据包也会被阻塞，直到该数据包被重新传输或到达）减少到最小的方法。</p><p>​        虽然协议族被称为TCP/IP，但除了TCP和IP这两个主要协议外，还有许多其他成员：</p><p><img src="71f6c8b2006c43cd81569b4c89093cc7.png" alt="在这里插入图片描述"></p><p>从右向左看上图，最右边5个网络应用在使用IPv6协议，随后的6个网络应用使用IPv4。</p><p>​        上图最左边的tcpdump网络应用或者使用BSD分组过滤器（BPF，BSD Packet Filter），或者使用数据链路提供者接口（DLPI，DataLink Provider Interface）直接与数据链路通信。上图中的应用下面的虚线为API，它通常是套接字或XTI（X/Open Transport Interface）。访问BPF或DLPI的接口不使用套接字或XTI（但Linux是例外，它使用SOCK_PACKET特殊套接字类型提供对数据链路的访问）。</p><p>​        上图中显示traceroute程序使用两种套接字，IP套接字（用于访问IP）和ICMP套接字（用于访问ICMP）。</p><p>​        上图中的每个协议框：</p><p>​        1.IPv4：网际协议版本4（Internet Protocol version 4），自20世纪80年代早期以来一直是网际协议族的主力协议。它使用32位地址。IPv4给TCP、UDP、SCTP、ICMP、IGMP提供分组递送服务。</p><p>​        2.IPv6：网际协议版本6，是在20世纪90年代中期作为IPv4的一个替代品设计的，其主要变化是使用128位地址以应对20世纪90年代因特网的爆发性增长。IPv6给TCP、UDP、SCTP、ICMPv6提供分组递送服务。</p><p>​        3.<strong>TCP：传输控制协议（Transmission Control Protocol）是面向连接的协议</strong>，为用户进程提供可靠的全双工字节流。TCP套接字是一种流套接字。TCP关心确认、超时、重传之类的细节。大多数因特网应用程序使用TCP。</p><p>​        4.UDP：用户数据报协议（User Datagram Protocol）是一<strong>个无连接协议，UDP套接字是一种数据报套接字（datagram socket）。UDP数据报不能保证最终到达它们的目的地。</strong></p><p>​        5.SCTP：流传输控制协议（Stream Control Transmission Protocol）是一个<strong>提供可靠全双工关联的面向连接的协议</strong>，我们用关联一词指称SCTP中的连接，因为SCTP是多宿的，从而每个关联的两端均涉及一组IP地址和一个端口号。SCTP提供消息服务，即维护来自应用层的记录边界。与TCP和UDP一样，SCTP既可以使用IPv4，也可以使用IPv6，而且能在同一个关联中同时使用它们。</p><p>​        5.ICMP：网际控制消息协议（Internet Control Message Protocol）处理在路由器和主机之间流通的错误和控制消息。这些消息通常由TCP/IP网络支持软件（而非用户进程）产生和处理，但上图的ping和traceroute程序同样使用ICMP。有时我们称其为ICMPv4，以便与ICMPv6相区别。</p><p>​        6.IGMP：网际组管理协议（Internet Group Management Protocol）用于多播，它在IPv4中是可选的（但大多IPv4实现都支持多播）。</p><p>​        7.ARP：地址解析协议（Address Resolution Protocol）把一个IPv4地址映射成一个硬件地址（如以太网地址）。ARP常用于以太网、令牌环网、FDDI（Fiber Distributed Data Interface，光纤分布式数据接口）等广播网络，在点到点网络上并不需要。</p><p>​        8.RARP：反向地址解析协议（Reverse Address Resolution Protocol）把一个硬件地址映射成一个IPv4地址。它有时用于无盘节点的引导。</p><p>​        9.ICMPv6：网际控制消息协议版本6综合了ICMPv4、IGMP、ARP功能。</p><p>​        10.BPF：BSD分组过滤器，该接口提供对于数据链路层的访问能力，通常可以在源自Berkeley的内核中找到。</p><p>​        11.DLPI：数据链路提供者接口，该接口也提供对于数据链路层的访问能力，通常随SVR 4（System V Release 4）内核提供。</p><p>​        所有网际协议分别由一个或多个请求评注（Request For Comments，RFC）文档定义，这是它们的正式规范。</p><h2 id="TCP-UDP-SCTP"><a href="#TCP-UDP-SCTP" class="headerlink" title="TCP    UDP    SCTP"></a>TCP    UDP    SCTP</h2><p>​        我们使用术语IPv4/IPv6主机或双栈主机表示同时支持IPv4和IPv6的主机。</p><p>​        TCP/IP协议的细节参见TCPv1（TCP/IP详解 卷一：协议），TCP/IP在4.4 BSD上的实现参见TCPv2（TCP/IP详解 卷二：实现）。</p><p>​        RFC 768中说明了UDP。应用进程往一个UDP套接字写入一个消息，该消息随后被封装到一个UDP数据报，该UDP数据报又被封装到一个IP数据报，然后发送到目的地。UDP不保证UDP数据报会到达其最终目的地，不保证各个数据报的先后顺序跨网络后保持不变，也不保证每个数据报只到达一次。</p><p>​        <strong>使用UDP进行网络编程的问题是它缺乏可靠性，如果一个数据报到达了其最终目的地，但目的主机的UDP模块校验和检测发现错误，或该数据报在网络传输途中被丢弃了，它就无法被投递给UDP套接字，也不会被源端自动重传。如想确保一个数据报到达了目的地，可以往应用中添置一些特性：来自对端的确认、本端的超时与重传</strong>等。</p><p>​        每个UDP数据报都有一个长度，如果数据报正确到达其目的地，那么该数据报的长度将随数据一道传递给接收端应用进程。这一点不同于TCP，TCP是一个字节流协议，没有任何记录边界。</p><p>​        我们说UDP提供无连接服务，因为UDP客户与服务器之间不必存在任何长期的关系，例如，一个UDP客户可以创建一个套接字并发送一个数据报给一个服务器，然后立即用同一个套接字发送另一个数据报给另一个服务器。同样，一个UDP服务器可以用同一个UDP套接字从若干不同客户接收数据报。</p><p>​        TCP在RFC 793中说明，然后由RFC 1323、RFC 2581、RFC 2988、RFC 3390加以更新。TCP提供客户与服务器之间的连接，TCP客户先与某个给定服务器建立一个连接，再跨该连接与那个服务器交换数据，最后终止这个连接。</p><p>​        <strong>TCP还提供可靠性</strong>，当TCP向另一端发送数据时，它要求对端返回一个确认，如果没有收到确认，TCP就自动重传数据并等待更长时间，在数次重传失败后，TCP才放弃，如此在尝试发送数据上所花的总时间一般是4~10分钟（取决于实现）。</p><p>​        <strong>TCP并不保证数据一定被对端接收，TCP只是尽可能把数据送到对端，如果送不到会放弃重传并中断连接来通知本端用户，这么说来，TCP也不能被描述为100%可靠的协议，它提供的是数据的可靠递送或错误的可靠通知。</strong></p><p>​        TCP有动态估算客户和服务器之间往返时间（RTT，Round-Trip Time）的算法，以便知道等待一个确认需要多少时间。RTT在一个局域网上大约几毫秒，跨越一个广域网则可能是数秒钟。另外，由于RTT受网络流通等各种变化因素影响，TCP会持续估算一个给定连接的RTT。</p><p>​        TCP通过给其中每个字节关联一个序号对发送的数据进行排序，如果一个应用写2048字节到一个TCP套接字，导致了TCP发送2个分节，第一个分节所含数据序号为1~1024，第二个分节所含数据序列号为1025~2048（分节是TCP传递给IP的数据单元），如果这些分节非顺序到达，接收端TCP将先根据它们的序列号重新排序，再把结果数据传递给应用。如果接收端TCP接收到来自对端的重复数据（如发送端认为一个分节已丢失并因此重传，而这个分节并没有真正丢失，只是网络通信过于拥挤），它可以根据序列号发现数据是重复的，从而丢弃重复数据。</p><p>​        UDP不提供可靠性，UDP不提供确认、序列号、RTT估算、超时和重传等机制。如果一个UDP数据报在网络中被复制（可能是由于网络拓扑结构（如主机的多个接口都在同一广播域，如果收到该广播域的广播时）、网络设备的传输错误或其他网络因素引起），两份副本就可能都递送到接收端主机。如果一个UDP客户发送两个数据报到同一个目的地，它们可能被网络重新排序，颠倒顺序后到达目的地。UDP应用必须处理所有这些情况。</p><p>​        <strong>TCP还提供流量控制，</strong>TCP总是告知对端它一次能够从对端接收多少字节的数据，这称为通告窗口。该窗口指出此刻接收缓冲区当前可用空间量，从而确保发送端发送的数据不会使接收缓冲区溢出。该窗口时刻动态变化，当接收到来自发送端的数据时，窗口大小就减小，当接收端应用从缓冲区中读取数据时，窗口大小就增大。通告窗口大小减小到0是可能的：TCP对应某个套接字的接收缓冲区已满，导致它必须等待应用从该缓冲区读取数据后，才能从对端再接收数据。</p><p>​        UDP不提供流量控制，让较快的UDP发送端以一个UDP接收端难以跟上的速率发送数据报是非常容易的。</p><p>​        <strong>TCP连接是全双工的，在一个给定的连接上应用可以在任何时刻既发送数据又接收数据。因此，TCP必须为每个数据流方向跟踪诸如序列号和通告窗口大小等状态信息。建立一个全双工连接后，需要的话可以将其转换成一个单工连接。</strong></p><p>​        <strong>UDP可以是全双工的，具体取决于应用程序，UDP允许应用程序以任意的方式发送和接收数据报。</strong></p><p>​        SCTP在RFC 2960中详细说明，并由RFC 3309加以更新。RFC 3286给出了SCTP的简要介绍。SCTP在客户和服务器之间提供关联，并像TCP那样给应用提供可靠性、排序、流量控制、全双工的数据传送。SCTP使用关联代替连接是由于：一个连接只涉及两个IP地址之间的通信；一个关联指两个系统之间的通信，它可能因为SCTP支持多宿而涉及不止两个地址。</p><p>​        SCTP是面向消息的，它提供各个记录的按序递送服务。与UDP一样，由发送端写入的每条记录长度随数据一道传递给接收端应用。</p><p>​        SCTP能在所连接的端点之间提供多个流，每个流各自可靠地按序递送消息。一个流上某个消息的丢失不会阻塞同一关联其他流上的消息的投递。而TCP在单一字节流中任何位置的字节丢失都将阻塞该连接上其后所有数据的递送，直到该丢失被修复。</p><p>​        SCTP提供多宿特性，单个SCTP端点能支持多个IP地址，可以增强应对网络故障的健壮性。一个端点可能有多个冗余的网络连接。当一个端点与另一个端点建立一个关联后，如果它的某个网络或某个跨越因特网的通路发生故障，SCTP可以通过切换到使用已与该关联相关的另一个地址来规避发生的故障。</p><p>​        BGP（边界网关协议，Border Gateway Protocol），是一种在互联网中用于交换路由信息的协议，它被用来确定数据包在互联网上的最佳路径，以便将它们从源主机发送到目标主机。BGP主要用于连接不同的自治系统（AS）。自治系统（AS）是指一组相互连接的网络，由一个或多个网络管理实体（例如互联网服务提供商、企业或组织）组成，在互联网架构中，自治系统是将一组IP地址块（IP地址前缀）和一组路由策略（自治系统内部定义的用于控制和管理路由流量的规则和策略）组合在一起的网络集合。每个自治系统被分配一个唯一的自治系统号（ASN），用于在全球范围内唯一标识该自治系统。以下是几个自治系统的例子：<br>1.互联网服务提供商（ISP）Verizon的自治系统，AS号为AS701，它是一个大型的自治系统，它拥有全球范围内的网络和多个数据中心。通过该自治系统，Verizon可以连接和提供服务给各种客户，包括企业、政府机构和个人用户。AS701的存在使得Verizon能够管理其网络流量、优化路由选择，并确保高效、可靠的通信服务。</p><p>2.包含多个办公地点或多分支的机构或校园网络的中型自治系统。这些自治系统可能由中等规模的企业、学校、大学或中型互联网服务提供商管理。</p><p>3.包含单个机构或小型企业或小型组织的小型自治系统。它们可能仅包含一个办公地点或一个局域网，并且连接的设备数量相对较少。这样的自治系统可能只需要几个IP地址块，并且使用较简单的路由协议进行内部路由交换。</p><p>​        iBGP（内部边界网关协议，Internal Border Gateway Protocol），是BGP协议的一种变种，用于在同一个自治系统（AS）内部的不同路由器之间交换路由信息。iBGP用于将从外部BGP邻居（即与其他自治系统之间建立的BGP连接）学到的路由信息传播给本地的内部BGP邻居（即AS内部的其他路由器）。使用iBGP，自治系统内的各个边界路由器可以共享路由信息（各个边界路由器并不需要邻接，只要有路由可达即可）。例如，有3个AS，AS1与AS2相连，AS2与AS3相连，而AS1和AS3之间相隔AS2，AS2有两个边界网关G1和G3，它们分别与AS1和AS3相连，这是典型的AS1和AS3是客户，而AS2是ISP的情形，如果AS1想向AS3发送消息，就要经过AS2，由于有iBGP，G1和G3的路由信息是共享的，这样G1就知道怎样到达AS3。</p><p>​        以上所说的SCTP的健壮性也可以在路由协议的辅助下从TCP中获得。由iBGP实现的同一域内的BGP连接（指使用iBGP可以让所有边界路由器共享路由信息）往往把赋予路由器的某个虚拟接口的多个地址用作TCP连接的端点，该域的路由协议确保域内两个路由器之间只要存在一条路由（即虚拟接口的多个地址中有一个可用），该连接可以使用，从而保证这两个边界路由器之间的BGP连接可用；要是使用属于某个物理接口的地址来建立BGP连接，该物理接口又不工作了，就不能做到这一点。SCTP的多宿特性允许主机（而不仅仅是路由器）也多宿，而且允许多宿跨越不同的服务供应商发生，这是基于路由的TCP多宿方法无法做到的。</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>建立一个TCP连接时会发生：<br><strong>1.服务器先准备好接受外来连接，这通常通过调用socket、bind、listen三个函数来完成，我们称其为被动打开。</strong></p><p><strong>2.客户通过调用connect发起主动打开，这导致客户TCP发送一个SYN（同步）分节，它告诉服务器客户将在待建立的连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部、一个TCP首部和可能有的若干个TCP选项。</strong></p><p><strong>3.服务器必须确认（ACK）客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一待建立连接中发送的数据的初始序列号。服务器在单个分节中发送SYN和对客户SYN的ACK。</strong></p><p><strong>4.客户必须确认服务器的SYN。</strong></p><p><img src="7dc58c218ba442c7978c64e0f04050c0.png" alt="在这里插入图片描述"></p><p>以上过程至少需要三个分组，因此称之为TCP的三路握手：</p><p>​        如上图，客户的初始序列号为J，服务器的初始序列号为K，ACK中的确认号是发送这个ACK的一端所期待的下一个序列号。因为SYN占据一个字节的空间，所以每一个SYN的ACK中的确认号就是该SYN的初始序列号加1。类似地，每一个FIN的ACK中的确认号为该FIN的序号加1。</p><p>​        建立TCP连接就好比一个电话系统，<strong>socket函数等同于有电话可用</strong>；<strong>bind函数在告诉别人你的电话号码</strong>，这样他们可以呼叫你；<strong>listen函数是打开电话振铃，这样有一个外来呼叫时，你可以听到</strong>；<strong>connect函数要求我们知道对方的电话号码并拨打它；accept函数发生在被呼叫人应答电话时</strong>。由accept函数返回客户的标识（即客户的IP地址和端口号）类似于让电话机的呼叫者ID功能部件显示呼叫者的电话号码，然而两者不同之处在于accept函数只在连接建立后返回客户的标识，而呼叫者ID功能部件却在我们选择应答或不应答电话前显示呼叫者电话号码。域名系统DNS，提供类似于电话簿的服务，getaddrinfo函数类似于在电话簿中查找某个人的电话号码，getnameinfo则类似有一本按照电话号码而非用户名排序的电话簿，这样就能通过电话号码查找用户名。</p><p>以下是常用TCP选项：<br>1.MSS选项<strong>：发送SYN的TCP一端使用此选项通告对端它的最大分节大小（MSS，Maximum Segment Size），即发送的一端在本连接的每个TCP分节中愿意接受的最大数据量。</strong>发送端TCP使用接收端MSS值作为所发送分节的最大大小。可使用TCP_MAXSEG套接字选项提取和设置这个TCP选项。</p><p>2.窗口规模选项：<strong>TCP连接任何一端能通告对端的最大窗口大小是65535，因为在TCP首部中相应字段占16位。然而如今因特网上已普及高速网络连接（45Mbit/s或更快）或长延迟路径（卫星链路），要求有更大的窗口以获得尽可能大的吞吐量。这个新选项指定TCP首部中的通告窗口扩大的位数（0~14），因此提供的最大窗口为1GB（65535 * 214）</strong>。套接字选项SO_RCVBUF可影响此TCP选项。为提供与不支持此选项的较早实现的互操作性，需应用以下规则：TCP可将该选项随主动打开的SYN发送，但只有在对端也随它的SYN发送该选项时，它才扩大自己的窗口规模。类似地，服务器的TCP只有接收到随客户的SYN到达的该选项时，才能发送该选项。本逻辑假定实现忽略它们不理解的选项，大多实现都会忽略，但无法保证所有实现都忽略。</p><p>3.时间戳选项：该选项对于高速网络连接是必要的，它可以防止失而复现的分组可能造成的数据破坏（高速网络中32位序列号短时间内就可能循环一轮重新使用，如不使用该选项，可能失而复现的分节会与再次使用相同序列号的真正分节发生混淆）。它是一个较新的选项，也以类似窗口规模选项的方式协商处理。作为网络编程人员，我们无需考虑这个选项。</p><p>大多TCP实现都支持这些常用选项，后两个选项也称RFC 1323选项，因为它们是在RFC 1323中说明的。既然高带宽或长延迟的网络（时延带宽积大）被称为长胖管道，这两个选项也称为长胖管道选项。</p><p>终止一个TCP连接需4个分节：<br>1.某个应用进程先调用close，我们称该端为主动关闭。该端的TCP于是发送一个FIN分节，表示发送完毕。</p><p>2.接收到这个FIN的对端执行被动关闭，接收到的这个FIN由TCP确认，一个文件结束符也会传递给接收端应用进程（放在该应用进程的接收缓冲区末尾），因为FIN的接收意味着接收端应用进程在相应连接上再无额外数据可接收。</p><p>3.一段时间后，接收到这个文件结束符的应用将调用close关闭它的套接字，这导致它的TCP也发送一个FIN。</p><p>4.接收这个最终FIN的原发送端TCP确认这个FIN。</p><p>以上过程通常是4个分节，以下情况例外：步骤1的FIN随数据一起发送；步骤2和步骤3发送的分节可能被合并成一个分节。</p><p><img src="f0b196b872c34051b0f695ebc22e9efa.png" alt="在这里插入图片描述"></p><p>​        在步骤2和步骤3之间，从执行被动关闭端到执行主动关闭端进行数据流动是可能的，这称为半关闭。</p><p>​        一个Unix进程无论自愿地（调用exit或从main函数返回）还是非自愿地（收到一个终止本进程的信号）终止，所有打开的描述符都会关闭，会导致仍然打开的TCP连接上发出一个FIN。</p><p>​        无论是客户还是服务器都可以执行主动关闭，通常情况下是客户执行主动关闭，但某些协议（HTTP/1.0）由服务器执行主动关闭。</p><p>​        TCP涉及连接建立和连接终止的操作可以用状态转换图说明：</p><p>​        TCP为一个连接定义了11种状态，且TCP规定了如何基于当前状态及在该状态下所接收的分节从一个状态转换为另一个状态。如某应用在CLOSED状态下执行主动打开，TCP将发送一个SYN，进入新的状态SYN_SENT，如果这个TCP接着收到一个带ACK的SYN，它将发送一个ACK，进入新状态ESTABLISHED，ESTABLISHED状态是绝大多数数据传送发生的状态。</p><p>​        自ESTABLISH状态引出的两个箭头处理连接的终止，如果某个应用进程接收到一个FIN前调用close（主动关闭），则进入FIN_WAIT_1状态；如果某个进程在ESTABLISH状态期间接收到一个FIN（被动关闭），则进入CLOSE_WAIT状态。</p><p>​        上图用粗实线表示通常的客户状态转换，用粗虚线表示通常的服务器状态转换。上图还存在两个转换：同时打开（两端几乎同时发送SYN且这两个SYN在网络中交错）和同时关闭（两端几乎同时发送FIN），它们可能发生，但非常罕见。</p><p>​        netstat命令可显示连接处于以上11种TCP状态中的哪种。</p><p>​        完整的TCP连接所发生的实际分组交换情况，包括连接建立、数据传送、连接终止三阶段：</p><p><img src="b4a283bae17648fa940a22851bb13235.png" alt="在这里插入图片描述"></p><p>​        如上图，客户通告了一个值为536的MSS，表明客户只实现了最小重组缓冲区大小（ipv4为576字节，减去20字节的TCP首部和20字节的IP首部），而服务器通告了一个值为1460的MSS（以太网上的典型IPv4值）。两个方向上的MSS允许不同。</p><p>​        上图我们假设客户的请求可在单个TCP分节中发送（即请求大小小于服务器通告的1460字节），服务器处理该请求并发送一个应答，我们也假设了应答的大小小于536字节，且服务器对客户请求的确认是伴随其应答发送的，这称为捎带，它通常在服务器处理请求并产生应答的时间少于延迟确认的时间时发生，如果服务器耗用更长时间，我们将看到先确认后应答。</p><p>​        执行主动关闭的一端会进入TIME_WAIT状态。</p><p>​        上图中，仅仅是发送一个单分节的请求和接收一个单分节的应答，使用TCP有8个分节的开销，如果改用UDP，只需交换两个分组。然而从TCP切换到UDP将丧失TCP提供给应用进程的全部可靠性，迫使可靠服务的细节从传输层TCP转移到UDP应用进程。TCP提供的拥塞控制也必须由UDP应用进程来处理。尽管如此，很多网络应用是用UDP的，因为这些应用交换的数据量较少，UDP避免了TCP连接建立和终止所需的开销。</p><p>​        停留在TIME_WAIT状态的时长是最长分节生命期（MSL，Maximum Segment Lifetime）的两倍，有时称之为2MSL。</p><p>​        任何TCP实现都要为MSL选择一个值，RFC 1122的建议值是2分钟，但源自Berkeley的实现取值为30秒，这意味着TIME_WAIT状态的持续时间在1分钟到4分钟之间。MSL是任何IP数据报能在因特网中存活的最长时间，这个时间是有限的，因为每个数据报都有一个称为跳限（hop limit）的8位字段，它的最大值为255，尽管这是一个跳数限制而非真正时间限制，我们仍假设具有最大跳限255的分组在网络中存在的时间不可能超过MSL秒。</p><p>​        分组在网络中迷途通常是路由异常的结果，某个路由器崩溃或两个路由器间的链路断开时，路由协议会花数秒到数分钟时间才能稳定找出另一条通路，这段时间内可能发生路由循环（路由器A把分组发给路由器B，而B又将其发给A）。假设迷途的分组是一个TCP分节，在它迷途期间，发送端TCP超时并重传该分组，而重传分组通过某条候选路径到达目的地，不久后（自迷途分组开始其旅程起最多MSL秒内）路由循环恢复，早先迷失在循环中的分组最终也被送到目的地，这个原来的分组称为迷途的重复分组或漫游的重复分组。TCP必须正确处理这些分组。</p><p>TIME_WAIT状态存在的理由：<br>1.可靠地实现TCP全双工连接的终止。当被动关闭的一端发送了FIN后，主动关闭端会发送最终的ACK，如果这个ACK丢失了，被动关闭端会重发这个FIN。如果主动关闭端不维护状态信息，再次收到FIN后，将响应一个RST，该分节将被被动关闭端解释为一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭），它必须正确处理连接终止序列4个分节中任何一个丢失的情况。这也说明了为什么主动关闭的一端才需要TIME_WAIT状态，因为要重传最后一个FIN的ACK。</p><p>2.允许老的重复分节在网络中消逝。我们假设在12.106.32.254的1500端口和206.168.112.219的21端口之间有一个TCP连接，我们关闭这个连接，一段时间后在相同IP和端口间建立另一个连接。后一个连接称为前一个连接的化身，因为它们的IP和端口号都相同。TCP必须防止来自某连接的老的重复分组在该连接已终止后再现，从而被误解成属于同一连接的某个新的化身，为此，TCP将不给处于TIME_WAIT状态的连接发起新的化身。TIME_WAIT状态持续时间是MSL的2倍，这足以让某方向上的分组存活MSL秒后被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。</p><p>以上第二点有一个例外，如果处于TIME_WAIT状态时，接收到SYN序号大于前一化身的结束序列号，源自Berkeley的实现将无需等待TIME_WAIT状态结束就启动新的化身。它要求服务器执行主动关闭，因为接收第一个SYN的一端需要处于TIME_WAIT状态。</p><p>SCTP也是面向连接的，因此也有关联的建立与终止的握手过程。</p><p>SCTP关联时的过程：<br>1.服务器必须准备好接受外来关联，通常通过调用socket、bind、listen完成，称为被动打开。</p><p>2.客户通过调用connect或发送一个隐式打开该关联的消息进行主动打开。这使得客户SCTP发送一个INIT消息（表示初始化），该消息告诉服务器客户的IP地址清单、初始序列号（用于数据包排序和流控制）、用于识别此关联中所有数据包的初始化标签（initiation tag，每个关联都有自己唯一的初始化标签，且会用于每个SCTP包中，作用是识别前一个关联中的过期的包）、客户请求的外出流的数目、客户能够支持的外来流的数目。</p><p>3.服务器以一个INIT ACK确认客户的INIT消息，其中包含服务器的IP地址清单、初始序列号、初始化标签、服务器请求的外出流数目、服务器能支持的外来流数目、一个状态cookie。状态cookie包含服务器用于确信本关联有效所需的所有状态，它是数字化签名过的（指使用非对称加密算法对数据进行加密哈希处理以确保数据的完整性和验证身份的过程），以确保有效性。</p><p>4.客户把一个COOKIE ECHO消息发到服务器，其中包含第3步中服务器发送的状态cookie，该消息可能在同一个分组中捆绑了用户数据。</p><p>5.服务器以一个COOKIE ACK消息确认客户回射的cookie是正确的，本关联于是确立，该消息可能在同一个分组中捆绑了用户数据。</p><p><img src="df2bceb1e53d46868b42910e3dde066b.png" alt="在这里插入图片描述"></p><p>上图中，客户的INIT中包含一个验证标记Ta和一个初始序列号J以及其他众多参数，在关联有效期内，验证标记必须在服务器发送的每个分组中出现。初始序列号J用作承载用户数据的DATA块的起始序列号。服务器也在INIT ACK中承载一个验证标记Tz，关联有效期内，验证标记Tz也必须在客户发送的每个分组中出现。cookie中包含设置本SCTP关联所需的所有信息，这样服务器SCTP栈就不必保存所关联客户的有关信息。</p><p>四路握手结束时，两端会各自选择一个主目的地址，当不存在网络故障时，主目的地址将用作数据要发送到的默认目的地。</p><p>TCP中的SYN洪泛攻击是指，攻击者向目标服务器发送大量的伪造源IP地址的TCP连接请求（SYN包），但不完成握手过程，从而消耗服务器的资源，导致服务器无法处理正常的连接请求。在TCP中，SYN洪泛攻击是一种常见的DoS（Denial of Service，拒绝服务）攻击方式。</p><p>SCTP使用cookie的四路握手形成了一种防护以上TCP的拒绝服务攻击的方法，即在第一次握手过程中，服务器不会为每个收到的INIT报文都创建一个连接状态，而是生成一个Cookie作为回应，该Cookie包含了客户端的信息和服务器的状态，并且只有在客户端发送合法的COOKIE ECHO报文时，服务器才会将其解析并创建连接状态，这种Cookie机制的好处是，服务器可以在不创建连接状态的情况下，有效地抵御大规模的SYN洪泛攻击。因为服务器只需要验证COOKIE ECHO报文是否合法，而无需为每个未完成的连接请求消耗资源。TCP的许多实现也用类似的方法（SYN cookie，不是TCP标准中的内容，用的较少），区别在于，TCP中cookie状态必须编码到只有32位长的初始序列号中，SCTP为此提供了一个任意长的字段，并且要求实施基于加密的安全性以防护攻击。</p><p>SCTP不允许TCP那样的半关闭，当一端关闭某个关联时，另一端必须停止发送新数据。关联关闭请求的接收端发送完已经排队的数据（如果有）后，完成关联的关闭。</p><p><img src="2e192e47334c44a39cb7ac691065a7b9.png" alt="在这里插入图片描述"></p><p>SCTP没有类似于TCP的TIME_WAIT状态，因为SCTP使用了验证标记，所有后续块所在的SCTP分组的公共首部中都有来自初始INIT块和INIT ACK块中作为起始标记交换的验证标记。来自旧连接的块所在的SCTP分组的公共首部携带的验证标记对于新连接来说是不正确的。</p><p>SCTP状态转换图：</p><p><img src="7582032a4e3f4e31a2e1f27cd10b7d2b.png" alt="在这里插入图片描述"></p><p>​        如上图，本状态机（一个状态机由一组状态和状态之间的转换组成）中从一个状态到另一个状态的转换由SCTP规则基于当前状态及在该状态下所接收的块规定。当某个应用进程在CLOSED状态下执行主动打开时，会发送一个INIT，进入状态COOKIE_WAIT，接着如果收到一个INIT ACK，它将发送一个COOKIE ECHO，进入状态COOKIE-ECHOED，随后收到一个COOKIE ACK时，进入状态ESTABLISHED。ESTABLISHED状态是绝大多数数据传送发生的状态，有些DATA块也可以由COOKIE ECHO块或COOKIE ACK块所在消息捆绑捎带。</p><p>​        上图中，从ESTABLISHED状态引出两个箭头处理关联的终止。如果某应用进程在接收到一个SHUTDOWN前调用close，就转换到SHUTDOWN-PENDING状态；如果某进程在ESTABLISHED状态期间收到一个SHUTDOWN，就转换到SHUTDOWN-RECEIVED状态。</p><p><img src="e2dca99db8854415be4100eb8d5fe910.png" alt="img"></p><p>​        上图中，客户在COOKIE ECHO块所在分组中捎带了它的第一个DATA块，服务器在作为应答的COOKIE ACK块所在分组中捎带了数据。一般，当网络应用采用一到多接口式样时，COOKIE ECHO通常捎带一个或多个DATA块。</p><p>​        SCTP分组中信息的单位称为块。块是自描述的，包含一个块类型、若干个块标记、一个块长度。这样方便了多个块的绑缚，只要把它们简单地组合到一个SCTP外出消息中。</p><p>​        SCTP使用参数和块来方便增设可选特性，新特性通过添加这两个条目之一加以定义，并允许通常的SCTP处理规则汇报未知的参数和未知的块。参数类型和块类型的高两位指明SCTP接收端该如何处置未知的参数或未知的块。</p><p>当前如下两个对SCTP的扩展正在开发中：<br>1.动态地址扩展：允许协作的SCTP端点从已有的某个关联中动态增删IP地址。</p><p>2.不完全可靠性扩展：允许协作的SCTP端点在应用进程指导下限制数据的重传，当一个消息变得陈旧而无需发送时（由应用进程指导），该消息被跳过而不再被发到对端。这意味着不是所有数据都确保到达关联的另一端。</p><h2 id="端口划分"><a href="#端口划分" class="headerlink" title="端口划分"></a>端口划分</h2><p>​        TCP、UDP、SCTP这三种协议都使用16位整数的端口号来区分进程。</p><p>​        TCP、UDP、SCTP定义了一组众所周知端口，用于标识众所周知的服务，如支持FTP的任何TCP/IP实现都把端口21作为众所周知端口分配给FTP服务器。分配给简单文件传送协议（FTFP，Trivial File Transfer Protocol）的UDP端口号是69。</p><p>​        客户通常使用短期有效的临时端口，这些端口号通常由传输层协议自动赋予客户，客户通常不关心端口的具体值，只需确认该端口在所在主机中是唯一的即可。传输协议的代码确保这种唯一性。</p><p>​        IANA（因特网已分配数值权威机构，the Internet Assigned Numbers Authority）维护着一个众所周知端口号分配的清单，该清单作为RFC多次发布，RFC 1700是这个系列最后一个。</p><p>​        端口号被划分为以下3段：<br>1.众所周知端口0~1023：这些端口由IANA分配和控制。可能的话，相同端口号就分配给TCP、UDP、SCTP的同一给定服务，如不论TCP还是UDP端口号80都被赋予web服务器（http服务），尽管它的目前所有实现都单纯使用TCP。端口号80分配时SCTP尚不存在，新分配的端口将针对这三种协议执行，RFC 2960声明所有现有的TCP端口号对于使用SCTP的同一服务同样有效。</p><p>2.已登记的端口1024~49151：这些端口不受IANA控制，但由IANA登记并提供它们的使用清单，可能的话，相同端口号也分配给TCP和UDP的同一给定服务，如6000~6063分配给这两种协议的X Window服务器，尽管它的所有实现当前单纯使用TCP。上限49151是为了给临时端口留出范围。</p><p>3.动态端口或私有端口49152~65535：IANA不管这些端口，它是我们所称的临时端口。49152是65536的四分之三。</p><p><img src="04cb922ee520408fa90d4b506d2c6e33.png" alt="在这里插入图片描述"></p><p>对于上图需注意以下几点：</p><ol><li><p>Unix系统保留端口（reserved port）指的是小于1024的端口，这些端口只能赋予特权用户进程的套接字。所有IANA众所周知端口都是保留端口，使用这些端口的服务器必须以超级用户特权启动。</p></li><li><p>由于历史原因，源自伯克利的实现从BSD 4.3开始曾在1024~5000范围内分配临时端口，这在20世纪80年代初始可行的，但如今很容易找到同时支持多于3977个连接的主机，于是许多较新系统从另外的范围分配临时端口以提供更多临时端口，它们或者使用IANA定义的临时端口范围，或者使用一个更大的其他范围（如上图的Solaris）。由于这个原因许多较早系统的临时端口上限为5000，后来发现5000这一上限是一个排版错误，本应是50000。</p></li><li><p>有少数客户需要一个保留端口用于客户/服务器认证，如rlogin和rsh客户，这些客户调用库函数rresvport创建一个TCP套接字，并赋予它一个在513~1023范围内未使用的端口，该函数通常先尝试绑定1023，若失败尝试1022，依次类推，直到在端口513。</p></li></ol><p>​        BSD的保留端口和rresvport函数返回的端口都跟IANA众所周知端口有所重叠，这是因为IANA众所周知端口早先上限为255，1992年的RFC 1340开始在256~1023之间分配众所周知端口。1990年的RFC 1060称256~1023之间的端口是Unix标准服务。20世纪80年代不少源自Berkeley的服务器在512以后挑选它们的众所周知端口，留下了256~511这个空档。</p><p>​        一个TCP连接的套接字对指定义该连接的两个端点的四元组：本地IP地址、本地TCP端口号、外地IP地址、外地TCP端口号。套接字对唯一标识一个网络上的每个TCP连接。SCTP一个关联由一组本地IP地址、一个本地端口、一组外地IP地址、一个外地端口标识，在两个端点均非多宿的情况下，SCTP与TCP所用的四元组一致，在某个关联任何一端多宿时，同一关联需要多个四元组标识（这些四元组的多宿一端的IP各不相同，但端口号都是一样的）。</p><p>​        标识每个端点的两个值（IP地址和端口号）通常称为一个套接字。我们可以把套接字的概念扩展到UDP，即使UDP是无连接的。</p><p>​        并发服务器中主服务器循环通过派生一个子进程来处理每个新的连接，子进程可以继续使用服务器众所周知端口来服务一个长时间请求。可能发生以下序列：首先，在主机freebsd上启动服务器，该主机是多宿的，其IP地址为12.106.32.254和192.168.42.1，服务器在众所周知端口21上执行被动打开，从而等待客户请求，如图：</p><p><img src="63a2f5293eb34592a73695582c7c98d7.png" alt="在这里插入图片描述"></p><p>​        上图中<em>:21, \</em>:*指出服务器的套接字对，服务器在任意本地接口的端口21上等待连接请求，外地IP地址和外地端口都没有指定。我们称它为监听套接字。</p><p>​        以上指定本地IP地址的星号称为通配符，如果运行服务器的主机是多宿的，服务器可以指定它只接受到达某个本地接口的外来连接，这里要么选一个接口要么选任意接口。通配地址通过将套接字地址结构中的IP地址字段设为INADDR_ANY指定。</p><p>​        在206.168.112.219主机上启动一个客户，它对服务器的IP地址之一12.106.32.254指定主动打开，我们假设本例的客户主机TCP选择的临时端口为1500：当服务器接收并接受这个客户的连接时<strong>，它fork一个自身的副本，让子进程来处理该客户的请求。</strong></p><p>​        至此，我们要在服务器主机上区分监听套接字和已连接套接字，这两个套接字都使用相同本地端口21。在多宿主机上，连接一旦建立，已连接套接字的本地地址12.106.32.254随即填入四元组：</p><p><img src="aac62918f0ae4df3a0fea49c3a2705a5.png" alt="在这里插入图片描述"></p><p>下一步假设在客户主机上另有一个客户请求连接到同一服务器。客户主机的TCP为新客户的套接字分配一个未使用的临时端口，假设是1501：</p><p><img src="a7197b112278446c97444c363c2f3b95.png" alt="在这里插入图片描述"></p><p>上图中，服务器上这两个连接是有区别的，第一个连接的套接字对和第二个连接的套接字对不一样。</p><p>通过上例可知，TCP无法仅仅通过查看目的端口号来决定把TCP报文递交给哪个套接字，必须查看套接字对的所有4个元素才能确定由哪个端点接收某个到达的分节。上图中同一端口21存在3个套接字，如果一个分节来自206.168.112.219:1500，目的地为12.106.32.254:21，它就被递送给第一个子进程；如果一个分节来自206.168.112.219:1501，目的地为12.106.32.254:21，它就被递送给第二个子进程。所有目的端口为21的其他TCP分节都被递送给拥有监听套接字的服务器父进程。</p><p>影响IP数据报大小的限制：</p><ol><li><p>IPv4数据报的最大大小是<strong>65535</strong>字节，包括IPv4首部，这是因为IPv4首部总长度字段是16位。</p></li><li><p>IPv6数据报的最大大小是<strong>65575</strong>字节，包括40字节的IPv6首部，这是因为IPv6净荷长度字段（不包括IPv6首部）是16位，加上40字节的首部，即65575字节。IPv6有一个特大净荷选项，它把净荷长度字段扩展到32位，但这个选项需要MTU（最大传输单元，Maximum Transmiision Unit）超过65535的数据链路提供支持。</p></li><li><p>许多网络有可由硬件规定的MTU，如以太网MTU为1500字节；一些链路（如使用PPP协议的点到点链路）其MTU可人为配置；较老的SLIP链路通常使用1006字节或296字节的MTU。IPv4要求的最小链路MTU是68字节，这允许最大的IPv4首部（包括20字节的固定长度、最多40字节选项）和最小的拼接片段（IPv4首部中片偏移字段以8个字节为单位，片偏移字段含义为每个分片相对于原始报文开头的偏移量，即每个分片的长度必须是8字节的整数倍）。IPv6要求的最小链路MTU为1280字节，IPv6可运行在MTU小于此值的链路上，不过需要链路的分片和重组功能，以使得这些链路看起来至少有1280字节。</p></li><li><p>两个主机之间的路径中最小的MTU称为路径MTU。1500字节的以太网MTU是当今常见的路径MTU。两个主机间相反的两个方向上路径MTU可以不一致，因为因特网中路由选择往往是不对称的。</p></li><li><p>当一个IP数据报从某个接口送出时，如果它的大小超过相应链路的MTU，IPv4和IPv6都将执行分片，这些片段到达最终目的地前通常不会重组。IPv4主机对其产生的数据报执行分片，IPv4路由器对其转发的数据报执行分片；然而IPv6只有主机对其产生的数据报执行分片，IPv6路由器不对其转发的数据报执行分片。一个标记为IPv6的路由器设备可能执行分片，不过只是对于由它产生的那些数据报，此时该设备实际作为主机运作，如大多路由器支持telnet协议，管理员用它来配置路由器，由路由器的telnet服务器产生的IP数据报是由路由器产生的，而不是由路由器转发的。IPv4首部有用于处理分片的字段，而IPv6首部没有类似字段，既然分片是例外而非通常情况，IPv6于是引入一个可选首部以提供分片信息。某些通常用作路由器的防火墙可能会重组分片了的分组，以便查看整个IP数据报的内容，这样使得不必在防火墙上引入额外的复杂性就能防止某些攻击，它还要求防火墙设备是进出网络的唯一路径上的设备。</p></li><li><p>IPv4首部的不分片位（DF位，don’t fragment）若被设置，那么无论是主机还是路由器都不允许对它分片。当路由器接收到一个超过其外出链路MTU大小且设置了DF位的IPv4数据报时，它将产生一个ICMPv4目的地不可达出错消息。由于IPv6路由器不执行分片，每个IPv6于是隐含一个DF位，当IPv6收到一个超过其外出链路MTU大小的IPv6数据报时，它产生一个ICMPv6分组太大出错消息。IPv4的DF位和IPv6的隐含DF位可用于路径MTU发现，如果基于IPv4的TCP使用该技术，那么它将在所有发送的数据报中设置DF位，如果某个中间路由器返回ICMP目的地不可达错误，TCP就减小每个数据报的数据量并重传。路径MTU发现对于IPv4是可选的，但对于IPv6的所有实现要么支持它，要么必须总使用最小的MTU发送IPv6数据报。路径MTU发现在如今的因特网上有问题，许多防火墙丢弃所有ICMP消息，这意味着TCP永远得不到要求它降低所发送数据量的信号，IETF（Internet Engineering Task Force，互联网工程任务组）已经开始尝试定义不依赖于ICMP出错消息的另一种路径MTU发现方法。</p></li><li><p>IPv4和IPv6都定义了<strong>最小重组缓冲区大小</strong>，<strong>它是IPv4或IPv6的任何实现都必须保证支持的最小数据报大小。其值对于IPv4为576字节，对于IPv6为1500字节。</strong>例如，就IPv4而言，我们不能判定某个给定目的地能否接受577字节的数据报，为此许多使用UDP的IPv4网络应用（如DNS、RIP、TFTP、BOOTP、SNMP（简单网络管理协议））避免产生大于这个大小的数据报。</p></li><li><p>TCP有一个最大分节大小（MSS，Maximum Segment Size），用于向对端TCP通告对端在每个分节中能发送的最大TCP数据量。MSS的目的是告诉对端自己的重组缓冲区大小的实际值，从而试图避免分片，如果自己的重组缓冲区大小大于外出接口MTU，MSS经常设为MTU减去IP和TCP首部的固定长度，在以太网中IPv4的MSS值为1460，IPv6的MSS值为1440（两者的TCP首部都是20个字节，但IPv4首部是20字节，IPv6首部却是40字节）。TCP的MSS选项的值是一个16位的字段，限定了其最大值为65535，这对于IPv4是合适的，因为IPv4数据报中的最大TCP数据量为65495（65535字节的IPv4数据报总长度减去20字节IPv4首部和20字节TCP首部），而对于具有特大净荷选项的IPv6，需要另一种技巧，即在用到特大净荷选项时，将65535这个MSS值视为表示无限的特殊值，如果接收到的数据报使用了特大净荷选项且收到对端通告的MSS为65535，则接收端所发送数据报的大小限制就是路径MTU，路径MTU发现功能将确定此值。如果没有特大净荷选项，IPv6数据报中的最大TCP数据量为65515（65535字节的IPv6数据报净荷减去20字节TCP首部）。</p></li><li><p>SCTP基于到对端的所有地址发现的最小MTU作为分片点，这个最小MTU大小用于把较大的用户消息分割成较小的能够以单个IP数据报发送的若干片段。SCTP_MAXSEG套接字选项可以使用户请求一个更小的分片点。</p></li></ol><p><img src="ebed11d016bf48588a8e91e78a9389c7.png" alt="在这里插入图片描述"></p><p>​        每个TCP套接字都有一个发送缓冲区，我们可以用套接字选项SO_SNDBUF来更改该缓冲区大小。当应用调用write时，内核从该应用的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据，该应用将被投入睡眠，这里假设了该套接字是阻塞的，它是通常的默认设置。内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区。因此从写一个套接字的write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，不代表对端TCP或应用已接收到数据。</p><p>​        发送端TCP提取套接字缓冲区中的数据并把它发送给对端TCP，对端TCP必须确认收到的数据，收到对端的ACK后，本端TCP才能从套接字发送缓冲区丢弃已确认的数据，因为TCP必须为已发送的数据保留一个副本，直到它被对端确认为止。</p><p>​        发送端TCP以MSS大小或更小的块把数据传递给IP，同时给每个数据块安上一个TCP首部以构成TCP分节，其中MSS或是对端通告的值，或是536（对端未发送MSS选项时，536是IPv4最小重组缓冲区字节数576减去20字节IPv4首部和20字节TCP首部的结果）。IP给每个TCP分节安上一个IP首部以构成IP数据报，并按照其目的IP地址查找路由表确定外出接口，然后把数据报传递给相应的数据链路。IP可能在把数据报传递给数据链路前将其分片，但之前说过MSS选项的目的之一就是试图避免分片，因此发送端没有意外的情况下IP不会在把数据报传递给链路层时进行分片，并且较新的实现还使用了路径MTU发现功能（可能会导致MSS比外出接口的MTU更小，从而更不可能导致发送端IP把数据报传递给链路层时分片）。每个数据链路都有一个输出队列，如果该队列已满，则新到的分组将被丢弃，并沿协议栈向上返回一个错误，TCP将注意到此错误，并在以后重传相应分节，应用并不知道这种暂时的情况。</p><p><img src="17b8560a7e8249468cf884f4631b5744.png" alt="在这里插入图片描述"></p><p>​        如上图，用虚线展示套接字发送缓冲区，因为它实际上并不存在。任何UDP套接字都有发送缓冲区大小，可用套接字选项SO_SNDBUF更改它，但它仅仅是可以写到该套接字的UDP数据报的大小上限，如果应用进程写一个大于套接字发送缓冲区大小的数据报，内核将返回该进程一个EMSGSIZE错误。既然UDP是不可靠的，它不必保存应用进程数据的副本，因此无需一个真正的发送缓冲区。应用进程的数据在沿协议栈向下传递时，通常被复制到某种格式的一个内核缓冲区中，当该数据被发送后，这个副本就被数据链路层丢弃了。</p><p>​        发送端UDP简单地给来自用户的数据报安上它的8字节首部以构成UDP数据报，然后传递给IP，IPv4或IPv6给数据报安上相应IP首部以构成IP数据报，然后执行路由操作确定外出接口，然后或者直接把数据报加入数据链路层输出队列（如果MTU合适），或者分片后再把每个片段加入数据链路层的输出队列。如果某个UDP应用进程发送大数据报（如2000字节的数据报），那么相比TCP应用更可能被IP分片，因为TCP会把应用数据划分成MSS大小的块。</p><p>​        从写一个UDP套接字的write调用成功返回表示所写的数据报或其所有片段已被加入数据链路层的输出队列，如果该队列没有足够空间存放该数据报或它的某个片段，内核通常会返回一个ENOBUFS错误给它的应用进程，但有些UDP实现不返回这种错误，这样数据报未经发送就被丢弃的情况应用也不知道。</p><p><img src="4f1b5fe2d98b4d369f28b69a54fac7be.png" alt="在这里插入图片描述"></p><p>​        SCTP是与TCP类似的可靠协议，因此它的套接字也有一个发送缓冲区，而且也可以用套接字选项SO_SNDBUF更改这个缓冲区大小。当一个应用进程调用write时，内核从该应用的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据，应用进程将被投入睡眠，这里假设该套接字是阻塞的，它是通常的默认设置。内核直到应用进程缓冲区中的所有数据都复制到套接字缓冲区才从write函数返回。因此从写一个SCTP套接字的write调用成功返回仅表示我们可以重新使用原来的应用进程缓冲区，不表明对端SCTP或应用进程已接收到数据。</p><p>​        发送端SCTP发送完数据后，必须等待SACK，在累计确认点超过已发送的数据后，才可以从套接字缓冲区中删除该数据。</p><p><img src="3716c09ec35b4d5b9697e42ffc15a9b7.png" alt="在这里插入图片描述"></p><p>​        上图是TCP/IP多数实现都提供的服务，表中所有服务同时使用TCP和UDP，且这两个协议所用端口号也相同。</p><p>​        以上服务通常由Unix主机的inetd守护进程提供，可用telnet程序访问以上服务：</p><p>​        上例中，我们键入了主机名和服务名，这些服务名通过/etc/services文件映射到对应端口号。</p><p><img src="f4d761418adb40f88640ba6b4527ef8c.png" alt="在这里插入图片描述"></p><p>​        上例中连接到daytime服务器时是服务器执行主动关闭，而连接到echo服务器时是客户执行主动关闭。主动关闭的一方会进入TIME_WAIT状态。</p><p>​        上例中，当输出Trying IP…时，gethostbyname函数已返回了域名对应的IP地址，客户在此之前的停顿是解析器用于查找主机名的时间。输出Connected to host时意味着connect函数已返回，这两行输出间的停顿是connect函数用来建立连接的时间。</p><p>​        为了应对针对以上服务的拒绝服务攻击和其他资源使用攻击，如今的系统中，这些简单的服务通常被禁用。</p><p>​        常见因特网应用使用的协议：</p><p><img src="3ea4ae656f8844eb953ea40cafbf032e.png" alt="在这里插入图片描述"></p><p>​        ping和traceroute是使用ICMP协议实现的网络诊断应用。traceroute自行构造UDP分组来发送并读取所引发的ICMP应答。路由协议OSPF通过原始套接字直接使用IP，RIP使用UDP，BGP使用TCP。</p><p>​        TIME_WAIT状态是为了实现TCP的全双工连接终止（处理最终那个ACK丢失的情形），并允许老的重复分节从网络中消逝。IP协议版本1~3未曾分配。版本5是网际网流协议，由Apple、NEXT和SunMicroystems为试验流式语音和视频而创建。RFC可通过电子邮件、匿名FTP、Web（<a href="https://www.rfc-editor.org/rfc/）免费获取。如果TCP一端没有收到对端的MSS选项，默认MSS值取536字节大小，因为IPv4的最小重组缓冲区大小是576字节，减去20字节的TCP首部和20字节的IP首部，就是536字节。在一个以太网上的主机和一个令牌环网上的主机之间建立一个连接，其中以太网上主机的TCP通告的MSS为1460，令牌环网上主机的TCP通告的MSS为4096，两个主机都没有实现路径MTU发现功能，对于令牌环网上的主机来说，不能发送超过1460字节的数据，因为它接收到的MSS是1460，对于以太网上的主机来说，可以发送4096字节的数据，但为了避免分片，它不会超过其外出接口的MTU（即以太网的1460）。">https://www.rfc-editor.org/rfc/）免费获取。如果TCP一端没有收到对端的MSS选项，默认MSS值取536字节大小，因为IPv4的最小重组缓冲区大小是576字节，减去20字节的TCP首部和20字节的IP首部，就是536字节。在一个以太网上的主机和一个令牌环网上的主机之间建立一个连接，其中以太网上主机的TCP通告的MSS为1460，令牌环网上主机的TCP通告的MSS为4096，两个主机都没有实现路径MTU发现功能，对于令牌环网上的主机来说，不能发送超过1460字节的数据，因为它接收到的MSS是1460，对于以太网上的主机来说，可以发送4096字节的数据，但为了避免分片，它不会超过其外出接口的MTU（即以太网的1460）。</a></p><p>​        IPv4首部有一个协议字段，对于直接使用IP层的OSPF，该字段值为IANA注册的OSPF协议号，值为89。</p><p>​        SCTP发送端必须等待累计确认点已经超过已发送的数据，才能从套接字缓冲区中释放该数据，假设某个选择性确认（SACK）表明累计确认点之后的数据得到了确认，这样的数据不能被释放，因为选择性确认只是表明由选择性确认消息反映的序列号所涵盖的数据已被接收，而累计确认表明由累计确认消息中的序列号指示的所有该序列号以前的数据都已被接收。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux漫游——文件IO操作</title>
      <link href="/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux漫游-文件-I-O：通用的-I-O-模型"><a href="#Linux漫游-文件-I-O：通用的-I-O-模型" class="headerlink" title="Linux漫游- 文件 I/O：通用的 I/O 模型"></a>Linux漫游- 文件 I/O：通用的 I/O 模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        我们下面开始正式的开启Linux系统编程之路。我们首先解决一个问题——那就是我们如何对文件进行IO操作呢？本章就是解决这个问题的。Unix-Linux由一套通用的IO操作方法，这让我们可以通用的视一切为文件进行操作</p><p>​        首先，我们需要拿到文件——在系统编程中，我们以<strong>文件描述符</strong>来代表文件。有三个文件描述符，总是被分配且有自己特殊的含义的。那就是标准IO流</p><div class="table-container"><table><thead><tr><th>文件描述符</th><th>用途</th><th>POSIX名称</th><th>stdio流</th></tr></thead><tbody><tr><td>0</td><td>标准输入</td><td><code>STDIN_FILENO</code></td><td><code>stdin</code></td></tr><tr><td>1</td><td>标准输出</td><td><code>STDOUT_FILENO</code></td><td><code>stdout</code></td></tr><tr><td>2</td><td>标准错误</td><td><code>STDERR_FILENO</code></td><td><code>stderr</code></td></tr></tbody></table></div><p>​        在程序中指代这些文件描述符时，可以使用数字（0、1、2）表示，或者采用<unistd.h>所定义的 POSIX 标准名称—此方法更为可取。</p><p>​        虽然 stdin、stdout 和 stderr 变量在程序初始化时用于指代进程的标准输入、标准输出和标准错误，但是调用 freopen()库函数可以使这些变量指代其他任何文件对象。作为其操作的一部分，freopen()可以在将流（stream）重新打开之际一并更换隐匿其中的文件描述符。换言之，针对 stdout 调用 freopen()函数后，无法保证 stdout 变量值仍然为 1。（不建议使用具体的数字而是预定义变量！）</p><h2 id="四个主流的IO操作"><a href="#四个主流的IO操作" class="headerlink" title="四个主流的IO操作"></a>四个主流的IO操作</h2><p>​        我们操作文件，首先就是——拿到文件（open），读文件（read），写文件(write)，把文件关了（是不是很像你编写word文档那样？）</p><ul><li>fd = open(pathname, flags, mode) 函数打开 pathname 所标识的文件，并返回文件描述符，用以在后续函数调用中指代打开的文件。<strong>如果文件不存在，open()函数可以创建之，这取决于对位掩码参数 flags 的设置。</strong>flags 参数还可指定文件的打开方式：<strong>只读、只写亦或是读写方式。mode 参数则指定了由 open()调用创建文件的访问权限，如果 open()函数并未创建文件，那么可以忽略或省略 mode 参数。</strong></li><li>numread = read(fd, buffer, count) 调用从 fd 所指代的打开文件中读取至多 count 字节的数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节可读（例如：读到文件结尾符 EOF 时），则返回值为 0。</li><li>numwritten = write(fd, buffer, count) 调用从 buffer 中读取多达 count 字节的数据写入由fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可能小于 count。</li><li>status = close(fd)在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及与之相关的内核资源。</li></ul><p>​        可以使用这些操作完成一个简单的cp程序</p><p><img src="image-20230803170335161.png" alt="image-20230803170335161"></p><p><img src="image-20230803170341322.png" alt="image-20230803170341322"></p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>​        open()调用既能打开一个业已存在的文件，也能创建并打开一个新文件。</p><pre class="line-numbers language-none"><code class="language-none">extern int open (const char *__file, int __oflag, ...) __nonnull ((1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        要打开的文件由参数 pathname 来标识。<strong>如果 pathname 是一符号链接，会对其进行解引用。如果调用成功，open()将返回一文件描述符，用于在后续函数调用中指代该文件。</strong>若发生错误，则返回−1，并将 errno 置为相应的错误标志。参数 flags 为位掩码，用于指定文件的访问模式</p><pre class="line-numbers language-none"><code class="language-none">早期的 UNIX 实现中使用数字 0、1、2，而非表 4-2 中所列的常量名称。大多数现代UNIX 实现将这些常量定义为上述相应数字（以期与早期系统保持兼容）。由此可见，O_RDWR 并不等同于 O_RDONLY | O_WRONLY，后者（或组合）属于逻辑错误。(请务必注意！！！)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当调用 open()创建新文件时，位掩码参数 mode 指定了文件的访问权限。（SUSv3 规定，mode的数据类型 mode_t 属于整数类型。）</p><p>​        如果 open()并未指定 O_CREAT 标志，则可以省略 mode 参数。</p><div class="table-container"><table><thead><tr><th>访问模式</th><th>描述</th></tr></thead><tbody><tr><td><code>O_RDONLY</code></td><td>只读方式打开文件</td></tr><tr><td><code>O_WRONLY</code></td><td>只写方式打开文件</td></tr><tr><td><code>O_RDWR</code></td><td>以读写方式打开文件</td></tr></tbody></table></div><p><img src="image-20230803170532396.png" alt="image-20230803170532396"></p><p>​        如果调用 open()成功，必须保证其返回值为进程未用文件描述符中数值最小者。可以利用该特性以特定文件描述符打开某一文件。例如，如下代码序列就会确保使用标准输入（文件描述符 0）打开一文件。</p><p><img src="image-20230803170606375.png" alt="image-20230803170606375"></p><p>​        由于文件描述符 0 未用，所以 open()调用势必使用此描述符打开文件。5.5 节中所论及的dup2()和 fcntl()也可实现类似功能，但对于文件描述符的控制更加灵活。</p><h3 id="open-调用中的-flags-参数"><a href="#open-调用中的-flags-参数" class="headerlink" title="open()调用中的 flags 参数"></a>open()调用中的 flags 参数</h3><p>对于<code>flags</code>:</p><ul><li>文件访问模式标志：先前描述的 O_RDONLY、O_WRONLY 和 O_RDWR 标志均在此列，调用 open()时，上述三者在 flags 参数中不能同时使用，只能指定其中一种。调用fcntl()的 F_GETFL 操作能够检索文件的访问模式（见 5.3 节）。</li></ul><div class="table-container"><table><thead><tr><th>参  数</th><th>说  明</th><th>参  数</th><th>说  明</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>以只读方式打开文件</td><td>O_RDWR</td><td>以可读写方式打开文件</td></tr><tr><td>O_WRONLY</td><td>以只写方式打开文件</td><td></td></tr></tbody></table></div><ul><li>文件创建标志：这些标志在表 4-3 中位于第二部分，其控制范围不拘于 open()调用行为的方方面面，还涉及后续 I/O 操作的各个选项。这些标志不能检索，也无法修改。</li></ul><div class="table-container"><table><thead><tr><th>参  数</th><th>说 明</th></tr></thead><tbody><tr><td><code>O_CLOEXEC</code></td><td>设置close-on-exec标志</td></tr><tr><td><code>O_CREAT</code></td><td>若路径中的文件不存在则自动建立该文件</td></tr><tr><td><code>O_DIRECT</code></td><td>无缓冲的输入输出</td></tr><tr><td><code>O_DIRECTORY</code></td><td>如果pathname不是目录则会失败</td></tr><tr><td><code>O_EXCL</code></td><td>如果与O_CREAT同时设置，此指令会去检查文件是否存在，文件若不存在则建立该文件，否则将导致打开文件错误。此外，若O_CREAT与O_EXCL同时设置，并且将要打开的文件为符号连接，则将导致打开文件失败</td></tr><tr><td><code>O_LARGEFILE</code></td><td>在32位系统上用之打开大文件</td></tr><tr><td><code>O_NOATIME</code></td><td>调用read时候不修改文件最近的访问时间</td></tr><tr><td><code>O_NOCTTY</code></td><td>不要让pathname（所指向的终端设备）成为控制终端</td></tr><tr><td><code>O_NOFOLLOW</code></td><td>对链接符号不予解引用</td></tr><tr><td><code>O_TRUNC</code></td><td>若文件存在并且以可写的方式打开时，此标志会将文件长度清为0，而原来存于该文件的资料也会消失</td></tr></tbody></table></div><ul><li>已打开文件的状态标志：这些标志是表 4-3 中的剩余部分，使用 fcntl()的 F_GETFL 和F_SETFL 操作可以分别检索和修改此类标志。有时干脆将其称之为<strong>文件状态标志</strong>。</li></ul><div class="table-container"><table><thead><tr><th>参  数</th><th>说 明</th></tr></thead><tbody><tr><td><code>O_APPEND</code></td><td>读写文件从文件尾部开始移动，所写入的数据追加到文件尾</td></tr><tr><td><code>O_ASYNC</code></td><td>当IO操作可行时，产生信号通知进程</td></tr><tr><td><code>O_DSYNC</code></td><td>提供同步的IO数据完整性</td></tr><tr><td><code>O_NONBLOCK</code></td><td>以非阻塞的方式打开</td></tr><tr><td><code>O_SYNC</code></td><td>以同步方式写入文件</td></tr></tbody></table></div><h4 id="O-APPEND"><a href="#O-APPEND" class="headerlink" title="O_APPEND"></a>O_APPEND</h4><p>​        总是在文件尾部追加数据，5.1 节将讨论此标志的意义。</p><h4 id="O-ASYNC"><a href="#O-ASYNC" class="headerlink" title="O_ASYNC"></a>O_ASYNC</h4><p>​        当对于 open()调用所返回的文件描述符可以实施 I/O 操作时，系统会产生一个信号通知进程。这一特性，也被称为信号驱动 I/O，仅对特定类型的文件有效，诸如终端、FIFOS 及 socket。（在 SUSv3 中并未规定 O_ASYNC 标志，但大多数 UNIX 实现都支持此标志或者老版本中与其等效的 FASYNC 标志。）在 Linux 中，调用 open()时指定 O_ASYNC 标志没有任何实质效果。要启用信号驱动 I/O 特性，必须调用 fcntl()的 F_SETFL 操作来设置 O_ASYNC 标志（见 5.3 节）。（其他一些 UNIX 系统的实现有类似行为。）关于 O_ASYNC 标志的更多内容请参考 63.3 节。</p><h4 id="O-CLOEXEC（自-Linux-2-6-23-版本开始支持）"><a href="#O-CLOEXEC（自-Linux-2-6-23-版本开始支持）" class="headerlink" title="O_CLOEXEC（自 Linux 2.6.23 版本开始支持）"></a>O_CLOEXEC（自 Linux 2.6.23 版本开始支持）</h4><p>​        为新（创建）的文件描述符启用 close-on-flag 标志（FD_CLOEXEC）。27.4 节将描述 FD_ CLOEXEC 标志。使用 O_CLOEXEC 标志（打开文件），可以免去程序执行 fcntl()的 F_GETFD和 F_SETFD 操作来设置 close-on-exec 标志的额外工作。在多线程程序中执行 fcntl() 的 F_GETFD和 F_SETFD 操作有可能导致竞争状态，而使用 O_CLOEXEC 标志则能够避免这一点。可能引发竞争的场景是：线程某甲打开一文件描述符，尝试为该描述符标记 close-on-exec 标志，于此同时，线程某乙执行 fork()调用，然后调用 exec()执行任意一个程序。（假设在某甲打开文件描述符和调用fcntl()设置 close-on-exec 标志之间，某乙成功地执行了 fork()和 exec()操作。）此类竞争可能会在无意间将打开的文件描述符泄露给不安全的程序。（更多关于竞争状态的内容请参考 5.1 节。）</p><h4 id="O-CREAT"><a href="#O-CREAT" class="headerlink" title="O_CREAT"></a>O_CREAT</h4><p>如果文件不存在，将创建一个新的空文件。即使文件以只读方式打开，此标志依然有效。如果在 open()调用中指定 O_CREAT 标志，那么还需要提供 mode 参数，否则，会将新文件的权限设置为栈中的某个随机值。</p><h4 id="O-DIRECT"><a href="#O-DIRECT" class="headerlink" title="O_DIRECT"></a>O_DIRECT</h4><p>​        无系统缓冲的文件 I/O 操作。该特性将在 13.6 节中详述。为使 O_DIRECT 标志的常量定义在<fcntl.h>中有效，必须定义_GNU_SOURCE 功能测试宏。</p><h4 id="O-DIRECTORY"><a href="#O-DIRECTORY" class="headerlink" title="O_DIRECTORY"></a>O_DIRECTORY</h4><p>​        如果 pathname 参数并非目录，将返回错误（错误号 errno 为 ENOTDIR）。这一标志是专为实现 opendir()函数（18.8 节）而设计的扩展标志。为使 O_DIRECTORY 标志的常量定义在<fcntl.h>中有效，必须定义_GNU_SOURCE 功能测试宏. _</p><h4 id="O-DSYNC（自-Linux-2-6-33-版本开始支持）"><a href="#O-DSYNC（自-Linux-2-6-33-版本开始支持）" class="headerlink" title="O_DSYNC（自 Linux 2.6.33 版本开始支持）"></a>O_DSYNC（自 Linux 2.6.33 版本开始支持）</h4><p>​        根据同步 I/O 数据完整性的完成要求1来执行文件写操作。参见 13.3 节中关于内核 I/O 缓冲的讨论。</p><h4 id="O-EXCL"><a href="#O-EXCL" class="headerlink" title="O_EXCL"></a>O_EXCL</h4><p>​        此标志与 O_CREAT 标志结合使用表明如果文件已经存在，则不会打开文件，且 open()调用失败，并返回错误，错误号 errno 为 EEXIST。换言之，此标志确保了调用者（open( )的调用进程）就是创建文件的进程。检查文件存在与否和创建文件这两步属于同一原子操作。5.1 节将讨论原子操作的概念。如果在 flags 参数中同时指定了 O_CREAT 和 O_EXCL 标志，且 pathname参数是符号链接，则 open()函数调用失败（错误号 errno 为 EEXIST）。SUSv3 之所以如此规定，是要求有特权的应用程序在已知目录下创建文件，从而消除了如下安全隐患，使用符号链接打开文件会导致在另一位置创建文件（例如，系统目录）。</p><h4 id="O-LARGEFILE"><a href="#O-LARGEFILE" class="headerlink" title="O_LARGEFILE"></a>O_LARGEFILE</h4><p>​        支持以大文件方式打开文件。在 32 位操作系统中使用此标志，以支持大文件操作。尽管在 SUSv3 中没有规定这一标志，但其他一些 UNIX 实现都支持这一特性。此标志在诸如 Alpha、IA-64 之类的 64 位 Linux 实现中是无效的。更多的内容将在 5.10 节中讨论。</p><h4 id="O-NOATIME（自-Linux-2-6-8-版本开始）"><a href="#O-NOATIME（自-Linux-2-6-8-版本开始）" class="headerlink" title="O_NOATIME（自 Linux 2.6.8 版本开始）"></a>O_NOATIME（自 Linux 2.6.8 版本开始）</h4><p>​        在读文件时，不更新文件的最近访问时间（15.1 节中所描述的 st_atime 属性）。要使用该标志，要么调用进程的有效用户 ID 必须与文件的拥有者相匹配，要么进程需要拥有特权（CAP_FOWNER）。否则，open()调用失败，并返回错误，错误号 errno 为 EPERM。（事实上，如 9.5 节所述，对于非特权进程，当以 O_NOATIME 标志打开文件时，与文件用户 ID 必须匹配的是进程的文件系统用户 ID，而非进程的有效用户 ID。）此标志是 Linux 特有的非标准扩展。要从<fcntl.h>中启用此标志，必须定义_GNU_SOURCE 功能测试宏。O_NOATIME 标志的设计旨在为索引和备份程序服务。该标志的使用能够显著减少磁盘的活动量，省却了既要读取文件内容，又要更新文件 i-node 结构中最近访问时间的繁琐，进而节省了磁头在磁盘上的反复寻道时间（14.4 节）。mount()函数中 MS_ NOATIME 标志（14.8.1 节）和 FS_NOATIME_ FL 标志（15.5 节）与 O_NOATIME 标志功能相似。</p><h4 id="O-NOCTTY"><a href="#O-NOCTTY" class="headerlink" title="O_NOCTTY"></a>O_NOCTTY</h4><p>​        如果正在打开的文件属于终端设备，O_NOCTTY 标志防止其成为控制终端。34.4 节将讨论控制终端。如果正在打开的文件不是终端设备，则此标志无效。</p><h4 id="O-NOFOLLOW"><a href="#O-NOFOLLOW" class="headerlink" title="O_NOFOLLOW"></a>O_NOFOLLOW</h4><p>​        通常，如果 pathname 参数是符号链接，open()函数将对 pathname 参数进行解引用。一旦在 open()函数中指定了 O_NOFOLLOW 标志，且 pathname 参数属于符号链接，则 open()函数将返回失败（错误号 errno 为 ELOOP）。此标志在特权程序中极为有用，能够确保 open()函数不对符号链接进行解引用。为使 O_NOFOLLOW 标志在<fcntl.h>中有效，必须定义_GNU_SOURCE功能测试宏。_</p><h4 id="O-NONBLOCK"><a href="#O-NONBLOCK" class="headerlink" title="O_NONBLOCK"></a>O_NONBLOCK</h4><p>以非阻塞方式打开文件，参照 5.9 节。</p><h4 id="O-SYNC"><a href="#O-SYNC" class="headerlink" title="O_SYNC"></a>O_SYNC</h4><p>以同步 I/O 方式打开文件，参见 13.3 节针对内核 I/O 缓冲的讨论。</p><h4 id="O-TRUNC"><a href="#O-TRUNC" class="headerlink" title="O_TRUNC"></a>O_TRUNC</h4><p>​        如果文件已经存在且为普通文件，那么将清空文件内容，将其长度置 0。在 Linux 下使用此标志，无论以读、写方式打开文件，都可清空文件内容（在这两种情况下，都必须拥有对文件的写权限）。SUSv3 对 O_RDONLY 与 O_TRUNC 标志的组合未作规定，但多数其他 UNIX实现与 Linux 的处理方式相同。</p><h3 id="open可能抛出的异常"><a href="#open可能抛出的异常" class="headerlink" title="open可能抛出的异常"></a>open可能抛出的异常</h3><p>​        若打开文件时发生错误，open()将返回−1，错误号 errno 标识错误原因。以下是一些可能发生的错误（除了在上节参数描述中已经提及的错误之外）。</p><h4 id="EACCES"><a href="#EACCES" class="headerlink" title="EACCES"></a>EACCES</h4><p>​        文件权限不允许调用进程以 flags 参数指定的方式打开文件。无法访问文件，其可能的原因有目录权限的限制、文件不存在并且也无法创建该文件。</p><h4 id="EISDIR"><a href="#EISDIR" class="headerlink" title="EISDIR"></a>EISDIR</h4><p>​        所指定的文件属于目录，而调用者企图打开该文件进行写操作。不允许这种用法。（另一方面，在某些场合中，打开目录进行读操作是必要的。18.11 节将举例说明。）</p><h4 id="EMFILE"><a href="#EMFILE" class="headerlink" title="EMFILE"></a>EMFILE</h4><p>​        进程已打开的文件描述符数量达到了进程资源限制所设定的上限（在 36.3 节将描述RLIMIT_NOFILE 参数）。ENFILE 文件打开数量已经达到系统允许的上限。</p><h4 id="ENOENT"><a href="#ENOENT" class="headerlink" title="ENOENT"></a>ENOENT</h4><p>​        要么文件不存在且未指定 O_CREAT 标志，要么指定了 O_CREAT 标志，但 pathname 参数所指定路径的目录之一不存在，或者 pathname 参数为符号链接，而该链接指向的文件不存在（空链接）。</p><h4 id="EROFS"><a href="#EROFS" class="headerlink" title="EROFS"></a>EROFS</h4><p>​        所指定的文件隶属于只读文件系统，而调用者企图以写方式打开文件。</p><h4 id="ETXTBSY"><a href="#ETXTBSY" class="headerlink" title="ETXTBSY"></a>ETXTBSY</h4><p>​        所指定的文件为可执行文件（程序），且正在运行。系统不允许修改正在运行的程序（比如以写方式打开文件）。（必须首先终止程序运行，然后方可修改可执行文件。）后续在描述其他系统调用或库函数时，一般不会再以上述方式展现可能发生的一系列错误。（每个系统调用或库函数的错误列表可从相关操作手册中查询获得。）采用上述方式原因有二，一是因为 open()是本书详细描述的首个系统调用，而上述列表表明任一原因都有可能导致系统调用或库函数的调用失败。二是 open()调用失败的具体原因列表本身就颇为值得玩味，它展示了影响文件访问的若干因素，以及访问文件时系统所执行的一系列检查。（上述错误列表并不完整，更多 open()调用失败的错误原因请查看 open(2)的操作手册。）</p><h2 id="read读文件"><a href="#read读文件" class="headerlink" title="read读文件"></a>read读文件</h2><p>​        read()系统调用从文件描述符 fd 所指代的打开文件中读取数据。</p><pre class="line-numbers language-none"><code class="language-none">extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        count 参数指定最多能读取的字节数。（size_t 数据类型属于无符号整数类型。）buffer 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。</p><p>​        <strong>如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。</strong>ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。</p><p>​        一次 read()调用所读取的字节数可以小于请求的字节数。对于普通文件而言，这有可能是因为当前读取位置靠近文件尾部。（不难理解，一个只有10b的文件读它个20b，那么实际上就会读取10b）</p><p>​        当 read()应用于其他文件类型时，比如管道、FIFO、socket 或者终端，在不同环境下也会出现 read()调用读取的字节数小于请求字节数的情况。例如，默认情况下从终端读取字符，一遇到换行符（\n），read()调用就会结束。</p><p>​        值得注意的是：有必要在read的东西加上一个\0以示终止，因为 read()调用没有在 字符串尾部添加一个表示终止的空字符。为什么不加呢？read()无从区分这些数据，故而也无法遵从 C 语言对字符串处理的约定，在字符串尾部追加标识字符串结束的空字符。如果输入缓冲区的结尾处需要一个表示终止的空字符，必须显式追加。</p><h2 id="write写文件"><a href="#write写文件" class="headerlink" title="write写文件"></a>write写文件</h2><pre class="line-numbers language-none"><code class="language-none">extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        write()系统调用将数据写入一个已打开的文件中。write()调用的参数含义与 read()调用相类似。buffer 参数为要写入文件中数据的内存地址，count参数为欲从 buffer 写入文件的数据字节数，fd 参数为一文件描述符，指代数据要写入的文件。</p><p>​        如果 write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因为进程资源对文件大小的限制。（相关的限制为 RLIMIT_FSIZE，将在 36.3 节描述。）</p><p>​        对磁盘文件执行 I/O 操作时，write()调用成功并不能保证数据已经写入磁盘。因为为了减少磁盘活动量和加快 write()系统调用，内核会缓存磁盘的 I/O 操作</p><h2 id="close-关闭文件"><a href="#close-关闭文件" class="headerlink" title="close() 关闭文件"></a>close() 关闭文件</h2><p>​        close()系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。</p><pre class="line-numbers language-none"><code class="language-none">extern int close (int __fd);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当一进程终止时，将自动关闭其已打开的所有文件描述符。</p><p>​        显式关闭不再需要的文件描述符往往是良好的编程习惯，会使代码在后续修改时更具可读性，也更可靠。进而言之，文件描述符属于有限资源，因此文件描述符关闭失败可能会导致一个进程将文件描述符资源消耗殆尽。在编写需要长期运行并处理大量文件的程序时，比如 shell 或者网络服务器软件，需要特别加以关注。<strong>像其他所有系统调用一样，应对 close()的调用进行错误检查</strong></p><pre class="line-numbers language-none"><code class="language-none">if(close(fd) &#x3D;&#x3D; -1)&#123;exit(-1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        上述代码能够捕获的错误有：<strong>企图关闭一个未打开的文件描述符，或者两次关闭同一文件描述符，也能捕获特定文件系统在关闭操作中诊断出的错误条件</strong>。针对特定文件系统的错误，NFS（网络文件系统）就是一例。如果 NFS 出现提交失败，这意味着数据没有抵达远程磁盘，随之将这一错误作为 close()调用失败的原因传递给应用系统。</p><h2 id="lseek-改变文件偏移量"><a href="#lseek-改变文件偏移量" class="headerlink" title="lseek()改变文件偏移量"></a>lseek()改变文件偏移量</h2><p>​        对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指<strong>执行下一个 read()或 write()操作的文件起始位置</strong>，会以相对于文件头部起始点的文件当前位置来表示。<strong>文件第一个字节的偏移量为 0。</strong></p><p>​        文件打开时，会将文件偏移量设置为指向文件开始，以后每次 read()或 write()调用将自动对其进行调整，以指向已读或已写数据后的下一字节。因此，连续的 read()和 write()调用将按顺序递进，对文件进行操作。</p><p>​        针对文件描述符 fd 参数所指代的已打开文件，lseek()系统调用依照 offset 和 whence 参数值调整该文件的偏移量。</p><pre class="line-numbers language-none"><code class="language-none">extern __off_t lseek (int __fd, __off_t __offset, int __whence) __THROW;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        offset 参数指定了一个以字节为单位的数值。（SUSv3 规定 off_t 数据类型为有符号整型数。）whence 参数则表明应参照哪个基点来解释 offset 参数，应为下列其中之一：</p><ul><li>SEEK_SET   将文件偏移量设置为从文件头部起始点开始的 offset 个字节。</li><li>SEEK_CUR 相对于当前文件偏移量，将文件偏移量调整 offset 个字节1。</li><li>SEEK_END 将文件偏移量设置为起始于文件尾部的 offset 个字节。也就是说，offset 参数应该从文件最后一个字节之后的下一个字节算起。</li></ul><p><img src="image-20230803172531005.png" alt="image-20230803172531005"></p><p>​        lseek()并不适用于所有类型的文件。不允许将 lseek()应用于管道、FIFO、socket 或者终端。一旦如此，调用将会失败，并将 errno 置为 ESPIPE。</p><p>​        另一方面，只要合情合理，也可以将 lseek()应用于设备。例如，在磁盘或者磁带上查找一处具体位置。lseek()调用名中的 l 源于这样一个事实：offset 参数和调用返回值的类型起初都是 long型。早期的 UNIX 系统还提供了 seek()系统调用，当时这两个值的类型为 int 型。</p><h3 id="文件空洞"><a href="#文件空洞" class="headerlink" title="文件空洞"></a>文件空洞</h3><p>​        对于我们想要执行写操作——我们打算在文件偏移量已经大于文件长度的情况下去写东西会如何呢？</p><p>​        答案是——不会报错！相反，会将中间的部分填充0后再准备写想写的东西。从文件结尾后到新写入数据间的这段空间被称为文件空洞。从编程角度看，文件空洞中是存在字节的，读取空洞将返回以 0（空字节）填充的缓冲区。</p><p>​        然而，文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块相比，稀疏填充的文件会占用较少的磁盘空间。核心转储文件（core dump）（见 22.1 节）是包含空洞文件的常见例子。</p><h2 id="4-9-总结"><a href="#4-9-总结" class="headerlink" title="4.9 总结"></a>4.9 总结</h2><p>​        为了对普通文件执行 I/O 操作，首先必须调用 open()以获得一个文件描述符。随之使用read()和 write()执行文件的 I/O 操作，然后应使用 close()释放文件描述符及相关资源。这些系统调用可对所有类型的文件执行 I/O 操作。所有类型的文件和设备驱动都实现了相同的 I/O 接口，这保证了 I/O 操作的通用性，同时也意味着在无需针对特定文件类型编写代码的情况下，程序通常就能操作所有类型的文件。对于已打开的每个文件，内核都维护有一个文件偏移量，这决定了下一次读或写操作的起始位置。读和写操作会隐式修改文件偏移量。使用 lseek()函数可以显式地将文件偏移量置为文件中或文件结尾后的任一位置。在文件原结尾处之后的某一位置写入数据将导致文件空洞。从文件空洞处读取文件将返回全 0 字节。对于未纳入标准 I/O 模型的所有设备和文件操作而言，ioctl()系统调用是个“百宝箱”。</p><h1 id="扩展：传统的-System-Call-I-O"><a href="#扩展：传统的-System-Call-I-O" class="headerlink" title="扩展：传统的 System Call I/O"></a>扩展：传统的 System Call I/O</h1><p><a href="https://zhuanlan.zhihu.com/p/435406445">Linux系统中I/O操作的数据读写流程介绍 - 知乎 (zhihu.com)</a></p><p>​        在 Linux 系统中，<strong>传统的访问方式是通过 write() 和 read() 两个系统调用实现的，通过 read() 函数读取文件到到缓存区中，然后通过 write() 方法把缓存中的数据输出到网络端口</strong>。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">read(file_fd, tmp_buf, len);write(socket_fd, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        下图分别对应传统 I/O 操作的数据读写流程，整个过程涉及 2 次 CPU 拷贝、2 次 DMA 拷贝，总共 4 次拷贝，以及 4 次上下文切换。</p><ul><li><strong>CPU 拷贝</strong>：由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。</li><li><strong>DMA 拷贝</strong>：由 CPU 向DMA磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。</li><li><strong>上下文切换</strong>：当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；当系统调用返回时，CPU 将用户进程从内核态切换回用户态。</li></ul><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>​        当应用程序执行 read 系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。</p><p>​        如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（Read Buffer）中，再从读缓存拷贝到用户进程的页内存中。</p><p><img src="v2-c4ffd5334a977af27f18b3b6eac6f65c_1440w.webp" alt="img"></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">read(file_fd, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        基于传统的 I/O 读取方式，read 系统调用会触发 2 次上下文切换，1 次 DMA 拷贝和 1 次 CPU 拷贝。</p><p><strong>发起数据读取的流程如下：</strong></p><ol><li>用户进程通过 read() 函数向 Kernel 发起 System Call，上下文从 user space 切换为 kernel space。</li><li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到 kernel space 的读缓冲区（Read Buffer）。</li><li>CPU 将读缓冲区（Read Buffer）中的数据拷贝到 user space 的用户缓冲区（User Buffer）。</li><li>上下文从 kernel space 切换回用户态（User Space），read 调用执行返回。</li></ol><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>​        当应用程序准备好数据，执行 write 系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（Socket Buffer）中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">write(socket_fd, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        基于传统的 I/O 写入方式，write() 系统调用会触发 2 次上下文切换，1 次 CPU 拷贝和 1 次 DMA 拷贝。</p><p>​        <strong>用户程序发送网络数据的流程如下：</strong></p><ol><li>用户进程通过 write() 函数向 kernel 发起 System Call，上下文从 user space 切换为 kernel space。</li><li>CPU 将用户缓冲区（User Buffer）中的数据拷贝到 kernel space 的网络缓冲区（Socket Buffer）。</li><li>CPU 利用 DMA 控制器将数据从网络缓冲区（Socket Buffer）拷贝到 NIC 进行数据传输。</li><li>上下文从 kernel space 切换回 user space，write 系统调用执行返回。</li></ol><h2 id="网络-I-O"><a href="#网络-I-O" class="headerlink" title="网络 I/O"></a>网络 I/O</h2><p><img src="v2-a0bbc8704096e91fd1ab2546d5dedfde_1440w.webp" alt="img"></p><h2 id="磁盘-I-O"><a href="#磁盘-I-O" class="headerlink" title="磁盘 I/O"></a>磁盘 I/O</h2><p><img src="v2-6a02810aa6d653bae2d27784d1f79995_1440w.webp" alt="img"></p><h2 id="高性能优化的-I-O"><a href="#高性能优化的-I-O" class="headerlink" title="高性能优化的 I/O"></a>高性能优化的 I/O</h2><ol><li><strong>零拷贝技术。</strong></li><li><strong>多路复用技术。</strong></li><li><strong>页缓存（PageCache）技术。</strong></li></ol><p>其中，<strong>页缓存（PageCache）</strong>是操作系统对文件的缓存，用来减少对磁盘的 I/O 操作，以页为单位的，内容就是磁盘上的物理块，页缓存能帮助程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于 OS 使用 PageCache 机制对读写访问操作进行了性能优化。</p><p><strong>页缓存读取策略</strong>：当进程发起一个读操作 （比如，进程发起一个 read() 系统调用），它首先会检查需要的数据是否在页缓存中：</p><ul><li><strong>如果在</strong>，则放弃访问磁盘，而直接从页缓存中读取。</li><li><strong>如果不在</strong>，则内核调度块 I/O 操作从磁盘去读取数据，并读入紧随其后的少数几个页面（不少于一个页面，通常是三个页面），然后将数据放入页缓存中。</li></ul><p><img src="v2-222d29b87f50973806ed9c1a7633819f_1440w.webp" alt="img"></p><p><strong>页缓存写策略</strong>：当进程发起 write 系统调用写数据到文件中，先写到页缓存，然后方法返回。此时数据还没有真正的保存到文件中去，Linux 仅仅将页缓存中的这一页数据标记为 “脏”，并且被加入到脏页链表中。</p><p>然后，由 flusher 回写线程周期性将脏页链表中的页写到磁盘，让磁盘中的数据和内存中保持一致，最后清理“脏”标识。</p><p><strong>在以下三种情况下，脏页会被写回磁盘：</strong></p><ol><li>空闲内存低于一个特定阈值。</li><li>脏页在内存中驻留超过一个特定的阈值时。</li><li>当用户进程调用 sync() 和 fsync() 系统调用时。</li></ol><h2 id="存储设备的-I-O-栈"><a href="#存储设备的-I-O-栈" class="headerlink" title="存储设备的 I/O 栈"></a>存储设备的 I/O 栈</h2><p><img src="v2-c5c7c058af6239bbb2f86fe9da0f33f9_1440w.webp" alt="img"></p><p><strong>由图可见，从系统调用的接口再往下，Linux 下的 IO 栈致大致有三个层次：</strong></p><ol><li><strong>文件系统层</strong>，以 write 为例，内核拷贝了 write 参数指定的用户态数据到文件系统 Cache 中，并适时向下层同步。</li><li><strong>块层</strong>，管理块设备的 IO 队列，对 IO 请求进行合并、排序（还记得操作系统课程学习过的 IO 调度算法吗？）。</li><li><strong>设备层</strong>，通过 DMA 与内存直接交互，完成数据和具体设备之间的交互。</li></ol><p>结合这个图，想想 Linux 系统编程里用到的 <strong>Buffered IO</strong>、<strong>mmap</strong>、<strong>Direct IO</strong>，这些机制怎么和<strong>Linux I/O栈</strong>联系起来呢？上面的图有点复杂，我画一幅简图，把这些机制所在的位置添加进去：</p><p><img src="v2-50b7e6e5b531ab5fc8c294bc6cfa125a_1440w.webp" alt="img"></p><h2 id="Linux-IO系统"><a href="#Linux-IO系统" class="headerlink" title="Linux IO系统"></a><strong>Linux IO系统</strong></h2><p>​        这下一目了然了吧？<strong>传统的 Buffered IO</strong> 使用 read 读取文件的过程什么样的？假设要去读一个冷文件（Cache 中不存在），open 打开文件内核后建立了一系列的数据结构，接下来调用 read，到达文件系统这一层，发现 <strong>Page Cache</strong> 中不存在该位置的磁盘映射，然后创建相应的 Page Cache 并和相关的扇区关联。然后请求继续到达块设备层，在 IO 队列里排队，接受一系列的调度后到达设备驱动层，此时一般使用 <strong>DMA</strong> 方式读取相应的磁盘扇区到 Cache 中，然后 read 拷贝数据到用户提供的<strong>用户态 buffer</strong> 中去（read 的参数指出的）。</p><p>​        <strong>整个过程有几次拷贝？</strong>从磁盘到 Page Cache 算第一次的话，从 Page Cache 到用户态 buffer 就是第二次了。而 mmap 做了什么？mmap 直接把 Page Cache 映射到了用户态的地址空间里了，所以 mmap 的方式读文件是没有第二次拷贝过程的。</p><p>​        <strong>那 Direct IO 做了什么？</strong>这个机制更狠，直接让用户态和块 IO 层对接，直接放弃 Page Cache，从磁盘直接和用户态拷贝数据。好处是什么？写操作直接映射进程的buffer到磁盘扇区，以 DMA 的方式传输数据，减少了原本需要到 Page Cache 层的一次拷贝，提升了写的效率。对于读而言，第一次肯定也是快于传统的方式的，但是之后的读就不如传统方式了（当然也可以在用户态自己做 Cache，有些商用数据库就是这么做的）。</p><p>除了传统的 Buffered IO 可以比较自由的用偏移+长度的方式读写文件之外，<strong>mmap</strong> 和 Direct IO 均有数据按页对齐的要求，Direct IO 还限制读写必须是底层存储设备块大小的整数倍（甚至 Linux 2.4 还要求是文件系统逻辑块的整数倍）。所以接口越来越底层，换来表面上的效率提升的背后，需要在应用程序这一层做更多的事情。所以想用好这些高级特性，除了深刻理解其背后的机制之外，也要在系统设计上下一番功夫。</p><h2 id="I-O-Buffering"><a href="#I-O-Buffering" class="headerlink" title="I/O Buffering"></a>I/O Buffering</h2><p><img src="v2-5ac443941b2d427d34d958db72480d9e_1440w.webp" alt="img"></p><p>​        如图，当程序调用各类文件操作函数后，用户数据（User Data）到达磁盘（Disk）的流程如图所示。</p><p>​        图中描述了 Linux 下文件操作函数的层级关系和内存缓存层的存在位置。中间的黑色实线是用户态和内核态的分界线。</p><p><strong>从上往下分析这张图：</strong></p><p>​        <strong>1.</strong> 首先是 C 语言 stdio 库定义的相关文件操作函数，这些都是用户态实现的跨平台封装函数。stdio 中实现的文件操作函数有自己的 stdio buffer，这是在用户态实现的缓存。此处使用缓存的原因很简单 — 系统调用总是昂贵的。如果用户代码以较小的 size 不断的读或写文件的话，stdio 库将多次的读或者写操作通过 buffer 进行聚合是可以提高程序运行效率的。stdio 库同时也支持 fflush 函数来主动的刷新 buffer，主动的调用底层的系统调用立即更新 buffer 里的数据。特别地，setbuf 函数可以对 stdio 库的用户态 buffer 进行设置，甚至取消 buffer 的使用。</p><p>​        <strong>2.</strong> <strong>系统调用的 read/write 和真实的磁盘读写之间也存在一层 buffer</strong>，这里用术语 Kernel buffer cache 来指代这一层缓存。在 Linux 下，文件的缓存习惯性的称之为 Page Cache，而更低一级的设备的缓存称之为 Buffer Cache。这两个概念很容易混淆，这里简单的介绍下概念上的区别：Page Cache 用于缓存文件的内容，和文件系统比较相关。文件的内容需要映射到实际的物理磁盘，这种映射关系由文件系统来完成；Buffer Cache 用于缓存存储设备块（比如磁盘扇区）的数据，而不关心是否有文件系统的存在（文件系统的元数据缓存在 Buffer Cache 中）。</p><h1 id="深入探究文件IO"><a href="#深入探究文件IO" class="headerlink" title="深入探究文件IO"></a>深入探究文件IO</h1><h2 id="原子操作和竞争条件"><a href="#原子操作和竞争条件" class="headerlink" title="原子操作和竞争条件"></a>原子操作和竞争条件</h2><p>​        我们下面要要谈到的是高级一些的文件IO，这里，我们就需要考虑到原子操作和竞争条件.也就是说,我们现在来考虑一下多进程下的文件IO函数行为</p><h3 id="举个例子-以独占方式创建一个文件"><a href="#举个例子-以独占方式创建一个文件" class="headerlink" title="举个例子:以独占方式创建一个文件"></a>举个例子:以独占方式创建一个文件</h3><p>​        当同时指定 O_EXCL 与 O_CREAT 作为 open()的标志位时，如果要打开的文件已然存在，则 open()将返回一个错误。这提供了一种机制，保证进程是打开文件的创建者。</p><p>​        下面的这个程序是有问题的:</p><p><img src="image-20230803174458278.png" alt="image-20230803174458278"></p><p>​        在多进程条件下,我们如果不加原子操作,非文件开创的进程会认为是自己开创的进程.</p><p><img src="image-20230803174619051.png" alt="image-20230803174619051"></p><p>​        从而埋下隐患.结合 O_CREAT 和 O_EXCL 标志来一次性地调用 open()可以防止这种情况，因为这确保了检查文件和创建文件的步骤属于一个单一的原子（即不可中断的）操作。</p><h3 id="再举个例子-向文件尾部追加数据"><a href="#再举个例子-向文件尾部追加数据" class="headerlink" title="再举个例子:向文件尾部追加数据"></a>再举个例子:向文件尾部追加数据</h3><p>​        还有一个例子,就是多个进程同时向某一个文件追加数据</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if(lseek(fd, 0, SEEK_END) &#x3D;&#x3D; -1)&#123;    errExit(-1);&#125;if(write(fd,buf,len) !&#x3D; len)&#123;    fatal(&quot;Partially write or failed write!&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是，这段代码存在的缺陷与前一个例子如出一辙。<strong>如果第一个进程执行到 lseek()和 write()之间，被执行相同代码的第二个进程所中断，那么这两个进程会在写入数据前，将文件偏移量设为相同位置，而当第一个进程再次获得调度时，会覆盖第二个进程已写入的数据。此时再次出现了竞争状态，因为执行的结果依赖于内核对两个进程的调度顺序。</strong></p><p>​        需要将文件偏移量的移动与数据写操作纳入同一原子操作。在打开文件时加入 O_APPEND 标志就可以保证这一点。有些文件系统（例如 NFS）不支持 O_APPEND 标志。</p><h2 id="文件控制操作：fcntl"><a href="#文件控制操作：fcntl" class="headerlink" title="文件控制操作：fcntl()"></a>文件控制操作：fcntl()</h2><p>​    fcntl()系统调用对一个打开的文件描述符执行一系列控制操作。</p><p><img src="image-20230803174720241.png" alt="image-20230803174720241"></p><p>​        cmd 参数所支持的操作范围很广。本章随后各节会对其中的部分操作加以研讨，剩下的操作将在后续各章中进行论述。</p><p>​        fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。</p><h2 id="打开文件的状态标志"><a href="#打开文件的状态标志" class="headerlink" title="打开文件的状态标志"></a>打开文件的状态标志</h2><p>​        这个函数有一个用途:<strong>针对打开的文件,获取或修改其访问模式和状态标志（这些值是通过指定 open()调用的 flag 参数来设置的）。要获取这些设置，应将 fcntl()的 cmd 参数设置为F_GETFL。</strong></p><p><img src="image-20230803174744205.png" alt="image-20230803174744205"></p><p>​        在上述代码之后，可以以如下代码测试文件是否以同步写方式打开：</p><p><img src="image-20230803174814491.png" alt="image-20230803174814491"></p><p>​        当然,判断访问模式就有些复杂了</p><p>​        这是因为 O_RDONLY(0)、O_WRONLY(1)和 O_RDWR(2)这 3 个常量并不与打开文件状态标志中的单个比特位对应。因此，要判定访问模式，需使用掩码 O_ACCMODE 与 flag 相与，将结果与 3 个常量进行比对，示例代码如下：</p><p><img src="image-20230803174834715.png" alt="image-20230803174834715"></p><p>​        可以使用 fcntl()的 F_SETFL 命令来修改打开文件的某些状态标志。允许更改的标志有O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和 O_DIRECT。系统将忽略对其他标志的修改操作。（有些其他的 UNIX 实现允许 fcntl()修改其他标志，如 O_SYNC。）使用 fcntl()修改文件状态标志，尤其适用于如下场景。</p><ul><li>文件不是由调用程序打开的，所以程序也无法使用 open()调用来控制文件的状态标志（例如，文件是 3 个标准输入输出描述符中的一员，这些描述符在程序启动之前就被打开）。</li><li>文件描述符的获取是通过 open()之外的系统调用。比如 pipe()调用，该调用创建一个管道，并返回两个文件描述符分别对应管道的两端。再比如 socket()调用，该调用创建一个套接字并返回指向该套接字的文件描述符。</li></ul><p>​        为了修改打开文件的状态标志，可以使用 fcntl()的 F_GETFL 命令来获取当前标志的副本，然后修改需要变更的比特位，最后再次调用 fcntl()函数的 F_SETFL 命令来更新此状态标志。因此，为了添加 O_APPEND 标志，可以编写如下代码：</p><p><img src="image-20230803174904937.png" alt="image-20230803174904937"></p><h2 id="文件描述符和打开文件之间的关系"><a href="#文件描述符和打开文件之间的关系" class="headerlink" title="文件描述符和打开文件之间的关系"></a>文件描述符和打开文件之间的关系</h2><p>​        多个文件描述符当然可以指向同一个文件</p><p>这些文件描述符可在相同或不同的进程中打开。要理解具体情况如何，需要查看由内核维护的 3 个数据结构。</p><ul><li>进程级的文件描述符表。</li><li>系统级的打开文件表。</li><li>文件系统的 i-node 表。</li></ul><p>​        针对每个进程，<strong>内核为其维护打开文件的描述符（open file descriptor）表</strong>。该表的每一条目都记录了单个文件描述符的相关信息，如下所示。</p><ul><li><strong>控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即 close-on-exec 标志，将在 27.4 节予以介绍。）</strong></li><li><strong>对打开文件句柄的引用。</strong></li></ul><p>​        内核对所有打开的文件维护有一个系统级的描述表格（open file description table）。<strong>有时，也称之为打开文件表（open file table），并将表中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示。</strong></p><ul><li>当前文件偏移量（调用 read()和 write()时更新，或使用 lseek()直接修改）。</li><li>打开文件时所使用的状态标志（即，open()的 flags 参数）。</li><li>文件访问模式（如调用 open()时所设置的只读模式、只写模式或读写模式）。</li><li>与信号驱动 I/O 相关的设置（见 63.3 节）。</li><li>对该文件 i-node 对象的引用。</li></ul><p>​        每个文件系统都会为驻留其上的所有文件建立一个 i-node 表。第 14 章将详细讨论 i-node 结构和文件系统的总体结构。这里只是列出每个文件的 i-node 信息，具体如下。</p><ul><li>文件类型（例如，常规文件、套接字或 FIFO）和访问权限。</li><li>一个指针，指向该文件所持有的锁的列表。</li><li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳。</li></ul><p>​        打开的文件句柄以及 i-node 之间的关系。在下图中，两个进程拥有诸多打开的文件描述符。在进程 A 中，文件描述符 1 和 20 都指向同一个打开的文件句柄（标号为 23）。这可能是通过调用 dup()、dup2()或 fcntl()而形成的（参见 5.5 节）。进程A的文件描述符2和进程B的文件描述符2都指向同一个打开的文件句柄（标号为73）。这种情形可能在调用 fork()后出现（即，进程 A 与进程 B 之间是父子关系），或者当某进程通过UNIX 域套接字将一个打开的文件描述符传递给另一进程时，也会发生（参见 61.13.3 节）。此外，进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件句柄，但这些句柄均指向 i-node 表中的相同条目（1976），换言之，指向同一文件。发生这种情况是因为每个进程各自对同一文件发起了 open()调用。同一个进程两次打开同一文件，也会发生类似情况。上述讨论揭示出如下要点。</p><ul><li>两个不同的文件描述符，若指向同一打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用 read()、write()或 lseek()所致），那么从另一文件描述符中也会观察到这一变化。无论这两个文件描述符分属于不同进程，还是同属于一个进程，情况都是如此。</li><li>要获取和修改打开的文件标志（例如，O_APPEND、O_NONBLOCK 和 O_ASYNC），可执行 fcntl()的 F_GETFL 和 F_SETFL 操作，其对作用域的约束与上一条颇为类似。</li><li>相形之下，文件描述符标志（亦即，close-on-exec 标志）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符。</li></ul><p><img src="image-20230803175434477.png" alt="image-20230803175434477"></p><h2 id="复制文件描述符"><a href="#复制文件描述符" class="headerlink" title="复制文件描述符"></a>复制文件描述符</h2><p>​        Bourne shell 的 I/O 重定向语法 2&gt;&amp;1，意在通知 shell 把标准错误（文件描述符 2）重定向到标准输出（文件描述符 1）。因此，下列命令将把（因为 shell 按从左至右的顺序处理 I/O 重定向语句）标准输出和标准错误写入 result.log 文件：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;myscript 2&gt;&amp;1 | less<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        shell 通过复制文件描述符 21实现了标准错误的重定向操作，因此文件描述符 2 与文件描述符 1 指向同一个打开文件句柄（类似于图 5-2 中进程 A 的描述符 1 和 20 指向同一打开文件句柄的情况）。可以通过调用 dup()和 dup2()来实现此功能。</p><p>​        请注意，要满足 shell 的这一要求，仅仅简单地打开 results.log 文件两次是远远不够的（第一次在描述符 1 上打开，第二次在描述符 2 上打开）。首先两个文件描述符不能共享相同的文件偏移量指针，因此有可能导致相互覆盖彼此的输出。再者打开的文件不一定就是磁盘文件。在如下命令中，标准错误就将和标准输出一起送达同一管道：</p><p><img src="image-20230803175629749.png" alt="image-20230803175629749"></p><p>​        <strong>dup()调用复制一个打开的文件描述符 oldfd，并返回一个新描述符，二者都指向同一打开的文件句柄。系统会保证新描述符一定是编号值最低的未用文件描述符。</strong></p><p><img src="image-20230803175616029.png" alt="image-20230803175616029"></p><p>​        假设发起如下调用：</p><pre class="line-numbers language-none"><code class="language-none">newfd &#x3D; dup(1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        再假定在正常情况下，shell 已经代表程序打开了文件描述符 0、1 和 2，且没有其他描述符在用，dup()调用会创建文件描述符 1 的副本，返回的文件描述符编号值为 3。如果希望返回文件描述符 2，可以使用如下技术：</p><p><img src="image-20230803175648334.png" alt="image-20230803175648334"></p><p>​        <strong>只有当描述符 0 已经打开时，这段代码方可工作。如果想进一步简化上述代码，同时总是能获得所期望的文件描述符，可以调用 dup2()。</strong></p><p><img src="image-20230803175701621.png" alt="image-20230803175701621"></p><p>​        dup2()系统调用会为 oldfd 参数所指定的文件描述符创建副本，其编号由 newfd 参数指定。<strong>如果由 newfd 参数所指定编号的文件描述符之前已经打开，那么 dup2()会首先将其关闭。（dup2()调用会默然忽略 newfd 关闭期间出现的任何错误。</strong>故此，编码时更为安全的做法是：<strong>在调用dup2()之前，若 newfd 已经打开，则应显式调用 close()将其关闭。</strong>）</p><p>​        前述调用 close()和 dup()的代码可以简化为：</p><pre class="line-numbers language-none"><code class="language-none">dup2(1,2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        若调用 dup2()成功，则将返回副本的文件描述符编号（即 newfd 参数指定的值）。如果 oldfd 并非有效的文件描述符，那么 dup2()调用将失败并返回错误 EBADF，且不关闭 newfd。如果 oldfd 有效，且与 newfd 值相等，那么 dup2()将什么也不做，不关闭 newfd，并将其作为调用结果返回。</p><p>​        fcntl()的 F_DUPFD 操作是复制文件描述符的另一接口，更具灵活性。</p><p>​        该调用为 oldfd 创建一个副本，且将使用大于等于 startfd 的最小未用值作为描述符编号。该调用还能保证新描述符（newfd）编号落在特定的区间范围内。总是能将 dup()和 dup2()调用改写为对 close()和 fcntl()的调用，虽然前者更为简洁。（还需注意，正如手册页中所描述的，dup2()和 fcntl()二者返回的 errno 错误码存在一些差别。）</p><p>​        由图 5-2 可知，文件描述符的正、副本之间共享同一打开文件句柄所含的文件偏移量和状态标志。然而，新文件描述符有其自己的一套文件描述符标志，且其 close-on-exec 标志（FD_CLOEXEC）总是处于关闭状态。下面将要介绍的接口，可以直接控制新文件描述符的close-on-exec 标志。</p><p>​        <strong>dup3()系统调用完成的工作与 dup2()相同，只是新增了一个附加参数 flag，这是一个可以修改系统调用行为的位掩码。</strong></p><p><img src="image-20230803181405591.png" alt="image-20230803181405591"></p><p>​        目前，dup3()只支持一个标志 O_CLOEXEC，这将促使内核为新文件描述符设置 close-on-exec标志（FD_CLOEXEC）。设计该标志的缘由，类似于 4.3.1 节对 open()调用中 O_CLOEXEC 标志的描述。dup3()系统调用始见于 Linux 2.6.27，为 Linux 所特有。Linux 从 2.6.24 开始支持 fcntl()用于复制文件描述符的附加命令：F_DUPFD_CLOEXEC。该标志不仅实现了与 F_DUPFD 相同的功能，还为新文件描述符设置 close-on-exec 标志。同样，此命令之所以得以一显身手，其原因也类似于 open()调用中的 O_CLOEXEC 标志。SUSv3 并未论及 F_DUPFD_CLOEXEC 标志，但 SUSv4 对其作了规范。</p><h2 id="在文件特定偏移量处的-I-O：pread-和-pwrite"><a href="#在文件特定偏移量处的-I-O：pread-和-pwrite" class="headerlink" title="在文件特定偏移量处的 I/O：pread()和 pwrite()"></a>在文件特定偏移量处的 I/O：pread()和 pwrite()</h2><p>​        系统调用 pread()和 pwrite()完成与 read()和 write()相类似的工作，只是前两者会在 offset 参数所指定的位置进行文件 I/O 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。</p><p><img src="image-20230803181548445.png" alt="image-20230803181548445"></p><p>​        pread()调用等同于将如下调用纳入同一原子操作：对 pread()和 pwrite()而言，fd 所指代的文件必须是可定位的（即允许对文件描述符执行lseek()调用）。</p><p>​        多线程应用为这些系统调用提供了用武之地。正如第 29 章所述，进程下辖的所有线程将共享同一文件描述符表。这也意味着每个已打开文件的文件偏移量为所有线程所共享。当调用pread()或 pwrite()时，多个线程可同时对同一文件描述符执行 I/O 操作，且不会因其他线程修改文件偏移量而受到影响。如果还试图使用 lseek()和 read()(或 write())来代替 pread()（或pwrite()），那么将引发竞争状态，这类似于 5.1 节讨论 O_APPEND 标志时的描述（当多个进程的文件描述符指向相同的打开文件句柄时，使用 pread()和 pwrite()系统调用同样能够避免进程间出现竞争状态）。</p><pre class="line-numbers language-none"><code class="language-none">如果需要反复执行 lseek()，并伴之以文件 I&#x2F;O，那么 pread()和 pwrite()系统调用在某些情况下是具有性能优势的。这是因为执行单个 pread()（或 pwrite()）系统调用的成本要低于执行 lseek()和 read()（或 write()）两个系统调用。然而，较之于执行 I&#x2F;O 实际所需的时间，系统调用的开销就有些相形见绌了。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分散输入和集中输出（Scatter-Gather-I-O）：readv-和-writev"><a href="#分散输入和集中输出（Scatter-Gather-I-O）：readv-和-writev" class="headerlink" title="分散输入和集中输出（Scatter-Gather I/O）：readv() 和 writev()"></a>分散输入和集中输出（Scatter-Gather I/O）：readv() 和 writev()</h2><p>​        readv()和 writev()系统调用分别实现了分散输入和集中输出的功能。</p><p><img src="image-20230803181750097.png" alt="image-20230803181750097"></p><p>​        这些系统调用并非只对单个缓冲区进行读写操作，而是一次即可传输多个缓冲区的数据。数组 iov 定义了一组用来传输数据的缓冲区。整型数 iovcnt 则指定了 iov 的成员个数。iov 中的每个成员都是如下形式的数据结构。</p><p><img src="image-20230803181801884.png" alt="image-20230803181801884"></p><pre class="line-numbers language-none"><code class="language-none">SUSv3 标准允许系统实现对 iov 中的成员个数加以限制。系统实现可以通过定义&lt;limits.h&gt;文件中 IOV_MAX 来通告这一限额，程序也可以在系统运行时调用 sysconf (_SC_ IOV_MAX)来获取这一限额。（11.2 节将介绍 sysconf()。）SUSv3 要求该限额不得少于 16。Linux将 IOV_MAX 的值定义为 1024，这是与内核对该向量大小的限制（由内核常量 UIO_MAXIOV定义）相对应的。然而，glibc 对 readv()和 writev()的封装函数1还悄悄做了些额外工作。若系统调用因iovcnt 参数值过大而失败，外壳函数将临时分配一块缓冲区，其大小足以容纳 iov 参数所有成员所描述的数据缓冲区，随后再执行 read()或 write()调用（参见后文对使用 write()实现writev()功能的讨论）。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>图 5-3 展示的是一个关于 iov、iovcnt 以及 iov 指向缓冲区之间关系的示例。</p><p><img src="image-20230803181844559.png" alt="image-20230803181844559"></p><h4 id="分散输入"><a href="#分散输入" class="headerlink" title="分散输入"></a>分散输入</h4><p>​        readv()系统调用实现了分散输入的功能：从文件描述符 fd 所指代的文件中读取一片连续的字节，然后将其散置（“分散放置”）于 iov 指定的缓冲区中。这一散置动作从 iov[0]开始，依次填满每个缓冲区。原子性是 readv()的重要属性。换言之，从调用进程的角度来看，当调用 readv()时，内核在 fd 所指代的文件与用户内存之间一次性地完成了数据转移。这意味着，假设即使有另一进程（或线程）与其共享同一文件偏移量，且在调用 readv()的同时企图修改文件偏移量，readv()所读取的数据仍将是连续的。调用 readv()成功将返回读取的字节数，若文件结束1将返回 0。调用者必须对返回值进行检查，以验证读取的字节数是否满足要求。若数据不足以填充所有缓冲区，则只会占用2部分缓冲区，其中最后一个缓冲区可能只存有部分数据。程序清单 5-2 展示了 readv()的用法。在本书中，当以函数名称冠以“t_”来命名示例程序时（例如：程序清单 5-2 中的程序t_readv.c），意在表明该程序主要用于展示单个系统调用或库函数的用法。程序清单 5-2：使用 readv()执行分散输入 _</p><p><img src="image-20230803181920503.png" alt="image-20230803181920503"></p><p><img src="image-20230803181925983.png" alt="image-20230803181925983"></p><h4 id="集中输出"><a href="#集中输出" class="headerlink" title="集中输出"></a>集中输出</h4><p>​        writev()系统调用实现了集中输出：将 iov 所指定的所有缓冲区中的数据拼接（“集中”）起来，然后以连续的字节序列写入文件描述符 fd 指代的文件中。对缓冲区中数据的“集中”始于iov[0]所指定的缓冲区，并按数组顺序展开。像 readv()调用一样，writev()调用也属于原子操作，即所有数据将一次性地从用户内存传输到 fd 指代的文件中。因此，在向普通文件写入数据时，writev()调用会把所有的请求数据连续写入文件，而不会在其他进程（或线程）写操作的影响下1分散地写入文件2。</p><p>​        如同 write()调用，writev()调用也可能存在部分写的问题。因此，必须检查 writev()调用的返回值，以确定写入的字节数是否与要求相符。</p><p>​        readv()调用和 writev()调用的主要优势在于便捷。如下两种方案，任选其一都可替代对writev()的调用。</p><ul><li>编码时，首先分配一个大缓冲区，随即再从进程地址空间的其他位置将数据复制过来，最后调用 write()输出其中的所有数据。</li><li>发起一系列 write()调用，逐一输出每个缓冲区中的数据。</li></ul><p>​        尽管方案一在语义上等同于 writev()调用，但需要在用户空间内分配缓冲区，进行数据复制，很不方便（效率也低）。方案二在语义上就不同于单次的 writev()调用，因为发起多次 write()调用将无法保证原子性。更何况，执行一次 writev()调用比执行多次 write()调用开销要小（参见 3.1 节关于系统调用的讨论）。</p><h4 id="在指定的文件偏移量处执行分散输入-集中输出"><a href="#在指定的文件偏移量处执行分散输入-集中输出" class="headerlink" title="在指定的文件偏移量处执行分散输入/集中输出"></a>在指定的文件偏移量处执行分散输入/集中输出</h4><p>​        Linux 2.6.30 版本新增了两个系统调用：preadv()、pwritev()，将分散输入/集中输出和于指定文件偏移量处的 I/O 二者集于一身。它们并非标准的系统调用，但获得了现代 BSD 的支持。 </p><p><img src="image-20230803182034792.png" alt="image-20230803182034792"></p><p>​        preadv()和 pwritev()系统调用所执行的任务与 readv()和 writev()相同，但执行 I/O 的位置将由 offset 参数指定（类似于 pread()和 pwrite()系统调用）1。对于那些既想从分散-集中 I/O 中受益，又不愿受制于当前文件偏移量的应用程序（比如，多线程的应用程序）而言，这些系统调用恰好可以派上用场。</p><h2 id="截断文件：truncate-和-ftruncate-系统调用"><a href="#截断文件：truncate-和-ftruncate-系统调用" class="headerlink" title="截断文件：truncate()和 ftruncate()系统调用"></a>截断文件：truncate()和 ftruncate()系统调用</h2><p>​        truncate()和 ftruncate()系统调用将文件大小设置为 length 参数指定的值。</p><p><img src="image-20230803183805730.png" alt="image-20230803183805730"></p><p>​        <strong>若文件当前长度大于参数 length，调用将丢弃超出部分，若小于参数 length，调用将在文件尾部添加一系列空字节或是一个文件空洞。</strong>两个系统调用之间的差别在于如何指定操作文件。truncate()以路径名字符串来指定文件，并要求可访问该文件2，且对文件拥有写权限。若文件名为符号链接，那么调用将对其进行解引用。而调用 ftruncate()之前，需以可写方式打开操作文件，获取其文件描述符以指代该文件，该系统调用不会修改文件偏移量。若 ftruncate()的 length 参数值超出文件的当前大小，SUSv3 允许两种行为：要<strong>么扩展该文件（如 Linux），要么返回错误。而符合 XSI 标准的系统则必须采取前一种行为。相同的情况，对于 truncate()系统调用，SUSv3 则要求总是能扩展文件。truncate()无需先以 open()（或是一些其他方法）来获取文件描述符，却可修改文件内容，在系统调用中可谓独树一帜。</strong></p><h2 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h2><p>​        在打开文件时指定 O_NONBLOCK 标志，目的有二。</p><ul><li>若 open()调用未能立即打开文件，则返回错误，而非陷入阻塞。有一种情况属于例外，调用 open()操作 FIFO 可能会陷入阻塞（参见 44.7 节）。</li><li>调用 open()成功后，后续的 I/O 操作也是非阻塞的。若 I/O 系统调用未能立即完成，则可能会只传输部分数据，或者系统调用失败，并返回 EAGAIN 或 EWOULDBLOCK 错误。具体返回何种错误将依赖于系统调用。Linux 系统与许多 UNIX 实现一样，将两个错误常量视为同义。</li></ul><p>​        管道、FIFO、套接字、设备（比如终端、伪终端）都支持非阻塞模式。（因为无法通过 open()来获取管道和套接字的文件描述符，所以要启用非阻塞标志，就必须使用 5.3 节所述 fcntl()的F_SETFL 命令。）正如 13.1 节所述，由于内核缓冲区保证了普通文件 I/O 不会陷入阻塞，故而打开普通文件时一般会忽略 O_NONBLOCK 标志。然而，当使用强制文件锁时（55.4 节），O_NONBLOCK标志对普通文件也是起作用的。更多关于非阻塞 I/O 的信息请参见 44.9 节和第 63 章。</p><pre class="line-numbers language-none"><code class="language-none">历史上，派生自 System V 的系统提供有 O_NDELAY 标志，语义上类似于 O_ NONBLOCK标志。二者主要的区别在于：在 System V 系统中，若非阻塞的 write()调用未能完成写操作，或者非阻塞的 read()调用无输入数据可读时，则两个调用将返回 0。这对于 read()调用来说会有问题，因为程序将无法区分返回 0 的 read()到底是没有可用的输入数据，还是遇到了文件结尾1。故而 POSIX.1 标准在初版中引入了 O_NONBLOCLK 标志。有些UNIX 实现一直还在支持旧语义的 O_NDELAY 标志。Linux 系统虽然也定义了 O_NDELAY常量，但其与 O_NONBLOCK 标志同义。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-10-大文件-I-O"><a href="#5-10-大文件-I-O" class="headerlink" title="5.10 大文件 I/O"></a>5.10 大文件 I/O</h2><p>​        通常将存放文件偏移量的数据类型 off_t 实现为一个有符号的长整型。（之所以采用有符号数据类型，是要以−1 来表示错误情况。）在 32 位体系架构中（比如 x86-32），这将文件大小置于 $2^{31}−1 $个字节（即 2GB）的限制之下。</p><p>​        然而，磁盘驱动器的容量早已超出这一限制，因此 32 位 UNIX 实现有处理超过 2GB 大小文件的需求，这也在情理之中。由于问题较为普遍，UNIX 厂商联盟在大型文件峰会（Large File Summit）上就此进行了协商，并针对必需的大文件访问功能，形成了对 SUSv2 规范的扩展。</p><p>​        始于内核版本 2.4，32 位 Linux 系统开始提供对 LFS 的支持（glibc 版本必须为 2.2 或更高）。另一个前提是，相应的文件系统也必须支持大文件操作。大多数“原生”Linux 文件系统提供了 LFS 支持，但一些“非原生”文件系统则未提供该功能（微软的 VFAT 和 NFSv2 系统是其中较为知名的范例，无论系统是否启用了 LFS 扩展功能，2GB 的文件大小限制都是硬杠杠）。</p><pre class="line-numbers language-none"><code class="language-none">由于 64 位系统架构（例如，Alpha、IA-64）的长整型类型长度为 64 位，故而 LFS 增强特性所要突破的限制对其而言并不是问题。然而，即便在64 位系统中，一些“原生”Linux 文件系统的实现细节还是将文件大小的理论值默认为不会超过 2^63−1 个字节。在大多数情况下，此限额远远超出了目前的磁盘容量，故而这一对文件大小的限制并无实际意义。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        应用程序可使用如下两种方式之一以获得 LFS 功能。</p><ul><li>使用支持大文件操作的备选 API。该 API 由 LFS 设计，意在作为 SUS 规范的“过渡型扩展”。因此，尽管大部分系统都支持这一 API，但这对于符合 SUSv2 或 SUSv3 规范的系统其实并非必须。这一方法现已过时。</li><li>在编译应用程序时，将宏_FILE_OFFSET_BITS 的值定义为 64。这一方法更为可取，因为符合 SUS 规范的应用程序无需修改任何源码即可获得 LFS 功能。</li></ul><h4 id="过渡型-LFS-API"><a href="#过渡型-LFS-API" class="headerlink" title="过渡型 LFS API"></a>过渡型 LFS API</h4><p>​        要使用过渡型的 LFS API，必须在编译程序时定义_LARGEFILE64_SOURCE 功能测试宏，该定义可以通过命令行指定，也可以定义于源文件中包含所有头文件之前的位置。该 API 所属函数具有处理 64 位文件大小和文件偏移量的能力。这些函数与其 32 位版本命名相同，只是尾部缀以 64 以示区别。其中包括：fopen64()、open64()、lseek64()、truncate64()、stat64()、mmap64()和 setrlimit64()。（针对这些函数的 32 位版本，本书前面已然讨论了一部分，还有一些将在后续章节中描述。）要访问大文件，可以使用这些函数的 64 位版本。例如，打开大文件的编码示例如下：调用 open64()，相当于在调用 open()时指定 O_LARGEFILE 标志。</p><p><img src="image-20230803184224033.png" alt="image-20230803184224033"></p><p>​        若调用 open()时未指定此标志，且欲打开的文件大小大于 2GB，那么调用将返回错误。另外，除去上述提及的函数之外，过渡型 LFS API 还增加了一些新的数据类型，如下所示 </p><p>struct stat64：类似于 stat 结构（参见 15.1 节），支持大文件尺寸。</p><p>off64_t：64 位类型，用于表示文件偏移量。</p><p>​        如程序清单 5-3 所示，除去使用了该 API 中的其他 64 位函数之外，lseek64()就用到了数据类型 off64_t。该程序接受两个命令行参数：欲打开的文件名称和给定的文件偏移量（整型）值。程序首先打开指定的文件，然后检索至给定的文件偏移量处，随即写入一串字符。如下所示的 shell会话中，程序检索到一个超大的文件偏移量处（超过 10GB），再写入一些字节：</p><p><img src="image-20230803184308492.png" alt="image-20230803184308492"></p><p>​        程序清单 5-3：访问大文件 </p><p><img src="image-20230803184333790.png" alt="image-20230803184333790"></p><p><img src="image-20230803184344338.png" alt="image-20230803184344338"></p><h4 id="FILE-OFFSET-BITS-宏"><a href="#FILE-OFFSET-BITS-宏" class="headerlink" title="_FILE_OFFSET_BITS 宏"></a>_FILE_OFFSET_BITS 宏</h4><p>​        要获取 LFS 功能，推荐的作法是：在编译程序时，将宏_FILE_OFFSET_BITS 的值定义为64。做法之一是利用 C 语言编译器的命令行选项：</p><p><img src="image-20230803184359092.png" alt="image-20230803184359092"></p><p>另外一种方法，是在 C 语言的源文件中，在包含所有头文件之前添加如下宏定义：</p><p><img src="image-20230803184405206.png" alt="image-20230803184405206"></p><p>​        所有相关的 32 位函数和数据类型将自动转换为 64 位版本。因而，例如，实际会将 open()转换为 open64()，数据类型 off_t 的长度也将转而定义为 64 位。换言之，无需对源码进行任何修改，只要对已有程序进行重新编译，就能够实现大文件操作。</p><p>​        显然，使用宏_FILE_OFFSET_BITS 要比采用过渡型的 LFS API 更为简单，但这也要求应用程序的代码编写必须规范（例如，声明用于放置文件偏移量的变量，应正确地使用 off_t，而不能使用“原生”的 C 语言整型）。</p><p>​        LFS 规范对于支持_FILE_OFFSET_BITS 宏未作硬性规定，仅仅提及将该宏作为指定数据类型 off_t 大小的可选方案。一些 UNIX 实现使用不同的特性测试宏来获取此功能。</p><pre class="line-numbers language-none"><code class="language-none">若试图使用 32 位函数访问大文件（即在编译程序时，未将宏_FILE_OFFSET_BITS 的值设置为 64），调用可能会返回 EOVERFLOW 错误。例如，为获取大小超过 2G 文件的信息，若使用 stat 的 32 位版本时就会遇到这一错误。_<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="向-printf-调用传递-off-t-值"><a href="#向-printf-调用传递-off-t-值" class="headerlink" title="向 printf()调用传递 off_t 值"></a>向 printf()调用传递 off_t 值</h4><p>​        LFS 扩展功能没有解决的问题之一是，如何向 printf()调用传递 off_t 值。3.6.2 节曾特别指出，对于预定义的系统数据类型（诸如 pid_t、uid_t），展示其值的可移植方法是将该值强制转换为 long 型，并在 printf()中使用限定符%ld。然而，一旦使用了 LFS 扩展功能，%ld 将不足以处理 off_t 数据类型，因为对该数据类型的定义可能会超出 long 类型的范围，一般为 long long类型。据此，若要显示 off_t 类型的值，则先要将其强制转换为 long long 类型，然后使用 printf()函数的%lld 限定符显示，如下所示：</p><p><img src="image-20230803184515230.png" alt="image-20230803184515230"></p><p>​        在处理 stat 结构所使用的 blkcnt_t 数据类型时，也应予以类似关注（参见 15.1 节的描述）。如需在独立的编译模块之间传递 off_t 或 stat 类型的参数值，则需确保在所有模块中，这些数据类型的大小相同（即编译这些模块时，要么将宏_FILE_OFFSET_BITS 的值都定义为 64，要么都不做定义）。</p><h2 id="dev-fd-目录"><a href="#dev-fd-目录" class="headerlink" title="/dev/fd 目录"></a>/dev/fd 目录</h2><p>​        对于每个进程，内核都提供有一个特殊的虚拟目录/dev/fd。该目录中包含“/dev/fd/n”形式的文件名，其中 n 是与进程中的打开文件描述符相对应的编号。因此，例如，/dev/fd/0 就对应于进程的标准输入。（SUSv3 对/dev/fd 特性未做规定，但有些其他的 UNIX 实现也提供了这一特性。）</p><p>​        打开/dev/fd 目录中的一个文件等同于复制相应的文件描述符，所以下列两行代码是等价的：</p><p><img src="image-20230803184537756.png" alt="image-20230803184537756"></p><p>​        在为 open()调用设置 flag 参数时，需要注意将其设置为与原描述符相同的访问模式。这一场景下，在 flag 标志的设置中引入其他标志，诸如 O_CREAT，是毫无意义的（系统会将其忽略）。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;dev&#x2F;fd 实际上是一个符号链接，链接到 Linux 所专有的&#x2F;proc&#x2F;self&#x2F;fd 目录。后者又是 Linux特有的&#x2F;proc&#x2F;PID&#x2F;fd 目录族的特例之一，此目录族中的每一目录都包含有符号链接，与一进程所打开的所有文件相对应。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        程序中很少会使用/dev/fd 目录中的文件。其主要用途在 shell 中。许多用户级 shell 命令将文件名作为参数，有时需要将命令输出至管道，并将某个参数替换为标准输入或标准输出。出于这一目的，有些命令（例如，diff、ed、tar 和 comm）提供了一个解决方法，使用“-”符号作为命令的参数之一，用以表示标准输入或输出（视情况而定）。所以，要比较 ls 命令输出的文件名列表与之前生成的文件名列表，命令就可以写成：</p><pre class="line-numbers language-none"><code class="language-none">ls | diff - oldfilelist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这种方法有不少问题。首先，该方法要求每个程序都对“-”符号做专门处理，但是许多程序并未实现这样的功能，这些命令只能处理文件，不支持将标准输入或输出作为参数。</p><p>​        其次，有些程序还将单个“-”符解释为表征命令行选项结束的分隔符。使用/dev/fd 目录，上述问题将迎刃而解，可以把标准输入、标准输出和标准错误作为文件名参数传递给任何需要它们的程序。所以，可以将前一个 shell 命令改写成如下形式：</p><pre class="line-numbers language-none"><code class="language-none">ls | diff &#x2F;dev&#x2F;fd&#x2F;0 oldfilelist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        方便起见，系统还提供了 3 个符号链接：/dev/stdin、/dev/stdout 和/dev/stderr，分别链接到/dev/fd/0、/dev/fd/1 和/dev/fd/2。</p><h2 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h2><p>​        有些程序需要创建一些临时文件，仅供其在运行期间使用，程序终止后即行删除。例如，很多编译器程序会在编译过程中创建临时文件。GNU C 语言函数库为此而提供了一系列库函数。（之所以有“一系列”的库函数，部分原因是由于这些函数分别继承自各种 UNIX 实现。）本节将介绍其中的两个函数：mkstemp()和 tmpfile()。</p><p>​        <strong>基于调用者提供的模板，mkstemp()函数生成一个唯一文件名并打开该文件，返回一个可用于 I/O 调用的文件描述符。</strong></p><p><img src="image-20230803184721401.png" alt="image-20230803184721401"></p><p>​        模板参数采用路径名形式，其中最后 6 个字符必须为 XXXXXX。这 6 个字符将被替换，以保证文件名的唯一性，且修改后的字符串将通过 template 参数传回。因为会对传入的 template参数进行修改，所以必须将其指定为字符数组，而非字符串常量。</p><p>​        文件拥有者对 mkstemp()函数建立的文件拥有读写权限（其他用户则没有任何操作权限），且打开文件时使用了 O_EXCL 标志，以保证调用者以独占方式访问文件。</p><p>​        通常，打开临时文件不久，程序就会使用 unlink 系统调用（参见 18.3 节）将其删除。故而，mkstemp()函数的示例代码如下所示：</p><p><img src="image-20230803184801020.png" alt="image-20230803184801020"></p><p>​        使用 tmpnam()、tempnam()和 mktemp()函数也能生成唯一的文件名。然而，由于这会导致应用程序出现安全漏洞，应当避免使用这些函数。关于这些函数的进一步细节请参考手册页。tmpfile()函数会创建一个名称唯一的临时文件，并以读写方式将其打开。（打开该文件时使用了 O_EXCL 标志，以防一个可能性极小的冲突，即另一个进程已经创建了一个同名文件。）tmpfile()函数执行成功，将返回一个文件流供 stdio 库函数使用。文件流关闭后将自动删除临时文件。为达到这一目的，tmpfile()函数会在打开文件后，从内部立即调用 unlink()来删除该文件名1。 1 译者注：进程终止时会关闭所有打开的文件描述符，关闭文件就会删除这些临时文件（参考 mkstmp 代码示例中的注释），由此可以推导出，进程退出时将自动删除临时文件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        本章介绍了原子操作的概念，这对于一些系统调用的正确操作至关重要。特别是，指定O_EXCL 标志调用 open()，这确保了调用者就是文件的创建者。而指定 O_APPEND 标志来调用 open()，还确保了多个进程在对同一文件追加数据时不会覆盖彼此的输出。系统调用 fcntl()可以执行许多文件控制操作，其中包括：修改打开文件的状态标志、复制文件描述符。使用 dup()和 dup2()系统调用也能实现文件描述符的复制功能。本章接着研究了文件描述符、打开文件句柄和文件 i-node 之间的关系，并特别指出这 3个对象各自包含的不同信息。文件描述符及其副本指向同一个打开文件句柄，所以也将共享打开文件的状态标志和文件偏移量。之后描述的诸多系统调用，是对常规 read()和 write()系统调用的功能扩展。pread()和pwrite()系统调用可在文件的指定位置处执行 I/O 功能，且不会修改文件偏移量。readv()和writev()系统调用实现了分散输入和集中输出的功能。preadv()和 pwritev()系统调用则集上述两对系统调用的功能于一身。使用 truncate() 和 ftruncate()系统调用，既可以丢弃多余的字节以缩小文件大小，又能使用填充为 0 的文件空洞来增加文件大小。本章还简单介绍了非阻塞 I/O 的概念，后续章节中还将继续讨论。LFS 规范定义了一套扩展功能，允许在 32 位系统中运行的进程来操作无法以 32 位表示的大文件。运用虚拟目录/dev/fd 中的编号文件，进程就可以通过文件描述符编号来访问自己打开的文件，这在 shell 命令中尤其有用。mkstemp()和 tmpfile()函数允许应用程序去创建临时文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix网络编程 - 1</title>
      <link href="/2023/08/17/Unix-network-programming-Guidance/"/>
      <url>/2023/08/17/Unix-network-programming-Guidance/</url>
      
        <content type="html"><![CDATA[<h1 id="Unix网络编程"><a href="#Unix网络编程" class="headerlink" title="Unix网络编程"></a>Unix网络编程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        我们一般认为Web服务器是一个长期运行的程序。一般的讲：我们的（通信）请求总是由客户发起的（想想某种浏览器）。大多数的网络应用都可以被划分成——客户（client）和服务器(server)</p><p>​        下图，你可以看到一个简单的模型</p><p><img src="image-20230817084042597-1692267130131-1.png" alt="image-20230817084042597">    </p><p>​            一般来讲，一个客户只跟一个服务器通信。但是一个服务器往往可以同时处理多个客户的请求（线程解决）</p><p><img src="image-20230817084516015-1692267130131-2.png" alt="image-20230817084516015"></p><p>（可以看到上面的图中一个服务器可以处理多个客户的请求）</p><p><img src="image-20230817171652172-1692267130131-3.png" alt="image-20230817171652172"></p><p>​        你也可以看到，这是一个客户和服务器通讯的一个基本的协议层次图。</p><p>​        客户与服务器之间的信息流在其中一端是向下通过协议栈的，跨越网络后，在另一端是向上通过协议栈的。客户和服务器通常是用户进程，而TCP和IP协议通常是内核中协议栈的一部分。</p><p>​        上图中术语IP自20世纪80年代以来一直在使用，其正式名称是IPv4（IP version 4），<strong>IPv4的新版本IPv6是在20世纪90年代中期开发出来的，将来会取代IPv4。</strong></p><p>​        客户和服务器无需如上图一样都处于一个局域网（LAN），可通过路由器将两个局域网连接到广域网（WAN）：</p><p><img src="image-20230817172011557-1692267130131-4.png" alt="image-20230817172011557"></p><p>​        路由器是广域网的架构设备。<strong>当今最大的广域网是因特网，许多公司也构建自己的广域网，这些私用的广域网既可以连接到因特网，也可以不连接。</strong></p><h2 id="一个简单的小程序"><a href="#一个简单的小程序" class="headerlink" title="一个简单的小程序"></a>一个简单的小程序</h2><p>​        来看一个返回时间的网络小程序：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;unp.h&gt;int main(int argc,char** agrv)&#123;    int sockfd, n;    char recvline[MAXLINE + 1];    struct sockaddr_in servaddr;    if(argc !&#x3D; 2)        err_quit(&quot;usage: a.out &lt;IPaddress&gt;&quot;);    if((sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)        err_sys(&quot;socket error&quot;);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sin_family &#x3D; AF_INET;    servaddr.sin_port &#x3D; htons(13); &#x2F;&#x2F; daytime server    if(inet_pton(AF_INET, agrv[1], &amp;servaddr.sin_addr) &lt;&#x3D; 0)        err_quit(&quot;inet_pton error for %s&quot;, agrv[1]);    if(connect(sockfd, (SA*)&amp;servaddr, sizeof(servaddr)) &lt; 0)        err_sys(&quot;connect error&quot;);    while((n &#x3D; read(sockfd, recvline, MAXLINE)) &gt; 0)    &#123;        recvline[n] &#x3D; 0; &#x2F;&#x2F; null terminate        if(fputs(recvline, stdout) &#x3D;&#x3D; EOF)            err_sys(&quot;fputs error&quot;);    &#125;    if(n &lt; 0)        err_sys(&quot;read error&quot;);    exit(0);        &#x2F;&#x2F; have no daytime server        &#x2F;&#x2F; try IPv4  129.6.15.28&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们对它进行编译：</p><p><img src="image-20230817172342839-1692267130132-5.png" alt="image-20230817172342839"></p><p>​        可以尝试IP：129.6.15.28。这个IP可以链接成功并且返回当地时间的。</p><p>​        下面，我们来简单的看看这个程序</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys&#x2F;socket.h&gt;#include &lt;netinet&#x2F;in.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define MAXLINE 512int main(int argc, char **argv) &#123;    int sockfd, n;    char recvline[MAXLINE + 1];    struct sockaddr_in servaddr;    &#x2F;&#x2F; 此结构位于头文件netinet&#x2F;in.h    if (argc !&#x3D; 2) &#123;        printf(&quot;usage: a.out &lt;IPaddress&gt;\n&quot;);exit(1);    &#125;    &#x2F;&#x2F; 作为一种编码风格，作者在两个左括号间加了一个空格，提示比较运算的左侧同时也是一个赋值运算    &#x2F;&#x2F; 这种风格借鉴自Minix源代码，下面的while语句也用了相同的格式    if ( (sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;    &#x2F;&#x2F; 创建一个网际（AF_INET）字节流（SOCK_STREAM）套接字，即TCP套接字，它返回一个小整数描述符，以后的函数调用（如connect和read函数）就用该描述符来标识这个套接字        printf(&quot;socket error\n&quot;);exit(1);    &#125;    bzero(&amp;servaddr, sizeof(servaddr));    &#x2F;&#x2F; bzero函数位于头文件string.h，把指定字节大小的地址区域都置为0字节    servaddr.sin_family &#x3D; AF_INET;    &#x2F;&#x2F; 置地址族为AF_INET    servaddr.sin_port &#x3D; htons(13);    &#x2F;&#x2F; daytime server的端口号为13，htons函数将短整型变量从主机字节顺序转变成网络字节顺序（高位字节存在低地址处）    if (inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;&#x3D; 0) &#123;    &#x2F;&#x2F; inet_pton函数将点分十进制IP地址转换为二进制                                                                   &#x2F;&#x2F; inet_pton函数是支持IPv6的新函数，以前的代码使用inet_addr函数将ASCII点分十进制串变成正确形式，但inet_addr函数有很多局限，这些局限都在inet_pton函数中被纠正        printf(&quot;inet_pton error for %s\n&quot;, argv[1]);exit(1);    &#125;        &#x2F;&#x2F; connect函数与它的第二个参数指向的套接字地址结构所指定的服务器建立TCP连接    &#x2F;&#x2F; 第三个参数是这个套接字地址结构的长度，对于网际套接字地址结构，我们总是使用C语言的sizeof操作符由编译器来计算这个长度    &#x2F;&#x2F; 第二个参数我们用sockaddr类型指针指向了sockaddr_in类型，因为sockaddr类型是通用套接字地址结构    &#x2F;&#x2F; 每当一个套接字函数需要一个指向某个套接字地址结构的指针时，这个指针必须强制类型转换成一个指向通用套接字地址结构的指针    &#x2F;&#x2F; 这是因为套接字函数早于ANSI C标准，20世纪80年代开发这些函数时，ANSI C的void *指针类型还不可用    &#x2F;&#x2F; 但转换时，struct sockaddr长达15个字符，往往造成源代码超出屏幕右边缘，因此我们可以使用#define将其简化为SA    if (connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;    &#x2F;&#x2F; sockaddr结构位于头文件sys&#x2F;socket.h        printf(&quot;connect error\n&quot;);perror(&quot;connect&quot;);    &#x2F;&#x2F; perror函数将其参数和errno所对应的错误一起输出到标准错误exit(1);    &#125;    &#x2F;&#x2F; 此处需要while循环，因为服务器可能会将TCP分节，我们一次只能读取单个分节，需要一直读取，直到read函数返回0（对端关闭连接）或负数（发生错误），此程序中，服务器关闭连接表示记录接收结束    while ( (n &#x3D; read(sockfd, recvline, MAXLINE)) &gt; 0) &#123;        recvline[n] &#x3D; 0;    &#x2F;&#x2F; null terminate        if (fputs(recvline, stdout) &#x3D;&#x3D; EOF) &#123;    printf(&quot;fputs error\n&quot;);    exit(1);&#125;    &#125;    if (n &lt; 0) &#123;        printf(&quot;fputs error\n&quot;);    &#125;    exit(0);    &#x2F;&#x2F; 结束程序，内核会关闭所有打开的文件描述符，套接字就此被关闭&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们的socket函数创建了一个叫<strong>网际字节流的东西（AF_INET SOCK_STREAM）</strong>。返回的是一个整形描述符，我们就是用它来代替链接进行后续的操作</p><p>​        这里有一个技巧：请看</p><pre class="line-numbers language-none"><code class="language-none">if ( (sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0) ) &lt; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        实际上，这里使用了C语言的一个重要的特性：也就是运算符优先级</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);if(sockfd &lt; 0)&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是跟上面的话是等效的。</p><p>​         随后，我们指定服务器的IP地址和端口：服务器的IP地址和端口号填入一个网际套接字地址结构（一个名为servaddr的sockaddr_in结构变量）。网际套接字地址结构中IP地址和端口号这两个成员必须使用特定格式，<strong>htons（“主机到网络短整数”）去转换二进制端口号，inet_pton(“呈现形式到数值”)把ASCII命令行参数转换为合适的格式。</strong></p><p>​        接着，当我们指定好了服务器的IP地址和端口之后，实际上我们就是知道了服务器的位置，下面就是建立联系。</p><p>​        connect函数应用于一个TCP套接字时，将与由它的第二个参数指向的套接字地址结构指定的服务器建立一个TCP连接。该套接字结构的长度也必须作为该函数的第三个参数指定，对于网际套接字地址结构，用sizeof操作符指定。每当一个套接字函数需要一个指向某个套接字地址结构的指针时，<strong>这个指针必须强制类型转换成一个指向通用套接字地址结构的指针。</strong></p><pre><code>     建立联系后就是拿到服务器的数据了：**读入并输出服务器的应答**：通常服务器返回包含所有字节的单个分节，但是如果数据量很大，就不能保证一次read调用能返回服务器的整个应答。因此从TCP套接字读取数据时，总是需要把read编写在某个循环中，当read返回0（表明对端关闭连接）或者负值（表明发生错误）时终止循环。</code></pre><p>​        这就是我们拿到的联系：</p><p><img src="image-20230817173715614-1692267130132-6.png" alt="image-20230817173715614"></p><p>​        注意到我们这里并没有转化为我们可以读到的格式。</p><p>​        为什么我们要：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while ( (n &#x3D; read(sockfd, recvline, MAXLINE)) &gt; 0) &#123;       recvline[n] &#x3D; 0;    &#x2F;&#x2F; null terminate       if (fputs(recvline, stdout) &#x3D;&#x3D; EOF) &#123;    printf(&quot;fputs error\n&quot;);    exit(1);&#125;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        呢？答案是，我们没有办法保证我们一次就可以读完所有的数据。如果数据量很大，我们就不能确保一次read调用能返回服务器的整个应答，因此从TCP套接字读取数据时，我们总是需要把read函数编写在某个循环中，当read函数返回0（表明对端关闭连接）或负值（表明发生错误）时终止循环。</p><p>​        上例中，服务器关闭连接表征记录的结束，HTTP（Hypertext Transfer Protocol，超文本传送协议）的1.0版本也采用这种技术。也可用其他技术标识记录结束，如SMTP（Simple Mail Transfer Protocol，简单邮件传送协议）使用由ASCII回车符后跟换行符构成的2字节序列标记记录的结束；Sun远程过程调用和域名系统在每个要发送的记录前放置一个二进制计数值，给出这个记录的长度。这里的重要概念是TCP本身不提供记录结束标志，应用需要自己实现记录边界的确定。</p><p>​        我们的协议使用的是IPv4，注意到的是他不可以直接搬到IPv6上运行。我们需要做一些修改</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys&#x2F;socket.h&gt;#include &lt;netinet&#x2F;in.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#define MAXLINE 512int main(int argc, char **argv) &#123;    int sockfd, n;    char recvline[MAXLINE + 1];&#x2F;&#x2F;  struct sockaddr_in servaddr;        struct sockaddr_in6 servaddr;    if (argc !&#x3D; 2) &#123;        printf(&quot;usage: a.out &lt;IPaddress&gt;\n&quot;);exit(1);    &#125;&#x2F;&#x2F;  if ( (sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;    if ( (sockfd &#x3D; socket(AF_INET6, SOCK_STREAM, 0)) &lt; 0) &#123;           printf(&quot;socket error\n&quot;);exit(1);    &#125;    bzero(&amp;servaddr, sizeof(servaddr));&#x2F;&#x2F;  servaddr.sin_family &#x3D; AF_INET;    servaddr.sin6_family &#x3D; AF_INET6;&#x2F;&#x2F;  servaddr.sin_port &#x3D; htons(13);    servaddr.sin6_port &#x3D; htons(13);&#x2F;&#x2F;  if (inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;&#x3D; 0) &#123;     if (inet_pton(AF_INET6, argv[1], &amp;servaddr.sin6_addr) &lt;&#x3D; 0) &#123;           printf(&quot;inet_pton error for %s\n&quot;, argv[1]);exit(1);    &#125;        if (connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;           printf(&quot;connect error\n&quot;);perror(&quot;connect&quot;);    exit(1);    &#125;    while ( (n &#x3D; read(sockfd, recvline, MAXLINE)) &gt; 0) &#123;        recvline[n] &#x3D; 0;            if (fputs(recvline, stdout) &#x3D;&#x3D; EOF) &#123;    printf(&quot;fputs error\n&quot;);    exit(1);&#125;    &#125;    if (n &lt; 0) &#123;        printf(&quot;fputs error\n&quot;);    &#125;    exit(0);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        当然一个更好的做法是去编写一个与协议无关的程序——这个我们之后再说。</p><p>​        以上程序的另一个不足之处是，用户必须以点分十进制数格式给出服务器的IP地址，人们更习惯于用域名来代替数字。</p><p>​        以上程序中，当函数调用发生错误时，我们输出一个出错消息并终止程序运行，这是大多情况下的做法，<strong>个别情况下，我们要做的事并非简单地终止程序运行，如需要检查系统调用是否被中断了。</strong>既然大多情况下发生错误时需要终止程序，<strong>我们可以定义包裹函数来缩短程序，每个包裹函数完成实际的函数调用，检查返回值，并在发生错误时终止进程。包裹函数名一般是实际函数名的首字母大写形式，这是约定，</strong>如：</p><pre class="line-numbers language-none"><code class="language-none">int Socket(int family, int type, int protocol) &#123;    int n;    if ( (n &#x3D; socket(family, type, protocol)) &lt; 0) &#123;        err_sys(&quot;socket error\n&quot;);        exit(1);    &#125;    return n;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是一个良好的编程习惯（即handle我们的异常值和处理，同时简化代码，屏蔽掉无关竟要的细节）</p><p>​        熟知Unix系统编程的知道：errno值可以用来衡量错误是啥。但是一些函数是开在线程中的，我们需要手动的设置errno值并且返回调用端。</p><pre class="line-numbers language-none"><code class="language-none">线程函数在遇到错误是并不设置标准Unix errno变量，而是把errno的值作为函数返回值返回调用者，我们每次调用以pthread_开头的函数时，必须分配一个变量来存放函数返回值，以便在输出错误消息前把errno变量设置为该值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">void Pthread_mutex_lock(pthread_mutex_t *mptr) &#123;    int n;    if ( (n &#x3D; pthread_mutex_lock(mptr)) &#x3D;&#x3D; 0) &#123;        return;    &#125;    errno &#x3D; n;    err_sys(&quot;pthread_mutex_lock error&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展：Unix的errno值"><a href="#扩展：Unix的errno值" class="headerlink" title="扩展：Unix的errno值"></a>扩展：Unix的errno值</h3><p>​        只要一个Unix函数中有错误发生，<strong>全局变量errno就被置为一个指明该错误类型的正值，函数本身则通常返回-1。自定义函数err_sys查看errno变量的值并输出相应的出错消息，如errno值等于ETIMEDOUT时，输出”Connection timed out”。</strong></p><p>​        errno的值只在函数发生错误时设置，如果函数没有出错，errno的值就没有定义。errno的所有正数错误值都是常值，并有以E开头的全大写字母名，并通常在<sys/errno.h>头文件中定义。errno值0不表示任何错误。</p><h2 id="一个简单的时间获取服务器程序"><a href="#一个简单的时间获取服务器程序" class="headerlink" title="一个简单的时间获取服务器程序"></a>一个简单的时间获取服务器程序</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;unp.h&gt;#include &lt;time.h&gt;int main()&#123;    int listenfd, connfd;    struct sockaddr_in servaddr;    char buff[MAXLINE];    time_t ticks;    listenfd &#x3D; Socket(AF_INET, SOCK_STREAM, 0);    bzero(&amp;servaddr, sizeof(servaddr)); &#x2F;&#x2F; 初始化    servaddr.sin_family &#x3D; AF_INET;    servaddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);    servaddr.sin_port &#x3D; htons(13);    Bind(listenfd, (SA *)&amp;servaddr, sizeof(servaddr));    Listen(listenfd, LISTENQ);    for (;;)    &#123;        connfd &#x3D; Accept(listenfd, (SA *)NULL, NULL);        ticks &#x3D; time(NULL);        snprintf(buff, sizeof(buff), &quot;%.24s\r\n&quot;, ctime(&amp;ticks));        Write(connfd, buff, strlen(buff));        Close(connfd);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上述的城西完成了这几个动作：</p><p>​        监听套接字：listen函数将套接字转换成一个监听套接字，这样来自客户的外来连接就可在该套接字上由内核接受。LISTENQ指定系统内核允许在这个监听描述符上排队的最大客户连接数。<br>         接受客户连接，发送应答：通常情况，服务器进程在accept调用中被投入睡眠，等待某个客户连接的到达并被内核接受。TCP连接使用三路握手来建立连接，握手完毕accept返回一个已连接描述符，用于与客户通信。<br>         终止连接：服务器通过close关闭与客户的连接。该调用引发正常的TCP连接终止序列：每个方向上发送一个FIN，每个FIN又由各自对端确认</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;unp.h&quot;#include &lt;time.h&gt;int main(int argc, char **argv) &#123;    int listenfd, connfd;    struct sockaddr_in servaddr;    char buff[MAXLINE];    time_t ticks;    listenfd &#x3D; Socket(AF_INET, SOCK_STREAM, 0);    bzero(&amp;servaddr, sizeof(servaddr));    servaddr.sin_family &#x3D; AF_INET;    servaddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);    servaddr.sin_port &#x3D; htons(13);    &#x2F;* daytime server *&#x2F;    Bind(listenfd, (SA *)&amp;servaddr, sizeof(servaddr));    &#x2F;&#x2F; 调用listen函数将该套接字转换成一个监听套接字，这样来自客户的外来连接就可以在该套接字上由内核接收    &#x2F;&#x2F; LISTENQ在头文件unp.h中定义，它指定系统内核允许在这个监听描述符上排队的最大客户连接数    Listen(listenfd, LISTENQ);    &#x2F;&#x2F; socket、bind、listen这3个调用步骤是任何TCP服务器准备监听描述符的正常步骤    for (; ; ) &#123;        &#x2F;&#x2F; 通常，服务器进程在accept调用中被投入睡眠，等待某个客户连接的到达并被内核接受       &#x2F;&#x2F; TCP使用三路握手来建立连接，握手完毕时accept函数返回，其返回值是一个称为已连接描述符的新描述符，该描述符用于同新近连接的那个客户通信        &#x2F;&#x2F; accept函数为每个连接到本服务器的客户返回一个新描述符        connfd &#x3D; Accept(listenfd, (SA *)NULL, NULL);       &#x2F;&#x2F; time函数返回自Unix纪元（即19700101000000）以来的秒数ticks &#x3D; time(NULL);&#x2F;&#x2F; 相比于sprintf函数，snprintf函数要求其第二个参数指定目的缓冲区大小，因此可确保该缓冲区不溢出&#x2F;&#x2F; snprintf函数在ISO C99版本中才加入到ANSI C标准中，但几乎所有厂商都把它作为标准C函数库的一部分提供，出于可靠性考虑，可将其改为sprintf函数&#x2F;&#x2F; 但许多网络入侵是由黑客通过发送数据，导致服务器对sprintf调用使其缓冲区溢出而发生的&#x2F;&#x2F; 需要小心的函数还有gets、strcat、strcpy，通常应分别改为fgets、strncat、strncpy函数，更好的替代函数是strlcat和strlcpy，它们确保结果是正确终止的字符串snprintf(buff, sizeof(buff), &quot;%.24s\r\n&quot;, ctime(&amp;ticks));    &#x2F;&#x2F; %.24s表示最多打印24个字符，ctime函数返回一个25个字节的串，如&quot;Wed Jun 30 21:49:08 1993\n&quot;                                                             &#x2F;&#x2F; %24s表示最少打印24个字符Write(connfd, buff, strlen(buff));    &#x2F;&#x2F; 通过close调用关闭与客户的连接，该调用引发正常的TCP连接终止序列：每个方向上发送一个FIN，每个FIN又由各自的对端确认Close(connfd);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p>​        国际标准化组织（International Organization for Standardization，ISO）的开放系统互连（Open Systems Interconnection，OSI）模型，这是一个七层模型（图中还给出了它与网际协议族的近似映射）：</p><p><img src="8d760d7c2f744c9bad396817afc0035f-1692267130132-7.png" alt="在这里插入图片描述"></p><p>​        我们认为OSI模型的底下两层是随系统提供的设备驱动程序和网络硬件，通常，除需知道数据链路层的某些特性外（如1500字节的以太网MTU大小），我们不关心这两层情况。</p><p>​        上图网际协议族中，传输层的TCP和UDP中间留有空隙，表明网络应用可能绕过传输层直接使用IPv4或IPv6，这是所谓的原始套接字。我们甚至可以绕过IP层直接读写数据链路层的帧。</p><p>​        OSI模型的顶上三层在网际协议中被合并为一层，称为应用层，这是Web客户（浏览器）、Telnet客户、Web服务器、FTP服务器和其他我们使用的网络应用所在的层。对于网际协议，OSI模型的顶上三层协议几乎没有区别。</p><p>​        本书讲述的套接字编程接口是从OSI的顶上三层（即网际协议的应用层）进入传输层的接口。为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口？这样设计有两个理由：一是顶上三层处理具体网络应用（如FTP、Telnet、HTTP）的所有细节，却对通信细节了解很少；底下四层对具体网络应用了解不多，却处理所有通信细节（发送数据、等待确认、给无序到达的数据排序、计算并验证校验和等）。二是顶上三层通常构成所谓用户进程，底下四层通常作为操作系统内核的一部分提供，Unix与其他现代操作系统都提供分隔用户进程与内核的机制。由以上可见，OSI模型的第4层和第5层之间的接口是构建API的自然位置。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>​        如果发现配置完成了但是再VScode下还是会爆出undefined reference的问题，可以直接采用自己编译的方式，也就是在命令行中</p><pre class="line-numbers language-none"><code class="language-none">gcc -o result file.c &#x2F;usr&#x2F;lib&#x2F;libunp.a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        的方式。当然，自己找到file.c和libunp.a的位置！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux漫游——系统调用</title>
      <link href="/2023/08/16/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
      <url>/2023/08/16/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux漫游"><a href="#Linux漫游" class="headerlink" title="Linux漫游"></a>Linux漫游</h1><h2 id="系统调用概念"><a href="#系统调用概念" class="headerlink" title="系统调用概念"></a>系统调用概念</h2><h3 id="3-1-系统调用"><a href="#3-1-系统调用" class="headerlink" title="3.1 系统调用"></a>3.1 系统调用</h3><p>​        <strong>系统调用是受控的内核入口，借助于这一机制，进程可以请求内核以自己的名义去执行某些动作</strong>。以应用程序编程接口（API）的形式，内核提供有一系列服务供程序访问。</p><p>​        也就是说，我们将底层的一些操作封装起来，构成了系统函数。</p><p>​        在深入系统调用的运作方式之前，务必关注以下几点。</p><ul><li><strong>系统调用将处理器从用户态切换到核心态，以便 CPU 访问受到保护的内核内存。</strong></li><li>系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识。（程序通过名称来标识系统调用，对这一编号方案往往一无所知。）</li><li>每个系统调用可辅之以一套参数，对用户空间（亦即进程的虚拟地址空间）与内核空间之间（相互）传递的信息加以规范。</li></ul><p>下面以一个具体的硬件平台—x86-32 为例，按事件发生的顺序对这些步骤加以分析。</p><p>1． <strong>应用程序通过调用 C 语言函数库中的外壳（wrapper）函数，来发起系统调用。</strong></p><p>2． 对系统调用中断处理例程（稍后介绍）来说，<strong>外壳函数必须保证所有的系统调用参数可用。通过堆栈，这些参数传入外壳函数，但内核却希望将这些参数置入特定寄存器。</strong>因此，外壳函数会将<strong>上述参数复制到寄存器。</strong></p><p>3． 由于所有系统调用进入内核的方式相同，内核需要设法区分每个系统调用。为此，外壳函数会<strong>将系统调用编号复制到一个特殊的 CPU 寄存器（%eax）中。</strong></p><p>4． <strong>外壳函数执行一条中断机器指令（int 0x80），引发处理器从用户态切换到核心态，并执行系统中断 0x80 (十进制数 128)的中断矢量所指向的代码。</strong></p><p>5． 为响应中断 0x80，内核会<strong>调用 system _call()例程</strong>（位于汇编文件 arch/i386/entry.S 中）来处理这次中断，具体如下。</p><p>a）在内核栈中保存寄存器值（参见 6.5 节）。</p><p>b）审核系统调用编号的有效性。</p><p>c）以系统调用编号对存放所有调用服务例程的列表（内核变量 sys _call _table）进行索引，<strong>发现并调用相应的系统调用服务例程。若系统调用服务例程带有参数，那么将首先检查参数的有效性。</strong>例如，会检查地址指向用户空间的内存位置是否有效。随后，该服务例程会执行必要的任务，这可能涉及对特定参数中指定地址处的值进行修改，以及在用户内存和内核内存间传递数据（比如，在 I/O 操作中）<strong>。最后，该服务例程会将结果状态返回给 system _call()例程。</strong></p><p>d）从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中。</p><p>e）返回至外壳函数，同时将处理器切换回用户态。</p><p>6． 若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno（参见 3.4 节）。然后，外壳函数会返回到调用程序，并同时返回一个整型值，以表明系统调用是否成功。</p><p><img src="image-20230816211115576.png" alt="image-20230816211115576"></p><p>​        我们用<code>execve</code>这个函数举个例子。可以看到上图。</p><h3 id="3-2-库函数"><a href="#3-2-库函数" class="headerlink" title="3.2 库函数"></a>3.2 库函数</h3><p>​        设计库函数是为了提供比底层系统调用更为方便的调用接口。而库函数自己的功能也是丰富多样的。</p><h3 id="3-3-标准-C-语言函数库；GNU-C-语言函数库（glibc）标准-C-语言"><a href="#3-3-标准-C-语言函数库；GNU-C-语言函数库（glibc）标准-C-语言" class="headerlink" title="3.3 标准 C 语言函数库；GNU C 语言函数库（glibc）标准 C 语言"></a>3.3 标准 C 语言函数库；GNU C 语言函数库（glibc）标准 C 语言</h3><p>​        GNU C 语言函数库（glibc, <a href="http://www.gnu.org/software/libc/）是">http://www.gnu.org/software/libc/）是</a> Linux 上最常用的实现。确定glibc的方法很简答——我们只需要反解析依赖库，再查看版本即可</p><pre class="line-numbers language-none"><code class="language-none">dd file | grep libc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230816211824026.png" alt="image-20230816211824026"></p><h3 id="3-4-处理来自系统调用和库函数的错误"><a href="#3-4-处理来自系统调用和库函数的错误" class="headerlink" title="3.4 处理来自系统调用和库函数的错误"></a>3.4 处理来自系统调用和库函数的错误</h3><p>​        几乎所有的库函数都会返回状态值。要了解调用是否成功，必须坚持对状态值进行检查。若调用失败，那么必须采取相应行动。至少，程序应该显示错误消息，警示有意想不到的事件发生。</p><h4 id="处理系统调用错误"><a href="#处理系统调用错误" class="headerlink" title="处理系统调用错误"></a>处理系统调用错误</h4><p>​        每个系统调用的手册页记录有调用可能的返回值，并指出了哪些值表示错误。一般的，我们指出-1是一个常见的出错值。</p><p>​        另一方面，全局的errno值就会被设置以表示当前出错的状态和原因    </p><p>​        程序应包含<errno.h>头文件，该文件提供了对 errno 的声明，以及一组针对各种错误编号而定义的常量。所有这些符号名都以字母 E 打头。</p><p>​        函数 perror()会打印出其 msg 参数所指向的字符串，紧跟一条与当前 errno 值相对应的消息。（简单的理解为前置信息——是啥引发了错误呢？）</p><p>​        函数 strerror()会针对其 errnum 参数中所给定的错误号，返回相应的错误字符串 </p><p>​        strerror()所返回的字符串可以是静态分配的，这意味着后续对 strerror()的调用可能会覆盖该字符串。对于无法找到的，则会返回未知错误。</p><h4 id="处理来自库函数的错误"><a href="#处理来自库函数的错误" class="headerlink" title="处理来自库函数的错误"></a>处理来自库函数的错误</h4><ul><li><strong>某些库函数返回错误信息的方式与系统调用完全相同—返回值为−1，伴之以 errno号来表示具体错误。</strong>remove()便是其中一例，可使用该函数来删除文件（调用 unlink()系统调用）或目录（调用 rmdir()系统调用）。对此类函数所发生的错误进行诊断，其方式与系统调用完全相同。</li><li><strong>某些库函数在出错时会返回−1 之外的其他值，但仍会设置 errno 来表明具体的出错情况。</strong>例如，fopen()在出错时会返回一个 NULL 指针，还会根据出错的具体底层系统调 用来设置 errno。函数 perror()和 strerror()都可用来诊断此类错误</li><li><strong>还有些函数根本不使用 errno。</strong>对此类函数来说，确定错误存在与否及其起因的方法各不相同，可见诸于相应函数的手册页中，不应使用 errno、perror()或 strerror()来诊断错误。</li></ul><p>​        换而言之，使用函数之前务必参考手册！</p><h3 id="系统数据类型"><a href="#系统数据类型" class="headerlink" title="系统数据类型"></a>系统数据类型</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>类型要求</th><th>描述</th></tr></thead><tbody><tr><td>blkcnt_t</td><td>有符号整型</td><td>文件块数量</td></tr><tr><td>blksize_t</td><td>有符号整型</td><td>文件块大小</td></tr><tr><td>cc_t</td><td>无符号整型</td><td>终端特殊字符</td></tr><tr><td>clock_t</td><td>整型或者浮点型实数</td><td>以时钟周期计量的系统时间</td></tr><tr><td>clockid_t</td><td>运算类型之一</td><td>时钟和定时器函数的时钟标识符</td></tr><tr><td>comp_t</td><td>SUSv3未作规范</td><td>经由压缩处理的时钟周期</td></tr><tr><td>dev_t</td><td>运算类型之一</td><td>设备号，包括主/次设备号</td></tr><tr><td>DIR</td><td>无类型要求</td><td>目录流</td></tr><tr><td>fd_set</td><td>结构类型</td><td>select()中的文件描述符集</td></tr><tr><td>fsblkcnt_t</td><td>无符号整型</td><td>文件系统块数量</td></tr><tr><td>fsfilcnt_t</td><td>无符号整型</td><td>文件数量</td></tr><tr><td>gid_t</td><td>整型</td><td>数值型组标识符</td></tr><tr><td>id_t</td><td>整型</td><td>用以存放标识符的通用类型，其大小至少可放置pid_t，uid_t和gid_t类型</td></tr><tr><td>in_addr_t</td><td>32位无符号整型</td><td>IPv4地址</td></tr><tr><td>in_port_t</td><td>16位无符号整型</td><td>IP端口号</td></tr><tr><td>ino_t</td><td>无符号整型</td><td>文件i-node号</td></tr><tr><td>key_t</td><td>运算类型之一</td><td>System V IPC键</td></tr><tr><td>mode_t</td><td>整型</td><td>文件权限及类型</td></tr><tr><td>mqd_t</td><td>无类型要求，但是不能为数组类型</td><td>消息队列描述符</td></tr><tr><td>msglen_t</td><td>无符号整型</td><td>消息队列所允许的字节数</td></tr><tr><td>msgqnum_t</td><td>无符号整型</td><td>消息队列中的消息数量</td></tr><tr><td>nfds_t</td><td>无符号整型</td><td>poll()中文件描述符数量</td></tr><tr><td>nlink_t</td><td>整型</td><td>文件的（硬）连接数量</td></tr><tr><td>off_t</td><td>有符号整型</td><td>文件偏移量或大小</td></tr><tr><td>pid_t</td><td>有符号整型</td><td>进程ID，进程组ID或会话ID</td></tr><tr><td>ptrdiff_t</td><td>有符号整型</td><td>两指针差值，为有符号整型</td></tr><tr><td>rlim_t</td><td>无符号整型</td><td>资源限制</td></tr><tr><td>sa_family_t</td><td>无符号整型</td><td>套接字地址族</td></tr><tr><td>shmatt_t</td><td>无符号整型</td><td>与System V共享内存段相连的进程数量</td></tr><tr><td>sig_atomic_t</td><td>整型</td><td>可进行原子访问的数据类型</td></tr><tr><td>siginfo_t</td><td>结构类型</td><td>信号起源的相关信息</td></tr><tr><td>sigset_t</td><td>整型或者结构类型</td><td>信号集合</td></tr><tr><td>size_t</td><td>无符号整型</td><td>对象大小</td></tr><tr><td>socklen_t</td><td>至少32位的整型</td><td>套接字地址结构大小（以字节计数）</td></tr><tr><td>speed_t</td><td>无符号整型</td><td>终端线速度</td></tr><tr><td>ssize_t</td><td>有符号整型</td><td>字节数或（为负时）标识错误</td></tr><tr><td>stack_t</td><td>结构类型</td><td>对备选信号栈的描述</td></tr><tr><td>suseconds_t</td><td>有符号整型，范围为[-1~1000000]</td><td>微秒级的时间间隔</td></tr><tr><td>tcflag_t</td><td>无符号整型</td><td>终端模式标志位的位掩码</td></tr><tr><td>time_t</td><td>整型或者浮点型实数</td><td>自纪元开始，以秒计的日历时间</td></tr><tr><td>timer_t</td><td>运算类型之一</td><td>间隔定时器函数的定时器标识符</td></tr><tr><td>uid_t</td><td>整型</td><td>数组型用户标识符</td></tr></tbody></table></div><p>​        注意到——我们常常需要显示他们当中的类型，这里建议查阅完typedef之前的类型，再实际使用的时候先强制转化。可以有效避免不同系统实现问题</p><h2 id="Summury"><a href="#Summury" class="headerlink" title="Summury"></a>Summury</h2><p>​        系统调用允许进程向内核请求服务。与用户空间的函数调用相比，哪怕是最简单的系统调用都会产生显著的开销，其原因是为了执行系统调用，系统需要临时性地切换到核心态，此外，内核还需验证系统调用的参数、用户内存和内核内存之间也有数据需要传递。</p><p>​        标准的 C 语言函数库提供了大量库函数，功能五花八门。有些库函数会利用系统调用来完成工作，而另一些库函数则完全在用户空间内执行任务。在 Linux 上，一般情况下，使用 glibc作为 C 语言标准库的实现。大多数系统调用和库函数都会返回一个状态值，以表明调用成功与否。对这一返回状态进行检查是一条编程铁律。为本书的程序示例还实现有一批函数。其所执行的任务包括诊断错误和解析命令行参数。</p><p>​        本章也提供了一系列指南及技术，以帮助读者编写可移植的系统程序，此类程序可在任何符合标准的系统上运行。编译应用程序时，可定义不同的特性测试宏，以控制头文件显露对特定标准的定义。当希望确保程序符合某些正式或由实现定义的标准时，上述做法可谓是非常实用。</p><p>​        利用定义于各个标准中（而非原生 C 语言类型）的系统数据类型，能够改善系统编程的可移植性。SUSv3 定义有大量系统数据类型，UNIX 实现应加以支持，应用程序应予以采用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux漫游——导论</title>
      <link href="/2023/08/15/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA/"/>
      <url>/2023/08/15/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux漫游导论"><a href="#Linux漫游导论" class="headerlink" title="Linux漫游导论"></a>Linux漫游导论</h1><h2 id="Linux系统编程之旅"><a href="#Linux系统编程之旅" class="headerlink" title="Linux系统编程之旅"></a>Linux系统编程之旅</h2><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>​        首先就要谈谈内核是什么：</p><p>​        一般的讲，也就是我们在这本书提到的那样的东西——是指管理和分配计算机资源（即CPU、RAM 和设备）的核心层软件。值得一提的是——内核让我们的程序运行更加的简单。</p><p>​        内核的职责，有六个：</p><ul><li>进程调度：计算机内均配备有一个或多个 CPU（中央处理单元），以执行程序指令。</li></ul><pre class="line-numbers language-none"><code class="language-none">“多任务”意指多个进程（即运行中的程序）可同时驻留于内存，且每个进程都能获得对 CPU 的使用权。“抢占”则是指一组规则。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>内存管理：内核必须以公平、高效地方式在进程间共享这一资源</li><li>提供了文件系统：内核在磁盘之上提供有文件系统，允许对文件执行创建、获取、更新以及删除等操作。</li><li>创建和终止进程：内核可将新程序载入内存，为其提供运行所需的资源（比如，CPU、内存以及对文件的访问等）。这样一个运行中的程序我们称之为“进程”。一旦进程执行完毕，内核还要确保释放其占用资源，以供后续程序重新使用。</li><li>对设备的访问：计算机外接设备（鼠标、键盘、磁盘和磁带驱动器等）可实现计算机与外部世界的通信，这一通信机制包括输入、输出或是两者兼而有之。内核既为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问。</li><li>联网：内核以用户进程的名义收发网络消息（数据包）。该任务包括将网络数据包路由至目标系统。</li></ul><p>​        这就是说，每个用户都可以登录进入系统，独立操作，而与其他用户大致无干。</p><h3 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h3><p>​        现代CPU允许两个重要的状态即：用户态和核心态（有时也称之为监管态 supervisor mode）。执行硬件指令可使 CPU 在两种状态间来回切换。与之对应，可将虚拟内存区域划分（标记）为用户空间部分或内核空间部分。</p><h3 id="以进程及内核视角检视系统"><a href="#以进程及内核视角检视系统" class="headerlink" title="以进程及内核视角检视系统"></a>以进程及内核视角检视系统</h3><p>​        学习内核编程的时候，有必要注意到思维的转化，换而言之，我们需要学习从内核的角度上看待问题</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>​        shell 是一种具有特殊用途的程序，主要用于读取用户输入的命令，并执行相应的程序以响应命令。有时，人们也称之为命令解释器。术语登录 shell（login shell）是指用户刚登录系统时，由系统创建，用以运行 shell 的进程。</p><p>​        设计 shell 的目的不仅仅是用于人机交互，对 shell 脚本（包含 shell 命令的文本文件）进行解释也是其用途之一。为实现这一目的，每款 shell 都内置有许多通常与编程语言相关的功能，其中包括变量、循环和条件语句、I/O 命令以及函数等。</p><h2 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h2><p>​        系统会对每个用户的身份做唯一标识，<strong>用户可隶属于多个组</strong>。用户系统的每个用户都拥有唯一的登录名（用户名）和与之相对应的整数型用户ID（UID）。每一个用户，都会有对应的记录。这样的记录由下面的三个部分组成</p><ul><li>组名：（唯一的）组名称。</li><li>组 ID（GID）：与组相关的整数型 ID。</li><li>用户列表：隶属于该组的用户登录名列表（通过密码文件记录的 group ID 字段未能标识出的该组其他成员，也在此列），以逗号分隔。</li></ul><p>需要注意的是，超级用户的用户ID是0，登录名称是root，在一般的 UNIX 系统上，超级用户凌驾于系统的权限检查之上。因此，无论对文件施以何种访问权限限制，超级用户都可以访问系统中的任何文件，也能发送信号干预系统运行的所有用户进程。</p><h2 id="单根目录层级、目录、链接及文件"><a href="#单根目录层级、目录、链接及文件" class="headerlink" title="单根目录层级、目录、链接及文件"></a>单根目录层级、目录、链接及文件</h2><p>​    <strong>内核维护着一套单根目录结构，以放置系统的所有文件。</strong>完全不同于Windows的是，Linux有一个根目录<code>/</code>，所有的文件和目录都是他的子孙。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>​        在文件系统内，会对文件类型进行标记，以表明其种类。其中一种用来表示普通数据文件，人们常称之为“普通文件”或“纯文本文件”，以示与其他种类的文件有所区别。于是，文件在这里就是任何形式的文件的意思了。</p><h3 id="路径和链接"><a href="#路径和链接" class="headerlink" title="路径和链接"></a>路径和链接</h3><p>​        目录是一种特殊类型的文件，内容采用表格形式，数据项包括文件名以及对相应文件的引用。这一“文件名+引用”的组合被称为链接。每个文件都可以有多条链接，因而也可以有多个名称，在相同或不同的目录中出现。目录可包含指向文件或其他目录的链接。路径间的链接建立起如图 2-1 所示的目录层级。每个目录至少包含两条记录：.和..，前者是指向目录自身的链接，后者是指向其上级目录—父目录的链接。</p><p><img src="image-20230815074522653.png" alt="image-20230815074522653"></p><h3 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h3><p>​        类似于普通链接，符号链接给文件起了一个“别号（alternative name）”。所谓“另一文件”通常被称为符号链接的目标，人们一般会说符号链接“指向”或“引用”目标文件。在多数情况下，只要系统调用用到了路径名，内核会自动解除（换言之，按照）该路径名中符号链接的引用，以符号链接所指向的文件名来替换符号链接。若符号链接的目标文件自身也是一个符号链接，那么上述过程会以递归方式重复下去。对于那些指向了一个并不存在的文件，可以视之为空连接。</p><p>​        通常，人们会分别使用<strong>硬链接（hard link）或软链接（soft link）</strong>这样的术语来指代正常链接和符号链接。</p><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>​        <strong>在大多数 Linux 文件系统上，文件名最长可达 255 个字符。</strong>文件名可以包含除“/”和空字符（\0）外的所有字符。但是，只建议使用字母、数字、点(“.”)、下划线（“_”）以及连字符（“−”）。SUSv3 将这 65 个字符的集合[-.\ _a-zA-Z0-9]称为可移植文件名字符集（portable filename character set）。</p><p>​        注意的是——为了防止出现特殊字符无法识别的问题，强烈建议避免使用上述可以指字符以外的字符作为文件名称</p><p>​        此外，还应避免以连字符（“-”）作为文件名的起始字符，因为一旦在 shell 命令中使用这种文件名，会被误认为命令行选项开关。 </p><h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>​        <strong>路径名是由一系列文件名组成的字符串，彼此以“/”分隔，首字符可以为“/”（非强制）1。除却最后一个文件名外，该系列文件名均为目录名称（或为指向目录的符号链接）。路径名的尾部2可标识任意类型的文件，包括目录在内。有时将该字符串中最后一个“/”字符之前的部分称为路径名的目录部分，将其之后的部分称为路径名的文件部分或基础部分。</strong></p><p>​        路径名应按从左至右的顺序阅读，路径名中每个文件名之前的部分，即为该文件所处目录。可在路径名中任意位置后引入字符串“..”，用以指代路径名中当前位置的父目录。路径名描述了单根目录层级下的文件位置，又可分为绝对路径名和相对路径名：</p><ul><li><strong>绝对路径名以“/”开始</strong>，指明文件相对于根目录的位置。图 2-1 中的/home/mtk/. bashrc、/usr/include 以及/（根路径的路径名）都是绝对路径名的例子。</li><li>相对路径名定义了相对于进程当前工作目录（见下文）的文件位置，与绝对路径名相比，相对路径名缺少了起始的“/”。如图 2-1 所示，在目录 usr 下，可使用相对路径名include/sys/types.h 来引用文件 types.h，在目录 avr 下，可使用相对路径名../mtk/.bashrc来访问文件.bashrc。</li></ul><h3 id="当前工作目录"><a href="#当前工作目录" class="headerlink" title="当前工作目录"></a>当前工作目录</h3><p>​        值得注意的是，每一个进程都由当前工作目录的说法！说白了就是你现在所处的文件系统的位置。</p><h3 id="文件的所有权和权限"><a href="#文件的所有权和权限" class="headerlink" title="文件的所有权和权限"></a>文件的所有权和权限</h3><p>​        每个文件都有一个与之相关的用户 ID 和组 ID，分别定义文件的属主和属组。系统根据文件的所有权来判定用户对文件的访问权限。</p><p>​        为了访问文件，系统把用户分为 3 类：<strong>文件的属主（有时，也称为文件的用户）、与文件组（group）ID 相匹配的属组成员用户以及其他用户。</strong>可为以上 3 类用户分别设置 3 种权限（共计 9 种权限位）：只允许查看文件内容的读权限；允许修改文件内容的写权限；允许执行文件的执行权限。这里的文件要么指程序，要么是交由某种解释程序（通常指 shell 的一种，但也有例外）处理的脚本。</p><h2 id="文件-I-O-模型"><a href="#文件-I-O-模型" class="headerlink" title="文件 I/O 模型"></a>文件 I/O 模型</h2><p>​            UNIX 系统 I/O 模型最为显著的特性之一是其 I/O 通用性概念。也就是说，同一套系统调用（open()、read()、write()、close()等）所执行的 I/O 操作，可施之于所有文件类型，包括设备文件在内。</p><p>​        就本质而言，内核只提供一种文件类型：<strong>字节流序列，在处理磁盘文件、磁盘或磁带设备时，可通过 lseek()系统调用来随机访问。</strong></p><p>​        <strong>UNIX 系统没有文件结束符的概念，读取文件时如无数据返回，便会认定抵达文件末尾</strong>。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>​        I/O 系统调用使用文件描述符—（往往是数值很小的）非负整数—来指代打开的文件。获取文件描述符的常用手法是调用 open()，在参数中指定 I/O 操作目标文件的路径名。通常，由 shell 启动的进程会继承 3 个已打开的文件描述符：</p><ul><li>描述符 0 为标准输入，指代为进程提供输入的文件；</li><li>描述符 1 为标准输出，指代供进程写入输出的文件；</li><li>描述符 2 为标准错误，指代供进程写入错误消息或异常通告的文件。</li></ul><p>​        在交互式 shell 或程序中，上述三者一般都指向终端。在 stdio 函数库中，这几种描述符分别与文件流 stdin、stdout 和 stderr 相对应。</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>​        程序通常以两种面目示人。<strong>其一为源码形式，由使用编程语言（比如，C 语言）写成的一系列语句组成，是人类可以阅读的文本文件</strong>。要想执行程序，<strong>则需将源码转换为第二种形式—计算机可以理解的二进制机器语言指令。</strong></p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>​        从 stdin 读取输入，加以转换，再将转换后的数据输出到 stdout，常常将拥有上述行为的程序称为过滤器，cat、grep、tr、sort、wc、sed、awk 均在其列。</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>​        C 语言程序可以访问命令行参数，即程序运行时在命令行中输入的内容。要访问命令行参数，程序的 main()函数需做如下声明：argc 变量包含命令行参数的总个数，argv 指针数组的成员指针则逐一指向每个命令行参数字符串。首个字符串 argv[0]，标识程序名本身。</p><h2 id="2-7-进程"><a href="#2-7-进程" class="headerlink" title="2.7 进程"></a>2.7 进程</h2><p>​            简而言之，进程是正在执行的程序实例。也就是说，一个程序被CPU执行的时候就变成了进程，并且，程序代码将会被载入虚拟内存，微程序变量分配空间，建立内核记账（bookkeeping）数据结构，以记录与进程有关的各种信息（比如，进程 ID、用户 ID、组 ID 以及终止状态等）。</p><p>​        内核会为进程分配一些资源，并且在进程的生命周期中为之分配资源。<strong>程序终止时，内核会释放所有此类资源，供其他进程重新使用。其他资源（如 CPU、网络带宽等）都属于可再生资源，但必须在所有进程间平等共享。</strong></p><p>​        进程的内存布局逻辑上将一个进程划分为以下几部分（也称为段）。</p><ul><li>文本：程序的指令。</li><li>数据：程序使用的静态变量。</li><li>堆：程序可从该区域动态分配额外内存。</li><li>栈：随函数调用、返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间。</li></ul><h3 id="创建进程和执行程序"><a href="#创建进程和执行程序" class="headerlink" title="创建进程和执行程序"></a>创建进程和执行程序</h3><p>​        进程可使用系统调用 fork()来创建一个新进程。调用 fork()的进程被称为父进程，新创建的进程则被称为子进程。</p><p>​        对父进程的复制来创建子进程。子进程从父进程处继承数据段、栈段以及堆段的副本后，可以修改这些内容，不会影响父进程的“原版”内容。<strong>（在内存中被标记为只读的程序文本段则由父、子进程共享。）</strong></p><p>​        以 execve()为基础，C 语言库还提供了几个相关函数，接口虽然略有不同，但功能全都相同。以上所有库函数的名称均以字符串“exec”打头，在函数间差异无关宏旨的场合，本书会用符号exec()作为这些库函数的统称。</p><h3 id="进程-ID-和父进程-ID"><a href="#进程-ID-和父进程-ID" class="headerlink" title="进程 ID 和父进程 ID"></a>进程 ID 和父进程 ID</h3><p>​        每一进程都有一个唯一的整数型进程标识符（PID）。此外，每一进程还具有一个父进程标识符（PPID）属性，用以标识请求内核创建自己的进程。</p><h3 id="进程终止和终止状态"><a href="#进程终止和终止状态" class="headerlink" title="进程终止和终止状态"></a>进程终止和终止状态</h3><p>​        可使用以下两种方式之一来终止一个进程：</p><ul><li><strong>其一，进程可使用 _exit()系统调用（或相关的exit()库函数）</strong>，请求退出；</li><li>其二，向进程传递信号，将其“杀死”。</li></ul><p>​        无论以何种方式退出，进程都会生成“终止状态”，一个非负小整数，可供父进程的 wait()系统调用检测。在调用 _exit()的情况下，进程会指明自己的终止状态。若由信号来“杀死”进程，则会根据导致进程“死亡”的信号类型来设置进程的终止状态。（有时会将传递进\ _exit()的参数称为进程的“退出状态”，以示与终止状态有所不同，后者要么指传递给 _exit()的参数值，要么表示“杀死”进程的信号。）根据惯例，<strong>终止状态为 0 表示进程“功成身退”，非 0 则表示有错误发生。</strong>大多数 shell 会将前一执行程序的终止状态保存于 shell 变量$?中。</p><h3 id="进程的用户和组标识符（凭证）"><a href="#进程的用户和组标识符（凭证）" class="headerlink" title="进程的用户和组标识符（凭证）"></a>进程的用户和组标识符（凭证）</h3><p>​        每个进程都有一组与之相关的用户 ID (UID)和组 ID (GID)，如下所示。 </p><ul><li>真实用户 ID 和组 ID：用来标识进程所属的用户和组。新进程从其父进程处继承这些 ID。登录 shell 则会从系统密码文件的相应字段中获取其真实用户 ID 和组 ID。</li><li>有效用户 ID 和组 ID：进程在访问受保护资源（比如，文件和进程间通信对象）时，会使用这两个 ID（并结合下述的补充组 ID）来确定访问权限。一般情况下，进程的有效 ID 与相应的真实 ID 值相同。正如即将讨论的那样，改变进程的有效ID 实为一种机制，可使进程具有其他用户或组的权限。 </li><li>补充组 ID：用来标识进程所属的额外组。新进程从其父进程处继承补充组 ID。登录shell 则从系统组文件中获取其补充组 ID。</li></ul><h3 id="特权进程"><a href="#特权进程" class="headerlink" title="特权进程"></a>特权进程</h3><p>​        在 UNIX 系统上，就传统意义而言，特权进程是指有效用户 ID 为 0（超级用户）的进程。通常由内核所施加的权限限制对此类进程无效。与之相反，术语“无特权”（或非特权）进程是指由其他用户运行的进程。此类进程的有效用户 ID 为非 0 值，且必须遵守由内核所强加的权限规则。由某一特权进程创建的进程，也可以是特权进程。例如，一个由 root（超级用户）发起的登录 shell。成为特权进程的另一方法是利用 set-user-ID 机制，该机制允许某进程的有效用户ID 等同于该进程所执行程序文件的用户 ID。</p><h3 id="能力（Capabilities）"><a href="#能力（Capabilities）" class="headerlink" title="能力（Capabilities）"></a>能力（Capabilities）</h3><p>​        始于内核 2.2，Linux 把传统上赋予超级用户的权限划分为一组相互独立的单元（称之为“能力”）。每次特权操作都与特定的能力相关，仅当进程具有特定能力时，才能执行相应操作。传统意义上的超级用户进程（有效用户 ID 为 0）则相应开启了所有能力。赋予某进程部分能力，使得其既能够执行某些特权级操作，又防止其执行其他特权级操作。本书第 39 章会对能力做深入讨论。在本书后文中，当述及只能由特权进程执行的特殊操作时，一般都会在括号中标明其具体能力。能力的命名以 CAP_为前缀，例如，CAP_KILL。init 进程系统引导时，内核会创建一个名为 init 的特殊进程，即“所有进程之父”，该进程的相应程序文件为/sbin/init。系统的所有进程不是由 init（使用 fork()）“亲自”创建，就是由其后代进程创建。<strong>init 进程的进程号总为 1，且总是以超级用户权限运行。</strong>谁（哪怕是超级用户）都不能“杀死”init 进程，<strong>只有关闭系统才能终止该进程</strong>。init 的主要任务是创建并监控系统运行所需的一系列进程。（手册页 init(8)中包含了 init 进程的详细信息。）</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>​        守护进程指的是具有特殊用途的进程，系统创建和处理此类进程的方式与其他进程相同，但以下特征是其所独有的： </p><ul><li>“长生不老”。<strong>守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”。</strong> </li><li>守护进程在后台运行，且无控制终端供其读取或写入数据。守护进程中的例子有 syslogd（在系统日志中记录消息）和 httpd（利用 HTTP 分发 Web 页面）。</li></ul><h3 id="环境列表"><a href="#环境列表" class="headerlink" title="环境列表"></a>环境列表</h3><p>​        每个进程都有一份环境列表，即在进程用户空间内存中维护的一组环境变量。</p><p>​        由 fork()创建的新进程，会继承父进程的环境副本。这也为父子进程间通信提供了一种机制。当进程调用 exec()替换当前正在运行的程序时，新程序要么继承老程序的环境，要么在 exec()调用的参数中指定新环境并加以接收。</p><p>​        我们可以自己创建环境变量</p><pre class="line-numbers language-none"><code class="language-none">export MYVAR &#x3D; &quot;Hello, World&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        C 语言程序可使用外部变量（char **environ）来访问环境，而库函数也允许进程去获取或修改自己环境中的值。</p><p>​        环境变量的用途多种多样。例如，shell 定义并使用了一系列变量，供 shell 执行的脚本和程序访问。其中包括：</p><ul><li>变量 HOME（明确定义了用户登录目录的路径名）、</li><li>变量 PATH（指明了用户输入命令后，shell 查找与之相应程序时所搜索的目录列表）。</li></ul><h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><p>​        每个进程都会消耗诸如打开文件、内存以及 CPU 时间之类的资源。使用系统调用 setrlimit()，进程可为自己消耗的各类资源设定一个上限。</p><p>​        这样的限制分为软限制和硬限制。</p><p>​        软限制（soft limit）限制了进程可以消耗的资源总量，硬限制（hard limit）软限制的调整上限。非特权进程在针对特定资源调整软限制值时，可将其设置为 0 到相应硬限制值之间的任意值，但硬限制值则只能调低，不能调高。由 fork()创建的新进程，会继承其父进程对资源限制的设置。使用 ulimit 命令（在 C shell 中为 limit）可调整 shell 的资源限制。shell 为执行命令所创建的子进程会继承上述资源设置。</p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>调用系统函数 mmap()的进程，会在其虚拟地址空间中创建一个新的内存映射。映射分为两类。 </p><ul><li>文件映射：将文件的部分区域映射入调用进程的虚拟内存。映射一旦完成，对文件映射内容的访问则转化为对相应内存区域的字节操作。映射页面会按需自动从文件中加载。 </li><li>相映成趣的是并无文件与之相对应的匿名映射，其映射页面的内容会被初始化为 0。</li></ul><p>​        由某一进程所映射的内存可以与其他进程的映射共享。达成共享的方式有二：</p><ul><li>其一是两个进程都针对某一文件的相同部分加以映射，</li><li>其二是由 fork()创建的子进程自父进程处继承映射。</li></ul><p>​        当两个或多个进程共享的页面相同时，进程之一对页面内容的改动是否为其他进程所见呢？这取决于创建映射时所传入的标志参数。若传入标志为私有，则某进程对映射内容的修改对于其他进程是不可见的，而且这些改动也不会真地落实到文件上；若传入标志为共享，对映射内容的修改就会为其他进程所见，并且这些修改也会造成对文件的改动。内存映射用途很多，其中包括：以可执行文件的相应段来初始化进程的文本段、内存（内容填充为 0）分配、文件 I/O（即映射内存 I/O）以及进程间通信（通过共享映射）。</p><h2 id="2-10-进程间通信及同步"><a href="#2-10-进程间通信及同步" class="headerlink" title="2.10 进程间通信及同步"></a>2.10 进程间通信及同步</h2><p>​        Linux 系统上运行有多个进程，其中许多都是独立运行。然而，有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制。</p><p>​        读写磁盘文件中的信息是进程间通信的方法之一。可是，对许多程序来说，这种方法既慢又缺乏灵活性。因此，像所有现代 UNIX 实现那样，Linux 也提供了丰富的进程间通信（IPC）机制，如下所示。 </p><ul><li>信号（signal），用来表示事件的发生。 </li><li>管道（亦即 shell 用户所熟悉的“|”操作符）和 FIFO，用于在进程间传递数据。 </li><li>套接字，供同一台主机或是联网的不同主机上所运行的进程之间传递数据。 </li><li>文件锁定，为防止其他进程读取或更新文件内容，允许某进程对文件的部分区域加以锁定。 </li><li>消息队列，用于在进程间交换消息（数据包）。 </li><li>信号量（semaphore），用来同步进程动作。 </li><li>共享内存，允许两个及两个以上进程共享一块内存。当某进程改变了共享内存的内容时，其他所有进程会立即了解到这一变化。</li></ul><p>​        UNIX 系统的 IPC 机制种类如此繁多，有些功能还互有重叠，部分原因是由于各种 IPC 机制是在不同的 UNIX 实现上演变而来的，需要遵循的标准也各不相同。例如，就本质而言，FIFO和 UNIX 套接字功能相同，允许同一系统上并无关联的进程彼此交换数据。二者之所以并存于现代 UNIX 系统之中，是由于 FIFO 来自 System V，而套接字则源于 BSD。</p><h2 id="2-11-信号"><a href="#2-11-信号" class="headerlink" title="2.11 信号"></a>2.11 信号</h2><p>​        尽管上一节将信号视为 IPC 的方法之一，但其在其他方面的广泛应用则更为普遍，因此值得深入讨论。</p><p>​        人们往往将信号称为“软件中断”。进程收到信号，就意味着某一事件或异常情况的发生。信号的类型很多，每一种分别标识不同的事件或情况。采用不同的整数来标识各种信号类型，并以 SIGxxxx 形式的符号名加以定义。</p><p>​        内核、其他进程（只要具有相应的权限）或进程自身均可向进程发送信号。例如，发生下列情况之一时，内核可向进程发送信号。 </p><ul><li><strong>用户键入中断字符（通常为 Control-C）。</strong> </li><li><strong>进程的子进程之一已经终止。</strong> </li><li>由进程设定的<strong>定时器（告警时钟）已经到期。</strong> </li><li>进程尝试访问无效的内存地址。</li></ul><p>​        在 shell 中，可使用 kill 命令向进程发送信号。在程序内部，系统调用 kill()可提供相同的功能。</p><p>​        收到信号时，进程会根据信号采取如下动作之一。 </p><ul><li>忽略信号。 </li><li>被信号“杀死”。 </li><li>先挂起，之后再被专用信号唤醒。</li></ul><p>​        <strong>就大多数信号类型而言，程序可选择不采取默认的信号动作，而是忽略信号（当信号的默认处理行为并非忽略此信号时，会派上用场）或者建立自己的信号处理器。</strong>信号处理器是由程序员定义的函数，会在进程收到信号时自动调用，根据信号的产生条件执行相应动作。（换而言之，可以自己自定义处理信号）</p><p>​        <strong>信号从产生直至送达进程期间，一直处于挂起状态。</strong>通常，系统会在接收进程下次获得调度时，将处于挂起状态的信号同时送达。如果接收进程正在运行，则会立即将信号送达。然而，程序可以将信号纳入所谓“信号屏蔽”1以求阻塞该信号。如果产生的信号处于“信号屏蔽”之列，那么此信号将一直保持挂起状态，直至解除对该信号的阻塞。（亦即从信号屏蔽中移除。）</p><h2 id="2-12-线程"><a href="#2-12-线程" class="headerlink" title="2.12 线程"></a>2.12 线程</h2><p>​        在现代 UNIX 实现中，<strong>每个进程都可执行多个线程</strong>。可将线程想象为共享同一虚拟内存及一干其他属性的进程。每个线程都会执行相同的程序代码，共享同一数据区域和堆。可是，每个线程都拥有属于自己的栈，用来装载本地变量和函数调用链接信息。线程之间可通过共享的全局变量进行通信。借助于线程 API 所提供的条件变量和互斥机制，进程所属的线程之间得以相互通信并同步行为—尤其是在对共享变量的使用方面。此外，利用 2.10 节所述的 IPC 和同步机制，线程间也能彼此通信。线程的主要优点在于协同线程之间的数据共享（通过全局变量）更为容易，而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然。再者，显而易见，多线程应用能从多处理器硬件的并行处理中获益匪浅。</p><h2 id="2-13-进程组和-shell-任务控制"><a href="#2-13-进程组和-shell-任务控制" class="headerlink" title="2.13 进程组和 shell 任务控制"></a>2.13 进程组和 shell 任务控制</h2><p>​        shell 执行的每个程序都会在一个新进程内发起。比如，shell 创建了 3 个进程来执行以下管道命令（在当前的工作目录下，根据文件大小对文件进行排序并显示）：</p><pre class="line-numbers language-none"><code class="language-none">ls -l | sort -k5n | less<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        除 Bourne shell 以外，几乎所有的主流 shell 都提供了一种交互式特性，名为任务控制。该特性允许用户同时执行并操纵多条命令或管道。在支持任务控制的 shell 中，会将管道内的所有进程置于一个新进程组或任务中。（如果情况很简单，shell 命令行只包含一条命令，那么就会创建一个只包含单个进程的新进程组。）<strong>进程组中的每个进程都具有相同的进程组标识符（以整数形式），其实就是进程组中某个进程（也称为进程组组长 process group leader）的进程 ID。</strong>内核可对进程组中的所有成员执行各种动作，尤其是信号的传递。<strong>如下节所述，支持任务控制的 shell 会利用这一特性，以挂起或恢复执行管道中的所有进程。</strong></p><h2 id="2-14-会话、控制终端和控制进程"><a href="#2-14-会话、控制终端和控制进程" class="headerlink" title="2.14 会话、控制终端和控制进程"></a>2.14 会话、控制终端和控制进程</h2><p>​        <strong>会话指的是一组进程组（任务）。</strong>会话中的所有进程都具有相同的<strong>会话标识符。会话首进程（session leader）是指创建会话的进程，其进程 ID 会成为会话 ID。</strong></p><p>​        使用会话最多的是<strong>支持任务控制的 shell</strong>，由 shell 创建的所有进程组与 shell 自身隶属于同一会话，shell 是此会话的会话首进程。</p><p>​        通常，会话都会与某个控制终端相关。控制终端建立于会话首进程初次打开终端设备之时。对于由交互式 shell 所创建的会话，这恰恰是用户的登录终端。一个终端至多只能成为一个会话的控制终端。</p><p>​        打开控制终端会致使会话首进程成为终端的控制进程。一旦断开了与终端的连接（比如，关闭了终端窗口），控制进程将会收到 SIGHUP 信号。</p><p>​        在任一时点，会话中总有一个前台进程组（前台任务），可以从终端中读取输入，向终端发送输出。如果用户在控制终端中输入了“中断”（通常是 Control-C）或“挂起”字符（通常是 Control-Z），那么终端驱动程序会发送信号以终止或挂起（亦即停止）前台进程组。一个会话可以拥有任意数量的后台进程组（后台任务），由以“&amp;”字符结尾的行命令来创建。支持任务控制的 shell 提供如下命令：列出所有任务，向任务发送信号，以及在前后台任务之间来回切换。</p><h2 id="2-15-伪终端"><a href="#2-15-伪终端" class="headerlink" title="2.15 伪终端"></a>2.15 伪终端</h2><p>​        伪终端是一对相互连接的虚拟设备，也称为主从设备。在这对设备之间，设有一条 IPC信道，可供数据进行双向传递。从设备（slave device）所提供的接口，其行为方式与终端相类似<strong>，基于这一特点，可以将某个为终端编写的程序与从设备连接起来，然后，再利用连接到主设备的另一程序来驱动这一“面向终端”的程序，这是伪终端的一个关键用途。</strong>由“驱动程序”1所产生的输出，在经由终端驱动程序的常规输入处理（例如，默认情况下，会把回车符映射为换行符）后，会作为输入传递给与从设备相连的面向终端的程序。而由面向终端的程序向从设备写入的任何数据又作为“驱动程序”的输入来传递（在执行完所有常规的终端输入处理后）。换句话说，“驱动程序”所履行的功能，在效果上等同于用户通常在传统终端上所执行的操作。伪终端广泛应用于各种应用领域，最知名的要数 telnet 和 ssh 之类提供网络登录服务的应用，以及 X Window 系统所提供的终端窗口实现。</p><h2 id="2-16-日期和时间"><a href="#2-16-日期和时间" class="headerlink" title="2.16 日期和时间"></a>2.16 日期和时间</h2><p>​        进程涉及两种类型的时间。 </p><ul><li><strong>真实时间：指的是在进程的生命期内（所经历的时间或时钟时间），以某个标准时间点（日历时间）或固定时间点（通常是进程的启动时间）为起点测量得出的时间。在UNIX 系统上，日历时间是以国际协调时间（简称 UTC）1970 年 1 月 1 日凌晨为起始点，按秒测量得出的时间，再进行时区调整（定义时区的基准点为穿过英格兰格林威治的经线) 。这一日期与 UNIX 系统的生日很接近，也被称为纪元（Epoch）。</strong> </li><li><strong>进程时间：亦称为 CPU 时间，指的是进程自启动起来，所占用的 CPU 时间总量。可进一步将 CPU 时间划分为系统 CPU 时间和用户 CPU 时间。前者是指在内核模式中，执行代码所花费的时间（比如，执行系统调用，或代表进程执行其他的内核服务）。后者是指在用户模式中，执行代码所花费的时间（比如，执行常规的程序代码）。</strong></li></ul><p>​        time 命令会显示出真实时间、系统 CPU 时间，以及为执行管道中的多个进程而花费的用户 CPU 时间。 </p><h2 id="2-17-客户端-服务器架构"><a href="#2-17-客户端-服务器架构" class="headerlink" title="2.17 客户端/服务器架构"></a>2.17 客户端/服务器架构</h2><p>​        本书有多处论及客户端/服务器应用程序的设计和实现。客户端/服务器应用由两个组件进程组成。 </p><ul><li>客户端：向服务器发送请求消息，请求服务器执行某些服务。 </li><li>服务器：分析客户端的请求，执行相应的动作，然后，向客户端回发响应消息。</li></ul><p>​        有时，服务器与客户端之间可能需要就一次服务而进行多次交互。客户端应用通常与用户打交道，而服务器应用则提供对某些共享资源的访问。一般说来，都是众多客户端进程与为数不多的一个或几个服务器端进程进行通信。客户端和服务器既可以驻留于同一台计算机上，也可以位于联网的不同计算机上。客户端和服务器使用 2.10 节所讨论的 IPC 机制来实现彼此通信。服务器可以提供各种服务，如下所示。</p><ul><li>提供对数据库或其他共享信息资源的访问。</li><li>提供对远程文件的跨网访问。 </li><li>对某些商业逻辑进行封装。 </li><li>提供对共享硬件资源的访问（比如，打印机）。 </li><li>提供 WWW 服务。</li></ul><p>​        将某项服务封装于单独的服务器应用中，这一做法原因很多，举例如下。</p><ul><li>效率：较之于在本地的每台计算上提供相同资源，在服务器应用管理之下提供资源的一份实例，则要节约许多。</li><li>控制、协调和安全：由于资源（尤其是信息资源）的统一存放，服务器既可以协调对资源的访问（例如，两个客户端不能同时更新同一信息），还可以保护资源安全，令其只对特定客户端开放。 </li><li>在异构环境中运行：在网络中，客户端和服务器应用所运行的硬件平台和操作系统可以不同。</li></ul><h2 id="2-18-实时性"><a href="#2-18-实时性" class="headerlink" title="2.18 实时性"></a>2.18 实时性</h2><p>​        实时性应用程序是指那些需要对输入做出及时响应的程序。此类输入往往来自于外接的传感器或某些专门的输入设备，而输出则会去控制外接硬件。具有实时性需求的应用程序示例包括自动化装配流水线、银行 ATM 机，以及飞机导航系统等。</p><p>​        虽然许多实时性应用程序都要求对输入做出快速响应，但决定性因素却在于要在事件触发后的一定时限内，保证响应的交付。要提供实时响应，特别是在短时间内加以响应，就需要底层操作系统的支持。由于实时响应的需求与多用户分时操作系统的需求存在冲突，大多数操作系统“天生”并不提供这样的支持。虽然已经设计出不少实时性的 UNIX 变体，但传统的 UNIX 实现都不是实时操作系统。Linux 的实时性变体也早已诞生，而近期的 Linux 内核正转向对实时性应用原生而全面的支持。</p><p>​        为支持实时性应用，POSIX.1b 定义了多个 POSIX.1 扩展，其中包括异步 I/O、共享内存、内存映射文件、内存锁定、实时性时钟和定时器、备选调度策略、实时性信号、消息队列，以及信号量等。虽然这些扩展还不具备严格意义上的“实时性”，但当今的大多数 UNIX 实现都支持上面提到的全部或部分扩展（本书将讲解 Linux 所支持的 POSIX.1b 特性）。本书会以术语“真实时间（real time）”来指代日历时间或经历时间的概念，而术语“实时性（realtime）”则是指操作系统或应用程序具备本节所述的响应能力。</p><h2 id="2-19-proc"><a href="#2-19-proc" class="headerlink" title="2.19 /proc"></a>2.19 /proc</h2><p> 文件系统类似于其他的几种 UNIX 实现，Linux 也提供了/proc 文件系统，由一组目录和文件组成，装配（mount）于/proc 目录下。/proc 文件系统是一种虚拟文件系统，以文件系统目录和文件形式，提供一个指向内核数据结构的接口。这为查看和改变各种系统属性开启了方便之门。此外，还能通过一组以/ proc/PID 形式命名的目录（PID 即进程 ID）查看系统中运行各进程的相关信息。通常，/proc 目录下的文件内容都采取人类可读的文本形式，shell 脚本也能对其进行解析。程序可以打开、读取和写入/proc 目录下的既定文件。大多数情况下，只有特权级进程才能修改/proc 目录下的文件内容。本书在讲解各种 Linux 编程接口的同时，也会对相关的/proc 文件进行介绍。12.1 节将就该文件系统的总体信息做进一步介绍。尚无任何标准对/proc 文件系统进行过规范，书中与该文件系统相关的细节均为 Linux 专有。2.20 总结本章纵览了一系列与 Linux 系统编程相关的基本概念。对于 Linux 或 UNIX“生手”而言，理解这些基本概念将为学习系统编程提供足够的背景知识。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="环境列表-1"><a href="#环境列表-1" class="headerlink" title="环境列表"></a>环境列表</h2><p>更加详细的：<a href="https://www.cnblogs.com/youyoui/p/10680329.html">Linux环境变量配置全攻略 - 悠悠i - 博客园 (cnblogs.com)</a></p><h4 id="Linux环境变量分类"><a href="#Linux环境变量分类" class="headerlink" title="Linux环境变量分类"></a>Linux环境变量分类</h4><p>一、按照生命周期来分，Linux环境变量可以分为两类：<br>1、永久的：需要用户修改相关的配置文件，变量永久生效。<br>2、临时的：用户利用export命令，在当前终端下声明环境变量，关闭Shell终端失效。</p><p>二、按照作用域来分，Linux环境变量可以分为：<br>1、系统环境变量：系统环境变量对该系统中所有用户都有效。<br>2、用户环境变量：顾名思义，这种类型的环境变量只对特定的用户有效。</p><h4 id="Linux设置环境变量的方法"><a href="#Linux设置环境变量的方法" class="headerlink" title="Linux设置环境变量的方法"></a>Linux设置环境变量的方法</h4><p>一、在<code>/etc/profile</code>文件中添加变量 <strong>对所有用户生效（永久的）</strong><br>用vim在文件<code>/etc/profile</code>文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。<br>例如：编辑/etc/profile文件，添加CLASSPATH变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile    <span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>./JAVA_HOME/lib<span class="token punctuation">;</span><span class="token variable">$JAVA_HOME</span>/jre/lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：修改文件后要想马上生效还要运行<code>source /etc/profile</code>不然只能在下次重进此用户时生效。<br>二、在用户目录下的.bash_profile文件中增加变量 <strong>【对单一用户生效（永久的）】</strong><br>用<code>vim ~/.bash_profile</code>文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.bash.profile<span class="token builtin class-name">export</span> <span class="token assign-left variable">CLASSPATH</span><span class="token operator">=</span>./JAVA_HOME/lib<span class="token punctuation">;</span><span class="token variable">$JAVA_HOME</span>/jre/lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注：修改文件后要想马上生效还要运行$ source ~/.bash_profile不然只能在下次重进此用户时生效。<br>三、直接运行export命令定义变量 <strong>【只对当前shell（BASH）有效（临时的）】</strong><br>在shell的命令行下直接使用<code>export 变量名=变量值</code><br>定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。</p><h4 id="Linux环境变量使用"><a href="#Linux环境变量使用" class="headerlink" title="Linux环境变量使用"></a>Linux环境变量使用</h4><p>一、Linux中常见的环境变量有：</p><ul><li>PATH：指定命令的搜索路径</li></ul><blockquote><p><strong>PATH声明用法：</strong><br>PATH=$PAHT:<PATH 1>:<PATH 2>:<PATH 3>:————:&lt; PATH n &gt;<br>export PATH<br>你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效。<br>可以利用<code>echo $PATH</code>查看当前当前系统PATH路径。</p></blockquote><ul><li>HOME：指定用户的主工作目录（即用户登陆到Linux系统中时，默认的目录）。</li><li>HISTSIZE：指保存历史命令记录的条数。</li><li>LOGNAME：指当前用户的登录名。</li><li>HOSTNAME：指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的</li><li>SHELL：指当前用户用的是哪种Shell。</li><li>LANG/LANGUGE：和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。</li><li>MAIL：指当前用户的邮件存放目录。</li></ul><p>【修改Linux环境变量的方法】</p><p>这里:arrow_right:<a href="https://www.cnblogs.com/youyoui/p/10680329.html">Linux环境变量配置全攻略 - 悠悠i - 博客园 (cnblogs.com)</a></p><p>在自定义安装软件的时候，经常需要配置环境变量，下面列举出各种对环境变量的配置方法。</p><p>下面所有例子的环境说明如下：</p><ul><li>系统：Ubuntu 14.0</li><li>用户名：uusama</li><li>需要配置MySQL环境变量路径：/home/uusama/mysql/bin</li></ul><h3 id="Linux读取环境变量"><a href="#Linux读取环境变量" class="headerlink" title="Linux读取环境变量"></a>Linux读取环境变量</h3><p>读取环境变量的方法：</p><ul><li><code>export</code>命令显示当前系统定义的所有环境变量</li><li><code>echo $PATH</code>命令输出当前的<code>PATH</code>环境变量的值</li></ul><p>这两个命令执行的效果如下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uusama@ubuntu:~$ <span class="token builtin class-name">export</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">HOME</span></span><span class="token operator">=</span><span class="token string">"/home/uusama"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">LANG</span></span><span class="token operator">=</span><span class="token string">"en_US.UTF-8"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">LANGUAGE</span></span><span class="token operator">=</span><span class="token string">"en_US:"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">LESSCLOSE</span></span><span class="token operator">=</span><span class="token string">"/usr/bin/lesspipe %s %s"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">LESSOPEN</span></span><span class="token operator">=</span><span class="token string">"| /usr/bin/lesspipe %s"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">LOGNAME</span></span><span class="token operator">=</span><span class="token string">"uusama"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable">MAIL</span><span class="token operator">=</span><span class="token string">"/var/mail/uusama"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"/home/uusama/bin:/home/uusama/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable">SSH_TTY</span><span class="token operator">=</span><span class="token string">"/dev/pts/0"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">TERM</span></span><span class="token operator">=</span><span class="token string">"xterm"</span><span class="token builtin class-name">declare</span> <span class="token parameter variable">-x</span> <span class="token assign-left variable"><span class="token environment constant">USER</span></span><span class="token operator">=</span><span class="token string">"uusama"</span>uusama@ubuntu:~$ <span class="token builtin class-name">echo</span> <span class="token environment constant">$PATH</span>/home/uusama/bin:/home/uusama/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>PATH</code>变量定义了运行命令的查找路径，以冒号<code>:</code>分割不同的路径，使用<code>export</code>定义的时候可加双引号也可不加。</p><h3 id="Linux环境变量配置方法一：export-PATH"><a href="#Linux环境变量配置方法一：export-PATH" class="headerlink" title="Linux环境变量配置方法一：export PATH"></a>Linux环境变量配置方法一：<code>export PATH</code></h3><p>使用<code>export</code>命令直接修改<code>PATH</code>的值，配置MySQL进入环境变量的方法:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/home/uusama/mysql/bin:<span class="token environment constant">$PATH</span><span class="token comment"># 或者把PATH放在前面</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：立即生效</li><li>生效期限：当前终端有效，窗口关闭后无效</li><li>生效范围：仅对当前用户有效</li><li>配置的环境变量中不要忘了加上原来的配置，即<code>$PATH</code>部分，避免覆盖原来配置</li></ul><h3 id="Linux环境变量配置方法二：vim-bashrc"><a href="#Linux环境变量配置方法二：vim-bashrc" class="headerlink" title="Linux环境变量配置方法二：vim ~/.bashrc"></a>Linux环境变量配置方法二：<code>vim ~/.bashrc</code></h3><p>通过修改用户目录下的<code>~/.bashrc</code>文件进行配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.bashrc<span class="token comment"># 在最后一行加上</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：使用相同的用户打开新的终端时生效，或者手动<code>source ~/.bashrc</code>生效</li><li>生效期限：永久有效</li><li>生效范围：仅对当前用户有效</li><li>如果有后续的环境变量加载文件覆盖了<code>PATH</code>定义，则可能不生效</li></ul><h3 id="Linux环境变量配置方法三：vim-bash-profile"><a href="#Linux环境变量配置方法三：vim-bash-profile" class="headerlink" title="Linux环境变量配置方法三：vim ~/.bash_profile"></a>Linux环境变量配置方法三：<code>vim ~/.bash_profile</code></h3><p>和修改<code>~/.bashrc</code>文件类似，也是要在文件最后加上新的路径即可：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.bash_profile<span class="token comment"># 在最后一行加上</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：使用相同的用户打开新的终端时生效，或者手动<code>source ~/.bash_profile</code>生效</li><li>生效期限：永久有效</li><li>生效范围：仅对当前用户有效</li><li>如果没有<code>~/.bash_profile</code>文件，则可以编辑<code>~/.profile</code>文件或者新建一个</li></ul><h3 id="Linux环境变量配置方法四：vim-etc-bashrc"><a href="#Linux环境变量配置方法四：vim-etc-bashrc" class="headerlink" title="Linux环境变量配置方法四：vim /etc/bashrc"></a>Linux环境变量配置方法四：<code>vim /etc/bashrc</code></h3><p>该方法是修改系统配置，需要管理员权限（如root）或者对该文件的写入权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果/etc/bashrc文件不可编辑，需要修改为可编辑</span><span class="token function">chmod</span> <span class="token parameter variable">-v</span> u+w /etc/bashrc<span class="token function">vim</span> /etc/bashrc<span class="token comment"># 在最后一行加上</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：新开终端生效，或者手动<code>source /etc/bashrc</code>生效</li><li>生效期限：永久有效</li><li>生效范围：对所有用户有效</li></ul><h3 id="Linux环境变量配置方法五：vim-etc-profile"><a href="#Linux环境变量配置方法五：vim-etc-profile" class="headerlink" title="Linux环境变量配置方法五：vim /etc/profile"></a>Linux环境变量配置方法五：<code>vim /etc/profile</code></h3><p>该方法修改系统配置，需要管理员权限或者对该文件的写入权限，和<code>vim /etc/bashrc</code>类似：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果/etc/profile文件不可编辑，需要修改为可编辑</span><span class="token function">chmod</span> <span class="token parameter variable">-v</span> u+w /etc/profile<span class="token function">vim</span> /etc/profile<span class="token comment"># 在最后一行加上</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：新开终端生效，或者手动<code>source /etc/profile</code>生效</li><li>生效期限：永久有效</li><li>生效范围：对所有用户有效</li></ul><h3 id="Linux环境变量配置方法六：vim-etc-environment"><a href="#Linux环境变量配置方法六：vim-etc-environment" class="headerlink" title="Linux环境变量配置方法六：vim /etc/environment"></a>Linux环境变量配置方法六：<code>vim /etc/environment</code></h3><p>该方法是修改系统环境配置文件，需要管理员权限或者对该文件的写入权限：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 如果/etc/bashrc文件不可编辑，需要修改为可编辑</span><span class="token function">chmod</span> <span class="token parameter variable">-v</span> u+w /etc/environment<span class="token function">vim</span> /etc/profile<span class="token comment"># 在最后一行加上</span><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/home/uusama/mysql/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>生效时间：新开终端生效，或者手动<code>source /etc/environment</code>生效</li><li>生效期限：永久有效</li><li>生效范围：对所有用户有效</li></ul><p>上面列出了环境变量的各种配置方法，那么Linux是如何加载这些配置的呢？是以什么样的顺序加载的呢？</p><p>特定的加载顺序会导致相同名称的环境变量定义被覆盖或者不生效。</p><h3 id="环境变量的分类"><a href="#环境变量的分类" class="headerlink" title="环境变量的分类"></a>环境变量的分类</h3><p>环境变量可以简单的分成用户自定义的环境变量以及系统级别的环境变量。</p><ul><li>用户级别环境变量定义文件：<code>~/.bashrc</code>、<code>~/.profile</code>（部分系统为：<code>~/.bash_profile</code>）</li><li>系统级别环境变量定义文件：<code>/etc/bashrc</code>、<code>/etc/profile</code>(部分系统为：<code>/etc/bash_profile</code>）、<code>/etc/environment</code></li></ul><p>另外在用户环境变量中，系统会首先读取<code>~/.bash_profile</code>（或者<code>~/.profile</code>）文件，如果没有该文件则读取<code>~/.bash_login</code>，根据这些文件中内容再去读取<code>~/.bashrc</code>。</p><h3 id="测试Linux环境变量加载顺序的方法"><a href="#测试Linux环境变量加载顺序的方法" class="headerlink" title="测试Linux环境变量加载顺序的方法"></a>测试Linux环境变量加载顺序的方法</h3><p>为了测试各个不同文件的环境变量加载顺序，我们在每个环境变量定义文件中的第一行都定义相同的环境变量<code>UU_ORDER</code>，该变量的值为本身的值连接上当前文件名称。</p><p>需要修改的文件如下：</p><ul><li><code>/etc/environment</code></li><li><code>/etc/profile</code></li><li><code>/etc/profile.d/test.sh</code>，新建文件，没有文件夹可略过</li><li><code>/etc/bashrc</code>，或者<code>/etc/bash.bashrc</code></li><li><code>~/.bash_profile</code>，或者<code>~/.profile</code></li><li><code>~/.bashrc</code></li></ul><p>在每个文件中的第一行都加上下面这句代码，并相应的把冒号后的内容修改为当前文件的绝对文件名。</p><pre class="line-numbers language-none"><code class="language-none">export UU_ORDER&#x3D;&quot;$UU_ORDER:~&#x2F;.bash_profile&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改完之后保存，新开一个窗口，然后<code>echo $UU_ORDER</code>观察变量的值：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">uusama@ubuntu:~$ <span class="token builtin class-name">echo</span> <span class="token variable">$UU_ORDER</span><span class="token variable">$UU_ORDER</span>:/etc/environment:/etc/profile:/etc/bash.bashrc:/etc/profile.d/test.sh:~/.profile:~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以推测出Linux加载环境变量的顺序如下：</p><ol><li><code>/etc/environment</code></li><li><code>/etc/profile</code></li><li><code>/etc/bash.bashrc</code></li><li><code>/etc/profile.d/test.sh</code></li><li><code>~/.profile</code></li><li><code>~/.bashrc</code></li></ol><h3 id="Linux环境变量文件加载详解"><a href="#Linux环境变量文件加载详解" class="headerlink" title="Linux环境变量文件加载详解"></a>Linux环境变量文件加载详解</h3><p>由上面的测试可容易得出Linux加载环境变量的顺序如下，：</p><p>系统环境变量 -&gt; 用户自定义环境变量<br><code>/etc/environment</code> -&gt; <code>/etc/profile</code> -&gt; <code>~/.profile</code></p><p>打开<code>/etc/profile</code>文件你会发现，该文件的代码中会加载<code>/etc/bash.bashrc</code>文件，然后检查<code>/etc/profile.d/</code>目录下的<code>.sh</code>文件并加载。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># /etc/profile: system-wide .profile file for the Bourne shell (sh(1))</span><span class="token comment"># and Bourne compatible shells (bash(1), ksh(1), ash(1), ...).</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token environment constant">$PS1</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token environment constant">$BASH</span>"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token environment constant">$BASH</span>"</span> <span class="token operator">!=</span> <span class="token string">"/bin/sh"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token comment"># The file bash.bashrc already sets the default PS1.</span>    <span class="token comment"># PS1='\h:\w\$ '</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> /etc/bash.bashrc <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>      <span class="token builtin class-name">.</span> /etc/bash.bashrc    <span class="token keyword">fi</span>  <span class="token keyword">else</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">id</span> <span class="token parameter variable">-u</span><span class="token variable">`</span></span>"</span> <span class="token parameter variable">-eq</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>      <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">'# '</span>    <span class="token keyword">else</span>      <span class="token assign-left variable"><span class="token environment constant">PS1</span></span><span class="token operator">=</span><span class="token string">'$ '</span>    <span class="token keyword">fi</span>  <span class="token keyword">fi</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-d</span> /etc/profile.d <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>  <span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> /etc/profile.d/*.sh<span class="token punctuation">;</span> <span class="token keyword">do</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-r</span> <span class="token variable">$i</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>      <span class="token builtin class-name">.</span> <span class="token variable">$i</span>    <span class="token keyword">fi</span>  <span class="token keyword">done</span>  <span class="token builtin class-name">unset</span> i<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其次再打开<code>~/.profile</code>文件，会发现该文件中加载了<code>~/.bashrc</code>文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># if running bash</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-n</span> <span class="token string">"<span class="token environment constant">$BASH_VERSION</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>    <span class="token comment"># include .bashrc if it exists</span>    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token string">"<span class="token environment constant">$HOME</span>/.bashrc"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span><span class="token builtin class-name">.</span> <span class="token string">"<span class="token environment constant">$HOME</span>/.bashrc"</span>    <span class="token keyword">fi</span><span class="token keyword">fi</span><span class="token comment"># set PATH so it includes user's private bin directories</span><span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/bin:<span class="token environment constant">$HOME</span>/.local/bin:<span class="token environment constant">$PATH</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从<code>~/.profile</code>文件中代码不难发现，<code>/.profile</code>文件<strong>只在用户登录的时候读取一次</strong>，而<code>/.bashrc</code>会在每次运行<code>Shell</code>脚本的时候读取一次。</p><h3 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h3><p>可以自定义一个环境变量文件，比如在某个项目下定义<code>uusama.profile</code>，在这个文件中使用<code>export</code>定义一系列变量，然后在<code>~/.profile</code>文件后面加上：<code>sourc uusama.profile</code>，这样你每次登陆都可以在Shell脚本中使用自己定义的一系列变量。</p><p>也可以使用<code>alias</code>命令定义一些命令的别名，比如<code>alias rm=&quot;rm -i&quot;</code>（双引号必须），并把这个代码加入到<code>~/.profile</code>中，这样你每次使用<code>rm</code>命令的时候，都相当于使用<code>rm -i</code>命令，非常方便。</p><h2 id="Linux下静态库和动态库的区别"><a href="#Linux下静态库和动态库的区别" class="headerlink" title="Linux下静态库和动态库的区别"></a>Linux下静态库和动态库的区别</h2><p>这里：:arrow_right:<a href="https://zhuanlan.zhihu.com/p/609647309">Linux静态库与共享库基础笔记 - 知乎 (zhihu.com)</a></p><h3 id="1、目标库"><a href="#1、目标库" class="headerlink" title="1、目标库"></a><strong>1、目标库</strong></h3><p>编译程序的一种简单方式是简单地将每一个源文件编译成目标文件，然后将这些目标链接在一起组成可执行程序：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g prog.c mod1.c mod2.c mod3.cgcc -g prog_nolib prog.o mod1.o mod2.o mod3.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>链接实际上是用链接器 <code>ld</code> 来完成的，使用 <code>gcc</code> 命令链接一个程序时，编译器会再幕后调用 <code>ld</code>。</p><p>为了解决共享的问题，可以将一组目标文件组织成一个对象库，对象库分为两种：</p><ul><li>静态库</li><li>共享库，比静态库更具优势</li></ul><h3 id="2、静态库"><a href="#2、静态库" class="headerlink" title="2、静态库"></a><strong>2、静态库</strong></h3><p>静态库也称为归档文件，有点：</p><ul><li>可以将一组经常被调用到的目标文件组织成单个库文件，这样避免构建多个程序时反复编译原来代码的问题</li><li>链接命令变得更加简单，链接时只需要指定静态库的名称即可，不需要列出一个个目标文件</li></ul><h4 id="2-1、创建和维护静态库"><a href="#2-1、创建和维护静态库" class="headerlink" title="2.1、创建和维护静态库"></a><strong>2.1、创建和维护静态库</strong></h4><p>使用 <code>ar</code> 命令能够创建和维护静态库，静态库的名称一般为 <code>libname.a</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ar options archive object-filr...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><code>options</code> 参数由一系列的字母构成，其中一个是操作码，其他是可能影响操作的执行修饰符：</p></li><li><ul><li><code>r</code> ： 替换，将一个目标文件插入到归档文件中并取代同名的目标文件</li><li><code>t</code> ：目录表，显示归档中的目录表，默认情况下只会列出归档文件中目标文件的名称，添加 <code>v</code> 修饰之后可以看到记录在归档文件中的各个目标文件的其他特性</li><li><code>d</code> ： 从归档文件中删除一个模块</li></ul></li></ul><h4 id="2-2、使用静态库"><a href="#2-2、使用静态库" class="headerlink" title="2.2、使用静态库"></a><strong>2.2、使用静态库</strong></h4><p>程序和静态库链接起来存在的两种方式：</p><ul><li>在连接命令中指定静态库的名称</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -c prog.cgcc -g -o prog prog.o libdemo.a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>或者将静态库放在链接器搜索的其中一个标准目录中 ，例如<code>/usr/lib</code>，然后使用 <code>-l</code> 选项指定库名，库名需要去除 <code>lib</code> 前缀和 <code>.a</code> 后缀：</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -o prog prog.o -ldemo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>如果库不在链接器的搜索目录中，则需要使用 <code>-L</code> 指定额外的目录：</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -o prog prog.o -Llibdir -ldemo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3、共享库概述"><a href="#3、共享库概述" class="headerlink" title="3、共享库概述"></a><strong>3、共享库概述</strong></h3><p>多个程序使用同一个静态库时，每个程序都有自己的目标模块的副本，这种代码冗余存在的缺点：</p><ul><li>存储同一个目标模块的多个副本会浪费磁盘空间，并且所浪费的空间是比较大的</li><li>如果使用了同一模块的程序在同一时刻执行，每个程序都有自己独立的虚拟地址空间，其中保存了一份目标代码副本，这将会提供系统中虚拟内存的整体使用量</li><li>如果需要修改一个静态库的一个目标模块，那么所有使用这个模块的可执行程序都必须重新进行链接合并这个变更</li></ul><p>共享库就是为了克服静态库的诸多缺点，它还具有的优势有：</p><ul><li>由于整个程序的大小变得更小了，一些情况下，程序可以完全被加载到内存中，从而能够更快的启动程序，这一点只有在大型共享库正被其他程序使用时才成立，第一个加载共享库的程序实际上会在启动时花费更长的时间，因为必须要先找到共享库并将其加载到内存中</li><li>目标模块修改是 ，不需要重新编译程序就可以看到变更，甚至当运行着的程序正在使用共享库的现有版本时也能够进行这样的变更</li></ul><p>共享库的额外开销：</p><ul><li>创建共享库和构建使用共享库的程序比静态库更复杂</li><li>共享库在编译时需要使用位置独立代码，这在大多数架构上会带来性能开销，因为它需要使用一个额外的寄存器</li><li>在运行时必须要执行符号重定位，符号重定位期间，需要对共享库中的每个符号(变量或函数)的引用修改成符合在虚拟内存中的实际运行时位置，这个重定位的过程需要花费一定的时间</li></ul><p>虽然共享库的代码是多个进程共享的，但是其中的变量不是，每个使用库的进程会拥有自己的在库中定义的全局和静态变量的副本。</p><h4 id="3-1、创建和使用共享库"><a href="#3-1、创建和使用共享库" class="headerlink" title="3.1、创建和使用共享库"></a><strong>3.1、创建和使用共享库</strong></h4><h5 id="创建一个共享库"><a href="#创建一个共享库" class="headerlink" title="创建一个共享库"></a><strong>创建一个共享库</strong></h5><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.cgcc -g -shared libfoo.so mod1.o mod2.o mod3.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>贡献库的命名方式一般为 <code>libname.so</code></li><li>可以向之前构建的共享库中添加单个目标模块，也可以从中删除单个目标模块</li><li>也可以将编译共享库的命令放在一行：</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -fPIC -Wall mod1.c mod2.c mod3.c -shared -o libfoo.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="位置独立的代码"><a href="#位置独立的代码" class="headerlink" title="位置独立的代码"></a><strong>位置独立的代码</strong></h5><p><strong><code>-fPIC</code> 选项指定编译器应该生成位置无关代码，这会改变编译器生成执行文件特定操作的代码方式，包括访问全局、静态和外部变量，访问字符串常量，以及获取函数的地址，这些改变使得代码可以在运行时放在任意虚拟地址处，这一点对于共享库来说是必须的，因为链接的时候是无法知道共享库代码位于内存何处。</strong></p><p>在 linux/x86-32 上，可以使用不加 <code>-fPIC</code> 选项编译的模块来创建共享库，为了确定一个既有目标文件在编译时是否使用了 <code>-fPIC</code> 选项，可以使用检查目标文件符号表中是否存在 <code>_GLOBAL_OFFSET_TABLE</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">nm mod1.o | grep _GLOBAL_OFFSET_TABLEreadelf -s  mod1.o | grep _GLOBAL_OFFSET_TABLE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面的命令中如果产生了输出，则说明指定的共享库中至少存在一个目标模块在编译时没有指定 <code>-fPIC</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">objdump --all-headers libfoo.so | grep TEXTRELobjdump --all-headers libfoo.so | grep TEXTREL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>TEXTREL</code> 表示存在一个目标模块，其文本段中包含需要运行时重定位的引用。</p><h5 id="使用一个共享库"><a href="#使用一个共享库" class="headerlink" title="使用一个共享库"></a><strong>使用一个共享库</strong></h5><p>为了使用共享库需要做两件事情，而使用静态库则无需完成这两件事情：</p><ul><li>可执行文件中不包含它所需要的目标文件的副本，因此需要通过某种机制找到运行时所需要的共享库：链接阶段将共享库名称嵌入可执行文件中，一个程序所依赖的所有共享库列表称为程序的动态依赖表</li><li>在程序运行时需要某种机制解析嵌入的库名，即找出与在可执行文件中指定的名称对应的共享库文件，如果库不再内存中的话就将库加载进内存</li></ul><p>运行时解析内嵌库名的工作由动态链接器(也称为动态链接加载器或运行时加载器)来完成，动态链接器本身也是一个共享库，其名称为 <code>lib/ld-linux.so.2</code>，所有使用共享库的 ELF 可执行文件都会用到这个共享库。</p><p><code>lib/ld-linux.so.2</code> 通常是指向动态链接器可执行文件的符号链接，这个文件的名称为 <code>ld-version.so</code>。</p><p>动态链接器会检查程序所需的共享库清单并使用一组预先定义好的规则来在文件系统上找出相关的库文件。其中一些规则指定了一组存放共享库的标准目录，如 <code>/lib</code>，<code>/usr/lib</code>。</p><p><strong>LD_LIBRARY_PATH 环境变量</strong></p><p>通知动态链接器一个共享库位于一个非标准目录中的一种方法是将该目录添加到 <code>LD_LIBRARY_PATH</code> 环境变量中以分号分隔的目录列表中，如果定义了 <code>LD_LIBRARY_PATH</code>，那么动态链接器在查找标准库目录前会先查找该环境变量列出的目录中的共享库。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">LD_LIBRARY_PATH=. ./prog # 告知动态链接器在当前工作目录中搜索共享库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>静态链接和动态链接的比较</strong></p><p>术语链接通常指的是使用链接器 <code>ld</code> 将一个或多个编译过的目标文件合成一个可执行程序，也称为静态链接。</p><p>在运行时使用共享库的可执行程序需要经历额外的动态链接阶段。</p><h4 id="3-2、共享库-soname"><a href="#3-2、共享库-soname" class="headerlink" title="3.2、共享库 soname"></a><strong>3.2、共享库 soname</strong></h4><p>嵌入到可执行程序以及动态链接器在运行时搜索的名称除了使用真实名称，还经常使用别名来创建共享库，这种别名称为 <code>soname</code>，ELF 中的 <code>DT_SONAME</code> 标签。</p><p>如果共享库拥有一个 <code>soname</code>，那么在静态链接阶段会将 <code>soname</code> 嵌入到可执行文件中，而不会使用真实名称，同时后面的动态链接器在运行时也会使用这个 <code>soname</code> 来搜索库，引入 <code>soname</code> 的目的是为了提供一个间接层，使得可执行程序能够在运行时使用与链接时使用不同的但兼容的共享库。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.cgcc -g -shared -Wl,-soname,libbar.so -o libfoo.so mod1.o mod2.o mod3.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>-Wl,-soname,libbar.so</code> 等选项都是传给链接器的指令，以将共享库 <code>libfoo.so</code> 的 <code>soname</code> 设置为 <code>libbar.so</code></li></ul><p>使用一下命令中的任意一个，可以确定既有共享库的 <code>soname</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">objdump -p libz.so | grep SONAME  SONAME               libz.so.1  readelf -d libz.so | grep SONAME0x000000000000000e (SONAME)             Library soname: [libz.so.1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>soname</code> 创建程序：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -Wall -o prog prog.c libfoo.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>链接器检查到库 <code>libfoo.so</code> 包含了 <code>soname</code> ： <code>libbar.so</code>，就将这个 <code>soname</code> 嵌入到可执行文件中。</p><p>使用共享库时必须要创建一个符号链接，将 <code>soname</code> 指向库的真实名称，并且必须要将这个符号链接放在动态链接器搜索的其中一个目录中。</p><p><img src="D:\Hexo-Blog\source\_posts\Linux漫游——导论\v2-5e9bc96f828ae91b153c6c6504f41fdc_1440w.webp" alt="img"></p><p>程序载入内存以设备执行时发生的事情：</p><p><img src="D:\Hexo-Blog\source\_posts\Linux漫游——导论\v2-3d7bf5f5668a7093739e3ea3916f2c02_1440w.webp" alt="img"></p><p>要找出一个进程当前使用的共享库则可以列出相应的 Linux 特有的 <code>/proc/PID/maps</code> 文件中的内容。</p><h4 id="4、使用共享库的有用工具"><a href="#4、使用共享库的有用工具" class="headerlink" title="4、使用共享库的有用工具"></a><strong>4、使用共享库的有用工具</strong></h4><h4 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a><strong>ldd</strong></h4><p><code>ldd</code> ： 列出动态依赖，显示一个程序运行时所需要的共享库。</p><p><code>ldd</code> 会解析出每个库引用，使用的搜索方式与动态链接器一样，并以下面的形式显示结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">library-name => resolves-to-path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于多数的 ELF 文件，<code>ldd</code> 至少会列出与 <code>ld-linux.so.2</code>、动态链接器以及标准 C 库 <code>lib.so.6</code> 相关的条目。</p><h4 id="objdump-和-readelf"><a href="#objdump-和-readelf" class="headerlink" title="objdump 和 readelf"></a><strong>objdump 和 readelf</strong></h4><p><code>objdump</code> ：用来从可执行文件、编译过的目标、以及共享库中获取各类信息，包括反汇编的二进制机器码，还可以用来显示这些文件各个 ELF 节的头部信息，当这样使用时，它就类似于 <code>readelf</code>，<code>readelf</code> 能显示类似的信息，但是格式不同。</p><h4 id="nm"><a href="#nm" class="headerlink" title="nm"></a><strong>nm</strong></h4><p><code>nm</code> 命令会列出目标库或可执行文件中定义的一组符号，常用来寻找哪些库定义了一个符号。</p><h4 id="5、共享库版本和命名规则"><a href="#5、共享库版本和命名规则" class="headerlink" title="5、共享库版本和命名规则"></a><strong>5、共享库版本和命名规则</strong></h4><p>命名形式：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">libname.so major-id.minor-id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>major-id</code> ：主要版本标识符，区分两个不兼容的版本</li><li><code>minor-id</code> ：次要版本可以是任意字符串，但是通常的形式是两个由点分隔的数字，第一个数字表示次要版本，第二个数字表示该次要版本的补丁号或者修订号</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">libdemo.so.1.0.1libdemo.so.1.0.2libdemo.so.2.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>共享库的 <code>soname</code> 包括相应的主版本标识符，但是不包含次要版本标识符，因此 <code>soname</code> 的命名形式为：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">libname.so.major-id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通常，会将 <code>soname</code> 创建为包含真实名称的目录的一个相对符号链接：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">libdemo.so.1      ->  libdemo.so.1.0.2libdemo.so.2      ->  libdemo.so.2.0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>共享库的一个主要版本可能有多个不同的次要版本，通常每个库的主要版本的 <code>soname</code> 会指向主要版本中最新的次要版本，由于静态链接阶段会将 <code>soname</code> 的副本(独立于次要版本)嵌入到可执行文件中，并且 <code>soname</code> 符号链接后面可能会被修改为指向更新的次要版本，从而确保在执行期间能够加载库的最新的次要版本。</p><p>同一个库的不同主要版本也能够同时存在，被需要它们的程序分别访问。</p><p>除了真实名称和 <code>soname</code> 之外，通常还会为每个共享库定义第三个名称：链接器名称，将可执行文件与共享库链接起来时会使用这个名称，链接器名称是一个只包含库名称不包含主要版本和次要版本标识符的符号链接，其形式为 <code>libname.so</code>，有了链接器名称之后就可以构建能够自动使用共享库最新版本的链接命令。</p><p>链接器名称一般与它所引用的文件位于同一个目录中，它既可以链接到真实名称，也可以链接到库的最新主要版本的 <code>soname</code>。通常最好使用指向 <code>soname</code> 的链接，从而对 <code>soname</code> 的修改会自动反应到链接器名称。</p><p>如果需要使用一个旧版本的共享库，就不能使用链接器名称，要使用真实名称或者 <code>soname</code> 来指示出需要的版本。</p><p><img src="D:\Hexo-Blog\source\_posts\Linux漫游——导论\v2-cae92dd2aff7b336178790a60a59992c_1440w.webp" alt="img"></p><h4 id="5-1、使用标准规范创建一个共享库"><a href="#5-1、使用标准规范创建一个共享库" class="headerlink" title="5.1、使用标准规范创建一个共享库"></a><strong>5.1、使用标准规范创建一个共享库</strong></h4><ul><li>创建目标文件</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>创建共享库，指定真实名称和 <code>soname</code></li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 mod1.o mod2.o mod3.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>为 <code>soname</code> 和链接器名称创建恰当的符号链接</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">ln -s libdemo.so.1.0.1 libdemo.so.1ln -s libdemo.so.1 libdemo.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>使用链接器名称构建可执行文件</li></ul><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -Wall -o prog prog.c -L. -ldemoLD_LIBRARY_PATH=. ./prog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-2、安装共享库"><a href="#5-2、安装共享库" class="headerlink" title="5.2、安装共享库"></a><strong>5.2、安装共享库</strong></h4><p>共享库及其关联的符号链接一般会被安装到一个标准目录中，标准目录包括：</p><ul><li><code>/usr/lib</code> ：是大多数标准库安装的目录</li><li><code>/lib</code> ：应该将系统启动时用到的库安装到这个目录，因为系统启动时可能还没有挂载 <code>/usr/lib</code></li><li><code>/usr/local/lib</code> ：应该将非标准或者实验性质的库安装到这个目录</li><li><code>/etc/ld.so.conf</code> 中列出的目录</li></ul><p>安装完成后一般需要创建 <code>soname</code> 和链接器名称的符号链接：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mv libdemo.so.1.0.1 /usr/libcd /usr/libln -s libdemo.so.1.0.1 libdemo.so.1 # 创建 soname ln -s libdemo.so.1 libdemo.so# 创建链接器名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a><strong>ldconfig</strong></h4><p><code>ldconfig</code> 解决了共享库的两个潜在问题：</p><ul><li>共享库可以位于各种目录中，如果动态链接器需要通过搜索这些目录来找一个库并加载这个库，整个过程将非常慢</li><li>当安装了新版本的库或者删除了旧版本的库，那么 <code>soname</code> 符号链接就不是最新的</li></ul><p><code>ldconfig</code> 可以通过执行两个任务来解决这些问题：</p><ul><li><p>它搜索一组标准的目录并创建或更新一个缓存文件 <code>/etc/ld.so.cache</code> 使之包含在所有这些目录中的主要版本(每个库的主要版本的最新的次要版本)列表，动态链接器在运行时解析库名称时会轮流使用这个缓存文件：</p></li><li><ul><li>为了构建这个缓存，<code>ldconfig</code> 会搜索在 <code>/etc/ld.so.conf</code> 中指定的目录，然后搜索 <code>/lib</code> 和 <code>/usr/lib</code></li><li><code>`/etc/ld.so.conf</code> 文件由一个目录路径名（应该是绝对路径名）列表构成，其中路径名之间用换行、空格、制表符、逗号或冒号分隔</li><li>在一些发行版中， <code>/usr/local/lib</code> 目录也位于这个列表中</li><li><code>ldconfig -p</code> 会显示 <code>/etc/ls.so.cache</code> 的当前内容</li></ul></li><li><p>它检查每个库的各个主要版本的最新次要版本以找出嵌入的 <code>soname</code>，然后在同一目录中为每个 <code>soname</code> 创建（或更新）相对符号链接：</p></li><li><ul><li>为了能够正确执行这些动作，<code>ldconfig</code> 要求库的名称要根据前面介绍的规范来命名：库的真实名称包含主要和次要标识符，它们随着库的版本的更新而恰当的增长</li><li>可以使用命令行选项来指定它执行其中一个动作： <code>-N</code> 选项会防止缓存的重建，<code>-X</code> 选项会阻止 <code>soname</code> 符号链接的创建。 此外， <code>-v</code>(verbose)选项会使得 <code>ldconfig</code> 输出描述其所执行的动作的信息</li></ul></li></ul><p>每当安装了一个新的库，更新或者删除一个既有库，以及 <code>/etc/ld.so.conf</code> 中的目录列表被修改后，都运行相应的 <code>ldconfig</code>。</p><p>安装一个库的两个不同主要版本：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mv libdemo.so.1.0.1 libdemo.so.2.0.0 /usr/lib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为链接器名称创建符号链接：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">ln -s libdemo.so.2 libdemo.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果更新库的一个次要版本，由于链接器名称指向了最新的 <code>soname</code>，因此 <code>ldconfig</code> 还能取得保持链接器名称的最新效果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">mv libdemo.so.2.0.1 /usr/lib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用的是私有库，即没有安装在上述的标准目录中的库，那么可以使用 <code>-n</code> 选项让 <code>ldconfig</code> 创建 <code>soname</code> ，这个选项指定了只处理在命令行中列出的目录的库，无需更新缓存文件。</p><p>使用 <code>ldconfig</code> 来处理当前工作目录中的库：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.cgcc -g -c -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.1 mod1.o mod2.o mod3.o/sbin/ldconfig -nv .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-3、兼容与不兼容库比较"><a href="#5-3、兼容与不兼容库比较" class="headerlink" title="5.3、兼容与不兼容库比较"></a><strong>5.3、兼容与不兼容库比较</strong></h4><p>满足下列条件时表示修改过的库与既有版本兼容：</p><ul><li>库中所有公共方法和变量的语义保持不变</li><li>没有删除库的公共 API 中的函数和变量，但向公共 API 中添加新函数和变量</li><li>每个函数分配的结构以及没和函数的返回结构保持不变</li></ul><p>如果这些条件都满足，更新库时只需要调增既有库的次要版本号，否则就要创建新的主版本。</p><h4 id="5-4、升级共享库"><a href="#5-4、升级共享库" class="headerlink" title="5.4、升级共享库"></a><strong>5.4、升级共享库</strong></h4><p>共享库的优点之一就是当一个运行着的程序正在使用共享库的一个既有版本时，也能够安装新的主要版本或者次要版本的库，需要做的是：</p><ul><li>创建新的库版本，将其安装到恰当的目录</li><li>根据需要更新 <code>soname</code> 和链接器名称符号链接，或者使用 <code>ldconfig</code> 完成这部分工作</li></ul><p>更新次要版本：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.cgcc -g -c -shared -Wl,-soname,libdemo.so.1 -o libdemo.so.1.0.2 mod1.o mod2.o mod3.omv libdemo.so.1.0.2 /usr/libldconfig -v | grep libdemo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>更新主要版本：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -c -fPIC -Wall mod1.c mod2.c mod3.cgcc -g -c -shared -Wl,-soname,libdemo.so.2 -o libdemo.so.2.0.0 mod1.o mod2.o mod3.omv libdemo.so.2.0.0 /usr/libldconfig -v | grep libdemocd /usr/libln -sf libdemo.so.2 libdemo.so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、在目标文件中指定库搜索目录"><a href="#6、在目标文件中指定库搜索目录" class="headerlink" title="6、在目标文件中指定库搜索目录"></a><strong>6、在目标文件中指定库搜索目录</strong></h3><p>通知动态链接器共享库的位置的方式：</p><ul><li><code>LD_LIBRARY_PATH</code> 环境变量中指定</li><li>将共享库安装到标准库目录：<code>/lib</code>，<code>/usr/lib</code>，<code>/etc/ls.so.conf</code> 中列出的其中一个目录</li></ul><p>第三种方式：在静态编辑阶段可以在执行文件中插入一个在运行时搜索共享库的目录列表，这种方式对于库位于一个固定的但不属于动态链接器搜索标准位置时非常有用，在创建文件时需要增加 <code>-rpath</code> 链接器选项。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -Wall,-rpath,/home/mtk/pdir -o prog prog.c libdemo.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将字符串 <code>/home/mtk/pdir</code> 复制到可执行 文件 <code>prog</code> 的运行时库路径列表中，在程序运行时，动态链接器在解析共享库引用时还会搜索这个路径。</p><p>指定多个目录：</p><ul><li>多次指定 <code>-rpath</code> 选项，所有这些列出的目录会被链接成一个放到可执行文件中的有序 <code>-rpath</code> 列表</li><li>在一个 <code>-rpath</code> 选项中可以指定多个由分号分隔开的目录列表，运行时，动态链接器会按照 <code>-rpath</code> 选项中指定的目录顺序来搜索目录</li></ul><pre class="line-numbers language-none"><code class="language-none">-rpath&#96; 的一个可替代方案就是使用 &#96;LD_RUN_PARH&#96; 环境变量，可以将由一个逗号分隔开的目录的字符串赋值给该变量，只有当构建可执行文件时没有指定 &#96;-rpath&#96; 选项才会使用 &#96;LD_RUN_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="6-1、在构建贡献库时使用-rpath-链接器选项"><a href="#6-1、在构建贡献库时使用-rpath-链接器选项" class="headerlink" title="6.1、在构建贡献库时使用 -rpath 链接器选项"></a><strong>6.1、在构建贡献库时使用 -rpath 链接器选项</strong></h4><p>假设有一个库 <code>lib1.so</code> 依赖于另一个共享库 <code>lib2.so</code> ，另外再假设这些库分别位于非标准目录 <code>d1</code> 和 <code>d2</code>中：</p><p><img src="D:\Hexo-Blog\source\_posts\Linux漫游——导论\v2-799878290cd5afeb54d0cc9fbf194cf4_1440w.webp" alt="img"></p><p>首先在 <code>pdir/d2</code> 目录中构建 <code>libx2.so</code>，这里省略了库的版本号和 <code>soanme</code>：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">cd  /home/mtk/pdir/d2gcc -g -c -fPIC -Wall modx2.cgcc -g -shared -o libx2.so modx2.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着在 <code>pdir/d1</code> 目录中构建 <code>libx1.so</code>。由于 <code>libx1.so</code> 依赖于 <code>lib2.so</code>，并且 <code>libx2.so</code> 位于一个非标准目录中，因此在指定 <code>libx2.so</code> 的运行时位置时需要使用 <code>-rpath</code> 链接器选项。这个选项的取值与库的链接时位置可以不同：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">cd /home/mtk/pdir/d1gcc -g -c -Wall modx1.cgcc -g -shared -o libx1.so modx1.o -Wl,-rpath,/home/mtk/pdir/d2 -L/home/mtk/pdir/d2 -lx2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>pdir</code> 目录中构建主程序，由于主程序使用了 <code>libx1.so</code> 并且这个库位于一个非标准目录中，因此还需要使用 <code>-rpath</code> 链接器选项：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">cd /home/mtk/pdirgcc -g -Wall -o prog prog.c -Wl,-rpath,/home/mtk/pdir/d1 -L/home/mtk/pdir/d1 -lx1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在链接主程序是，无需指定 <code>libx2.so</code>，由于链接器能够分析 <code>libx1.so</code> 中的 <code>rpath</code> 列表，因此它能够找到 <code>libx2.so</code>，同时在静态链接阶段解析出所有的符号。</p><p>可以通过 <code>readelf --dynamic</code> 或者等价的 <code>readelf -d</code> 命令的输出来查看 <code>rpath</code> 列表。</p><h4 id="6-2、ELF-DT-RPATH-和-DT-RUNPATH-条目"><a href="#6-2、ELF-DT-RPATH-和-DT-RUNPATH-条目" class="headerlink" title="6.2、ELF DT_RPATH 和 DT_RUNPATH 条目"></a><strong>6.2、ELF DT_RPATH 和 DT_RUNPATH 条目</strong></h4><p>第一版 ELF 规范中，只有一种 <code>rpath</code> 列表能够被嵌入到可执行文件或共享库中，对应 ELF 文件中的 <code>DT_RPATH</code> 标签。后续的 ELF 舍弃了 <code>DT_RPATH</code> ，同时引入 <code>DT_RUNPATH</code> 来表示 <code>rpath</code> 列表，两者的差别在于动态链接器在运行时搜索共享库时它们相对于 <code>LD_LIBRARY_PATH</code> 环境变量的优先级，<code>DT_RPATH</code> 的优先级更高，<code>DT_RUNPATH</code> 的优先级更低。</p><p>默认情况下，链接器将 <code>rpath</code> 列表创建为 <code>DT_RPATH</code> 标签。为了让链接器将 <code>rpath</code> 列表创建为 <code>DT_RUNPATH</code> 条目必须使用 <code>--enable-new-dtags</code>。</p><h4 id="6-3、在-rpath-中使用-ORIGIN"><a href="#6-3、在-rpath-中使用-ORIGIN" class="headerlink" title="6.3、在 rpath 中使用 $ORIGIN"></a><strong>6.3、在 rpath 中使用 $ORIGIN</strong></h4><p>应用程序中使用了自身的共享库，但同时不希望强制要求将这些库安装在其中一个标准目录中，可以在构建链接器的时候，增加 <code>$ORIGIN</code>，动态链接器将这个字符串解释成 “包含应用程序的目录”：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -Wl,-rpath,'ORIGIN'/lib ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="7、在运行时找出共享库"><a href="#7、在运行时找出共享库" class="headerlink" title="7、在运行时找出共享库"></a><strong>7、在运行时找出共享库</strong></h3><p>在解析库依赖时，动态链接器首先会检查各个依赖字符串以确定它是否包含 <code>/</code>，如果找到了一个斜线，那么依赖字符串就会被解释成一个路径名，并且会使用该路径名加载库，否则动态链接器会使用下面的规则来搜索共享库：</p><ul><li>如果可执行文件的 <code>DT_RPATH</code> 运行时库路径列表中包含目录并且不包含 <code>DT_RUNPATH</code> 列表，那么就搜索这些目录，按照链接程序时指定的目录顺序</li><li>如果定义了 <code>LD_LIBRARY_PATH</code> 环境变量，那么就会轮流搜索该变量值中以冒号分隔的各个目录，如果可执行文件是一个 set-user-ID 或者 set-group-ID 程序，那么就会忽略 <code>LD_LIBRARY_PATH</code> 变量。这项安全措施就是为了防止用户欺骗动态链接器让其加载一个与可执行文件所属的库的名称一样的私有库</li><li>如果可执行文件 <code>DT_RUNPATH</code> 运行时库路径列表中包含目录，那么就搜索这些目录，按照链接程序时指定的目录顺序</li><li>检查 <code>/etc/ld.so.cache</code> 文件以确认它是否包含了与库相关的条目</li><li>搜索 <code>/lib</code> 和 <code>/usr/lib</code> 目录</li></ul><h3 id="运行时符号解析"><a href="#运行时符号解析" class="headerlink" title="运行时符号解析"></a><strong>运行时符号解析</strong></h3><p>假设现在有一个主程序和一个共享库，它们两个都定义了一个全局函数 <code>xyz()</code>，并且共享库中的另一个函数调用了 <code>xyz()</code>：</p><p><img src="D:\Hexo-Blog\source\_posts\Linux漫游——导论\v2-fc4bc00b982b2ad965ea63baaa6d3b29_1440w.webp" alt="img"></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -c -fPIC -Wall -c foo.cgcc -g -shared -o libfoo.so foo.ogcc -g -o prog prog.c libfoo.soLD_LIBRARY_PATH=../prog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>主程序中的 <code>xyz()</code> 定义将覆盖共享库中的定义</li><li>如果一个全局符号在多个库中进行了定义，那么对该符号的引用会绑定在扫描库时找到的第一个定义，扫描顺序是按照这些库在静态链接命令行中列出时从左到右的顺序</li></ul><p>如果想使用共享库中的 <code>xyz()</code> 调用，需要指定 <code>-Bsymbolic</code> 链接器选项：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">gcc -g -c -fPIC -Wall -c foo.cgcc -g -shared -Wl,-Bsymbolic -o libfoo.so foo.ogcc -g -o prog prog.c libfoo.soLD_LIBRARY_PATH=../prog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>-Bsymbolic</code> 链接器选项指定了共享库中对全局符号的应用应该优先绑定到库中的相应定义(如果存在)。</p><h4 id="使用静态库取代共享库"><a href="#使用静态库取代共享库" class="headerlink" title="使用静态库取代共享库"></a><strong>使用静态库取代共享库</strong></h4><p>默认情况下，当链接器能够选择名称一样的共享库和静态库时，会优先使用共享库：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">-Lsomedir -ldemo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并且 <code>libdemo.so</code> 和 <code>libdemo.a</code> 都存在的话，会优先使用 <code>libdemo.a</code>。</p><p>如果要强制使用静态库：</p><ul><li>在 gcc 命令中指定静态库的路径名，包括 <code>.a</code> 扩展</li><li>在 gcc 命令行中指定 <code>-static</code> 选项</li><li>使用 <code>-Wl,-Bstatic</code> 和 <code>-Wl,Bdynamic</code> gcc 选项来显示指定链接到静态库还是动态库</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++. Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Net-Experience-report Using_STMP2SendAEmail</title>
      <link href="/2023/07/25/Net-Experience-report-Using-STMP2SendAEmail/"/>
      <url>/2023/07/25/Net-Experience-report-Using-STMP2SendAEmail/</url>
      
        <content type="html"><![CDATA[<h1 id="使用telnet-QQ邮箱在命令行下发送邮件"><a href="#使用telnet-QQ邮箱在命令行下发送邮件" class="headerlink" title="使用telnet + QQ邮箱在命令行下发送邮件"></a>使用telnet + QQ邮箱在命令行下发送邮件</h1><p>​        整个活(后空翻)</p><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>​        最近写C++和操作系统写腻歪了,来点活.</p><h2 id="配置telnet"><a href="#配置telnet" class="headerlink" title="配置telnet"></a>配置telnet</h2><p>​        Windows11相当的智能,我们只需要打开控制面板:</p><p><img src="image-20230725104103213.png" alt="image-20230725104103213"></p><p><img src="image-20230725104221212.png" alt="image-20230725104221212"></p><p><img src="image-20230725104447916.png" alt="image-20230725104447916"></p><p>​        对,把这玩意勾上就好.如果你是第一次开,Windows就会准备好相关的文件.</p><h2 id="打开QQ邮箱的SMTP服务"><a href="#打开QQ邮箱的SMTP服务" class="headerlink" title="打开QQ邮箱的SMTP服务"></a>打开QQ邮箱的SMTP服务</h2><p>​        qq邮箱-&gt; 设置-&gt;账户 -&gt; 找到这些服务，开启SMTP服务.</p><p>​        以及,我们开启服务会收到一个授权码,请务必!请务必保存好!</p><h2 id="login"><a href="#login" class="headerlink" title="login"></a>login</h2><p>​        现在火速前往cmd.或者PowerShell,只需要输入</p><pre class="line-numbers language-none"><code class="language-none">telnet smtp.qq.com 25<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        25是端口号,也有人会要求你输入加密端口587,我的评价是:无所谓.</p><p>​        如果你发现telnet不认识,爬回去返回第一大步.</p><p><img src="image-20230725104858217.png" alt="image-20230725104858217"></p><p>​        220是我们的状态码, 表示的是服务就绪.我们输入</p><pre class="line-numbers language-none"><code class="language-none">helo qq.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230725105125071.png" alt="image-20230725105125071"></p><p>​        表示我们发出请求.</p><p>​        对了,我们的输入中,发现输错了就需要重新输入.退格是无用的:服务器会每时每刻接受我们的输入字符而不会撤回.</p><p><img src="image-20230725105241994.png" alt="image-20230725105241994"></p><p>​        这个代表我们的链接成功</p><pre class="line-numbers language-none"><code class="language-none">auth login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们发出了登录账户的请求. 如果在这个步骤中发出了 502 错误,稍后尝试(也有可能你输错了,比如我整了auto login…)</p><p><img src="image-20230725105537073.png" alt="image-20230725105537073"></p><p>​        这是什么意思? 334表示的是认证输入,就像我们需要输入账号和密码一样.事实上,这里的ASCII文字是使用base64编码了的.我们使用解码:</p><p>​        在网站：<a href="https://link.zhihu.com/?target=https%3A//base64.us/">Base64 加密解密 - Base64.us</a></p><p><img src="image-20230725105842209.png" alt="image-20230725105842209"></p><pre class="line-numbers language-none"><code class="language-none">334 Username:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        就是这样.</p><p>​        我把邮箱给出去—-<strong>但是务必注意是base64编码</strong></p><p><img src="image-20230725105905462.png" alt="image-20230725105905462"></p><p><img src="image-20230725105930962.png" alt="image-20230725105930962"></p><p><img src="image-20230725105944043.png" alt="image-20230725105944043"></p><p>​        别急着输入你的QQ密码,首先, 我们要的是 base64编码,其次,要的是那个授权码!我们得吧授权码给编码后再输入</p><p><img src="image-20230725110134366.png" alt="image-20230725110134366"></p><p>​        235表示认证成功.</p><pre class="line-numbers language-none"><code class="language-none">注意！！我们在输入用户名和密码的时候如果打错字了，需要重来。退格之后空格是没用的，因为键盘每一次敲下都把数据传到了服务器上面，而服务器上面的呈现方式和我们所看到的是不一样的，所以这一步是最最最麻烦的。（包括在输入命令的时候也是一样，错了就要换行重输）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后,我们可以开始操作了:</p><h2 id="MAIL-FROM与RCPT-TO"><a href="#MAIL-FROM与RCPT-TO" class="headerlink" title="MAIL FROM与RCPT TO"></a>MAIL FROM与RCPT TO</h2><p>MAIL FROM必须写自己所登录的邮箱名字，RCPT TO写收件人的邮箱名字。</p><p><img src="image-20230725110313627.png" alt="image-20230725110313627"></p><h2 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a>DATA</h2><p>​        DATA表示的是我们预备好输入邮件内容</p><p><img src="image-20230725110350476.png" alt="image-20230725110350476"></p><p>​        注意,要符合发送规范:</p><pre class="line-numbers language-none"><code class="language-none">from:sender@qq.comto:sendee@qq.comsubject:urSub正文内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        sender, sendee换成自己的和对方的邮箱.</p><p>​        结束输入的方式,是单独开启一行打一个点<code>.</code></p><p><img src="image-20230725110553260.png" alt="image-20230725110553260"></p><p>​        这个时候敲回车</p><p><img src="image-20230725110605782.png" alt="image-20230725110605782"></p><p>​        发送成功!</p><p><img src="image-20230725110722059.png" alt="image-20230725110722059"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Experiment </tag>
            
            <tag> NetWork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手整一个操作系统玩玩（1）</title>
      <link href="/2023/07/13/%E5%8A%A8%E6%89%8B%E6%95%B4%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%8E%A9%E7%8E%A9%EF%BC%881%EF%BC%89/"/>
      <url>/2023/07/13/%E5%8A%A8%E6%89%8B%E6%95%B4%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%8E%A9%E7%8E%A9%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统实现（From-Ogrange’S）"><a href="#操作系统实现（From-Ogrange’S）" class="headerlink" title="操作系统实现（From Ogrange’S）"></a>操作系统实现（From Ogrange’S）</h1><h2 id="暑期书籍阅读Project"><a href="#暑期书籍阅读Project" class="headerlink" title="暑期书籍阅读Project"></a>暑期书籍阅读Project</h2><p>​        我们下面干一件很酷很酷的事情——</p><p>​        这是一段很有名（convinced）的ASM汇编代码</p><pre class="line-numbers language-none"><code class="language-none">1 org 07c00h ; 告诉编译器程序加载到*7c00*处2 mov ax, cs3 mov ds, ax4 mov es, ax5 call DispStr ; 调用显示字符串例程6 jmp $ ; 无限循环7 DispStr:8 mov ax, BootMessage9 mov bp, ax ; *ES:BP &#x3D;* 串地址10 mov cx, 24 ; *CX &#x3D;* 串长度11 mov ax, 01301h ; *AH &#x3D; 13, AL &#x3D; 01h*12 mov bx, 000ch ; 页号为*0 (BH &#x3D; 0)* 黑底红字*(BL &#x3D; 0Ch,*高亮*)*13 mov dl, 014 int 10h ; *10h* 号中断15 ret16 BootMessage: db &quot;Hello,From_CCSTDC_World!&quot;17 times 510 - ($-$$) db 0 ; 填充剩下的空间，使生成的二进制代码恰好为*512*字节18 dw 0xaa55 ; 结束标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        好吧,做出一个假设——你不知道怎么处理汇编代码，那么，根据这本书的建议，你可以考虑去下载一个NASM汇编编译器，我们直接在Windows下的官网整出来一个就好了。当我们下载好了之后，转向点击exe文件（原谅我在Windows下干活），会自动弹出一个DOS窗口，把我们刚刚准备好的汇编文件——麻烦重命名成boot.asm（这个后缀表示的是这是一个汇编文件）    放到exe文件下方（嘿！你知道的！或者指定清楚全文件名，这里偷个懒）</p><pre class="line-numbers language-none"><code class="language-none">nasm boot.asm -o boot.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们就有了一个二进制文件。但是仅有次远远不够，对于我自己，我转战了Linux虚拟机（呃，不如先去了解一下怎么搞Linux虚拟机？if any questions…）在Linux终端，键入这个命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>boot.bin <span class="token assign-left variable">of</span><span class="token operator">=</span>devfd0 <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h3><p><strong>*\</strong>*一、dd命令的解释**<em>**</em></p><pre class="line-numbers language-none"><code class="language-none">dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。注意：指定数字的地方若以下列字符结尾，则乘以相应的数字：b&#x3D;512；c&#x3D;1；k&#x3D;1024；w&#x3D;2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong><em>\</em>参数注释：**</strong></p><ol><li><p>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</p></li><li><p>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</p></li><li><p>ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</p><p>obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</p><p>bs=bytes：同时设置读入/输出的块大小为bytes个字节。</p></li></ol><p>\4. cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</p><p>\5. skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</p><p>\6. seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</p><p>注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</p><p>\7. count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</p><p>\8. conv=conversion：用指定的参数转换文件。</p><p>  ascii：转换ebcdic为ascii</p><p>   ebcdic：转换ascii为ebcdic</p><p>  ibm：转换ascii为alternate ebcdic</p><p>  block：把每一行转换为长度为cbs，不足部分用空格填充</p><p>  unblock：使每一行的长度都为cbs，不足部分用空格填充</p><p>  lcase：把大写字符转换为小写字符</p><p>  ucase：把小写字符转换为大写字符</p><p>  swab：交换输入的每对字节</p><p>   noerror：出错时不停止</p><p>   notrunc：不截短输出文件</p><p>  sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</p><p><strong>*\</strong>*二、dd应用实例**<em>**</em></p><p><strong><em>\</em>1.将本地的/dev/hdb整盘备份到/dev/hdd**</strong></p><p>#dd if=/dev/hdb of=/dev/hdd</p><p><strong><em>\</em>2.将/dev/hdb全盘数据备份到指定路径的image文件**</strong></p><p>#dd if=/dev/hdb of=/root/image</p><p><strong><em>\</em>3.将备份文件恢复到指定盘**</strong></p><p>#dd if=/root/image of=/dev/hdb</p><p><strong><em>\</em>4.备份/dev/hdb全盘数据，并利用gzip工具进行压缩，保存到指定路径**</strong></p><p>#dd if=/dev/hdb | gzip &gt; /root/image.gz</p><p><strong><em>\</em>5.将压缩的备份文件恢复到指定盘**</strong></p><p>#gzip -dc /root/image.gz | dd of=/dev/hdb</p><p><strong><em>\</em>6.备份与恢复MBR**</strong></p><p>备份磁盘开始的512个字节大小的MBR信息到指定文件：</p><p>#dd if=/dev/hda of=/root/image count=1 bs=512</p><p>  count=1指仅拷贝一个块；bs=512指块大小为512个字节。</p><p>恢复：</p><p>#dd if=/root/image of=/dev/had</p><p>将备份的MBR信息写到磁盘开始部分</p><p><strong><em>\</em>7.备份软盘**</strong></p><p>#dd if=/dev/fd0 of=disk.img count=1 bs=1440k (即块大小为1.44M)</p><p><strong><em>\</em>8.拷贝内存内容到硬盘**</strong></p><p>#dd if=/dev/mem of=/root/mem.bin bs=1024 (指定块大小为1k) </p><p><strong><em>\</em>9.拷贝光盘内容到指定文件夹，并保存为cd.iso文件**</strong></p><p>#dd if=/dev/cdrom(hdc) of=/root/cd.iso</p><p><strong><em>\</em>10.增加swap分区文件大小**</strong></p><p>第一步：创建一个大小为256M的文件：</p><p>#dd if=/dev/zero of=/swapfile bs=1024 count=262144</p><p>第二步：把这个文件变成swap文件：</p><p>#mkswap /swapfile</p><p>第三步：启用这个swap文件：</p><p>#swapon /swapfile</p><p>第四步：编辑/etc/fstab文件，使在每次开机时自动加载swap文件：</p><p>/swapfile  swap  swap  default  0 0</p><p><strong><em>\</em>11.销毁磁盘数据**</strong></p><p>#dd if=/dev/urandom of=/dev/hda1</p><p>注意：利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据。</p><p><strong><em>\</em>12.测试硬盘的读写速度**</strong></p><p>#dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</p><p>#dd if=/root/1Gb.file bs=64k | dd of=/dev/null</p><p>通过以上两个命令输出的命令执行时间，可以计算出硬盘的读、写速度。</p><p><strong><em>\</em>13.确定硬盘的最佳块大小：**</strong></p><p>#dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file</p><p>#dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file</p><p>#dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file</p><p>#dd if=/dev/zero bs=8192 count=125000 of=/root/1Gb.file</p><p>通过比较以上命令输出中所显示的命令执行时间，即可确定系统最佳的块大小。</p><p><strong><em>\</em>14.修复硬盘：**</strong></p><p>#dd if=/dev/sda of=/dev/sda 或dd if=/dev/hda of=/dev/hda</p><p>当硬盘较长时间(一年以上)放置不使用后，磁盘上会产生magnetic flux point，当磁头读到这些区域时会遇到困难，并可能导致I/O错误。当这种情况影响到硬盘的第一个扇区时，可能导致硬盘报废。上边的命令有可能使这些数 据起死回生。并且这个过程是安全、高效的。</p><p><strong><em>\</em>15.利用netcat远程备份**</strong></p><p>#dd if=/dev/hda bs=16065b | netcat &lt; targethost-IP &gt; 1234</p><p>在源主机上执行此命令备份/dev/hda</p><p>#netcat -l -p 1234 | dd of=/dev/hdc bs=16065b</p><p>在目的主机上执行此命令来接收数据并写入/dev/hdc</p><p>#netcat -l -p 1234 | bzip2 &gt; partition.img</p><p>#netcat -l -p 1234 | gzip &gt; partition.img</p><p>以上两条指令是目的主机指令的变化分别采用bzip2、gzip对数据进行压缩，并将备份文件保存在当前目录。</p><p><strong><em>\</em>将一个很大的视频文件中的第i个字节的值改成0×41（也就是大写字母A的ASCII值）**</strong></p><p>echo A | dd of=bigfile seek=$i bs=1 count=1 conv=notrunc</p><p><strong>*\</strong>*三、/dev/null和/dev/zero的区别**<em>**</em></p><p>/dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！</p><p>/dev/zero，是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0。</p><p>/dev/null——它是空设备，也称为位桶（bit bucket）。任何写入它的输出都会被抛弃。如果不想让消息以标准输出显示或写入文件，那么可以将消息重定向到位桶。</p><p>#if=/dev/zero of=./test.txt bs=1k count=1<br>#ls –l</p><p>total 4<br>-rw-r–r–  1 oracle  dba      1024 Jul 15 16:56 test.txt</p><p>#find / -name access_log 2&gt;/dev/null</p><p><strong>*\</strong>*3.1****使用/dev/null**<em>**</em> </p><p>把/dev/null看作”黑洞”， 它等价于一个只写文件，所有写入它的内容都会永远丢失.，而尝试从它那儿读取内容则什么也读不到。然而， /dev/null对命令行和脚本都非常的有用</p><p>l <strong>禁止标准输出</strong></p><p>#cat $filename &gt;/dev/null</p><p>文件内容丢失，而不会输出到标准输出.</p><p>l <strong>禁止标准错误</strong></p><p>#rm $badname 2&gt;/dev/null</p><p>这样错误信息[标准错误]就被丢到太平洋去了</p><p>l <strong>禁止标准输出和标准错误的输出</strong></p><p>#cat $filename 2&gt;/dev/null &gt;/dev/null</p><p>如果”$filename”不存在，将不会有任何错误信息提示；如果”$filename”存在， 文件的内容不会打印到标准输出。</p><p>因此，上面的代码根本不会输出任何信息。当只想测试命令的退出码而不想有任何输出时非常有用。</p><p>#cat $filename &amp;&gt;/dev/null</p><p>这样其实也可以， 由 Baris Cicek 指出</p><p><strong><em>\</em>自动清空日志文件的内容**</strong></p><p>l Deleting contents of a file, but preserving the file itself, with all attendant permissions(from Example 2-1 and Example 2-3): </p><p>#cat /dev/null &gt; /var/log/messages<br># : &gt; /var/log/messages  有同样的效果， 但不会产生新的进程.（因为:是内建的）<br>#cat /dev/null &gt; /var/log/wtmp</p><p><strong><em>\</em>隐藏cookie而不再使用**</strong></p><p>特别适合处理这些由商业Web站点发送的讨厌的”cookies”</p><p>#if [ -f ~/.netscape/cookies ] # 如果存在则删除.<br>#then<br>#rm -f ~/.netscape/cookies<br>#fi<br>#ln -s /dev/null ~/.netscape/cookies</p><p>现在所有的cookies都会丢入黑洞而不会保存在磁盘上了.</p><p><strong>*\</strong>*3.2****使用/dev/zero**<em>**</em></p><p>像/dev/null一样， /dev/zero也是一个伪文件， 但它实际上产生连续不断的null的流（二进制的零流，而不是ASCII型的）。 写入它的输出会丢失不见， 而从/dev/zero读出一连串的null也比较困难， 虽然这也能通过od或一个十六进制编辑器来做到。 /dev/zero主要的用处是用来创建一个指定长度用于初始化的空文件，就像临时交换文件。</p><p><strong><em>\</em>用/dev/zero创建一个交换临时文件**</strong></p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bash \# 创建一个交换文件. ROOT_UID&#x3D;0 # Root 用户的 $UID 是 0. E_WRONG_USER&#x3D;65 # 不是 root? FILE&#x3D;&#x2F;swap BLOCKSIZE&#x3D;1024 MINBLOCKS&#x3D;40 SUCCESS&#x3D;0 \# 这个脚本必须用root来运行. if [ &quot;$UID&quot; -ne &quot;$ROOT_UID&quot; ]  then  echo; echo &quot;You must be root to run this script.&quot;; echo  exit $E_WRONG_USER fi blocks&#x3D;$&#123;1:-$MINBLOCKS&#125; # 如果命令行没有指定， \#+ 则设置为默认的40块. \# 上面这句等同如： \# ————————————————– \# if [ -n &quot;$1&quot; ] \# then \# blocks&#x3D;$1 \# else \# blocks&#x3D;$MINBLOCKS \# fi \# ————————————————– if [ &quot;$blocks&quot; -lt $MINBLOCKS ] then blocks&#x3D;$MINBLOCKS # 最少要有 40 个块长. fi echo &quot;Creating swap file of size $blocks blocks (KB).&quot; dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;$FILE bs&#x3D;$BLOCKSIZE count&#x3D;$blocks # 把零写入文件. mkswap $FILE $blocks # 将此文件建为交换文件（或称交换分区）. swapon $FILE # 激活交换文件. echo &quot;Swap file created and activated.&quot; exit $SUCCESS <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        关于 /dev/zero 的另一个应用是为特定的目的而用零去填充一个指定大小的文件， 如挂载一个文件系统到环回设备 （loopback device）或”安全地” 删除一个文件</p><p><strong><em>\</em>例子创建ramdisk**</strong></p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bash \# ramdisk.sh \# &quot;ramdisk&quot;是系统RAM内存的一段， \#+ 它可以被当成是一个文件系统来操作. \# 它的优点是存取速度非常快 (包括读和写). \# 缺点: 易失性, 当计算机重启或关机时会丢失数据. \#+ 会减少系统可用的RAM. \# 10 # 那么ramdisk有什么作用呢? \# 保存一个较大的数据集在ramdisk, 比如一张表或字典, \#+ 这样可以加速数据查询, 因为在内存里查找比在磁盘里查找快得多. E_NON_ROOT_USER&#x3D;70 # 必须用root来运行. ROOTUSER_NAME&#x3D;root MOUNTPT&#x3D;&#x2F;mnt&#x2F;ramdisk SIZE&#x3D;2000 # 2K 个块 (可以合适的做修改) BLOCKSIZE&#x3D;1024 # 每块有1K (1024 byte) 的大小 DEVICE&#x3D;&#x2F;dev&#x2F;ram0 # 第一个 ram 设备 username&#x3D;&#96;id -nu&#96; if [ &quot;$username&quot; !&#x3D; &quot;$ROOTUSER_NAME&quot; ] then  echo &quot;Must be root to run &quot;&#96;basename $0&#96;&quot;.&quot;  exit $E_NON_ROOT_USER fi  if [ ! -d &quot;$MOUNTPT&quot; ] # 测试挂载点是否已经存在了, then #+ 如果这个脚本已经运行了好几次了就不会再建这个目录了  mkdir $MOUNTPT #+ 因为前面已经建立了. fi dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;$DEVICE count&#x3D;$SIZE bs&#x3D;$BLOCKSIZE  \# 把RAM设备的内容用零填充.                          \# 为何需要这么做? mke2fs $DEVICE # 在RAM设备上创建一个ext2文件系统. mount $DEVICE $MOUNTPT # 挂载设备. chmod 777 $MOUNTPT # 使普通用户也可以存取这个ramdisk. \# 但是, 只能由root来缷载它. echo &quot;&quot;$MOUNTPT&quot; now available for use.&quot; \# 现在 ramdisk 即使普通用户也可以用来存取文件了. \# 注意, ramdisk是易失的, 所以当计算机系统重启或关机时ramdisk里的内容会消失. \# 拷贝所有你想保存文件到一个常规的磁盘目录下. \# 重启之后, 运行这个脚本再次建立起一个 ramdisk. \# 仅重新加载 &#x2F;mnt&#x2F;ramdisk 而没有其他的步骤将不会正确工作. \# 如果加以改进, 这个脚本可以放在 &#x2F;etc&#x2F;rc.d&#x2F;rc.local, \#+ 以使系统启动时能自动设立一个ramdisk. \# 这样很合适速度要求高的数据库服务器. exit 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Extension-Finished-amp-amp-move-on"><a href="#Extension-Finished-amp-amp-move-on" class="headerlink" title="Extension Finished &amp;&amp; move on"></a>Extension Finished &amp;&amp; move on</h3><p>​        我们拿到了一个boot.img映像文件。现在，指定虚拟机一个</p><p>这里通过虚拟机<a href="https://so.csdn.net/so/search?q=VMware&amp;spm=1001.2101.3001.7020">VMware</a>进行测试写好的镜像系统。<br>  首先新建一个虚拟机，暂时不用添加系统，选择稍后安装操作系统，如下图：<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODM4MDM5,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p><p>图4</p><p> 然后，系统类型可随便选择，笔者这里都选择其他，如下图：<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODM4MDM5,size_16,color_FFFFFF,t_70#pic_center-16892593779681.png" alt="在这里插入图片描述"></p><p>图5</p><p>  之后的虚拟机名字、位置选择，可自行选择。完成之后，会有如下图6界面；</p><p>  点击编辑虚拟机设置，会出现如图7界面，由于方框中没有软盘驱动器的选项，我们可以选择添加；</p><p><img src="image-20230713211644653.png" alt="image-20230713211644653"></p><p>图7</p><p>  在添加硬件向导里选择软盘驱动器，如下图8所示；<br><img src="image-20230713211657226.png" alt="image-20230713211657226"></p><p>  添加之后，在软盘那里选择使用软盘映像文件，把我们保存的软盘镜像:肯定的是boot.img添加进去，之后就可运行虚拟机了。</p><p>3、运行虚拟机：</p><p><img src="image-20230713211342658.png" alt="image-20230713211342658"></p><p>​        好吧，还是很酷的。虽然，还是看起来不咋地。但是我们的征程不会停下来</p><p>​        你可能还没有从刚刚的兴奋中走出来，可是我不得不告诉你，实际上，你刚刚所完成的并不是一个完整的操作系统，而仅仅是一个最最简单的引导扇区（Boot Sector）。然而不管我们完成的是什么，至少，它是直接在裸机上运行的，不依赖于任何其他软件，所以，这和我们平时所编写的应用软件有本质的区别。它不是操作系统，但已经具备了操作系统的一个特性。</p><p>​        我们知道，当计算机电源被打开时，它会先进行加电自检（POST），然后寻找启动盘，如果是选择从软盘启动，计算机就会检查软盘的0面0磁道1扇区，如果发现它以0xAA55 (9)结束，则BIOS认为它是一个引导扇区。当然，一个正确的引导扇区除了以0xAA55结束之外，还应该包含一段少于512字节的执行码。</p><p>​        好了，一旦BIOS发现了引导扇区，就会将这512字节的内容装载到内存地址0000:7c00处，然后跳转到0000:7c00处将控制权彻底交给这段引导代码。到此为止，计算机不再由BIOS中固有的程序来控制，而变成由操作系统的一部分来控制。</p><p>​        现在，你可能明白了为什么在那段代码的第一行会出现“org0 7c00”这样的代码。没错，这行代码就是告诉编译器，将来我们的这段程序要被加载到内存偏移地址0x7c00处。好了，下面将对代码的其他部分进行详细解释。</p><h3 id="在Linux中开启虚拟机中虚拟机的模式"><a href="#在Linux中开启虚拟机中虚拟机的模式" class="headerlink" title="在Linux中开启虚拟机中虚拟机的模式"></a>在Linux中开启虚拟机中虚拟机的模式</h3><p>​        是的！我们下一个bochs虚拟机，在我们的Linux操作系统下！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> vgabios bochs bochs-x bximage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        现在启动一下这个虚拟机配置程序</p><pre class="line-numbers language-none"><code class="language-none">bximage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;bximageDisk Image Creation Tool for Bochs$Id: bximage.c,v 1.32 2006&#x2F;06&#x2F;16 07:29:33 vruppert Exp $&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Do you want to create a floppy disk image or a hard disk image?Please type hd or fd. [hd] fd ↩ &#x2F;&#x2F; Enter fdChoose the size of floppy disk image to create, in megabytes.Please type 0.16, 0.18, 0.32, 0.36, 0.72, 1.2, 1.44, 1.68, 1.72, or 2.88.[1.44] ↩ &#x2F;&#x2F; default choiceI will create a floppy image withcyl&#x3D;80heads&#x3D;2sectors per track&#x3D;18total sectors&#x3D;2880total bytes&#x3D;1474560What should I name the image?[a.img] ↩ &#x2F;&#x2F; name the default33Writing: [ ] Done.I wrote 1474560 bytes to a.img.The following line should appear in your bochsrc:floppya: image&#x3D;&quot;a.img&quot;, status&#x3D;inserted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们创建了一个空的映像文件，然后，使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>boot.bin <span class="token assign-left variable">of</span><span class="token operator">=</span>a.img <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        完成编写</p><p>​        然后，开一个目录：把我们写好了的映像文件跟一个空白的配置文件放在一起</p><pre class="line-numbers language-none"><code class="language-none">################################################################ Configuration file for Bochs################################################################ how much memory the emulated machine will havemegs: 32# filename of ROM imagesromimage: file&#x3D;&#x2F;usr&#x2F;share&#x2F;bochs&#x2F;BIOS-bochs-latestvgaromimage: file&#x3D;&#x2F;usr&#x2F;share&#x2F;vgabios&#x2F;vgabios.bin# what disk images will be usedfloppya: 1_44&#x3D;a.img, status&#x3D;inserted# choose the boot disk.boot: floppy# where do we send log messages?log: bochsout.txt# disable the mousemouse: enabled&#x3D;0# enable key mapping, using US layout as default.keyboard: keymap&#x3D;&#x2F;usr&#x2F;share&#x2F;bochs&#x2F;keymaps&#x2F;x11-pc-us.map# what makes ot different is that the keyboard_mapping key is abolished and deprecated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        把这一串东西复制进去,确保这些文件都在路径下！（检查一下，不然报出各种奇怪的错误！）</p><p>​        现在，启用配置文件二开一个虚拟机：</p><pre class="line-numbers language-none"><code class="language-none">bochs -f bochsrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        （对了，注意就是这个文件没有后缀名！这很重要）</p><p><img src="image-20230713223012591.png" alt="image-20230713223012591"></p><p>​        虚拟机启动了！现在是debug模式，所以我们可以一步步打断点的调试内核。</p><p>​        </p><pre class="line-numbers language-none"><code class="language-none">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;                       Bochs x86 Emulator 2.6.11              Built from SVN snapshot on January 5, 2020                Timestamp: Sun Jan  5 08:36:00 CET 2020&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;00000000000i[      ] LTDL_LIBRARY_PATH not set. using compile time default &#39;&#x2F;usr&#x2F;lib&#x2F;bochs&#x2F;plugins&#39;00000000000i[      ] BXSHARE not set. using compile time default &#39;&#x2F;usr&#x2F;share&#x2F;bochs&#39;00000000000i[      ] lt_dlhandle is 0x55ab518f9fe000000000000i[PLUGIN] loaded plugin libbx_unmapped.so00000000000i[      ] lt_dlhandle is 0x55ab518fb60000000000000i[PLUGIN] loaded plugin libbx_biosdev.so00000000000i[      ] lt_dlhandle is 0x55ab518fce0000000000000i[PLUGIN] loaded plugin libbx_speaker.so00000000000i[      ] lt_dlhandle is 0x55ab518feb8000000000000i[PLUGIN] loaded plugin libbx_extfpuirq.so00000000000i[      ] lt_dlhandle is 0x55ab518ff35000000000000i[PLUGIN] loaded plugin libbx_parallel.so00000000000i[      ] lt_dlhandle is 0x55ab51900fb000000000000i[PLUGIN] loaded plugin libbx_serial.so00000000000i[      ] lt_dlhandle is 0x55ab519053b000000000000i[PLUGIN] loaded plugin libbx_gameport.so00000000000i[      ] lt_dlhandle is 0x55ab51905be000000000000i[PLUGIN] loaded plugin libbx_iodebug.so00000000000i[      ] reading configuration from bochsrc00000000000i[      ] lt_dlhandle is 0x55ab5190665000000000000i[PLUGIN] loaded plugin libbx_x.so00000000000i[      ] installing x module as the Bochs GUI00000000000i[      ] using log file bochsout.txtNext at t&#x3D;0(0) [0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0&lt;bochs:1&gt; b 0x7c00&lt;bochs:2&gt; c(0) Breakpoint 1, 0x0000000000007c00 in ?? ()Next at t&#x3D;14479647(0) [0x000000007c00] 0000:7c00 (unk. ctxt): mov ax, cs                ; 8cc8&lt;bochs:3&gt; info cpuCPU0:rax: 00000000_0000aa55rbx: 00000000_00000000rcx: 00000000_00090000rdx: 00000000_00000000rsp: 00000000_0000ffd6rbp: 00000000_00000000rsi: 00000000_000e0000rdi: 00000000_0000ffacr8 : 00000000_00000000r9 : 00000000_00000000r10: 00000000_00000000r11: 00000000_00000000r12: 00000000_00000000r13: 00000000_00000000r14: 00000000_00000000r15: 00000000_00000000rip: 00000000_00007c00eflags 0x00000082: id vip vif ac vm rf nt IOPL&#x3D;0 of df if tf SF zf af pf cfstatus  word: 0x0000: b c3 TOS0 c2 c1 c0 es sf pe ue oe ze de iecontrol word: 0x0040: inf RC_NEAREST PC_32 pm um om zm dm imtag word:     0x5555operand:      0x0000fip:          0x0000000000000000fcs:          0x0000fdp:          0x0000000000000000fds:          0x0000&#x3D;&gt;FP0 ST0(0):        raw 0x0000:0000000000000000 (0.0000000000) (ZERO)  FP1 ST1(0):        raw 0x0000:0000000000000000 (0.0000000000) (ZERO)  FP2 ST2(0):        raw 0x0000:0000000000000000 (0.0000000000) (ZERO)  FP3 ST3(0):        raw 0x0000:0000000000000000 (0.0000000000) (ZERO)  FP4 ST4(0):        raw 0x0000:0000000000000000 (0.0000000000) (ZERO)  FP5 ST5(0):        raw 0x0000:0000000000000000 (0.0000000000) (ZERO)  FP6 ST6(0):        raw 0x0000:0000000000000000 (0.0000000000) (ZERO)  FP7 ST7(0):        raw 0x0000:0000000000000000 (0.0000000000) (ZERO)MM[0]: 00000000_00000000MM[1]: 00000000_00000000MM[2]: 00000000_00000000MM[3]: 00000000_00000000MM[4]: 00000000_00000000MM[5]: 00000000_00000000MM[6]: 00000000_00000000MM[7]: 00000000_00000000The CPU doesn&#39;t support AVX state !&lt;bochs:4&gt; x &#x2F;64xb 0x7c00[bochs]:0x0000000000007c00 &lt;bogus+       0&gt;:0x8c0xc80x8e0xd80x8e0xc00xe80x020x0000000000007c08 &lt;bogus+       8&gt;:0x000xeb0xfe0xb80x1e0x7c0x890xc50x0000000000007c10 &lt;bogus+      16&gt;:0xb90x9f0x000xb80x010x130xbb0x0c0x0000000000007c18 &lt;bogus+      24&gt;:0x000xb20x000xcd0x100xc30x480x650x0000000000007c20 &lt;bogus+      32&gt;:0x6c0x6c0x6f0x210x540x680x690x730x0000000000007c28 &lt;bogus+      40&gt;:0x200x690x730x200x430x430x530x540x0000000000007c30 &lt;bogus+      48&gt;:0x440x430x5f0x4f0x530x200x530x700x0000000000007c38 &lt;bogus+      56&gt;:0x650x610x6b0x690x6e0x670x210x20&lt;bochs:5&gt; nNext at t&#x3D;14479648(0) [0x000000007c02] 0000:7c02 (unk. ctxt): mov ds, ax                ; 8ed8&lt;bochs:6&gt; trace-reg onRegister-Tracing enabled for CPU0&lt;bochs:7&gt; nNext at t&#x3D;14479649CPU0:rax: 00000000_00000000rbx: 00000000_00000000rcx: 00000000_00090000rdx: 00000000_00000000rsp: 00000000_0000ffd6rbp: 00000000_00000000rsi: 00000000_000e0000rdi: 00000000_0000ffacr8 : 00000000_00000000r9 : 00000000_00000000r10: 00000000_00000000r11: 00000000_00000000r12: 00000000_00000000r13: 00000000_00000000r14: 00000000_00000000r15: 00000000_00000000rip: 00000000_00007c04eflags 0x00000082: id vip vif ac vm rf nt IOPL&#x3D;0 of df if tf SF zf af pf cf(0) [0x000000007c04] 0000:7c04 (unk. ctxt): mov es, ax                ; 8ec0&lt;bochs:8&gt; c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;bochs:1&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这就是在提示我们要输入指令，我们的第一条指令就是</p><pre class="line-numbers language-none"><code class="language-none">&lt;bochs:1&gt; b 0x7c00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是在给程序打断点。一旦执行到这里（也就是执行点的地址）就停下来让我们查看。</p><p>​        其他的指令这里看一看：</p><div class="table-container"><table><thead><tr><th style="text-align:left">行为</th><th style="text-align:left">指令</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">在某物理地址设置断点</td><td style="text-align:left">b addr</td><td style="text-align:left">b 0x30400</td></tr><tr><td style="text-align:left">显示当前所有断点信息</td><td style="text-align:left">info break</td><td style="text-align:left">info break</td></tr><tr><td style="text-align:left">继续执行，直到遇上断点</td><td style="text-align:left">c</td><td style="text-align:left">c</td></tr><tr><td style="text-align:left">单步执行</td><td style="text-align:left">s</td><td style="text-align:left">s</td></tr><tr><td style="text-align:left">单步执行，遇到函数则跳过</td><td style="text-align:left">n</td><td style="text-align:left">n</td></tr><tr><td style="text-align:left">查看寄存器信息</td><td style="text-align:left">info cpu r fp sreg creg</td><td style="text-align:left">info cpu r fp sreg creg</td></tr><tr><td style="text-align:left">查看堆栈</td><td style="text-align:left">print-stack</td><td style="text-align:left">print-stack</td></tr><tr><td style="text-align:left">查看内存物理地址内容</td><td style="text-align:left">xp /nuf addr</td><td style="text-align:left">xp /40bx 0x9013e</td></tr><tr><td style="text-align:left">查看线性地址内容</td><td style="text-align:left">x /nuf addr</td><td style="text-align:left">x /40bx 0x13e</td></tr><tr><td style="text-align:left">反汇编一段内存</td><td style="text-align:left">u start end</td><td style="text-align:left">u 0x30400 0x3040D</td></tr><tr><td style="text-align:left">反汇编执行的每一条指令</td><td style="text-align:left">trace-on</td><td style="text-align:left">trace-on</td></tr><tr><td style="text-align:left">每执行一条指令就打印CPU信息</td><td style="text-align:left">trace-reg</td><td style="text-align:left">trace-reg on</td></tr></tbody></table></div><p>​        在查看寄存器信息中，r为通用寄存器，fp应该就是fp寄存器吧，sreg为段寄存器，creg为控制寄存器。</p><p>​        在xp和x命令中，nuf表示指定打印多少信息。</p><p>​        其实bochs调试跟gdb挺像的~</p><p><img src="image-20230713223742519.png" alt="image-20230713223742519"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> Projects Rrcorder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnCPP (English)</title>
      <link href="/2023/07/01/LearnCPP-English/"/>
      <url>/2023/07/01/LearnCPP-English/</url>
      
        <content type="html"><![CDATA[<h1 id="LearnCPP-guidance"><a href="#LearnCPP-guidance" class="headerlink" title="LearnCPP guidance"></a>LearnCPP guidance</h1><p>​        <code>This is a self read from Learncpp blog</code></p><p>​        <code>click here for reading the source blog:</code><a href="www.learncpp.com">learncpp.com</a></p><h2 id="Top-guide"><a href="#Top-guide" class="headerlink" title="Top guide"></a><code>Top guide</code></h2><p>​        <code>Modern computers are incredibly fast, and getting faster all the time. However, computers also have some significant constraints: they only natively understand a limited set of commands, and must be told exactly what to do. Yes, they are not intelligent as we considered actually.</code></p><p>​        <code>A computer program (also commonly called an application) is a set of instructions that the computer can perform in order to perform some task. The process of creating a program is called programming. Programmers typically create programs by producing source code (commonly shortened to code), which is a list of commands typed into one or more text files.</code></p><p>​        <code>The collection of physical computer parts that make up a computer and execute programs is called the hardware. When a computer program is loaded into memory and the hardware sequentially executes each instruction, this is called running or executing the program.</code></p><h2 id="Machine-Language"><a href="#Machine-Language" class="headerlink" title="Machine Language"></a><code>Machine Language</code></h2><p>​        <code>A computer’s CPU is incapable of speaking C++. The limited set of instructions that a CPU can understand directly is called machine code (or machine language or an instruction set).</code></p><p>​        <code>Here is a sample machine language instruction:</code> <code>10110000 01100001</code></p><p>​        <code>Back when computers were first invented, programmers had to write programs directly in machine language, which was a very difficult and time consuming thing to do.</code></p><p>​        <code>How these instructions are organized is beyond the scope of this introduction, but it is interesting to note two things.</code></p><p>​        <code>1. First, each instruction is composed of a sequence of 1s and 0s. Each individual 0 or 1 is called a binary digit, or bit for short. The number of bits that make up a single command vary -- for example, some CPUs process instructions that are always 32 bits long, whereas some other CPUs (such as the x86 family, which you are likely using) have instructions that can be a variable length.</code></p><p>​        <code>2. Second, each set of binary digits is interpreted(解析) by the CPU into a command to do a very specific job, such as *compare these two numbers*, or *put this number in that memory location*. However, because different CPUs have different instruction sets, instructions that were written for one CPU type could not be used on a CPU that didn’t share the same instruction set. This meant programs generally weren’t portable (usable without major rework) to different types of system, and had to be written all over again.</code></p><h2 id="Assembly-Language"><a href="#Assembly-Language" class="headerlink" title="Assembly Language"></a><code>Assembly Language</code></h2><p>​        <code>Because machine language is so hard for humans to read and understand, assembly language was invented. In an assembly language, each instruction is identified by a short abbreviation (rather than a set of bits), and names and other numbers can be used.</code></p><p>​        <code>Here is the same instruction as above in assembly language:</code> <code>mov al, 061h</code></p><p>​        <code>This makes assembly much easier to read and write than machine language. However, the CPU can not understand assembly language directly. Instead, the assembly program must be translated into machine language before it can be executed by the computer. This is done by using a program called an assembler. Programs written in assembly languages tend to be very fast, and assembly is still used today when speed is critical.</code></p><p>​        <code>However, assembly still has some downsides. First, assembly languages still require a lot of instructions to do even simple tasks. While the individual instructions themselves are somewhat human readable, understanding what an entire program is doing can be challenging (it’s a bit like trying to understand a sentence by looking at each letter individually). Second, assembly language still isn’t very portable -- a program written in assembly for one CPU will likely not work on hardware that uses a different instruction set, and would have to be rewritten or extensively modified.</code></p><h2 id="High-level-Languages"><a href="#High-level-Languages" class="headerlink" title="High-level Languages"></a><strong><code>High-level Languages</code></strong></h2><p>​        <code>To address the readability and portability concerns, new programming languages such as C, C++, Pascal (and later, languages such as Java, Javascript, and Perl) were developed. These languages are called high level languages, as they are designed to allow the programmer to write programs without having to be as concerned about what kind of computer the program will be run on.</code></p><p>​        <code>Here is the same instruction as above in C/C++:</code> <code>a = 97;</code></p><p>​        <code>Much like assembly programs, programs written in high level languages must be translated into a format the computer can understand before they can be run. There are two primary ways this is done: compiling and interpreting.</code></p><p>​        <code>A compiler is a program that reads source code and produces a stand-alone executable program that can then be run. Once your code has been turned into an executable, you do not need the compiler to run the program. In the beginning, compilers were primitive and produced slow, unoptimized code. However, over the years, compilers have become very good at producing fast, optimized code, and in some cases can do a better job than humans can in assembly language!</code></p><p>​        <code>Here is a simplified representation of the compiling process:</code></p><p><img src="ngcb2.webp" alt="Example of compiling"></p><p>​        <code>Since C++ programs are generally compiled, we’ll explore compilers in more detail shortly.</code></p><p>​        <code>An interpreter is a program that directly executes the instructions in the source code without requiring them to be compiled into an executable first. Interpreters tend to be more flexible than compilers, but are less efficient when running programs because the interpreting process needs to be done every time the program is run. This means the interpreter is needed every time the program is run.</code></p><p>​        <code>Here is a simplified representation of the interpretation process:</code><img src="ngcb2.webp" alt="Example of interpreting"></p><p>​        <code>Most languages can be compiled or interpreted, however, traditionally languages like C, C++, and Pascal are compiled, whereas “scripting” languages like Perl and Javascript tend to be interpreted. Some languages, like Java, use a mix of the two.</code></p><p>​        <code>High level languages have many desirable properties.</code></p><p>​        <code>First, high level languages are much easier to read and write because the commands are closer to natural language that we use every day.</code></p><p>​        <code>Second, high level languages require fewer instructions to perform the same task as lower level languages, making programs more concise and easier to understand. In C++ you can do something like</code> <code>a = b * 2 + 5;</code> <code>in one line. In assembly language, this would take 5 or 6 different instructions.</code></p><p>​        <code>Third, programs can be compiled (or interpreted) for many different systems, and you don’t have to change the program to run on different CPUs (you just recompile for that CPU). As an example:</code></p><p><img src="ngcb2-16881933943273.webp" alt="Example of portability"></p><p>​        <code>There are two general exceptions to portability.</code></p><p>​        <code>The first is that many operating systems, such as Microsoft Windows, contain platform-specific capabilities that you can use in your code. These can make it much easier to write a program for a specific operating system, but at the expense of portability. In these tutorials, we will avoid any platform specific code.</code></p><p>​        <code>The second is that some compilers also support compiler-specific extensions -- if you use these, your programs won’t be able to be compiled by other compilers that don’t support the same extensions without modification. We’ll talk more about these later, once you’ve installed a compiler.</code></p><h2 id="Rules-Best-practices-and-warnings"><a href="#Rules-Best-practices-and-warnings" class="headerlink" title="Rules, Best practices, and warnings"></a><code>Rules, Best practices, and warnings</code></h2><p>​        <code>As we proceed through these tutorials, we’ll highlight many important points under the following three categories:</code></p><h3 id="Rule"><a href="#Rule" class="headerlink" title="Rule"></a><code>Rule</code></h3><p>​        <code>Rules are instructions that you must do, as required by the language. Failure to abide by a rule will generally result in your program not working.</code></p><h3 id="Best-practice"><a href="#Best-practice" class="headerlink" title="Best practice"></a><code>Best practice</code></h3><p>​        <code>Best practices are things that you should do, because that way of doing things is generally considered a standard or highly recommended. That is, either everybody does it that way (and if you do otherwise, you’ll be doing something people don’t expect), or it is superior to the alternatives.</code></p><h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a><strong><code>Warning</code></strong></h3><p>​        <code>Warnings are things that you should not do, because they will generally lead to unexpected results.</code></p><h2 id="Basic-Introduction-in-C"><a href="#Basic-Introduction-in-C" class="headerlink" title="Basic Introduction in C"></a><code>Basic Introduction in C</code></h2><p>​        <code>The C language was developed in 1972 by Dennis Ritchie at Bell Telephone laboratories, primarily as a systems programming language (a language to write operating systems with). Ritchie’s primary goals were to produce a minimalistic language that was easy to compile, allowed efficient access to memory, produced efficient code, and was self-contained (not reliant on other programs). For a high-level language, it was designed to give the programmer a lot of control, while still encouraging platform (hardware and operating system) independence (that is, the code didn’t have to be rewritten for each platform).</code></p><p>​        <code>C ended up being so efficient and flexible that in 1973, Ritchie and Ken Thompson rewrote most of the Unix operating system using C. Many previous operating systems had been written in assembly. Unlike assembly, which produces programs that can only run on specific CPUs, C has excellent portability, allowing Unix to be easily recompiled on many different types of computers and speeding its adoption. C and Unix had their fortunes tied together, and C’s popularity was in part tied to the success of Unix as an operating system.</code></p><p>​        <code>In 1978, Brian Kernighan and Dennis Ritchie published a book called “The C Programming Language”. This book, which was commonly known as K&amp;R (after the authors’ last names), provided an informal specification for the language and became a de facto standard. When maximum portability was needed, programmers would stick to the recommendations in K&amp;R, because most compilers at the time were implemented to K&amp;R standards.</code></p><p>​        <code>In 1983, the American National Standards Institute (ANSI) formed a committee to establish a formal standard for C. In 1989 (committees take forever to do anything), they finished, and released the C89 standard, more commonly known as ANSI C. In 1990 the International Organization for Standardization (ISO) adopted ANSI C (with a few minor modifications). This version of C became known as C90. Compilers eventually became ANSI C/C90 compliant, and programs desiring maximum portability were coded to this standard.</code></p><p>​        <code>In 1999, the ISO committee released a new version of C called C99. C99 adopted many features which had already made their way into compilers as extensions, or had been implemented in C++.</code></p><h3 id="and-about-C"><a href="#and-about-C" class="headerlink" title="and about C++"></a><code>and about C++</code></h3><p>​        <code>C++ (pronounced see plus plus) was developed by Bjarne Stroustrup at Bell Labs as an extension to C, starting in 1979. C++ adds many new features to the C language, and is perhaps best thought of as a superset of C, though this is not strictly true (as C99 introduced a few features that do not exist in C++). C++’s claim to fame results primarily from the fact that it is an object-oriented language. As for what an “object” is and how it differs from traditional programming methods, well, we’ll cover that in later chapters.</code></p><p>​        <code>C++ was standardized in 1998 by the ISO committee (this means the ISO standards committee approved a document describing the C++ language, to help ensure all compilers adhere to the same set of standards). A minor update to the language was released in 2003 (called C++03).</code></p><p>​        <code>Four major updates to the C++ language (C++11, C++14, C++17, and C++20) have been made since then, each adding additional functionality. C++11 in particular added a huge number of new capabilities, and is widely considered to be the new baseline version of the language. Future upgrades to the language are expected every three or so years, with the feature set for C++23 already starting to be formulated.</code></p><p>​        <code>Each new formal release of the language is called a language standard (or language specification). Standards are named after the year they are released in. For example, there is no C++15, because there was no new standard in 2015.</code></p><h2 id="C-and-C-’s-philosophy"><a href="#C-and-C-’s-philosophy" class="headerlink" title="C and C++’s philosophy"></a><code>C and C++’s philosophy</code></h2><p>​        <code>The underlying design philosophy of C and C++ can be summed up as “trust the programmer” -- which is both wonderful and dangerous. C++ is designed to allow the programmer a high degree of freedom to do what they want. However, this also means the language often won’t stop you from doing things that don’t make sense, because it will assume you’re doing so for some reason it doesn’t understand. There are quite a few pitfalls that new programmers are likely to fall into if caught unaware. This is one of the primary reasons why knowing what you shouldn’t do in C/C++ is almost as important as knowing what you should do.</code></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a><code>Q&amp;A</code></h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a><code>1</code></h3><p><code>Q: What is C++ good at?</code></p><p><code>A: C++ excels in situations where high performance and precise control over memory and other resources is needed. Here are a few common types of applications that most likely would be written in C++:</code></p><ul><li><code>Video games</code></li><li><code>Real-time systems (e.g. for transportation, manufacturing, etc…)</code></li><li><p><code>High-performance financial applications (e.g. high frequency trading)</code></p></li><li><p><code>Graphical applications and simulations</code></p></li><li><code>Productivity / office applications</code></li><li><code>Embedded software</code></li><li><code>Audio and video processing</code></li><li><code>Artificial intelligence and neural networks</code></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2"></a><code>2</code></h3><p><strong><code>Q: Do I need to know C before I do these tutorials?</code></strong></p><p>​    <code>A:Nope! It’s perfectly fine to start with C++, and we’ll teach you everything you need to know (including pitfalls to avoid) along the way.</code></p><p>​    <code>Once you know C++, it should be pretty easy to learn standard C if you ever have the need. These days, C is mostly used for niche use cases: code that runs on embedded devices, when you need to interact with other languages that can only interface with C, etc… For most other cases, C++ is recommended.</code></p><h2 id="Introduction-to-C-development"><a href="#Introduction-to-C-development" class="headerlink" title="Introduction to C++ development"></a><code>Introduction to C++ development</code></h2><p>​        <code>Before we can write and execute our first C++ program, we need to understand in more detail how C++ programs get developed. Here is a graphic outlining a simplistic approach:</code></p><p><img src="Development-min.webp" alt="The software development process"></p><h3 id="Step-1-Define-the-problem-that-you-would-like-to-solve"><a href="#Step-1-Define-the-problem-that-you-would-like-to-solve" class="headerlink" title="Step 1: Define the problem that you would like to solve"></a><code>Step 1: Define the problem that you would like to solve</code></h3><p>​        <code>This is the “what” step, where you figure out what problem you are intending to solve. Coming up with the initial idea for what you would like to program can be the easiest step, or the hardest. But conceptually, it is the simplest. All you need is an idea that can be well defined, and you’re ready for the next step.</code></p><p><code>Here are a few examples:</code></p><ul><li><code>“I want to write a program that will allow me to enter many numbers, then calculates the average.”</code></li><li><code>“I want to write a program that generates a 2d maze and lets the user navigate through it. The user wins if they reach the end.”</code></li><li><code>“I want to write a program that reads in a file of stock prices and predicts whether the stock will go up or down.”</code></li></ul><h3 id="Step-2-Determine-how-you-are-going-to-solve-the-problem"><a href="#Step-2-Determine-how-you-are-going-to-solve-the-problem" class="headerlink" title="Step 2: Determine how you are going to solve the problem"></a><strong><code>Step 2: Determine how you are going to solve the problem</code></strong></h3><p>​        <code>This is the “how” step, where you determine how you are going to solve the problem you came up with in step 1. It is also the step that is most neglected in software development. The crux(关键) of the issue is that there are many ways to solve a problem -- however, some of these solutions are good and some of them are bad. Too often, a programmer will get an idea, sit down, and immediately start coding a solution. This often generates a solution that falls into the bad category.</code></p><p>​        <code>Typically, good solutions have the following characteristics:</code></p><ul><li><code>They are straightforward (not overly complicated or confusing).</code></li><li><code>They are well documented (especially around any assumptions being made or limitations).</code></li><li><code>They are built modularly(模块化), so parts can be reused or changed later without impacting other parts of the program.</code></li><li><code>They are robust(强大的), and can recover or give useful error messages when something unexpected happens.</code></li></ul><p>​        <code>When you sit down and start coding right away, you’re typically thinking “I want to do &lt;something&gt;”, so you implement the solution that gets you there the fastest. This can lead to programs that are fragile, hard to change or extend later, or have lots of bugs (technical defects).</code></p><p>​        <code>Studies have shown that only 20% of a programmer’s time is actually spent writing the initial program. The other 80% is spent on maintenance, which can consist of debugging (removing bugs), updates to cope with changes in the environment (e.g. to run on a new OS version), enhancements (minor changes to improve usability or capability), or internal improvements (to increase reliability or maintainability).</code></p><p>​        <code>Consequently, it’s worth your time to spend a little extra time up front (before you start coding) thinking about the best way to tackle a problem, what assumptions you are making, and how you might plan for the future, in order to save yourself a lot of time and trouble down the road.</code></p><p>​        <code>We’ll talk more about how to effectively design solutions to problems in a future lesson.</code></p><h3 id="Step-3-Write-the-program"><a href="#Step-3-Write-the-program" class="headerlink" title="Step 3: Write the program"></a><strong><code>Step 3: Write the program</code></strong></h3><p>​        <code>In order to write the program, we need two things: First, we need knowledge of a programming language -- that’s what these tutorials are for! Second, we need a text editor to write and save our written programs. The programs we write using C++ instructions are called source code (often shortened to just code). It’s possible to write a program using any text editor you want, even something as simple as Windows’ notepad or Unix’s vi or pico. However, we strongly urge you to use an editor that is designed for programming (called a code editor). Don’t worry if you don’t have one yet. We’ll cover how to install a code editor shortly.</code></p><p>​        <code>A typical editor designed for coding has a few features that make programming much easier, including:</code></p><ol><li><code>Line numbering. Line numbering is useful when the compiler gives us an error, as a typical compiler error will state: *some error code/message, line 64*. Without an editor that shows line numbers, finding line 64 can be a real hassle.</code></li><li><code>Syntax highlighting and coloring. Syntax highlighting and coloring changes the color of various parts of your program to make it easier to identify the different components of your program. Here’s an example of a C++ program with both line numbering and syntax highlighting:</code></li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;int main()&#123;    std::cout &lt;&lt; &quot;Colored text!&quot;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>The examples we show in this tutorial will always have both line numbering and syntax highlighting to make them easier to follow.</code></p><ol><li><p>​        <code>An unambiguous font. Non-programming fonts often make it hard to distinguish between the number 0 and the letter O, or between the number 1, the letter l (lower case L), and the letter I (upper case i). A good programming font will ensure these symbols are visually differentiated in order to ensure one isn’t accidentally used in place of the other. All code editors should have this enabled by default, but a standard text editor might not.</code></p><p><code>From Editor here: In Visual Studio, I highly recommand the Consola, which is just the font I used to present the text here</code></p></li></ol><p>​        <code>The programs you write will typically be named something.cpp, where something is replaced with the name of your choosing for the program (e.g. calculator, hi-lo, etc…). The .cpp extension tells the compiler (and you) that this is a C++ source code file that contains C++ instructions. Note that some people use the extension .cc instead of .cpp, but we recommend you use .cpp.</code></p><h3 id="Best-practice-1"><a href="#Best-practice-1" class="headerlink" title="Best practice"></a>Best practice</h3><p>​        <code>Name your code files something.cpp, where something is a name of your choosing, and .cpp is the extension that indicates the file is a C++ source file.</code></p><p>​        <code>Also note that many complex C++ programs have multiple .cpp files. Although most of the programs you will be creating initially will only have a single .cpp file, it is possible to write single programs that have tens or hundreds of .cpp files.</code></p><p>​        <code>Once we’ve written our program, the next steps are to convert the source code into something that we can run, and then see whether it works! We’ll discuss those steps (4-7) in the next lesson.</code></p><h2 id="Introduction-to-the-compiler-linker-and-libraries"><a href="#Introduction-to-the-compiler-linker-and-libraries" class="headerlink" title="Introduction to the compiler, linker, and libraries"></a>Introduction to the compiler, linker, and libraries</h2><p><img src="Development-min.webp" alt="The software development process"></p><p>​        <code>Back to this map. Currently we will focus on the steps 4 - 7!</code></p><h3 id="Step-4-Compiling-your-source-code"><a href="#Step-4-Compiling-your-source-code" class="headerlink" title="Step 4: Compiling your source code"></a><code>Step 4: Compiling your source code</code></h3><p>​        <code>In order to compile a C++ program, we use a C++ compiler. The C++ compiler sequentially goes through each source code (.cpp) file in your program and does two important tasks:</code></p><p>​        <code>First, it checks your code to make sure it follows the rules of the C++ language. If it does not, the compiler will give you an error (and the corresponding line number) to help pinpoint what needs fixing. The compilation process will also be aborted until the error is fixed.</code></p><p>​        <code>Second, it translates your C++ source code into a machine language file called an object file. Object files are typically named *name.o* or *name.obj*, where *name* is the same name as the.cpp file it was produced from.</code></p><p>​        <code>If your program had 3 .cpp files, the compiler would generate 3 object files:</code></p><p><img src="ngcb2-168819467648010.webp" alt="The compilation process"></p><p>​        <code>C++ compilers are available for many different operating systems. We will discuss installing a compiler shortly, so there is no need to do so now.</code></p><h3 id="Step-5-Linking-object-files-and-libraries"><a href="#Step-5-Linking-object-files-and-libraries" class="headerlink" title="Step 5: Linking object files and libraries"></a><code>Step 5: Linking object files and libraries</code></h3><p>​        <code>After the compiler creates one or more object files, then another program called the linker** kicks in. The job of the linker is three fold:</code></p><p>​        <code>First, to take all the object files generated by the compiler and combine them into a single executable program.</code></p><p><img src="ngcb2-168819479437013.webp" alt="The linking process"></p><p>​        <code>The C++ core language is actually fairly small and concise (and you’ll learn much of it in these tutorials). However, C++ also comes with an extensive library called the C++ Standard Library (usually shortened to standard library) that provides additional functionality that you can use in your programs. One of the most commonly used parts of the C++ standard library is the *iostream library*, which contains functionality for printing text on a monitor and getting keyboard input from a user. Almost every C++ program written utilizes the standard library in some form, so it’s very common for the standard library to get linked into your programs. Most linkers will automatically link in the standard library as soon as you use any part of it, so this generally isn’t something you need to worry about.</code></p><p>​        <code>You can also optionally link in other libraries. For example, if you were going to write a program that played sounds, you probably would not want to write your own code to read in the sound files from disk, check to ensure they were valid, or figure out how to route the sound data to the operating system or hardware to play through the speaker -- that would be a lot of work! Instead, you’d probably download a library that already knew how to do those things, and use that. We’ll talk about how to link in libraries (and create your own!) in the appendix.</code></p><p>​        <code>Third, the linker makes sure all cross-file dependencies are resolved properly. For example, if you define something in one .cpp file, and then use it in another .cpp file, the linker connects the two together. If the linker is unable to connect a reference to something with its definition, you’ll get a linker error, and the linking process will abort.</code></p><p>​        <code>Once the linker is finished linking all the object files and libraries (assuming all goes well), you will have an executable file that you can then run!</code></p><h4 id="For-advanced-readers"><a href="#For-advanced-readers" class="headerlink" title="For advanced readers"></a><code>For advanced readers</code></h4><p>​        <code>For complex projects, some development environments use a makefile, which is a file that describes how to build a program (e.g. which files to compile and link, or otherwise process in various ways). Entire books have been written about how to write and maintain makefiles, and they can be an incredibly powerful tool. However, because makefiles are not part of the C++ core language, nor do you need to use them to proceed, we’ll not discuss them as part of this tutorial series.</code></p><h3 id="Steps-6-amp-7-Testing-and-Debugging"><a href="#Steps-6-amp-7-Testing-and-Debugging" class="headerlink" title="Steps 6 &amp; 7: Testing and Debugging"></a><strong><code>Steps 6 &amp; 7: Testing and Debugging</code></strong></h3><p>​        <code>This is the fun part (hopefully)! You are able to run your executable and see whether it produces the output you were expecting!</code></p><p>​        <code>If your program runs but doesn’t work correctly, then it’s time for some debugging to figure out what’s wrong. We will discuss how to test your programs and how to debug them in more detail soon.</code></p><h3 id="Integrated-development-environments-IDEs"><a href="#Integrated-development-environments-IDEs" class="headerlink" title="Integrated development environments (IDEs)"></a><code>Integrated development environments (IDEs)</code></h3><p>​        <code>Note that steps 3, 4, 5, and 7 all involve software (editor, compiler, linker, debugger). While you can use separate programs for each of these activities, a software package known as an integrated development environment (IDE) bundles and integrates all of these features together. We’ll discuss IDEs, and install one, in the next section.</code></p><h2 id="Installing-an-Integrated-Development-Environment-IDE"><a href="#Installing-an-Integrated-Development-Environment-IDE" class="headerlink" title="Installing an Integrated Development Environment (IDE)"></a><code>Installing an Integrated Development Environment (IDE)</code></h2><p>​        <code>An Integrated Development Environment (IDE) is a piece of software that contains all of the things you need to develop, compile, link, and debug your programs.</code></p><p>​        <code>With a typical C++ IDE, you get a code editor that does line numbering and syntax highlighting. Many (but not all) IDEs include a C++ compiler and a linker, which the IDE will know how to interface with in order to convert your source code into an executable file. And when you need to debug your program, you can use the integrated debugger.</code></p><p>​        <code>Furthermore, IDEs typically bundle a number of other helpful editing features, such as integrated help, name completion, auto-formatting, and sometimes a version control system. So while you could do all of these things separately, it’s much easier to install an IDE and have them all accessible from a single interface.</code></p><p>​        <code>So let’s install one! The obvious next question is, “which one?”. Many IDEs are free (in price), and you can install multiple IDEs if you wish, so there’s no “wrong decision” to be made here. We’ll recommend a few of our favorites below.</code></p><p>​        <code>If you have some other IDE in mind, that’s fine too. The concepts we show you in these tutorials should generally work for any decent modern IDE. However, various IDEs use different names, layouts, key mappings, etc… so you may have to do a bit of searching in your IDE to find the equivalent functionality.</code></p><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a><code>Tip</code></h3><p>​        <code>To get the most value of this tutorial, we recommend installing an IDE that comes with a C++17 capable compiler.</code></p><p>​        <code>If you’re restricted to using a compiler that only supports C++14 or C++11 (due to educational or business constraints), most of the lessons and examples will still work. However, if you encounter a lesson that uses concepts from C++17 (or newer) and you’re using an older language compiler, you’ll have to skip it or translate it to your version, which may or may not be easy.</code></p><p>​        <code>You should not be using any compiler that does not support at least C++11 (which is typically considered the modern minimum spec for C++).</code></p><p>​        <code>We recommend installing the newest version of a compiler. If you can’t use the newest version, these are the absolute minimum compiler versions with C++17 support:</code></p><ul><li><code>GCC/G++ 7</code></li><li><code>Clang++ 8</code></li><li><code>Visual Studio 2017 15.7</code></li></ul><h3 id="Visual-Studio-for-Windows"><a href="#Visual-Studio-for-Windows" class="headerlink" title="Visual Studio (for Windows)"></a><code>Visual Studio (for Windows)</code></h3><p>​        <code>If you are developing on a Windows 10 machine, then we strongly recommend downloading Visual Studio 2022 Community.</code></p><p>​        <code>Once you run the installer, you’ll eventually come to a screen that asks you what workload you’d like to install. Choose Desktop development with C++. If you do not do this, then C++ capabilities will not be available.</code></p><p>​        <code>The default options selected on the right side of the screen should be fine, but please ensure that the Windows 10 SDK is selected.</code></p><h3 id="Code-Blocks-for-Linux-or-Windows"><a href="#Code-Blocks-for-Linux-or-Windows" class="headerlink" title="Code::Blocks (for Linux or Windows)"></a><strong><code>Code::Blocks (for Linux or Windows)</code></strong></h3><p>​        <code>if you are developing on Linux (or you are developing on Windows but want to write programs that you can easily port to Linux), we recommend Code::Blocks. Code::Blocks is a free, open source, cross-platform IDE that will run on both Linux and Windows.</code></p><h4 id="For-Windows-users"><a href="#For-Windows-users" class="headerlink" title="For Windows users"></a>For Windows users</h4><p>​        <code>Make sure to get the version of Code::Blocks that has MinGW bundled (it should be the one whose filename ends in mingw-setup.exe). This will install MinGW, which includes a Windows port of the GCC C++ compiler:</code></p><p><img src="ngcb2-168819520026616.webp" alt="Code::Blocks MinGW Windows download"></p><p>​        <code>Code::Blocks 20.03 ships with an outdated version of MinGW that only supports C++17 (currently one version back from the latest version of C++). If you want to use the latest version of C++ (C++20), you will need to update MinGW. To do so, follow this procedure:</code></p><ol><li><code>Install Code::Blocks as per the above.</code></li><li><code>Close Code::Blocks if it is open.</code></li><li><code>Open Windows File Explorer (Keyboard shortcut Win-E).</code></li><li><code>Navigate to your Code::Blocks install directory (probably C:\Program Files (x86)\CodeBlocks).</code></li><li><code>Rename the “MinGW” directory to “MinGW.bak” (in case something goes wrong).</code></li><li><code>Open a browser and navigate to https://winlibs.com/.</code></li><li><code>Download an updated version of MinGW. You probably want the one under Release Versions -&gt; UCRT Runtime -&gt; LATEST -&gt; Win64 -&gt; without LLVM/Clang/LLD/LLDB -&gt; Zip archive.</code></li><li><code>Extract the “mingw64” folder to your Code::blocks install directory.</code></li><li><code>Rename “mingw64” to “MinGW”.</code></li></ol><p><code>Once you have confirmed the updated compiler works, you can delete the old folder (“MinGW.bak”).</code></p><h4 id="For-Linux-users"><a href="#For-Linux-users" class="headerlink" title="For Linux users"></a>For Linux users</h4><p>​        <code>Some Linux installations may be missing dependencies needed to run or compile programs with Code::Blocks.</code></p><p>​        <code>Debian-based Linux users (such as those on Mint or Ubuntu) may need to install the *build-essential* package. To do so from the terminal command line, type: sudo apt-get install build-essential.</code></p><p>​        <code>Arch Linux users may need to install the base-devel package.</code></p><p>​        <code>Users on other Linux variants will need to determine what their equivalent package manager and packages are.</code></p><p>​        <code>When you launch Code::Blocks for the first time, you may get a Compilers auto-detection* dialog. If you do, make sure *GNU GCC Compiler is set as the default compiler and then select the OK button.</code></p><p><img src="ngcb2-168819531557219.webp" alt="Compilers Auto Detection dialog"></p><h3 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p>​        <code>Q: What do I do if I get a &quot;Can’t find compiler executable in your configured search paths for GNU GCC Compiler&quot; error?</code></p><p>​        <code>A: Try the following:</code></p><ol><li><code>If you’re on Windows, make sure you’ve downloaded the version of Code::Blocks WITH MinGW. It’s the one with “mingw” in the name.</code></li><li><code>Try going to settings, compiler, and choose “reset to defaults”.</code></li><li><code>Try going to settings, compiler, toolchain executables tab, and make sure “Compiler’s installation directory” is set to the MinGW directory (e.g. C:\Program Files (x86)\CodeBlocks\MinGW).</code></li><li><code>Try doing a full uninstall, then reinstall.</code></li><li><code>Try a different compiler.</code></li></ol><h3 id="Visual-Studio-Code-for-experienced-Linux-macOS-or-Windows-users"><a href="#Visual-Studio-Code-for-experienced-Linux-macOS-or-Windows-users" class="headerlink" title="Visual Studio Code (for experienced Linux, macOS, or Windows users)"></a><code>Visual Studio Code (for experienced Linux, macOS, or Windows users)</code></h3><p>​        <code>Visual Studio Code (also called “VS Code”, not to be confused with the similarly named “Visual Studio Community”) is code editor that is a popular choice with experienced developers because it is fast, flexible, open source, works for multiple programming languages, and is available for many different platforms.</code></p><p>​        <code>The downside is that VS Code is much harder to configure correctly than other choices on this list (and on Windows, harder to install as well). Before proceeding, we recommend reading through the installation and configuration documents linked below to ensure you understand and are comfortable with the steps involved.</code></p><h4 id="Author’s-note"><a href="#Author’s-note" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>Readers have reported many different challenges getting Visual Studio Code installed and configured correctly for C++. We do not recommend this option unless you are already familiar with Visual Studio Code, or have experience debugging issues and modifying configuration .json files. We cannot provide installation or configuration support on this site.</code></p><p>​        <code>Also, a tip o’ the hat to user glibg10b for providing an initial draft of these instructions across multiple articles.</code></p><h4 id="For-Linux-users-1"><a href="#For-Linux-users-1" class="headerlink" title="For Linux users"></a><strong><code>For Linux users</code></strong></h4><p>​        <code>VS Code should be downloaded using your distribution’s package manager. The</code> <a href="https://code.visualstudio.com/docs/setup/linux">VS Code instructions for linux</a> <code>cover how to do this for various Linux distributions.</code></p><p><code>Once VS Code is installed, follow the</code> <a href="https://code.visualstudio.com/docs/cpp/config-linux">instructions on how to configure C++ for linux</a>.</p><h4 id="For-Mac-users"><a href="#For-Mac-users" class="headerlink" title="For Mac users"></a><strong><code>For Mac users</code></strong></h4><p>​        <code>The</code> <a href="https://code.visualstudio.com/docs/setup/mac">VS Code instructions for Mac</a> <code>detail how to install and setup VS Code for macOS.</code></p><p>​        <code>Once VS Code is installed, follow the</code> <a href="https://code.visualstudio.com/docs/cpp/config-clang-mac">instructions on how to configure C++ for Mac</a>.</p><h4 id="For-Windows-users-1"><a href="#For-Windows-users-1" class="headerlink" title="For Windows users"></a><strong><code>For Windows users</code></strong></h4><p>​        <code>The</code> <a href="https://code.visualstudio.com/docs/setup/windows">VS Code instructions for Windows</a> <code>detail how to install and setup VS Code for Windows.</code></p><p>​        <code>Once VS Code is installed, follow the</code> <a href="https://code.visualstudio.com/docs/cpp/config-mingw">instructions on how to configure C++ for Windows</a>.</p><h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p>​        <strong><code>Q: Can I use a web-based compiler?</code></strong></p><p>​        <code>Yes, for some things. While your IDE is downloading (or if you’re not sure you want to commit to installing one yet), you can continue this tutorial using a web-based compiler. We recommend one of the following:</code></p><ul><li><a href="https://www.tutorialspoint.com/compile_cpp_online.php">TutorialsPoint</a></li><li><a href="https://wandbox.org/">Wandbox</a> (can choose different versions of GCC or Clang)</li><li><a href="https://godbolt.org/">Godbolt</a> (can see assembly)</li></ul><p>​        <code>Web-based compilers are fine for dabbling and simple exercises. However, they are generally quite limited in functionality -- many won’t allow you to create multiple files or effectively debug your programs. You’ll want to migrate to a full IDE when you can.</code></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><code>Q: Can I use a command-line compiler (e.g. g++ on Linux)?</code></p><p>​        <code>Yes, but we don’t recommend it for beginners. You’ll need to find your own editor and look up how to use it elsewhere. Using a command line debugger is not as easy as an integrated debugger, and will make debugging your programs more difficult.</code></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>​        <code>Q: Can I use other code editors or IDEs, such as Eclipse, Sublime, or Notepad++?</code></p><p>​        <code>Yes, but we don’t recommend it for beginners. There are many great code editors and IDEs that can be configured to support a wide variety of languages, and allow you to mix and match plugins to customize your experience however you like. However, many of these editors and IDEs require additional configuration to compile C++ programs, and there’s a lot that can go wrong during that process. For beginners, we recommend something that works out of the box, so you can spend more time learning to code and less time trying to figure out why your code editor isn’t working properly with your compiler or debugger.</code></p><h3 id="When-things-go-wrong-a-k-a-when-IDE-stands-for-“I-don’t-even…”"><a href="#When-things-go-wrong-a-k-a-when-IDE-stands-for-“I-don’t-even…”" class="headerlink" title="When things go wrong (a.k.a. when IDE stands for “I don’t even…”)"></a><code>When things go wrong (a.k.a. when IDE stands for “I don’t even…”)</code></h3><p>​        <code>IDE installations seem to cause their fair share of problems. Installation might fail outright (or installation might work but the IDE will have problems when you try to use it due to a configuration issue). If you encounter such issues, try uninstalling the IDE (if it installed in the first place), reboot your machine, disable your antivirus or anti-malware temporarily, and try the installation again.</code></p><p>​        <code>If you’re still encountering issues at this point, you have two options. The easier option is to try a different IDE. The other option is to fix the problem. Unfortunately, the causes of installation and configuration errors are varied and specific to the IDE software itself, and we’re unable to effectively advise on how to resolve such issues. In this case, we recommend copying the error message or problem you are having into your favorite search engine (such as Google or Duck Duck Go) and trying to find a forum post elsewhere from some poor soul who has inevitably encountered the same issue. Often there will be suggestions on things you can try to remedy the issue.</code></p><h2 id="Compile-our-first-program"><a href="#Compile-our-first-program" class="headerlink" title="Compile our first program!"></a><code>Compile our first program!</code></h2><p>​        <code>Before we can write our first program, we need to learn how to create new programs within our Integrated Development Environment (IDE). In this lesson, we’ll cover how to do that, and you’ll also compile and execute your first program!</code></p><h3 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a><code>Projects</code></h3><p>​        <code>To write a C++ program inside an IDE, we typically start by creating a new project (we’ll show you how to do this in a bit). A project is a container that holds all of your source code files, images, data files, etc… that are needed to produce an executable (or library, website, etc…) that you can run or use. The project also saves various IDE, compiler, and linker settings, as well as remembering where you left off, so that when you reopen the project later, the state of the IDE can be restored to wherever you left off. When you choose to compile your program, all of the .cpp files in the project will get compiled and linked.</code></p><p>​        <code>Each project corresponds to one program. When you’re ready to create a second program, you’ll either need to create a new project, or overwrite the code in an existing project (if you don’t want to keep it). Project files are generally IDE specific, so a project created for one IDE will need to be recreated in a different IDE.</code></p><h4 id="Best-practice-2"><a href="#Best-practice-2" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p><code>Create a new project for each new program you write.</code></p><h3 id="Console-projects"><a href="#Console-projects" class="headerlink" title="Console projects"></a><code>Console projects</code></h3><p>​        <code>When you create a new project, you’ll generally be asked what type of project you want to create. All of the projects that we will create in this tutorial will be console projects. A console project means that we are going to create programs that can be run from the Windows, Linux, or Mac console.</code></p><p>​        <code>Here’s a screenshot of the Windows console:</code><img src="WindowsCommandLine-min.webp" alt="Windows console"></p><p>​        <code>By default, console applications have no graphical user interface (GUI), they print text to the console, read input from the keyboard, and are compiled into stand-alone executable files. This is perfect for learning C++, because it keeps the complexity to a minimum, and ensures things work on a wide variety of systems.</code></p><p>​        <code>Don’t worry if you’ve never used a console before, or don’t know how to access it. We’ll compile and launch our programs through our IDEs (which will invoke the console when necessary).</code></p><h3 id="Workspaces-solutions"><a href="#Workspaces-solutions" class="headerlink" title="Workspaces / solutions"></a><code>Workspaces / solutions</code></h3><p>​        <code>When you create a new project for your program, many IDEs will automatically add your project to a “workspace” or a “solution” (the term varies by IDE). A workspace or solution is a container that can hold one or more related projects. For example, if you were writing a game and wanted to have a separate executable for single player and multiplayer, you’d need to create two projects. It wouldn’t make sense for both of these projects to be completely independent -- after all, they are part of the same game. Most likely, each would be configured as a separate project within a single workspace/solution.</code></p><p>​        <code>Although you can add multiple projects to a single solution, we generally recommend creating a new workspace or solution for each program, especially while learning. It’s simpler and there’s less chance of something going wrong.</code></p><h3 id="Writing-your-first-program"><a href="#Writing-your-first-program" class="headerlink" title="Writing your first program"></a><code>Writing your first program</code></h3><p>​        <code>Traditionally, the first program programmers write in a new language is the infamous [hello world program](https://en.wikipedia.org/wiki/Hello_world), and we aren’t going to deprive you of that experience! You’ll thank us later. Maybe.</code></p><h3 id="Creating-a-project-in-Visual-Studio-2019-or-newer"><a href="#Creating-a-project-in-Visual-Studio-2019-or-newer" class="headerlink" title="Creating a project in Visual Studio 2019 (or newer)"></a><code>Creating a project in Visual Studio 2019 (or newer)</code></h3><p>​        <code>When you run Visual Studio 2019 (or newer), you should see a dialog that looks like this:</code></p><p><img src="ngcb2-168819579248124.webp" alt="Visual Studio 2019 Get Started dialog"></p><p>​        <code>Select *Create a new project*.</code></p><p>​        <code>You’ll then see a dialog that looks like this:</code></p><p><img src="ngcb2-168819580463727.webp" alt="Visual Studio 2019 Create New Project dialog"></p><p>​        <code>If you’ve already opened a prior project, you can access this dialog via the *File menu &gt; New &gt; Project*.</code></p><p>​        <code>Select *Windows Desktop Wizard* and click *Next*. If you don’t see this, then you probably forgot to choose to install the *Desktop development with C++* workload when you installed Visual Studio.</code></p><p>​        <code>Next, you’ll see a dialog that looks like this:</code></p><p><img src="ngcb2-168819580463728.webp" alt="Visual Studio 2019 Configure New Project dialog"></p><p>​        <code>Replace the existing project name with HelloWorld</code>.</p><p>​        <code>It’s recommended that you also check the *Place solution and project in the same directory*, as this reduces the number of subdirectories that get created with each project.</code></p><p>​        <code>Click *Create* to continue.</code></p><p>​        <code>Finally, you’ll see one last dialog:</code></p><p><img src="ngcb2-168819588936339.webp" alt="Visual Studio 2019 Project options dialog"></p><p>​        <code>Make sure the *Application type* is set as *Console Application (.exe)* and that the *Precompiled Header* option is unselected. Then click *OK*.</code></p><p>​        <code>You’ve now created a project! Jump down to the</code> <a href="https://www.learncpp.com/cpp-tutorial/compiling-your-first-program/#visual_studio_solution_explorer">Visual Studio Solution Explorer</a> <code>section below to continue.</code></p><h3 id="Q-amp-A-2"><a href="#Q-amp-A-2" class="headerlink" title="Q &amp; A"></a><code>Q &amp; A</code></h3><p>​        <code>Q: What are precompiled headers and why are we turning them off?</code></p><p>​        <code>In large projects (those with many code files), precompiled headers can improve compilation speed by avoiding some redundant compilation that tends to occur in larger projects.</code></p><p>​        <code>However, precompiled headers require extra work to use, and for small projects (such as those you’ll create in our tutorials) make little to no difference in compilation times.</code></p><p>​        <code>For this reason, we recommend turning precompiled headers off initially, and only enabling them later if and when you find your compilation times suffering.</code></p><h3 id="Creating-a-project-in-Visual-Studio-2017-or-older"><a href="#Creating-a-project-in-Visual-Studio-2017-or-older" class="headerlink" title="Creating a project in Visual Studio 2017 or older"></a><code>Creating a project in Visual Studio 2017 or older</code></h3><p>​        <code>To create a new project in Visual Studio 2017 or older, go to the *File menu &gt; New &gt; Project*. A dialog box will pop up that looks something like this:</code></p><p><img src="ngcb2-168819594447148.webp" alt="Visual Studio 2017 New Project dialog"></p><p>​        <code>First, make sure *Visual C++* is listed on the left side. If you don’t see *Visual C++*, then you probably forgot to choose to install the *Desktop development with C++* workload when you installed Visual Studio.</code></p><p>​        <code>If you’re using Visual Studio 2017 v15.3 or newer, underneath *Visual C++*, select *Windows Desktop* and then select *Windows Desktop Wizard* in the main window.</code></p><p>​        <code>If you don’t see *Windows Desktop* as an option, you’re probably using an older version of Visual Studio. That’s fine. Instead, choose *Win32* and then *Win32 Console Application* in the main window.</code></p><p>​        <code>Down below, in the *Name* field, enter the name of your program (replace the existing name with</code>HelloWorld<code>). In the Location field, you can optionally select a different location for your project to be placed into. The default is fine for now.</code></p><p>​        <code>Click *OK*. If you’re using an older version of Visual Studio, the Win32 Application Wizard will launch. Press *Next*.</code></p><p>​        <code>At this point, you should see a wizard dialog that looks something like this (older versions of Visual Studio use a different style, but have most of the same options):</code></p><p><img src="ngcb2-168819594447149.webp" alt="Visual Studio 2017 Desktop wizard"></p><p>​        <code>Make sure you uncheck *Precompiled Header*.</code></p><p>​        <code>Then click *Ok* or *Finish*. Now your project is created!</code></p><h3 id="Visual-Studio-Solution-Explorer"><a href="#Visual-Studio-Solution-Explorer" class="headerlink" title="Visual Studio Solution Explorer"></a>Visual Studio Solution Explorer</h3><p>​        <code>On the left or right side of the window, you should see a window titled *Solution Explorer*. Inside this window, Visual Studio has created a solution for you (*Solution ‘HelloWorld’*). Within that, with the name in bold, is your new project (*HelloWorld*). Within the project, Visual Studio has created a number of files for you, including *HelloWorld.cpp* (underneath the *Source Files* tree item). You may also see some other .cpp or .h files, which you can ignore for now.</code></p><p><img src="ngcb2-168819594447150.webp" alt="Visual Studio 2019 initial windows"></p><p>​        <code>In the text editor, you will see that Visual Studio has already opened *HelloWorld.cpp* and created some code for you. Select and delete all of the code, and type/copy the following into your IDE:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>To compile your program, either press *F7* (if this doesn’t work, try *Ctrl-Shift-B*) or go to the *Build menu &gt; Build Solution*. If all goes well, you should see the following appear in the Output window:</code></p><pre class="line-numbers language-none"><code class="language-none">1&gt;------ Build started: Project: HelloWorld, Configuration: Debug Win32 ------1&gt;HelloWorld.cpp1&gt;HelloWorld.vcxproj -&gt; c:\users\alex\documents\visual studio 2017\Projects\HelloWorld\Debug\HelloWorld.exe&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This means your compile was successful!</code></p><h3 id="Q-amp-A-3"><a href="#Q-amp-A-3" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p>​        <code>Q: I got error C1010 (&quot;fatal error C1010: unexpected end of file while looking for precompiled header. Did you forget to add ‘#include &quot;stdafx.h&quot;’ to your source?&quot;). What now?</code></p><p>​        <code>You forgot to turn off precompiled headers when you created your project. Recreate your project and make sure to disable precompiled headers.</code></p><p>​        <code>To run your compiled program, press *Ctrl-F5*, or go to the *Debug menu* and choose *Start Without Debugging*. You will see the following:</code></p><p><img src="ngcb2-168819594447251.webp" alt="Program run"></p><p>​        <code>That is the result of your program! Congratulations, you’ve compiled and run your first program!</code></p><h3 id="Related-content"><a href="#Related-content" class="headerlink" title="Related content"></a><code>Related content</code></h3><p>​        <code>When you run a program directly from Visual Studio, you may see an additional line of output that looks something like this:</code></p><pre class="line-numbers language-none"><code class="language-none">C:\Users\Alex\source\repos\Project6\Debug\Project6.exe (process 21896) exited with code 0.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>This is normal. Visual Studio is providing some additional information about whether your program exited normally or abnormally.</code></p><h3 id="Creating-a-project-in-Code-Blocks"><a href="#Creating-a-project-in-Code-Blocks" class="headerlink" title="Creating a project in Code::Blocks"></a>Creating a project in Code::Blocks</h3><p>​        <code>To create a new project, go to *File menu &gt; New &gt; Project*. A dialog box will pop up that looks like this:</code></p><p><img src="ngcb2-168819594447252.webp" alt="Code::Blocks Project Dialog"></p><p>​        <code>Select *Console application* and press the *Go (or Create)* button.</code></p><p>​        <code>If you see a console application wizard dialog, press *Next*, make sure C++ is selected and press *Next* again.</code></p><p>​        <code>Now you will be asked to name your project. Title the project</code>HelloWorld<code>. You can save it wherever you wish. On Windows, we recommend you to save it in a subdirectory of the C drive, such as</code> <code>C:\CBProjects</code>.``</p><p><img src="ngcb2-168819594447253.webp" alt="Code::Blocks Save Project Dialog"></p><p>​        <code>You may see another dialog asking you which configurations you want enabled. The defaults should be fine here, so select *Finish*.</code></p><p>​        <code>Now your new project has been created.</code></p><p>​        <code>On the left side of the screen, you should see a *Management* window, with the *Projects* tab selected. Inside that window, you’ll see a *Workspace* folder, with your *HelloWorld* project inside of it:</code></p><p><img src="ngcb2-168819594447254.webp" alt="Code::Blocks Workspace"></p><p>​        <code>Inside the *HelloWorld* project, expand the *Sources* folder, and double click on “main.cpp”. You will see that a hello world program has already been written for you!</code></p><p>​        <code>Replace that one with the following:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>To build your project, press *Ctrl-F9*, or go to *Build menu &gt; Build*. If all goes well, you should see the following appear in the Build log window:</code></p><pre class="line-numbers language-none"><code class="language-none">-------------- Build: Debug in HelloWorld (compiler: GNU GCC Compiler)---------------mingw32-g++.exe -Wall -fexceptions -g -std&#x3D;c++14  -c C:\CBProjects\HelloWorld\main.cpp -o obj\Debug\main.omingw32-g++.exe  -o bin\Debug\HelloWorld.exe obj\Debug\main.o   Output file is bin\Debug\HelloWorld.exe with size 1.51 MBProcess terminated with status 0 (0 minute(s), 0 second(s))0 error(s), 0 warning(s) (0 minute(s), 0 second(s))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This means your compile was successful!</code></p><p>​        <code>To run your compiled program, press *Ctrl-F10*, or go to *Build menu &gt; Run*. You will see something similar to the following:</code></p><p><img src="ngcb2-168819594447251.webp" alt="Program run"></p><p>​        <code>That is the result of your program!</code></p><h3 id="For-Linux-users-2"><a href="#For-Linux-users-2" class="headerlink" title="For Linux users"></a>For Linux users</h3><p>​        <code>Linux users may need to install the additional packages before Code::Blocks will compile.</code></p><h3 id="Creating-a-project-in-VS-Code"><a href="#Creating-a-project-in-VS-Code" class="headerlink" title="Creating a project in VS Code"></a>Creating a project in VS Code</h3><p>​        <code>To start a new project, go to the *View &gt; Explorer* menu (or press *Ctrl-Shift-E*). This will open the explorer pane. If you haven’t previously opened a project, you should see an *Open Folder* button in the explorer pane -- press it. If there is already an open project and you want to start a new one, choose *File &gt; Open Folder* from the top nav.</code></p><p>​        <code>Inside the dialog that opens, create a new folder named *HelloWorld* and then select this folder. This folder will be your project folder.</code></p><p>​        <code>Next, we need to create the file that will contain our source code. Choose *File &gt; New File* from the top nav, or click the *New File icon* to the right of *HELLOWORLD* in the explorer pane.</code></p><p>​        <code>Name your file *main.cpp* and add the following contents to it:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>To compile *main.cpp* and run the program, make sure *main.cpp* is open in the main pane, and then either choose *Run &gt; Run Without Debugging* from the top nav, or click the *v* to the right of the play icon to the right of *main.cpp* tab and choose *Run C/C++ File*.</code></p><p>​        <code>Next, choose the *g++ build and debug active file* option (macOS users should choose *clang++* instead of *g++*). Switch the tab from *DEBUG CONSOLE* to *TERMINAL* at the bottom of the window.</code></p><p>​        <code>If the terminal contains the text “Hello, world!”, then congratulations, you’ve just run your first C++ program!</code></p><p>​        <code>If you’re using g++ on the command line</code></p><p>​        <code>In this case, you don’t need to create a project. Simply paste the following into a text file named HelloWorld.cpp and save your file:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>From the command line, type:</code></p><pre class="line-numbers language-none"><code class="language-none">g++ -o HelloWorld HelloWorld.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>This will compile and link HelloWorld.cpp. To run it, type:</code></p><p>​        <code>`HelloWorld</code> (or possibly <code>./HelloWorld</code>), and you will see the output of your program.`</p><p>​        <code>If you’re using other IDEs or a web-based compiler</code></p><p>​        <code>You will have to figure out how to do the following on your own:</code></p><ol><li><code>Create a console project (IDEs only)</code></li><li><code>Add a .cpp file to the project (IDEs only, if one isn’t auto-created for you)</code></li><li><code>Paste the following code into the file:</code></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Compile the project</li><li>Run the project</li></ol><h4 id="If-compiling-fails"><a href="#If-compiling-fails" class="headerlink" title="If compiling fails"></a><code>If compiling fails</code></h4><p>​        <code>It’s okay, take a deep breath. We can probably fix it. :)</code></p><p>​        <code>First, look at the error message that the compiler gave you. Most often, it will contain a line number indicating which line was in error. Examine both that line and the lines around it, and make sure there are no typos or misspellings. Also make sure you’re not including line numbers in your code (your editor should be providing those).</code></p><p>​        <code>Second, you could view some Q &amp; A to check the answer.</code></p><p>​        <code>Third, read the comments below the lesson containing the example you’re compiling -- someone may have encountered the same issue and provided a solution.</code></p><p>​        <code>Finally, if all of the above fail, try searching for your error message on your favorite search engine. It’s likely someone else has encountered this issue before and figured out how to fix it.</code></p><p>​        <code>If your program runs but the console window flashes and closes immediately</code></p><p>​        <code>When a console program is run, the console window will open and any output from the program will be written into the console window.</code></p><p>​        <code>When the program has finished running, most modern IDEs will keep the console open (until you press a key) so you can inspect the results of the program before continuing. However, some older IDEs will automatically close the console window when the program finishes running. This is generally not what you want.</code></p><p>​        <code>If your IDE closes the console window automatically, the following two steps can be used to ensure the console pauses at end of the program.</code></p><p>​        <code>First, add or ensure the following lines are near the top of your program:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;limits></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Second, add the following code at the end of the main() function (just before the return statement):</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reset any error flags</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>streamsize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ignore any characters in the input buffer until we find a newline</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get one more char from the user (waits for user to press enter)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>This will cause your program to wait for the user to press enter before continuing (you may have to press enter twice), which will give you time to examine your program’s output before your IDE closes the console window.</code></p><p>​        <code>Other solutions, such as the commonly suggested</code></p><pre class="line-numbers language-none"><code class="language-none">system(&quot;pause&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>     `solution may only work on certain operating systems and should be avoided.`</code></pre><p>​        <code>If the console window doesn’t open at all and your program doesn’t appear to be running, your anti-virus or anti-malware may also be blocking execution of the program. If that’s the case, try temporarily disabling your scanners and see if the problem resolves.</code></p><p>​        <code>What is the difference between the compile, build, rebuild, clean, and run/start options in my IDE?</code></p><p>​        <code>Previously, we showed that to produce an executable that can be run, each code file in a program is compiled into an object file, and then the object files are linked into an executable.</code></p><p>​        <code>When a code file is compiled, your IDE may cache the resulting object file. That way, if the program is compiled again in the future, any code file that hasn’t been modified doesn’t need to be recompiled -- the cached object file from last time can be reused. This can speed up compilation times significantly (at the cost of a little bit of disk space).</code></p><p>​        <code>With that in mind, here’s what each of the options typically does:</code></p><ul><li><code>Build compiles all modified code files in the project or workspace/solution, and then links the object files into an executable. If no code files have been modified since the last build, this option does nothing.</code></li><li><code>Clean removes all cached objects and executables so the next time the project is built, all files will be recompiled and a new executable produced.</code></li><li><code>Rebuild does a “clean”, followed by a “build”.</code></li><li><code>Compile recompiles a single code file (regardless of whether it has been cached previously). This option does not invoke the linker or produce an executable.</code></li><li><code>Run/start executes the executable from a prior build. Some IDEs (e.g. Visual Studio) will invoke a “build” before doing a “run” to ensure you are running the latest version of your code. Otherwise (e.g. Code::Blocks) will just execute the prior executable.</code></li></ul><p>​        <code>Although we talk informally about “compiling” our programs, to actually compile our programs we will typically choose the “build” (or “run”) option in our IDE to do so.</code></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>​        <code>Congratulations, you made it through the hardest part of this tutorial (installing the IDE and compiling your first program)!</code></p><p>​        <code>Don’t worry if you don’t understand what the different lines in the Hello World program do. We’ll examine and explain each line in detail at the start of the next chapter.</code></p><h2 id="A-few-common-C-problems"><a href="#A-few-common-C-problems" class="headerlink" title="A few common C++ problems"></a><code>A few common C++ problems</code></h2><p>​        <code>In this section, we’ll address some of the common issues that new programmers seem to run across with fairly high probability. This is not meant to be a comprehensive list of compilation or execution problems, but rather a pragmatic list of solutions to very basic issues. If you have any suggestions for other issues that might be added to this list, post them in the comments section below.</code></p><h3 id="General-run-time-issues"><a href="#General-run-time-issues" class="headerlink" title="General run-time issues"></a><code>General run-time issues</code></h3><p><code>Q: When executing a program, the console window blinks and then closes immediately.</code></p><p>​        <code>First, add or ensure the following lines are near the top of your program (Visual Studio users, make sure these lines appear after #include “pch.h” or #include “stdafx.h”, if those exist):</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;limits></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Second, add the following code at the end of your main() function (right before the return statement):</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reset any error flags</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>streamsize<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ignore any characters in the input buffer until we find an enter character</span>std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get one more char from the user</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>This will cause your program to wait for the user to press a key before continuing, which will give you time to examine your program’s output before your operating system closes the console window.</code></p><p>​        <code>Other solutions, such as the commonly suggested system(“pause”) solution may only work on certain operating systems and should be avoided.</code></p><p>​        <code>Older versions of Visual Studio may not pause when the program is run in *Start With Debugging (F5)* mode. Try running in *Start Without Debugging (Ctrl-F5)* mode.</code></p><p>​        <code>Q: I ran my program and get a window but no output.</code></p><p>​        <code>Your virus scanner or anti-malware may be blocking execution. Try disabling it temporarily and see if that’s the issue.</code></p><p>​        <code>Q: My program compiles but it isn’t working correctly. What do I do?</code></p><p>​        <code>Debug it! There are tips on how to diagnose and debug your programs later in chapter 3.</code></p><h3 id="General-compile-time-issues"><a href="#General-compile-time-issues" class="headerlink" title="General compile-time issues"></a>General compile-time issues</h3><p>​        <code>Q: When I compile my program, I get an error about unresolved external symbol _main or _WinMain@16</code></p><p>​        <code>This means your compiler can’t find your main() function. All programs must include a main() function.</code></p><p><code>There are a few things to check:</code><br><code>a) Does your code include a function named main?</code><br><code>b) Is main spelled correctly?</code><br><code>c) When you compile your program, do you see the file that contains function main() get compiled? If not, either move the main() function to one that is, or add the file to your project</code><br><code>d) Did you create a console project? Try creating a new console project.</code></p><p><code>Q: I’m trying to use C++11/14/17/XX functionality and it doesn’t work</code></p><p><code>If your compiler is old, it may not support these more recent additions to the language. In that case, upgrade your compiler.</code></p><p><code>For modern IDEs/compilers, your compiler may be defaulting to an older language standard.</code> </p><p><code>Q: When trying to use cin, cout, or endl, the compiler says cin, cout, or endl is an ‘undeclared identifier’</code></p><p>​        <code>First, make sure you have included the following line near the top of your file:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Second, make sure each use of cin, cout, and endl are prefixed by “std::”. For example:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>If this doesn’t fix your issue, then it may be that your compiler is out of date, or the install is corrupted. Try reinstalling and/or upgrading to the latest version of your compiler.</code></p><p><code>Q: When trying to use endl to end a printed line, the compiler says end1 is an ‘undeclared identifier’</code></p><p>​        <code>Make sure you do not mistake the letter l (lower case L) in endl for the number 1. endl is all letters.</code></p><p>​        <code>Make sure your editor is using a font that makes clear the differences between the letter lower case L, upper case i, and the number 1. Also the letter capital o and the number zero can easily be confused in many non-programming fonts.</code></p><p><code>Q: When compiling my program, I get a ‘no newline at end of file’ error</code></p><p>​        <code>The C++ standard requires that all source (.cpp) files end in a newline. It’s silly, but it is what it is. Go to the bottom of your source file(s), hit enter, save, and recompile.</code></p><h3 id="Visual-Studio-issues"><a href="#Visual-Studio-issues" class="headerlink" title="Visual Studio issues"></a><code>Visual Studio issues</code></h3><p>​        <code>Q: When compiling with Microsoft Visual C++, you get a C1010 fatal error, with an error message like &quot;c:\vcprojects\test.cpp(263) :fatal error C1010: unexpected end of file while looking for precompiled header directive&quot;</code></p><p>​        <code>This error occurs when the Microsoft Visual C++ compiler is set to use precompiled headers but one (or more) of your C++ code files does not #include “stdafx.h” or #include “pch.h” as the first line of the code file.</code></p><p>​        <code>Our suggested fix is to turn off precompiled headers,</code> </p><p>​        <code>If you would like to keep precompiled headers turned on, to fix this problem, simply locate the file(s) producing the error (in the above error, test.cpp is the culprit), and add the following line at the very top of the file(s):</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pch.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Older versions of Visual Studio use “stdafx.h” instead of “pch.h”, so if pch.h doesn’t resolve the issue, try stdafx.h.</code></p><p>​        <code>Note that for programs with multiple files, every C++ code file needs to start with this line.</code></p><p>​        <code>Q: Visual Studio gives the following error: &quot;1MSVCRTD.lib(exe_winmain.obj) : error LNK2019: unresolved external symbol _WinMain@16 referenced in function &quot;int __cdecl invoke_main(void)&quot; (?invoke_main@@YAHXZ)&quot;</code></p><p>​        <code>You’ve likely created a Windows graphical application rather than a console application. Recreate your project, and make sure to create it as a Windows (or Win32) *Console* project.</code></p><p>​        <code>Q: When I compile my program, I get a warning about &quot;Cannot find or open the PDB file&quot;</code></p><p>​        <code>This is a warning, not an error, so it shouldn’t impact your program. However, it is annoying. To fix it, go into the Debug menu -&gt; Options and Settings -&gt; Symbols, and check “Microsoft Symbol Server”.</code></p><h3 id="Something-else"><a href="#Something-else" class="headerlink" title="Something else"></a>Something else</h3><p><code>Q: I have some other problem that I can’t figure out. How can I get an answer quickly?</code></p><p>​        <code>As you progress through the material, you’ll undoubtedly have questions or run into unexpected problems. What to do next depends on your problem. But in general, there are a few things you can try.</code></p><p>​        <code>First, ask a search engine. Find a good way to phrase your question and do a search. If you are searching an error message, paste in the exact error message using quotes (exclude any filenames or line numbers). Odds are someone has already asked the same question and there is an answer waiting for you.</code></p><p>​        <code>If that fails, ask on a Q&amp;A board. There are websites designed for programming questions and answers, like</code><a href="https://www.stackoverflow.com/">Stack Overflow</a>. <code>Try posting your question there. Remember to be thorough about what your problem is, and include all relevant information like what OS you’re on and what IDE you’re using.</code></p><h2 id="Configuring-your-compiler-Build-configurations"><a href="#Configuring-your-compiler-Build-configurations" class="headerlink" title="Configuring your compiler: Build configurations"></a><code>Configuring your compiler: Build configurations</code></h2><p>​        <code>A build configuration (also called a build target) is a collection of project settings that determines how your IDE will build your project. The build configuration typically includes things like what the executable will be named, what directories the IDE will look in for other code and library files, whether to keep or strip out debugging information, how much to have the compiler optimize your program, etc… Generally, you will want to leave these settings at their default values unless you have a specific reason to change something.</code></p><p>​        <code>When you create a new project in your IDE, most IDEs will set up two different build configurations for you: a release configuration, and a debug configuration.</code></p><p>​        <code>The debug configuration is designed to help you debug your program, and is generally the one you will use when writing your programs. This configuration turns off all optimizations, and includes debugging information, which makes your programs larger and slower, but much easier to debug. The debug configuration is usually selected as the active configuration by default. We’ll talk more about debugging techniques in a later lesson.</code></p><p>​        <code>The release configuration is designed to be used when releasing your program to the public. This version is typically optimized for size and performance, and doesn’t contain the extra debugging information. Because the release configuration includes all optimizations, this mode is also useful for testing the performance of your code (which we’ll show you how to do later in the tutorial series).</code></p><p>​        <code>When the Hello World program  was built using Visual Studio, the executable produced in the debug configuration was 65kb, whereas the executable built in the release version was 12kb. The difference is largely due to the extra debugging information kept in the debug build.</code></p><p>​        <code>Although you can create your own custom build configurations, you’ll rarely have a reason to unless you want to compare two builds made using different compiler settings.</code></p><h3 id="Best-practice-3"><a href="#Best-practice-3" class="headerlink" title="Best practice"></a>Best practice</h3><p>​        <code>Use the debug build configuration when developing your programs. When you’re ready to release your executable to others, or want to test performance, use the release build configuration.</code></p><p>​        <code>Some IDEs (e.g. Visual Studio) also create separate build configurations for different platforms. For example, Visual Studio creates build configurations for both the x86 (32-bit) and the x64 (64-bit) platforms.</code></p><h3 id="Switching-between-build-configurations"><a href="#Switching-between-build-configurations" class="headerlink" title="Switching between build configurations"></a>Switching between build configurations</h3><h4 id="For-Visual-Studio-users"><a href="#For-Visual-Studio-users" class="headerlink" title="For Visual Studio users"></a><code>For Visual Studio users</code></h4><p>​        <code>There are multiple ways to switch between debug and release in Visual Studio. The easiest way is to set your selection directly from the Solution Configurations dropdown in the Standard Toolbar Options:</code></p><p><img src="ngcb2-168819683449469.webp" alt="VS Solution Configurations Dropdown"></p><p>​        <code>Set it to Debug for now.</code></p><p>​        <code>You can also access the configuration manager dialog by selecting Build menu &gt; Configuration Manager, and change the active solution configuration.</code>    </p><p>​        <code>To the right of the Solutions Configurations dropdown, Visual Studio also has a Solutions Platform dropdown that allows you to switch between x86 (32-bit) and x64 (64-bit) platforms.</code></p><h4 id="For-Code-Blocks-users"><a href="#For-Code-Blocks-users" class="headerlink" title="For Code::Blocks users"></a><code>For Code::Blocks users</code></h4><p>​        <code>In Code::Blocks, you should see an item called Build Target in the Compiler toolbar:</code></p><p><img src="ngcb2-168819683449470.webp" alt="Code::Blocks Build Target Dropdown"></p><p>​        <code>Set it to Debug for now.</code></p><h4 id="For-GCC-G-users"><a href="#For-GCC-G-users" class="headerlink" title="For GCC/G++ users"></a><code>For GCC/G++ users</code></h4><p>​        <code>Add</code>-ggdb<code>to the command line when debugging and</code>-O2 -DNDEBUG<code>for release builds. Use the former for now.</code></p><h4 id="For-VS-Code-users"><a href="#For-VS-Code-users" class="headerlink" title="For VS Code users"></a><code>For VS Code users</code></h4><p>​        <code>When you first ran your program, a new file called tasks.json was created under the .vscode folder in the explorer pane. Open the tasks.json file, find “args”, and then locate the line “$&#123;file&#125;” within that section.</code></p><p>​        <code>Above the “$&#123;file&#125;” line, add a new line containing the following command (one per line) when debugging:</code><br><code>&quot;-ggdb&quot;,</code></p><p>​        <code>Above the “$&#123;file&#125;” line, add new lines containing the following commands (one per line) for release builds:</code><br><code>&quot;-O2&quot;,</code><br><code>&quot;-DNDEBUG&quot;,</code></p><h3 id="Modifying-build-configurations"><a href="#Modifying-build-configurations" class="headerlink" title="Modifying build configurations"></a>Modifying build configurations</h3><p>​        <code>In the next few lessons, we’ll show you how to tweak some settings in your build configurations. Whenever changing a project setting, we recommend making the change in all build configurations.</code></p><p>​        <code>This will help prevent making the change to the wrong build configuration, and ensure the change is still applied if you happen to switch build configurations later.</code></p><h3 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip"></a><code>Tip</code></h3><p>​        <code>Whenever you update your project settings, make the change for all build configurations (unless it’s not appropriate for some reason).</code></p><p>​        <code>A **build configuration** (also called a **build target**) is a collection of project settings that determines how your IDE will build your project. The build configuration typically includes things like what the executable will be named, what directories the IDE will look in for other code and library files, whether to keep or strip out debugging information, how much to have the compiler optimize your program, etc… Generally, you will want to leave these settings at their default values unless you have a specific reason to change something.</code></p><p>​        <code>When you create a new project in your IDE, most IDEs will set up two different build configurations for you: a release configuration, and a debug configuration.</code></p><p>​        <code>The debug configuration is designed to help you debug your program, and is generally the one you will use when writing your programs. This configuration turns off all optimizations, and includes debugging information, which makes your programs larger and slower, but much easier to debug. The debug configuration is usually selected as the active configuration by default. We’ll talk more about debugging techniques in a later lesson.</code></p><p>​        <code>The release configuration is designed to be used when releasing your program to the public. This version is typically optimized for size and performance, and doesn’t contain the extra debugging information. Because the release configuration includes all optimizations, this mode is also useful for testing the performance of your code (which we’ll show you how to do later in the tutorial series).</code></p><p>​        <code>When the Hello World program was built using Visual Studio, the executable produced in the debug configuration was 65kb, whereas the executable built in the release version was 12kb. The difference is largely due to the extra debugging information kept in the debug build.</code></p><p>​        <code>Although you can create your own custom build configurations, you’ll rarely have a reason to unless you want to compare two builds made using different compiler settings.</code></p><h3 id="Best-practice-4"><a href="#Best-practice-4" class="headerlink" title="Best practice"></a><code>Best practice</code></h3><p>​        <code>Use the *debug* build configuration when developing your programs. When you’re ready to release your executable to others, or want to test performance, use the *release* build configuration.</code></p><p>​        <code>Some IDEs (e.g. Visual Studio) also create separate build configurations for different platforms. For example, Visual Studio creates build configurations for both the x86 (32-bit) and the x64 (64-bit) platforms.</code></p><h3 id="Switching-between-build-configurations-1"><a href="#Switching-between-build-configurations-1" class="headerlink" title="Switching between build configurations"></a><code>Switching between build configurations</code></h3><h4 id="For-Visual-Studio-users-1"><a href="#For-Visual-Studio-users-1" class="headerlink" title="For Visual Studio users"></a><code>For Visual Studio users</code></h4><p>​        <code>There are multiple ways to switch between debug and release in Visual Studio. The easiest way is to set your selection directly from the Solution Configurations dropdown in the Standard Toolbar Options:</code></p><p><img src="ngcb2-16882122895681.webp" alt="VS Solution Configurations Dropdown"></p><p>​        <code>Set it to *Debug* for now.</code></p><p>​        <code>You can also access the configuration manager dialog by selecting Build menu &gt; Configuration Manager, and change the active solution configuration.</code></p><p>​        <code>To the right of the Solutions Configurations dropdown, Visual Studio also has a Solutions Platform dropdown that allows you to switch between x86 (32-bit) and x64 (64-bit) platforms.</code></p><h4 id="For-Code-Blocks-users-1"><a href="#For-Code-Blocks-users-1" class="headerlink" title="For Code::Blocks users"></a><code>For Code::Blocks users</code></h4><p>​        <code>In Code::Blocks, you should see an item called Build Target in the Compiler toolbar:</code></p><p><img src="ngcb2-168819695778076.webp" alt="Code::Blocks Build Target Dropdown"></p><p>​        <code>Set it to *Debug* for now.</code></p><h4 id="For-GCC-G-users-1"><a href="#For-GCC-G-users-1" class="headerlink" title="For GCC/G++ users"></a><code>For GCC/G++ users</code></h4><p>​        <code>Add</code> <code>-ggdb</code> <code>to the command line when debugging and</code>-O2 -DNDEBUG<code>for release builds. Use the former for now.</code></p><h4 id="For-VS-Code-users-1"><a href="#For-VS-Code-users-1" class="headerlink" title="For VS Code users"></a><code>For VS Code users</code></h4><p>​        <code>When you first ran your program, a new file called *tasks.json* was created under the *.vscode* folder in the explorer pane. Open the *tasks.json* file, find *“args”*, and then locate the line *“$&#123;file&#125;”* within that section.</code></p><p><code>Above the *“$&#123;file&#125;”* line, add a new line containing the following command (one per line) when debugging:</code><br><code>&quot;-ggdb&quot;,</code></p><p><code>Above the *“$&#123;file&#125;”* line, add new lines containing the following commands (one per line) for release builds:</code><br><code>&quot;-O2&quot;,</code><br><code>&quot;-DNDEBUG&quot;,</code></p><h3 id="Modifying-build-configurations-1"><a href="#Modifying-build-configurations-1" class="headerlink" title="Modifying build configurations"></a><code>Modifying build configurations</code></h3><p>​        <code>In the next few lessons, we’ll show you how to tweak some settings in your build configurations. Whenever changing a project setting, we recommend making the change in all build configurations.</code></p><p>​        <code>This will help prevent making the change to the wrong build configuration, and ensure the change is still applied if you happen to switch build configurations later.</code></p><h3 id="Tip-2"><a href="#Tip-2" class="headerlink" title="Tip"></a><code>Tip</code></h3><p>​        <code>Whenever you update your project settings, make the change for all build configurations (unless it’s not appropriate for some reason).</code></p><h2 id="Configuring-your-compiler-Compiler-extensions"><a href="#Configuring-your-compiler-Compiler-extensions" class="headerlink" title="Configuring your compiler: Compiler extensions"></a><code>Configuring your compiler: Compiler extensions</code></h2><p>​        <code>The C++ standard defines rules about how programs should behave in specific circumstances. And in most cases, compilers will follow these rules. However, many compilers implement their own changes to the language, often to enhance compatibility with other versions of the language (e.g. C99), or for historical reasons. These compiler-specific behaviors are called compiler extensions.</code></p><p>​        <code>Writing a program that makes use of a compiler extension allows you to write programs that are incompatible with the C++ standard. Programs using non-standard extensions generally will not compile on other compilers (that don’t support those same extensions), or if they do, they may not run correctly.</code></p><p>​        <code>Frustratingly, compiler extensions are often enabled by default. This is particularly damaging for new learners, who may think some behavior that works is part of official C++ standard, when in fact their compiler is simply over-permissive.</code></p><p>​        <code>Because compiler extensions are never necessary, and cause your programs to be non-compliant with C++ standards, we recommend turning compiler extensions off.</code></p><h3 id="Best-practice-5"><a href="#Best-practice-5" class="headerlink" title="Best practice"></a><code>Best practice</code></h3><p>​        <code>Disable compiler extensions to ensure your programs (and coding practices) remain compliant with C++ standards and will work on any system.</code></p><h3 id="Disabling-compiler-extensions"><a href="#Disabling-compiler-extensions" class="headerlink" title="Disabling compiler extensions"></a><code>Disabling compiler extensions</code></h3><h4 id="For-Visual-Studio-users-2"><a href="#For-Visual-Studio-users-2" class="headerlink" title="For Visual Studio users"></a><code>For Visual Studio users</code></h4><p>​        <code>To disable compiler extensions, right click on your project name in the *Solution Explorer* window, then choose *Properties*:</code></p><p><img src="ngcb2-168819697699381.webp" alt="Solution Explorer Properties"></p><p>​        <code>From the *Project* dialog, first make sure the *Configuration* field is set to *All Configurations*.</code></p><p>​        <code>Then, click C/C++ &gt; Language tab, and set Conformance mode to Yes (/permissive-) (if it is not already set to that by default).</code></p><p><img src="ngcb2-168819697699482.webp" alt="Disable Language Extensions"></p><h4 id="For-Code-Blocks-users-2"><a href="#For-Code-Blocks-users-2" class="headerlink" title="For Code::Blocks users"></a><code>For Code::Blocks users</code></h4><p>​        <code>Disable compiler extensions via Settings menu &gt; Compiler &gt; Compiler flags tab, then find and check the -pedantic-errors option.</code></p><p><img src="ngcb2-168819697699483.webp" alt="Disable Language Extensions"></p><h4 id="For-GCC-G-users-2"><a href="#For-GCC-G-users-2" class="headerlink" title="For GCC/G++ users"></a><code>For GCC/G++ users</code></h4><p>​        <code>You can disable compiler extensions by adding the *-pedantic-errors* flag to the compile command line.</code></p><h4 id="For-VS-Code-users-2"><a href="#For-VS-Code-users-2" class="headerlink" title="For VS Code users"></a><code>For VS Code users</code></h4><ul><li><p><code>Open the tasks.json file, find</code>“args”<code>, and then locate the line</code>“$\{file\}”<code>within that section.</code></p></li><li><p><code>Above the</code></p><pre class="line-numbers language-none"><code class="language-none">&quot;$&#123;file&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>line, add a new line containing the following commands:</code></p></li></ul><pre class="line-numbers language-none"><code class="language-none">&quot;-pedantic-errors&quot;,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>As of the time of writing, VS Code does not automatically add a newline to the end of code files that are missing it (something that is pedantically required by the C++ standard). Fortunately, we can tell VS Code to do so:</code></p><ul><li><code>Open VS Code and go to *File (Code if using a Mac) &gt; Preferences &gt; Settings*. This will open a settings dialog.</code></li><li><code>Enter</code>insert final newline<code>into the search bar.</code></li><li><code>In both the *Workspace Settings* and *User Settings* tabs, ensure the checkbox labeled *Files: Insert Final Newline* is checked.</code></li></ul><h3 id="Related-content-1"><a href="#Related-content-1" class="headerlink" title="Related content"></a>Related content</h3><p>​        <code>Xcode users can refer to</code> <a href="https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-compiler-extensions/comment-page-1/#comment-446983">Rory’s comment</a>, <code>who kindly provided instructions.</code></p><h3 id="A-reminder"><a href="#A-reminder" class="headerlink" title="A reminder"></a>A reminder</h3><p>​        <code>These settings are applied on a per-project basis. You need to set them every time you create a new project, or create a template project with those settings once and use that to create new projects.</code></p><h2 id="Configuring-your-compiler-Warning-and-error-levels"><a href="#Configuring-your-compiler-Warning-and-error-levels" class="headerlink" title="Configuring your compiler: Warning and error levels"></a><code>Configuring your compiler: Warning and error levels</code></h2><p>​        <code>When you write your programs, the compiler will check to ensure you’ve followed the rules of the C++ language</code></p><p>​        <code>If you have done something that definitively violates the rules of the language, during compilation the compiler will emit an error, providing both line number containing the error, and some text about what was expected vs what was found. The actual error may be on that line, or on a preceding line. Once you’ve identified and fixed the erroneous line(s) of code, you can try compiling again.</code></p><p>​        <code>In other cases, the compiler may find code that seems like it might be in error, but the compiler can’t be sure (remember the motto: “trust the programmer”). In such cases, the compiler may opt to issue a warning. Warnings do not halt compilation, but are notices to the programmer that something seems amiss.</code></p><h3 id="Best-practice-6"><a href="#Best-practice-6" class="headerlink" title="Best practice"></a>Best practice</h3><p>​        <code>Don’t let warnings pile up. Resolve them as you encounter them (as if they were errors). Otherwise a warning about a serious issue may be lost amongst warnings about non-serious issues.</code></p><p>​        <code>In most cases, warnings can be resolved either by fixing the issue the warning is pointing out, or by rewriting the line of code generating the warning in such a way that the warning is no longer generated.</code></p><p>​        <code>In rare cases, it may be necessary to explicitly tell the compiler to not generate a particular warning for the line of code in question. C++ does not support an official way to do this, but many individual compilers (including Visual Studio and GCC) offer solutions (via non-portable #pragma directives) to temporarily disable warnings.</code></p><h3 id="Increasing-your-warning-levels"><a href="#Increasing-your-warning-levels" class="headerlink" title="Increasing your warning levels"></a>Increasing your warning levels</h3><p>​        <code>By default, most compilers will only generate warnings about the most obvious issues. However, you can request your compiler be more assertive about providing warnings for things it finds strange.</code></p><h4 id="Best-practice-7"><a href="#Best-practice-7" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>Turn your warning levels up to the maximum, especially while you are learning. It will help you identify possible issues.</code></p><h4 id="For-Visual-Studio-users-3"><a href="#For-Visual-Studio-users-3" class="headerlink" title="For Visual Studio users"></a><code>For Visual Studio users</code></h4><p>​        <code>To increase your warning levels, right click on your project name in the Solution Explorer window, then choose Properties:</code></p><p><img src="ngcb2-168819717437590.webp" alt="Solution Explorer Properties"></p><p>​        <code>From the Project dialog, first make sure the Configuration field is set to All Configurations. Then select C/C++ &gt; General tab and set Warning level to Level4 (/W4):</code></p><p><img src="ngcb2-168819717437591.webp" alt="Enable Level 4 Warnings"></p><p>​        Note: Do not choose <em>EnableAllWarnings (/Wall)</em> or you will be buried in warnings generated by the C++ standard library.</p><p>Visual Studio disables signed/unsigned conversion warnings by default, and those are useful, so if you are using Visual Studio 2019 or newer, let’s enable those:</p><ul><li><p>​        <code>From C/C++ &gt; Command Line tab, underAdditional Options, add</code></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;w44365<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>This tells the compiler to enable signed/unsigned conversion warnings at warning level 4 (which you enabled above).</code></p><ul><li>​    <code>From C/C++ &gt; External Includes tab, set External Header Warning Level to Level3 (/external:W3). This tells the compiler to compile standard library headers at warning level 3 (instead of 4) so that compiling those headers doesn’t trigger this warning.</code></li></ul></li></ul><p>​        <code>The “External Includes” tab isn’t shown in the graphic above, but appears in VS Community 2019 or newer between the “Browse Information” and “Advanced” tabs. See</code>  <a href="https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/">this link</a>, <code>which contains a recent photo of the dialog containing the “External Includes” tab.</code></p><h4 id="For-Code-Blocks-users-3"><a href="#For-Code-Blocks-users-3" class="headerlink" title="For Code::Blocks users"></a><code>For Code::Blocks users</code></h4><p>​        <code>From Settings menu &gt; Compiler &gt; Compiler settings tab, find and check the options that correlate with -Wall, -Weffc++, and -Wextra:</code></p><p><img src="ngcb2-168819717437592.webp" alt="Enable All Warnings"></p><p>​        <code>Then go to the Other compiler options tab, and add -Wconversion -Wsign-conversion to the following text edit area:</code></p><p><img src="ngcb2-168819717437593.webp" alt="Add -Wsign-conversion"></p><p>​        <code>Note: The *-Werror* parameter is explained below.</code></p><h4 id="For-GCC-G-users-3"><a href="#For-GCC-G-users-3" class="headerlink" title="For GCC/G++ users"></a><code>For GCC/G++ users</code></h4><p>​        <code>Add the following flags to your command line: -Wall -Weffc++ -Wextra -Wconversion -Wsign-conversion</code></p><h4 id="For-VS-Code-users-3"><a href="#For-VS-Code-users-3" class="headerlink" title="For VS Code users"></a><code>For VS Code users</code></h4><p>​        <code>Open the tasks.json file, find “args”, and then locate the line *“$&#123;file&#125;”* within that section.</code></p><p>​        <code>Above the *“$&#123;file&#125;”* line, add new lines containing the following commands (one per line):</code></p><pre class="line-numbers language-none"><code class="language-none">&quot;-Wall&quot;,&quot;-Weffc++&quot;,&quot;-Wextra&quot;,&quot;-Wconversion&quot;,&quot;-Wsign-conversion&quot;,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Treat warnings as errors</code></p><p>​        <code>It is also possible to tell your compiler to treat all warnings as if they were errors (in which case, the compiler will halt compilation if it finds any warnings). This is a good way to enforce the recommendation that you should fix all warnings (if you lack self-discipline, which most of us do).</code></p><h3 id="Best-practice-8"><a href="#Best-practice-8" class="headerlink" title="Best practice"></a>Best practice</h3><p>​        <code>Enable “Treat warnings as errors”. This will force you to resolve all issues causing warnings.</code></p><h4 id="For-Visual-Studio-users-4"><a href="#For-Visual-Studio-users-4" class="headerlink" title="For Visual Studio users"></a><code>For Visual Studio users</code></h4><p>​        <code>To treat warnings as errors, right click on your project name in the *Solution Explorer* window, then choose *Properties*:</code></p><p><img src="ngcb2-168819717437590.webp" alt="Solution Explorer Properties"></p><p>​        <code>From the *Project* dialog, first make sure the *Configuration* field is set to *All Configurations*.</code></p><p>​        <code>Then select *C/C++ &gt; General tab* and set *Treat Warnings As Errors* to *Yes (/WX)*.</code></p><p><img src="ngcb2-168819717437594.webp" alt="Treat warnings as errors"></p><h4 id="For-Code-Blocks-users-4"><a href="#For-Code-Blocks-users-4" class="headerlink" title="For Code::Blocks users"></a><code>For Code::Blocks users</code></h4><p>​        <code>From Settings menu &gt; Compiler &gt; Other compiler options tab, add -Werror to the text edit area:</code></p><p><img src="ngcb2-168819717437593.webp" alt="Add -Werror"></p><h4 id="For-GCC-G-users-4"><a href="#For-GCC-G-users-4" class="headerlink" title="For GCC/G++ users"></a><code>For GCC/G++ users</code></h4><p>​        <code>Add the following flag to your command line: *-Werror*</code></p><h4 id="For-VS-Code-users-4"><a href="#For-VS-Code-users-4" class="headerlink" title="For VS Code users"></a><code>For VS Code users</code></h4><p><code>In the tasks.json file, add the following flags before “$&#123;file&#125;”, one per line:</code></p><pre class="line-numbers language-none"><code class="language-none">&quot;-Werror&quot;,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Configuring-your-compiler-Choosing-a-language-standard"><a href="#Configuring-your-compiler-Choosing-a-language-standard" class="headerlink" title="Configuring your compiler: Choosing a language standard"></a><code>Configuring your compiler: Choosing a language standard</code></h2><p>​        <code>With many different versions of C++ available (C++98, C++03, C++11, C++14, C++17, C++20, etc…) how does your compiler know which one to use? Generally, a compiler will pick a standard to default to (typically *not* the most recent language standard).</code></p><p>​        <code>If you wish to use a different language standard (and you probably will), you’ll have to configure your IDE/compiler to do so.</code></p><h3 id="Code-names-for-in-progress-language-standards"><a href="#Code-names-for-in-progress-language-standards" class="headerlink" title="Code names for in-progress language standards"></a><code>Code names for in-progress language standards</code></h3><p>​        <code>Finalized language standards are named after the years in which they are finalized (e.g. C++17 was finalized in 2017).</code></p><p>​        <code>However, when a new language standard is being agreed upon, it’s not clear in what year the finalization will take place. Consequently, in-progress language standards are given code names, which are then replaced by the actual names upon finalization of the standard. For example, *C++11* was called *c++1x* while it was being worked on. You may still see the code names used in places (especially for upcoming version of the language standard, which won’t have a final name yet).</code></p><p>​        <code>Here’s a mapping of code names to the final names:</code></p><ul><li><code>c++1x = C++11</code></li><li><code>c++1y = C++14</code></li><li><code>c++1z = C++17</code></li><li><code>c++2a = C++20</code></li><li><code>c++2b = C++23</code></li></ul><p>​        <code>For example, if you see c++1z, this is synonymous with the C++17 language standard.</code></p><h3 id="Which-language-standard-should-you-choose"><a href="#Which-language-standard-should-you-choose" class="headerlink" title="Which language standard should you choose?"></a><code>Which language standard should you choose?</code></h3><p>​        <code>In professional environments, it’s common to choose a language standard that is one or two versions back from the latest standard (e.g. if C++20 is the latest version, that means C++14 or C++17). This is typically done to ensure the compiler makers have had a chance to resolve defects, and so that best practices for new features are well understood. Where relevant, this also helps ensure better cross-platform compatibility, as compilers on some platforms may not provide full support for newer language standards immediately.</code></p><p>​        <code>For personal projects and while learning, there is little downside to choosing the latest finalized standard (as of the time of writing, currently C++20).</code></p><h4 id="Author’s-note-1"><a href="#Author’s-note-1" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>This website currently targets the C++17 standard, meaning our lessons and examples assume your compiler is C++17 capable. Some C++20 content is available for those with C++20 compatible compilers.</code></p><p>​        <code>To take full advantage of all the lesson content, we recommend using the C++20 language standard if your compiler supports it. Using the C++17 language standard will also provide a good experience.</code></p><p>​        <code>If your compiler doesn’t support C++17, we recommend upgrading to one that does. If this is not possible for some reason, you will need to skip some content, and alter some examples so that they will compile. This should not impact your overall experience too heavily (especially in the early lessons).</code></p><p>​        <code>C++14 is the minimum language standard for a decent experience on this site.</code></p><p>​        <code>At the end of this lesson, there are some test programs that you can compile to see if you set up your compiler to use C++17 or C++20 correctly.</code></p><h4 id="A-reminder-1"><a href="#A-reminder-1" class="headerlink" title="A reminder"></a><code>A reminder</code></h4><p>​        <code>When changing your language standard (or any other project setting), make the change to all build configurations.</code></p><p>​        <code>Setting a language standard in Visual Studio</code></p><p>​        <code>As of the time of writing, Visual Studio 2022 defaults to C++14 capabilities, which does not allow for the use of newer features introduced in C++17 and C++20.</code></p><p>​        <code>To use these newer features, you’ll need to enable a newer language standard. Unfortunately, there is currently no way to do this globally -- you must do so on a project-by-project basis.</code></p><h4 id="Warning-1"><a href="#Warning-1" class="headerlink" title="Warning"></a><code>Warning</code></h4><p>​        <code>With Visual Studio, you will need to reselect your language standard every time you create a new project.</code></p><p>​        <code>To select a language standard, open your project, then go to Project menu &gt; (Your application’s Name) Properties, then open Configuration Properties &gt; C/C++ &gt; Language.</code></p><p><img src="ngcb2-1688197483551105.webp" alt="img"></p><p>​        <code>First, make sure the *Configuration* is set to “All Configurations”.</code></p><p>​        <code>From there, you can set the *C++ Language Standard* to the version of C++ you wish to use.</code></p><h4 id="Tip-3"><a href="#Tip-3" class="headerlink" title="Tip"></a>Tip</h4><p>​        <code>We recommend choosing the latest standard “ISO C++ Latest (/std:c++latest)”, which will ensure you can use as many features as your compiler supports.</code></p><p>​        <code>Make sure you’re selecting the language standard from the dropdown menu (don’t type it out).</code></p><h4 id="Related-content-2"><a href="#Related-content-2" class="headerlink" title="Related content"></a><code>Related content</code></h4><p>​        <code>For more information on Visual Studio language standard settings, Microsoft has a</code><a href="https://docs.microsoft.com/en-us/cpp/build/reference/std-specify-language-standard-version?view=msvc-160">Visual Studio language standard reference document</a>.</p><h4 id="Setting-a-language-standard-in-Code-Blocks"><a href="#Setting-a-language-standard-in-Code-Blocks" class="headerlink" title="Setting a language standard in Code::Blocks"></a><code>Setting a language standard in Code::Blocks</code></h4><p>​        <code>Code::Blocks may default to a pre-C++11 language standard. You’ll definitely want to check and ensure a more modern language standard is enabled.</code></p><p>​        <code>The good news is that Code::Blocks allows setting your language standard globally, so you can set it once (rather than per-project). To do so, go to *Settings menu &gt; Compiler…*:</code></p><p><img src="ngcb2-1688197483551106.webp" alt="Code::Blocks Settings &gt; Compiler"></p><p>​        <code>Then find the checkboxes labeled Have g++ follow the C++XX ISO C++ language standard [-std=c++XX], where XX is some number (e.g. 20, 17, etc…) representing a language standard:</code></p><p><img src="ngcb2-1688197483551107.webp" alt="Code::Blocks C++11 setting"></p><h4 id="Tip-4"><a href="#Tip-4" class="headerlink" title="Tip"></a>Tip</h4><p>​        <code>If C++20 or C++17 appears in this list, select the one that represents the latest ISO standard (e.g. select *Have g++ follow the C++20 ISO language standard*). If you see GNU standards in this list as well, ignore them.</code></p><p>​        <code>If you do not see C++17 in this list, upgrade to the latest version of Code::Blocks.</code></p><p>​        <code>If upgrading to the latest version is not possible for some reason, your version of Code::Blocks may have support for upcoming (or just released) versions of C++. If so, these will be labeled Have g++ follow the coming C++XX (aka C++YY) ISO C++ language standard [-std=c++XX] (see the blue box above). Select the latest version from this list.</code></p><h4 id="Tip-5"><a href="#Tip-5" class="headerlink" title="Tip"></a>Tip</h4><p>​        <code>As of the time of writing, the current version of Code::Blocks (20.03) does not support C++20. If you want to use C++20 with Code::Blocks:</code></p><ol><li><code>Update your compiler by updating MinGW.</code></li><li><code>Add the following in the “Other compiler options tab” of the “Global Compiler Settings” dialog:</code></li></ol><pre class="line-numbers language-none"><code class="language-none">-std&#x3D;c++20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Setting a language standard in g++</code></p><p>​        <code>For GCC/G++, you can pass compiler flags</code>-std=c++11<code>,</code>-std=c++14<code>,</code>-std=c++17<code>, or</code>-std=c++20<code>to enable C++11/14/17/20 support respectively. If you have GCC 8 or 9, you’ll need to use</code>-std=c++2a<code>for C++20 support instead.</code></p><h4 id="Setting-a-language-standard-for-VS-Code"><a href="#Setting-a-language-standard-for-VS-Code" class="headerlink" title="Setting a language standard for VS Code"></a><code>Setting a language standard for VS Code</code></h4><p>​        <code>For VS Code, you can use compiler flags</code>“-std=c++11”,<code>,</code>“-std=c++14”,<code>,</code>“-std=c++17”,<code>, or</code>“-std=c++20”,<code>to enable C++11/14/17/20 support respectively. If you have GCC 8 or 9, you’ll need to use</code>“-std=c++2a”,<code>for C++20 support instead.</code></p><p>​        <code>Place the appropriate language standard flag (including the double quotes and comma) in the</code>tasks.json<code>configuration file, in the</code>“args”<code>section, on its own line before</code>“${file}”<code>.</code></p><p>​        <code>For C++20, in</code>settings.json<code>, change or add the following setting on its own line:</code>“C_Cpp.default.cppStandard”: “c++20”<code>.</code></p><h3 id="Testing-your-compiler-for-C-17-compatibility"><a href="#Testing-your-compiler-for-C-17-compatibility" class="headerlink" title="Testing your compiler for C++17 compatibility"></a><code>Testing your compiler for C++17 compatibility</code></h3><p>​        <code>After enabling the C++17 language standard (or higher), you should be able to compile the following code without any warnings or errors.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;array></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string_view></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tuple></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits></span></span><span class="token keyword">namespace</span> a<span class="token double-colon punctuation">::</span>b<span class="token double-colon punctuation">::</span>c<span class="token punctuation">&#123;</span>    <span class="token keyword">inline</span> <span class="token keyword">constexpr</span> std<span class="token double-colon punctuation">::</span>string_view str<span class="token punctuation">&#123;</span> <span class="token string">"hello"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">></span>std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>common_type_t<span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">>></span> <span class="token function">sum</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> <span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>args <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">auto</span> <span class="token punctuation">[</span>iNumbers<span class="token punctuation">,</span> iSum<span class="token punctuation">]</span><span class="token punctuation">&#123;</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token double-colon punctuation">::</span>b<span class="token double-colon punctuation">::</span>c<span class="token double-colon punctuation">::</span>str <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> iNumbers <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> iSum <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>array arr<span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">size</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>COPY</p><p>​        <code>If you can’t compile this code, you either haven’t enabled C++17, or your compiler doesn’t fully support C++17. In the latter case, please install the latest version of your IDE/compiler,</code></p><h3 id="Testing-your-compiler-for-C-20-compatibility"><a href="#Testing-your-compiler-for-C-20-compatibility" class="headerlink" title="Testing your compiler for C++20 compatibility"></a><code>Testing your compiler for C++20 compatibility</code></h3><p>​        <code>After enabling the C++20 language standard, you should be able to compile the following code without any warnings or errors.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;array></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;span></span></span><span class="token keyword">struct</span> <span class="token class-name">Foo</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> a<span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b<span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">consteval</span> <span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>span<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">)</span> <span class="token comment">// std::span and consteval</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> s<span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> n <span class="token operator">:</span> a<span class="token punctuation">)</span>        s <span class="token operator">+=</span> n<span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">auto</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">auto</span> x<span class="token punctuation">,</span> <span class="token keyword">auto</span> y<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span> <span class="token comment">// abbreviated function templates</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">constexpr</span> std<span class="token double-colon punctuation">::</span>array a<span class="token punctuation">&#123;</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> s<span class="token punctuation">&#123;</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    Foo f1<span class="token punctuation">&#123;</span> <span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">3</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// designated initializers</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">sum</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span>a<span class="token punctuation">,</span> f1<span class="token punctuation">.</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Exporting-your-configuration"><a href="#Exporting-your-configuration" class="headerlink" title="Exporting your configuration"></a><code>Exporting your configuration</code></h3><p>​        <code>Having to reselect all of your settings options every time you create a new project is burdensome. Fortunately, most IDEs provide a way to export your settings. This is typically done by creating a new project template with the settings you want, and then selecting that project template when you create a new project.</code></p><h4 id="For-Visual-Studio-users-5"><a href="#For-Visual-Studio-users-5" class="headerlink" title="For Visual Studio users"></a><code>For Visual Studio users</code></h4><p>​        <code>In Visual Studio, this option is available via Project -&gt; Export Template. Select “Project template”, add a name and optional description (e.g. C++20 console application), and then click “Finish”.</code></p><p>​        <code>Next time you create a new project, you’ll see this template show up in your list of project templates.</code></p><p>​        <code>Once you create a new project with this template, it may not open any files. You can open up your .cpp file in the Solution Explorer window by going to Solution -&gt; &lt;Project Name&gt; -&gt; Source Files -&gt; &lt;template name&gt;.cpp.</code></p><h4 id="For-Code-Blocks-users-5"><a href="#For-Code-Blocks-users-5" class="headerlink" title="For Code::Blocks users"></a><code>For Code::Blocks users</code></h4><p><code>In Code::Blocks, choose File -&gt; Save project as template. Give your template a title, and save.</code></p><p><code>When you create a new project, you will find this template under the “User templates” option.</code></p><h3 id="Where-can-I-view-the-C-standards-document"><a href="#Where-can-I-view-the-C-standards-document" class="headerlink" title="Where can I view the C++ standards document?"></a><code>Where can I view the C++ standards document?</code></h3><p>​        <code>Each C++ language standard is described by a standards document, which is a formal technical document that is the authoritative source for the rules and requirements of a given language standard. The standards document is not designed for learning -- rather, it’s designed for compiler writers to be able to implement new language standards accurately. You will occasionally see people quoting the standards document when explaining how something works.</code></p><p>​        <code>The approved C++ standards document for a given language standard is not available for free. There is a link to purchase the latest standard</code> <a href="https://isocpp.org/std/the-standard">here</a>.</p><p>​        <code>When a new language standard is being developed, draft standards documents are published for review. These drafts *are* available online for free. The last draft standard before the approved standard is generally close enough to the official standard to use for most purposes. You can find the draft standards</code>     <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/standards">here</a>.</p><h2 id="Statements-and-the-structure-of-a-program"><a href="#Statements-and-the-structure-of-a-program" class="headerlink" title="Statements and the structure of a program"></a><code>Statements and the structure of a program</code></h2><p>​        <code>Welcome to the first primary chapter of these C++ tutorials!</code></p><p>​        <code>In this chapter, we’ll take a first look at a number of topics that are essential to every C++ program. Because there are quite a few topics to cover, we’ll cover most at a fairly shallow level (just enough to get by). The goal of this chapter is to help you understand how basic C++ programs are constructed. By the end of the chapter, you will be able to write your own simple programs.</code></p><p>​        <code>In future chapters, we’ll revisit the majority of these topics and explore them in more detail. We’ll also introduce new concepts that build on top of these.</code></p><p>​        <code>In order to keep the lesson lengths manageable, topics may be split over several subsequent lessons. If you feel like some important concept isn’t covered in a lesson, it’s possible that it’s covered in the next lesson.</code></p><h3 id="Statements"><a href="#Statements" class="headerlink" title="Statements"></a><code>Statements</code></h3><p>​        <code>A computer program is a sequence of instructions that tell the computer what to do. A statement is a type of instruction that causes the program to perform some action.</code></p><p>​        <code>Statements are by far the most common type of instruction in a C++ program. This is because they are the smallest independent unit of computation in the C++ language. In that regard, they act much like sentences do in natural language. When we want to convey an idea to another person, we typically write or speak in sentences (not in random words or syllables). In C++, when we want to have our program do something, we typically write statements.</code></p><p>​        <code>Most (but not all) statements in C++ end in a semicolon. If you see a line that ends in a semicolon, it’s probably a statement.</code></p><p>​        <code>In a high-level language such as C++, a single statement may compile into many machine language instructions.</code></p><h4 id="For-advanced-readers-1"><a href="#For-advanced-readers-1" class="headerlink" title="For advanced readers"></a><code>For advanced readers</code></h4><p><code>There are many different kinds of statements in C++:</code></p><ol><li><code>Declaration statements</code></li><li><code>Jump statements</code></li><li><code>Expression statements</code></li><li><code>Compound statements</code></li><li><code>Selection statements (conditionals)</code></li><li><code>Iteration statements (loops)</code></li><li><code>Try blocks</code></li></ol><p><code>By the time you’re through with this tutorial series, you’ll understand what all of these are!</code></p><h3 id="Functions-and-the-main-function"><a href="#Functions-and-the-main-function" class="headerlink" title="Functions and the main function"></a><code>Functions and the main function</code></h3><p>​        <code>In C++, statements are typically grouped into units called functions. A function is a collection of statements that get executed sequentially (in order, from top to bottom). As you learn to write your own programs, you’ll be able to create your own functions and mix and match statements in any way you please (we’ll show how in a future lesson).</code></p><h4 id="Rule-1"><a href="#Rule-1" class="headerlink" title="Rule"></a><code>Rule</code></h4><p>​        <code>Every C++ program must have a special function named main (all lower case letters). When the program is run, the statements inside of *main* are executed in sequential order.</code></p><p>​        <code>Programs typically terminate (finish running) after the last statement inside function main has been executed (though programs may abort early in some circumstances, or do some cleanup afterwards).</code></p><p>​        <code>Functions are typically written to do a specific job. For example, a function named “max” might contain statements that figures out which of two numbers is larger. A function named “calculateGrade” might calculate a student’s grade from a set of test scores. We will talk a lot more about functions soon, as they are the most commonly used organizing tool in a program.</code></p><h4 id="Author’s-note-2"><a href="#Author’s-note-2" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>When discussing functions, it’s fairly common shorthand to append a pair of parenthesis to the end of the function’s name. For example, if you see the term main() or doSomething(), this is shorthand for functions named main or doSomething respectively. This helps differentiate functions from other things with names (such as variables) without having to write the word “function” each time.</code></p><h3 id="Dissecting-Hello-world"><a href="#Dissecting-Hello-world" class="headerlink" title="Dissecting Hello world!"></a><code>Dissecting Hello world!</code></h3><p>​        <code>Now that you have a brief understanding of what statements and functions are, let’s return to our “Hello world” program and take a high-level look at what each line does in more detail.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Line 1 is a special type of line called a preprocessor directive. This preprocessor directive indicates that we would like to use the contents of the iostream library, which is the part of the C++ standard library that allows us to read and write text from/to the console. We need this line in order to use std::cout on line 5. Excluding this line would result in a compile error on line 5, as the compiler wouldn’t otherwise know what std::cout is.</code></p><p>​        <code>Line 2 is blank, and is ignored by the compiler. This line exists only to help make the program more readable to humans (by separating the #include preprocessor directive and the subsequent parts of the program).</code></p><p>​        <code>Line 3 tells the compiler that we’re going to write (define) a function called *main*. As you learned above, every C++ program must have a *main* function or it will fail to link.</code></p><p>​        <code>Lines 4 and 7 tell the compiler which lines are part of the main function. Everything between the opening curly brace on line 4 and the closing curly brace on line 7 is considered part of the main function. This is called the function body.</code></p><p>​        <code>Line 5 is the first statement within function main, and is the first statement that will execute when we run our program. std::cout (which stands for “character output”) and the &lt;&lt; operator allow us to send letters or numbers to the console to be output. In this case, we’re sending it the text “Hello world!”, which will be output to the console. This statement creates the visible output of the program.</code></p><p>​        <code>Line 6 is a return statement. When an executable program finishes running, the program sends a value back to the operating system in order to indicate whether it ran successfully or not. This particular return statement returns the value of 0 to the operating system, which means “everything went okay!”. This is the last statement in the program that executes.</code></p><p>​        <code>All of the programs we write will follow this general template, or a variation on it.</code></p><h4 id="Author’s-note-3"><a href="#Author’s-note-3" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>If parts (or all) of the above explanation are confusing, that’s to be expected at this point. This was just to provide a quick overview. Subsequent lessons will dig into all of the above topics, with plenty of additional explanation and examples.</code></p><p>​        <code>You can compile and run this program yourself, and you will see that it outputs the following to the console:</code></p><pre class="line-numbers language-none"><code class="language-none">Hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Syntax-and-syntax-errors"><a href="#Syntax-and-syntax-errors" class="headerlink" title="Syntax and syntax errors"></a><code>Syntax and syntax errors</code></h3><p>​        <code>In English, sentences are constructed according to specific grammatical rules that you probably learned in English class in school. For example, normal sentences end in a period. The rules that govern how sentences are constructed in a language is called syntax. If you forget the period and run two sentences together, this is a violation of the English language syntax.</code></p><p>​        <code>C++ has a syntax too: rules about how your programs must be constructed in order to be considered valid. When you compile your program, the compiler is responsible for making sure your program follows the basic syntax of the C++ language. If you violate a rule, the compiler will complain when you try to compile your program, and issue you a syntax error.</code></p><p>​        <code>Let’s see what happens if we omit the semicolon on line 5 of the “Hello world” program, like this:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Feel free to compile this ill-formed program yourself.</code></p><p>​        <code>Visual Studio produces the following error (your compiler may generate an error message with different wording):</code></p><pre class="line-numbers language-none"><code class="language-none">c:\vcprojects\test1.cpp(6): error C2143: syntax error : missing &#39;;&#39; before &#39;return&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>This is telling you that you have a syntax error on line 6: the compiler was expecting a semicolon before the return statement, but it didn’t find one. Although the compiler will tell you which line of code it was compiling when it encountered the syntax error, the omission may actually be on a previous line. In this case, the error is actually at the end of line 5 (the compiler didn’t discover the issue until line 6).</code></p><p>​        <code>Syntax errors are common when writing a program. Fortunately, they’re typically straightforward to find and fix, as the compiler will generally point you right at them. Compilation of a program will only complete once all syntax errors are resolved.</code></p><p>​        <code>You can try deleting characters or even whole lines from the “Hello world” program to see different kinds of errors that get generated. Try restoring the missing semicolon at the end of line 5, and then deleting lines 1, 3, or 4 and see what happens.</code></p><h2 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a><code>Comments</code></h2><p>​        <code>A comment is a programmer-readable note that is inserted directly into the source code of the program. Comments are ignored by the compiler and are for the programmer’s use only.</code></p><p>​        <code>In C++ there are two different styles of comments, both of which serve the same purpose: to help programmers document the code in some way.</code></p><h3 id="Single-line-comments"><a href="#Single-line-comments" class="headerlink" title="Single-line comments"></a><code>Single-line comments</code></h3><p>​        <code>The//</code> <code>symbol begins a C++ single-line comment, which tells the compiler to ignore everything from the</code> <code>// symbol to the end of the line. For example:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span> <span class="token comment">// Everything from here to the end of the line is ignored</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Typically, the single-line comment is used to make a quick comment about a single line of code.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!\n"</span><span class="token punctuation">;</span> <span class="token comment">// std::cout lives in the iostream library</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It is very nice to meet you!\n"</span><span class="token punctuation">;</span> <span class="token comment">// these comments make the code hard to read</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yeah!\n"</span><span class="token punctuation">;</span> <span class="token comment">// especially when lines are different lengths</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>Having comments to the right of a line can make both the code and the comment hard to read, particularly if the line is long. If the lines are fairly short, the comments can simply be aligned (usually to a tab stop), like so:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!\n"</span><span class="token punctuation">;</span>                 <span class="token comment">// std::cout lives in the iostream library</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It is very nice to meet you!\n"</span><span class="token punctuation">;</span> <span class="token comment">// this is much easier to read</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yeah!\n"</span><span class="token punctuation">;</span>                        <span class="token comment">// don't you think so?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>However, if the lines are long, placing comments to the right can make your lines really long. In that case, single-line comments are often placed above the line it is commenting:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// std::cout lives in the iostream library</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!\n"</span><span class="token punctuation">;</span><span class="token comment">// this is much easier to read</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It is very nice to meet you!\n"</span><span class="token punctuation">;</span><span class="token comment">// don't you think so?</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yeah!\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Author’s-note-4"><a href="#Author’s-note-4" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>The statements above represent one of our first encounters with snippets of code. Because snippets aren’t full programs, they aren’t able to be compiled by themselves. Rather, they exist to demonstrate specific concepts in a concise manner.</code></p><p>​        <code>If you would like to compile a snippet, you’ll need to turn it into a full program in order for it to compile. Typically, that program will look something like this:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// Replace this line with the snippet of code you'd like to compile</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Multi-line-comments"><a href="#Multi-line-comments" class="headerlink" title="Multi-line comments"></a><code>Multi-line comments</code></h3><p><code>The /*</code> <code>and</code> <code>*/</code> <code>pair of symbols denotes a C-style multi-line comment. Everything in between the symbols is ignored.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* This is a multi-line comment.   This line will be ignored.   So will this one. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>Since everything between the symbols is ignored, you will sometimes see programmers “beautify” their multi-line comments:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* This is a multi-line comment. * the matching asterisks to the left * can make this easier to read */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Multi-line style comments can not be nested. Consequently, the following will have unexpected results:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* This is a multi-line /* comment */</span> <span class="token keyword">this</span> is <span class="token operator">not</span> inside the comment <span class="token operator">*</span><span class="token operator">/</span><span class="token comment">// The above comment ends at the first */, not the second */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>When the compiler tries to compile this, it will ignore everything from the first /*``to the first ``*/</code>. <code>Since</code> <code>this is not inside the comment */</code> <code>is not considered part of the comment, the compiler will try to compile it. That will inevitably result in a compile error.</code></p><p>​        <code>This is one place where using a syntax highlighter can be really useful, as the different coloring for comment should make clear what’s considered part of the comment vs not.</code></p><h4 id="Warning-2"><a href="#Warning-2" class="headerlink" title="Warning"></a><code>Warning</code></h4><p><code>Don’t use multi-line comments inside other multi-line comments. Wrapping single-line comments inside a multi-line comment is okay.</code>    </p><h3 id="Proper-use-of-comments"><a href="#Proper-use-of-comments" class="headerlink" title="Proper use of comments"></a><code>Proper use of comments</code></h3><p>​        <code>Typically, comments should be used for three things. First, for a given library, program, or function, comments are best used to describe what the library, program, or function, does. These are typically placed at the top of the file or library, or immediately preceding the function. For example:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// This program calculates the student's final grade based on their test and homework scores.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// This function uses Newton's method to approximate the root of a given equation.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// The following lines generate a random item based on rarity, level, and a weight factor.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>All of these comments give the reader a good idea of what the library, program, or function is trying to accomplish without having to look at the actual code. The user (possibly someone else, or you if you’re trying to reuse code you’ve previously written) can tell at a glance whether the code is relevant to what he or she is trying to accomplish. This is particularly important when working as part of a team, where not everybody will be familiar with all of the code.</code></p><p><code>Second, within a library, program, or function described above, comments can be used to describe how the code is going to accomplish its goal.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/* To calculate the final grade, we sum all the weighted midterm and homework scores    and then divide by the number of scores to assign a percentage, which is    used to calculate a letter grade. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// To generate a random item, we're going to do the following:</span><span class="token comment">// 1) Put all of the items of the desired rarity on a list</span><span class="token comment">// 2) Calculate a probability for each item based on level and weight factor</span><span class="token comment">// 3) Choose a random number</span><span class="token comment">// 4) Figure out which item that random number corresponds to</span><span class="token comment">// 5) Return the appropriate item</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>These comments give the user an idea of how the code is going to accomplish its goal without having to understand what each individual line of code does.</code></p><p>​        <code>Third, at the statement level, comments should be used to describe *why* the code is doing something. A bad statement comment explains *what* the code is doing. If you ever write code that is so complex that needs a comment to explain *what* a statement is doing, you probably need to rewrite your statement, not comment it.</code></p><p>​        <code>Here are some examples of bad line comments and good statement comments.</code></p><p><code>Bad comment:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Set sight range to 0</span>sight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Reason: We already can see that sight is being set to 0 by looking at the statement</code></p><p><code>Good comment:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// The player just drank a potion of blindness and can not see anything</span>sight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Reason: Now we know why the player’s sight is being set to 0</code></p><p><code>Bad comment:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Calculate the cost of the items</span>cost <span class="token operator">=</span> quantity <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> storePrice<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Reason: We can see that this is a cost calculation, but why is quantity multiplied by 2?</code></p><p><code>Good comment:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// We need to multiply quantity by 2 here because they are bought in pairs</span>cost <span class="token operator">=</span> quantity <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> storePrice<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>Reason: Now we know why this formula makes sense.</code></p><p>​        <code>Programmers often have to make a tough decision between solving a problem one way, or solving it another way. Comments are a great way to remind yourself (or tell somebody else) the reason you made one decision instead of another.</code></p><p><code>Good comments:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// We decided to use a linked list instead of an array because</span><span class="token comment">// arrays do insertion too slowly.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// We're going to use Newton's method to find the root of a number because</span><span class="token comment">// there is no deterministic way to solve these equations.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Finally, comments should be written in a way that makes sense to someone who has no idea what the code does. It is often the case that a programmer will say “It’s obvious what this does! There’s no way I’ll forget about this”. Guess what? It’s not obvious, and you will be amazed how quickly you forget. :) You (or someone else) will thank you later for writing down the what, how, and why of your code in human language. Reading individual lines of code is easy. Understanding what goal they are meant to accomplish is not.</code></p><h4 id="Best-practice-9"><a href="#Best-practice-9" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>Comment your code liberally, and write your comments as if speaking to someone who has no idea what the code does. Don’t assume you’ll remember why you made specific choices.</code></p><h4 id="Author’s-note-5"><a href="#Author’s-note-5" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>Throughout the rest of this tutorial series, we’ll use comments inside code blocks to draw your attention to specific things, or help illustrate how things work (while ensuring the programs still compile). Astute readers will note that by the above standards, most of these comments are horrible. :) As you read through the rest of the tutorials, keep in mind that the comments are serving an intentional educational purpose, not trying to demonstrate what good comments look like.</code></p><h3 id="Commenting-out-code"><a href="#Commenting-out-code" class="headerlink" title="Commenting out code"></a><code>Commenting out code</code></h3><p>​        <code>Converting one or more lines of code into a comment is called commenting out your code. This provides a convenient way to (temporarily) exclude parts of your code from being included in your compiled program.</code></p><p>​        <code>To comment out a single line of code, simply use the // style comment to turn a line of code into a comment temporarily:</code></p><p>​        <code>Uncommented out:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Commented out:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//    std::cout &lt;&lt; 1;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>To comment out a block of code, use // on multiple lines of code, or the /* */ style comment to turn the block of code into a comment temporarily.</code></p><p>​        <code>Uncommented out:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>Commented out:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//    std::cout &lt;&lt; 1;</span><span class="token comment">//    std::cout &lt;&lt; 2;</span><span class="token comment">//    std::cout &lt;&lt; 3;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>or</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/*    std::cout &lt;&lt; 1;    std::cout &lt;&lt; 2;    std::cout &lt;&lt; 3;*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>There are quite a few reasons you might want to do this:</code></p><ol><li><code>You’re working on a new piece of code that won’t compile yet, and you need to run the program. The compiler won’t let you compile the code if there are compiler errors. Commenting out the code that won’t compile will allow the program to compile so you can run it. When you’re ready, you can uncomment the code, and continue working on it.</code></li><li><code>You’ve written new code that compiles but doesn’t work correctly, and you don’t have time to fix it until later. Commenting out the broken code will ensure the broken code doesn’t execute and cause problems until you can fix it.</code></li><li><code>To find the source of an error. If a program isn’t producing the desired results (or is crashing), it can sometimes be useful to disable parts of your code to see if you can isolate what’s causing it to not work correctly. If you comment out one or more lines of code, and your program starts working as expected (or stops crashing), odds are whatever you last commented out was part of the problem. You can then investigate why those lines of code are causing the problem.</code></li><li><code>You want to replace one piece of code with another piece of code. Instead of just deleting the original code, you can comment it out and leave it there for reference until you’re sure your new code works properly. Once you are sure your new code is working, you can remove the old commented out code. If you can’t get your new code to work, you can always delete the new code and uncomment the old code to revert to what you had before.</code></li></ol><p>​        <code>Commenting out code is a common thing to do while developing, so many IDEs provide support for commenting out a highlighted section of code. How you access this functionality varies by IDE.</code></p><h4 id="For-Visual-Studio-users-6"><a href="#For-Visual-Studio-users-6" class="headerlink" title="For Visual Studio users"></a><code>For Visual Studio users</code></h4><p>​        <code>You can comment or uncomment a selection via Edit menu &gt; Advanced &gt; Comment Selection (or Uncomment Selection).</code></p><h4 id="For-Code-Blocks-users-6"><a href="#For-Code-Blocks-users-6" class="headerlink" title="For Code::Blocks users"></a><code>For Code::Blocks users</code></h4><p>​        <code>You can comment or uncomment a selection via Edit menu &gt; Comment (or Uncomment, or Toggle comment, or any of the other comment tools).</code></p><h4 id="For-VS-Code-users-5"><a href="#For-VS-Code-users-5" class="headerlink" title="For VS Code users"></a><code>For VS Code users</code></h4><p>​        <code>You can comment out a selection by pressing ctrl-k-c, and uncomment out a selection by pressing ctrl-k-u.</code></p><h4 id="Tip-6"><a href="#Tip-6" class="headerlink" title="Tip"></a><code>Tip</code></h4><p>​        <code>If you always use single line comments for your normal comments, then you can always use multi-line comments to comment out your code without conflict. If you use multi-line comments to document your code, then commenting-out code using comments can become more challenging.</code></p><p>​        <code>If you do need to comment out a code block that contains multi-line comments, you can also consider using the</code>#if 0<code>preprocessor directive, which we discuss in lesson</code> <a href="https://www.learncpp.com/cpp-tutorial/introduction-to-the-preprocessor/#if0">2.10 — Introduction to the preprocessor</a>.</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><code>Summary</code></h3><ul><li><code>At the library, program, or function level, use comments to describe what.</code></li><li><code>Inside the library, program, or function, use comments to describe how.</code></li><li><code>At the statement level, use comments to describe why.</code></li></ul><h2 id="Introduction-to-objects-and-variables"><a href="#Introduction-to-objects-and-variables" class="headerlink" title="Introduction to objects and variables"></a><code>Introduction to objects and variables</code></h2><h2 id="Data-and-values"><a href="#Data-and-values" class="headerlink" title="Data and values"></a><strong><code>Data and values</code></strong></h2><p><code>We have learned that the majority of instructions in a program are statements, and that functions are groups of statements that execute sequentially. The statements inside the function perform actions that (hopefully) generate whatever result the program was designed to produce.</code></p><p>​        <code>But how do programs actually produce results? They do so by manipulating (reading, changing, and writing) data. In computing, data is any information that can be moved, processed, or stored by a computer.</code></p><h4 id="Key-insight"><a href="#Key-insight" class="headerlink" title="Key insight"></a><code>Key insight</code></h4><p>​        <code>Programs are collections of instructions that manipulate data to produce a desired result.</code></p><p>​        <code>A program can acquire data to work with in many ways: from a file or database, over a network, from the user providing input on a keyboard, or from the programmer putting data directly into the source code of the program itself. In the “Hello world” program from the aforementioned lesson, the text “Hello world!” was inserted directly into the source code of the program, providing data for the program to use. The program then manipulates this data by sending it to the monitor to be displayed.</code></p><p>​        <code>Data on a computer is typically stored in a format that is efficient for storage or processing (and is thus not human readable). Thus, when the “Hello World” program is compiled, the text “Hello world!” is converted into a more efficient format for the program to use (binary, which we’ll discuss in a future lesson).</code></p><p>​        <code>A value is a letter (e.g.</code> <code>a</code>), <code>number</code>(e.g. <code>5</code>), <code>text</code>(e.g. <code>Hello</code>),<code>or instance of some other useful concept that can be represented as data.</code></p><h3 id="Objects-and-variables"><a href="#Objects-and-variables" class="headerlink" title="Objects and variables"></a><code>Objects and variables</code></h3><p>​        <code>All computers have memory, called RAM (short for random access memory), that is available for your programs to use. You can think of RAM as a series of numbered mailboxes that can each be used to hold a piece of data while the program is running.</code></p><p>​        <code>In some older programming languages (like Applesoft BASIC), you could directly access these mailboxes (a statement could say something like go get the value stored in mailbox number 7532).</code></p><p>​        <code>In C++, direct memory access is discouraged. Instead, we access memory indirectly through an object. An object is a region of storage (usually memory) that can store a value, and has other associated properties (that we’ll cover in future lessons). How the compiler and operating system work to assign memory to objects is beyond the scope of this lesson. But the key point here is that rather than say go get the value stored in mailbox number 7532, we can say, go get the value stored by this object. This means we can focus on using objects to store and retrieve values, and not have to worry about where in memory they’re actually being placed.</code></p><p>​        <code>Objects can be named or unnamed (anonymous). A named object is called a variable, and the name of the object is called an identifier. In our programs, most of the objects we create and use will be variables.</code></p><h4 id="Author’s-note-6"><a href="#Author’s-note-6" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>In general programming, the term object typically refers to an unnamed object in memory, a variable, or a function. In C++, the term object has a narrower definition that excludes functions.</code></p><h4 id="Key-insight-1"><a href="#Key-insight-1" class="headerlink" title="Key insight"></a><code>Key insight</code></h4><p><code>Objects (and named objects, called variables) are used to store a value.</code></p><h3 id="Variable-instantiation"><a href="#Variable-instantiation" class="headerlink" title="Variable instantiation"></a><code>Variable instantiation</code></h3><p>​        <code>In order to create a variable, we use a special kind of declaration statement called a definition (we’ll clarify the difference between a declaration and definition later).</code></p><p>​        <code>Here’s an example of defining a variable named x:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token comment">// define a variable named x, of type int</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>At compile time, when the compiler sees this statement, it makes a note to itself that we are defining a variable, giving it the name x, and that it is of type int (more on types in a moment). From that point forward (with some limitations that we’ll talk about in a future lesson), whenever the compiler sees the identifier x, it will know that we’re referencing this variable.</code>    </p><p>​        <code>When the program is run (called runtime), the variable will be instantiated. Instantiation is a fancy word that means the object will be created and assigned a memory address. Variables must be instantiated before they can be used to store values. For the sake of example, let’s say that variable *x* is instantiated at memory location 140. Whenever the program uses variable x, it will access the value in memory location 140. An instantiated object is sometimes also called an instance.</code></p><h3 id="Data-types"><a href="#Data-types" class="headerlink" title="Data types"></a><code>Data types</code></h3><p>​        <code>far, we’ve covered that variables are a named region of storage that can store a data value (how exactly data is stored is a topic for a future lesson). A data type (more commonly just called a type) tells the compiler what type of value (e.g. a number, a letter, text, etc…) the variable will store.</code></p><p>​        <code>In the above example, our variable x was given type int, which means variable x will represent an integer value. An integer is a number that can be written without a fractional component, such as 4, 27, 0, -2, or -12. For short, we can say that x is an integer variable.</code></p><p>​        <code>In C++, the type of a variable must be known at compile-time (when the program is compiled), and that type can not be changed without recompiling the program. This means an integer variable can only hold integer values. If you want to store some other kind of value, you’ll need to use a different type.</code></p><p>​        <code>Integers are just one of many types that C++ supports out of the box. For illustrative purposes, here’s another example of defining a variable using data type double:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> width<span class="token punctuation">;</span> <span class="token comment">// define a variable named width, of type double</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>C++ also allows you to create your own user-defined types. This is something we’ll do a lot of in future lessons, and it’s part of what makes C++ powerful.</code></p><p>​        <code>For these introductory chapters, we’ll stick with integer variables because they are conceptually simple, but we’ll explore many of the other types C++ has to offer soon.</code></p><h3 id="Defining-multiple-variables"><a href="#Defining-multiple-variables" class="headerlink" title="Defining multiple variables"></a><code>Defining multiple variables</code></h3><p>​        <code>It is possible to define multiple variables of the same type in a single statement by separating the names with a comma. The following 2 snippets of code are effectively the same:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>is the same as:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>When defining multiple variables this way, there are two common mistakes that new programmers tend to make (neither serious, since the compiler will catch these and ask you to fix them):</code></p><p>​        <code>The first mistake is giving each variable a type when defining variables in sequence.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span> <span class="token comment">// wrong (compiler error)</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span> <span class="token comment">// correct</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>The second mistake is to try to define variables of different types in the same statement, which is not allowed. Variables of different types must be defined in separate statements.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">;</span> <span class="token comment">// wrong (compiler error)</span><span class="token keyword">int</span> a<span class="token punctuation">;</span> <span class="token keyword">double</span> b<span class="token punctuation">;</span> <span class="token comment">// correct (but not recommended)</span><span class="token comment">// correct and recommended (easier to read)</span><span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">double</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Best-practice-10"><a href="#Best-practice-10" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>Although the language allows you to do so, avoid defining multiple variables of the same type in a single statement. Instead, define each variable in a separate statement on its own line (and then use a single-line comment to document what it is used for).</code></p><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a><code>Summary</code></h3><p>​        <code>In C++, we use variables to access memory. Variables have an identifier, a type, and a value (and some other attributes that aren’t relevant here). A variable’s type is used to determine how the value in memory should be interpreted.</code></p><h2 id="Variable-assignment-and-initialization"><a href="#Variable-assignment-and-initialization" class="headerlink" title="Variable assignment and initialization"></a><code>Variable assignment and initialization</code></h2><p>​        <code>we covered how to define a variable that we can use to store values. In this lesson, we’ll explore how to actually put values into variables and use those values.</code></p><p>​        <code>As a reminder, here’s a short snippet that first allocates a single integer variable named x, then allocates two more integer variables named y and z:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token comment">// define an integer variable named x</span><span class="token keyword">int</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span> <span class="token comment">// define two integer variables, named y and z</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Variable-assignment"><a href="#Variable-assignment" class="headerlink" title="Variable assignment"></a><code>Variable assignment</code></h3><p>​        <code>After a variable has been defined, you can give it a value (in a separate statement) using the = operator. This process is called copy assignment (or just assignment) for short.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> width<span class="token punctuation">;</span> <span class="token comment">// define an integer variable named width</span>width <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// copy assignment of value 5 into variable width</span><span class="token comment">// variable width now has value 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>Copy assignment is named such because it copies the value on the right-hand side of the *= operator* to the variable on the left-hand side of the operator. The = operator is called the assignment operator.</code></p><p>​        <code>Here’s an example where we use assignment twice:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> width<span class="token punctuation">;</span>width <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// copy assignment of value 5 into variable width</span><span class="token comment">// variable width now has value 5</span>width <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// change value stored in variable width to 7</span><span class="token comment">// variable width now has value 7</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>When we assign value 7 to variable width, the value 5 that was there previously is overwritten. Normal variables can only hold one value at a time.</code></p><h4 id="Warning-3"><a href="#Warning-3" class="headerlink" title="Warning"></a><code>Warning</code></h4><p>​        <code>One of the most common mistakes that new programmers make is to confuse the assignment operator (</code>=<code>) with the equality operator (</code>==<code>). Assignment (=) is used to assign a value to a variable. Equality (==``) is used to test whether two operands are equal in value.</code></p><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a><code>Initialization</code></h3><p>​        <code>One downside of assignment is that it requires at least two statements: one to define the variable, and one to assign the value.</code></p><p>​        <code>These two steps can be combined. When a variable is defined, you can also provide an initial value for the variable at the same time. This is called initialization. The value used to initialize a variable is called an initializer.</code></p><p>​        <code>Initialization in C++ is surprisingly complex, so we’ll present a simplified view here.</code></p><p>​        <code>There are 6 basic ways to initialize variables in C++:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span>         <span class="token comment">// no initializer (default initialization)</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>     <span class="token comment">// initializer after equals sign (copy initialization)</span><span class="token keyword">int</span> <span class="token function">c</span><span class="token punctuation">(</span> <span class="token number">6</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// initializer in parenthesis (direct initialization)</span><span class="token comment">// List initialization methods (C++11) (preferred)</span><span class="token keyword">int</span> d <span class="token punctuation">&#123;</span> <span class="token number">7</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">// initializer in braces (direct list initialization)</span><span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">8</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// initializer in braces after equals sign (copy list initialization)</span><span class="token keyword">int</span> f <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      <span class="token comment">// initializer is empty braces (value initialization)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>You may see the above forms written with different spacing</code> (e.g. <code>int d&#123;7&#125;;</code>). <code>Whether you use extra spaces for readability or not is a matter of personal preference.</code></p><h3 id="Default-initialization"><a href="#Default-initialization" class="headerlink" title="Default initialization"></a><code>Default initialization</code></h3><p>​        <code>When no initialization value is provided (such as for variable a above), this is called default initialization. In most cases, default initialization leaves a variable with an indeterminate value.</code></p><p>​        <code>We’ll discuss this case further in lesson</code> (<a href="https://www.learncpp.com/cpp-tutorial/uninitialized-variables-and-undefined-behavior/">1.6 — Uninitialized variables and undefined behavior</a>).</p><h3 id="Copy-initialization"><a href="#Copy-initialization" class="headerlink" title="Copy initialization"></a><code>Copy initialization</code></h3><p>​        <code>When an initializer is provided after an equals sign, this is called copy initialization. This form of initialization was inherited from C.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> width <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// copy initialization of value 5 into variable width</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Much like copy assignment, this copies the value on the right-hand side of the equals into the variable being created on the left-hand side. In the above snippet, variable width will be initialized with value 5</code>.</p><p>​        <code>Copy initialization had fallen out of favor in modern C++ due to being less efficient than other forms of initialization for some complex types. However, C++17 remedied much of these issues, and copy initialization is now finding some new advocates. You will also find it used in older code (especially code ported from C), or by developers who simply think it looks better.</code></p><h4 id="For-advanced-readers-2"><a href="#For-advanced-readers-2" class="headerlink" title="For advanced readers"></a><code>For advanced readers</code></h4><p>​        <code>Copy initialization is also used whenever values are implicitly copied or converted, such as when passing arguments to a function by value, returning from a function by value, or catching exceptions by value.</code></p><h3 id="Direct-initialization"><a href="#Direct-initialization" class="headerlink" title="Direct initialization"></a><code>Direct initialization</code></h3><p>​        <code>When an initializer is provided inside parenthesis, this is called direct initialization.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">width</span><span class="token punctuation">(</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// direct initialization of value 5 into variable width</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Direct initialization was initially introduced to allow for more efficient initialization of complex objects (those with class types, which we’ll cover in a future chapter). However, direct initialization has generally fallen out of favor in modern C++.</code></p><h4 id="For-advanced-readers-3"><a href="#For-advanced-readers-3" class="headerlink" title="For advanced readers"></a><code>For advanced readers</code></h4><p>​        <code>Direct initialization is also used when values are explicitly cast to another type.</code></p><p>​        <code>One of the reasons direct initialization has fallen out of favor is because it makes it hard to differentiate variables from functions. For example:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// forward declaration of function x</span><span class="token keyword">int</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// definition of variable x with initializer 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="List-initialization"><a href="#List-initialization" class="headerlink" title="List initialization"></a><code>List initialization</code></h3><p>​        <code>The modern way to initialize objects in C++ is to use a form of initialization that makes use of curly braces: list initialization (also called uniform initialization or brace initialization).</code></p><p>​        <code>List initialization comes in three forms:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> width <span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// direct list initialization of value 5 into variable width</span><span class="token keyword">int</span> height <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">6</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// copy list initialization of value 6 into variable height</span><span class="token keyword">int</span> depth <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>       <span class="token comment">// value initialization (see next section)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>As an aside…</code></p><p>​        <code>Prior to the introduction of list initialization, some types of initialization required using copy initialization, and other types of initialization required using direct initialization. List initialization was introduced to provide a more consistent initialization syntax (which is why it is sometimes called “uniform initialization”) that works in most cases.</code></p><p>​        <code>Additionally, list initialization provides a way to initialize objects with a list of values (which is why it is called “list initialization”).</code></p><p>​        <code>List initialization has an added benefit: it disallows “narrowing conversions”. This means that if you try to brace initialize a variable using a value that the variable can not safely hold, the compiler will produce an error. For example:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> width <span class="token punctuation">&#123;</span> <span class="token number">4.5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// error: a number with a fractional value can't fit into an int</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>In the above snippet, we’re trying to assign a number (4.5) that has a fractional part (the .5 part) to an integer variable (which can only hold numbers without fractional parts).</code></p><p>​        <code>Copy and direct initialization would simply drop the fractional part, resulting in the initialization of value 4 into variable width (your compiler may produce a warning about this, since losing data is rarely desired). However, with list initialization, the compiler will generate an error instead, forcing you to remedy this issue before proceeding.</code></p><p>​        <code>Conversions that can be done without potential data loss are allowed.</code></p><p>​        <code>To summarize, list initialization is generally preferred over the other initialization forms because it works in most cases, it disallows narrowing conversions, and it supports initialization with lists of values (something we’ll cover in a future lesson).</code></p><h4 id="Best-practice-11"><a href="#Best-practice-11" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>Favor initialization using braces.</code></p><p>​        <code>Value initialization and zero initialization</code></p><p>​        <code>When a variable is list initialized using empty braces, value initialization takes place. In most cases, value initialization will initialize the variable to zero (or empty, if that’s more appropriate for a given type). In such cases where zeroing occurs, this is called zero initialization.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> width <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// value initialization / zero initialization to value 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Q: When should I initialize with &#123; 0 &#125; vs &#123;&#125;?</code></p><p>​        <code>Use an explicit initialization value if you’re actually using that value.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// explicit initialization to value 0</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span> <span class="token comment">// we're using that zero value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Use value initialization if the value is temporary and will be replaced.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      <span class="token comment">// value initialization</span>std<span class="token double-colon punctuation">::</span>cin <span class="token operator">>></span> x<span class="token punctuation">;</span> <span class="token comment">// we're immediately replacing that value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Initialize your variables</code></p><p>​        <code>Initialize your variables upon creation. You may eventually find cases where you want to ignore this advice for a specific reason (e.g. a performance critical section of code that uses a lot of variables), and that’s okay, as long the choice is made deliberately.</code></p><p>​        <code>For more discussion on this topic, Bjarne Stroustrup (creator of C++) and Herb Sutter (C++ expert) make this recommendation themselves</code> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es20-always-initialize-an-object">here</a>.</p><h4 id="Best-practice-12"><a href="#Best-practice-12" class="headerlink" title="Best practice"></a><strong><code>Best practice</code></strong></h4><p><code>Initialize your variables upon creation.</code></p><h3 id="Initializing-multiple-variables"><a href="#Initializing-multiple-variables" class="headerlink" title="Initializing multiple variables"></a><code>Initializing multiple variables</code></h3><p>​        <code>In the last section, we noted that it is possible to define multiple variables *of the same type* in a single statement by separating the names with a comma:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>We also noted that best practice is to avoid this syntax altogether. However, since you may encounter other code that uses this style, it’s still useful to talk a little bit more about it, if for no other reason than to reinforce some of the reasons you should be avoiding it.</code></p><p>​        <code>You can initialize multiple variables defined on the same line:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>          <span class="token comment">// copy initialization</span><span class="token keyword">int</span> <span class="token function">c</span><span class="token punctuation">(</span> <span class="token number">7</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">d</span><span class="token punctuation">(</span> <span class="token number">8</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// direct initialization</span><span class="token keyword">int</span> e <span class="token punctuation">&#123;</span> <span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> f <span class="token punctuation">&#123;</span> <span class="token number">10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>     <span class="token comment">// direct brace initialization (preferred)</span><span class="token keyword">int</span> g <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">9</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> h <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// copy brace initialization</span><span class="token keyword">int</span> i <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> j <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token comment">// value initialization</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Unfortunately, there’s a common pitfall here that can occur when the programmer mistakenly tries to initialize both variables by using one initialization statement:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// wrong (a is not initialized!)</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// correct</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>In the top statement, variable “a” will be left uninitialized, and the compiler may or may not complain. If it doesn’t, this is a great way to have your program intermittently crash or produce sporadic results. We’ll talk more about what happens if you use uninitialized variables shortly.</code></p><p>​        <code>The best way to remember that this is wrong is to consider the case of direct initialization or brace initialization:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> d<span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Because the parenthesis or braces are typically placed right next to the variable name, this makes it seem a little more clear that the value 5 is only being used to initialize variable b and d, not a or c.</code></p><h3 id="Unused-initialized-variables-and-maybe-unused"><a href="#Unused-initialized-variables-and-maybe-unused" class="headerlink" title="Unused initialized variables and [[maybe_unused]]"></a><code>Unused initialized variables and [[maybe_unused]]</code></h3><p>​        <code>Modern compilers will typically generate warnings if a variable is initialized but not used (since this is rarely desirable). And if “treat warnings as errors” is enabled, these warnings will be promoted to errors and cause the compilation to fail.</code></p><p>​        <code>Consider the following innocent looking program:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x <span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// variable defined</span>    <span class="token comment">// but not used anywhere</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>When compiling this with g++, the following error is generated:</code></p><pre class="line-numbers language-none"><code class="language-none">prog.cc: In function &#39;int main()&#39;:prog.cc:3:9: error: unused variable &#39;x&#39; [-Werror&#x3D;unused-variable]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>and the program fails to compile.</code></p><p>​        <code>There are a few easy ways to fix this.</code></p><p>​        <code>The first option is to turn off “treat warning as errors” temporarily (just don’t forget to turn it back on).</code></p><p>​        <code>The second option is to simply use the variable somewhere:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x <span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span> <span class="token comment">// variable now used somewhere</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>In C++17, the best solution is to use the [[maybe_unused]] attribute. This attribute tells the compiler to expect that the variable may not be used, so it will not generate unused variable warnings.</code></p><p>​        <code>The following program should generate no warnings/errors, even though x is unused:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span>maybe_unused<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">int</span> x <span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">// since x is [[maybe_unused]], no warning generated</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Introduction-to-iostream-cout-cin-and-endl"><a href="#Introduction-to-iostream-cout-cin-and-endl" class="headerlink" title="Introduction to iostream: cout, cin, and endl"></a><code>Introduction to iostream: cout, cin, and endl</code></h2><p>​        <code>In this lesson, we’ll talk more about std::cout, which we used in our Hello world! program to output the text Hello world! to the console. We’ll also explore how to get input from the user, which we will use to make our programs more interactive.</code></p><h3 id="The-input-output-library"><a href="#The-input-output-library" class="headerlink" title="The input/output library"></a><code>The input/output library</code></h3><p>​        <code>The input/output library (io library) is part of the C++ standard library that deals with basic input and output. We’ll use the functionality in this library to get input from the keyboard and output data to the console. The io part of iostream stands for input/output.</code></p><p>​        <code>To use the functionality defined within the iostream library, we need to include the iostream header at the top of any code file that uses the content defined in iostream, like so:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token comment">// rest of code that uses iostream functionality here</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="std-cout"><a href="#std-cout" class="headerlink" title="std::cout"></a><code>std::cout</code></h3><p>​        <code>The iostream library contains a few predefined variables for us to use. One of the most useful is std::cout, which allows us to send data to the console to be printed as text. cout stands for “character output”.</code></p><p>​        <code>As a reminder, here’s our Hello world program:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> <span class="token comment">// for std::cout</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span> <span class="token comment">// print Hello world! to console</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>In this program, we have included iostream so that we have access to std::cout. Inside our main function, we use std::cout, along with the insertion operator (&lt;&lt;), to send the text Hello world! to the console to be printed.</code></p><p>​        <code>std::cout can not only print text, it can also print numbers:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> <span class="token comment">// for std::cout</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// print 4 to console</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This produces the result:</code></p><pre class="line-numbers language-none"><code class="language-none">4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>It can also be used to print the value of variables:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> <span class="token comment">// for std::cout</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// define integer variable x, initialized with value 5</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span> <span class="token comment">// print value of x (5) to console</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This produces the result:</code></p><pre class="line-numbers language-none"><code class="language-none">5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>To print more than one thing on the same line, the insertion operator (&lt;&lt;) can be used multiple times in a single statement to concatenate (link together) multiple pieces of output. For example:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> <span class="token comment">// for std::cout</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" world!"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This program prints:</code></p><pre class="line-numbers language-none"><code class="language-none">Hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Here’s another example where we print both text and the value of a variable in the same statement:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> <span class="token comment">// for std::cout</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x is equal to: "</span> <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This program prints:</code></p><pre class="line-numbers language-none"><code class="language-none">x is equal to: 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="std-endl"><a href="#std-endl" class="headerlink" title="std::endl"></a><code>std::endl</code></h3><p>​        <code>What would you expect this program to print?</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> <span class="token comment">// for std::cout</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hi!"</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"My name is Alex."</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>You might be surprised at the result:</code></p><pre class="line-numbers language-none"><code class="language-none">Hi!My name is Alex.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>Separate output statements don’t result in separate lines of output on the console.</code></p><p>​        <code>If we want to print separate lines of output to the console, we need to tell the console when to move the cursor to the next line.</code></p><p>​        <code>One way to do that is to use std::endl. When output with std::cout, std::endl prints a newline character to the console (causing the cursor to go to the start of the next line). In this context, endl stands for “end line”.</code></p><p>​        <code>For example:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> <span class="token comment">// for std::cout and std::endl</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hi!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// std::endl will cause the cursor to move to the next line of the console</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"My name is Alex."</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This prints:</code></p><pre class="line-numbers language-none"><code class="language-none">Hi!My name is Alex.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Tip-7"><a href="#Tip-7" class="headerlink" title="Tip"></a><code>Tip</code></h4><p>​        <code>In the above program, the second std::endl isn’t technically necessary, since the program ends immediately afterward. However, it serves a few useful purposes.</code></p><p>​        <code>First, it helps indicate that the line of output is a “complete thought” (as opposed to partial output that is completed somewhere later in the code). In this sense, it functions similarly to using a period in standard English.</code></p><p>​        <code>Second, it positions the cursor on the next line, so that if we later add additional lines of output (e.g. have the program say “bye!”), those lines will appear where we expect (rather than appended to the prior line of output).</code></p><p>​        <code>Third, after running an executable from the command line, some operating systems do not output a new line before showing the command prompt again. If our program does not end with the cursor on a new line, the command prompt may appear appended to the prior line of output, rather than at the start of a new line as the user would expect.</code></p><h4 id="Best-practice-13"><a href="#Best-practice-13" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>Output a newline whenever a line of output is complete.</code></p><h3 id="std-cout-is-buffered"><a href="#std-cout-is-buffered" class="headerlink" title="std::cout is buffered"></a><code>std::cout is buffered</code></h3><p>​        <code>Consider a rollercoaster ride at your favorite amusement park. Passengers show up (at some variable rate) and get in line. Periodically, a train arrives and boards passengers (up to the maximum capacity of the train). When the train is full, or when enough time has passed, the train departs with a batch of passengers, and the ride commences. Any passengers unable to board the current train wait for the next one.</code></p><p>​        <code>This analogy is similar to how output sent to std::cout is typically processed in C++. Statements in our program request that output be sent to the console. However, that output is typically not sent to the console immediately. Instead, the requested output “gets in line”, and is stored in a region of memory set aside to collect such requests (called a buffer). Periodically, the buffer is flushed, meaning all of the data collected in the buffer is transferred to its destination (in this case, the console).</code></p><h4 id="Author’s-note-7"><a href="#Author’s-note-7" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>To use another analogy, flushing a buffer is kind of like flushing a toilet. All of your collected “output” is transferred to … wherever it goes next. Eew.</code></p><h4 id="Key-insight-2"><a href="#Key-insight-2" class="headerlink" title="Key insight"></a><code>Key insight</code></h4><p>​        <code>Buffered systems are often used in cases where processing a few large batches of data is more efficient than processing many smaller batches of data. Buffering maximizes overall throughput, at the cost of increasing response time.</code></p><p>​        <code>This also means that if your program crashes, aborts, or is paused (e.g. for debugging purposes) before the buffer is flushed, any output still waiting in the buffer will not be displayed.</code></p><h3 id="std-endl-vs-‘-n’"><a href="#std-endl-vs-‘-n’" class="headerlink" title="std::endl vs ‘\n’"></a><code>std::endl vs ‘\n’</code></h3><p>​        <code>Using std::endl can be a bit inefficient, as it actually does two jobs: it moves the cursor to the next line of the console, and it flushes the buffer. When writing text to the console, we typically don’t need to flush the buffer at the end of each line. It’s more efficient to let the system flush itself periodically (which it has been designed to do efficiently).</code></p><p>​        <code>Because of this, use of the ‘\n’ character is typically preferred instead. The ‘\n’ character moves the cursor to the next line of the console, but doesn’t request a flush, so it will often perform better. The ‘\n’ character also tends to be easier to read since it’s both shorter and can be embedded into existing text.</code></p><p>​        <code>Here’s an example that uses ‘\n’ in two different ways:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span> <span class="token comment">// for std::cout</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> x<span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"x is equal to: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token comment">// Using '\n' standalone</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"And that's all, folks!\n"</span><span class="token punctuation">;</span> <span class="token comment">// Using '\n' embedded into a double-quoted piece of text (note: no single quotes when used this way)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This prints:</code></p><pre class="line-numbers language-none"><code class="language-none">x is equal to: 5And that&#39;s all, folks!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Note that when ‘\n’ is used by itself to move the cursor to the next line of the console, the single quotes are needed. When embedded into text that is already double-quoted, the single quotes aren’t needed.</code></p><p>​        <code>We’ll cover what ‘\n’ is in more detail when we get to the lesson on chars</code></p><h4 id="Best-practice-14"><a href="#Best-practice-14" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>Prefer ‘\n’ over std::endl when outputting text to the console.</code></p><h4 id="Warning-4"><a href="#Warning-4" class="headerlink" title="Warning"></a><code>Warning</code></h4><p>​        <code>‘\n’ uses a backslash (as do all special characters in C++), not a forward slash. Using a forward slash (e.g. ‘/n’) instead may result in unexpected behavior.</code></p><h3 id="std-cin"><a href="#std-cin" class="headerlink" title="std::cin"></a><code>std::cin</code></h3><p>​        <code>std::cin is another predefined variable that is defined in the iostream library. Whereas std::cout prints data to the console using the insertion operator (&lt;&lt;std::cin&gt;&gt;). The input must be stored in a variable to be used.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  <span class="token comment">// for std::cout and std::cin</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter a number: "</span><span class="token punctuation">;</span> <span class="token comment">// ask user for a number</span>    <span class="token keyword">int</span> x<span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// define variable x to hold user input (and zero-initialize it)</span>    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">>></span> x<span class="token punctuation">;</span> <span class="token comment">// get number from keyboard and store it in variable x</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"You entered "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Try compiling this program and running it for yourself. When you run the program, line 5 will print “Enter a number: “. When the code gets to line 8, your program will wait for you to enter input. Once you enter a number (and press enter), the number you enter will be assigned to variable x. Finally, on line 10, the program will print “You entered ” followed by the number you just entered.</code></p><p>​        <code>For example (I entered 4):</code></p><pre class="line-numbers language-none"><code class="language-none">Enter a number: 4You entered 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>This is an easy way to get keyboard input from the user, and we will use it in many of our examples going forward. Note that you don’t need to use ‘\n’ when accepting input, as the user will need to press the *enter* key to have their input accepted, and this will move the cursor to the next line of the console.</code></p><p>​        <code>Just like it is possible to output more than one bit of text in a single line, it is also possible to input more than one value on a single line:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  <span class="token comment">// for std::cout and std::cin</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Enter two numbers separated by a space: "</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// define variable x to hold user input (and zero-initialize it)</span>    <span class="token keyword">int</span> y<span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// define variable y to hold user input (and zero-initialize it)</span>    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">>></span> x <span class="token operator">>></span> y<span class="token punctuation">;</span> <span class="token comment">// get two numbers and store in variable x and y respectively</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"You entered "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">" and "</span> <span class="token operator">&lt;&lt;</span> y <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This produces the output:</code></p><pre class="line-numbers language-none"><code class="language-none">Enter two numbers separated by a space: 5 6You entered 5 and 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="Best-practice-15"><a href="#Best-practice-15" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>There’s some debate over whether it’s necessary to initialize a variable immediately before you give it a user provided value via another source (e.g. std::cin), since the user-provided value will just overwrite the initialization value. In line with our previous recommendation that variables should always be initialized, best practice is to initialize the variable first.</code></p><p>​        <code>For now, it’s enough to know that std::cin will extract as much as it can, and any input characters that could not be extracted are left for a later extraction attempt.</code></p><h4 id="For-advanced-readers-4"><a href="#For-advanced-readers-4" class="headerlink" title="For advanced readers"></a><code>For advanced readers</code></h4><p>​        <code>The C++ I/O library does not provide a way to accept keyboard input without the user having to press *enter*. If this is something you desire, you’ll have to use a third party library. For console applications, we’d recommend</code> <a href="https://pdcurses.org/">pdcurses</a>, <a href="https://github.com/ArthurSonzogni/FTXUI">FXTUI</a>, or <a href="https://github.com/jupyter-xeus/cpp-terminal">cpp-terminal</a>.<code>Many graphical user libraries have their own functions to do this kind of thing.</code></p><h3 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a><code>Summary</code></h3><p><code>New programmers often mix up std::cin, std::cout, the insertion operator</code> (<code>&lt;&lt;</code>) <code>and the extraction operator</code> (<code>&gt;&gt;</code>). <code>Here’s an easy way to remember:</code></p><ul><li><code>std::cin</code> and <code>std::cout</code> <code>always go on the left-hand side of the statement.</code></li><li><code>std::cout</code> <code>is used to output a value (cout = character output)</code></li><li><code>std::cin</code> <code>is used to get an input value (cin = character input)</code></li><li><code>&lt;&lt;</code> <code>is used with std::cout, and shows the direction that data is moving</code> (if <code>std::cout</code> <code>represents the console, the output data is moving from the variable to the console).</code> <code>std::cout &lt;&lt; 4</code> <code>moves the value of 4 to the console</code></li><li><code>&gt;&gt;</code> <code>is used with</code> <code>std::cin</code>, <code>and shows the direction that data is moving</code> (if std::cin <code>represents the keyboard, the input data is moving from the keyboard to the variable).</code> <code>std::cin &gt;&gt; x</code> <code>moves the value the user entered from the keyboard into x</code></li></ul><h2 id="Uninitialized-variables-and-undefined-behavior"><a href="#Uninitialized-variables-and-undefined-behavior" class="headerlink" title="Uninitialized variables and undefined behavior"></a><code>Uninitialized variables and undefined behavior</code></h2><h3 id="Uninitialized-variables"><a href="#Uninitialized-variables" class="headerlink" title="Uninitialized variables"></a><strong><code>Uninitialized variables</code></strong></h3><p>​        <code>Unlike some programming languages, C/C++ does not initialize most variables to a given value (such as zero) automatically. Thus when a variable is given a memory address to use to store data, the default value of that variable is whatever (garbage) value happens to already be in that memory address! A variable that has not been given a known value (usually through initialization or assignment) is called an uninitialized variable.</code></p><h4 id="Author’s-note-8"><a href="#Author’s-note-8" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>Many readers expect the terms “initialized” and “uninitialized” to be strict opposites, but they aren’t quite! Initialization means the object was provided with an initial value at the point of definition. Uninitialized means the object has not been given a known value (through any means, including assignment). Therefore, an object that is not initialized but is then assigned a value is no longer uninitialized (because it has been given a known value).</code></p><p><code>To recap:</code></p><ul><li><code>Initialization = The object is given a known value at the point of definition.</code></li><li><code>Assignment = The object is given a known value beyond the point of definition.</code></li><li><code>Uninitialized = The object has not been given a known value yet.</code></li></ul><p><code>As an aside…</code></p><p>​        <code>This lack of initialization is a performance optimization inherited from C, back when computers were slow. Imagine a case where you were going to read in 100,000 values from a file. In such case, you might create 100,000 variables, then fill them with data from the file.</code></p><p>​        <code>If C++ initialized all of those variables with default values upon creation, this would result in 100,000 initializations (which would be slow), and for little benefit (since you’re overwriting those values anyway).</code></p><p>​        <code>For now, you should always initialize your variables because the cost of doing so is miniscule compared to the benefit. Once you are more comfortable with the language, there may be certain cases where you omit the initialization for optimization purposes. But this should always be done selectively and intentionally.</code></p><p>​        <code>Using the values of uninitialized variables can lead to unexpected results. Consider the following short program:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// define an integer variable named x</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token comment">// this variable is uninitialized because we haven't given it a value</span>    <span class="token comment">// print the value of x to the screen</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token comment">// who knows what we'll get, because x is uninitialized</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>In this case, the computer will assign some unused memory to x. It will then send the value residing in that memory location to std::cout, which will print the value (interpreted as an integer). But what value will it print? The answer is “who knows!”, and the answer may (or may not) change every time you run the program. When the author ran this program in Visual Studio, std::cout printed the value 7177728 one time, and 5277592 the next. Feel free to compile and run the program yourself (your computer won’t explode).</code></p><h4 id="Warning-5"><a href="#Warning-5" class="headerlink" title="Warning"></a><code>Warning</code></h4><p>​        <code>Some compilers, such as Visual Studio, will initialize the contents of memory to some preset value when you’re using a debug build configuration. This will not happen when using a release build configuration. Therefore, if you want to run the above program yourself, make sure you’re using a release build configuration For example, if you run the above program in a Visual Studio debug configuration, it will consistently print -858993460, because that’s the value (interpreted as an integer) that Visual Studio initializes memory with in debug configurations.</code></p><p>​        <code>Most modern compilers will attempt to detect if a variable is being used without being given a value. If they are able to detect this, they will generally issue a compile-time warning or error. For example, compiling the above program on Visual Studio produced the following warning:</code></p><pre class="line-numbers language-none"><code class="language-none">c:\VCprojects\test\test.cpp(11) : warning C4700: uninitialized local variable &#39;x&#39; used<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <code>If your compiler won’t let you compile and run the above program (e.g. because it treats the issue as an error), here is a possible solution to get around this issue:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token comment">// Don't worry about what &amp; is for now, we're just using it to trick the compiler into thinking variable x is used</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// define an integer variable named x</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token comment">// this variable is uninitialized</span>    <span class="token function">doNothing</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// make the compiler think we're assigning a value to this variable</span>    <span class="token comment">// print the value of x to the screen (who knows what we'll get, because x is uninitialized)</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Using uninitialized variables is one of the most common mistakes that novice programmers make, and unfortunately, it can also be one of the most challenging to debug (because the program may run fine anyway if the uninitialized variable happened to get assigned to a spot of memory that had a reasonable value in it, like 0).</code></p><p>​        <code>This is the primary reason for the “always initialize your variables” best practice.</code></p><h3 id="Undefined-behavior"><a href="#Undefined-behavior" class="headerlink" title="Undefined behavior"></a><code>Undefined behavior</code></h3><p>​        <code>Using the value from an uninitialized variable is our first example of undefined behavior. Undefined behavior (often abbreviated UB) is the result of executing code whose behavior is not well-defined by the C++ language. In this case, the C++ language doesn’t have any rules determining what happens if you use the value of a variable that has not been given a known value. Consequently, if you actually do this, undefined behavior will result.</code></p><p>​        <code>Code implementing undefined behavior may exhibit any of the following symptoms:</code></p><ul><li><code>Your program produces different results every time it is run.</code></li><li><code>Your program consistently produces the same incorrect result.</code></li><li><code>Your program behaves inconsistently (sometimes produces the correct result, sometimes not).</code></li><li><code>Your program seems like it’s working but produces incorrect results later in the program.</code></li><li><code>Your program crashes, either immediately or later.</code></li><li><code>Your program works on some compilers but not others.</code></li><li><code>Your program works until you change some other seemingly unrelated code.</code></li></ul><p>​        <code>Or, your code may actually produce the correct behavior anyway.</code></p><h4 id="Author’s-note-9"><a href="#Author’s-note-9" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>Undefined behavior is like a box of chocolates. You never know what you’re going to get!</code></p><p>​        <code>C++ contains many cases that can result in undefined behavior if you’re not careful. We’ll point these out in future lessons whenever we encounter them. Take note of where these cases are and make sure you avoid them.</code></p><h4 id="Rule-2"><a href="#Rule-2" class="headerlink" title="Rule"></a><code>Rule</code></h4><p>​        <code>Take care to avoid all situations that result in undefined behavior, such as using uninitialized variables.</code></p><h4 id="Author’s-note-10"><a href="#Author’s-note-10" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>One of the most common types of comment we get from readers says, “You said I couldn’t do X, but I did it anyway and my program works! Why?”.</code></p><p>​        <code>There are two common answers. The most common answer is that your program is actually exhibiting undefined behavior, but that undefined behavior just happens to be producing the result you wanted anyway… for now. Tomorrow (or on another compiler or machine) it might not.</code></p><p>​        <code>Alternatively, sometimes compiler authors take liberties with the language requirements when those requirements may be more restrictive than needed. For example, the standard may say, “you must do X before Y”, but a compiler author may feel that’s unnecessary, and make Y work even if you don’t do X first. This shouldn’t affect the operation of correctly written programs, but may cause incorrectly written programs to work anyway. So an alternate answer to the above question is that your compiler may simply be not following the standard! It happens. You can avoid much of this by making sure you’ve turned compiler extensions off</code></p><h3 id="Implementation-defined-behavior-and-unspecified-behavior"><a href="#Implementation-defined-behavior-and-unspecified-behavior" class="headerlink" title="Implementation-defined behavior and unspecified behavior"></a><code>Implementation-defined behavior and unspecified behavior</code></h3><p>​        <code>Implementation-defined behavior means the behavior of some syntax is left up to the implementation (the compiler) to define. Such behaviors must be consistent and documented, but different compilers may produce different results.</code></p><p>​        <code>Let’s look at a simple example of implementation-defined behavior:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// print how many bytes of memory an int value takes</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>On most compilers, this will produce</code>4<code>, but on others it may produce</code> <code>2</code>.</p><p>​        <code>Unspecified behavior is almost identical to implementation-defined behavior in that the behavior is left up to the implementation, but the implementation is not required to document the behavior.</code></p><p>​        <code>We generally want to avoid implementation-defined and unspecified behavior, as it means our program may not work as expected if compiled on a different compiler (or even on the same compiler if we change project settings that affect how the implementation behaves!)</code></p><h4 id="Best-practice-16"><a href="#Best-practice-16" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>Avoid implementation-defined and unspecified behavior whenever possible, as they may cause your program to malfunction on other implementations.</code></p><h2 id="Keywords-and-naming-identifiers"><a href="#Keywords-and-naming-identifiers" class="headerlink" title="Keywords and naming identifiers"></a><code>Keywords and naming identifiers</code></h2><h3 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a><strong><code>Keywords</code></strong></h3><p>​        <code>C++ reserves a set of 92 words (as of C++20) for its own use. These words are called keywords (or reserved words), and each of these keywords has a special meaning within the C++ language.</code></p><p>​        <code>Here is a list of all the C++ keywords (through C++20):</code></p><div class="table-container"><table><thead><tr><th>keyWords</th><th>keyWords</th><th>keyWords</th><th>keyWords</th></tr></thead><tbody><tr><td>alignas</td><td>const_cast</td><td>int</td><td>static_assert</td></tr><tr><td>alignof</td><td>continue</td><td>long</td><td>static_cast</td></tr><tr><td>and</td><td>co_await (since C++20)</td><td>mutable</td><td>struct</td></tr><tr><td>and_eq</td><td>co_return (since C++20)</td><td>namespace</td><td>switch</td></tr><tr><td>asm</td><td>co_yield (since C++20)</td><td>new</td><td>template</td></tr><tr><td>auto</td><td>decltype</td><td>noexcept</td><td>this</td></tr><tr><td>bitand</td><td>default</td><td>not</td><td>thread_local</td></tr><tr><td>bitor</td><td>delete</td><td>not_eq</td><td>throw</td></tr><tr><td>bool</td><td>do</td><td>nullptr</td><td>true</td></tr><tr><td>break</td><td>double</td><td>operator</td><td>try</td></tr><tr><td>case</td><td>dynamic_cast</td><td>or</td><td>typedef</td></tr><tr><td>catch</td><td>else</td><td>or_eq</td><td>typeid</td></tr><tr><td>char</td><td>enum</td><td>private</td><td>typename</td></tr><tr><td>char8_t (since C++20)</td><td>explicit</td><td>protected</td><td>union</td></tr><tr><td>char16_t</td><td>export</td><td>public</td><td>unsigned</td></tr><tr><td>char32_t</td><td>extern</td><td>register</td><td>using</td></tr><tr><td>class</td><td>false</td><td>reinterpret_cast</td><td>virtual</td></tr><tr><td>compl</td><td>float</td><td>requires (since C++20)</td><td>void</td></tr><tr><td>concept (since C++20)</td><td>for</td><td>return</td><td>volatile</td></tr><tr><td>const</td><td>friend</td><td>short</td><td>wchar_t</td></tr><tr><td>consteval (since C++20)</td><td>goto</td><td>signed</td><td>while</td></tr><tr><td>constexpr</td><td>if</td><td>sizeof</td><td>xor</td></tr><tr><td>constinit (since C++20)</td><td>inline</td><td>static</td><td>xor_eq</td></tr></tbody></table></div><p>​        <code>The keywords marked (C++20) were added in C++20. If your compiler is not C++20 compliant (or does have C++20 functionality, but it’s turned off by default), these keywords may not be functional.</code></p><p>​        <code>C++ also defines special identifiers: override, final, import, and module. These have a specific meaning when used in certain contexts but are not reserved.</code></p><p>​        <code>You have already run across some of these keywords, including *int* and *return*. Along with a set of operators, these keywords and special identifiers define the entire language of C++ (preprocessor commands excluded). Because keywords and special identifiers have special meaning, your IDEs will likely change the text color of these words to make them stand out from other identifiers.</code></p><p>​        <code>By the time you are done with this tutorial series, you will understand what almost all of these words do!</code></p><h3 id="Identifier-naming-rules"><a href="#Identifier-naming-rules" class="headerlink" title="Identifier naming rules"></a><code>Identifier naming rules</code></h3><p>​        <code>As a reminder, the name of a variable (or function, type, or other kind of item) is called an identifier. C++ gives you a lot of flexibility to name identifiers as you wish. However, there are a few rules that must be followed when naming identifiers:</code></p><ul><li><p><code>The identifier can not be a keyword. Keywords are reserved.</code></p></li><li><p><code>The identifier can only be composed of letters (lower or upper case), numbers, and the underscore character. That means the name can not contain symbols (except the underscore) nor whitespace (spaces or tabs).</code></p></li><li><p><code>The identifier must begin with a letter (lower or upper case) or an underscore. It can not start with a number.</code></p></li><li><p><code>C++ is case sensitive, and thus distinguishes between lower and upper case letters.</code> </p><pre class="line-numbers language-none"><code class="language-none">nvalue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>is different than</p><pre class="line-numbers language-none"><code class="language-none">nValue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>is different than</p><pre class="line-numbers language-none"><code class="language-none">NVALUE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>.</p></li></ul><h3 id="Identifier-naming-best-practices"><a href="#Identifier-naming-best-practices" class="headerlink" title="Identifier naming best practices"></a><code>Identifier naming best practices</code></h3><p>​        <code>Now that you know how you *can* name a variable, let’s talk about how you *should* name a variable (or function).</code></p><p>​        <code>First, it is a convention in C++ that variable names should begin with a lowercase letter. If the variable name is one word, the whole thing should be written in lowercase letters.</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> value<span class="token punctuation">;</span> <span class="token comment">// correct</span><span class="token keyword">int</span> Value<span class="token punctuation">;</span> <span class="token comment">// incorrect (should start with lower case letter)</span><span class="token keyword">int</span> VALUE<span class="token punctuation">;</span> <span class="token comment">// incorrect (should start with lower case letter)</span><span class="token keyword">int</span> VaLuE<span class="token punctuation">;</span> <span class="token comment">// incorrect (see your psychiatrist) ;)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Most often, function names are also started with a lowercase letter (though there’s some disagreement on this point). We’ll follow this convention, since function main (which all programs must have) starts with a lowercase letter, as do all of the functions in the C++ standard library.</code>        </p><p>​        <code>Identifier names that start with a capital letter are typically used for user-defined types (such as structs, classes, and enumerations, all of which we will cover later).</code></p><p>​        <code>If the variable or function name is multi-word, there are two common conventions: words separated by underscores, called snake_case, or intercapped (sometimes called camelCase, since the capital letters stick up like the humps on a camel).</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> my_variable_name<span class="token punctuation">;</span> <span class="token comment">// correct (separated by underscores/snake_case)</span><span class="token keyword">int</span> <span class="token function">my_function_name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// correct (separated by underscores/snake_case)</span><span class="token keyword">int</span> myVariableName<span class="token punctuation">;</span> <span class="token comment">// correct (intercapped/CamelCase)</span><span class="token keyword">int</span> <span class="token function">myFunctionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// correct (intercapped/CamelCase)</span><span class="token keyword">int</span> my variable name<span class="token punctuation">;</span> <span class="token comment">// invalid (whitespace not allowed)</span><span class="token keyword">int</span> my function <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// invalid (whitespace not allowed)</span><span class="token keyword">int</span> MyVariableName<span class="token punctuation">;</span> <span class="token comment">// valid but incorrect (should start with lower case letter)</span><span class="token keyword">int</span> <span class="token function">MyFunctionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// valid but incorrect (should start with lower case letter)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>In this tutorial, we will typically use the intercapped approach because it’s easier to read (it’s easy to mistake an underscore for a space in dense blocks of code). But it’s common to see either -- the C++ standard library uses the underscore method for both variables and functions. Sometimes you’ll see a mix of the two: underscores used for variables and intercaps used for functions.</code></p><p>​        <code>It’s worth noting that if you’re working in someone else’s code, it’s generally considered better to match the style of the code you are working in than to rigidly follow the naming conventions laid out above.</code></p><h4 id="Best-practice-17"><a href="#Best-practice-17" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>When working in an existing program, use the conventions of that program (even if they don’t conform to modern best practices). Use modern best practices when you’re writing new programs.</code></p><p>​        <code>Second, you should avoid naming your identifiers starting with an underscore, as these names are typically reserved for OS, library, and/or compiler use.</code></p><p>​        <code>Third, your identifiers should make clear what the value they are holding means (particularly if the units aren’t obvious). Identifiers should be named in a way that would help someone who has no idea what your code does be able to figure it out as quickly as possible. In 3 months, when you look at your program again, you’ll have forgotten how it works, and you’ll thank yourself for picking variable names that make sense.</code></p><p>​        <code>However, giving a trivial variable an overly complex name impedes overall understanding of what the program is doing almost as much as giving a widely used identifier an inadequate name. Therefore, a good rule of thumb is to make the length of an identifier proportional to how widely it is used. An identifier with a trivial use can have a short name (e.g. such as *i*). An identifier that is used more broadly (e.g. a function that is called from many different places in a program) should have a longer and more descriptive name (e.g. instead of *open*, try *openFileOnDisk*).</code></p><div class="table-container"><table><thead><tr><th>int ccount</th><th>Bad</th><th>What does the c before “count” stand for?</th></tr></thead><tbody><tr><td>int customerCount</td><td>Good</td><td>Clear what we’re counting</td></tr><tr><td>int i</td><td>Either</td><td>Okay if use is trivial, bad otherwise</td></tr><tr><td>int index</td><td>Either</td><td>Okay if obvious what we’re indexing</td></tr><tr><td>int totalScore</td><td>Either</td><td>Okay if there’s only one thing being scored, otherwise too ambiguous</td></tr><tr><td>int _count</td><td>Bad</td><td>Do not start names with underscore</td></tr><tr><td>int count</td><td>Either</td><td>Okay if obvious what we’re counting</td></tr><tr><td>int data</td><td>Bad</td><td>What kind of data?</td></tr><tr><td>int time</td><td>Bad</td><td>Is this in seconds, minutes, or hours?</td></tr><tr><td>int minutesElapsed</td><td>Good</td><td>Descriptive</td></tr><tr><td>int value1, value2</td><td>Either</td><td>Can be hard to differentiate between the two</td></tr><tr><td>int numApples</td><td>Good</td><td>Descriptive</td></tr><tr><td>int monstersKilled</td><td>Good</td><td>Descriptive</td></tr><tr><td>int x, y</td><td>Either</td><td>Okay if use is trivial, bad otherwise</td></tr></tbody></table></div><p>​        <code>In any case, avoid abbreviations (unless they are common/unambiguous). Although they reduce the time you need to write your code, they make your code harder to read. Code is read more often than it is written, the time you saved while writing the code is time that every reader, including the future you, wastes when reading it. If you’re looking to write code faster, use your editor’s auto-complete feature.</code></p><p>​        <code>Finally, a clarifying comment can go a long way. For example, say we’ve declared a variable named numberOfChars that is supposed to store the number of characters in a piece of text. Does the text “Hello World!” have 10, 11, or 12 characters? It depends on whether we’re including whitespace or punctuation. Rather than naming the variable numberOfCharsIncludingWhitespaceAndPunctuation, which is rather lengthy, a well placed comment on the declaration line should help the user figure it out:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// holds number of chars in a piece of text -- including whitespace and punctuation!</span><span class="token keyword">int</span> numberOfChars<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Whitespace-and-basic-formatting"><a href="#Whitespace-and-basic-formatting" class="headerlink" title="Whitespace and basic formatting"></a><code>Whitespace and basic formatting</code></h2><p>​        <code>Whitespace is a term that refers to characters that are used for formatting purposes. In C++, this refers primarily to spaces, tabs, and newlines. The C++ compiler generally ignores whitespace, with a few minor exceptions (when processing text literals). For this reason, we say that C++ is a whitespace-independent language.</code></p><p>​        <code>Consequently, the following statements all do the exact same thing:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout               <span class="token operator">&lt;&lt;</span>            <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Even the last statement that is split over two lines compiles just fine.</code></p><p>​        <code>The following functions all do the same thing:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>One exception where the C++ compiler *does* pay attention to whitespace is inside quoted text, such as</code> </p><pre class="line-numbers language-none"><code class="language-none">&quot;Hello world!&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>is different than:</code></p><pre class="line-numbers language-none"><code class="language-none">&quot;Hello     world!&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>and each prints out exactly as you’d expect.</code></p><p><code>Newlines are not allowed in quoted text:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> "Hello     world<span class="token operator">!</span>"<span class="token punctuation">;</span> <span class="token comment">// Not allowed!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Quoted text separated by nothing but whitespace (spaces, tabs, or newlines) will be concatenated:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello "</span>     <span class="token string">"world!"</span><span class="token punctuation">;</span> <span class="token comment">// prints "Hello world!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>Another exception where the C++ compiler pays attention to whitespace is with // comments. Single-line comments only last to the end of the line. Thus doing something like this will get you in trouble:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span> <span class="token comment">// Here is a single-line comment</span><span class="token keyword">this</span> is <span class="token operator">not</span> part of the comment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="Basic-formatting"><a href="#Basic-formatting" class="headerlink" title="Basic formatting"></a><code>Basic formatting</code></h3><p>​        <code>Unlike some other languages, C++ does not enforce any kind of formatting restrictions on the programmer (remember, trust the programmer!). Many different methods of formatting C++ programs have been developed throughout the years, and you will find disagreement on which ones are best. Our basic rule of thumb is that the best styles are the ones that produce the most readable code, and provide the most consistency.</code></p><p><code>Here are our recommendations for basic formatting:</code></p><ol><li><code>It’s fine to use either tabs or spaces for indentation (most IDEs have a setting where you can convert a tab press into the appropriate number of spaces). Developers who prefer spaces tend to do so because it makes the formatting self-describing -- code that is spaced using spaces will always look correct regardless of editor. Proponents of using tabs wonder why you wouldn’t use the character designed to do indentation for indentation, especially as you can set the width to whatever your preference is. There’s no right answer here -- and debating it is like arguing whether cake or pie is better. It ultimately comes down to personal preference.</code></li></ol><p>​        <code>Either way, we recommend you set your tabs to 4 spaces worth of indentation. Some IDEs default to 3 spaces of indentation, which is fine too.</code></p><ol><li><code>There are two acceptable styles for function braces.</code></li></ol><p>​        <code>The Google C++ style guide recommends putting the opening curly brace on the same line as the statement:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>The justification for this is that it reduces the amount of vertical whitespace (you aren’t devoting an entire line to nothing but the opening curly brace), so you can fit more code on a screen. More code on a screen makes the program easier to understand.</code></p><p>​        <code>However, we prefer the common alternative, where the opening brace appears on its own line:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>This enhances readability, and is less error prone since your brace pairs should always be indented at the same level. If you get a compiler error due to a brace mismatch, it’s very easy to see where.</code></p><ol><li><code>Each statement within curly braces should start one tab in from the opening brace of the function it belongs to. For example:</code></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!\n"</span><span class="token punctuation">;</span> <span class="token comment">// tabbed in one tab (4 spaces)</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Nice to meet you.\n"</span><span class="token punctuation">;</span> <span class="token comment">// tabbed in one tab (4 spaces)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>Lines should not be too long. Typically, 80 characters has been the de facto standard for the maximum length a line should be. If a line is going to be longer, it should be split (at a reasonable spot) into multiple lines. This can be done by indenting each subsequent line with an extra tab, or if the lines are similar, by aligning it with the line above (whichever is easier to read).</code></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This is a really, really, really, really, really, really, really, "</span>        <span class="token string">"really long line\n"</span><span class="token punctuation">;</span> <span class="token comment">// one extra indentation for continuation line</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This is another really, really, really, really, really, really, really, "</span>                 <span class="token string">"really long line\n"</span><span class="token punctuation">;</span> <span class="token comment">// text aligned with the previous line for continuation line</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"This one is short\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>This makes your lines easier to read. On modern wide-screen monitors, it also allows you to place two windows with similar code side by side and compare them more easily.</code></p><h4 id="Best-practice-18"><a href="#Best-practice-18" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p><code>Consider keeping your lines to 80 chars or less in length.</code></p><p><code>Tip</code></p><p>​        <code>Many editors have a built-in feature (or plugin/extension) that will show a line (called a “column guide”) at a given column (e.g. at 80 characters), so you can easily see when your lines are getting too long. To see if your editor supports this, do a search on your editor’s name + “Column guide”.</code></p><ol><li><code>If a long line is split with an operator (eg. &lt;&lt; or +), the operator should be placed at the beginning of the next line, not the end of the current line</code></li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4</span>    <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">6</span>    <span class="token operator">*</span> <span class="token number">7</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>This helps make it clearer that subsequent lines are continuations of the previous lines, and allows you to align the operators on the left, which makes for easier reading.</code></p><ol><li><code>Use whitespace to make your code easier to read by aligning values or comments or adding spacing between blocks of code.</code></li></ol><p>​        <code>Harder to read:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cost <span class="token operator">=</span> <span class="token number">57</span><span class="token punctuation">;</span>pricePerItem <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>value <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>numberOfItems <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Easier to read:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cost          <span class="token operator">=</span> <span class="token number">57</span><span class="token punctuation">;</span>pricePerItem  <span class="token operator">=</span> <span class="token number">24</span><span class="token punctuation">;</span>value         <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>numberOfItems <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Harder to read:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!\n"</span><span class="token punctuation">;</span> <span class="token comment">// cout lives in the iostream library</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It is very nice to meet you!\n"</span><span class="token punctuation">;</span> <span class="token comment">// these comments make the code hard to read</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yeah!\n"</span><span class="token punctuation">;</span> <span class="token comment">// especially when lines are different lengths</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>Easier to read:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!\n"</span><span class="token punctuation">;</span>                  <span class="token comment">// cout lives in the iostream library</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It is very nice to meet you!\n"</span><span class="token punctuation">;</span>  <span class="token comment">// these comments are easier to read</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yeah!\n"</span><span class="token punctuation">;</span>                         <span class="token comment">// especially when all lined up</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <code>Harder to read:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// cout lives in the iostream library</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!\n"</span><span class="token punctuation">;</span><span class="token comment">// these comments make the code hard to read</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It is very nice to meet you!\n"</span><span class="token punctuation">;</span><span class="token comment">// especially when all bunched together</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yeah!\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>Easier to read:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// cout lives in the iostream library</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!\n"</span><span class="token punctuation">;</span><span class="token comment">// these comments are easier to read</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"It is very nice to meet you!\n"</span><span class="token punctuation">;</span><span class="token comment">// when separated by whitespace</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Yeah!\n"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>We will follow these conventions throughout this tutorial, and they will become second nature to you. As we introduce new topics to you, we will introduce new style recommendations to go with those features.</code></p><p>​        <code>Ultimately, C++ gives you the power to choose whichever style you are most comfortable with, or think is best. However, we highly recommend you utilize the same style that we use for our examples. It has been battle tested by thousands of programmers over billions of lines of code, and is optimized for success. One exception: If you are working in someone else’s code base, adopt their styles. It’s better to favor consistency than your preferences.</code></p><h3 id="Automatic-formatting"><a href="#Automatic-formatting" class="headerlink" title="Automatic formatting"></a><code>Automatic formatting</code></h3><p>​        <code>Most modern IDEs will help you format your code as you type it in (e.g. when you create a function, the IDE will automatically indent the statements inside the function body).</code></p><p>​        <code>However, as you add or remove code, or change the IDE’s default formatting, or paste in a block of code that has different formatting, the formatting can get messed up. Fixing the formatting for part or all of a file can be a headache. Fortunately, modern IDEs typically contain an automatic formatting feature that will reformat either a selection (highlighted with your mouse) or an entire file.</code></p><h4 id="For-Visual-Studio-users-7"><a href="#For-Visual-Studio-users-7" class="headerlink" title="For Visual Studio users"></a><code>For Visual Studio users</code></h4><p>​        <code>In Visual Studio, the automatic formatting options can be found under Edit &gt; Advanced &gt; Format Document and Edit &gt; Advanced &gt; Format Selection.</code></p><h4 id="For-Code-Blocks-users-7"><a href="#For-Code-Blocks-users-7" class="headerlink" title="For Code::Blocks users"></a><code>For Code::Blocks users</code></h4><p>​        <code>In Code::Blocks, the automatic formatting options can be found under Right mouse click &gt; Format use AStyle.</code></p><p>​        <code>For easier access, we recommend adding a keyboard shortcut to auto-format the active file.</code></p><p>​        <code>There are also external tools that can be used to automatically format code.</code><a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a> <code>is a popular one.</code></p><h4 id="Best-practice-19"><a href="#Best-practice-19" class="headerlink" title="Best practice"></a><code>Best practice</code></h4><p>​        <code>Using the automatic formatting feature is highly recommended to keep your code’s formatting style consistent.</code></p><h2 id="Introduction-to-literals-and-operators"><a href="#Introduction-to-literals-and-operators" class="headerlink" title="Introduction to literals and operators"></a><code>Introduction to literals and operators</code></h2><h3 id="Literals"><a href="#Literals" class="headerlink" title="Literals"></a><code>Literals</code></h3><p>​        <code>Consider the following two statements:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello world!"</span><span class="token punctuation">;</span><span class="token keyword">int</span> x <span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>What are ‘”Hello world!”‘ and ‘5’? They are literals. A literal (also known as a literal constant) is a fixed value that has been inserted directly into the source code.</code></p><p>​        <code>Literals and variables both have a value (and a type). Unlike a variable (whose value can be set and changed through initialization and assignment respectively), the value of a literal is fixed</code> (<code>5</code> is always <code>5</code>). <code>This is why literals are called constants.</code></p><p>​        <code>To further highlight the difference between literals and variables, let’s examine this short program:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">5</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token comment">// print the value of a literal</span>    <span class="token keyword">int</span> x <span class="token punctuation">&#123;</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token comment">// print the value of a variable</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>On line 5, we’re printing the value</code>5<code>to the console. When the compiler compiles this, it will generate code that causes ``std::cout</code> <code>to print the value</code>5<code>. This value</code>5<code>is compiled into the executable and can be used directly.</code></p><p>​        <code>On line 7, we’re creating a variable named</code>x<code>, and initializing it with value</code>5<code>. The compiler will generate code that copies the literal value</code>5<code>into whatever memory location is given to</code>x<code>. On line 8, when we print</code>x<code>, the compiler will generate code that causes std::cout to print the value at the memory location ofx (which has value</code>5<code>).</code></p><p>​        <code>Thus, both output statements do the same thing (print the value 5). But in the case of the literal, the value</code>5<code>can be printed directly. In the case of the variable, the value</code>5<code>must be fetched from the memory the variable represents.</code></p><p>​        <code>This also explains why a literal is constant while a variable can be changed. A literal’s value is placed directly in the executable, and the executable itself can’t be changed after it is created. A variable’s value is placed in memory, and the value of memory can be changed while the executable is running.</code></p><h4 id="Key-insight-3"><a href="#Key-insight-3" class="headerlink" title="Key insight"></a><code>Key insight</code></h4><p>​        <code>Literals are values that are inserted directly into the source code. These values usually appear directly in the executable code (unless they are optimized out).</code></p><p>​        <code>Objects and variables represent memory locations that hold values. These values can be fetched on demand.</code></p><h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a><code>Operators</code></h3><p>​        <code>In mathematics, an operation is a mathematical process involving zero or more input values (called operands) that produces a new value (called an output value). The specific operation to be performed is denoted by a symbol called an operator.</code></p><p>​        <code>For example, as children we all learn that 2 + 3 equals 5. In this case, the literals 2 and 3 are the operands, and the symbol + is the operator that tells us to apply mathematical addition on the operands to produce the new value 5.</code></p><p>​        <code>In C++, operations work as you’d expect. For example:</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>In this program, the literals</code>1<code>and</code>2<code>are operands to the plus (</code>+<code>) operator, which produces the output value</code>3<code>. This output value is then printed to the console. In C++, the output value of an operation is often called a return value.</code></p><p>​        <code>You are likely already quite familiar with standard arithmetic operators from common usage in mathematics, including addition (</code>+<code>), subtraction (</code>-<code>), multiplication (</code>*<code>), and division (</code>/<code>). In C++, assignment (</code>=<code>) is an operator as well, as are insertion (</code>&lt;&lt;<code>), extraction (</code>&gt;&gt;<code>), and equality (</code>==<code>). While most operators have symbols for names (e.g. +</code>, or <code>==</code>), <code>there are also a number of operators that are keywords</code> (e.g. <code>new</code>, <code>delete</code>, and <code>throw</code>).</p><h4 id="Author’s-note-11"><a href="#Author’s-note-11" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>For reasons that will become clear when we discuss operators in more detail, for operators that are symbols, it is common to append the operator’s symbol to the word operator.</code></p><p>​        <code>For example, the plus operator would be written</code>operator+<code>, and the extraction operator would be written</code>operator&gt;&gt;<code>.</code></p><p>​        <code>The number of operands that an operator takes as input is called the operator’s **arity**. Few people know what this word means, so don’t drop it in a conversation and expect anybody to have any idea what you’re talking about. Operators in C++ come in four different arities:</code></p><p>​        <code>Unary operators act on one operand. An example of a unary operator is the</code>-<code>operator. For example, given</code>-5<code>,</code>operator-<code>takes literal operand</code>5<code>and flips its sign to produce new output value</code>-5`</p><p>​        <code>Binary operators act on two operands (often called *left* and *right*, as the left operand appears on the left side of the operator, and the right operand appears on the right side of the operator). An example of a binary operator is the</code>+<code>operator. For example, given</code>3 + 4<code>,</code>operator+<code>takes the left operand</code>3<code>and the right operand</code>4<code>and applies mathematical addition to produce new output value</code>7<code>. The insertion (</code>&lt;&lt;<code>) and extraction (</code>&gt;&gt;<code>) operators are binary operators, taking</code>std::cout<code>or</code>std::cin<code>on the left side, and the value to output or variable to input to on the right side.</code></p><p>​        <code>Ternary operators act on three operands. There is only one of these in C++ (the conditional operator), which we’ll cover later.</code></p><p>​        <code>Nullary operators act on zero operands. There is also only one of these in C++ (the throw operator), which we’ll also cover later.</code></p><p>​        <code>Note that some operators have more than one meaning depending on how they are used. For example,</code>operator-<code>has two contexts. It can be used in unary form to invert a number’s sign (e.g. to convert</code>5<code>to</code>-5<code>, or vice versa), or it can be used in binary form to do subtraction (e.g.</code>4 - 3<code>).</code></p><h3 id="Chaining-operators"><a href="#Chaining-operators" class="headerlink" title="Chaining operators"></a><code>Chaining operators</code></h3><p>​        <code>Operators can be chained together such that the output of one operator can be used as the input for another operator. For example, given the following:</code>2 * 3 + 4<code>, the multiplication operator goes first, and converts left operand</code>2<code>and right operand</code>3<code>into return value</code>6<code>(which becomes the left operand for the plus operator). Next, the plus operator executes, and converts left operand</code>6<code>and right operand</code>4<code>into new value</code>10`.</p><p>​        <code>We’ll talk more about the order in which operators execute when we do a deep dive into the topic of operators. For now, it’s enough to know that the arithmetic operators execute in the same order as they do in standard mathematics: Parenthesis first, then Exponents, then Multiplication &amp; Division, then Addition &amp; Subtraction. This ordering is sometimes abbreviated *PEMDAS*, or expanded to the mnemonic “Please Excuse My Dear Aunt Sally”.</code></p><h4 id="Author’s-note-12"><a href="#Author’s-note-12" class="headerlink" title="Author’s note"></a><code>Author’s note</code></h4><p>​        <code>In some countries, PEMDAS is taught as PEDMAS, BEDMAS, BODMAS, or BIDMAS instead.</code></p><h3 id="Return-values-and-side-effects"><a href="#Return-values-and-side-effects" class="headerlink" title="Return values and side effects"></a><code>Return values and side effects</code></h3><p>​        <code>Most operators in C++ just use their operands to calculate a return value. For example,</code>-5<code>produces return value</code>-5<code>and</code>2 + 3<code>produces return value</code>5<code>. There are a few operators that do not produce return values</code>(such as <code>delete</code> and <code>throw</code>). <code>We’ll cover what these do later.</code></p><p>​        <code>Some operators have additional behaviors. An operator that has some observable effect beyond producing a return value is said to have a side effect. For example, when</code>x = 5<code>is evaluated, the assignment operator has the side effect of assigning the value</code>5<code>to variable</code>x<code>. The changed value of</code>x<code>is observable (e.g. by printing the value of</code>x<code>) even after the operator has finished executing.</code>std::cout &lt;&lt; 5<code>has the side effect of printing</code>5<code>to the console. We can observe the fact that</code>5<code>has been printed to the console even after</code>std::cout &lt;&lt; 5<code>has finished executing.</code></p><p>​        <code>Operators with side effects are usually called for the behavior of the side effect rather than for the return value (if any) those operators produce.</code></p><h4 id="For-advanced-readers-5"><a href="#For-advanced-readers-5" class="headerlink" title="For advanced readers"></a><code>For advanced readers</code></h4><p>​        <code>For the operators that we call primarily for their return values (e.g.</code>operator+<code>or</code>operator*<code>), it’s usually obvious what their return values will be (e.g. the sum or product of the operands).</code></p><p>​        <code>For the operators we call primarily for their side effects (e.g.</code>operator=<code>or</code>operator&lt;&lt;<code>), it’s not always obvious what return values they produce (if any). For example, what return value would you expect</code>x = 5<code>to have?</code></p><p>​        <code>Both</code>operator=<code>and</code> <code>operator&lt;&lt;</code> (when used to output values to the console) return their left operand. Thus, <code>x = 5</code> returns <code>x</code>, and <code>std::cout &lt;&lt; 5</code> returns <code>std::cout</code>. This is done so that these operators can be chained.`</p><p><code>For example,</code>x = y = 5<code>evaluates as</code>x = (y = 5)<code>. First</code>y = 5<code>assigns</code>5<code>to</code>y<code>. This operation then returns</code>y<code>, which can then be assigned to</code>x<code>.</code></p><p><code>std::cout &lt;&lt; &quot;Hello &quot; &lt;&lt; &quot;world&quot;</code> <code>evaluates as</code> <code>(std::cout &lt;&lt; &quot;Hello &quot;) &lt;&lt; &quot;world!&quot;</code>. <code>This first prints</code> <code>&quot;Hello &quot;`` to the console. This operation</code> returns <code>std::cout</code>,<code>which can then be used to print</code>“world!”<code>to the console as well.</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeepLearningQt-ReadingDocuments1</title>
      <link href="/2023/06/07/DeepLearningQt-ReadingDocuments1/"/>
      <url>/2023/06/07/DeepLearningQt-ReadingDocuments1/</url>
      
        <content type="html"><![CDATA[<p>​        写在前面：这是阅读英文文档+我翻译+我阅读资料的博客，目的是为了浏览并通读基本的 QT常用类型！</p><h1 id="Qt深入理解-QString"><a href="#Qt深入理解-QString" class="headerlink" title="Qt深入理解 QString"></a>Qt深入理解 QString</h1><p>​        QString的内容是QCore下的 C++类的一个子类。想要使用它和相关的API函数，请务必：</p><pre class="line-numbers language-none"><code class="language-none">Header:  #include &lt;QString&gt; CMake: find_package(Qt6 REQUIRED COMPONENTS Core) target_link_libraries(mytarget PRIVATE Qt6::Core) qmake: QT +&#x3D; core<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="table-container"><table><thead><tr><th>MakeFileplatform</th><th>Actions</th></tr></thead><tbody><tr><td><code>#include</code></td><td><code>#include &lt;QString&gt;</code></td></tr><tr><td><code>Cmake</code></td><td><code>find_package(Qt6 REQUIRED COMPONENTS Core) target_link_libraries(mytarget PRIVATE Qt6::Core)</code></td></tr><tr><td><code>qmake</code></td><td><code>QT += core</code></td></tr></tbody></table></div><p><img src="image-20230606194623400.png" alt="image-20230606194623400"></p><p>​        在<code>QString</code>下，允许访问的类型如下：</p><div class="table-container"><table><thead><tr><th>num</th><th>Types</th></tr></thead><tbody><tr><td>1</td><td><code>ConstIterator</code></td></tr><tr><td>2</td><td><code>Iterator</code></td></tr><tr><td>3</td><td><code>enum NormalizationForm &#123; NormalizationForm_D, NormalizationForm_C, NormalizationForm_KD, NormalizationForm_KC &#125;</code></td></tr><tr><td>4</td><td><code>enum SectionFlag &#123; SectionDefault, SectionSkipEmpty, SectionIncludeLeadingSep, SectionIncludeTrailingSep, SectionCaseInsensitiveSeps &#125;</code></td></tr><tr><td>5</td><td><code>flags SectionFlags</code></td></tr><tr><td>6</td><td><code>const_iterator</code></td></tr><tr><td>7</td><td><code>const_pointer</code></td></tr><tr><td>8</td><td><code>const_reference</code></td></tr><tr><td>9</td><td><code>const_reverse_iterator</code></td></tr><tr><td>10</td><td><code>difference_type</code></td></tr><tr><td>11</td><td><code>iterator</code></td></tr><tr><td>12</td><td><code>pointer</code></td></tr><tr><td>13</td><td><code>reference</code></td></tr><tr><td>14</td><td><code>reverse_iterator</code></td></tr><tr><td>15</td><td><code>size_type</code></td></tr><tr><td>16</td><td><code>value_type</code></td></tr></tbody></table></div><p> 方便起见，我们顺序往下，遇到就阐述：            |</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><div class="table-container"><table><thead><tr><th>API</th></tr></thead><tbody><tr><td><code>QString()</code></td></tr><tr><td><code>QString(const QChar *unicode, qsizetype size = -1)</code></td></tr><tr><td><code>QString(QChar ch)</code></td></tr><tr><td><code>QString(qsizetype size, QChar ch)</code></td></tr><tr><td><code>QString(QLatin1StringView str)</code></td></tr><tr><td><code>QString(const int *str)</code></td></tr><tr><td><code>QString(const char *str)</code></td></tr><tr><td><code>QString(const QByteArray &amp;ba)</code></td></tr><tr><td><code>QString(const QString &amp;other)</code></td></tr><tr><td><code>QString(QString &amp;&amp;other)</code></td></tr><tr><td><code>~QString()</code></td></tr></tbody></table></div><p>​    1.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">constexpr QString::QString() noexcept<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Constructs a null string. Null strings are also considered empty.See also isEmpty(), isNull(), and Distinction Between Null and Empty Strings.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        也就是说，默认构造一个空的字符串！</p><p>2.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString::QString(const QChar *unicode, qsizetype size &#x3D; -1)explicit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Constructs a string initialized with the first size characters of the QChar array unicode.If unicode is 0, a null string is constructed.If size is negative, unicode is assumed to point to a \0&#39;-terminated array and its length is determined dynamically. The terminating null character is not considered part of the string.QString makes a deep copy of the string data. The unicode data is copied as is and the Byte Order Mark is preserved if present.See also fromRawData().<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        也就是说：构造一个用QChar数组unicode的第一个大小字符初始化的字符串。<strong>如果unicode为0，则构造一个空字符串。如果大小为负数，则假定unicode指向一个以\0’结尾的数组，并且其长度是动态确定的。终止的null字符不被视为字符串的一部分。QString对字符串数据进行深拷贝。unicode数据按原样复制，如果存在，则保留字节顺序标记。</strong></p><p>3.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString::QString(QChar ch)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Constructs a string of size 1 containing the character ch.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        构造一个只含有一个字符的字符串</p><p>4.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString::QString(qsizetype size, QChar ch)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Constructs a string of the given size with every character set to ch.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        构造一个只含有N个相同字符的字符串</p><p>5.</p><pre class="line-numbers language-none"><code class="language-none">QString::QString(QLatin1StringView str); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Constructs a copy of the Latin-1 string viewed by str.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="【QT】QLatin1String类的说明-补充"><a href="#【QT】QLatin1String类的说明-补充" class="headerlink" title="【QT】QLatin1String类的说明(补充)"></a>【QT】QLatin1String类的说明(补充)</h4><p>​        <code>QLatin1String</code>类对<code>US-ASCII/Latin-1编码</code>的字符串进行了简单封装，可理解为<code>关于const char*的一个浅封装</code>。</p><p>​        许多<code>QString</code>的成员函数都用<code>const char*</code>代替<code>QString</code>作为参数实现重载。这包含<strong>拷贝构造函数</strong>，<strong>赋值操作</strong>，<strong>比较操作</strong>和其他不同的函数，比如<code>insert()</code>, <code>replace(),</code> <code>indexOf()</code>. 这些函数都做了<strong>优化</strong>以避免在函数调用时从<code>const char*</code>中构造一个<code>QString</code>对象。例如，假定str是<a href="https://so.csdn.net/so/search?q=QString&amp;spm=1001.2101.3001.7020">QString</a>对象，</p><p>i</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">f</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> <span class="token string">"auto"</span> <span class="token operator">||</span> str <span class="token operator">==</span> <span class="token string">"extern"</span>        <span class="token operator">||</span> str <span class="token operator">==</span> <span class="token string">"static"</span> <span class="token operator">||</span> str <span class="token operator">==</span> <span class="token string">"register"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <strong>上面的代码执行会比下面的代码执行快很多</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"auto"</span><span class="token punctuation">)</span> <span class="token operator">||</span> str <span class="token operator">==</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"extern"</span><span class="token punctuation">)</span>        <span class="token operator">||</span> str <span class="token operator">==</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"static"</span><span class="token punctuation">)</span> <span class="token operator">||</span> str <span class="token operator">==</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"register"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        因为在第二部分的代码中会构造<code>四个临时的QString对象</code>，并复制字符串中的值。</p><p>​        在程序中定义了<code>QT_NO_CAST_FROM_ASCII</code>的应用程序是无法使用QString的<code>const char*</code>相关的API函数，因此Qt提供了<strong>QLatin1String类来更高效的利用const char*的类型</strong>，它就是一个关于const char*的一个浅封装。如果利用QLatin1String类来写上述的程序就是</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> <span class="token function">QLatin1String</span><span class="token punctuation">(</span><span class="token string">"auto"</span><span class="token punctuation">)</span>        <span class="token operator">||</span> str <span class="token operator">==</span> <span class="token function">QLatin1String</span><span class="token punctuation">(</span><span class="token string">"extern"</span><span class="token punctuation">)</span>        <span class="token operator">||</span> str <span class="token operator">==</span> <span class="token function">QLatin1String</span><span class="token punctuation">(</span><span class="token string">"static"</span><span class="token punctuation">)</span>        <span class="token operator">||</span> str <span class="token operator">==</span> <span class="token function">QLatin1String</span><span class="token punctuation">(</span><span class="token string">"register"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        虽然在代码输入的时候有点长，但是它的执行效率和上面第一段的代码一样，同时也比使用<code>QString::fromLatin1()</code>转换来的快。</p><p>​        得益于<code>QString(const QLatin1String&amp;)</code>这个构造函数，QLatin1String可以在任何需要QString对象的地方使用，比如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QLabel <span class="token operator">*</span>label <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QLabel</span><span class="token punctuation">(</span><span class="token function">QLatin1String</span><span class="token punctuation">(</span><span class="token string">"MOD"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><p>​        <strong>QString str = “hello” 报错:</strong></p><p>​        在程序中定义了<code>QT_NO_CAST_FROM_ASCII</code>的应用程序是无法使用QString的const char<em>相关的API函数，因此Qt提供了QLatin1String类来更高效的利用const char</em>的类型，它就是一个关于const char*的一个浅封装。</p><ol><li><pre class="line-numbers language-none"><code class="language-none">QString::QString(const int *str)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><pre class="line-numbers language-none"><code class="language-none">Constructs a string initialized with the UTF-8 string str. The given const char8_t pointer is converted to Unicode using the fromUtf8() function.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7.</p><pre class="line-numbers language-none"><code class="language-none">QString::QString(const char *str)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Constructs a string initialized with the 8-bit string str. The given const char pointer is converted to Unicode using the fromUtf8() function.You can disable this constructor by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        构造一个用8位字符串str初始化的字符串。给定的<code>const char</code>指针使用<code>fromUtf8（）</code>函数转换为<code>Unicode</code>。</p><p>​        在编译应用程序时，可以通过定义<code>QT_NO_CAST_FROM_ASII</code>来禁用此构造函数。例如，如果您想确保所有用户可见的字符串都通过<code>QObject::tr()</code>，这可能很有用。</p><pre class="line-numbers language-none"><code class="language-none">Note: Defining QT_RESTRICTED_CAST_FROM_ASCII also disables this constructor, but enables a QString(const char (&amp;ch)[N]) constructor instead. Using non-literal input, or input with embedded NUL characters, or non-7-bit characters is undefined in this case.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">注意：定义QT_RESTRICTED_CAST_FROM_ASICI也会禁用此构造函数，但会启用QString（const-char（.ch）[N]）构造函数。在这种情况下，使用非文字输入、嵌入NUL字符的输入或非7位字符是未定义的。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>8.</p><pre class="line-numbers language-none"><code class="language-none">QString::QString(const QByteArray &amp;ba)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Constructs a string initialized with the byte array ba. The given byte array is converted to Unicode using fromUtf8().You can disable this constructor by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.Note: : any null (&#39;\0&#39;) bytes in the byte array will be included in this string, converted to Unicode null characters (U+0000). This behavior is different from Qt 5.x.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        构造一个用字节数组ba初始化的字符串。给定的字节数组使用fromUtf8（）转换为Unicode。<br>​        在编译应用程序时，可以通过定义QT_NO_CAST_FROM_ASII来禁用此构造函数。例如，如果您想确保所有用户可见的字符串都通过QObject:：tr（），这可能很有用。<br>​        <strong>注意：字节数组中的任何null（’\0’）字节都将包含在此字符串中，并转换为Unicode null字符（U+0000）。这种行为与Qt 5.x不同。</strong></p><p>9.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString::QString(const QString &amp;other)noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Constructs a copy of other.This operation takes constant time, because QString is implicitly shared. This makes returning a QString from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.See also operator&#x3D;().<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        构造其他的副本。<br>​        此操作需要恒定的时间，因为QString是隐式共享的。这使得从函数返回QString的速度非常快。如果共享实例被修改，它将被复制（写时复制），这需要线性时间。<br>另请参见运算符=（）。<strong>（缓式评估）</strong></p><p>10.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString::QString(QString &amp;&amp;other) noexcept<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Move-constructs a QString instance, making it point at the same object that other was pointing to.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        移动构造函数！</p><pre class="line-numbers language-none"><code class="language-none">QString::~QString() noexcept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Destroys the string: 析构字符串。</p><h2 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h2><pre class="line-numbers language-none"><code class="language-none">QString &amp;QString::append(const QString &amp;str)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Appends the string str onto the end of this string.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在字符串后面追加内容</p><p>Example:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString x &#x3D; &quot;free&quot;;QString y &#x3D; &quot;dom&quot;;x.append(y);&#x2F;&#x2F; x &#x3D;&#x3D; &quot;freedom&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">This is the same as using the insert() function:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也就是说，这个函数本质上等效于：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">x.insert(x.size(), y);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">The&#96; append()&#96; function is typically very fast (constant time), because QString preallocates extra space at the end of the string data so it can grow without reallocating the entire string each time.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>留心到QString会提前分配好空间</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString&amp; QString::append(QChar ch)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">This function overloads append().Appends the character ch to this string.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        通过重载<code>append</code>函数直接追加一个字符。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString &amp;QString::append(const QChar *str, qsizetype len)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">This function overloads append().Appends len characters from the QChar array str to this string.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>     我们通过简单的重载`append`函数来完成向内追加一个长度为`len`的QChar字符串！</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">[since 6.0] QString&amp; QString::append(QStringView v)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">This function overloads append().Appends the given string view v to this string and returns the result.This function was introduced in Qt 6.0.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        这个函数是通过一个叫QStringView的方式载入到字符串的末尾!</p><h3 id="Extensive-for-QChar-and-QStringView"><a href="#Extensive-for-QChar-and-QStringView" class="headerlink" title="Extensive for QChar and QStringView"></a>Extensive for QChar and QStringView</h3><h4 id="QChar是什么"><a href="#QChar是什么" class="headerlink" title="QChar是什么:"></a>QChar是什么:</h4><p>原文链接：<a href="https://blog.csdn.net/a8039974/article/details/104126186">https://blog.csdn.net/a8039974/article/details/104126186</a></p><p>​        在Qt中,我们封装了unicode字符:</p><p>​        在Qt中，QChar是Qt处理字符的基本类型,是对unicode字符的封装。QChar使用2个字节的内存，在其内部维护了一个unsigned short 类型的内存。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QChar();                   &#x2F;&#x2F; 构造一个空字符，即&#39;\0&#39;QChar(char ch);            &#x2F;&#x2F; 由字符数据ch构造，char类型作为QChar的构造参数时，会被转换为unsigned short，继而可被QChar接管QChar(uchar ch);          &#x2F;&#x2F; 由无符号字符数据ch构造QChar(ushort code);       &#x2F;&#x2F; 由无符号短整形数据code构造，code是Unicode编码QChar(short code);        &#x2F;&#x2F;由 短整形数据code构造，code是Unicode编码QChar(uint code);         &#x2F;&#x2F; 由无符号整型数据code构造，code是Unicode编码QChar(int code);          &#x2F;&#x2F; 由整型数据code构造，code是Unicode编码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在Qt中，<strong>Unicode字符是没有任何标记或结构的16位实体</strong>。此类表示这样的实体。它是轻量级的，因此可以在任何地方使用。<strong>大多数编译器将其视为无符号空头</strong>。</p><p>​        <strong>QChar提供了完整的测试/分类功能，可以转换为其他格式，也可以转换为分解的Unicode格式，如果需要，还可以尝试比较和转换大小写。</strong></p><p>​        分类函数包括标准c++标头<cctype>(以前是<ctype.h>)中的函数，<strong>但是操作的是Unicode字符的全范围，而不仅仅是ASCII范围。</strong></p><p>​        如果字符是某种类型的字符，它们都返回true;否则返回false。</p><p>​        这些分类功能</p><div class="table-container"><table><thead><tr><th>functions</th><th>descriptions</th></tr></thead><tbody><tr><td>isNull()</td><td>(返回true,如果字符’ \ 0 ‘),</td></tr><tr><td>isPrint()</td><td>(如果是任何类型的可打印字符,包括空格),</td></tr><tr><td>isPunct()</td><td>(任何类型的标点),</td></tr><tr><td>isMark ()</td><td>(Unicode)、</td></tr><tr><td>isLetter()</td><td>(字母),</td></tr><tr><td>isNumber()</td><td>(任何形式的数字字符,而不仅仅是0 - 9),</td></tr><tr><td>isLetterOrNumber(), isDigit()</td><td>是不是字母或者是数字,或者是十进制数</td></tr></tbody></table></div><p>​        所有这些都是围绕category()的包装器，它返回每个字符的unicode定义的类别。其中一些还计算派生属性(例如isSpace()如果字符属于类别分隔符_*或来自Other_Control类别的异常代码点，则返回true)。</p><p>​        QChar还提供了direction()，它指示该字符的“自然”写入方向。joiningType()函数指示字符如何与它的邻居连接(主要用于阿拉伯语或叙利亚语)，最后是has()，它指示当字符以“非自然”的书写方向打印时，是否需要镜像字符。</p><p>​        通过使用decomposition()，可以将组合的Unicode字符(比如ring)转换成分解的Unicode(“a”后面跟着“ring above”)。</p><p>​        在Unicode中，比较是不可能的，大小写转换是非常困难的。Unicode覆盖了“整个”世界，也包括世界上的大多数情况和排序问题。操作符==()和好友将纯粹基于字符的数值Unicode值(代码点)进行比较，而toUpper()和toLower()将在字符具有定义良好的大写/小写等价时进行大小写更改。对于依赖于语言环境的比较，使用QString::localeAwareCompare()。</p><p>​        转换函数包括unicode()(转换为标量)、toLatin1()(转换为标量，但将所有非latin -1字符转换为0)、row()(提供unicode行)、cell()(提供unicode单元格)、digitValue()(提供任意数字字符的整数值)和许多构造函数。</p><p>​        QChar提供了构造函数和强制类型转换操作符，这使得转换传统的8位字符变得很容易。如果您定义了<strong>QT_NO_CAST_FROM_ASCII和QT_NO_CAST_TO_ASCII</strong>，就像QString文档中解释的那样，您将需要显式地调用fromLatin1()，或者使用QLatin1Char，从一个8位的字符构造一个QChar，并且您将需要调用toLatin1()来获取8位的值。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QCoreApplication&gt;#include &lt;QChar&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123;    QCoreApplication a(argc, argv);    char  ch1 &#x3D; &#39;h&#39;;    QChar ch &#x3D; &#39;hh&#39;;    qDebug(&quot;%x&quot;,ch);    qDebug(&quot;%x&quot;,ch1);    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">686868<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="QStringView"><a href="#QStringView" class="headerlink" title="QStringView"></a>QStringView</h4><h5 id="快速简介"><a href="#快速简介" class="headerlink" title="快速简介:"></a>快速简介:</h5><pre class="line-numbers language-none"><code class="language-none">The QStringView class provides a unified view on UTF-16 strings with a read-only subset of the [QString](https:&#x2F;&#x2F;doc.qt.io&#x2F;qt-5&#x2F;qstring.html) API. <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        QStringView类通过[QString]的只读子集提供了UTF-16字符串的统一视图.</p><h5 id="如何引入"><a href="#如何引入" class="headerlink" title="如何引入:"></a>如何引入:</h5><div class="table-container"><table><thead><tr><th>Header:</th><th>#include <QStringView></th></tr></thead><tbody><tr><td>qmake:</td><td>QT += core</td></tr><tr><td>Since:</td><td>Qt 5.10</td></tr></tbody></table></div><h5 id="Public-Types"><a href="#Public-Types" class="headerlink" title="Public Types"></a>Public Types</h5><div class="table-container"><table><thead><tr><th>typedef</th><th><strong><a href="https://doc.qt.io/qt-5/qstringview.html#const_iterator-typedef">const_iterator</a></strong></th></tr></thead><tbody><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#const_pointer-typedef">const_pointer</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#const_reference-typedef">const_reference</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#const_reverse_iterator-typedef">const_reverse_iterator</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#difference_type-typedef">difference_type</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#iterator-typedef">iterator</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#pointer-typedef">pointer</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#reference-typedef">reference</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#reverse_iterator-typedef">reverse_iterator</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#size_type-typedef">size_type</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#storage_type-typedef">storage_type</a></strong></td></tr><tr><td>typedef</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#value_type-typedef">value_type</a></strong></td></tr></tbody></table></div><h5 id="Public-Functions"><a href="#Public-Functions" class="headerlink" title="Public Functions"></a>Public Functions</h5><div class="table-container"><table><thead><tr><th></th><th><strong><a href="https://doc.qt.io/qt-5/qstringview.html#QStringView-8">QStringView</a></strong>(const StdBasicString &amp;<em>str</em>)</th></tr></thead><tbody><tr><td></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#QStringView-7">QStringView</a></strong>(const QStringRef &amp;<em>str</em>)</td></tr><tr><td></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#QStringView-6">QStringView</a></strong>(const QString &amp;<em>str</em>)</td></tr><tr><td></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#QStringView-5">QStringView</a></strong>(const Char <em>*str</em>)</td></tr><tr><td></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#QStringView-4">QStringView</a></strong>(const Char (&amp;)[N] <em>string</em> = N)</td></tr><tr><td></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#QStringView-3">QStringView</a></strong>(const Char <strong>first*, const Char </strong>last*)</td></tr><tr><td></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#QStringView-2">QStringView</a></strong>(const Char <em>*str</em>, qsizetype <em>len</em>)</td></tr><tr><td></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#QStringView-1">QStringView</a></strong>(<em>std::nullptr_t</em>)</td></tr><tr><td></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#QStringView">QStringView</a></strong>()</td></tr><tr><td>QString</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#arg">arg</a></strong>(Args &amp;&amp;… <em>args</em>) const</td></tr><tr><td>QChar</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#at">at</a></strong>(qsizetype <em>n</em>) const</td></tr><tr><td>QChar</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#back">back</a></strong>() const</td></tr><tr><td>QStringView::const_iterator</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#begin">begin</a></strong>() const</td></tr><tr><td>QStringView::const_iterator</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#cbegin">cbegin</a></strong>() const</td></tr><tr><td>QStringView::const_iterator</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#cend">cend</a></strong>() const</td></tr><tr><td>void</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#chop">chop</a></strong>(qsizetype <em>length</em>)</td></tr><tr><td>QStringView</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#chopped">chopped</a></strong>(qsizetype <em>length</em>) const</td></tr><tr><td>int</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#compare">compare</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>int</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#compare-1">compare</a></strong>(QLatin1String <em>l1</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>int</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#compare-2">compare</a></strong>(QChar <em>ch</em>) const</td></tr><tr><td>int</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#compare-3">compare</a></strong>(QChar <em>ch</em>, Qt::CaseSensitivity <em>cs</em>) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#contains">contains</a></strong>(QChar <em>c</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#contains-1">contains</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#contains-2">contains</a></strong>(QLatin1String <em>l1</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>qsizetype</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#count">count</a></strong>(QChar <em>ch</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>qsizetype</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#count-1">count</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>QStringView::const_reverse_iterator</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#crbegin">crbegin</a></strong>() const</td></tr><tr><td>QStringView::const_reverse_iterator</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#crend">crend</a></strong>() const</td></tr><tr><td>QStringView::const_pointer</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#data">data</a></strong>() const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#empty">empty</a></strong>() const</td></tr><tr><td>QStringView::const_iterator</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#end">end</a></strong>() const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#endsWith">endsWith</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#endsWith-1">endsWith</a></strong>(QLatin1String <em>l1</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#endsWith-2">endsWith</a></strong>(QChar <em>ch</em>) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#endsWith-3">endsWith</a></strong>(QChar <em>ch</em>, Qt::CaseSensitivity <em>cs</em>) const</td></tr><tr><td>QChar</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#first">first</a></strong>() const</td></tr><tr><td>QChar</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#front">front</a></strong>() const</td></tr><tr><td>qsizetype</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#indexOf">indexOf</a></strong>(QChar <em>c</em>, qsizetype <em>from</em> = 0, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>qsizetype</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#indexOf-1">indexOf</a></strong>(QStringView <em>str</em>, qsizetype <em>from</em> = 0, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>qsizetype</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#indexOf-2">indexOf</a></strong>(QLatin1String <em>l1</em>, qsizetype <em>from</em> = 0, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#isEmpty">isEmpty</a></strong>() const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#isNull">isNull</a></strong>() const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#isRightToLeft">isRightToLeft</a></strong>() const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#isValidUtf16">isValidUtf16</a></strong>() const</td></tr><tr><td>QChar</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#last">last</a></strong>() const</td></tr><tr><td>qsizetype</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#lastIndexOf">lastIndexOf</a></strong>(QChar <em>c</em>, qsizetype <em>from</em> = -1, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>qsizetype</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#lastIndexOf-1">lastIndexOf</a></strong>(QStringView <em>str</em>, qsizetype <em>from</em> = -1, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>qsizetype</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#lastIndexOf-2">lastIndexOf</a></strong>(QLatin1String <em>l1</em>, qsizetype <em>from</em> = -1, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>QStringView</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#left">left</a></strong>(qsizetype <em>length</em>) const</td></tr><tr><td>int</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#length">length</a></strong>() const</td></tr><tr><td>QStringView</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#mid">mid</a></strong>(qsizetype <em>start</em>) const</td></tr><tr><td>QStringView</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#mid-1">mid</a></strong>(qsizetype <em>start</em>, qsizetype <em>length</em>) const</td></tr><tr><td>QStringView::const_reverse_iterator</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#rbegin">rbegin</a></strong>() const</td></tr><tr><td>QStringView::const_reverse_iterator</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#rend">rend</a></strong>() const</td></tr><tr><td>QStringView</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#right">right</a></strong>(qsizetype <em>length</em>) const</td></tr><tr><td>qsizetype</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#size">size</a></strong>() const</td></tr><tr><td>QList<QStringView></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#split">split</a></strong>(QStringView <em>sep</em>, Qt::SplitBehavior <em>behavior</em> = Qt::KeepEmptyParts, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>QList<QStringView></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#split-1">split</a></strong>(QChar <em>sep</em>, Qt::SplitBehavior <em>behavior</em> = Qt::KeepEmptyParts, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>QList<QStringView></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#split-2">split</a></strong>(const QRegularExpression &amp;<em>sep</em>, Qt::SplitBehavior <em>behavior</em> = Qt::KeepEmptyParts) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#startsWith">startsWith</a></strong>(QStringView <em>str</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#startsWith-1">startsWith</a></strong>(QLatin1String <em>l1</em>, Qt::CaseSensitivity <em>cs</em> = Qt::CaseSensitive) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#startsWith-2">startsWith</a></strong>(QChar <em>ch</em>) const</td></tr><tr><td>bool</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#startsWith-3">startsWith</a></strong>(QChar <em>ch</em>, Qt::CaseSensitivity <em>cs</em>) const</td></tr><tr><td>double</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toDouble">toDouble</a></strong>(bool <em>*ok</em> = nullptr) const</td></tr><tr><td>float</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toFloat">toFloat</a></strong>(bool <em>*ok</em> = nullptr) const</td></tr><tr><td>int</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toInt">toInt</a></strong>(bool <em>*ok</em> = nullptr, int <em>base</em> = 10) const</td></tr><tr><td>QByteArray</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toLatin1">toLatin1</a></strong>() const</td></tr><tr><td>QByteArray</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toLocal8Bit">toLocal8Bit</a></strong>() const</td></tr><tr><td>long</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toLong">toLong</a></strong>(bool <em>*ok</em> = nullptr, int <em>base</em> = 10) const</td></tr><tr><td>qlonglong</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toLongLong">toLongLong</a></strong>(bool <em>*ok</em> = nullptr, int <em>base</em> = 10) const</td></tr><tr><td>short</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toShort">toShort</a></strong>(bool <em>*ok</em> = nullptr, int <em>base</em> = 10) const</td></tr><tr><td>QString</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toString">toString</a></strong>() const</td></tr><tr><td>uint</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toUInt">toUInt</a></strong>(bool <em>*ok</em> = nullptr, int <em>base</em> = 10) const</td></tr><tr><td>ulong</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toULong">toULong</a></strong>(bool <em>*ok</em> = nullptr, int <em>base</em> = 10) const</td></tr><tr><td>qulonglong</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toULongLong">toULongLong</a></strong>(bool <em>*ok</em> = nullptr, int <em>base</em> = 10) const</td></tr><tr><td>ushort</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toUShort">toUShort</a></strong>(bool <em>*ok</em> = nullptr, int <em>base</em> = 10) const</td></tr><tr><td>QVector<uint></td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toUcs4">toUcs4</a></strong>() const</td></tr><tr><td>QByteArray</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toUtf8">toUtf8</a></strong>() const</td></tr><tr><td>int</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#toWCharArray">toWCharArray</a></strong>(wchar_t <em>*array</em>) const</td></tr><tr><td>QStringView</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#trimmed">trimmed</a></strong>() const</td></tr><tr><td>void</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#truncate">truncate</a></strong>(qsizetype <em>length</em>)</td></tr><tr><td>const QStringView::storage_type *</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#utf16">utf16</a></strong>() const</td></tr><tr><td>QChar</td><td><strong><a href="https://doc.qt.io/qt-5/qstringview.html#operator-5b-5d">operator[]</a></strong>(qsizetype <em>n</em>) const</td></tr></tbody></table></div><h5 id="Related-Non-Members-一些延申用到的API"><a href="#Related-Non-Members-一些延申用到的API" class="headerlink" title="Related Non-Members(一些延申用到的API)"></a>Related Non-Members(一些延申用到的API)</h5><div class="table-container"><table><thead><tr><th>uint</th><th><strong><a href="https://doc.qt.io/qt-5/qstringview.html#qHash">qHash</a></strong>(QStringView <em>key</em>, uint <em>seed</em> = 0)</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><h5 id="Detailed-Description-English"><a href="#Detailed-Description-English" class="headerlink" title="Detailed Description (English)"></a>Detailed Description (English)</h5><p>​        A QStringView references a contiguous portion of a UTF-16 string it does not own. It acts as an interface type to all kinds of UTF-16 string, without the need to construct a <code>QString</code> first.</p><p>​        The UTF-16 string may be represented as an array (or an array-compatible data-structure such as <a href="https://doc.qt.io/qt-5/qstring.html">QString</a>, std::basic_string, etc.) of <a href="https://doc.qt.io/qt-5/qchar.html">QChar</a>, <code>ushort</code>, <code>char16_t</code> or (on platforms, such as Windows, where it is a 16-bit type) <code>wchar_t</code>.</p><p>​        QStringView is designed as an interface type; its main use-case is as a function parameter type. When QStringViews are used as automatic variables or data members, care must be taken to ensure that the referenced string data (for example, owned by a <a href="https://doc.qt.io/qt-5/qstring.html">QString</a>) outlives the QStringView on all code paths, lest the string view ends up referencing deleted data.</p><p>​        When used as an interface type, QStringView allows a single function to accept a wide variety of UTF-16 string data sources. One function accepting QStringView thus replaces three function overloads (taking <a href="https://doc.qt.io/qt-5/qstring.html">QString</a>, <a href="https://doc.qt.io/qt-5/qstringref.html">QStringRef</a>, and <code>(const QChar*, int)</code>), while at the same time enabling even more string data sources to be passed to the function, such as <code>u&quot;Hello World&quot;</code>, a <code>char16_t</code> string literal.</p><p>​        QStringViews should be passed by value, not by reference-to-const:`</p><pre class="line-numbers language-none"><code class="language-none">void myfun1(QStringView sv);        &#x2F;&#x2F; preferredvoid myfun2(const QStringView &amp;sv); &#x2F;&#x2F; compiles and works, but slower<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        If you want to give your users maximum freedom in what strings they can pass to your function, accompany the QStringView overload with overloads for</p><ul><li><p>QChar</p><p>: this overload can delegate to the QStringView version:</p><pre class="line-numbers language-none"><code class="language-none">void fun(QChar ch) &#123; fun(QStringView(&amp;ch, 1)); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>even though, for technical reasons, QStringView cannot provide a <a href="https://doc.qt.io/qt-5/qchar.html">QChar</a> constructor by itself.</p></li><li><p><em>QString</em>: if you store an unmodified copy of the string and thus would like to take advantage of <a href="https://doc.qt.io/qt-5/qstring.html">QString</a>‘s implicit sharing.</p></li><li><p><a href="https://doc.qt.io/qt-5/qlatin1string.html">QLatin1String</a>: if you can implement the function without converting the <a href="https://doc.qt.io/qt-5/qlatin1string.html">QLatin1String</a> to UTF-16 first; users expect a function overloaded on <a href="https://doc.qt.io/qt-5/qlatin1string.html">QLatin1String</a> to perform strictly less memory allocations than the semantically equivalent call of the QStringView version, involving construction of a <a href="https://doc.qt.io/qt-5/qstring.html">QString</a> from the <a href="https://doc.qt.io/qt-5/qlatin1string.html">QLatin1String</a>.</p></li></ul><p>​        QStringView can also be used as the return value of a function. If you call a function returning QStringView, take extra care to not keep the QStringView around longer than the function promises to keep the referenced string data alive. If in doubt, obtain a strong reference to the data by calling <a href="https://doc.qt.io/qt-5/qstringview.html#toString">toString</a>() to convert the QStringView into a <a href="https://doc.qt.io/qt-5/qstring.html">QString</a>.</p><p>​        QStringView is a <em>Literal Type</em>, but since it stores data as <code>char16_t</code>, iteration is not <code>constexpr</code> (casts from <code>const char16_t*</code> to <code>const QChar*</code>, which is not allowed in <code>constexpr</code> functions). You can use an indexed loop and/or <a href="https://doc.qt.io/qt-5/qstringview.html#utf16">utf16</a>() in <code>constexpr</code> contexts instead.</p><p>​        <strong>Note:</strong> We strongly discourage the use of <a href="https://doc.qt.io/qt-5/qlist.html">QList</a><QStringView>, because <a href="https://doc.qt.io/qt-5/qlist.html">QList</a> is a very inefficient container for QStringViews (it would heap-allocate every element). Use <a href="https://doc.qt.io/qt-5/qvector.html">QVector</a> (or std::vector) to hold QStringViews instead.</p><h5 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h5><p>​        QStringView引用了它不拥有的UTF-16字符串的连续部分。它充当所有类型的UTF-16字符串的接口类型，而不需要构造<a href="https://doc.qt.io/qt-5/qstring.html">QString</a></p><p>​        UTF-16字符串可以表示为数组（或数组兼容的数据结构，如QString），std::basic_string等）、“ushort”、“char16_t”或（在Windows等平台上，它是16位类型）“wchar_t”。</p><p>​        QStringView被设计为一种接口类型；它的主要用例是作为函数参数类型。当QStringViews用作自动变量或数据成员时，必须注意确保引用的字符串数据（例如，由<code>QString</code>拥有)在所有代码路径上都比QStringView过期，以免字符串视图最终引用已删除的数据。</p><p>​        当用作接口类型时，QStringView允许单个函数接受各种各样的UTF-16字符串数据源。因此，一个接受QStringView的函数替换了三个函数重载（取<a href="https://doc.qt.io/qt-5/qstring.html">QString</a>，<a href="https://doc.qt.io/qt-5/qstringref.html">QStringRef</a>，和<code>（const QChar*，int）</code>），同时使更多的字符串数据源能够传递给函数，例如<code>u“Hello World”</code>，<code>char16_t</code>字符串文字。</p><p>​        QStringViews应通过值传递，而不是通过引用const:</p><p>​        为啥看着:<a href="https://www.thinbug.com/q/52364784">应用错误收集 (thinbug.com)</a></p><p>​        他们在文档中说应该按值传递，因为<code>QStringView</code>本身并不是字符串，它只是一种接口（嗯，这就是为什么它被称为“视图”的原因），它为您提供了读取对引用字符串的访问。因此，<code>QStringView</code>的大小很可能类似于参考的大小。根据QT源代码，<code>QStringView</code>只有2个字段：</p><pre class="line-numbers language-none"><code class="language-none">private:    qsizetype m_size;    const storage_type *m_data;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        在装有gcc 6.3的Debian9 x64机器上，此类的大小为8（指针）+ 4（整数）= 12个字节。在我的情况下，参考大小是8个字节，因此，在函数调用上的数据复制方面只有很小的差异。请记住，在不同的计算机上引用可能以另一种方式实现，并且可能更大。</p><p>​        虽然我同意这种接口应该通过副本传递（而不是const ref），但我不明白为什么他们声称通过const ref传递它实际上更慢（两次对变量进行解引用实际上并没有在现代应用中的任何可观察到的效果）。我真的很想看看支持该说法的测试。</p><hr><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void myfun1（QStringView sv）；&#x2F;&#x2F;首选void myfun2（const QStringView&amp;sv）；&#x2F;&#x2F;编译并工作，但速度较慢<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        如果您想让用户在可以传递给函数的字符串方面有最大的自由度，请在QStringView重载中添加:</p><p>1.-QChar：此重载可以委托给QStringView版本：</p><pre class="line-numbers language-none"><code class="language-none">void fun（QChar ch）｛fun（QStringView（.ch，1））；｝<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        尽管由于技术原因，QStringView无法提供<a href="https://doc.qt.io/qt-5/qchar.html">QChar</a>构造函数本身。</p><p>2.-<em>QString</em>：如果您存储未修改的字符串副本，因此希望利用<a href="https://doc.qt.io/qt-5/qstring.html">QString</a>的隐含共享。</p><ol><li>-<a href="https://doc.qt.io/qt-5/qlatin1string.html">QLatin1String</a>：如果您可以在不转换[QLatin1String]的情况下实现该函数(<a href="https://doc.qt.io/qt-5/qlatin1string.html)首先到UTF-16；用户期望函数在[QLatin1String]上重载(https://doc.qt.io/qt-5/qlatin1string.html)执行的内存分配严格少于QStringView版本的语义等效调用，涉及[QString]的构造(https://doc.qt.io/qt-5/qstring.html)从[QLatin1String](https://doc.qt.io/qt-5/qlatin1string.html)。">https://doc.qt.io/qt-5/qlatin1string.html)首先到UTF-16；用户期望函数在[QLatin1String]上重载(https://doc.qt.io/qt-5/qlatin1string.html)执行的内存分配严格少于QStringView版本的语义等效调用，涉及[QString]的构造(https://doc.qt.io/qt-5/qstring.html)从[QLatin1String](https://doc.qt.io/qt-5/qlatin1string.html)。</a></li></ol><p>​        QStringView也可以用作函数的返回值。如果调用返回QStringView的函数，请格外小心，<strong>不要使QStringView保持的时间超过该函数承诺保持引用字符串数据有效的时间。如果有疑问，</strong>请通过调用[toString]获得对数据的强引用(<a href="https://doc.qt.io/qt-5/qstringview.html#toString)（）将QStringView转换为[QString](https://doc.qt.io/qt-5/qstring.html)。">https://doc.qt.io/qt-5/qstringview.html#toString)（）将QStringView转换为[QString](https://doc.qt.io/qt-5/qstring.html)。</a></p><p>​        QStringView是一个<em>Literal Type</em>，但由于它将数据存储为“char16_t”，因此迭代不是“constexpr”（从“const char16_t<em>”强制转换为“const QChar</em>”，这在“constexpr”函数中是不允许的）。您可以使用索引循环和/或<a href="https://doc.qt.io/qt-5/qstringview.html#utf16">utf16</a>（）在<code>constexpr</code>上下文中。</p><p>​        <strong>注：</strong>我们强烈不建议的使用<a href="https://doc.qt.io/qt-5/qlist.html">QList</a><QStringView>，因为<a href="https://doc.qt.io/qt-5/qlist.html">QList</a>对于QStringViews来说是一个效率非常低的容器（它会对每个元素进行堆分配）。使用<a href="https://doc.qt.io/qt-5/qvector.html">QVector</a>（或std:：vector）来保存QStringViews。</p><h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString&amp; QString::append(QLatin1StringView str)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">This function overloads append().Appends the Latin-1 string viewed by *str* to this string.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        跟上面的类似:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">[since 6.5]QString&amp;QString::append(QUtf8StringView str)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">This function overloads append().Appends the UTF-8 string view *str* to this string.This function was introduced in Qt 6.5.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是类似的!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString&amp; QString::append(const char str)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">This function overloads append().Appends the string *str* to this string. The given const char pointer is converted to Unicode using the fromUtf8 function.You can disable this function by defining QT_NO_CAST_FROM_ASCII, when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        此函数重载append（）。</p><p>​        将字符串<em>str</em>追加到此字符串。给定的const-char指针使用fromUtf8函数转换为Unicode。</p><p>​        在编译应用程序时，可以通过定义QT_NO_CAST_FROM_ASII来禁用此功能。例如，如果您想确保所有用户可见的字符串都通过QObject::tr（），这可能很有用。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString&amp;QString::append(const QByteArray&amp; ba)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        This function overloads append().</p><pre class="line-numbers language-none"><code class="language-none">Appends the byte array *ba* to this string. The given byte array is converted to Unicode using the fromUtf8() function.You can disable this function by defining QT_NO_CAST_FROM_ASCII when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        将字节数组<em>ba</em>追加到此字符串。给定的字节数组使用fromUtf8（）函数转换为Unicode。</p><p>​        您可以在编译应用程序时通过定义QT_NO_CAST_FROM_ASII来禁用此功能。例如，如果您想确保所有用户可见的字符串都通过QObject:：tr（），这可能很有用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ModernCPP-SmartPointer</title>
      <link href="/2023/06/06/ModernCPP-SmartPointer/"/>
      <url>/2023/06/06/ModernCPP-SmartPointer/</url>
      
        <content type="html"><![CDATA[<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++ 智能指针"></a>C++ 智能指针</h1><p>​        突发奇想，准备来点CPP狠活（）</p><h2 id="CPP智能指针类型"><a href="#CPP智能指针类型" class="headerlink" title="CPP智能指针类型"></a>CPP智能指针类型</h2><p>​    ·    就三个：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::unique_ptrstd::shared_ptrstd::weak_ptr    std::auto_ptr 已经被废弃！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面就开始一些简单的讲述</p><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>​        在CPP智能指针诞生之后，CPP的指针就包括两类了： raw pointer裸指针和智能指针 smart_pointer。我们的cpp对指针进行了封装，优点就是可以自动分配内存，不需要你来干，不需要你来释放。</p><p>​        不过，需要知道的是：更多的时候裸指针会更加的方便而不是智能指针！在使用频率上，还是：原始指针 &gt; unique_ptr = shared_ptr &gt; weak_ptr的</p><p>​        对了，事实上我们的智能指针并没有完全解决内存安全！这是我们需要注意的。智能指针解决了所有权指针的释放和传输！因此，不是在开发中无脑的使用智能指针就完事了！否则还会造成内存安全隐患。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>​        人话：在任何给定时刻只有一个指针管理这片内存！并且，当这个指针出了作用域之后自动释放内存。BTW，因为只能一个指针管，因此不能复制，智能移动。</p><p>​        我们有三种创建方式。</p><p>​        1）现有的裸指针来创建（建议设置为空nullptr）</p><p>​        2）new一个</p><p>​        3）std::make_unique整一个（推介）</p><p>​        by the way我们使用get（）方法来获取地址</p><p>​        其余的-&gt;和 . 都跟裸指针都是一样的，下面来看下demo</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; create a file of dog class::.h:&gt;#pragma once#include&lt;string&gt;#include&lt;iostream&gt;class dog&#123;public:dog(std::string name, unsigned int age);dog() &#x3D; default; &#x2F;&#x2F; using in C++11, to avoid being mistaken while you just simply write &quot;dog a&quot;~dog();void showDogInfo() const &#123;std::cout &lt;&lt; &quot;the dog&#39;s name is: &quot; &lt;&lt; name &lt;&lt; &quot;and it&#39;s &quot; &lt;&lt; age &lt;&lt; &quot;years old&quot; &lt;&lt; &#39;\n&#39;;&#125;void setInfo(const std::string name,const unsigned int age)&#123;this-&gt;name &#x3D; name;this-&gt;age &#x3D; age;return;&#125;std::string getInfoofName() &#123;return this-&gt;name;&#125;unsigned int getAge() &#123;return this-&gt;age;&#125;private:std::string name;unsigned int age;&#125;;.cpp:&gt;   #include &quot;dog.h&quot;dog::dog(std::string name, unsigned int age)&#123;std::cout &lt;&lt; &quot;building a dog actually...&quot;;this-&gt;name &#x3D; name;this-&gt;age &#x3D; age;return;&#125;dog::~dog() &#123;std::cout &lt;&lt; &quot;is being erased of...  &quot; &lt;&lt;this-&gt;name&lt;&lt; &#39;\n&#39;;&#125;:&gt; in main.cpp    #include&lt;iostream&gt;#include&lt;memory&gt;#include&quot;dog.h&quot;using namespace std;int main()&#123;&#x2F;&#x2F; creating in stackdog c1(&quot;yes&quot;, 10);c1.showDogInfo();&#123;&#x2F;&#x2F; using in limited areadog c1(&quot;yep!!!&quot;, 200);c1.showDogInfo();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230416205015394.png" alt="image-20230416205015394"></p><p>​        那在裸指针的接收吧！</p><p><img src="image-20230416205243842.png" alt="image-20230416205243842"></p><p>​        出问题了，他没有调用析构，意味着内存泄漏</p><p>​        在CPP11之前，我们需要手动的delete！</p><p>​        但是就算如此还是会出现这样的问题！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">dog<span class="token operator">*</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"heap"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c2<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#123;</span>c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"heap"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c2<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">delete</span> c2<span class="token punctuation">;</span><span class="token comment">// FATAL ERROR!!!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们发现指针的转移造成了一个内存不被指针记住！</p><p>​        那这样呢？</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">dog<span class="token operator">*</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"heap"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c2<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#123;</span>c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"heap"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c2<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> c2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">delete</span> c2<span class="token punctuation">;</span><span class="token comment">// SO how???</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是错的！从这个变量已被改变开始，就找不回去了！所有，这个代码会崩溃。因此我们在这样的复杂场合下不应该使用裸指针。</p><h2 id="demo-of-智能指针创建"><a href="#demo-of-智能指针创建" class="headerlink" title="demo of 智能指针创建"></a>demo of 智能指针创建</h2><p><img src="image-20230416210214902.png" alt="image-20230416210214902"></p><p>​        你看，现在我们使用智能指针。没有调用delete还是成功的删除了dog在堆上的内存</p><p>​        但是还有一个大问题：我们就这样跑路了对不对？不对，没有对原始的空指针进行销毁：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Correct one:...dog* c2 &#x3D; new dog(&quot;heap&quot;, 1000);c2-&gt;showDogInfo();unique_ptr&lt;dog&gt; uni_dogPtr(c2);c2 &#x3D; nullptr;uni_dogPtr-&gt;showDogInfo();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我觉得不如这样写更加好：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> <span class="token function">uni_dogPtr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"smart"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uni_dogPtr<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        但官方推介的是这个：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> recommend <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"recommend"</span><span class="token punctuation">,</span><span class="token number">114514</span><span class="token punctuation">)</span><span class="token punctuation">;</span>recommend<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        显然这个更简洁。</p><p>​        下面是get()方法的应用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"\nthe data's addr is :> "</span><span class="token operator">&lt;&lt;</span>recommend<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也有可以对这个智能指针直接解引用的方式来处理问题：当然要预先定义解引用后怎么处置对象的问题。</p><p><img src="image-20230416212757013.png" alt="image-20230416212757013"></p><h2 id="unique-ptr和函数调用"><a href="#unique-ptr和函数调用" class="headerlink" title="unique_ptr和函数调用"></a>unique_ptr和函数调用</h2><p>​        注意！这个玩意不可以copy，而且在做函数参数或者是的时候一定要留心所有权的问题！</p><p>​        1）值传递</p><p>​        需要使用std::move来转移内存的拥有权</p><p>​        若参数直接传入到std::make_unique语句，那就自动转化成move!</p><p>​        2）引用传递</p><p>​        若设置了const就不能改变指针的指向！这是需要我们注意的！</p><p>​        3）返回值</p><p>​        指向一个local object</p><p>​        当然用于链式函数！</p><p>​        下面来看一个Demo, 现在我们来看一下，我们现在设计一个如下的函数！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void do_WithDog(std::unique_ptr&lt;dog&gt; pDog)&#123;pDog-&gt;showInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是很快，我们试图去传送的时候也，给你爆一个匪夷所思的错误：</p><p><img src="image-20230419214313273.png" alt="image-20230419214313273"></p><p>​        这个时候，其实就是ptr的权限不够，现在我们来用std::move来解决问题</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void do_WithDog(std::move(pDog))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        此后留意到，不可以再次使用这个指针来访问，因为以及被移动了！</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3MxMXNob3dfMTYz,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>（本质上讨论！就是把左值变为右值）</p><p>​        能不能简单点？可以，但是注意到，这里发生了隐式类型转换！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void do_WithDog(std::make_unique&lt;dog&gt;());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        2)引用传递</p><p>​        现在我们重新设计一下！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void doWithRefDof(std::unique_ptr&lt;dog&gt;&amp; pDog) &#123;pDog-&gt;setInfo(&quot;111&quot;, 100);pDog-&gt;showDogInfo();pDog.reset();&#x2F;&#x2F; 把pDog的指向转向0&#125;doWithRefDof(recommend);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是后面再次使用recommend的时候会发现代码会在运行的时候崩溃，因为</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">recommend.get() --&gt; 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是需要注意的！那这样呢？</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void doWithRefDof(const std::unique_ptr&lt;dog&gt;&amp; pDog) &#123;pDog-&gt;setInfo(&quot;111&quot;, 100);pDog-&gt;showDogInfo();pDog.reset();&#x2F;&#x2F; 把pDog的指向转向0&#125;doWithRefDof(recommend);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后发现爆了新错，不是因为setInfo不能使用，而是Reset 出了问题</p><p><img src="image-20230419214405927.png" alt="image-20230419214405927"></p><p>​        就像常指针一样了！</p><p>​        下面，我们来设计一个返回unique_ptr 的函数 ，他正是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::unique_ptr&lt;dog&gt; getUniDogPtr(const std::string name,const unsigned int age)&#123;std::unique_ptr&lt;dog&gt; p_Dog &#x3D; std::make_unique&lt;dog&gt;(name,age);        return p_Dog;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        或者再简洁一点！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::unique_ptr&lt;dog&gt; getUniqueDogPtr(const std::string name,const unsigned int age) &#123;return std::make_unique&lt;dog&gt;(name, age);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shared-ptr-与计数机制"><a href="#shared-ptr-与计数机制" class="headerlink" title="shared_ptr 与计数机制"></a>shared_ptr 与计数机制</h2><p>​        <code>shared_ptr</code>作为现代C++智能指针的一种，又被译作计数指针（按照原名是共享指针），于是，不同于<code>unique_ptr</code>那样， <code>shared_ptr</code>字如其名的——可以共享数据！我们可以复制这个指针，让多个指针都指向同一块内存！</p><p>​        但是让<code>shared_ptr</code>独特于裸指针的是：它引入了计数机制！也就是说，wrap了一个计数器与类对象所指向的内存相关联起来！</p><p>​        我们对其的copy行为在运行中发生一侧，计数器就+1，销毁一次就-1，对外界的接口就是调用方法：<code>use_count()</code>来查看</p><h3 id="常量类型的shared-ptr"><a href="#常量类型的shared-ptr" class="headerlink" title="常量类型的shared_ptr"></a>常量类型的shared_ptr</h3><p>​        下面呢：我们来搞一下shared_ptr来指向经典对象的demo:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">shared_ptr&lt;int&gt; i_pInt1 &#x3D; make_shared&lt;int&gt;(10);cout &lt;&lt; &quot;val:&gt;&quot; &lt;&lt; *i_pInt1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230422212238727.png" alt="image-20230422212238727"></p><p>​        试试use_count:</p><pre class="line-numbers language-none"><code class="language-none">cout &lt;&lt;&quot;use_count:&gt;&quot;&lt;&lt;i_pInt1.use_count()&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230422212438039.png" alt="image-20230422212438039"></p><p>​        那我们说的copy究竟是啥呢？正是类似于浅拷贝那样，announce 一个指针，直接将地址复制给这个新指针，只是将地址传递给了新指针而没有为这块数据本身做任何拷贝！</p><p><img src="image-20230422212644498.png" alt="image-20230422212644498"></p><p>​        可以看到，这下<code>use_count</code>变成2了！</p><p>​        那就显然了！如果我们通过i_pInt1来改变值，当我们解析i_pInt2的时候，值一定也会变！    </p><pre><code>//change the val by Path *pVal1 = 20;*i_pInt1 = 1000;cout &lt;&lt; &quot;val:&gt;&quot; &lt;&lt; *i_pInt2 &lt;&lt; endl;</code></pre><p><img src="image-20230422212859311.png" alt="image-20230422212859311"></p><p>​        那现在我们的指针的计数还是2，怎么让他减少呢？让其中一个不再指向这块内存就好了！</p><pre class="line-numbers language-none"><code class="language-none">i_pInt2 &#x3D; nullptr;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt1.use_count() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230422213103231.png" alt="image-20230422213103231"></p><p>​        同时，我们注意，那个被指向nullptr的共享指针，他的计数就是0了！因为他这个时候不在指向任何东西！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">shared_ptr&lt;int&gt; i_pInt3 &#x3D; i_pInt1;shared_ptr&lt;int&gt; i_pInt4 &#x3D; i_pInt1;shared_ptr&lt;int&gt; i_pInt5 &#x3D; i_pInt1;shared_ptr&lt;int&gt; i_pInt6 &#x3D; i_pInt1;&#x2F;&#x2F; erase i_pInt2;i_pInt2 &#x3D; nullptr;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt2.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt1.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt3.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt4.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt5.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt6.use_count() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422213428144.png" alt="image-20230422213428144"></p><h3 id="自定义类型的shared-ptr"><a href="#自定义类型的shared-ptr" class="headerlink" title="自定义类型的shared_ptr"></a>自定义类型的shared_ptr</h3><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(dog(&quot;111&quot;, 100));*pDog1 &lt;&lt; *pDog1;shared_ptr&lt;dog&gt; pDog2 &#x3D; pDog1;shared_ptr&lt;dog&gt; pDog3 &#x3D; pDog1;shared_ptr&lt;dog&gt; pDog4 &#x3D; pDog1;cout &lt;&lt; pDog1.use_count() &lt;&lt; &quot; &quot; &lt;&lt; pDog2.use_count() &lt;&lt; &quot; &quot; &lt;&lt; pDog3.use_count() &lt;&lt; &quot; &quot; &lt;&lt; pDog4.use_count();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422214020516.png" alt="image-20230422214020516"></p><p>​        当shared_ptr 中没人指向内存的时候自动释放内存！可以使用reset方法来置空指针为 nullptr!</p><h2 id="shared-ptr与函数"><a href="#shared-ptr与函数" class="headerlink" title="shared_ptr与函数"></a>shared_ptr与函数</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>​        我们使用值传递的时候，我们是使用了copy的，这个时候在函数内部来use_count就会发现计数器+1了，但是当函数结束调用时，指针析构，计数器-1！</p><p><img src="image-20230422214825448.png" alt="image-20230422214825448"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;dog.h&quot;#include&lt;iostream&gt;using namespace std;void passByVal(shared_ptr&lt;dog&gt; pDog)&#123;pDog-&gt;showDogInfo();cout &lt;&lt; pDog.use_count() &lt;&lt; endl;return;&#125;int main()&#123;shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(&quot;111&quot;, 100);cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;passByVal(pDog1);cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p><img src="image-20230422215220588.png" alt="image-20230422215220588"></p><p>​        </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"dog.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">passByVal</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pDog<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pDog<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pDog<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">passByRef</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span><span class="token operator">&amp;</span> pDog<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pDog<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pDog<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"222"</span><span class="token punctuation">,</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pDog1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pDog1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">passByVal</span><span class="token punctuation">(</span>pDog1<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pDog1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">passByRef</span><span class="token punctuation">(</span>pDog1<span class="token punctuation">)</span><span class="token punctuation">;</span>pDog1<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        显然，我们使用引用并更改之（reset方法）后，资源本身也被更改！因此，倘若我们不想让程序无意间更改资源本身，请在函数参数列表中做出如下的修改，那就是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void passByRef(const shared_ptr&lt;dog&gt;&amp; pDog)&#123;pDog-&gt;showDogInfo();&#x2F;&#x2F; pDog.reset(new dog(&quot;222&quot;,222));return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422215456331.png" alt="image-20230422215456331"></p><p>​        这样就修改不了了！</p><h3 id="做返回值"><a href="#做返回值" class="headerlink" title="做返回值"></a>做返回值</h3><p>​        同普通指针类似，这里不做过多的讲解</p><h2 id="和unique-ptr的区别"><a href="#和unique-ptr的区别" class="headerlink" title="和unique_ptr的区别"></a>和unique_ptr的区别</h2><p>​        我们可以将unique_ptr转化为shared_ptr,只需使用std::move就好了！但是反之不能！就像只指向一个内存的一个指针可以用多个指针一同指向它！而反之不能！这里，当我们的函数需要返回一个开辟的地址时，强烈建议返回的指针时unique_ptr！这样方便我们使用！随时可以转化为shared_ptr或者给其他指针赋值，反之很困难！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"dog.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> <span class="token function">getUniPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>unique_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pUniDog <span class="token operator">=</span> <span class="token function">getUniPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pSharedDog <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pUniDog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是值得注意的是：unique_ptr向shared_ptr 转化的时候是隐式转化的！</p><p><img src="image-20230422220750213.png" alt="image-20230422220750213"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;dog.h&quot;#include&lt;iostream&gt;using namespace std;unique_ptr&lt;dog&gt; getUniPtr() &#123;return make_unique&lt;dog&gt;(&quot;111&quot;, 100);&#125;int main()&#123;unique_ptr&lt;dog&gt; pUniDog &#x3D; getUniPtr();shared_ptr&lt;dog&gt; pSharedDog &#x3D; std::move(pUniDog);shared_ptr&lt;dog&gt; pTransform &#x3D; getUniPtr();if (!pTransform) &#123;return -1;&#125;pTransform-&gt;showDogInfo();cout &lt;&lt; pTransform.use_count() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ ptr"></a>weak_ ptr</h2><p>​        这是弱指针！很有趣的是 weak_ptr不可以调用-&gt;和*，因为它压根就没有内存的所有权！那他为什么存在？</p><h3 id="一个循环引用的例子"><a href="#一个循环引用的例子" class="headerlink" title="一个循环引用的例子"></a>一个循环引用的例子</h3><p>​        下面我们修改dog.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setFriend(std::shared_ptr&lt;dog&gt; dog) &#123;this-&gt;friends &#x3D; dog;&#125;&#x2F;&#x2F;private:std::shared_ptr&lt;dog&gt; friends;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;dog.h&quot;#include&lt;iostream&gt;&#x2F;&#x2F;ERROR!!!!!!!!!!!!!!!!!!!!!using namespace std;int main()&#123;shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(&quot;111&quot;, 111);weak_ptr&lt;dog&gt; weak_one(pDog1);cout &lt;&lt; &quot;see:&gt;weak_ptr:&quot; &lt;&lt; weak_one.use_count() &lt;&lt; &quot; while:&gt; &quot; &lt;&lt; pDog1.use_count()&lt;&lt;endl;shared_ptr&lt;dog&gt; pDogLock &#x3D; weak_one.lock();cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;cout &lt;&lt; weak_one.use_count() &lt;&lt; endl;cout &lt;&lt; pDogLock.use_count() &lt;&lt; endl;shared_ptr&lt;dog&gt; pDog3 &#x3D; make_shared&lt;dog&gt;(&quot;333&quot;, 3);shared_ptr&lt;dog&gt; pDog4 &#x3D; make_shared&lt;dog&gt;(&quot;444&quot;, 4);pDog3-&gt;setFriend(pDog4);pDog4-&gt;setFriend(pDog3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422223254134.png" alt="image-20230422223254134"></p><p>​        马上发现问题了！好家伙，333和444没被析构！正确的，因为此时他们循环调用导致计数器失灵！</p><p>​        上述问题可以简化为：</p><p>​        当我们有一个类A，需要存储其他A类的对象的信息的时候，倘若我们使用shared_ptr，就会在销毁的时候遇到循环依赖的问题！比若说</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class A &#123;public:std::shared_ptr&lt;B&gt; bptr;~A() &#123;cout &lt;&lt; &quot;A is deleted&quot; &lt;&lt; endl;&#125;&#125;;class B &#123;public:std::shared_ptr&lt;A&gt; aptr;~B() &#123;cout &lt;&lt; &quot;B is deleted&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    &#123;std::shared_ptr&lt;A&gt; ap(new A);std::shared_ptr&lt;B&gt; bp(new B);ap-&gt;bptr &#x3D; bp;bp-&gt;aptr &#x3D; ap;&#125;    cout&lt;&lt; &quot;Job unfinished,but sadly quit!&quot; endl; &#x2F;&#x2F; 循环引用导致ap bp退出了作用域都没有析构!return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那怎么办？使用weak_ptr就好了</p><p><img src="image-20230422223544954.png" alt="image-20230422223544954"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;std::shared_ptr&lt;dog&gt; friends;std::weak_ptr&lt;dog&gt; friends;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="构造一个weak-ptr"><a href="#构造一个weak-ptr" class="headerlink" title="构造一个weak_ptr"></a>构造一个weak_ptr</h3><p>​        我们注意到，weak_ptr作为shared_ptr的伴生物，其构造从shared_ptr来！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pDog1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>weak_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> <span class="token function">weak_one</span><span class="token punctuation">(</span>pDog1<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"see:>weak_ptr:"</span> <span class="token operator">&lt;&lt;</span> weak_one<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" while:> "</span> <span class="token operator">&lt;&lt;</span> pDog1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422222035184.png" alt="image-20230422222035184"></p><p>​        看到了嘛。我们的weak_ptr当被赋予了同样的地址之后，两者的计数器都不会+1！于是，想要解决上面的问题，只需要把其中一个指针改成weak_ptr就好了！</p><p>​        那么，weak_ptr可不可以转化成shared_ptr呢？可以！调用方法lock() 就OK了！</p><p><img src="image-20230422222447965.png" alt="image-20230422222447965"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm_RecursionSpecial</title>
      <link href="/2023/06/06/Algorithm-RecursionSpecial/"/>
      <url>/2023/06/06/Algorithm-RecursionSpecial/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解递归系列（1）"><a href="#深入理解递归系列（1）" class="headerlink" title="深入理解递归系列（1）"></a>深入理解递归系列（1）</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><a href="https://blog.csdn.net/charlie114514191/article/details/130049282">(43条消息) 深入理解递归系列（1）_charlie114514191的博客-CSDN博客</a></p><p>​        我们在学习与工作中，常常看到这样递归。是的，递归让代码变得简洁，复用率更高。但是我们往往不会很好的使用递归（包括我，QAQ）。 一般来讲，这可能是不知道递归的本质是函数调用，不清晰函数调用的本质造成的，其次，我们很容易陷入递归里去出不来了，搞不清楚当前的状态，也即是：搞错了方向。宏观把控更为重要（后面会细说）</p><p>​        简单来讲，函数体内一次递归是对线性数据结构的遍历处理，二次递归是对二叉树数据结构的递归处理。多次递归是对多叉树进行处理。但这样讲还是抽象，我们先不从应用层面而是转向原理层面来了解递归！</p><h2 id="从栈讲起！"><a href="#从栈讲起！" class="headerlink" title="从栈讲起！"></a>从栈讲起！</h2><p>​        有点莫名奇妙，我们为什么要从栈讲起呢？这是为了后面的系统函数调用栈做准备，如果对栈比自己喜欢吃啥都熟悉，建议移步到系统调用栈下面去。</p><p>​        其实他不是什么新东西，只是一个受到了限制的数据结构（数组，单链表）等。什么意思呢》以数组为例，数组可以在结构的两端插入元素，链表同理。但是现在我们规定我们只能从一端来操作数据结构。举个例子。现在我们要往一个数组里扔东西。对于一个一般的数组，我爱怎么扔怎么扔。但是对于栈来讲，他只能如下图所示的这样的放入数组或者弹出数组。这样受限的数据结构正是栈。</p><p><img src="image-20230409112854441.png" alt="image-20230409112854441"></p><p>​        可以看到，我们把插入和删除换成了 push back 和 pop out. 在栈里，这样的行为叫压栈和弹栈。</p><pre class="line-numbers language-none"><code class="language-none">往栈里放入元素的过程叫压栈往栈里弹出元素的过程叫弹栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        而且，我们只可以对最上面的元素展开操作而不能对下面的元素操作。这样的特点从动态角度来看，不正是后进先出嘛！就是说，最后进入栈的必须第一个出栈</p><p><img src="image-20230409113920536.png" alt="image-20230409113920536"></p><p>​        至于栈的实现如何，这里不做说明，可以看我搞的其他博客或者自行查询怎样实现。</p><h2 id="系统函数调用栈"><a href="#系统函数调用栈" class="headerlink" title="系统函数调用栈"></a>系统函数调用栈</h2><p>​        可以说，栈的一个在操作系统级别的应用，就是系统函数的调用栈。话说的太抽象了，来看个例子！</p><p>​        今天我们需要书写一个程序，很简单，不难的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt; &#x2F;&#x2F; 不熟悉这个的，理解为python 的 import 包就可以了！int getModFrom2Int(int num1,int num2)&#123;    return a % b; &#x2F;&#x2F; 函数执行取余数的操作，并将其返回！&#125;int getAddOf2Int(int num1,int num2)&#123;    int resFromMod &#x3D; getModFrom2Int(num1,num2);    return resFromMod + b;&#125;int main() &#x2F;&#x2F; 程序入口&#123;    int a &#x3D; 3;    int b &#x3D; 2;    int c &#x3D; getAddOf2Int(a,b); &#x2F;&#x2F;     printf(&quot;%d&quot;,c); &#x2F;&#x2F; print the num on console控制台的打印    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是一份简单的C语言代码。从程序运行的顺序来看：程序从 main 进入，经过初始化 a,b的时候，准备初始 c ，但是注意到，c的初始化是由<code>getAddOf2Int</code>这个函数的返回值赋值的，意味着程序必须要进入函数当中。 当程序执行到<code>getAddOf2Int</code>里，他马上又发现， 里头的另一个变量 res ，需要调用函数<code>getModFrom2Int</code>来解决。程序又跳转到<code>getModFrom2Int</code>里去，终于我们不折腾了，对 作为实参的 a, b 取完余数就直接扔回去（优雅的讲叫返回结果指调用处），res 得到了值 3 % 2 = 1，随后，<code>getAddOf2Int</code>又把res和 b 再次相加， 作为<code>getAddOf2Int</code>返回去了，显然这是 3。分析结束，是不是这样呢？我们在Linux下跑一下代码！</p><p>​        如果不知道怎么搞，就这样</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 找到一个文件夹，进入到里面，打开终端 open in terminal</span><span class="token operator">>></span><span class="token operator">></span> <span class="token function">vim</span> runCode1.c<span class="token comment">#书写代码， 当然不熟悉的话，先摁i进入编辑模式随后输入代码</span><span class="token comment"># 写完了退出去，方法是：摁esc，输入:wq退出</span><span class="token operator">>></span><span class="token operator">></span> gcc runCode1 <span class="token comment">#没有就跟提示 sudo apt install gcc</span><span class="token comment"># 没有指定可执行文件，会自动生成 a.out</span><span class="token operator">>></span><span class="token operator">></span> ./a.outres: <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409204340812.png" alt="image-20230409204340812"></p><p>​        找到你的可执行文件，不然就会出现如上图各种各样的报错。我们的分析没有大问题。</p><p>​        可是这跟我们的主题有什么关系呢？别着急，现在就来问你，怎么实现的？怎么让函数按部就班的调用，返回呢？答案就是系统调用函数栈</p><p>​        很好，我们遇到一个函数就把函数地址（函数在哪）压到里面去！直到程序不在调用新的函数（最后一个入栈的不调函数了！）开始逐级返回，函数出栈！</p><p><img src="image-20230409205354471.png" alt="image-20230409205354471"></p><p>​        这些函数在栈里，就用这里的属于说话吧！他们叫栈帧，如同视频一般，一帧一帧展示调用返回。</p><p>​        栈帧是一个复杂的复合体，一般而言他有三个部分构成！</p><p>​        1.函数参数，如 main 函数没有函数参数，而<code>getAddOf2Int</code>有两个参数 num1 ,num2</p><p>​        2.局部变量，如 main 函数里有 a, b ,c 三个在函数体内的变量，<code>getAddOf2Int</code>里有个res 来接受 Mod 函数的返回值。</p><p>​        3.(不好理解)返回地址。这是干嘛的呢？我们在文本编辑器里，可以直观的看到…</p><p><img src="image-20230409210330240.png" alt="image-20230409210330240"></p><p>但是对于CPU来讲，它进到getModFrom2Int里，再次出来的时候不知道下一条指令在哪里。于是，需要存储下一条指令（return resFromMod + num2）的指令地址，方便CPU从其他函数调用之后又再次回来时找到继续执行的地方.</p><p><img src="image-20230409210832275.png" alt="image-20230409210832275"></p><p>​        什么？口说无凭？上汇编！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">objdump <span class="token parameter variable">-S</span> a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>A</p><p><img src="image-20230409211229724.png" alt="image-20230409211229724"></p><p>​        留心到 callq 指令，这是函数调用的指令。函数执行完毕，CPU直接读取栈帧的存储返回地址继续走。</p><h2 id="步入正题！函数调用自己！（就是递归）"><a href="#步入正题！函数调用自己！（就是递归）" class="headerlink" title="步入正题！函数调用自己！（就是递归）"></a>步入正题！函数调用自己！（就是递归）</h2><p>​        我们学习完基本的函数调用之后，有没有一个大胆的想法：函数可不可以调他自己呢？试试！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int main()&#123;cout &lt;&lt; &quot;Lol, I am calling myself again and again!&quot;;Sleep(500); &#x2F;&#x2F; 加个这个，防止程序栈炸了main();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409212333392.png" alt="image-20230409212333392"></p><p>​        是的，尝试自己调用自己！这个函数正在不停的调用他自己，直到函数调用栈溢出崩溃。</p><p><img src="image-20230409213106889.png" alt="image-20230409213106889"></p><p>​        歪！不能这样啊，那咋办，简单，来个中止条件就可以了！简单加个出口。方法就是引入一个计数器，来控制调用次数</p><p><img src="image-20230409213315526.png" alt="image-20230409213315526"></p><p>​        就调用了十次，很好！</p><p>​        当然，没人，除非是真的需要，会对主函数干这种事情。事实上，以递归执行的函数的调用计时器往往放在参数列表里，通过检测参数来停止函数调用</p><p>​        比如说，打印函数3次：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PrintinLimits(int times)&#123;if (times &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; if time is used up,process exited by returning val directlyreturn;&#125;cout &lt;&lt; &quot;Calling for times:&gt;&quot; &lt;&lt; times &lt;&lt; &#39;\n&#39;;PrintinLimits(times - 1); &#x2F;&#x2F; 次数减1，趋向于停止（0就跳出去了）return;&#125;int main()&#123;PrintinLimits(3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409214645855.png" alt="image-20230409214645855"></p><p>所以，到底怎么回事，还是回到调用栈上</p><p><img src="image-20230409215339623.png" alt="image-20230409215339623"></p><p>​        比如说我们今天不好好写高斯求和函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;static int callLimits &#x3D; 10;long GaussainSumInRecurssion(int curAdder)&#123;if (curAdder &#x3D;&#x3D; 0) &#123;return 0;&#125;return curAdder + GaussainSumInRecurssion(curAdder-1);&#125;int main()&#123;cout &lt;&lt; GaussainSumInRecurssion(10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409214756137.png" alt="image-20230409214756137"></p><p>​        是跟上面同理的，但是这个是尾递归，不好理解，我们先不去分析。</p><p>​        仿照这一思路，打印数组也有花样！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void printArrayInRecur(int* array, unsigned int arraySize)&#123;if (arraySize &#x3D;&#x3D; 0) &#123;return;&#125;cout &lt;&lt; array[arraySize - 1] &lt;&lt; &quot; &quot; ; &#x2F;&#x2F; for correctly print&#x2F;&#x2F; 数组下标从0开始，减个一！printArrayInRecur(array, arraySize - 1);return;&#125;int main()&#123;int array[4] &#x3D; &#123;1,2,3,4&#125;;printArrayInRecur(array, 4);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409215928720.png" alt="image-20230409215928720"></p><p>​        手动实现了倒序打印！</p><p>​        那正序呢？</p><p><img src="image-20230409220243255.png" alt="image-20230409220243255"></p><p>​        回忆一下，递归的本质就是函数的调用，而且特别的，是调用他自己，为了防止根本停不下来的调用，我们必须提供一个函数的递归出口——这正是我们之前所阐述的！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;&#x2F;&#x2F; 如果你忘记了的话，看看这个复习一下吧！void printRecur(const int* array, unsigned int start, unsigned int end)&#123;if (array &#x3D;&#x3D; NULL) &#123;return;&#125;if (start &gt;&#x3D; end)&#123;return;&#125;cout &lt;&lt; array[start] &lt;&lt; &quot; &quot;;printRecur(array, start + 1, end);&#125;int main()&#123;int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;printRecur(arr, 0, 10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面继续哔哔新东西！</p><p>​        我们刚刚一直在说系统栈，可不可以书写一个函数来实现我们的系统栈功能呢？可以的：</p><p>​        改造上面的代码为如下，详细的解说请参看代码的注释！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void imitateSysRecur(const int* array, unsigned int start, unsigned int end)&#123;cout &lt;&lt; &#39;\n&#39;;stack&lt;int&gt;* sys &#x3D; new stack&lt;int&gt;();&#x2F;&#x2F; 创造一个空栈sys-&gt;push(array[start]);&#x2F;&#x2F; 这里等效做函数的第一次调用while (!sys-&gt;empty())&#x2F;&#x2F; 查看有没有弹出干净，没有继续弹出！&#123;int prt &#x3D; sys-&gt;top();&#x2F;&#x2F; 一下就弹出第一个任务if (start &gt;&#x3D; end)return;printf(&quot;%d &quot;, prt); &#x2F;&#x2F; 对之执行操作sys-&gt;push(array[++start]);&#x2F;&#x2F; 转向下一个&#125;&#125;int main()&#123;int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;imitateSysRecur(arr, 0, 10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="虽说递归爽，但是注意到性能问题！"><a href="#虽说递归爽，但是注意到性能问题！" class="headerlink" title="虽说递归爽，但是注意到性能问题！"></a>虽说递归爽，但是注意到性能问题！</h2><p>​        递归也有代价：写的爽必然有代价。</p><p>​        首先函数调用就有时间的开销（注意到递归反复调用函数）</p><p>​        其次，这也存在空间上的开销！我们需要占一定的空间复杂度来运行我们的函数。</p><p>​        那么，什么时候使用递归呢？预告一下：正是那些非线性的数据结构我们使用递归来处理，这将会在树与图论中显的常见！</p><h2 id="练习1：递归求解线性表：如数组的和"><a href="#练习1：递归求解线性表：如数组的和" class="headerlink" title="练习1：递归求解线性表：如数组的和"></a>练习1：递归求解线性表：如数组的和</h2><p>​        首先，我们来看，对于一个线性表，我们若是想得知这些元素的和：</p><script type="math/tex; mode=display">A = \sum_{i=0}^{n-1}a[i]</script><p>​        然而马上发现，这个表达式可以写作：</p><script type="math/tex; mode=display">A = \sum_{i=0}^{n-1}a[i] = a[n-1] + \sum_{i=0}^{n-2}a[i]</script><p>​        啊哈！这递归就出来了：终止条件就是当取到 arr[0]时停止！，这样就可以开始设计递归了。</p><p>​        我们的结果可以存放在函数的参数列表里，这样的话递归不用开辟新的空间存放局部变量！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long getSumRecur(const int* arr, unsigned int arrSize,int curSum)&#x2F;&#x2F; 设计1&#123;if (arr &#x3D;&#x3D; nullptr) &#x2F;&#x2F; 不合法的数组return&#123;return -1;&#x2F;&#x2F; 这个地方放错误处理，可以是cstdlib下的exit!&#125;if (arrSize &#x3D;&#x3D; -1) &#x2F;&#x2F; 即将越界&#123;return curSum; &#x2F;&#x2F; 求和结束，直接返回当下参数的curSum就好了&#125;getSumRecur(arr, arrSize - 1, curSum + arr[arrSize]);    &#x2F;&#x2F; 递归！ 让arrSize减1， 表明arr[size-1]已经纳入和 curSum 了！    &#x2F;&#x2F; 同时，在参数列表中做出 curSum + arr[arrSize]的修改就好了&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的递归适合与有前缀初始值的求和！</p><p>​        有没有别的形式的？有。直接注意到：没有必要新增一个参数，而是直接return掉局部和！就是说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">return arr[size] + getCur2(arr,size-1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为为了返回，必须要把getCur2的值求出来，一直递归到函数不需要调用自己为止！那就很是容易了，只要curSize == 0,返回 arr[curSize]就好了！（其实就是arr[0]）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long getSumRecur2(const int* arr,int arrSize)&#123;if (arr &#x3D;&#x3D; nullptr) &#123;return -1;&#125;if (arrSize &#x3D;&#x3D; 0)&#123;return arr[0];&#125;return arr[arrSize] + getSumRecur2(arr, arrSize - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        run 一下代码！</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;cout &lt;&lt; getSumRecur(arr, 9, 0)&lt;&lt; endl;cout &lt;&lt; getSumRecur2(arr, 9) &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230412214901272.png" alt="image-20230412214901272"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learn_ROS-I</title>
      <link href="/2023/06/06/Learn-ROS-I/"/>
      <url>/2023/06/06/Learn-ROS-I/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS-I-初试"><a href="#ROS-I-初试" class="headerlink" title="ROS-I 初试"></a>ROS-I 初试</h1><h1 id="ROS节点-范例"><a href="#ROS节点-范例" class="headerlink" title="ROS节点 范例"></a>ROS节点 范例</h1><h2 id="1-创建一个节点"><a href="#1-创建一个节点" class="headerlink" title="1.创建一个节点"></a>1.创建一个节点</h2><p>​        当我们下好了 ROS 之后，可以尝试创建自己的一个节点了！但是正如同工作要有工作桌，我们创立一个工作区才能干活，于是，我们先 mkdir 一个文件夹！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/RosWork<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以及建立一个子文件夹 src ，他就是来存我们源代码的地方</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/RosWork/<span class="token function">mkdir</span> src <span class="token builtin class-name">cd</span> ./src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <strong>不要换 src 名字！！！</strong></p><p>​        下面向电脑宣称这地方归 ROS 管：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin_init_workspace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        先返回上一级文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        先编译一次环境：</p><pre class="line-numbers language-none"><code class="language-none">catkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        从而产生工作文件！我们多了很多文件夹：</p><p><img src="image-20230302231715222.png" alt="image-20230302231715222"></p><p>​        下一步，就是设置一下环境变量，让电脑和ROS知道你的办公桌子在哪里：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不放心？想看看地方对没对？用这个指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$ROS_PACKAGE_PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230302232048106.png" alt="image-20230302232048106"></p><p>​        这下工作桌修好了！</p><h2 id="开始向里面塞东西"><a href="#开始向里面塞东西" class="headerlink" title="开始向里面塞东西"></a>开始向里面塞东西</h2><p>​        下面向节点里面塞东西：</p><p>​        下面创建一个 package 包（节点下属的一个功能包）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ./srccatkin_create_pkg talkerAndListener std_msgs rospy roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        后边包含了在编译时需要依赖的其他功能包：ROS 的标准消息结构（int、bool 等）以及 C++ 和 Python 的接口。</p><p>​        进去 src 文件看看</p><p>​        <img src="image-20230302232535223.png" alt="image-20230302232535223"></p><p>​        我们可以开始写文件了：</p><p>​        为了测试，我们选用最经典的 订阅 与 接受 来尝试我们的第一次节点编写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/你的工作区文件夹/src/talker_and__listener/src<span class="token function">vim</span> listener.cpp <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        偷懒了，用 vim 直接编辑！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 塞这些东西进去&#x2F;&#x2F; 原博客：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44420419&#x2F;article&#x2F;details&#x2F;111355655#include &quot;ros&#x2F;ros.h&quot;#include &quot;std_msgs&#x2F;String.h&quot; &#x2F;&#x2F;所要订阅的消息类型，此处是std)msgs包下的String。msg&#x2F;&#x2F;回调函数部分void chatterCallback(const std_msgs::String::ConstPtr&amp; msg)&#123;    ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str()); &#x2F;&#x2F;将接收到的消息打印出来&#125;&#x2F;*subscriber的回调函数，当接收到 chatter 话题的时候就会被调用。参数是所接收的消息的常数指标（const pkg_name::msg_name::ConstPtr&amp; msg）.消息是以 boost shared_ptr 指针的形式传输，这就意味着你可以存储它而又不需要复制数据。之后使用msg-&gt;field_name即可存取message的资料*&#x2F;int main(int argc, char **argv)&#123;    ros::init(argc, argv, &quot;listener&quot;); &#x2F;&#x2F;初始化ROS节点    ros::NodeHandle n; &#x2F;&#x2F;创建句柄节点    ros::Subscriber sub &#x3D; n.subscribe(&quot;chatter&quot;, 1000, chatterCallback);&#x2F;*告诉 master 要订阅 chatter 话题（第一个参数）上的消息。当有消息发布到这个话题时，ROS 就会调用 chatterCallback() 函数（第三个参数）。第二个参数是队列大小，当缓存达到 1000 条消息后，自动舍弃时间戳最早的消息。NodeHandle::subscribe() 返回 ros::Subscriber 对象,此处为sub。当这个对象销毁时，它将自动退订 chatter 话题的消息。有各种不同的 NodeHandle::subscribe() 函数，可以指定类的成员函数，甚至是 Boost.Function 对象可以调用的任何数据类型。*&#x2F;    ros::spin();&#x2F;*ros::spin() 进入自循环，可以尽可能快的调用消息回调函数，会调用主程序中所有回调函数，此处只有chatterCallback()一旦 ros::ok() 返回 false，ros::spin() 就会立刻跳出自循环。这有可能是 ros::shutdown() 被调用，或者是用户按下了 Ctrl-C，使得 master 告诉节点要终止运行。*&#x2F;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在：摁 esc 输入 :wq 退出编辑和 vim ，随后再整一个 talker.cpp</p><pre class="line-numbers language-none"><code class="language-none">vim talker.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;头文件部分#include &lt;sstream&gt; #include &quot;ros&#x2F;ros.h&quot; &#x2F;*&quot;ros&#x2F;ros.h 是一个实用的头文件，它引用了 ROS 系统中大部分常用的头文件。&quot;地址在 &#x2F;opt&#x2F;ros&#x2F;noetic&#x2F;include&#x2F;ros&#x2F;&quot; *&#x2F;#include &quot;std_msgs&#x2F;String.h&quot; &#x2F;* &quot;std_msgs&quot;是一个消息类型依赖包，此处要传输string类型数据，需要包含该数据类型的头文件String.h，就在这个依赖包里 *&#x2F;&#x2F;&#x2F;初始化部分int main(int argc, char **argv)&#123;    ros::init(argc, argv, &quot;talker&quot;);    &#x2F;* ROS节点初始化。初始化的init函数包含三个参数，    前两个参数是命令行或launch文件输入的参数，可以用来命名重映射等功能；    第三个参数定义了Publisher节点的名称“talker”，不允许重复，是一个base name。 *&#x2F;        ros::NodeHandle n;    &#x2F;* 为这个进程的节点创建一个句柄。    第一个创建的 NodeHandle 会为节点进行初始化，    最后一个销毁的 NodeHandle 则会释放该节点所占用的所有资源。 *&#x2F;        ros::Publisher chatter_pub &#x3D; n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000);    &#x2F;* 告诉 master 将要在 chatter（话题名）上发布 std_msgs&#x2F;String 消息类型的消息。    这样 master 就会告诉所有订阅了 chatter 话题的节点，将要有数据发布。    NodeHandle::advertise() 会建立一个topic。在ROS Master端注册一个Publisher，    返回一个 ros::Publisher 对象,此处为chatter_pub，,它有两个作用：     1) 它有一个 publish()函数可以在topic上发布(pubish)消息；     2) &lt;std_msgs::String&gt;指定后面要发布的消息类型是std_msgs包中的string类型，如果消息类型不对,它会拒绝发布。         (&quot;chatter&quot;, 1000)中两个参数，第一个参数指定以&quot;chatter&quot;为话题发布消息    第二个参数是发布序列的大小。如果发布的消息的频率太高，缓冲区中的消息在大于 1000 个的时候就会开始丢弃先前发布的消息。*&#x2F;        ros::Rate loop_rate(10);    &#x2F;* ros::Rate 对象可以允许你指定自循环的频率。它会追踪记录自上一次调用 Rate::sleep() 后时间的流逝，并休眠直到一个频率周期的时间。在这个例子中，让它以 10Hz 的频率运行，即节点休眠时间为100ms。 *&#x2F;       &#x2F;&#x2F;循环部分    int count &#x3D; 0;    while (ros::ok())    &#123;    &#x2F;*进入节点的主循环，如果下列条件之一发生，ros::ok() 返回false，跳出循环：·SIGINT 被触发 (Ctrl+C)：roscpp 会默认生成一个 SIGINT 句柄，它负责·处理 Ctrl+C 键盘操作使ros::ok() 返回 false·被另一同名节点踢出 ROS 网络·关闭函数ros::shutdown() 被程序的另一部分调用·节点中的所有 ros::NodeHandles 都已经被销毁一旦 ros::ok() 返回 false, 所有的 ROS 调用都会失效。    *&#x2F;            std_msgs::String msg;&#x2F;&#x2F;建立暂存区，先将消息放入，在进行publish        std::stringstream ss;        ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count;        msg.data &#x3D; ss.str();&#x2F;&#x2F;将要输出的字符串消息存储到string消息类型中唯一成员data中        ROS_INFO(&quot;%s&quot;, msg.data.c_str()); &#x2F;&#x2F;类似C&#x2F;C++的 printf&#x2F;cout 等函数，打印日志信息。        chatter_pub.publish(msg);&#x2F;&#x2F;发布封装完毕的消息msg。Master会查找订阅该话题的节点，并完成两个节点的连接，传输消息                ros::spinOnce();&#x2F;&#x2F;处理订阅话题的所有回调函数callback()，        loop_rate.sleep(); &#x2F;&#x2F;休眠，休眠时间由loop_rate()设定        ++count;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     打开你的 CMakeLists.txt ，随后找到（这里推介使用VScode 的搜索，嘎嘎快）</code></pre><p>​        留意到这里：</p><pre class="line-numbers language-none"><code class="language-none">add_executable()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是用于设置需要编译的代码和生成的可执行文件。第一个参数为期望生成的可执行文件的名称，后边的参数为参与编译的源码文件（cpp），如果需要多个代码文件，则可<br>在后面依次列出，中间用空格进行分隔。</p><p>​        和：</p><pre class="line-numbers language-none"><code class="language-none">target_link_libraries<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用于设置链接库。很多功能需要使用系统或者第三方的库函数，通过该选项可以配置<br>执行文件链接的库文件，第一个参数是可执行文件的名称，后面依次列出需要链接的<br>库。此处编译没有使用其他库，添加默认链接库${catkin_LIBRARIES}即可。</p><p>​        以及</p><pre class="line-numbers language-none"><code class="language-none">add_dependencies<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用于设置依赖。在很多应用中，我们需要定义语言无关的消息类型，消息类型会在编<br>译过程中产生相应语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则<br>需要使用add_dependencies添加${PROJECT_NAME}_generate_messages_cpp<br>配置，即该功能包动态产生的消息代码。该编译规则也可以添加其他需要依赖的功能包。</p><p>​        下面我们设置一下：</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">include_directories(include $&#123;catkin_INCLUDE_DIRS&#125;)add_executable(talker src&#x2F;talker.cpp)target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)add_dependencies(talker $&#123;PROJECT_NAME&#125;_generate_messages_cpp)add_executable(listener src&#x2F;listener.cpp)target_link_libraries(listener $&#123;catkin_LIBRARIES&#125;)add_dependencies(listener $&#123;PROJECT_NAME&#125;_generate_messages_cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230302234440520.png" alt="image-20230302234440520"></p><p>​        现在注意，现在注意！我们的Cmake 的版本要求的是过高的，需要调整最低版本，否则在之后的文件编译中是会爆出找不到文件的迷惑错误！看到文件的第一行</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">cmake_minimum_required(VERSION 3.0.2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        改成：</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">cmake_minimum_required(VERSION 2.8.3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        编译一下</p><p><img src="image-20230302234954815.png" alt="image-20230302234954815"></p><p>​        成功了。</p><p>​        为了运行，还是要设置环境变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/<span class="token operator">&lt;</span>workspace name<span class="token operator">></span><span class="token builtin class-name">source</span> ./devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​            想偷懒的话</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"source ~/ros/tr3_6/devel/setup.bash"</span> <span class="token operator">>></span> ~/.bashrc$ <span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        启动 ROS:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        开一个新终端：运行我们的包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun talkerAndlistener talker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        再来一个：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun talkerAndlistener listener<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230303002333631.png" alt="image-20230303002333631"></p><p>​        下班！</p><h1 id="ROS节点：调试（基于VScode）"><a href="#ROS节点：调试（基于VScode）" class="headerlink" title="ROS节点：调试（基于VScode）"></a>ROS节点：调试（基于VScode）</h1><p>​        我们已经学会创建一个简单的 ROS 节点了，但是，我们应当要学会调试，毕竟，我们的代码可不会那么短！出现了问题调试就是必然的！</p><p>​        下面开始介绍基于Vscode的 ROS 的调试办法：</p><h2 id="创建调试用的节点"><a href="#创建调试用的节点" class="headerlink" title="创建调试用的节点"></a>创建调试用的节点</h2><p>​        首先 cd 到工作文件夹，创建他们</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> workTab2/src<span class="token builtin class-name">cd</span> workTab2catkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        以准备好基本的文件！</p><h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><p>​        VScode 有两个很是好用的插件！一个是ROS，另一个是 catkin_tools 他们可以让你很好的进行ROS运行和调试（不用再命令框里看了！）。</p><p>​        那么问题来了，在哪里打开VScode 呢？显然不是随便打开，也不是在src文件，而是在工作文件夹 workTab2 下，</p><p><img src="image-20230304211639014.png" alt="image-20230304211639014"></p><p>​        这个地方，准备 ctrl+alt+T打开终端：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">code <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是结构！就出来了：</p><p><img src="image-20230304211739953.png" alt="image-20230304211739953"></p><p>​        点击最左侧栏目中的第四个：扩展，安装</p><p><img src="image-20230304211827660.png" alt="image-20230304211827660"></p><p><img src="image-20230304211844585.png" alt="image-20230304211844585"></p><p><img src="image-20230304211905431.png" alt="image-20230304211905431"></p><p><img src="image-20230304211913952.png" alt="image-20230304211913952"></p><p>​        好消息是：一般你已经安上了。</p><p>​        但是这两个：</p><p><img src="image-20230304211953729.png" alt="image-20230304211953729"></p><p><img src="image-20230304212010942.png" alt="image-20230304212010942"></p><p>​        是你大概率没有安装的！安上！</p><p>​        好了！让我们见识一下这玩意好用不好用！</p><p>​        一般的，在官方的命令行创建时如下的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/workTab2/srccatkin_create_pkg talker roscpp rospy std_msgs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        命令行快，但是不够可视化。那我们安装的插件是怎么处理的呢？看到VScode 的文件管理器：右键 src</p><p><img src="image-20230304212352420.png" alt="image-20230304212352420"></p><p>​        怎么着？有一个 Create Catkin Package 了，点击它：</p><p><img src="image-20230304212442723.png" alt="image-20230304212442723"></p><p>​        留意这里！你可以输入你想创建的节点名字！</p><p><img src="image-20230304212525846.png" alt="image-20230304212525846"></p><p>​        你一需要的 dependencies （就是命令行后半部分的内容）</p><p>​        一个回车：包创建结束</p><p><img src="image-20230304212701151.png" alt="image-20230304212701151"></p><h2 id="Coding时间"><a href="#Coding时间" class="headerlink" title="Coding时间"></a>Coding时间</h2><p>​        在我们的 src 文件夹下，右键整一个新文件：写完代码</p><p><img src="image-20230304212841542.png" alt="image-20230304212841542"></p><p>​        现在你无论是调试还是运行都不行！缺少配置文件！这是最最最麻烦的地方！！！</p><h2 id="补全配置文件"><a href="#补全配置文件" class="headerlink" title="补全配置文件"></a>补全配置文件</h2><h3 id="CmakeLists-txt-的内容补全"><a href="#CmakeLists-txt-的内容补全" class="headerlink" title="CmakeLists.txt 的内容补全"></a>CmakeLists.txt 的内容补全</h3><p>​        有点捞，这个还是要我们自己在文件中手动补充！</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">aux_source_directory(.&#x2F;src SRCS)add_executable(talker $&#123;SRCS&#125;)target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        有趣的是！这次我们不需要再次改动 Cmake的最低要求版本了！</p><h3 id="查看c-cpp-properties-json"><a href="#查看c-cpp-properties-json" class="headerlink" title="查看c_cpp_properties.json"></a>查看c_cpp_properties.json</h3><p>​        一般我们改动添加：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"compileCommands"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;/build/compile_commands.json"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们后面会知道，这是调用产生的调试文件，等效于在命令行输入了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">catkin_make <span class="token operator">-</span>DCMAKE_EXPORT_COMPILE_COMMANDS<span class="token operator">=</span> YES<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        后调用它，他在 devel/lib里面！</p><p>​        不同于我参考的，我选择了直接在命令行里直接编译产生二进制文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin_make catkin_make <span class="token parameter variable">-DCMAKE_EXPORT_COMPILE_COMMANDS</span><span class="token operator">=</span> YES<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        省事！</p><h3 id="不用改动settings-json"><a href="#不用改动settings-json" class="headerlink" title="不用改动settings.json"></a>不用改动settings.json</h3><h3 id="手动产生task-json"><a href="#手动产生task-json" class="headerlink" title="手动产生task.json"></a>手动产生task.json</h3><p>​        我说停！不是让你 vim task.json ，而是在Vscode 里摁下 ctrl + shift + P </p><p><img src="image-20230304214318786.png" alt="image-20230304214318786"></p><p>​        输入 tasks: configure task单击一下，注意，会弹出来很多东西！找到：catkin_make: build 点击（其他的我不清楚，萌新QAQ）。</p><p>​        对文件做出如下的修改：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"2.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"tasks"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"catkin_make"</span><span class="token punctuation">,</span> <span class="token comment">//代表提示的描述性信息</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"shell"</span><span class="token punctuation">,</span>  <span class="token comment">//可以选择shell或者process,如果是shell代码是在shell里面运行一个命令，如果是process代表作为一个进程来运行</span>            <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"catkin_make"</span><span class="token punctuation">,</span><span class="token comment">//这个是我们需要运行的命令</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">"-DCMAKE_EXPORT_COMPILE_COMMANDS=ON"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment">//如果需要在命令后面加一些后缀，可以写在这里，比如-DCATKIN_WHITELIST_PACKAGES=“pac1;pac2”</span>            <span class="token property">"group"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"kind"</span><span class="token operator">:</span><span class="token string">"build"</span><span class="token punctuation">,</span><span class="token property">"isDefault"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"presentation"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"reveal"</span><span class="token operator">:</span> <span class="token string">"always"</span><span class="token comment">//可选always或者silence，代表是否输出信息</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"problemMatcher"</span><span class="token operator">:</span> <span class="token string">"$msCompile"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        ！我参考的 CSDN 的作者说他不清楚为什么需要添加</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token string">"-DCMAKE_EXPORT_COMPILE_COMMANDS=ON"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是因为我们本质上是链接 ROS 官方的调试文件产生方法，从那里来调试，如果我们不在这里下这个指令，以及不在c_cpp_properties.json 做出那样更改的话：我们无法链接那个文件！</p><h3 id="手动创建-launch-json"><a href="#手动创建-launch-json" class="headerlink" title="手动创建 launch.json"></a>手动创建 launch.json</h3><p>​        别！不用 vim. 最聪明的办法是</p><p><img src="image-20230304215129045.png" alt="image-20230304215129045"></p><p>​        点击它，配置如下内容</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;(gdb) Launch&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            # 这里要修改，找到编译生成的二进制可执行文件            # 这里！！！！！！！！！！！！！！！！！！！！！！！！                   &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;build&#x2F;talker&#x2F;talker&quot;,             &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &#x2F;&#x2F;&quot;preLaunchTask&quot;: &quot;build&quot;,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: false,            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;targetArchitecture&quot;: &quot;x64&quot;,            &quot;avoidWindowsConsoleRedirection&quot;: true,            &quot;setupCommands&quot;: [                &#123;                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ]        &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        好的，如果你执行过：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin_make <span class="token parameter variable">-DCMAKE_EXPORT_COMPILE_COMMANDS</span><span class="token operator">=</span> YES<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        那你就去 build下面找！</p><p>​        我的是：</p><pre class="line-numbers language-none"><code class="language-none">~&#x2F;workTab2&#x2F;build&#x2F;talker&#x2F;talker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        而如果你是采用 Ctrl + shift+ B VScode 的 task.json 来帮你编译的：就去devel/lib下找！</p><pre class="line-numbers language-none"><code class="language-none">~&#x2F;workTab2&#x2F;devel&#x2F;lib&#x2F;talker&#x2F;talker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        总而言之，找到你的二进制文件在哪里！！！</p><p>​        现在的现在，再次编译一次！！！Ctrl+shift+B!!!</p><p>​        如果出现了编译成功（粉色的蓝色的绿色的都有，但是红色的就是寄！这个时候会给你报一些警告和错误！可以留意）</p><p>​        随后，尝试调试：</p><p><img src="image-20230304230646212.png" alt="image-20230304230646212"></p><p>​        出现这个，恭喜你！调试成功！可以打断点了！</p><p><img src="image-20230304232246697.png" alt="image-20230304232246697"></p><p>​        OK！下班！！！</p><p>​        如果对文件有所更改，请注意，你需要重新编译：Ctrl + Shift + B，随后再次调试！</p><p>​        如果断点失效，博主这里没有什么更好的办法（整了几个小时也没拿出可行的方案（彩笔落泪）），那只好试试重新生成文件看看！</p><h1 id="ROS入门"><a href="#ROS入门" class="headerlink" title="ROS入门"></a>ROS入门</h1><p>​        ROS：Robot operating System</p><p>​        他是一个开源元操作系统，类似于我们经典意义的操作系统，有大量的工具，库与协议，还可以在多台计算机上获取，构建编写和运行代码的工具和库。</p><p><img src="image-20230329203952156.png" alt="image-20230329203952156"></p><p>​        至于ROS 的安装，这就不在阐述！</p><p>​        还是决定提供一个简单的方式测试一下你的ROS有没有安装成功。启动Linux虚拟机，随后开三个终端！</p><p>​        第一个终端启动ros环境，输入</p><pre class="line-numbers language-none"><code class="language-none">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        第二个输入</p><pre class="line-numbers language-none"><code class="language-none">rosrun turtlesim turtlesim_node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        第三个输入</p><pre class="line-numbers language-none"><code class="language-none">rosrun turtlesim turtle_teleop_key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        看看小乌龟可不可以跑！注意第三个终端要在最上面！（焦点必须在第三个终端）</p><h2 id="体验经典：hello-world"><a href="#体验经典：hello-world" class="headerlink" title="体验经典：hello world"></a>体验经典：hello world</h2><p>​        ROS工作的程序有C++ 和 Python。</p><p>​        首先，我们需要让Linux认识一下ROS的库！这需要我们来初始化工作环境！其基本步骤如下：</p><ol><li><p>先创建一个工作空间</p></li><li><p>创建一个工作包</p></li><li><p>编辑源文件</p></li><li><p>编辑配置文件</p></li><li><p>编译并执行</p></li></ol><p>​        当然，真正的差异就在第四步，那我们先来看前几步！</p><p>第一步：</p><p>​        简而言之，找个地方！安装当下的文件，今天我们先创建一个RosLearn 文件夹吧，以及我们的第一个实验：Learn1,注意，还要整一个 src 文件夹，并且必须是这个名字！！！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> Roslearn/learn1/src<span class="token builtin class-name">cd</span> Roslearn/learn1catkin_make <span class="token comment">#this instructions aims to init the workspace!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="1-16806218690051.png" alt="1"></p><p><img src="1 (2" alt="1 ( 1 (2)-16806218769883.png)">-16806218769883.png)</p><p>​        这些正是Cmake的日志，下面开始第二部，创建一些简单的package!</p><p>​        我们把我们一切的源文件放到src文件夹下，随后，在命令行下输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如是，创建功能节点即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin_create_pkg <span class="token string">'packName'</span> <span class="token string">'dependency'</span> <span class="token comment">#when writing , you are no need to add ''!</span><span class="token comment"># examples</span>catkin_create_pkg helloWorld roscpp rospy std_msgs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        会发现：</p><p><img src="4-16806218814825.png" alt="4"></p><p><img src="5-16806218834477.png" alt="5"></p><p>​        多了很多文件，我们不予理会，还没到时候！</p><p>​        roscpp是C++的实现库，rospy是 python库的，这点需要注意！</p><p>​        好了，开始第三步！！！cd到包里的src文件</p><p><img src="10.png" alt="10"></p><p>​        如果熟悉 vim, 可以直接 vim helloworld_cpp.cpp来一个！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> helloworld_cpp.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        书写这些代码！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;ros&#x2F;ros.h&quot;int main(int argc,char* argv[])&#123;    ros::init(argc,argv,&quot;hello&quot;);        ROS_INFO(&quot;hello world!!!&quot;);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        摁esc退出insert模式，随后:wq退出vim。</p><p>​        随后，更改CmakeLists 配置文件，注意到是这里的</p><p><img src="image-20230404230008119.png" alt="image-20230404230008119"></p><p>​        找到第136行的 add_executable,和第149行的target_link_library做出这样的更改</p><p><img src="image-20230404230318106.png" alt="image-20230404230318106"></p><p>​        这个haha是Cmake下的临时变量，注意到149行的name必须和136行的name一致</p><p>​        最后一步就是编译！！！</p><p>​        退回到最顶层工作文件夹，再次编译，若有错，按照报错改！</p><p><img src="image-20230404231553533.png" alt="image-20230404231553533"></p><p>​        没有错的话，是这样的 </p><p><img src="image-20230404231631732.png" alt="image-20230404231631732"></p><p>​        开一个新端</p><p>​        先让ros环境启动一下！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        回到原来的终端，注意是原来的！！！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ./devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不知道啥情况的找到这个文件然后source一下。</p><p>​        下面，就可以有</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun helloworld haha<span class="token comment">#helloworld包下的haha</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        至于集成的开发环境，可以考虑VScode+插件，具体的配置方法在我的博客已经讲述过了！不再讲述！</p><h2 id="ROS节点说明"><a href="#ROS节点说明" class="headerlink" title="ROS节点说明"></a>ROS节点说明</h2><p>​        我们大多数时候需要启动多个ROS节点，这就需要我们写Launch文件来完成这个工作！</p><p>​        其实现如下：(以经典乌龟为例)</p><p>​        1)选定功能包右击—&gt;添加launch文件夹</p><p>​        2)选定launch文件邮寄—&gt;添加launch文件(xml文件)</p><p>​        3)书写</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">...</span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        node : 节点</p><p>​        pkg 功能包</p><p>​        type: 被运行的节点文件</p><p>​        name 为节点命名</p><p>​        output 设置日志的输出目标</p><pre class="line-numbers language-none"><code class="language-none">roslaunch 包名 launch文件名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="撸代码"><a href="#撸代码" class="headerlink" title="撸代码"></a>撸代码</h2><p>​        下面,在一个节点下新建一个launch文件夹,随后在这个文件夹下面新建xml文件        </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- add nodes here--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        不要急着就写下面,先保存,后跑一下可不可以跑!</p><p>​        摁 ctrl + ~打开bash ,先搞一下环境变量 source ./devel/setup.bash</p><p>​        然后跑一下</p><p><img src="image-20230418221943490.png" alt="image-20230418221943490"></p><p>​        这个Launch标签就是启动环境的,下面开始书写</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- add nodes here--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim_node<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>GUI<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle_teleop_key<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Key<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello_cpp<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello_cpp_c<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>try<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- pkg是包名 type就是运行文件!切记--></span><span class="token comment">&lt;!-- output 表示的是输出的日志输出在哪里--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ROS架构"><a href="#ROS架构" class="headerlink" title="ROS架构"></a>ROS架构</h1><p>​        现在我们开始讲解ROS的架构</p><h2 id="设计者"><a href="#设计者" class="headerlink" title="设计者"></a>设计者</h2><p>​        ROS的设计者将ROS表述为“ROS = Plumbing + Tools + Capabilities + Ecosystem”</p><p>​        Plumbing 是通讯机制（实现ROS不同节点）</p><p>​        Tools 是工具软件包（ROS开发和调试工具）</p><p>​        Capabilities 机器人高层技能（导航）</p><p>​        EcoSystem 机器人生态</p><h2 id="维护角度"><a href="#维护角度" class="headerlink" title="维护角度"></a>维护角度</h2><p>​        main:核心部分</p><p>​        universe: 一些扩展的代码</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>​        ROS可以有三层</p><p>​        （1）OS层 ，也就是经典操作系统 ，ROS是一个元操作系统</p><p>​        （2）中间层：封装了一些机器人开发的中间件</p><p>​                如：基于TCP/UDP 继续封装的TCPROS/UDPROS系统</p><p>​        （3）应用层</p><h2 id="自身结构"><a href="#自身结构" class="headerlink" title="自身结构"></a>自身结构</h2><p>​        文件系统：ROS文件系统指的是硬盘上面查看ROS源代码的组织形式。</p><p>​        计算图： 不同进程需要的进行数据交互。计算图可以良好的表现他们的作用关系</p><p>​        开源社区：略</p><h2 id="ROS文件系统"><a href="#ROS文件系统" class="headerlink" title="ROS文件系统"></a>ROS文件系统</h2><p><img src="image-20230419190503178.png" alt="image-20230419190503178"></p><p>​        如上图，这就是一个ROS的文件结构。</p><p><img src="image-20230419190959393.png" alt="image-20230419190959393"></p><p>​        下面详细重点的介绍如下的文件</p><h3 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h3><p>​        这个文件是自动生成的，他在这里：</p><p><img src="mage-20230419191623848.png" alt="image-20230419191623848"></p><p>​        是的，就在SRC文件夹下面</p><p>​        打开看看，就会发现这里有软件包名称，版本号，作者，维护者以及其他信息。</p><p><img src="image-20230419191807747.png" alt="image-20230419191807747"></p><p>​        <img src="image-20230419191842956.png" alt="image-20230419191842956"></p><p>​        这里可以查看依赖。</p><h3 id="CmakeLists-txt"><a href="#CmakeLists-txt" class="headerlink" title="CmakeLists.txt"></a>CmakeLists.txt</h3><p>​        隔壁就是CmakeLists.txt。大量的对象我们用到再说，先不说过多！</p><h2 id="ROS文件系统的相关命令"><a href="#ROS文件系统的相关命令" class="headerlink" title="ROS文件系统的相关命令"></a>ROS文件系统的相关命令</h2><p>​        下面我们来看一些常见的指令：</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>​        catkin_create_pkg 自定义的包名 依赖的包 == 创建新的ROS功能包</p><p>​        sudo apt install xxx ==安装ROS功能包 （后期经常用）</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>​        sudo apt purge xxx == 删除功能包</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>​        rospack list == 列出所有的功能包</p><p>​        rospack find 包名 == 查询寻包名是否存在，存在返回安装路径</p><p>​        roscd 包名 == 进入摸一个包</p><p>​        rosis 包名 == 列出包下的文件</p><p>​        apt search xxx == 搜索包</p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>​        rosed 包名 文件名 === 修改功能包文件</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>​        roscore === 是ROS系统先决条件和程序的集合，必须先启动ROScore</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roscore//roscore <span class="token parameter variable">-p</span> xxxx <span class="token comment"># 指定端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230419192925843.png" alt="image-20230419192925843"></p><p>​        启动发现产生了大量的信息，这是熟知英文就可以读懂了，以及这个</p><p><img src="image-20230419193030054.png" alt="image-20230419193030054"></p><p>​        这个是输出日志的Linux地址，可以查看这里。</p><p>​        </p><pre class="line-numbers language-none"><code class="language-none">rosrun 包名 可执行文件名 &#x3D;&#x3D;&#x3D; 运行指定的ROS节点<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        尝试一下：（rospack list）</p><p><img src="image-20230419193647318.png" alt="image-20230419193647318"></p><p>​        cd 一下</p><p>​        <img src="image-20230419193838171.png" alt="image-20230419193838171"></p><p>​        在全网搜寻一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> search ros-noetic-*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230419194007901.png" alt="image-20230419194007901"></p><p>​        当然，这不好，我们grep检索一下、</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> search ros-noetic-* <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> gmapping<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230419194126253.png" alt="image-20230419194126253"></p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>​        下面要说的是显示个节点关系的一个有效的动态展示图，他就是rqt_graph，用来展示错综复杂的节点关系！</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​        直接先跑一下这个玩意</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun rqt_graph rqt_graph <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果告诉你没安装，装一下就好了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-rqt<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-rqt-common-plugins-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-用ROS你自己安装的版本替代！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422205657970.png" alt=""></p><p>​        注意开的时候先把环境给开了！</p><p>​        然后，启动一下我们之前写的Launch脚本，这样，再次运行rosrun rqt_graph rqt_graph ：</p><p><img src="image-20230422210243852.png" alt="image-20230422210243852"></p><p>​        好了，基础的ROS认识就到这里，之后我们开始讲授核心！ROS的通讯机制！</p><h1 id="ROS通信机制"><a href="#ROS通信机制" class="headerlink" title="ROS通信机制"></a>ROS通信机制</h1><p>​        机器人是一种高度复杂的系统性实现。在机器人上可能集成了各种传感器（雷达）等，为了解耦合，ROS的每一个功能点都是一个单独的进程，并且他们是可以独立运行的。ROS是进程的分布式框架。</p><p>ROS 实现通信机制的三种实现策略</p><p>1）话题发布 （发布订阅模式）</p><p>2）服务通信 （请求响应模式）</p><p>3）参数服务器 （参数共享模式）</p><h2 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h2><p>​        话题通信时ROS使用频率最高的一种通信模式，也是基于发布订阅模式的，也即：一个节点发布消息，另一个节点订阅信息：</p><p>​        如：机器人执行导航功能的时候使用的传感器时激光雷达，机器人会采集相关的信息并且完成计算，随后控制运动生成信息</p><p>​        这样通信的作用时用在不断更新的，少逻辑处理的数据传输场景。下面尝试实现一下！</p><p>​        在这个模型里头，有三条个主角：ROS MASTER（管理者），Talker（话题发出者），Listener（订阅者）</p><p><img src="image-20230426205058563.png" alt="image-20230426205058563"></p><p>​        master 根据话题建立发布者和订阅者之间的联系。</p><p>​        使用的协议时RPC和TCP， 并且Listener和Talker可以存在多个。talker和Listener建立连接以后，master就可以关闭了。当然这些流程已经被封装，我们没有必要去了解。</p><h2 id="实践1-ROS-in-C"><a href="#实践1-ROS-in-C" class="headerlink" title="实践1 - ROS in C++"></a>实践1 - ROS in C++</h2><p>​            例子：我们要以每秒10次的频率实现信息的发送！</p><p><img src="image-20230502192159071.png" alt="image-20230502192159071"></p><p>​        我们按照先前早就讲过的流程创建一遍工程，在已经完事了的CPP文件下书写如下的代码</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;ros&#x2F;ros.h&quot;#include&quot;std_msgs&#x2F;String.h&quot;&#x2F;*    publisher release:        1. incldue Files: ROS RO    2. init ROS node    3. create Handle of the node    4. create publisher    5,create publisher logic and the data*&#x2F;int main(int argc, char* argv[])&#123;    &#x2F;&#x2F; init a node    ros::init(argc,argv,&quot;such_a_node&quot;); &#x2F;&#x2F; 别带空格！这是涉及到命令行的    &#x2F;&#x2F; create a handle    ros::NodeHandle nodeHandle;    &#x2F;&#x2F; create Publisher    ros::Publisher pub &#x3D; nodeHandle.advertise&lt;std_msgs::String&gt;(&quot;this_is_a_topic&quot;,10);&#x2F;&#x2F; 别带空格！这是涉及到命令行的        std_msgs::String msg;    &#x2F;&#x2F; create the msg    while(ros::ok) &#x2F;&#x2F; this node is still available    &#123;           msg.data &#x3D; &quot;hello this is a msg&quot;; &#x2F;&#x2F; 设置字符串        pub.publish(msg); &#x2F;&#x2F; 向外广播    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p><p><img src="image-20230502193924014.png" alt="image-20230502193924014"></p><p>​        看到这个节点句柄的 advertise API了嘛，这就是一个广播函数第一个很好理解，就是话题名称，第二个是什么呢：我们的网络通信可能会有阻塞，于是ROS会将这些被阻塞的数据存储到队列里，等到网络稍微流畅的时候再发送出去！</p><p>​        当我们编完Ctrl + Shift + B结束编译之后，在一个命令行窗口处输入</p><pre class="line-numbers language-none"><code class="language-none">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        启动大环境</p><pre class="line-numbers language-none"><code class="language-none">rosrun publish demo_cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230502200757049.png" alt="image-20230502200757049"></p><p><img src="image-20230502200830424.png" alt="image-20230502200830424"></p><p>​        啥也没有！那就对了！</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 再开一个rostopic echo + &#39;topic_name&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        比如说我的就是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">rostopic echo this_is_a_topic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        消息就这样打印出来了！</p><p>​        下面设置一下频率！和计数器的使用</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;ros&#x2F;ros.h&quot;#include&quot;std_msgs&#x2F;String.h&quot;#include&lt;sstream&gt;&#x2F;*    publisher release:        1. incldue Files: ROS RO    2. init ROS node    3. create Handle of the node    4. create publisher    5,create publisher logic and the data*&#x2F;int main(int argc, char* argv[])&#123;    &#x2F;&#x2F; init a node    ros::init(argc,argv,&quot;such_a_node&quot;);    &#x2F;&#x2F; create a handle    ros::NodeHandle nodeHandle;    &#x2F;&#x2F; create Publisher    ros::Publisher pub &#x3D; nodeHandle.advertise&lt;std_msgs::String&gt;(&quot;this_is_a_topic&quot;,10);        std_msgs::String msg;    &#x2F;&#x2F; create the msg    &#x2F;&#x2F; create a ratio obj    ros::Rate rate(10);    int count &#x3D; 1;    while(ros::ok) &#x2F;&#x2F; this node is still available    &#123;           &#x2F;&#x2F;msg.data &#x3D; &quot;hello this is a msg&quot;;        std::stringstream ss;        ss &lt;&lt; &quot;hello from -------&gt;&quot;&lt;&lt;count;        msg.data &#x3D; ss.str();        pub.publish(msg);        &#x2F;&#x2F; add log&#x2F;&#x2F; transform into C Style String        ROS_INFO(&quot;broadcast the msg : %s&quot;,ss.str().c_str());        rate.sleep();        count++;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个字符串的拼接使用扩展的ROS里的函数</p><p><img src="image-20230502203144864.png" alt="image-20230502203144864"></p><h2 id="订阅方的实现"><a href="#订阅方的实现" class="headerlink" title="订阅方的实现"></a>订阅方的实现</h2><p>​        我们这样实现一个如此的Demo!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;ros&#x2F;ros.h&quot;#include&quot;std_msgs&#x2F;String.h&quot;#include&lt;sstream&gt;void doMsg(const std_msgs::String::ConstPtr &amp;msg)&#123;    &#x2F;&#x2F; by this const ptr to subscribe the msg    ROS_INFO(&quot;Have received the %s&quot;,msg-&gt;data.c_str());&#125;int main(int argc, char *argv[])&#123;    &#x2F;* same as before... *&#x2F;    ros::init(argc,argv,&quot;sub&quot;);    ros::NodeHandle nodeHandle;    &#x2F;&#x2F; the last var is the callBackFuncPointer    ros::Subscriber sub &#x3D; nodeHandle.subscribe(&quot;this_is_a_topic&quot;,10,doMsg);    &#x2F;&#x2F; nake sub receive the msg consistently    ros::spin();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为了处理得到的信息，就是在这里的回调函数实现对信息的处理的！</p><p>​        当然，带上Cmakelists 的配置，不然系统不认识！</p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>​        ros 的python就简单很多，逻辑类似于C++，不做更多的解释：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#! /usr/bin/env python</span><span class="token keyword">import</span> rospy<span class="token keyword">from</span> std_msgs<span class="token punctuation">.</span>msg <span class="token keyword">import</span> String <span class="token triple-quoted-string string">"""message type"""</span><span class="token triple-quoted-string string">"""    load package    init ros node    create publisher    write the logic and broadcast"""</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    rospy<span class="token punctuation">.</span>init_node<span class="token punctuation">(</span><span class="token string">"pub"</span><span class="token punctuation">)</span>    pub <span class="token operator">=</span> rospy<span class="token punctuation">.</span>Publisher<span class="token punctuation">(</span><span class="token string">"topic"</span><span class="token punctuation">,</span>String<span class="token punctuation">,</span>queue_size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>    mag <span class="token operator">=</span> String<span class="token punctuation">(</span><span class="token punctuation">)</span>    rate <span class="token operator">=</span> rospy<span class="token punctuation">.</span>Rate<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    count <span class="token operator">=</span> <span class="token number">0</span>        rospy<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">//</span> 让之可以在后被启动的时候让sub完全接收到所有数据    <span class="token keyword">while</span> <span class="token keyword">not</span> rospy<span class="token punctuation">.</span>is_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>        mag<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>        pub<span class="token punctuation">.</span>publish<span class="token punctuation">(</span>mag<span class="token punctuation">)</span>        rate<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#! &#x2F;usr&#x2F;bin&#x2F;env python&quot;&quot;&quot;sub basic steps    1. import rospy std_msgs    2. init node    3. create a subscriber    4. using call back functions to deal with data    5. make spin() in python&quot;&quot;&quot;import rospyfrom std_msgs.msg import Stringdef doMsg(msg):    rospy.loginfo(&quot;The subscried data is:%s&quot;,msg.data)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    rospy.init_node(&quot;subscribe&quot;)    sub &#x3D; rospy.Subscriber(&quot;topic&quot;,String,doMsg,queue_size&#x3D;10)     &quot;&quot;&quot;need the name the same as publisher&quot;&quot;&quot;    rospy.spin()    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learn_Qt-I</title>
      <link href="/2023/06/06/Learn-Qt-I/"/>
      <url>/2023/06/06/Learn-Qt-I/</url>
      
        <content type="html"><![CDATA[<h1 id="QT开发-初探"><a href="#QT开发-初探" class="headerlink" title="QT开发-初探"></a>QT开发-初探</h1><p>​    注意创建工程路径的时候不要不要不要整到含有中文的路径！</p><p>​        我们下载了 QT 之后，创建信息之后，会发现有三个类：</p><p>1）QWeidge 作为父类</p><p>2）QMainWindows子类</p><p>3）QDialog子类</p><p>2，3是1的子类</p><p><img src="image-20230228192413374.png" alt="image-20230228192413374"></p><p>​        可以看到，有一个.pro文件，跟VS文件是一样的，他是一个工程文件！</p><p><img src="image-20230228192501749.png" alt="image-20230228192501749"></p><p>​        这是一个工程的目录</p><p>​        先看主要的显示文件：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt; &#x2F;&#x2F; 包含一个应用程序类的文件&#x2F;&#x2F;argc 命令行变量的数量， *argv[] 是命令行变量的数组int main(int argc, char *argv[])&#123;    &#x2F;&#x2F;应用程序对象，再QT中方，应用程序对像只有一个    QApplication a(argc, argv);        &#x2F;&#x2F;窗口对象， widget- 父类 -&gt; QWedget    Widget w;    &#x2F;&#x2F; 显示窗口    w.show();    &#x2F;&#x2F; 让应用程序对象进入消息循环    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个循环可以被类比成如下的C程序：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;conio.h&gt;int main()&#123;while(_get() &#x3D;&#x3D; &#39; &#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这里，是点击窗口’ X ‘来关闭！</p><h2 id="看看工程文件"><a href="#看看工程文件" class="headerlink" title="看看工程文件"></a>看看工程文件</h2><p>​        工程文件自身可以在QT里打开：</p><p><img src="image-20230228193538543.png" alt="image-20230228193538543"></p><p>​        点击 1.pro 文件，可以看到如下的内容</p><p><img src="image-20230228193615493.png" alt="image-20230228193615493"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span># <span class="token comment">//工程创建时间</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Project created by QtCreator <span class="token number">2023</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">28</span>T19<span class="token operator">:</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">11</span></span></span>##<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>QT       <span class="token operator">+=</span> core gui <span class="token comment">// 包含的模块（1）</span><span class="token function">greaterThan</span><span class="token punctuation">(</span>QT_MAJOR_VERSION<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">:</span> QT <span class="token operator">+=</span> widgets <span class="token comment">// 大于这个版本才添加模块</span>TARGET <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 目标 生成的.exe文件的名字（2）不满意名字可以自行更换</span>TEMPLATE <span class="token operator">=</span> app <span class="token comment">//模板</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">The following define makes your compiler emit warnings <span class="token keyword">if</span> you use</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">any</span> <span class="token expression">feature of Qt which as been marked as <span class="token function">deprecated</span> <span class="token punctuation">(</span>the exact warnings</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">depend</span> <span class="token expression">on your compiler<span class="token punctuation">)</span><span class="token punctuation">.</span> Please consult the documentation of the</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">deprecated</span> <span class="token expression">API in order to know how to port your code away from it<span class="token punctuation">.</span></span></span>DEFINES <span class="token operator">+=</span> QT_DEPRECATED_WARNINGS<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">You can also make your code fail to compile <span class="token keyword">if</span> you use deprecated APIs<span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">In order to <span class="token keyword">do</span> so<span class="token punctuation">,</span> uncomment the following line<span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">You can also select to disable deprecated APIs only up to a certain version of Qt<span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">DEFINES <span class="token operator">+=</span> QT_DISABLE_DEPRECATED_BEFORE<span class="token operator">=</span><span class="token number">0x060000</span>    # disables all the APIs deprecated before Qt <span class="token number">6.0</span><span class="token number">.0</span></span></span>SOURCES <span class="token operator">+=</span> \        main<span class="token punctuation">.</span>cpp \ <span class="token comment">//源文件</span>        widget<span class="token punctuation">.</span>cppHEADERS <span class="token operator">+=</span> \        widget<span class="token punctuation">.</span>h <span class="token comment">// 头文件</span>FORMS <span class="token operator">+=</span> \        widget<span class="token punctuation">.</span>ui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（1）：</p><p><img src="image-20230228193822499.png" alt="image-20230228193822499"></p><p>（2）那个exe文件在这里：打开你的工程目录，返回上级会发现：</p><p><img src="image-20230228194240791.png" alt="image-20230228194240791"></p><p>点击下面的文件夹</p><p><img src="image-20230228194256086.png" alt="image-20230228194256086"></p><p>点击 debug</p><p><img src="image-20230228194315627.png" alt="image-20230228194315627"></p><p>就在这里的 1.exe</p><h2 id="看看头文件和widget-cpp"><a href="#看看头文件和widget-cpp" class="headerlink" title="看看头文件和widget.cpp"></a>看看头文件和widget.cpp</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECT &#x2F;&#x2F; 允许类中使用信号和槽的宏，不要轻易改动public:    explicit Widget(QWidget *parent &#x3D; 0);&#x2F;&#x2F; 默认构造函数    ~Widget();private:    Ui::Widget *ui;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>​        类名：首字母大写，单词与单词之间首字母大写</p><p>​        函数名，变量名称：首字母小写，但单词与单词之间首字母大写</p><p>​        快捷键一览：</p><p>​        注释：ctrl + /</p><p>​        运行：ctrl + r</p><p>​        编译：ctrl + b</p><p>​        查找：ctrl + f</p><p>​        整行移动：ctrl + shift + ↑ 或者 ↓</p><p>​        自动对齐：ctrl + i</p><p>​        同名的.cpp 和 .h: F4</p><h2 id="创建一个按钮"><a href="#创建一个按钮" class="headerlink" title="创建一个按钮"></a>创建一个按钮</h2><p>​        我们查询帮助文档，得到这些信息</p><pre class="line-numbers language-none"><code class="language-none">QPushButton ClassThe QPushButton widget provides a command button. More...Header:#include &lt;QPushButton&gt; qmake:QT +&#x3D; widgetsInherits:QAbstractButtonInherited By:QCommandLinkButton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        当然要留意是什么模块，如果 pro 文件里没有，那需要我们手动添加，在</p><p><img src="image-20230301221926786.png" alt="image-20230301221926786"></p><p>​        的QT += 处 添加模块。</p><p>​        当然可以看看函数的功能</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">QPushButton</span><span class="token punctuation">(</span>QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span><span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span><span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>icon<span class="token punctuation">,</span> <span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span><span class="token operator">~</span><span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>bool <span class="token function">autoDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>bool <span class="token function">isDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>bool <span class="token function">isFlat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>QMenu <span class="token operator">*</span><span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token keyword">void</span> <span class="token function">setAutoDefault</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">setDefault</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">setFlat</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">setMenu</span><span class="token punctuation">(</span>QMenu <span class="token operator">*</span>menu<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是可以在 widget.cpp 中书写如下代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include&lt;QPushButton&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)&#123;    QPushButton* btn &#x3D; new QPushButton;    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点    btn-&gt;setText(&quot;hello world&quot;);&#125;Widget::~Widget()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230301222534315.png" alt="image-20230301222534315"></p><p>​        如果我们重新设置一下窗口大小，那就</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> Height<span class="token punctuation">,</span><span class="token keyword">int</span> Width<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        但是如果我们直接创建第二个按钮，那就会覆盖第一个，那怎么办？使用 move 方法！</p><pre class="line-numbers language-none"><code class="language-none">btn-&gt;move(int x_pos,int y_pos)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当然啊，我们可以设置窗口的名字：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">setWindowTitle(&quot;My first windows&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以及可以固定窗口大小：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">setFixedSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> Height<span class="token punctuation">,</span><span class="token keyword">int</span> Width<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230301223238957.png" alt="image-20230301223238957"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include&lt;QPushButton&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)&#123;    QPushButton* btn &#x3D; new QPushButton;    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点    btn-&gt;setText(&quot;hello world&quot;);    QPushButton* btn2 &#x3D; new QPushButton;    btn2-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点    btn2-&gt;move(100,100);    setWindowTitle(&quot;My first Window&quot;);    resize(600,400);    setFixedSize(600,400);&#125;Widget::~Widget()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="QT对象树"><a href="#QT对象树" class="headerlink" title="QT对象树"></a>QT对象树</h2><p>​        我们发现，程序结束后，不需要一个一个手动的释放对象，这是因为，我们调用构造函数指定了一个Parent父对象，其父对象会把我们自己搞的子对象挂到对象树上，</p><p><img src="image-20230411202327161.png" alt="image-20230411202327161"></p><p>​        （补充：一个类创建时需要调用一个函数来构造初始化这个类，这叫构造函数。当类的什么周期结束时需要调用一个删除函数，释放类占用的空间，这叫析构函数。类默认有这两个函数）于是在QT中只要指定好父对象就会帮助管理！不需要我们手动释放，很是方便</p><p>​        现在，我们来创建一个新类：MyPushBtn</p><p>​        右键工程-&gt; 添加新文件-&gt;C++ Class -&gt;选择 QWedget就好了。</p><p>​        随后，就发现多了一些文件</p><p><img src="image-20230411203853556.png" alt="image-20230411203853556"></p><p>​        pro文件下多了我们自己定义的类的cpp文件和头文件</p><p><img src="image-20230411204458973.png" alt="image-20230411204458973"></p><p><img src="image-20230411204545650.png" alt="image-20230411204545650"></p><p>​        现在我们调一下自己写的：</p><p><img src="image-20230411205908628.png" alt="image-20230411205908628"></p><p>​        可以看到我们自己的按钮产生了！</p><h2 id="QT-坐标系"><a href="#QT-坐标系" class="headerlink" title="QT 坐标系"></a>QT 坐标系</h2><p>​        QT的坐标原点在窗口的最左上角，这是值得注意的一点，同时：X向右增大，向左减小，而Y 向下增大，向上减小。对于嵌套窗口，则是以父窗口为例子的！</p><p>​        </p><h2 id="信号与槽的基础概念"><a href="#信号与槽的基础概念" class="headerlink" title="信号与槽的基础概念"></a>信号与槽的基础概念</h2><p>​        我们现在开始关联我们的行为和效果！比若说：我希望点击按钮后就帮我关闭窗口！于是</p><p><img src="image-20230412232937449.png" alt="image-20230412232937449"></p><p>​        这就是我们分解完后发现就是这样的，现在开始关联他们：</p><p>​        英语里：connect就是连接的，结合上图发现，想要表达一个链接，无非就是：</p><pre class="line-numbers language-none"><code class="language-none">connect(sender, sendSignal, receiver, slogAsActionReact)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意了：注意！我们点击按钮，不一定是去关闭窗口，而窗口关闭了不一定时我点击了按钮导致的</p><p>​        于是，信号槽的优点就是：松散耦合的！他们之间本来没啥关联！但是现在我们直接用connect函数来耦合在一起！</p><p>​        QT里，就是connect函数完成我们的工作！先来看发送者：按钮！那信号呢？</p><p><img src="image-20230412233514694.png" alt="image-20230412233514694"></p><p>​        于是找到一个信号clicked. </p><p><img src="image-20230412233547084.png" alt="image-20230412233547084"></p><p>​        所以传入一个函数的地址！&amp;QPushButton::clicked</p><p>​        接收者同理！：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">connect(mine, &amp;QPushButton::clicked,this,&amp;QWidget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这一思想十分重要！还是需要好好消化！</p><p>​        现在尝试自己来书写两个类，来建立相应的关系！</p><p>​        现在构建程序如下：</p><p>​        在最大工程文件之下添加两个类！，首先是 Teacher类。 随后是学生类。假设这一场景！老师要求学生交作业！学生听到老师的要求来拿出作业，老师看到学生拿出作业之后再上前收取。这个行为我们使用 QT 的槽与信号来完成我们的实现。</p><p>​        选择新建两个类： Student 和 Teacher. 注意到为了能够使用 QT系统的一些性质，有必要来选择继承QT类。</p><p>​        当我们完成了新建，马上就发现，它同我们所想象的不太一样！</p><p><img src="image-20230414145816352.png" alt="image-20230414145816352"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef TEACHER_H#define TEACHER_H#include &lt;QObject&gt;class Teacher : public QObject &#x2F;&#x2F; QObject 是 Teacher 的一个基类&#123;    Q_OBJECT &#x2F;&#x2F; 这是QObject宏，声明启用Slot - Signals关系的public:    explicit Teacher(QObject *parent &#x3D; nullptr);        &#x2F;&#x2F; 只有在有 Q_OBJECT下才生效signals:&#x2F;&#x2F; 我们在这里书写 signals 作为信号函数public slots:        &#x2F;&#x2F; 我们在这里书写 slots 作为响应信号的槽函数&#125;;#endif &#x2F;&#x2F; TEACHER_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到我们在这里完成槽函数和信号函数的书写！</p><p>​        以及这里需要提醒的是：槽函数在这里是一个实现的占位函数，这是在底层的文件中，QT为我们实现了函数了，不要在定义实现文件里再次定义信号函数，否则会发生报错。</p><p>​        但是，槽函数需要实现，这是需要在实现文件里自己重写的！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void student::reactions()&#123;qDebug() &lt;&lt; &quot;Yep, I think I will help you!&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        书写完响应之后，我们现在可以来干活了（在Widget.cpp）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include&quot;student.h&quot;#include&quot;teacher.h&quot;Widget::Widget(QWidget *parent)    : QWidget(parent)&#123;    Teacher* t &#x3D; new Teacher(this);    student* s &#x3D; new student(this);    &#x2F;&#x2F; 这里是链接信号和槽，但是这又这样是不行的，英文不是所有的这个函数都是信号，只有当我们认为指定他是信号的时候才需要出发槽函数    connect(t,&amp;Teacher::announceHungry,s,&amp;s-&gt;reactions);&#x2F;&#x2F; 而emit就是声命这是这是一个信号函数且需要调用s-&gt;reactions    emit t-&gt;announceHungry();&#125;Widget::~Widget()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，只要我们一开始运行程序，就会发现</p><p><img src="image-20230418202145548.png" alt="image-20230418202145548"></p><p>​        嗯，打印了（如果跑的是我的那个demo就是Yep, I think I will help you!）</p><h2 id="槽函数的重载版本"><a href="#槽函数的重载版本" class="headerlink" title="槽函数的重载版本"></a>槽函数的重载版本</h2><p>​        下面，我们进一步的探索可以重载版本的槽函数</p><p>​        以上一小节的场景为例子，加上槽函数的重载版本！</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; in .hslots:void reactions(QString s); &#x2F;&#x2F; .cppvoid student::reactions(QSrting s)&#123;qDebug() &lt;&lt; &quot;yep, I think it is&quot; &lt;&lt; s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，注释掉原先的emit 就可以发现智能提示上函数有重载版本！</p><p>​        但是，当我们直接单击运行的时候，QT报错了！原因很简单！QT不知道你要那个回应！于是，我们转向传专门到具体的函数的指针！也就是直接传重载版本的函数指针！</p><p>​        但是，我们的信号来源信息是需要从信号函数那里来的，于是还要重载Signal函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//.h</span>signal<span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">announceHungry</span><span class="token punctuation">(</span>QString s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// .cpp</span><span class="token keyword">void</span> <span class="token class-name">Teacher</span><span class="token double-colon punctuation">::</span><span class="token function">announceHungry</span><span class="token punctuation">(</span>QString s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 仍然不实现！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，告诉引发的信号是来自：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">emit t<span class="token operator">-></span><span class="token function">announceHungry</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从这里编译器判断函数类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>StringOne<span class="token punctuation">,</span>s<span class="token punctuation">,</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230418210445433.png" alt="image-20230418210445433"></p><h2 id="令人恼火的是："><a href="#令人恼火的是：" class="headerlink" title="令人恼火的是："></a>令人恼火的是：</h2><p>​        马上强迫症发现了：不对啊，我们的111不应该打印“” 啊！，这是因为类型是QString导致的，这个时候只要我们进行转化就好了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">toUtf8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// QString -> ByteArray -> const char*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230418211415114.png" alt="image-20230418211415114"></p><h2 id="高级一点的信号与槽"><a href="#高级一点的信号与槽" class="headerlink" title="高级一点的信号与槽"></a>高级一点的信号与槽</h2><p>​        现在，让我们点击按钮，连续的触发事件来让样例复杂起来。</p><p>​        信号与槽的一个重要的要求就是信号和槽的函数的参数必须一致(有参的信号和QPushButton的clicked信号的参数不匹配就会编译报错)，于是，包装一个Emit函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Widget::Emit()&#123;&#x2F;&#x2F; 预先在Widget里添加成员t，并且初始化Emit t-&gt;announcement(&quot;111&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，开始关联：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QPushButton<span class="token operator">*</span> btn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"Press me"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token operator">-></span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>btn<span class="token punctuation">,</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>Widget<span class="token double-colon punctuation">::</span>Emit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>StringOne<span class="token punctuation">,</span>s<span class="token punctuation">,</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230418213636339.png" alt="image-20230418213636339"></p><p>​        对了，信号也可以来连接信号，就是：</p><p><img src="image-20230418214613353.png" alt="image-20230418214613353"></p><p><img src="image-20230418214631458.png" alt="image-20230418214631458"></p><h2 id="断开链接"><a href="#断开链接" class="headerlink" title="断开链接"></a>断开链接</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">disconnect</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>signalF<span class="token punctuation">,</span>sloter<span class="token punctuation">,</span>slotF<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复习一下：</p><p>​        1）信号可以链接信号</p><p>​        2）一个信号可以链接多个槽函数</p><p>​        3）多个信号可以链接同一个槽函数</p><p>​        4）但是信号与槽函数的参数必须一一对应</p><p>这是我们练习生活实际是不难发现的！关于四，仔细看看！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        可以看到必须一 一对应！</p><p>​        5）信号的参数个数是可以多于槽的参数，也就是说，信号携带的信息必须多余槽需要的！</p><pre class="line-numbers language-none"><code class="language-none">void(A::*sig)(QString,int) &#x3D; &amp;A::singals;void(B::*slot)(QString,int) &#x3D; &amp;B::slots;(√)void(A::*sig)(QString,int) &#x3D; &amp;A::singals;void(B::*slot)(int，QString) &#x3D; &amp;B::slots;(×)必须一一对应<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        而在QT4之前，我们使用SIGNAL,SLOT宏链接的。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">connect(sig1,SIGNAL(signals()),slot1,SLOT(slot()))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="补充Lambda表达式"><a href="#补充Lambda表达式" class="headerlink" title="补充Lambda表达式"></a>补充Lambda表达式</h2><p>​        这是C++11的产物，我们由此创建一个匿名的函数以简化编程工作：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[capture](parameters)mutable-&gt;return-type&#123;statements&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        人话：[函数对象参数]（操作符重载函数参数）mutable-&gt;返回值{函数体实现}</p><h3 id="1-函数对象参数"><a href="#1-函数对象参数" class="headerlink" title="1.函数对象参数"></a>1.函数对象参数</h3><p>​        [ ]，这标志Lambda表达式的开始，不允许省略！其中，空表示没有使用任何函数对象。</p><p>​        [=] : 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是值传递</p><p>​        [&amp;]： 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是引用传递。</p><p>​        这是一个修改的demo.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[&#x3D;]()&#123;   btn2-&gt;setText(&quot;Lol&quot;);&#125;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        最后的（）表示的是当地声明马上调用</p><p>​        [this] :函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this和内部成员的变量），并且传递方式是值传递</p><p>​        [varName] 只认识varName，其他都看不见到，用于仅操作一个变量的匿名表达式</p><p><img src="image-20230419202055676.png" alt="image-20230419202055676"></p><p>​        当然后面的很少使用！</p><p>​        mutable关键字：可以修改按值传递进来的拷贝</p><p>​        可以观察这个代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QPushButton<span class="token operator">*</span> btn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"this is a btn2"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>btn2<span class="token punctuation">,</span><span class="token operator">&amp;</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token punctuation">&#123;</span>n<span class="token operator">=</span><span class="token number">110</span><span class="token punctuation">,</span><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>QPushButton<span class="token operator">*</span> btn3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"this is a btn3"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn3<span class="token operator">-></span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>btn3<span class="token punctuation">,</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token punctuation">&#123;</span><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你会发现，点击btn2之后又点击btn3，发现并没有修改n，说明确实只是更改了拷贝而已！</p><p>​        下面来用一下，复盘一下我们学习的知识，那就是设计一个按钮，位于图片中学附近，且点击之后可以使传入的一个值+=10，同时打印信息：From lambda’s reactions!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;Widget::Widget(QWidget *parent)    : QWidget(parent)&#123;    QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);    resize(640,480);    btn-&gt;move(320,240);    connect(btn,&amp;QPushButton::clicked,this,[]()&#123;qDebug()&lt;&lt;&quot;From lambda&#39;s reactions!&quot;;&#125;);    unsigned int m &#x3D; 10;    connect(btn,&amp;QPushButton::clicked,this,[m]()mutable&#123;m+&#x3D;10;qDebug()&lt;&lt;m;&#125;);&#125;Widget::~Widget()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        返回值：就是在（）后写 -&gt; type随后写实现！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[]()-&gt;int&#123;return 1000&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int in &#x3D; 10;  int res &#x3D; [&#x3D;]()-&gt;int&#123;return in*in;&#125;();  qDebug() &lt;&lt; res;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        又如点击按钮关闭窗口的demo:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);resize(640,480);btn-&gt;move(320,240);connect(btn,&amp;QPushButton::clicked,this,&amp;Widget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        好吧，那又加一个打印log?转向Lambda就好了</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);resize(640,480);btn-&gt;move(320,240);connect(btn,&amp;QPushButton::clicked,this,[this]()&#123;this-&gt;close();qDebug()&lt;&lt;&quot;Windows is closed!&quot;;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a>QMainWindow</h1><p>​        QMainWindow是一个为用户提供主窗口程序的类，它包含一个菜单栏，多个工具栏，多个铆接部件，一个状态栏和一个中心部件，是多个应用程序的基础，如文本编辑器，图片编辑器等等</p><p><img src="image-20230425213236864.png" alt="image-20230425213236864"></p><p>​        现在我们尝试创建一个QMainWindow，并运行之：</p><p><img src="image-20230425213429856.png" alt="image-20230425213429856"></p><p>​        好小！调整一下，在MainWindow里头resize一下完事！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)&#123;resize(640,480);&#125;MainWindow::~MainWindow()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230425213559077.png" alt="image-20230425213559077"></p><p>​        下面创建一个菜单栏，他是QMenuBar类的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QMenuBar* bar &#x3D; menuBar();&#x2F;&#x2F; 设置当前窗口的菜单栏setMenuBar(bar);&#x2F;&#x2F; 设定名称&#x2F;&#x2F; 事实上不是这样用的，但是为了展示效果如此bar-&gt;addMenu(&quot;文件&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230425214129151.png" alt="image-20230425214129151"></p><p>​        好吧，事实上是我们是使用一个菜单对象来接受之：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QMenu<span class="token operator">*</span> fileMenu <span class="token operator">=</span> bar<span class="token operator">-></span><span class="token function">addMenu</span><span class="token punctuation">(</span><span class="token string">"文件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们这样做是为了后续的其他操作！比如说，现在我们想点击它让他下拉一个菜单来，那就</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">fileMenu<span class="token operator">-></span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token string">"新建"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//添加一个分割符</span>fileMenu<span class="token operator">-></span><span class="token function">addSeparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   fileMenu<span class="token operator">-></span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token string">"打开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230425214843993.png" alt="image-20230425214843993"></p><h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;工具栏 QToolBar* toolBar &#x3D; new QToolBar(this); addToolBar(toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​            这个流程为我们的窗口添加了一个工具栏</p><p><img src="image-20230425215242772.png" alt="image-20230425215242772"></p><p>​        看到有变化！是的就是我们的工具栏。</p><p>​        工具栏是允许有多个的！我们再仔细瞧瞧其他的add重载函数！</p><p>​        这个引起了我们的注意</p><p><img src="image-20230425215627044.png" alt="image-20230425215627044"></p><p>​        这个函数究竟实现了啥功能呢？把这个函数扔进QT  帮助手册里</p><p><img src="image-20230425215808333.png" alt="image-20230425215808333"></p><p>​        这个地方，点击第一个参数的类去</p><p><img src="image-20230425215834180.png" alt="image-20230425215834180"></p><p>​        很明显了！就是再说这个工具栏初始时停靠在哪里！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">addToolBar(Qt::LeftToolBarArea,toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230425215957733.png" alt="image-20230425215957733"></p><p>​        这是设计默认区域。总结一下</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include&lt;QMenuBar&gt;#include&lt;QToolBar&gt;#include&lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)&#123;    &#x2F;&#x2F;重置窗口大小    resize(640,480);    &#x2F;&#x2F;创建菜单栏，最多只能有一个    QMenuBar* bar&#x3D; menuBar();    &#x2F;&#x2F;设置显示窗口为当前窗口    setMenuBar(bar);    &#x2F;&#x2F;菜单    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);    &#x2F;&#x2F;添加菜单项    fileMenu-&gt;addAction(&quot;新建&quot;);    &#x2F;&#x2F;添加分隔符    fileMenu-&gt;addSeparator();    fileMenu-&gt;addAction(&quot;打开&quot;);    &#x2F;&#x2F;添加工具栏    QToolBar* toolBar &#x3D; new QToolBar(this);    addToolBar(Qt::LeftToolBarArea,toolBar);        &#125;MainWindow::~MainWindow()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面说说它只允许停靠在一个方向。我们可以查看QToolBar的成员函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; constructorQToolBar(const QString &amp;title, QWidget *parent &#x3D; Q_NULLPTR)QToolBar(QWidget *parent &#x3D; Q_NULLPTR)&#x2F;&#x2F; destructor~QToolBar()QAction *actionAt(const QPoint &amp;p) constQAction *actionAt(int x, int y) constQAction *addAction(const QString &amp;text)QAction *addAction(const QIcon &amp;icon, const QString &amp;text)QAction *addAction(const QString &amp;text, const QObject *receiver, const char *member)QAction *addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, const char *member)QAction *addAction(const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)QAction *addAction(const QString &amp;text, Functor functor)QAction *addAction(const QString &amp;text, const QObject *context, Functor functor)QAction *addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)QAction *addAction(const QIcon &amp;icon, const QString &amp;text, Functor functor)QAction *addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *context, Functor functor)QAction *addSeparator()QAction *addWidget(QWidget *widget)Qt::ToolBarAreas allowedAreas() constvoid clear()QSize iconSize() constQAction *insertSeparator(QAction *before)QAction *insertWidget(QAction *before, QWidget *widget)bool isAreaAllowed(Qt::ToolBarArea area) constbool isFloatable() constbool isFloating() constbool isMovable() constQt::Orientation orientation() constvoid setAllowedAreas(Qt::ToolBarAreas areas)void setFloatable(bool floatable)void setMovable(bool movable)void setOrientation(Qt::Orientation orientation)QAction *toggleViewAction() constQt::ToolButtonStyle toolButtonStyle() constQWidget *widgetForAction(QAction *action) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        看到</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isAreaAllowed(Qt::ToolBarArea area) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        不正是表明停靠范围！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以及设置是否可以浮动：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setFloatable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        甚至可以设置是否可以移动！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setMovable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        下面设置内容：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;addAction(&quot;这是action 1&quot;);toolBar-&gt;addAction(&quot;这是action2&quot;);&#x2F;&#x2F;使用这个方法表明的是跟菜单栏是公用同一个功能的！&#x2F;&#x2F;需要接受返回值&#x2F;&#x2F;QAction* newAct &#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);toolBar-&gt;addAction(openAct);&#x2F;&#x2F;其他类似toolBar-&gt;addAction(newAct);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        工具栏也可以添加分割线：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;addSeparator();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        还可以添加控件！！！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);toolBar-&gt;addWidget(btn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>​        最多也只能有一个</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QStatusBar* stbar &#x3D; statusBar();setStatusBar(stbar);QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);&#x2F;&#x2F; QLable是Widget控件stbar-&gt;addWidget(lab);&#x2F;&#x2F; 左侧QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);stbar-&gt;addPermanentWidget(lab2);&#x2F;&#x2F;右侧<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        也可以添加铆接部件，可以有多个</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;铆接部件（可以一大堆）QDockWidget* dock &#x3D; new QDockWidget(this);addDockWidget(Qt::BottomDockWidgetArea,dock);&#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口QTextEdit* edit &#x3D; new QTextEdit(this);setCentralWidget(edit);dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于全局者，都是set,只能有一个，反之可以多个（add_）</p><p>​        回顾一下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include&lt;QMenuBar&gt;#include&lt;QToolBar&gt;#include&lt;QDebug&gt;#include&lt;QPushButton&gt;#include&lt;QStatusBar&gt;#include&lt;QLabel&gt;#include&lt;QDockWidget&gt;#include&lt;QTextEdit&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)&#123;    &#x2F;&#x2F;重置窗口大小    resize(1640,880);    &#x2F;&#x2F;创建菜单栏，最多只能有一个    QMenuBar* bar&#x3D; menuBar();    &#x2F;&#x2F;设置显示窗口为当前窗口    setMenuBar(bar);    &#x2F;&#x2F;菜单    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);    &#x2F;&#x2F;添加菜单项    QAction* newAct&#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);    &#x2F;&#x2F;添加分隔符    fileMenu-&gt;addSeparator();     QAction* openAct&#x3D; fileMenu-&gt;addAction(&quot;打开&quot;);    &#x2F;&#x2F;添加工具栏    QToolBar* toolBar &#x3D; new QToolBar(this);    addToolBar(Qt::LeftToolBarArea,toolBar);    &#x2F;&#x2F;设置允许停靠区域    toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);    &#x2F;&#x2F;设置行为    toolBar-&gt;addAction(&quot;这是action 1&quot;);    toolBar-&gt;addAction(&quot;这是action2&quot;);    toolBar-&gt;addAction(openAct);    toolBar-&gt;addSeparator();    toolBar-&gt;addAction(newAct);    &#x2F;&#x2F;放置控件    QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);    toolBar-&gt;addWidget(btn);    &#x2F;&#x2F;状态栏    QStatusBar* stbar &#x3D; statusBar();    setStatusBar(stbar);    &#x2F;&#x2F;加点东西    QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);    &#x2F;&#x2F; QLable是Widget控件    stbar-&gt;addWidget(lab);    QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);    stbar-&gt;addPermanentWidget(lab2);    &#x2F;&#x2F;铆接部件（可以一大堆）    QDockWidget* dock &#x3D; new QDockWidget(this);    addDockWidget(Qt::BottomDockWidgetArea,dock);    &#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口    QTextEdit* edit &#x3D; new QTextEdit(this);    setCentralWidget(edit);    dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);&#125;MainWindow::~MainWindow()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加资源文件"><a href="#添加资源文件" class="headerlink" title="添加资源文件"></a>添加资源文件</h2><p>​        我们现在打开UI设计一栏，现在可以直接开始先设计后构建代码逻辑了</p><p><img src="image-20230514102111415.png" alt="image-20230514102111415"></p><p>​        菜单项必须必须输入英文，这是因为跟变量命名有关，可以后续改动text 值来改变显示</p><p><img src="image-20230514101928675.png" alt="image-20230514101928675"></p><p>​        其他就不多阐述了，类似的。</p><p>​        如何使用代码访问ui呢？会带mainwindow.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this); &#x2F;&#x2F; 类似于这样的！&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        添加一个图标吧：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;D:&#x2F;QT projects&#x2F;9&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        首先先把资源放到项目目录路径下，不然肯定找不到！</p><p>​        如何快速的在项目中添加文件呢？先去右键项目：添加性文件，选择QT下的Qt resource files</p><p>​        然后，添加：会发现要求你写一个前缀，这是为了分类资源文件。可以偷懒直接写一个\</p><p>​        在项目中引用只需要按照格式：</p><pre class="line-numbers language-none"><code class="language-none">: + prefix + fileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也即是: + 前缀加上文件名即可</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;:&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>​            可是我们的点击事件还是没有任何反应。下面使用信号与槽让他动起来</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;QDialog&gt;#include&lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 点击新建按钮来弹出对话框    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;        &#x2F;&#x2F; 对话框 分类        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）        QDialog dlg(this);  &#x2F;&#x2F;创建一个        dlg.exec();        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;    &#125;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230516215248714.png" alt="image-20230516215248714"></p><p>​        出现这样的警告，说明是对话框太小了，需要调整</p><p><img src="image-20230516215825806.png" alt="image-20230516215825806"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;QDialog&gt;#include&lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 点击新建按钮来弹出对话框    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;        &#x2F;&#x2F; 对话框 分类        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）        QDialog dlg(this);        dlg.resize(100,200);        dlg.exec();        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;    &#125;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那我们现在来看一个非模糊的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;QDialog&gt;#include&lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 点击新建按钮来弹出对话框    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;        &#x2F;&#x2F; 对话框 分类        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）&#x2F;&#x2F;        QDialog dlg(this);&#x2F;&#x2F;        dlg.resize(100,200);&#x2F;&#x2F;        dlg.exec();        QDialog* dig &#x3D; new QDialog(this); &#x2F;&#x2F; 不可以开栈上，对象一show完就没了！        dig-&gt;resize(100,200);        dig-&gt;show();        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;    &#125;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为了防止用户一直点，一直创建对话框，我们可以设置关闭就删掉的属性</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">dig-&gt;setAttribute(Qt::WA_DeleteOnClose);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h1><h2 id="消息对话框-1"><a href="#消息对话框-1" class="headerlink" title="消息对话框"></a>消息对话框</h2><p>​        系统自己提供了大量的对话框，如：</p><p>​        QColorDialog                选择颜色</p><p>​        QFileDialog                    选择文件或者目录</p><p>​        QFontDialog                    选择字体</p><p>​        QInputDialog                允许用户输入一个值</p><p>​        QMessageDialog            模态对话框</p><p>​        QPageSetUpDialog        为打印机提供相关选项</p><p>​        QPrintDialog                    打印机配置</p><p>​        QPrintPreviewDialog        打印预览</p><p>​        QProcessDialog                显示操作过程</p><p>​        我们现在着重看看消息框是啥情况！在帮助文档下搜索QMessageBox</p><p><img src="image-20230519123236586.png" alt="image-20230519123236586"></p><p>​        下面显示之。</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    ui.setupUi(this);    QMessageBox::critical(this, &quot;critical&quot;, &quot;666&quot;);&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230519123918761.png" alt="image-20230519123918761"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    ui.setupUi(this);    QMessageBox::information(this, &quot;information&quot;, &quot;666&quot;);&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++</p><p><img src="image-20230519124310043.png" alt="image-20230519124310043"></p><pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    ui.setupUi(this);    QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;);&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230519124401064.png" alt="image-20230519124401064"></p><p><img src="image-20230519124448267.png" alt="image-20230519124448267"></p><p>​        于是可以更改参数就好了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;,QMessageBox::Save|QMessageBox::Cancel);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230519124653246.png" alt="image-20230519124653246"></p><p>​        这个函数参数是这样的：</p><p>​        参数1：父类</p><p>​        参数2：标题</p><p>​        参数3：提示内容</p><p>​        参数4：按键类型</p><p>​        参数5：默认回车关联的按键</p><p>​        返回参数：用户选择</p><p>如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;#include&lt;tchar.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    setLocale(QLocale::AnyLanguage);    ui.setupUi(this);    if (QMessageBox::Save &#x3D;&#x3D; QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;, QMessageBox::Save | QMessageBox::Cancel)) &#123;        qDebug() &lt;&lt; &quot;you clicked the save&quot;;    &#125;&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        想看Debug信息去项目属性那里更改一下输出为控制台即可！</p><p><img src="image-20230519125534877.png" alt="image-20230519125534877"></p><p>​        来看看其他demo:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;#include&lt;qcolordialog.h&gt;#include&lt;qcolor.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    setLocale(QLocale::AnyLanguage);    ui.setupUi(this);    QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230519125944025.png" alt="image-20230519125944025"></p><p><img src="image-20230519125950425.png" alt="image-20230519125950425"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;#include&lt;qcolordialog.h&gt;#include&lt;qcolor.h&gt;#include&lt;qfile.h&gt;#include&lt;qfiledialog.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    setLocale(QLocale::AnyLanguage);    ui.setupUi(this);    &#x2F;*QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;*&#x2F;&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;    QFileDialog::getOpenFileName(        this,&#x2F;&#x2F; 设置父亲        &quot;open the file&quot;, &#x2F;&#x2F; caption        &#x2F;&#x2F;目录        &quot;D:\\&quot;&#x2F;&#x2F;文件夹        &quot;(*.txt)&quot;&#x2F;&#x2F;过滤器，回忆Linux通配符就好了！    );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230519130333549.png" alt="image-20230519130333549"></p><p>​        返回的是文件的路径！这个可以注意一下！</p><h2 id="登录窗口界面布局介绍"><a href="#登录窗口界面布局介绍" class="headerlink" title="登录窗口界面布局介绍"></a>登录窗口界面布局介绍</h2><p>​        现在使用Widget控件把一些模块分类装之，随后垂直布局，就是这样</p><p><img src="image-20230519131530620.png" alt="image-20230519131530620"></p><h2 id="QListWidget空间"><a href="#QListWidget空间" class="headerlink" title="QListWidget空间"></a>QListWidget空间</h2><p><img src="image-20230523200845020.png" alt="image-20230523200845020"></p><p>​        是的！从这里拖一个QListWidget控件出来！</p><p><img src="image-20230523201158972.png" alt="image-20230523201158972"></p><p>​        代码里如上图所示，运行：</p><p><img src="image-20230523201220072.png" alt="image-20230523201220072"></p><p>​        也可以使用类似于list的容器放置一大堆内容：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QListWidgetItem&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;锄禾日当午&quot;);    ui-&gt;listWidget-&gt;addItem(item);    item-&gt;setTextAlignment(Qt::AlignHCenter);    &#x2F;&#x2F; QStringList      List&lt;String&gt;    QStringList list;    list &lt;&lt; &quot;锄禾日当午&quot;&lt;&lt;&quot;汗&quot;;    ui-&gt;listWidget-&gt;addItems(list);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230523201833675.png" alt="image-20230523201833675"></p><h3 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h3><p>​        下面的文段来自QT帮助助手！</p><pre><code>Detailed Description</code></pre><p><img src="image-20230526191818350.png" alt="image-20230526191818350"></p><p>​        QListWidget is a convenience class that provides a list view similar to the one supplied by QListView, but with a classic item-based interface for adding and removing items. QListWidget uses an internal model to manage each QListWidgetItem in the list.<br>For a more flexible list view widget, use the QListView class with a standard model.<br>List widgets are constructed in the same way as other widgets:</p><pre class="line-numbers language-none"><code class="language-none">QListWidget *listWidget &#x3D; new QListWidget(this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        The selectionMode() of a list widget determines how many of the items in the list can be selected at the same time, and whether complex selections of items can be created. This can be set with the setSelectionMode() function.<br>There are two ways to add items to the list: they can be constructed with the list widget as their parent widget, or they can be constructed with no parent widget and added to the list later. If a list widget already exists when the items are constructed, the first method is easier to use:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">new QListWidgetItem(tr(&quot;Oak&quot;), listWidget);new QListWidgetItem(tr(&quot;Fir&quot;), listWidget);new QListWidgetItem(tr(&quot;Pine&quot;), listWidget);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        If you need to insert a new item into the list at a particular position, then it should be constructed without a parent widget. The insertItem() function should then be used to place it within the list. The list widget will take ownership of the item.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem *newItem &#x3D; new QListWidgetItem;newItem-&gt;setText(itemText);listWidget-&gt;insertItem(row, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        For multiple items, insertItems() can be used instead. The number of items in the list is found with the count() function. To remove items from the list, use takeItem().<br>​        The current item in the list can be found with currentItem(), and changed with setCurrentItem(). The user can also change the current item by navigating with the keyboard or clicking on a different item. When the current item changes, the currentItemChanged() signal is emitted with the new current item and the item that was previously current.</p><p>​        大致就是创建一个长得像那样链表似的一个控件！</p><p><img src="image-20230526192003545.png" alt="image-20230526192003545">        在QT 的 UI设计下，常常见这个控件于： List Widget下面。</p><p>​        我们这里不对对象名称做什么修改了！默认的情况下——</p><pre class="line-numbers language-none"><code class="language-none">ui -&gt; listWidget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        找到它来！</p><p>​        为了添加控件，我们有两种方式来进行：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式1QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;卢本伟牛逼&quot;);ui-&gt;listWidget-&gt;addItem(item);item-&gt;setTextAlignment(Qt::AlignHCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这就是一种方式——通过包装成 Item 送到Widget里去。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式2QStringList list;list &lt;&lt; &quot;卢&quot;&lt;&lt;&quot;本&quot;&lt;&lt;&quot;伪&quot;&lt;&lt;&quot;牛&quot;&lt;&lt;&quot;逼&quot;;ui-&gt;listWidget-&gt;addItems(list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是通过传入String List 链表的方式送数据。</p><h2 id="1）添加条目的函数"><a href="#1）添加条目的函数" class="headerlink" title="1）添加条目的函数"></a>1）添加条目的函数</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QListWidget</span><span class="token operator">::</span><span class="token function">addItem</span><span class="token punctuation">(</span>QListWidgetItem <span class="token operator">*</span> item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个添加函数需要实现 new 一个 <a href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 条目对象，然后添加到列表控件末尾，下面小节会专门讲 QListWidgetItem 类。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItem(const QString &amp; label)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这第二个添加函数其实更常用，因为更简便，功能是将字符串 label 添加到列表控件末尾显示，其实该函数内部会自动根据字符串 new 一个条目对象添加到列表控件。<br>如果有设置好的字符串列表，那么可以通过如下函数把多个字符串全部添加到列表控件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItems(const QStringList &amp; labels)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>add<em> 函数是将条目添加到末尾，如果要将条目插入到指定行 row 位置，则使用 insert</em> 函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::insertItem(int row, QListWidgetItem * item) &#x2F;&#x2F;插入条目到第 row 行void QListWidget::insertItem(int row, const QString &amp; label) &#x2F;&#x2F;插入字符串到第 row 行void QListWidget::insertItems(int row, const QStringList &amp; labels) &#x2F;&#x2F;插入多个字符串到从 row 行开始的多个行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>获取列表控件里面的条目计数使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::count() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="（2）删除函数"><a href="#（2）删除函数" class="headerlink" title="（2）删除函数"></a>（2）<strong>删除函数</strong></h2><p>​        因为是基于条目的控件，所以列表控件的删除单个条目函数名字是 <strong>takeItem()</strong>：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::takeItem(int row)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        takeItem() 根据行号从列表控件移除一个条目，并返回该条目指针，如果行号不合法，返回 NULL 指针。<br>​        如果返回的是实际存在的条目，那么需要注意，返回的条目指针需要手动 delete 掉，因为列表控件不再拥有该条目，该条目<strong>不会由列表控件析构时自动删除。</strong><br>​        <strong>takeItem() 函数还有第二个用途，因为列表控件没有直接的调整条目前后顺序的函数，可以先将要调整顺序的条目移出来takeItem()，然后再调用 insertItem() 把这个条目插入到新的位置。</strong>（重点关注之）</p><p>​        如果要清空整个列表控件，删除之前添加的所有条目，可以调用槽函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="（3）条目访问函数"><a href="#（3）条目访问函数" class="headerlink" title="（3）条目访问函数"></a>（3）<strong>条目访问函数</strong></h2><p>​        根据行号获取条目对象的指针，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::item(int row) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果已知列表控件含有的条目对象指针，反查当前行号，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::row(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>在图形界面，如果希望根据列表控件在屏幕显示的相对坐标位置（以列表控件内部左上角为原点）来获取条目，使用如下函数：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::itemAt(const QPoint &amp; p) constQListWidgetItem * QListWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>反过来，如果根据已知条目，获取这个条目占据的矩形区域，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QListWidget::visualItemRect(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="（4）当前选中条目的操作"><a href="#（4）当前选中条目的操作" class="headerlink" title="（4）当前选中条目的操作"></a>（4）<strong>当前选中条目的操作</strong></h2><p>获取列表控件当前选中条目的函数如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::currentItem() const &#x2F;&#x2F;当前选中 条目int QListWidget::currentRow() const  &#x2F;&#x2F;当前选中的行号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果当前没有选中的条目，那么返回的指针为 NULL，返回的序号为 -1 ，代码里要注意判断返回值。</p><p>设置已存在的某个条目为选中状态，使用函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setCurrentItem(QListWidgetItem * item)    &#x2F;&#x2F;设置当前选中条目为 itemvoid QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)void QListWidget::setCurrentRow(int row, QItemSelectionModel::SelectionFlags command)&#x2F;&#x2F;设置当前选中行为 rowvoid QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        第二个和第四个设置函数有个 SelectionFlags 类型的参数 command，这个参数决定选中的方式，是要选中QItemSelectionModel::Select ，还是取消选中 QItemSelectionModel::Deselect，还有其他选中方式，等到表格控件一节再详细列出来。<br>如果当前选中的条目发生变化，会触发如下三个信号，可以根据实际用途选择合适的信号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::currentItemChanged(QListWidgetItem * current, QListWidgetItem * previous)void QListWidget::currentRowChanged(int currentRow)void QListWidget::currentTextChanged(const QString &amp; currentText)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意参数里的指针有可能为空值，序号可能为 -1，字符串也可能是空串，一定要注意判断非法的参数值。</p><p>​        本章的三个控件都可以设置选中模式，比如单选模式，一次只能选中一个条目，多选模式，一次可以选中多个条目等等，详细的选中模式在放到表格控件一节讲解，因为表格 中涉及的选中模式较多，一块讲解。本节的列表控件默认情况下，选中模式为单选 。QAbstractItemView::SingleSelection，以上的 <em>current</em> 等函数都是基于默认的单选模式的。</p><p>​        如果需要用到多选模式，可以设置 selectionMode 属性为 QAbstractItemView::ExtendedSelection，这种扩展选中模式类似常见的文件资源管理器的选中模式，可以使用 Ctrl 或 Shift 加鼠标点击实现多选：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setSelectionMode(QAbstractItemView::SelectionMode mode)  &#x2F;&#x2F;设置选中模式QAbstractItemView::SelectionMode    selectionMode() const     &#x2F;&#x2F;获取选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        QAbstractItemView 是本章所有控件的抽象基类，本章后面控件也有类似的选中模式设置，如果把列表控件设置成多选模式，那么可以用如下函数获取同 时选中的多个条目：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::selectedItems() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不论单选还是多选模式，条目选中情况有任何变化时，会触发如下信号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemSelectionChanged()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="（5）条目查找和排序"><a href="#（5）条目查找和排序" class="headerlink" title="（5）条目查找和排序"></a>（5）<strong>条目查找和排序</strong></h2><p>​        如果需要根据文本查找匹配的条目，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::findItems(const QString &amp; text, Qt::MatchFlags flags) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        该函数第一个参数 text 是要查找的模板子串，第二个参数是匹配标志，Qt::MatchFlags 是非常通用的枚举类型，不仅可用于字符串匹配，还能用于其他类型变量的匹配，Qt::MatchFlags 包含关于查找匹配的多种方式的枚举值：</p><div class="table-container"><table><thead><tr><th><strong>Qt::MatchFlags 枚举常量</strong></th><th><strong>数值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Qt::MatchExactly</td><td>0</td><td>精确匹配，执行基于 QVariant 的匹配。</td></tr><tr><td>Qt::MatchFixedString</td><td>8</td><td>执行基于字符串的匹配，如果不指定 MatchCaseSensitive，默认是大小写不敏感。</td></tr><tr><td>Qt::MatchContains</td><td>1</td><td>条目包含要查找的模板子串。</td></tr><tr><td>Qt::MatchStartsWith</td><td>2</td><td>条目以要查找的模板子串打头。</td></tr><tr><td>Qt::MatchEndsWith</td><td>3</td><td>条目以要查找的模板子串结尾。</td></tr><tr><td>Qt::MatchCaseSensitive</td><td>16</td><td>查找时大小写敏感。</td></tr><tr><td>Qt::MatchRegExp</td><td>4</td><td>根据正则表达式模板子串匹配字符串。</td></tr><tr><td>Qt::MatchWildcard</td><td>5</td><td>根据通配符模板子串（如 *.txt）匹配字符串。</td></tr><tr><td>Qt::MatchWrap</td><td>32</td><td>执行回绕查找，当查找到最后一个条目时返回到第一个的条目继续查找，直到所有的条目都检查一遍。</td></tr><tr><td>Qt::MatchRecursive</td><td>64</td><td>递归查找，遍历所有子条目。</td></tr></tbody></table></div><p>​        后面两节的表格控件和树形控件也有类似的查找函数 findItems() ，第二个匹配标志参数也是一样的类型。</p><p>​        列表控件的自动排序是通过 sortingEnabled 属性来控制，获取和设置函数如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isSortingEnabled() constvoid setSortingEnabled(bool enable)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        列表控件条目默认是不排序的，如果希望自动按照字典序排序，调用 setSortingEnabled(true) 即可。另外还可以手动对列表控件现有条目排序：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::sortItems(Qt::SortOrder order &#x3D; Qt::AscendingOrder)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Qt::AscendingOrder 是按升序排列，Qt::DescendingOrder 是按降序排列。</p><h2 id="（6）条目显示和运行时条目编辑"><a href="#（6）条目显示和运行时条目编辑" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）<strong>条目显示和运行时条目编辑</strong></h2><p>​        关于列表控件 QListWidget 和里面的条目 QListWidgetItem，需要注意条目 QListWidgetItem 仅仅是数据，不是控件或子控件，列表控件根据多个 QListWidgetItem 对象，来呈现条目里的数据，<strong>只有列表控件自己是控件实体。</strong><br>列表控件默认以自己的方式呈现条目数据，比如白底黑字的普通条目显示，如果要按照特殊的子控件来显示字符串，比如用 QLabel 对象显示条目数据，可以用如下函 数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setItemWidget(QListWidgetItem * item, QWidget * widget)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        列表控件会同时拥有 item 数据条目和用于显示 item 的子控件 widget。注意这里的子控件 widget 只有静态显示功能，如果用按钮作为显示子控件，那么按钮是不可点击的。如果希望自己定制一个能交互操作的子条目显示控件，需要使用 QListView 并子类化 QItemDelegate 类，这些复杂的等到模型视图章节再讲。</p><p>​        对于本节列表控件，如果要获取 setItemWidget() 函数指定某个条目的显示子控件，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QWidget * QListWidget::itemWidget(QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果要删除上面 setItemWidget() 指定的特殊显示控件，使用函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::removeItemWidget(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        特殊的显示子控件移除后，该条目就还按照列表控件原来的普通条目显示。</p><p>​        <strong>如果希望在程序运行时编辑列表控件的条目，有两种方式，本小节先讲第一种（第二种是设置条目自身的特性标志），手动打开条目的文本编辑器（这个编辑器是列表控件自 带功能，与 setItemWidget 设置的显示子控件没关系）：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::openPersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>这个函数名是打开条目的持续编辑器，持续的意思是如果不调用关闭函数，该条目的编辑器会一直开启，关闭这个持续编辑器使用如下函数：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::closePersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>一般可以在检测到条目激活信号（itemActivated）时调用打开函数 openPersistentEditor() ，在当前条目变化（ currentItemChanged）时调用关闭函数 closePersistentEditor() 。</strong> 使用这一对开关持续编辑器函数涉及到编写多个信号的槽函数，使用比较麻烦，建议用后面第二小节介绍的条目标 志位和 QListWidget::editItem(QListWidgetItem * item) 实现条目的可编辑功能。</p><h2 id="（7）其他信号和槽函数"><a href="#（7）其他信号和槽函数" class="headerlink" title="（7）其他信号和槽函数"></a>（7）<strong>其他信号和槽函数</strong></h2><p>除了上面关于当前条目变化和选中条目变化的信号，条目还有激活、单击、双击等信号，罗列如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemActivated(QListWidgetItem * item)  &#x2F;&#x2F;激活信号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当用户点击或双击条目时，条目会被激活，具体哪些操作会激活条目，要根据操作系统设置来定，比如 Windows 一般是双击打开激活，KDE 桌面通常是单击打开激活。另外，系统的快捷键也可以激活条目，如 Windows 和 Linux X11 桌面是回车键激活，Mac OS X 是 Ctrl+0 ，一般激活信号用于开启编辑等操作。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemChanged(QListWidgetItem * item)   &#x2F;&#x2F;条目内容发生变化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意这是条目内容变化的信号，不是选中状态变化，程序如果在运行时改变了条目文本内容，比如持续编辑器修改了文本，会触发这个信号。<br>剩下几个单击、双击、进入、按压等信号意义比较直白，不详细解释了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemClicked(QListWidgetItem * item)   &#x2F;&#x2F;条目单击信号void QListWidget::itemDoubleClicked(QListWidgetItem * item)  &#x2F;&#x2F;条目双击信号void QListWidget::itemEntered(QListWidgetItem * item)  &#x2F;&#x2F;鼠标追踪时进入条目的信号，一般用不着void QListWidget::itemPressed(QListWidgetItem * item)  &#x2F;&#x2F;鼠标按键在条目上处于按下状态时发的信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>列表控件的槽函数除了前面讲过的 clear() 槽函数用于清空所有条目，还有个比较实用的条目滚动函数，列表控件自带滚动条，当条目总数超出控件矩形能呈现的数目时，滚动条自动出现，通过滚动条支持更多的条目显示。使 用如下槽函数可 以让列表控件滚动到想显示的某个条目位置：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::scrollToItem(const QListWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数 item 就是想显示出来的条目，第二个参数是滚动显示方式，默认是 QAbstractItemView::EnsureVisible，即保证指定条目显示出来，还有其他的滚动显示方式：</p><div class="table-container"><table><thead><tr><th><strong>QAbstractItemView::ScrollHint 枚举常量</strong></th><th><strong>数值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>QAbstractItemView::EnsureVisible</td><td>0</td><td>滚动到指定条目能显示出来即可。</td></tr><tr><td>QAbstractItemView::PositionAtTop</td><td>1</td><td>滚动直到将指定条目显示到可视区域的顶部。</td></tr><tr><td>QAbstractItemView::PositionAtBottom</td><td>2</td><td>滚动直到将指定条目显示到可视区域的底部。</td></tr><tr><td>QAbstractItemView::PositionAtCenter</td><td>3</td><td>滚动直到将指定条目显示到可视区域的中间。</td></tr></tbody></table></div><p>原博客：<a href="https://blog.csdn.net/kongcheng253/article/details/128615688">[QT_007]Qt学习之QListWidget控件详解_天空之城8020的博客-CSDN博客</a></p><h1 id="一些主要控件"><a href="#一些主要控件" class="headerlink" title="一些主要控件"></a>一些主要控件</h1><h2 id="主要控件"><a href="#主要控件" class="headerlink" title="主要控件"></a>主要控件</h2><h3 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h3><pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        The QTreeWidget class is a convenience class that provides a standard tree widget with a classic item-based interface similar to that used by the QListView class in Qt 3. This class is based on Qt’s Model/View architecture and uses a default model to hold items, each of which is a QTreeWidgetItem.<br>​        Developers who do not need the flexibility of the Model/View framework can use this class to create simple hierarchical lists very easily. A more flexible approach involves combining a QTreeView with a standard item model. This allows the storage of data to be separated from its representation.<br>​        In its simplest form, a tree widget can be constructed in the following way:</p><pre class="line-numbers language-none"><code class="language-none">QTreeWidget *treeWidget &#x3D; new QTreeWidget();treeWidget-&gt;setColumnCount(1);QList&lt;QTreeWidgetItem *&gt; items;for (int i &#x3D; 0; i &lt; 10; ++i)&#123; items.append(new QTreeWidgetItem(static_cast&lt;QTreeWidget *&gt;\(nullptr), QStringList(QString(&quot;item: %1&quot;).arg(i))));&#125; treeWidget-&gt;insertTopLevelItems(0, items);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Before items can be added to the tree widget, the number of columns must be set with setColumnCount(). This allows each item to have one or more labels or other decorations. The number of columns in use can be found with the columnCount() function.<br>The tree can have a header that contains a section for each column in the widget. It is easiest to set up the labels for each section by supplying a list of strings with setHeaderLabels(), but a custom header can be constructed with a QTreeWidgetItem and inserted into the tree with the setHeaderItem() function.<br>​        The items in the tree can be sorted by column according to a predefined sort order. If sorting is enabled, the user can sort the items by clicking on a column header. Sorting can be enabled or disabled by calling setSortingEnabled(). The isSortingEnabled() function indicates whether sorting is enabled.</p><p>原博客：</p><p>​        <a href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p><p>​        树形控件的节点可以有多层、多个子节点， 如果将子节点全部展开，那么每一行都是一个数据条目。<a href="https://so.csdn.net/so/search?q=QTreeWidgetItem&amp;spm=1001.2101.3001.7020">QTreeWidgetItem</a> 比较特殊，一个条目内部可以有多列数据信息，相当于表格控件一整行的表格单元集成为一个条目，所以树形条目要比前面两节的列表条目和表格条目都复杂。树形控件每行的条目之间可以是兄弟关系或父子关系，含有子节点的条目可以折叠也可以展开，进行遍历时有专门的迭代器 QTreeWidgetItemIterator 实现，也可以自行编写<a href="https://so.csdn.net/so/search?q=递归算法&amp;spm=1001.2101.3001.7020">递归算法</a>遍历所有条目。</p><h3 id="8-3-1-QTreeWidget"><a href="#8-3-1-QTreeWidget" class="headerlink" title="8.3.1 QTreeWidget"></a>8.3.1 QTreeWidget</h3><p>在 Qt 设计师界面可以直接拖动树形控件到窗口里，下图展示树形控件的外观和构成：</p><p><img src="1.png" alt="f1ce3ab52d8fb8ed2698fa14a9ddb2b0.png"></p><p> 默认情况下，树形控件<strong>最上面是一个树头条目</strong>，<strong><em>\</em>树头条目也是 QTreeWidgetItem 对象**</strong>，可以有<strong>多列内容</strong>。<br>树头下面是真正的树形控件所有条目，在折叠的情况下，如上图所示，每行一个顶级条目，顶级条目也是 QTreeWidgetItem 对象，<strong>顶级条目的父节点指针 QTreeWidgetItem::parent() 为 NULL</strong>。<br>将所有节点展开之后，可以看到每个节点可以有多个子节点：</p><p><img src="2d11f9ba73fbaed337db73e2e141f4e7.png" alt="2d11f9ba73fbaed337db73e2e141f4e7.png"></p><p>对于包含子节点的父节点，左边会有小的三角形指示器，用于控制折叠或展开父节点。子节点也可以拥有更低级别的子节点（孙节点），以此类推，树形控件没 有限定子节点 的层数。顶级节点和其子孙节点的数据结构一样，都可以有多列数据，只是添加的函数、父节点指针不一样。下面介绍树形控件的函数和功能。</p><h3 id="（0）树形控件的构造函数很简单："><a href="#（0）树形控件的构造函数很简单：" class="headerlink" title="（0）树形控件的构造函数很简单："></a>（0）树形控件的构造函数很简单：</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidget(QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数里只有指定父窗口或父控件的指针 parent 。树形控件在添加条目之前，必须要先设置列数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setColumnCount(int columns) &#x2F;&#x2F;设置列数int columnCount() const &#x2F;&#x2F;获取列数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <strong>默认的列数是 1 列</strong>，如果涉及到多列数据，比如文件浏览树，有文件名、文件类型、大小、修改时间等等，就需要设置为多列数据的树。<br>树形控件设置好列数就可以添加相应的顶级条目，添加顶级条目是由树形控件自身的函数实现，而子条目则由 QTreeWidgetItem 的函数实现。本小节主要围绕树形控件和其基类的函数来讲，<strong>树形控件也可以设置和表格控件类似的表头，这里称为树头条目</strong>。</p><h3 id="（1）添加和访问顶级条目"><a href="#（1）添加和访问顶级条目" class="headerlink" title="（1）添加和访问顶级条目"></a>（1）添加和访问顶级条目</h3><p>树形控件顶级条目的操作比较类似 <a href="https://so.csdn.net/so/search?q=QListWidget&amp;spm=1001.2101.3001.7020">QListWidget</a> 的列表条目操作函数。新建条目之后，可以用如下函数把条目添加到树形控件的顶级条目<strong>列表末尾</strong>：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::addTopLevelItem(QTreeWidgetItem * item) &#x2F;&#x2F;添加一个顶级条目到末尾void QTreeWidget::addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items) &#x2F;&#x2F;添加多个顶级条目到末尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        如果希望将条目插入到指定顶级条目列表的 index 序号位置，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::insertTopLevelItem(int index, QTreeWidgetItem * item)void QTreeWidget::insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <strong>树形控件所有的顶级条目父节点指针都为 NULL</strong> （父节点是指树形层次中的节点关系，<strong>而条目的父控件依然是树形控件本身</strong>）。<br>​        添加了顶级条目之后，可以对顶级条目进行计数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::topLevelItemCount() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（2）移除顶级条目"><a href="#（2）移除顶级条目" class="headerlink" title="（2）移除顶级条目"></a>（2）移除顶级条目</h3><p>​        移除顶级条目的函数也是take*打头：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::takeTopLevelItem(int index)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        index是顶级条目的序号，<strong>该函数只是从树形控件卸下顶级条目，但不会删除条目的内存空间，如果希望彻底删除，那么手动 delete 该函数返回的条目。</strong><br>如果要清空所有的顶级条目和子条目，使用槽函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（3）条目访问函数-1"><a href="#（3）条目访问函数-1" class="headerlink" title="（3）条目访问函数"></a>（3）条目访问函数</h3><p>​        对于顶级条目，如果知道顶级条目的序号获取对应的条目：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::topLevelItem(int index) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        反过来，对于已知顶级条目对象，查看其顶级序号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::indexOfTopLevelItem(QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果条目不是顶级条目或者条目不属于该控件，那么会返回 -1。<br>​        树形控件实际运行时，可能既有顶级条目，也有展开后的子孙条目同时显示，<strong>所以某个条目上面或下面的相邻条目不一定是同级别的兄弟条目，有可能是叔辈祖 辈的条目，也 可能是子辈孙辈条目。</strong>获取某个条目的相邻条目函数为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAbove(const QTreeWidgetItem * item) const &#x2F;&#x2F;上面相邻条目QTreeWidgetItem * QTreeWidget::itemBelow(const QTreeWidgetItem * item) const &#x2F;&#x2F;下面相邻条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        从屏幕控件显示角度，如果根据树形控件<strong>内部相对坐标</strong>获取条目（树形控件显示区域的左上角为原点），使用下面函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAt(const QPoint &amp; p) constQTreeWidgetItem * QTreeWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这两个函数是一个意思，一<strong>个用 QPoint 对象表示相对坐标，另一个直接用 x 和 y 数值表示坐标，如果对应坐标没有条目，会返回</strong> <strong>NULL</strong>，注意判断 返回值。<br>​        树形控件也是自带滚动条的，如果条目特别多，自动显示滚动条，对于树形控件在屏幕可见的条目，可以根据条目对象获取它的<strong>可视矩形</strong>（树形控件显示区域的 左上角为原 点）：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QTreeWidget::visualItemRect(const QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（4）当前条目的操作"><a href="#（4）当前条目的操作" class="headerlink" title="（4）当前条目的操作"></a>（4）当前条目的操作</h3><p>​        树形控件的选中操作默认比较像 QListWidget，如果不手动设置，<strong>只能选中一个高亮条目</strong>。<br>获取当前高亮选中条目的函数为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::currentItem() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        树形控件可以有多列，当前条目被点击选中的列号为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::currentColumn() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        树形控件内的条目一般都没有固定行号，<strong>因为条目可以展开也可以折叠，行号是变化的，所以没有基于行号的操作函数。</strong></p><p>​        如果要设置某个条目为当前选中的状态：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setCurrentItem(QTreeWidgetItem * item)void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column)void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        第一个 setCurrentItem() 函数相当<strong>于设置该条目整行高亮选中</strong>，第二个是设置该条目行的 column <strong>列高亮选中</strong>，第三个函数是<strong>单次选中命令</strong>，参考“8.2.4 选中区域和选中行为”的单次选中命令内容，<strong>只是树形控件是一整行为一个条目，定位到条目的某列数据，就 类似指定表格控件的单元格。</strong><br>如果当前高亮选中的状态发生变化，会触发如下信号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数里分别是当前高亮选中的条目，和之前高亮选中的条目，注意指针可能是 NULL，使用指针前一定要判断指针非空</p><h3 id="（5）条目查找和排序-1"><a href="#（5）条目查找和排序-1" class="headerlink" title="（5）条目查找和排序"></a>（5）条目查找和排序</h3><p>​        如果要根据模板子串查找某列文本匹配的条目，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QTreeWidgetItem *&gt; QTreeWidget::findItems(const QString &amp; text, Qt::MatchFlags flags, int column &#x3D; 0) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数里text是模板子串，flags是匹配标志（参看“8.1.1 QListWidget”中的字符串匹配标志表格），第三个参数是指定查找的列。<strong>该函数只查找一列的文本，其他列的文本是不查找的</strong>。如果需要查找所有列数据，那么要根据不同列号逐列查询。</p><p>​        类似表格控件，树形控件也可以按照列的文本进行自动排序，自动排序的设置函数为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool    isSortingEnabled() const          &#x2F;&#x2F;设置是否自动排序void    setSortingEnabled(bool enable)   &#x2F;&#x2F;查看是否开启自动排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        指定排序的列号和升序降序，使用从基类继承的函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::sortByColumn(int column, Qt::SortOrder order)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>在没有开启自动排序的情况下，也可以调用该函数进行一次性的条目排序。</strong></p><h3 id="（6）条目显示和运行时条目编辑-1"><a href="#（6）条目显示和运行时条目编辑-1" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）条目显示和运行时条目编辑</h3><p>​        可以为条目的某列“单元格”设置单独的控件来静态显示（控件不具有编辑功能）：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget) &#x2F;&#x2F;设置条目列控件QWidget * QTreeWidget::itemWidget(QTreeWidgetItem * item, int column) const &#x2F;&#x2F;获取条目列控件，不设置就是NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        注意该函数只能在条目添加到树形控件之后*<em>才能调用，否则无效，\并且条目列控件只能用于显示，无法编辑，如果要定制可编辑的“单元格”控件，必须用基类 QTreeView 并继承 QItemDelegate 做代理，这些内容到后面模型视图章节讲解<br>​        再次强调：itemWidget 条目控件，在默认情况下是与条目本身数据完全无关的，是条目数据的替换品，而不是协作模式。<strong>只有手动设置信号与槽，它们才可能关联上。</strong><br>QListWidget 和 QTreeWidget 的条目控件<strong>都是静态显示，不能编辑。</strong><br>​        QTreeWidget 控件的条目列控件 widget 还必须把默认是透明背景<em>*，</em></em>这样控件的内容和内部模型数据（就是条目的列数据）同时显示，文本会重影，效果就糟糕了。<br>删除条目的列控件使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::removeItemWidget(QTreeWidgetItem * item, int column)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>这个函数没有返回值，会自动地彻底删除条目列控件。</strong></p><p>​        在大多数情况下都用不到 itemWidget ，因为能够为条目设置可编辑标志位，然后调用如下函数开启树形控件自带的文本编辑器：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::editItem(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数 item 是指定的条目，column 是条目的列（类似“单元格”）。在没有为条目设置可编辑标志位的情况下，可以调用下面一对函数进行持续编辑器的开启和关闭：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::openPersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)void QTreeWidget::closePersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <strong>注意这对函数一开一关，要成对调用，否则编辑完了不会自动关闭持续编辑器。</strong></p><h3 id="（7）信号"><a href="#（7）信号" class="headerlink" title="（7）信号"></a>（7）信号</h3><p>​        关于当前高亮选中变化的信号 currentItemChanged() 前面讲过了，这里先列几个常规的信号，然后再将树形控件独有的信号。常规信号就是下面这 几个：（条目列就类似表格控件的单元格）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void itemActivated(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被激活void itemChanged(QTreeWidgetItem * item, int column)   &#x2F;&#x2F;条目列的数据发生变化，比如文本或图标修改了void itemClicked(QTreeWidgetItem * item, int column)  &#x2F;&#x2F;条目列被单击void itemDoubleClicked(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被双击void itemEntered(QTreeWidgetItem * item, int column) &#x2F;&#x2F;进入条目列void itemPressed(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被点 击按下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>树形控件最独特的就是展开和折叠信号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::itemExpanded(QTreeWidgetItem * item)  &#x2F;&#x2F;条目展开时发送信号void QTreeWidget::itemCollapsed(QTreeWidgetItem * item) &#x2F;&#x2F;条目折叠时发送信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        如果调用槽函数 expandAll() 展开所有子孙条目，那么不会触发 itemExpanded() 信号，因为触发太多会非常影响性能。<br>​        类似地，如果用槽函数 collapseAll() 折叠所有子孙条目，也不会触发 itemCollapsed() 信号，以免影响性能。<br>举例来说，在文件夹浏览的时候，因为操作系统里的文件太多，没法一次性构建完整的文件树，那么就可以用展开和折叠信号实时枚举某一层次文件夹的内容， 而不是一次性 枚举文件系统所有文件，因为一次性枚举所有文件的性能太糟糕。<br>树形控件还有一个 <strong>itemSelectionChanged</strong>() 信号，一般在多选模式才会用到，稍后讲解。</p><h3 id="（8）槽函数"><a href="#（8）槽函数" class="headerlink" title="（8）槽函数"></a>（8）槽函数</h3><p>​        树形控件的槽函数包括四个（基类的另算）：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void clear() &#x2F;&#x2F;清空整个树形控件void collapseItem(const QTreeWidgetItem * item) &#x2F;&#x2F;折叠指定的条目void expandItem(const QTreeWidgetItem * item)  &#x2F;&#x2F;展开指定 条目void scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible) &#x2F;&#x2F;滚动到指定条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        滚动函数 scrollToItem() 第二个参数是<strong><em>\</em>滚到到该条目的显示方式**</strong>，参考“8.1.1 QListWidget”QAbstractItemView::  ScrollHint 枚举常量的表格。</p><h3 id="（9）基类-QTreeView-的函数"><a href="#（9）基类-QTreeView-的函数" class="headerlink" title="（9）基类 QTreeView 的函数"></a>（9）基类 QTreeView 的函数</h3><p>QTreeView 的功能函数也很多，这里列举几个可能常用的，详细的内容等到模型视图章节讲解。关于列隐藏或显示、设置列宽的函数如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::setColumnHidden(int column, bool hide) &#x2F;&#x2F;设置列隐藏或显示bool QTreeView::isColumnHidden(int column) const &#x2F;&#x2F;判断列是否隐藏void QTreeView::hideColumn(int column) &#x2F;&#x2F;槽函数，隐藏指定列void QTreeView::showColumn(int column) &#x2F;&#x2F;槽函数，显示指定列void QTreeView::setColumnWidth(int column, int width) &#x2F;&#x2F;设置列宽int QTreeView::columnWidth(int column) const &#x2F;&#x2F;获取指定列的宽度void QTreeView::resizeColumnToContents(int column) &#x2F;&#x2F;槽函数，自动调整 指定列的宽度属性  &#x2F;&#x2F;indentation 控制显示父子节点的缩进宽度：int indentation() const    &#x2F;&#x2F;获取父子节点的缩进宽度void setIndentation(int i) &#x2F;&#x2F;设置缩进宽度void resetIndentation()    &#x2F;&#x2F;重置缩进宽度为默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基类还有几个常用的折叠和展开槽函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void collapseAll() &#x2F;&#x2F;折叠所有子孙节点，这样只能看到顶级节点void expandAll() &#x2F;&#x2F;展开所有子孙节点，完全展开的树void expandToDepth(int depth) &#x2F;&#x2F;展开 depth 层级的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        expandToDepth() 函数是指一直展开，直到将第 depth 层级的子节点都展开为止。以顶级条目为第 0 层级，顶级条目的直接子节点为第 1 层级，孙子节点为第 2 层级，依次类推。<br>​        例如 expandToDepth(0) 的效果如下：</p><p><img src="c1f8eac3f9ec327ea98347e5abab1354.png" alt="c1f8eac3f9ec327ea98347e5abab1354.png"></p><p>​        如果调用 expandToDepth(1) 展开第1级的节点：</p><p><img src="590d3ad8a2fcae012d2240bdbe9a012c.png" alt="590d3ad8a2fcae012d2240bdbe9a012c.png"></p><p>​        如果把 expandToDepth() <strong>参数设置成负数，那么相当于展开无穷大级别，就是展开所有的子孙节点。</strong></p><h3 id="（10）树头条目"><a href="#（10）树头条目" class="headerlink" title="（10）树头条目"></a>（10）树头条目</h3><p>​        树形控件只有一个表头，就是<strong>显示在上面的水平表头，本节也叫树头条目</strong>。设置树头条目的函数为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setHeaderItem(QTreeWidgetItem * item) &#x2F;&#x2F;设置树头条目，树头条目可以有多列数据，相当于多列的表头一次性设置了。void QTreeWidget::setHeaderLabel(const QString &amp; label) &#x2F;&#x2F;只设置第 0 列的表头void QTreeWidget::setHeaderLabels(const QStringList &amp; labels) &#x2F;&#x2F;设置多列的表头QTreeWidgetItem * QTreeWidget::headerItem() const &#x2F;&#x2F;获取树头条目树头条目本质其实也是由 QHeaderView 子控件来显示的，可以在基类找到相关函数：QHeaderView * QTreeView::header() const &#x2F;&#x2F;获取表头视图控件void QTreeView::setHeader(QHeaderView * header) &#x2F;&#x2F;设置表头视图， 一般树形控件不需要用这个函数void QTreeView::setHeaderHidden(bool hide) &#x2F;&#x2F;设置表头是否隐藏bool QTreeView::isHeaderHidden() const &#x2F;&#x2F;判断是否隐藏了表头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        无论是 QTableWidget 还是 QTreeWidget 的表头，都是 QHeaderView 子控件显示，QHeaderView 参考“8.2.3 表头设置”的内容。</p><h3 id="（11）选中行为和选中模式"><a href="#（11）选中行为和选中模式" class="headerlink" title="（11）选中行为和选中模式"></a>（11）选中行为和选中模式</h3><p>​        与 QTableWidget 类似，QTreeWidget也从祖类 QAbstractItemView 继承了选中行为和选中模式的属性：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QAbstractItemView::SelectionBehavior  selectionBehavior() const &#x2F;&#x2F;获取选中行为，按条目选中、整行或整列选中void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior) &#x2F;&#x2F;设置选中行为QAbstractItemView::SelectionMode  selectionMode() const &#x2F;&#x2F;获取选中模式，比如单选、多选、扩展选择void setSelectionMode(QAbstractItemView::SelectionMode mode) &#x2F;&#x2F;设置选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        关于选中模式和选中行为的枚举常量参看“8.2.4 选中区域和选中行为”小节中的枚举常量表格，单次选中命令的函数和枚举常量也参考该小节。</p><p>​        默认情况下，树形控件是按照整行选中，并且是单选模式，如果把选中模式改成多选的 QAbstractItemView::ExtendedSelection，那么树形控件也可以使多选的，这时候信号 itemSelectionChanged() 就能派上用场：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QTreeWidget</span><span class="token operator">::</span><span class="token function">itemSelectionChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        多选状态变化时会触发该信号（单选模式也触发，只是不需要用这个信号），可以关联该信号，监视当前所有选中的条目：</p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">QList<span class="token operator">&lt;</span>QTreeWidgetItem <span class="token comment">*> QTreeWidget::selectedItems() const</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意，<strong>这里的选中条目仅仅是指实际显示的直接选中的条目，不包括折叠隐藏的子孙条目计数</strong>，因为选中父节点与选中其子孙节点没关系，不会递归选中所有子 孙：</p><p><img src="c216490e8c65baf4903b5093b2deddcc.png" alt="c216490e8c65baf4903b5093b2deddcc.png"></p><p>​        树形控件及其基类没有递归选中子条目的属性或函数，<strong>如果希望递归选中某个节点的所有子孙节点，那么需要自行编写递归函数。</strong>关于树形控件类本身的内容介 绍到这，因为 涉及到父子节点隶属关系、节点展开和折叠，树形控件还有很大一部分功能都是由其条目类 QTreeWidgetItem 的函数实现的.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;QListWidgetItem&gt;#include&lt;QStringList&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;       ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;&quot;卢本伟&quot;&lt;&lt;&quot;牛逼&quot;);QTreeWidgetItem* item &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐&quot;);    QTreeWidgetItem* item2 &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐2&quot;);    ui-&gt;treeWidget-&gt;addTopLevelItem(item);    ui-&gt;treeWidget-&gt;addTopLevelItem(item2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230526200623971.png" alt="image-20230526200623971"></p><h2 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h2><p><img src="image-20230526200740443.png" alt="image-20230526200740443"></p><pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Table widgets provide standard table display facilities for applications. The items in a QTableWidget are provided by QTableWidgetItem.<br>​        If you want a table that uses your own data model you should use QTableView rather than this class.<br>​        Table widgets can be constructed with the required numbers of rows and columns:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(12, 3, this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Alternatively, tables can be constructed without a given size and resized later:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(this);tableWidget-&gt;setRowCount(10);tableWidget-&gt;setColumnCount(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        Items are created outside the table (with no parent widget) and inserted into the table with setItem():</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *newItem &#x3D; new QTableWidgetItem(tr(&quot;%1&quot;).arg(\         (row+1)*(column+1)));tableWidget-&gt;setItem(row, column, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        If you want to enable sorting in your table widget, do so after you have populated it with items, otherwise sorting may interfere with the insertion order (see setItem() for details).<br>Tables can be given both horizontal and vertical headers. The simplest way to create the headers is to supply a list of strings to the setHorizontalHeaderLabels() and setVerticalHeaderLabels() functions. These will provide simple textual headers for the table’s columns and rows. More sophisticated headers can be created from existing table items that are usually constructed outside the table. For example, we can construct a table item with an icon and aligned text, and use it as the header for a particular column:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *cubesHeaderItem &#x3D; new QTableWidgetItem(tr(&quot;Cubes&quot;));cubesHeaderItem-&gt;setIcon(QIcon(QPixmap(&quot;:&#x2F;Images&#x2F;cubed.png&quot;)));cubesHeaderItem-&gt;setTextAlignment(Qt::AlignVCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        The number of rows in the table can be found with rowCount(), and the number of columns with columnCount(). The table can be cleared with the clear() function.</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>​        原博客：</p><p>​        <a href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p><h2 id="QTableWidgetItem"><a href="#QTableWidgetItem" class="headerlink" title="QTableWidgetItem"></a>QTableWidgetItem</h2><p>​        表格控件条目 QTableWidgetItem 与 8.1.2 节 <a href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 有很多相似的地方，<br>QTableWidgetItem 也是一个纯数据类，不是控件，没有基类，也就没有信号和槽函数。QTableWidgetItem 可以直接用数据流 <a href="https://so.csdn.net/so/search?q=QDataStream&amp;spm=1001.2101.3001.7020">QDataStream</a> 读写，表格条目不单单有文本，还可以有自己的图标、复选框等特性，表格控件会根据条目对象的丰富特性来呈现数据并进行交互操作。</p><h3 id="（1）首先来看看条目的构造函数："><a href="#（1）首先来看看条目的构造函数：" class="headerlink" title="（1）首先来看看条目的构造函数："></a>（1）<strong>首先来看看条目的构造函数：</strong></h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem(int type &#x3D; Type)QTableWidgetItem(const QString &amp; text, int type &#x3D; Type)QTableWidgetItem(const QIcon &amp; icon, const QString &amp; text, int type &#x3D; Type)QTableWidgetItem(const QTableWidgetItem &amp; other) &#x2F;&#x2F;复制构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        参数里的 type 一般用于派生类，指定条目独特的分类，对于普通的表格控件条目，通常用默认的数值即可。第二个构造函数是指定了条目的文本，第三个构造函数同 时指定了条目图标和文本。<br>​        在构造函数里不能直接指定所属的表格控件，因为表格控件有行号、列号所以不能简单追加到表格里，而只能用表格控件的 QTableWidget::setItem() 函数把条目设置到指定单元格里。注意一个条目只能设置给表格控件唯一的一个单元格，不能把一个条目设置给多个单元格。如果希望为多个单元格设置相似的条目数据内容，那么可 以用后面介绍的 clone() 函数制造大量新的复制体条目。<br>​        复制构造函数不会复制旧条目的 type() 类型值和tableWidget() 所属表格控件指针，条目其他的内部数据和条目标志都会复制。</p><h3 id="（2）复制函数和运算符函数"><a href="#（2）复制函数和运算符函数" class="headerlink" title="（2）复制函数和运算符函数"></a>（2）<strong>复制函数和运算符函数</strong></h3><p>​        除了复制构造函数，还有专门的克隆函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem * QTableWidgetItem::clone() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        克隆函数会新建一个当前条目的复制体，然后返回新复制体条目的指针，如果要构造并添加大量重复内容的条目，这个函数就比较实用。clone() 函数内部会调用复制构造函数创建新条目并返回。<br>​        条目复制还可以用等于号函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        等于号函数复制的内容与复制构造函数差不多，type() 类型值和 tableWidget() 所属表格控件指针也不复制。<br>​        还有个小于号函数，可以比较条目文本的字典序：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果希望使用更多的比较函数，可以直接用 QString 的比较函数。</p><h3 id="（3）QTableWidgetItem-的功能函数与内部数据"><a href="#（3）QTableWidgetItem-的功能函数与内部数据" class="headerlink" title="（3）QTableWidgetItem 的功能函数与内部数据"></a>（3）<strong>QTableWidgetItem 的功能函数与内部数据</strong></h3><p>​        QTableWidgetItem 内部的数据也大致分为两类：第一类是以数据角色形式管理的通用数据，这些数据自动参与 QDataStream 数据流的读写；第二类是非通用数据，不参与数据流读写，与 QListWidgetItem 和 QListWidget 自身特性有关。QTableWidgetItem 主要的功能函数也是围绕这两类内部数据展开的。</p><p>​        ● <strong>第一类：通用数据及其处理函数</strong><br>​        通用数据是以数据角色与数据变量一一对应的形式存储管理，比如设置文本 setText()、设置图标 setIcon() 等函数，其本质都是根据各自的角色调用通用设置数据的函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual void setData(int role, const QVariant &amp; value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也可以根据角色来获取各个数据变量：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual QVariant data(int role) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        查看表格控件的源代码文件可以看到关于图标操作函数的源码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> QIcon <span class="token function">icon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">qvariant_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QIcon<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">QTableWidgetItem</span><span class="token double-colon punctuation">::</span><span class="token function">setIcon</span><span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>aicon<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">setData</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">,</span> aicon<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        QTableWidgetItem 的通用数据与 QListWidgetItem 的通用数据一模一样，函数名也一样，列表如下：</p><div class="table-container"><table><thead><tr><th><strong>获取函数</strong></th><th><strong>设置函数</strong></th><th><strong>数据角色</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>text()</td><td>setText(const QString &amp;text)</td><td>Qt::DisplayRole</td><td>条目显示的文本。</td></tr><tr><td>icon()</td><td>setIcon(const QIcon &amp;icon)</td><td>Qt::DecorationRole</td><td>条目显示的图标。</td></tr><tr><td>statusTip()</td><td>setStatusTip(const QString &amp;statusTip)</td><td>Qt::StatusTipRole</td><td>如果主界面有状态栏，鼠标悬停在该条目上时显示该状态信息到状态栏。</td></tr><tr><td>toolTip()</td><td>setToolTip(const QString &amp;toolTip)</td><td>Qt::ToolTipRole</td><td>鼠标悬停在该条目上时显示的工具提示信息。</td></tr><tr><td>whatsThis()</td><td>setWhatsThis(const QString &amp;whatsThis)</td><td>Qt::WhatsThisRole</td><td>如果主界面窗口标题栏有？帮助按钮，点击帮助按钮再点击该条目会显示该帮助信息。</td></tr><tr><td>font()</td><td>setFont(const QFont &amp;font)</td><td>Qt::FontRole</td><td>显示条目文本用的字体。</td></tr><tr><td>textAlignment()</td><td>setTextAlignment(int alignment)</td><td>Qt::TextAlignmentRole</td><td>文本的对齐方式。</td></tr><tr><td>backgroundColor()</td><td>setBackgroundColor(const QColor &amp;color)</td><td>Qt::BackgroundColorRole</td><td>文本背景色。</td></tr><tr><td>textColor()</td><td>setTextColor(const QColor &amp;color)</td><td>Qt::TextColorRole</td><td>文字颜色。</td></tr><tr><td>background()</td><td>setBackground(const QBrush &amp;brush)</td><td>Qt::BackgroundRole</td><td>条目的背景画刷。</td></tr><tr><td>foreground()</td><td>setForeground(const QBrush &amp;brush)</td><td>Qt::ForegroundRole</td><td>条目的前景画刷。</td></tr><tr><td>checkState()</td><td>setCheckState(Qt::CheckState state)</td><td>Qt::CheckStateRole</td><td>条目自带的复选框选中状态，可以是三态复选框。</td></tr><tr><td>sizeHint()</td><td>setSizeHint(const QSize &amp;size)</td><td>Qt::SizeHintRole</td><td>条目显示的建议尺寸。</td></tr></tbody></table></div><p>​        表格条目 QTableWidgetItem 可以直接用数据流 QDataStream 读写，是通过下面运算符重载函数实现的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QDataStream &amp;    operator&lt;&lt;(QDataStream &amp; out, const QTableWidgetItem &amp; item)QDataStream &amp;    operator&gt;&gt;(QDataStream &amp; in, QTableWidgetItem &amp; item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        使用 &gt;&gt; 和 &lt;&lt; 运算符进行流输入输出比较常见，当然也可以用 QTableWidgetItem 类内部的读写函数进行输入输出：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTableWidgetItem::read(QDataStream &amp; in)void QTableWidgetItem::write(QDataStream &amp; out) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​         <strong>第二类：非通用数据及其操作函数</strong><br>表格控件的条目也是在构造函数一次性指定条目类型，然后这个类型是只读的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::type() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        类型值一般用于派生类区分不同的条目类型，自定义的条目类型值需要大于等于 QTableWidgetItem::UserType 。<br>​        新条目通过表格控件 QTableWidget::setItem() 函数设置给表格控件之后，条<strong>目会自动保存所属的表格控件指针，</strong>可以用如下函数获取：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidget * QTableWidgetItem::tableWidget() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        程序运行时，除了可以通过表格控件的 QTableWidget::selectedItems() 获取用户选中的条目列表，每个单元格条目自身也会记录是否 被用户选中，并且能设置自身是否被选中：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool QTableWidgetItem::isSelected() const &#x2F;&#x2F;判断条目自身是否高亮选中void QTableWidgetItem::setSelected(bool select) &#x2F;&#x2F;设置条目自身是 否被选中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <strong>表格控件条目初始化时也有默认的标志位，并且运行时可以修改条目的特性标志：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Qt::ItemFlags QTableWidgetItem::flags() const &#x2F;&#x2F;获取特性标志位void QTableWidgetItem::setFlags(Qt::ItemFlags flags) &#x2F;&#x2F;设置特性标志位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        QTableWidgetItem 构造<strong>时默认的标志位为</strong>：</p><div class="table-container"><table><thead><tr><th>QT宏</th></tr></thead><tbody><tr><td>Qt::ItemIsSelectable</td></tr><tr><td>Qt::ItemIsUserCheckable</td></tr><tr><td>Qt::ItemIsEnabled</td></tr><tr><td>Qt::ItemIsDragEnabled</td></tr><tr><td>Qt::ItemIsDropEnabled</td></tr><tr><td>Qt::ItemIsEditable</td></tr></tbody></table></div><p>​        因此程序代码生成的所有表格条目默认都是可编辑的，程序运行时用户双击空的单元格时，表格控件会自动创建新条目保存用户编辑内容，这些自动创建的条目也都是可编辑的。如果希望条目是只读的，那么把标志位设置不带Qt::ItemIsEditable 的新标志位即可。</p><p>​        Qt::ItemFlags 所有的枚举常量在 8.1.2 节末尾有详细的表格描述，这里不重复贴了。表格条目默认就是支持复选状态的，只是默认没有显示出来，要让表格控件显示条目对应的复选框，可以用下面一句代码实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">item-&gt;setCheckState( Qt::Unchecked );  &#x2F;&#x2F;显示复选框<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        对于表格控件和表格条目，自带单行编辑器和复选框功能，因此不需要为单元格添加自定义的单行编辑器或复选框，如果要用到其他更多的输入控件，那才需要定制单元格。<br>​        表格控件条目与 QListWidgetItem 最大的一个区别就是表格条目既有行号，也有列号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::row() const &#x2F;&#x2F;获取行号int QTableWidgetItem::column() const &#x2F;&#x2F;获取列号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        行号和列号也是在 QTableWidget::setItem() 函数里指定的，条目自身并不能修改行号或列号。表格控件条目与 QListWidgetItem 另一个区别是，<strong>表格控件条目没有隐藏函数，所有表格条目都是显示的（只要不被单元格控件QTableWidget::cellWidget() 遮挡）。</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F;设函数列数    ui-&gt;tableWidget-&gt;setColumnCount(3);    &#x2F;&#x2F;设置表头    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;&lt;&lt;&quot;年龄&quot;);    ui-&gt;tableWidget-&gt;setRowCount(10);    ui-&gt;tableWidget-&gt;setItem(0,0,new QTableWidgetItem(&quot;泰勒&quot;));&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230526202457563.png" alt="image-20230526202457563"></p><h2 id="其他常见的控件一览"><a href="#其他常见的控件一览" class="headerlink" title="其他常见的控件一览"></a>其他常见的控件一览</h2><h3 id="滚动条控件"><a href="#滚动条控件" class="headerlink" title="滚动条控件"></a>滚动条控件</h3><p>​        我们可以在UI界面中找到滚动条控件——Scroll Widget，将大量的控件扔到里面之后，可以得到：</p><p><img src="image-20230527100557180.png" alt="image-20230527100557180"></p><p>​        可以上下拖拽的那种！</p><h3 id="ToolBox"><a href="#ToolBox" class="headerlink" title="ToolBox"></a>ToolBox</h3><p>​        回忆一下，我们的ToolBox，就跟QQ的好友栏一样的</p><p><img src="image-20230527100815303.png" alt="image-20230527100815303"></p><p>​        这里的Page1 和 Page2单击一下在属性栏的CurrrentPageName里更改就好了</p><h3 id="Tab-Widget"><a href="#Tab-Widget" class="headerlink" title="Tab Widget"></a>Tab Widget</h3><p>​        有点像网页那样的东西!</p><p><img src="image-20230527101102584.png" alt="image-20230527101102584"></p><p>​        当然,我们切换就带上按钮就好了!,使用信号与槽即可</p><p><img src="image-20230527101328100.png" alt="image-20230527101328100"></p><p>​        等等…</p><h3 id="利用QLable显示图片"><a href="#利用QLable显示图片" class="headerlink" title="利用QLable显示图片"></a>利用QLable显示图片</h3><p><img src="image-20230527101714658.png" alt="image-20230527101714658"></p><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><p>​                可以在工程中新建一个QT文件_自定义设计师类&gt;默认的Widget类中!设计好空间之后返回主窗口的UI, 随后点击提升为(本质是换成子对象),将之提升为设计好的Widget的名称后点击提升,运行就可看到效果</p><p>​        点击全局提升，下一次直接提升为.</p><h2 id="QEvent"><a href="#QEvent" class="headerlink" title="QEvent"></a>QEvent</h2><p>​        下面我们自己写一个Lable，来学习自定义的事件这个模块。</p><p>​        首先，我们选择新建一个Widget：回忆下，就是在添加新文件下面——选择QWidget类型后include进来！</p><p>​        先不要着急include控件到UI界面下，我们修改几个地方：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef MYLABEL_H#define MYLABEL_H#include &lt;QLabel&gt;class MyLabel : public QLabel &#x2F;&#x2F; here&#123;    Q_OBJECTpublic:    explicit MyLabel(QWidget *parent &#x3D; nullptr);    void enterEvent(QEnterEvent*); &#x2F;&#x2F; add this    void leaveEvent(QEvent*); &#x2F;&#x2F;add thissignals:&#125;;#endif &#x2F;&#x2F; MYLABEL_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;#include&lt;QDebug&gt;MyLabel::MyLabel(QWidget *parent)    : QLabel&#123;parent&#125;&#123;&#125;void MyLabel::enterEvent(QEnterEvent* event)&#123;    qDebug()&lt;&lt;&quot;111&quot;;&#125;void MyLabel::leaveEvent(QEvent*)&#123;      qDebug()&lt;&lt;&quot;222&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         然后在UI界面中添加Label控件，提升为MyLabel。现在：</p><p><img src="image-20230528171240039.png" alt="image-20230528171240039"></p><p>​        现在，进入正题——鼠标事件的改写。</p><p>​        我们添加如下的事件函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef MYLABEL_H#define MYLABEL_H#include &lt;QLabel&gt;class MyLabel : public QLabel&#123;    Q_OBJECTpublic:    explicit MyLabel(QWidget *parent &#x3D; nullptr);    void enterEvent(QEnterEvent*);    void leaveEvent(QEvent*);    virtual void mousePressEvent(QMouseEvent* ev);    virtual void mouseReleaseEvent(QMouseEvent* ev);    virtual void mouseMoveEvent(QMouseEvent* ev);signals:&#125;;#endif &#x2F;&#x2F; MYLABEL_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;#include&lt;QDebug&gt;MyLabel::MyLabel(QWidget *parent)    : QLabel&#123;parent&#125;&#123;&#125;void MyLabel::enterEvent(QEnterEvent* event)&#123;    qDebug()&lt;&lt;&quot;111&quot;;&#125;void MyLabel::leaveEvent(QEvent*)&#123;      qDebug()&lt;&lt;&quot;222&quot;;&#125;void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;      qDebug()&lt;&lt;&quot;You press your mouse&quot;;&#125;void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;&#125;void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;      qDebug() &lt;&lt; &quot;yes, you move mouse&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528171807801.png" alt="image-20230528171807801"></p><p>​        我们的ev实际上就返回了所有的信息：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;#include&lt;QDebug&gt;#include&lt;QMouseEvent&gt;MyLabel::MyLabel(QWidget *parent)    : QLabel&#123;parent&#125;&#123;&#125;void MyLabel::enterEvent(QEnterEvent* event)&#123;    qDebug()&lt;&lt;&quot;111&quot;;&#125;void MyLabel::leaveEvent(QEvent*)&#123;      qDebug()&lt;&lt;&quot;222&quot;;&#125;void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;      qDebug()&lt;&lt;&quot;You press your mouse&quot;;&#125;void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;&#125;void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;      QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化      qDebug() &lt;&lt;str;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528172343019.png" alt="image-20230528172343019"></p><p>​        还有globle的，表明是相对于屏幕的为止！</p><p>​        如果是检测是不是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;    if(ev-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;        QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化      qDebug() &lt;&lt;str;       &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Qt-Event事件详解"><a href="#Qt-Event事件详解" class="headerlink" title="Qt Event事件详解"></a>Qt Event事件详解</h2><p>​        传送门：<a href="https://www.jianshu.com/p/48f007c2de09">https://www.jianshu.com/p/48f007c2de09</a></p><p>​        <strong>在与用户交互时发生</strong>。比如按下鼠标（mousePressEvent），敲击键盘（keyPressEvent）等。<br>​        <strong>系统自动发生</strong>，比如计时器事件（timerEvent）等。<br>在发生事件时（比如说上面说的按下鼠标），就会产生一个QEvent对象（这里是QMouseEvent，为QEvent的<a href="https://so.csdn.net/so/search?q=子类&amp;spm=1001.2101.3001.7020">子类</a>），这个QEvent对象会传给当前组件的event函数。如果当前组件没有安装事件过滤器（这个下文会提到），则会被event函数发放到相应的xxxEvent函数中（这里是mousePressEvent函数）。</p><p>​        Qt中所有的事件类都继承于QEvent类</p><p>​        这个QEvent对象会有各种各样的属性，这是由用户与界面交互时产生的。xxxEvent函数可以对其进行不同的处理（比如说是鼠标左键按下还是右键？）。查看帮助文档，可以看到QMouseEvent类有以下枚举。<br>在QtCreator中查看帮助文档<br>那么就可以在mousePressEvent中根据这个QEvent对象的这些枚举值来进行不同的处理，比如</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">myLabel</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QLabel</span></span><span class="token punctuation">&#123;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">mousePressEvent</span><span class="token punctuation">(</span>QMouseEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> myLabel<span class="token double-colon punctuation">::</span><span class="token function">mousePressEvent</span><span class="token punctuation">(</span>QMouseEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">-></span>Buttons <span class="token operator">==</span> LeftButton<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//do sth</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">-></span>Buttons <span class="token operator">==</span> RightButton<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//do sth</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到，我们首先需要先创建一个自己的QLabel类，并继承于Qt的QLabel类，然后并重写相应的xxxEvent函数（这些事件处理函数都是虚函数）。</p><p>​        Qt程序的main函数中需要创建一个QApplication对象，然后调用exec函数。这将令程序进入一个死循环，并不断监听应用程序的事件，发生事件时就生成一个QEvent对象。这又称为事件循环。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;QApplication></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mainwindow.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QApplication <span class="token function">app</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    MainWindow window<span class="token punctuation">;</span>    window<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> app<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、事件的分发：event函数"><a href="#二、事件的分发：event函数" class="headerlink" title="二、事件的分发：event函数"></a>二、事件的分发：event函数</h3><p>​        上面提到的xxxEvent函数，称为事件处理器（event handler）。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听某个按键的按下。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myWidget<span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>QEvent <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token comment">//将QEvent对象转换为真正的QKeyEvent对象</span>        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//按照原来的流程来进行事件的分发</span>    <span class="token keyword">return</span> <span class="token class-name">QWidget</span><span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在上面的程序中，myWidget是QWidget的子类。同样的，它的event函数是一个虚函数，带有一个QEvent类型的参数。当系统产生QEvent对象时，就会传入这个函数并调用。函数的返回值是bool类型，返回值不同有不同的意义。</p><p>​        如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODczOTU5OA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>​        Qt系统在处理事件时，有一种机制叫事件传播机制。也就是说，在子组件（比如说一个QButton）中发生的事件，调用了子组件的event函数之后，还会调用父组件（比如说QWidget）的event函数。event函数的返回值就用于控制这样的一个过程。</p><p>​        需要注意的是，重写event函数之后最好返回父类的event函数来处理其他的事件分发，不然就只能处理自己定义的事件。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myTextEdit<span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>QEvent <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token comment">//将QEvent对象转换为真正的QKeyEvent对象</span>        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//直接返回false</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在这个例子中，因为没有调用父类QTextEdit的event函数，所以只能处理Tab的情况，你再按其他按键就啥反应都没有了。同样，事件也不能进行传播。</p><h3 id="三、事件过滤器（Even-Filter）"><a href="#三、事件过滤器（Even-Filter）" class="headerlink" title="三、事件过滤器（Even Filter）"></a>三、事件过滤器（Even Filter）</h3><p>​        某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器（evenFilter）。</p><p>​        QObject有一个虚函数，原型如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> watched<span class="token punctuation">,</span> QEvent <span class="token operator">*</span> event <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件（产生的QEvent对象）。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p><p>​        实际使用中，我们需要对QObject组件调用installEvenFilter函数，即为组件安装过滤器，才能使用事件过滤器这个机制。这样，该组件及其子组件的事件就会被监听。这个机制的好处在于不用像重写QEvent和xxxEvent函数一样需要继承Qt的内置类。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">installEventFilter</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> filterObj <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        下面举一个例子。MainWindow中有一个QTextEdit控件，我们拦截它的键盘按下的事件。这样处理之后，会在输出窗口打印出按下的键位，但不会在控件上显示。这表明事件已被拦截，不会去调用even函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MainWindow</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QMainWindow</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>obj<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    QTextEdit <span class="token operator">*</span>textEdit<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token class-name">MainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    textEdit <span class="token operator">=</span> <span class="token keyword">new</span> QTextEdit<span class="token punctuation">;</span>    <span class="token function">setCentralWidget</span><span class="token punctuation">(</span>textEdit<span class="token punctuation">)</span><span class="token punctuation">;</span>        textEdit<span class="token operator">-></span><span class="token function">installEventFilter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">bool</span> <span class="token class-name">MainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>obj<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> textEdit<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>            QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"you press"</span> <span class="token operator">&lt;&lt;</span> keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//事件不再进行传播，拦截</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//继续传播</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">else</span>     <span class="token punctuation">&#123;</span>        <span class="token comment">//当不确定是否继续传播时，按照父类的方法来处理</span>        <span class="token comment">//即调用父类的evenFilter函数</span>        <span class="token keyword">return</span> <span class="token class-name">QMainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，even函数能干的事情，evenFilter也能干。比如说上面的处理键盘按下Tab键。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myObject<span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>object<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> target <span class="token operator">&amp;&amp;</span> event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>            <span class="token comment">//拦截</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span>         <span class="token punctuation">&#123;</span>            <span class="token comment">//不进行拦截</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//不进行拦截</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们可以对QApplication或者QCoreApplication对象添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。这种行为会严重降低整个应用程序的事件分发效率，要看具体情况使用。</p><p>​        事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>Qt中使用事件机制，每一种事件对应一个事件处理器，比如：</p><ul><li>mouseEvent()</li><li>keyPressEvent()</li><li>etc…<br>发生事件时会生成一个QEvent对象，则需要even函数进行分发，来调用相应的事件处理器</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> QEvent<span class="token double-colon punctuation">::</span>MouseMove<span class="token operator">:</span>        <span class="token function">mouseMoveEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>QMouseEvent<span class="token operator">*</span><span class="token punctuation">)</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        事件过滤器（evenFilter）可以令事件进行拦截，阻止其传播，从而实现某些功能。</p><p>另外，有一种一般很少使用的方法，即去重写这么一个函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token class-name">QCoreApplication</span><span class="token double-colon punctuation">::</span><span class="token function">notify</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> receiver<span class="token punctuation">,</span> QEvent <span class="token operator">*</span> event <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数原实现相当于让组件调用even函数，即receiver-&gt;event(event)。这相当于全局的事件过滤器，且不会受到多线程的限制。</p><p>那么，在使用Qt的事件机制时，应该按照以下思路进行</p><ul><li>重写paintEvent、mousePressEvent等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li><li>重写event函数。event函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li><li>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</li><li>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，但会有多线程问题。</li><li>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。</li></ul><h2 id="鼠标事件（QMouseEvent）"><a href="#鼠标事件（QMouseEvent）" class="headerlink" title="鼠标事件（QMouseEvent）"></a>鼠标事件（QMouseEvent）</h2><p>传送门：<a href="https://blog.csdn.net/qq_44386034/article/details/125637737">https://blog.csdn.net/qq_44386034/article/details/125637737</a></p><p>​        常用的鼠标事件：(本篇处理事件用的是方法一：重写鼠标事件)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void mousePressEvent(QMouseEvent *event);           &#x2F;&#x2F;单击void mouseReleaseEvent(QMouseEvent *event);       &#x2F;&#x2F;释放void mouseDoubleClickEvent(QMouseEvent *event); &#x2F;&#x2F;双击void mouseMoveEvent(QMouseEvent *event);           &#x2F;&#x2F;移动void wheelEvent(QWheelEvent *event);                      &#x2F;&#x2F;滑轮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        鼠标事件使用的时候，加头文件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QMouseEvent&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重写事件框架：</p><pre class="line-numbers language-none"><code class="language-none">鼠标按下事件void Widget::mousePressEvent(QMouseEvent *event)&#123;    &#x2F;&#x2F; 如果是鼠标左键按下       if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;        ···    &#125;    &#x2F;&#x2F; 如果是鼠标右键按下    else if(event-&gt;button() &#x3D;&#x3D; Qt::RightButton)&#123;       ···    &#125;&#125;鼠标移动事件void Widget::mouseMoveEvent(QMouseEvent *event)&#123;    &#x2F;&#x2F; 这里必须使用buttons()    if(event-&gt;buttons() &amp; Qt::LeftButton)&#123;  &#x2F;&#x2F;进行的按位与       ···    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        默认情况下，触发事件需要点击一下，才能触发。可设置为自动触发:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">setMouseTracking(true); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">鼠标释放事件void Widget::mouseReleaseEvent(QMouseEvent *event)&#123;   ···&#125;鼠标双击事件void Widget::mouseDoubleClickEvent(QMouseEvent *event)&#123;    &#x2F;&#x2F; 如果是鼠标左键按下    if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;              ···    &#125;&#125;滚轮事件void Widget::wheelEvent(QWheelEvent *event)&#123;    &#x2F;&#x2F; 当滚轮远离使用者时    if(event-&gt;delta() &gt; 0)&#123;        ···    &#125;else&#123;&#x2F;&#x2F;当滚轮向使用者方向旋转时        ···    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上"><a href="#实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上" class="headerlink" title="实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)"></a>实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)</h3><p>​        创建mylabel类，基类设置为QLabel <img src="b63f2e133baf5913fe5393dc477bfe20.png" alt="img"></p><pre><code>     这里用了类似自定义控件的方法，对Mylabel类进行封装。设置基类QLabel 是为了在ui界面中提升label控件(即将label控件和Mylabel关联，提升时候必须二者基类相同)</code></pre><p>​        在mylabel.h中声明鼠标事件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once#include &lt;qlabel.h&gt;class mylabel : public QLabel&#123;public:    mylabel(QWidget* parent &#x3D; 0);    ~mylabel();public:    &#x2F;&#x2F;鼠标移动事件    void mouseMoveEvent(QMouseEvent* event);    &#x2F;&#x2F;鼠标按下事件    void mousePressEvent(QMouseEvent* event);    &#x2F;&#x2F;鼠标释放事件    void mouseReleaseEvent(QMouseEvent* event);&#125;;在mylabel.cpp中重写事件#include &quot;mylabel.h&quot;#include&quot;QMouseEvent&quot;mylabel::mylabel(QWidget* parent) :QLabel(parent)&#123;    &#125;mylabel::~mylabel()&#123;&#125;&#x2F;&#x2F;鼠标移动显示坐标void mylabel::mouseMoveEvent(QMouseEvent* event)&#123;    if (event-&gt;buttons() &amp; Qt::LeftButton)  &#x2F;&#x2F;进行的按位与(只有左键点击移动才满足)    &#123;         QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());         this-&gt;setText(str);             &#125;&#125;&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”void mylabel::mousePressEvent(QMouseEvent* event)&#123;    setText(&quot;Ok, mouse is press&quot;);&#125;&#x2F;&#x2F;鼠标释放清除显示void mylabel::mouseReleaseEvent(QMouseEvent* event)&#123;    setText(&quot; &quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在主函数(QTest.cpp)中声明mylabel的类对象(即声明一个mylabel类的label控件)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;qtest.h&quot;QTest::QTest(QWidget *parent)    : QWidget(parent)&#123;    ui.setupUi(this);    &#x2F;&#x2F;声明mylabel类的控件    mylabel* label1 &#x3D; new mylabel(this);    label1-&gt;setGeometry(QRect(130, 100, 271, 161));    &#x2F;&#x2F;设置边框    label1-&gt;setFrameShape(QFrame::Panel);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     ![img](D:\My notebook project\Program language\C++\QT\QT new 13\2b78bd5ca82261a28798c809af0ef282.gif)</code></pre><p>​        另外，当调用setMouseTracking(true);时(即设置鼠标状态为自动触发)，需要将鼠标移动事件的if语句去掉(因为不需要点击触发了)</p><p>​        修改maylabel.cpp事件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;#include&quot;QMouseEvent&quot;mylabel::mylabel(QWidget* parent) :QLabel(parent)&#123;    &#x2F;&#x2F;设置鼠标状态(自动触发)    setMouseTracking(true);&#125;mylabel::~mylabel()&#123;&#125;&#x2F;&#x2F;鼠标移动显示坐标void mylabel::mouseMoveEvent(QMouseEvent* event)&#123;   QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());   this-&gt;setText(str);&#125;&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”void mylabel::mousePressEvent(QMouseEvent* event)&#123;    setText(&quot;Ok, mouse is press&quot;);&#125;&#x2F;&#x2F;鼠标释放清除显示void mylabel::mouseReleaseEvent(QMouseEvent* event)&#123;    setText(&quot; &quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果展示：</p><p><img src="0c83943e6ee8c74e39d09db4a899b2c6.gif" alt="img"></p><p>​        这里用的是代码创建label控件，那么能不能用ui界面编辑然后在对label控件提升呢？</p><p>答案是可以的，但是需要注意的是：此处不能选择全局包含</p><p><img src="4cb8112d483f6e94c8fe196258871445.png" alt="img"></p><p> 否则会出现：</p><p><img src="e7df65e65f36ed436c5ec6ab7c41f417.png" alt="img"></p><p>​        我想其中的原因主要是因为：</p><p>​        本实例是新建了一个mylabel类，而不是像QT常用控件(三)——自定义控件封装 - 唯有自己强大 - 博客园 (cnblogs.com)这篇博文中直接新添加了一个设计师界面类(即包含ui .h .cpp)。当选择全局包含时，就包含了主类。</p><p>​        其实也有解决的办法：需要在提升界面的头文件处，将工程目录下自定义控件的地址放于此处(本篇地址：C:/Users/WFD/Desktop/QTest/QTest/mylabel.h)</p><p><img src="c3a41a90d53c14e6f9e28ea56aa4c497.png" alt="img"></p><p> 二，事件的分发：event函数<br>        上面提到的xxxEvent函数，称为事件处理器(event handler)。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听(阻塞)鼠标按下事件。</p><pre><code>     如果希望在事件分发之前做一些操作，就可以重写这个 event()函数了。比如我们希望阻塞鼠标按下事件，那么我们就在新建的Mylabel类中重写event()函数(该类的父类是QLabel)</code></pre><p>在Mylabel.h中声明event事件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;qlabel.h&quot;class Mylabel : public QLabel&#123;public:    explicit Mylabel(QWidget* parent &#x3D; 0);    &#x2F;&#x2F;鼠标按下事件    void mousePressEvent(QMouseEvent* event);     &#x2F;&#x2F;鼠标释放事件    void mouseReleaseEvent(QMouseEvent* event);    &#x2F;&#x2F;声明event事件    bool event(QEvent* e);&#125;;在Mylabel.cpp中重写event事件。#include &quot;Mylabel.h&quot;#include&quot;QMouseEvent&quot;Mylabel::Mylabel(QWidget* parent) :QLabel(parent)&#123;&#125;&#x2F;&#x2F;重写鼠标按下事件void Mylabel::mousePressEvent(QMouseEvent* event)&#123;    this-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));&#125;&#x2F;&#x2F;重写鼠标释放事件void Mylabel::mouseReleaseEvent(QMouseEvent* event)&#123;    this-&gt;setText(&quot;mouse is release &quot;);&#125;&#x2F;&#x2F;重写event事件bool Mylabel::event(QEvent* e)&#123;    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截    if (e-&gt;type()&#x3D;&#x3D;QEvent::MouseButtonPress)    &#123;        &#x2F;&#x2F;静态转换(将QEvent的对象转换为QMouseEvent对象)        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);        this-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)    &#125;    return QLabel::event(e);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <img src="06ef2891b59dcc3d4f1953b7e3404c5e.png" alt="img"></p><p>​        点击鼠标可以看到，触发的是event的事件(即阻塞了mousePressEvent的事件)。特别需要注意的是：在将不需要阻塞分发的时候，需要分发给父类的event函数处理。即(return QLable::event(e)；)</p><p>​        由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个 event()函数，通过 QEvent::type()判断不同的事件。鉴于重写 event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器(当然，也必须记得是不是应该调用父类的同名处理器)。</p><h3 id="三，事件过滤器-Even-Filter"><a href="#三，事件过滤器-Even-Filter" class="headerlink" title="三，事件过滤器(Even Filter)"></a>三，事件过滤器(Even Filter)</h3><p>​         某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器，该过滤器在event分发之前进行拦截。</p><p>事件的过滤有两个步骤：</p><p>​        对QObject组件安装过滤器(调用installEvenFilter函数)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QObject::installEventFilter ( QObject * filterObj );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数filterobj 是指谁为组件安装过滤器(一般是父类)</p><p>​        这个函数接受一个 QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是 QObject 的一个成员函数，因此，任意 QObject 都可以作为事件过滤器(问题在于，如果你没有重写 eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤)。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。<br>我们可以向一个对象上面安装多个事件处理器 ，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。<br>​        事件过滤器的重写(evenFilter函数)</p><pre class="line-numbers language-none"><code class="language-none">virtual bool QObject::eventFilter ( QObject * watched, QEvent * event );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件(产生的QEvent对象)。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p><p>​        实例：通过事件过滤器阻塞上面代码中的鼠标按下事件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;qtest.h&quot;#include&quot;qmouseevent&quot;QTest::QTest(QWidget *parent)    : QWidget(parent)&#123;    ui.setupUi(this);    &#x2F;&#x2F;第一步：给label添加过滤器    ui.label-&gt;installEventFilter(this);&#125;&#x2F;&#x2F;第二步：重写过滤事件bool QTest::eventFilter(QObject* obj, QEvent* e)&#123;    if (obj &#x3D;&#x3D; ui.label)    &#123;        &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截        if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)        &#123;            QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);            ui.label-&gt;setText(QString(&quot;eventfilter mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));            return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)        &#125;    &#125;    return QWidget::eventFilter(obj, e);&#125;&#x2F;&#x2F;重写鼠标按下事件void QTest::mousePressEvent(QMouseEvent* event)&#123;    ui.label-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));&#125;&#x2F;&#x2F;重写事件分发bool QTest::event(QEvent* e)&#123;    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截    if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)    &#123;        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);        ui.label-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)    &#125;    return QWidget::event(e);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：<img src="09dd8a5f89d61fa32b9e3800fe5fff9a.png" alt="img"></p><p>可以看到在过滤器事件中就监听了鼠标按压(即阻塞了后面的事件分发和鼠标按压)</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>​        我们的定时器可以做到随着事件的事件流逝触发事件。</p><p>​        我们的办法是：添加窗口的代码，从而实现计时器。</p><p>​        在窗口中添加两个label:</p><p>​        随后改写事件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123;    Q_OBJECTpublic:    Widget(QWidget *parent &#x3D; nullptr);    ~Widget();    void timerEvent(QTimerEvent*);    int id1;    int id2;private:    Ui::Widget *ui;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F;启动定时器    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒    id2 &#x3D; startTimer(2000);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::timerEvent(QTimerEvent* ev)&#123;    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;        static int num &#x3D; 1;        ui-&gt;label_2-&gt;setText(QString::number(num++));    &#125;     if(ev-&gt;timerId() &#x3D;&#x3D; id2)    &#123;        static int num2 &#x3D; 1;        ui-&gt;label_3-&gt;setText(QString::number(num2++));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到，对于多个计时器需要接受返回ID并加之以判断才好！</p><h2 id="类的形式"><a href="#类的形式" class="headerlink" title="类的形式"></a>类的形式</h2><p>​        这个形式简单的多!直接一个类解决所有的问题!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include&lt;QTimer&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F;启动定时器    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒    id2 &#x3D; startTimer(2000);    QTimer* timer &#x3D; new QTimer(this);    timer-&gt;start(500); &#x2F;&#x2F; 到0.5秒发出信号    connect(timer,&amp;QTimer::timeout,[&#x3D;]()&#123;        static int num &#x3D; 1;        ui-&gt;label_4-&gt;setText(QString::number(num++));    &#125;);    &#x2F;&#x2F;    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[&#x3D;]()&#123;        timer-&gt;stop();    &#125;);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::timerEvent(QTimerEvent* ev)&#123;    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;        static int num &#x3D; 1;        ui-&gt;label_2-&gt;setText(QString::number(num++));    &#125;     if(ev-&gt;timerId() &#x3D;&#x3D; id2)    &#123;        static int num2 &#x3D; 1;        ui-&gt;label_3-&gt;setText(QString::number(num2++));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Extensive-Reading"><a href="#Extensive-Reading" class="headerlink" title="Extensive Reading"></a>Extensive Reading</h2><p>​        传送门：<a href="https://blog.csdn.net/Mountain_tai_li/article/details/130529628">https://blog.csdn.net/Mountain_tai_li/article/details/130529628</a></p><p>​        QTimer 类提供重复和单次计时器。</p><p>​        QTimer 类为计时器提供了一个高级编程接口。要使用它，首先创建一个 QTimer实例，将其 timeout() 信号连接到相应的插槽，然后调用 start()。从那时起，它将以恒定的间隔发出 timeout() 信号。</p><p>​        一秒（1000毫秒）计时器的示例（来自模拟时钟示例）：</p><pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);connect(timer, SIGNAL(timeout()), this, SLOT(update()));timer-&gt;start(1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        从那时起，每秒调用一次 update() 槽函数。</p><p>​        也可以通过调用 setSingleShot（true） 将计时器设置为仅超时一次。您还可以使用静态 QTimer::singleShot() 函数在指定的时间间隔后调用槽函数：</p><p>​        QTimer::singleShot(200, this, SLOT(updateCaption()));<br>​        在多线程应用程序中，可以在任何具有事件循环的线程中使用 QTimer。要从非 GUI 线程启动事件循环，使用 QThread::exec()。Qt使用计时器的线程亲和力来确定哪个线程将发出timeout()信号。因此，您必须在其线程中启动和停止计时器;无法从另一个线程启动计时器。作为特殊情况timeout 为 0 的 QTimer 将在窗口系统的事件队列中的所有事件都得到处理后立即timeout。这可用于完成繁重的工作，同时提供活泼的用户界面：</p><pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);connect(timer, SIGNAL(timeout()), this, SLOT(processOneThing()));timer-&gt;start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        从那时起，processOneThing()槽函数将被重复调用。它应该以这样一种方式编写，即它总是快速返回（通常在处理一个数据项之后），以便Qt可以将事件传递到用户界面，并在完成所有工作后立即停止计时器。这是在GUI应用程序中实现繁重工作的传统方式，但随着多线程在越来越多的平台上变得可用，我们预计零毫秒QTimer对象将逐渐被QThreads取代。</p><p>​        定时器精度和分辨率<br>​        计时器的准确性取决于底层操作系统和硬件。大多数平台都支持 1 毫秒的分辨率，尽管在许多现实情况下，计时器的精度不会等于此分辨率。</p><p>​        精度还取决于计时器类型。对于Qt::PreciseTimer，QTimer将尝试将精度保持在1毫秒。精确的计时器也不会比预期早超时。对于 Qt::CoarseTimer 和 Qt::VeryCoarseTimer 类型，QTimer 可能会比预期更早timeout，在这些类型的范围内：Qt::CoarseTimer 的间隔为 5%，Qt::VeryCoarseTimer 的间隔为 500 毫秒。如果系统繁忙或无法提供请求的准确性，则所有计时器类型都可能晚于预期超时。在timeout 溢出的情况下，Qt只会发出一次active()，即使多个超时已经过期，然后恢复原始间隔。 </p><h2 id="绘图事件"><a href="#绘图事件" class="headerlink" title="绘图事件"></a>绘图事件</h2><p>​        我们可以在窗口中绘制图像。比如说，我们新建一个Widget：在widget.h这个文件下书写有：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include&lt;QPaintEvent&gt; &#x2F;&#x2F; include neccessaryFileQT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123;    Q_OBJECTpublic:    Widget(QWidget *parent &#x3D; nullptr);    ~Widget();    &#x2F;&#x2F; 绘图事件    void paintEvent(QPaintEvent*); &#x2F;&#x2F; add code here...private:    Ui::Widget *ui;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        也就是说，我们需要重写一个函数叫做<code>paintEvent(QPaintEvent*)</code></p><p>​        转到widget.cpp下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include&lt;QPainter&gt;#include&lt;QPoint&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);&#125;void Widget::paintEvent(QPaintEvent*)&#123;    QPainter painter(this);    painter.drawLine(QPoint(0,0),QPoint(100,100));&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230605182550682.png" alt="image-20230605182550682"></p><p>​        我们还可以画圆：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">painter.drawEllipse(QPoint(100,100),50,50); &#x2F;&#x2F; 画椭圆<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230605182711434.png" alt="image-20230605182711434"></p><p>​        画矩形：</p><pre class="line-numbers language-none"><code class="language-none">painter.drawRect(QRect(QPoint(200,200),QPoint(300,300)));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230605183009972.png" alt="image-20230605183009972"></p><p>​        或者是展示文字：</p><pre class="line-numbers language-none"><code class="language-none">painter.drawText(QRect(10,200,200,200),&quot;好好学习，逆天享受&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230605183201375.png" alt="image-20230605183201375"></p><p>​        当然，我们可以设置画笔性质：</p><pre class="line-numbers language-none"><code class="language-none">QPen pen(QColor(255,0,0));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230605183341509.png" alt="image-20230605183341509"></p><p>​        我们还可以使用画刷：</p><pre class="line-numbers language-none"><code class="language-none">QBrush brush(Qt::green);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230605183737110.png" alt="image-20230605183737110"></p><p>​        其他：</p><p><img src="image-20230605183952474.png" alt="image-20230605183952474"></p><p><img src="image-20230605183959522.png" alt="image-20230605183959522"></p><p>​        上面的这个是让画笔的起笔点平移了！</p><p><img src="image-20230605184248890.png" alt="image-20230605184248890"></p><p>​        上面就是存储与换元的状态。</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>​        使用QPixmap类从而加载图片：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPainter painter(this);painter.drawPixmap(20,100,QPixmap(&quot;:&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230605184915345.png" alt="image-20230605184915345"></p><p>​        注意我们若是想要刷新图片，更好的使用<code>update()</code>！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include&lt;QPainter&gt;#include&lt;QPoint&gt;#include&lt;QPushButton&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[&#x3D;]()&#123;        posX +&#x3D; 20;        update();    &#125;);    connect(ui-&gt;pushButton_2,&amp;QPushButton::clicked,[&#x3D;]()&#123;        posX -&#x3D; 20;        update();    &#125;);&#125;void Widget::paintEvent(QPaintEvent*)&#123;    QPainter painter(this);    painter.drawPixmap(posX,0,QPixmap(&quot;:&#x2F;1.png&quot;));&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Extensive-Reading-I"><a href="#Extensive-Reading-I" class="headerlink" title="Extensive Reading I"></a>Extensive Reading I</h2><p>原文链接：<a href="https://blog.csdn.net/Jeffxu_lib/article/details/111224870">https://blog.csdn.net/Jeffxu_lib/article/details/111224870</a></p><h3 id="一、QPaintEvent-绘图事件"><a href="#一、QPaintEvent-绘图事件" class="headerlink" title="一、QPaintEvent 绘图事件"></a>一、QPaintEvent 绘图事件</h3><h4 id="1、paintEvent-函数"><a href="#1、paintEvent-函数" class="headerlink" title="1、paintEvent 函数"></a>1、paintEvent 函数</h4><p>该绘图函数为虚函数，一般要在子类中去重新实现，来接受绘图事件。<br>通过QPainter来绘图时，一般必须要在paintEvent 函数中来进行。在该函数中重新实现所有的绘图操作，程序在初始化之后会自动调用该绘图事件函数来进行绘图。</p><h4 id="2、绘图函数的调用"><a href="#2、绘图函数的调用" class="headerlink" title="2、绘图函数的调用"></a>2、绘图函数的调用</h4><p>绘图函数paintEvent 的首次调用是在所有的UI都初始化之后进行的。<br>当程序的UI发生变化时，如控件大小位置变化、控件由隐藏到显示变化时，程序会调用paintEvent函数<br>当调用repaint或update函数时，会导致程序调用paintEvent 函数。一般推荐使用update函数，因为Qt针对update做了优化和处理，而repaint则没有。</p><h3 id="二、QPainter基础"><a href="#二、QPainter基础" class="headerlink" title="二、QPainter基础"></a>二、QPainter基础</h3><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>QPainter一般在 paintEvent 事件函数中去使用，否则不会生效。在虚函数paintEvent中去重新实现对应功能，如构建和自定义画家QPainter对象，并指定绘图设备(即具体在什么上绘制，如指定的label或widget等控件)，进行绘制对应的UI<br>QPainter 在绘制GUI的程序上，提供了高度的优化功能。它能绘制几乎所有的 UI，如：点、线条、矩形、圆弧、椭圆、弦、图片、文字、填充等。</p><h4 id="2、常用接口"><a href="#2、常用接口" class="headerlink" title="2、常用接口"></a>2、常用接口</h4><p>QPainter (QPaintDevice *device)：构建画家对象，并指定绘图设备，即在哪上面进行绘制。<br>drawArc：在指定的矩形中画内切的圆弧<br>drawChord：在指定的矩形中画弦<br>drawPie：在指定矩形中画饼型图<br>drawConvexPolygon：根据给定的多个点来画凸多边形<br>drawPolygon：画多边形<br>drawEllipse：在指定矩形内画椭圆<br>drawImage：绘制图片，相当于用指定的图片来填充指定的矩形。<br>drawLine：根据给定的点来画线<br>drawPolyline：根据多个点来画折线，折线的首尾不相连<br>drawPath (const QPainterPath &amp;path)：画指定的路径图，可以画各种各样的不规则图形。<br>drawPicture：在给定的点重新加载展示指定的图片<br>drawPixmap:画像素图，即用指定的图来在指定矩形中进行填充<br>drawPoint：画一个点<br>drawRect：画方正的矩形<br>drawRoundedRect：画带圆角的矩形<br>drawText：画文本文字<br>fillRect：用指定的颜色来填充矩形区域，此时没有边线，只是填充指定区域<br>font：返回当前用来绘制文本的字体<br>fontMetrics：在画家处于激活的状态下返回当前字体的几何尺寸信息<br>opacity：返回当前的画家的透明度，默认值为1<br>layoutDirection：当绘制文本内容时，返回布局方向<br>setPen：设置画笔的样式<br>setOpacity：设置不透明度，取值的范围是0.0 0.00.0 ~ 1.0 1.01.0，当值为0.0 0.00.0时为完全透明，当值为1.0 1.01.0时为完全不透明。<br>setBackground：设置填充背景的颜色样式，当背景模式为透明时，该函数将不起作用<br>setBrush：以指定的颜色样式填充所画的图形<br>setFont：绘制文本内容时，来设置对应的字体样式<br>setLayoutDirection：当绘制文本内容时，用来设置布局的方向<br>3、对比 QPainter 和 QPen</p><p>QPainter和QPen都可以调用各自的setBrush函数，但是作用的效果完全不同</p><p>(1)、 QPainter 调用setBrush函数</p><p>此时画家QPainter可以以指定的颜色来填充所绘制的整个封闭图形(只有封闭的图形才能被填充，如弦Arc未封闭将不能被填充)，相当于刷子。<br>或者此时画家QPainter以指定的样式来填充封闭图形，(以颜色或样式填充只能有一种起作用，不可以同时起作用)。<br>应用示例</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PaintEventTest::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);    painter.setBrush(QColor(0, 200, 250, 200)); &#x2F;&#x2F;设置填充颜色    painter.setPen(QPen(Qt::red,20)); &#x2F;&#x2F;设置画笔的颜色和宽度。若不设置画笔，则画家会以默认宽度和颜色的画笔来绘制边线    painter.drawPie(QRect(50, 50, 500, 500), 0, 260 * 16);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2)、 QPen 调用setBrush函数</p><p>此时只是用来填充笔画，其效果相当于setColor。即只是设置线条的颜色。<br>应用示例</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PaintEventTest::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);        QPen pen;    pen.setBrush(Qt::red); &#x2F;&#x2F;只是设置画笔的颜色    &#x2F;&#x2F;pen.setColor(Qt::blue); &#x2F;&#x2F;和上面setBrush作用相同都是设置画笔的颜色    pen.setWidth(6);    painter.setPen(pen);    painter.drawPie(QRect(100, 100, 500, 500), 0, 260 * 16);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一、QPaintEvent-绘图事件-1"><a href="#一、QPaintEvent-绘图事件-1" class="headerlink" title="一、QPaintEvent 绘图事件"></a>一、<code>QPaintEvent</code> 绘图事件</h3><p><strong>1、<code>paintEvent</code> 函数</strong></p><ul><li>该绘图函数为虚函数，一般要在子类中去重新实现，来接受绘图事件。</li><li>通过<code>QPainter</code>来绘图时，一般必须要在<code>paintEvent</code> 函数中来进行。在该函数中重新实现所有的绘图操作，程序在初始化之后会自动调用该绘图事件函数来进行绘图。</li></ul><p><strong>2、绘图函数的调用</strong></p><ul><li>绘图函数<code>paintEvent</code> 的首次调用是在所有的<code>UI</code>都初始化之后进行的。</li><li>当程序的<code>UI</code>发生变化时，如控件大小位置变化、控件由隐藏到显示变化时，程序会调用<code>paintEvent</code>函数</li><li>当调用<code>repaint</code>或<code>update</code>函数时，会导致程序调用<code>paintEvent</code> 函数。一般推荐使用<code>update</code>函数，因为<code>Qt</code>针对<code>update</code>做了优化和处理，而<code>repaint</code>则没有。</li></ul><hr><h3 id="二、QPainter基础-1"><a href="#二、QPainter基础-1" class="headerlink" title="二、QPainter基础"></a>二、<code>QPainter</code>基础</h3><p><strong>1、简介</strong></p><ul><li><code>QPainter</code>一般在 <code>paintEvent</code> 事件函数中去使用，否则不会生效。在虚函数<code>paintEvent</code>中去重新实现对应功能，如构建和自定义画家<code>QPainter</code>对象，并指定绘图设备(即具体在什么上绘制，如指定的<code>label</code>或<code>widget</code>等控件)，进行绘制对应的UI</li><li><code>QPainter</code> 在绘制GUI的程序上，提供了高度的优化功能。它能绘制几乎所有的 UI，如：点、线条、矩形、圆弧、椭圆、弦、图片、文字、填充等。</li></ul><p><strong>2、常用接口</strong></p><ul><li><code>QPainter (QPaintDevice *device)</code>：构建画家对象，并指定绘图设备，即在哪上面进行绘制。</li><li><code>drawArc</code>：在指定的矩形中画内切的圆弧</li><li><code>drawChord</code>：在指定的矩形中画弦</li><li><code>drawPie</code>：在指定矩形中画饼型图</li><li><code>drawConvexPolygon</code>：根据给定的多个点来画凸多边形</li><li><code>drawPolygon</code>：画多边形</li><li><code>drawEllipse</code>：在指定矩形内画椭圆</li><li><code>drawImage</code>：绘制图片，相当于用指定的图片来填充指定的矩形。</li><li><code>drawLine</code>：根据给定的点来画线</li><li><code>drawPolyline</code>：根据多个点来画折线，折线的首尾不相连</li><li><code>drawPath (const QPainterPath &amp;path)</code>：画指定的路径图，可以画各种各样的不规则图形。</li><li><code>drawPicture</code>：在给定的点重新加载展示指定的图片</li><li><code>drawPixmap</code>:画像素图，即用指定的图来在指定矩形中进行填充</li><li><code>drawPoint</code>：画一个点</li><li><code>drawRect</code>：画方正的矩形</li><li><code>drawRoundedRect</code>：画带圆角的矩形</li><li><code>drawText</code>：画文本文字</li><li><code>fillRect</code>：用指定的颜色来填充矩形区域，此时没有边线，只是填充指定区域</li><li><code>font</code>：返回当前用来绘制文本的字体</li><li><code>fontMetrics</code>：在画家处于激活的状态下返回当前字体的几何尺寸信息</li><li><code>opacity</code>：返回当前的画家的透明度，默认值为1</li><li><code>layoutDirection</code>：当绘制文本内容时，返回布局方向</li><li><code>setPen</code>：设置画笔的样式</li><li><code>setOpacity</code>：设置不透明度，取值的范围是0.0 0.00.0 ~ 1.0 1.01.0，当值为0.0 0.00.0时为完全透明，当值为1.0 1.01.0时为完全不透明。</li><li><code>setBackground</code>：设置填充背景的颜色样式，当背景模式为透明时，该函数将不起作用</li><li><code>setBrush</code>：以指定的颜色样式填充所画的图形</li><li><code>setFont</code>：绘制文本内容时，来设置对应的字体样式</li><li><code>setLayoutDirection</code>：当绘制文本内容时，用来设置布局的方向</li></ul><p><strong>3、对比 <code>QPainter</code> 和 <code>QPen</code></strong></p><p><code>QPainter</code>和<code>QPen</code>都可以调用各自的setBrush函数，但是作用的效果完全不同</p><p>(1)、 <code>QPainter</code> 调用setBrush函数</p><ul><li>此时画家<code>QPainter</code>可以以指定的颜色来填充所绘制的整个封闭图形(只有封闭的图形才能被填充，如弦<code>Arc</code>未封闭将不能被填充)，相当于刷子。</li><li>或者此时画家<code>QPainter</code>以指定的样式来填充封闭图形，(以颜色或样式填充只能有一种起作用，不可以同时起作用)。</li><li>应用示例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PaintEventTest</span><span class="token double-colon punctuation">::</span><span class="token function">paintEvent</span><span class="token punctuation">(</span>QPaintEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QPainter <span class="token function">painter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        painter<span class="token punctuation">.</span><span class="token function">setBrush</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置填充颜色</span>    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span><span class="token function">QPen</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>red<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置画笔的颜色和宽度。若不设置画笔，则画家会以默认宽度和颜色的画笔来绘制边线</span>    painter<span class="token punctuation">.</span><span class="token function">drawPie</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>(2)、 <code>QPen</code> 调用setBrush函数</p><ul><li>此时只是用来填充笔画，其效果相当于setColor。即只是设置线条的颜色。</li><li>应用示例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PaintEventTest</span><span class="token double-colon punctuation">::</span><span class="token function">paintEvent</span><span class="token punctuation">(</span>QPaintEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QPainter <span class="token function">painter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        QPen pen<span class="token punctuation">;</span>    pen<span class="token punctuation">.</span><span class="token function">setBrush</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只是设置画笔的颜色</span>    <span class="token comment">//pen.setColor(Qt::blue); //和上面setBrush作用相同都是设置画笔的颜色</span>    pen<span class="token punctuation">.</span><span class="token function">setWidth</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span>pen<span class="token punctuation">)</span><span class="token punctuation">;</span>    painter<span class="token punctuation">.</span><span class="token function">drawPie</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70-16859635782821.png" alt="在这里插入图片描述"></p><hr><h3 id="三、基本应用"><a href="#三、基本应用" class="headerlink" title="三、基本应用"></a>三、基本应用</h3><p><strong>1、设置画笔样式 <code>setPen</code> 有三种方式</strong></p><p>（1）、<code>setPen(const QPen &amp;pen)</code> ：直接设置画笔QPen的样式，该项可以同时设置画笔的众多属性，如：宽度、线条样式、颜色等，因此最为常用。</p><ul><li>首先创建QPen的对象画笔，然后设置该画笔</li><li>在此可以通过构造函数或子函数来设置画笔的：样式、颜色(包括透明度)、线宽等属性。</li><li>然后画家通过 setPen 函数来将该画笔设置到对应的画家对象上。</li><li>Qt::PenStyle默认为实线类型。</li><li>使用示例如下：</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token comment">// 1、通过构造函数创建画笔pen01的属性</span>    QPen <span class="token function">pen01</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>red<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 2、通过子函数来单独设置pen02的属性</span>    QPen pen02<span class="token punctuation">;</span>    pen02<span class="token punctuation">.</span><span class="token function">setBrush</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pen02<span class="token punctuation">.</span><span class="token function">setWidth</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pen02<span class="token punctuation">.</span><span class="token function">setStyle</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DotLine<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）、<code>setPen(const QColor &amp;color)</code> ：只能设置画笔的颜色</p><ul><li>该函数只能设置画笔的颜色，包括透明度；不可以设置其它的属性</li><li>QColor(int r, int g, int b, int a = 255)在设置颜色的时候，可以通过构造函数来设置其对应的值，其中透明度值只能是0到255之间，不可以用0.0~1.0之间的值来代替</li><li>透明度默认值为 255，即不透明。</li><li>使用示例</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 直接通过画家设置其颜色和透明度，最后一个值255为透明度</span>    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（3）、<code>setPen(Qt::PenStyle style)</code> ：设置画笔的样式，如实线、虚线、点画线等样式</p><ul><li>只能设置画笔的样式，默认为实线，应用最少。</li></ul><p><strong>2、绘制圆弧类图形，如<code>drawArc</code>,<code>drawChord</code>,<code>drawPie</code></strong></p><p>（1）、绘制圆弧时，函数参数具体如下：</p><ul><li>指定的矩形、起始的角度和圆弧的跨度角。其中圆弧内切于指定的矩形；起始角度和圆弧跨度角必须为一个角度的 1 16 \frac{1}{16}161 ，如需要绘制的圆弧图形起始角度为 10 ° 10°10°，跨度角为 90 ° 90°90°，就需要指定对应的参数为：起始角度<code>startAngle = 10*16</code>，跨度角<code>spanAngle = 90*16</code>。因为该函数在绘制圆弧时会自动取给定角度参数的 1 16 \frac{1}{16}161 ，所以要将需要的角度值乘以 16，才能得到预定的结果。</li><li>起始角度 <code>0</code> 度位于3点钟方向，即X XX轴正方向的位置，如下图所示：<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70-16859635782832.png" alt="在这里插入图片描述"></li><li>角度值为正，则是逆时针；角度值为负，则是顺时针</li></ul><p>（2）、示例如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PaintEventTest</span><span class="token double-colon punctuation">::</span><span class="token function">paintEvent</span><span class="token punctuation">(</span>QPaintEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QPainter <span class="token function">painter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    QPen <span class="token function">pen01</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>red<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    QPen <span class="token function">pen02</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    QPen <span class="token function">pen03</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span>pen01<span class="token punctuation">)</span><span class="token punctuation">;</span>    painter<span class="token punctuation">.</span><span class="token function">drawArc</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span>pen02<span class="token punctuation">)</span><span class="token punctuation">;</span>    painter<span class="token punctuation">.</span><span class="token function">drawChord</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span>pen03<span class="token punctuation">)</span><span class="token punctuation">;</span>    painter<span class="token punctuation">.</span><span class="token function">drawPie</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">1160</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token number">1234567891011121314151617</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从左到右依次为<code>drawArc</code>,<code>drawChord</code>,<code>drawPie</code><br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70-16859635782833.png" alt="在这里插入图片描述"></p><p><strong>3、填充矩形区域 <code>fillRect</code></strong></p><p>(1)、应用分析</p><ul><li>用指定的颜色来填充矩形区域，且该矩形区域没有边线，此时可以通过画家<code>QPainter</code>来调用fillRect函数实现。</li><li>fillRect可以用指定的颜色或样式来对矩形区域进行填充，相当于画刷。</li></ul><p>(2)、示例</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PaintEventTest</span><span class="token double-colon punctuation">::</span><span class="token function">paintEvent</span><span class="token punctuation">(</span>QPaintEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QPainter <span class="token function">painter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 以指定颜色填充矩形</span>    painter<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 以指定样式填充矩形</span>    painter<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">700</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Qt<span class="token double-colon punctuation">::</span>DiagCrossPattern<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70-16859635782834.png" alt="在这里插入图片描述"></p><h3 id="三、基本应用-1"><a href="#三、基本应用-1" class="headerlink" title="三、基本应用"></a>三、基本应用</h3><h4 id="1、设置画笔样式-setPen-有三种方式"><a href="#1、设置画笔样式-setPen-有三种方式" class="headerlink" title="1、设置画笔样式 setPen 有三种方式"></a>1、设置画笔样式 setPen 有三种方式</h4><p>（1）、setPen(const QPen &amp;pen) ：直接设置画笔QPen的样式，该项可以同时设置画笔的众多属性，如：宽度、线条样式、颜色等，因此最为常用。</p><p>首先创建QPen的对象画笔，然后设置该画笔<br>在此可以通过构造函数或子函数来设置画笔的：样式、颜色(包括透明度)、线宽等属性。<br>然后画家通过 setPen 函数来将该画笔设置到对应的画家对象上。<br>Qt::PenStyle默认为实线类型。<br>使用示例如下：</p><pre class="line-numbers language-none"><code class="language-none">  &#x2F;&#x2F; 1、通过构造函数创建画笔pen01的属性    QPen pen01(Qt::red, 8);    &#x2F;&#x2F; 2、通过子函数来单独设置pen02的属性    QPen pen02;    pen02.setBrush(QColor(0, 200, 200, 100));    pen02.setWidth(10);    pen02.setStyle(Qt::DotLine);（2）、setPen(const QColor &amp;color) ：只能设置画笔的颜色<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        该函数只能设置画笔的颜色，包括透明度；不可以设置其它的属性<br>​        QColor(int r, int g, int b, int a = 255)在设置颜色的时候，可以通过构造函数来设置其对应的值，其中透明度值只能是0到255之间，不可以用0.0~1.0之间的值来代替,透明度默认值为 255，即不透明。<br>使用示例</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 直接通过画家设置其颜色和透明度，最后一个值255为透明度    painter.setPen(QColor(200,0,0,255));（3）、setPen(Qt::PenStyle style) ：设置画笔的样式，如实线、虚线、点画线等样式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>只能设置画笔的样式，默认为实线，应用最少。<br>2、绘制圆弧类图形，如drawArc,drawChord,drawPie</p><p>（1）、绘制圆弧时，函数参数具体如下：</p><p>​        指定的矩形、起始的角度和圆弧的跨度角。其中圆弧内切于指定的矩形；起始角度和圆弧跨度角必须为一个角度的 $ \frac{1}{16} $，如需要绘制的圆弧图形起始角度为 10 ° ，跨度角为 90 °，就需要指定对应的参数为：起始角度startAngle = 10*16，跨度角spanAngle = 90*16。因为该函数在绘制圆弧时会自动取给定角度参数的$\frac{1}{16}$  ，所以要将需要的角度值乘以 16，才能得到预定的结果。<br>​        起始角度 0 度位于3点钟方向，即X XX轴正方向的位置，如下图所示：</p><p>​        角度值为正，则是逆时针；角度值为负，则是顺时针<br>（2）、示例如下：</p><pre class="line-numbers language-none"><code class="language-none">void PaintEventTest::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);    QPen pen01(Qt::red, 8);    QPen pen02(QColor(0, 200, 200), 6);    QPen pen03(QColor(0, 0, 255, 200), 7);        painter.setPen(pen01);    painter.drawArc(QRect(10, 10, 500, 500), 0, 260 * 16);        painter.setPen(pen02);    painter.drawChord(QRect(600, 10, 500, 500), 0, 260 * 16);        painter.setPen(pen03);    painter.drawPie(QRect(1160, 10, 500, 500), 0, 260 * 16);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        从左到右依次为drawArc,drawChord,drawPie</p><p>3、填充矩形区域 fillRect</p><p>(1)、应用分析</p><p>用指定的颜色来填充矩形区域，且该矩形区域没有边线，此时可以通过画家QPainter来调用fillRect函数实现。<br>fillRect可以用指定的颜色或样式来对矩形区域进行填充，相当于画刷。<br>(2)、示例</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PaintEventTest::paintEvent(QPaintEvent *event)&#123;    QPainter painter(this);    &#x2F;&#x2F; 以指定颜色填充矩形    painter.fillRect(QRect(50, 50, 600, 300), QColor(0, 200, 250, 200));    &#x2F;&#x2F; 以指定样式填充矩形    painter.fillRect(QRect(700, 50, 600, 300), Qt::DiagCrossPattern);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>QRect类使用整数精度在平面上定义了一个矩形。</p><blockquote><p>Header:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;QRect></span></span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>CMake:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">find_package</span><span class="token punctuation">(</span>Qt6 COMPONENTS Core REQUIRED<span class="token punctuation">)</span><span class="token function">target_link_libraries</span><span class="token punctuation">(</span>mytarget PRIVATE Qt6<span class="token double-colon punctuation">::</span>Core<span class="token punctuation">)</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>qmake:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QT <span class="token operator">+=</span> core<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p>注意:这个类中的所有函数都是可重入的。</p><h2 id="Qrect详细说明"><a href="#Qrect详细说明" class="headerlink" title="Qrect详细说明"></a>Qrect详细说明</h2><p>​        矩形通常表示为左上角和大小。QRect的大小(宽度和高度)总是等价于数学矩形(构成其呈现的基础)。</p><p>​        QRect可以用一组左、顶、宽和高整数来构造，也可以用QPoint和QSize来构造。下面的代码创建了两个相同的矩形。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QRect <span class="token function">r1</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>QRect <span class="token function">r2</span><span class="token punctuation">(</span><span class="token function">QPoint</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">QSize</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        还有第三个构造函数使用左上角和右下角坐标创建QRect，但是我们建议您避免使用它。其基本原理是由于历史原因，由bottom()和right()函数返回的值偏离了矩形真正的右下角。</p><p>​        QRect类提供了一组函数，它们返回各种矩形坐标，并支持对它们进行操作。QRect还提供了相对于各种坐标移动矩形的函数。此外，还有一个moveTo()函数可以移动矩形，使其左上角保持在给定的坐标位置。或者，translate()函数将矩形移动到给定的相对于当前位置的偏移量，然后translate()函数返回该矩形的已翻译副本</p><p>​        size() 函数的作用是:返回矩形的尺寸为QSize。尺寸也可以使用width()和height()函数单独检索。使用setSize()、setWidth()或setHeight()函数来操作维度。或者，可以通过应用设置矩形坐标的函数来更改大小，例如setBottom()或setRight()。</p><p>​        contains()函数的作用是:告知给定的点是否在矩形内;如果矩形与给定的矩形相交，则intersects()函数返回true。QRect类还提供了intersected()函数，它返回相交的矩形，以及united()函数，它返回包含给定矩形的矩形，并如下所示:</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poaXpoZW5nZ3Vhbg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"><br>        如果left() &gt; right()或top() &gt; bottom()，则isEmpty()函数返回true。请注意，空矩形是无效的:如果left() &lt;= right()和top() &lt;= bottom()，则isValid()函数返回true。另一方面，一个空矩形(isNull() == true)的宽度和高度都设置为0。</p><p>​        注意，由于QRect和QRectF的定义方式，空QRect的定义基本上与QRectF相同。</p><p>​        最后，可以对QRect对象进行流化和比较。</p><h2 id="呈现"><a href="#呈现" class="headerlink" title="呈现"></a>呈现</h2><p>​        当使用反锯齿绘制器时，QRect的边界线将在数学矩形边界线的两侧对称地绘制。但是当使用别名绘制器(默认)时，应用其他规则。</p><p>​        然后，当使用一个像素宽的笔进行渲染时，QRect的边界线将被渲染到数学矩形边界线的右边和下面。</p><p>​        当使用两个像素宽的笔进行渲染时，边界线将被数学矩形从中间分割。当画笔被设置为偶数像素时，当画笔被设置为奇数像素时，备用像素将被渲染到数学矩形的右边和下面，就像在一个像素的情况下一样。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poaXpoZW5nZ3Vhbg==,size_16,color_FFFFFF,t_70-16859636729591.png" alt="在这里插入图片描述"></p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>​        QRect类提供了一组函数，它们返回各种矩形坐标，并支持对它们进行操作。QRect还提供了相对于各种坐标移动矩形的函数。</p><p>​        以left()， setLeft()和moveLeft()函数为例:左()返回矩形的坐标的左边缘,setLeft()矩形的左边缘设置为给定的x坐标(它可能改变宽度,但永远不会改变矩形的右边缘)和moveLeft()整个矩形水平移动,离开矩形的左边缘在给定的x坐标和其大小不变。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poaXpoZW5nZ3Vhbg==,size_16,color_FFFFFF,t_70-16859636729592.png" alt="在这里插入图片描述"><br>​        请注意，由于历史原因，由bottom()和right()函数返回的值偏离了矩形真正的右下角:right()函数返回left() + width() - 1, bottom()函数返回top() + height() - 1。由bottomRight()函数返回的point也是同样的情况。另外，topRight()函数和bottomLeft()函数的x坐标和y坐标与右真边和底边的偏差是相同的。</p><p>​        我们建议使用x() + width()和y() + height()来找到真正的右下角，避免使用right()和bottom()。另一种解决方案是使用QRectF: QRectF类使用浮点精度在坐标上定义平面中的矩形，QRectF::right()和QRectF::bottom()函数确实返回右坐标和底坐标。</p><p>​        还可以使用adjust()函数向这个矩形的坐标添加偏移量，也可以使用adjusted()函数根据对原矩形的调整获取新的矩形。如果宽度和高度是负的，使用normalized()函数来获取一个边角被交换的矩形。</p><p>​        此外，QRect提供了getCoords()函数，它提取矩形的左上角和右下角的位置，以及getRect()函数，它提取矩形的左上角、宽度和高度。使用setCoords()和setRect()函数一次性操作矩形的坐标和尺寸。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>​        QRect被限制为int类型的最小值和最大值。QRect上的操作可能会导致值超出这个范围，这将导致未定义的行为。</p><p>参见QRectF和QRegion。</p><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="QRect"><a href="#QRect" class="headerlink" title="QRect"></a>QRect</h4><blockquote><p><strong>QRect::QRect(int x, int y, int width, int height)</strong></p></blockquote><p>构造一个以(x, y)为左上角、给定宽度和高度的矩形。</p><p>参见setRect()</p><blockquote><p><strong>QRect::QRect(const QPoint &amp;topLeft, const QSize &amp;size)</strong></p></blockquote><p>构造具有给定顶角和给定大小的矩形。</p><p>参见setTopLeft()和setSize()。</p><blockquote><p><strong>QRect::QRect(const QPoint &amp;topLeft, const QPoint &amp;bottomRight)</strong></p></blockquote><p>构造一个矩形，包含给定的顶角和右下角。</p><p>如果右下角比顶部更高且在顶部的左边，则定义的矩形将不包含角。</p><p>注意:为了确保这两个点都被包含，而不考虑相对顺序，请使用span()。</p><p>参见setTopLeft()、setBottomRight()和span()。</p><blockquote><p><strong>QRect::QRect()</strong></p></blockquote><p>构造一个空矩形。</p><p>参见isNull()。</p><h2 id="QPoint类"><a href="#QPoint类" class="headerlink" title="QPoint类"></a>QPoint类</h2><p>QPoint类定义了平面上的一个点。 详情请见……</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;qpoint.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所有成员函数的列表。</p><h2 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h2><ul><li><strong>QPoint</strong> ()</li><li><strong>QPoint</strong> ( intxpos, intypos )</li><li>bool <strong>isNull</strong> () const</li><li>int <strong>x</strong> () const</li><li>int <strong>y</strong> () const</li><li>void <strong>setX</strong> ( intx )</li><li>void <strong>setY</strong> ( inty )</li><li>int <strong>manhattanLength</strong> () const</li><li>QCOORD &amp; <strong>rx</strong> ()</li><li>QCOORD &amp; <strong>ry</strong> ()</li><li>QPoint &amp; <strong>operator+=</strong> ( constQPoint&amp;p )</li><li>QPoint &amp; <strong>operator-=</strong> ( constQPoint&amp;p )</li><li>QPoint &amp; <strong>operator*=</strong> ( intc )</li><li>QPoint &amp; <strong>operator*=</strong> ( doublec )</li><li>QPoint &amp; <strong>operator/=</strong> ( intc )</li><li>QPoint &amp; <strong>operator/=</strong> ( doublec )</li></ul><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><ul><li>bool <strong>operator==</strong> ( constQPoint&amp;p1, constQPoint&amp;p2 )</li><li>bool <strong>operator!=</strong> ( constQPoint&amp;p1, constQPoint&amp;p2 )</li><li>const QPoint <strong>operator+</strong> ( constQPoint&amp;p1, constQPoint&amp;p2 )</li><li>const QPoint <strong>operator-</strong> ( constQPoint&amp;p1, constQPoint&amp;p2 )</li><li>const QPoint <strong>operator*</strong> ( constQPoint&amp;p, intc )</li><li>const QPoint <strong>operator*</strong> ( intc, constQPoint&amp;p )</li><li>const QPoint <strong>operator*</strong> ( constQPoint&amp;p, doublec )</li><li>const QPoint <strong>operator*</strong> ( doublec, constQPoint&amp;p )</li><li>const QPoint <strong>operator-</strong> ( constQPoint&amp;p )</li><li>const QPoint <strong>operator/</strong> ( constQPoint&amp;p, intc )</li><li>const QPoint <strong>operator/</strong> ( constQPoint&amp;p, doublec )</li><li>QDataStream &amp; <strong>operator&lt;&lt;</strong> ( QDataStream&amp;s, constQPoint&amp;p )</li><li>QDataStream &amp; <strong>operator&gt;&gt;</strong> ( QDataStream&amp;s, QPoint&amp;p )</li></ul><hr><h2 id="QPoint详细描述"><a href="#QPoint详细描述" class="headerlink" title="QPoint详细描述"></a>QPoint详细描述</h2><p>​        QPoint类定义了平面上的一个点。</p><p>​        一个点由一个x坐标和一个y坐标确定。</p><p>​        坐标类型是<code>QCOORD</code>（一个32位整数）。<code>QCOORD</code>的最小值是<code>QCOORD_MIN</code>（-2147483648），最大值是<code>QCOORD_MAX</code>（2147483647）。</p><p>​        坐标可以通过函数x()和y()来访问，它们可以由setX()和setY()来设置并且由rx()由ry()来参考。</p><p>​        假设一个点<em>p</em>，下面的语句都是等价的：</p><pre class="line-numbers language-none"><code class="language-none">p.setX( p.x() + 1 );p +&#x3D; QPoint( 1, 0 );p.rx()++;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        一个QPoint也可以用作是一个矢量。QPoint的加法和减法也像矢量一样定义了（每个分量分别的被相加或者相减）。你可以把一个QPoint与一个<code>int</code>或者一个<code>double</code>做乘法或者除法。函数manhattanLength()像对矢量那样给出了QPoint一个比较廉价的长度接近值的说明。</p><p>Example:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;QPoint oldPos在其它什么地方定义过了MyWidget::mouseMoveEvent( QMouseEvent *e )&#123;    QPoint vector &#x3D; e-&gt;pos() - oldPos;    if ( vector.manhattanLength() &gt; 3 )... &#x2F;&#x2F;鼠标从oldPos移动超过3个象素&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        QPoint可以进行比较得出相等或者不等，并且它们可以写到QStream或者从QStream中读出。</p><p>​        也可以参考QPointArray、QSize、QRect、图形类和图像处理类。</p><h2 id="成员函数文档"><a href="#成员函数文档" class="headerlink" title="成员函数文档"></a>成员函数文档</h2><pre class="line-numbers language-none"><code class="language-none">QPoint::QPoint ()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造一个坐标为(0,0)的点（isNull()返回真）。</p><pre class="line-numbers language-none"><code class="language-none">QPoint::QPoint ( intxpos, intypos )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造一个x值为<em>xpos</em>，y值为<em>ypos</em>的点。</p><pre class="line-numbers language-none"><code class="language-none">bool QPoint::isNull () const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果x值和y值都是0的话，返回真，否则返回假。</p><pre class="line-numbers language-none"><code class="language-none">int QPoint::manhattanLength () const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回x()和y()的绝对值得和，就是传统上的从原点开始的矢量的“曼哈顿长度”。这个传统的出现是因为这样的距离适用于在矩形方格上旅行的履行者们，就像曼哈顿的街道一样。</p><p>这个很有用的，并且运算很快，和真实长度sqrt(pow(x(),2)+pow(y(),2))很接近。</p><pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator*&#x3D; ( intc )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用<em>c</em>与这个点的x和y做乘法，并且返回这个点的引用。</p><p>实例：</p><pre class="line-numbers language-none"><code class="language-none">QPoint p( -1, 4 );p *&#x3D; 2;            &#x2F;&#x2F; p变成了(-2,8)   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator*&#x3D; ( doublec )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p><p>用<em>c</em>与这个点的x和y做乘法，并且返回这个点的引用。</p><p>实例：</p><pre class="line-numbers language-none"><code class="language-none">QPoint p( -1, 4 );p *&#x3D; 2.5;          &#x2F;&#x2F; p变成了(-3,10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意这个结果被取整了，因为点是用整数保存的。</p><pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator+&#x3D; ( constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把点<em>p</em>加到这个点上，并且返回这个点的引用。</p><p>实例：</p><pre class="line-numbers language-none"><code class="language-none">QPoint p(  3, 7 );QPoint q( -1, 4 );p +&#x3D; q;            &#x2F;&#x2F; p变成了(2,11)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator-&#x3D; ( constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        从这个点上减去点<em>p</em>，并且返回这个点的引用。</p><p>实例：</p><pre class="line-numbers language-none"><code class="language-none">QPoint p(  3, 7 );QPoint q( -1, 4 );p -&#x3D; q;            &#x2F;&#x2F; p变成了(4,3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator&#x2F;&#x3D; ( intc )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        x和y都除以<em>c</em>，并且返回这个点的引用。</p><p>​        实例：</p><pre class="line-numbers language-none"><code class="language-none">QPoint p( -2, 8 );p &#x2F;&#x3D; 2;            &#x2F;&#x2F; p变成了(-1,4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator&#x2F;&#x3D; ( doublec )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p><p>x和y都除以<em>c</em>，并且返回这个点的引用。</p><p>实例：</p><pre class="line-numbers language-none"><code class="language-none">QPoint p( -3, 10 );p &#x2F;&#x3D; 2.5;           &#x2F;&#x2F; p变成了(-1,4)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意这个结果被取整了，因为点是用整数保存的。</p><pre class="line-numbers language-none"><code class="language-none">QCOORD &amp; QPoint::rx ()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        返回这个点的x坐标的引用。</p><p>​        使用这个引用可以直接操作x。</p><p>​        实例：</p><pre class="line-numbers language-none"><code class="language-none">QPoint p( 1, 2 );p.rx()--;         &#x2F;&#x2F; p变成了(0, 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        也可以参考ry()。</p><pre class="line-numbers language-none"><code class="language-none">QCOORD &amp; QPoint::ry ()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        返回这个点的y坐标的引用。</p><p>​        使用这个引用可以直接操作y。</p><p>实例：</p><pre class="line-numbers language-none"><code class="language-none">QPoint p( 1, 2 );p.ry()++;         &#x2F;&#x2F; p变成了(1, 3)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以参考rx()。</p><pre class="line-numbers language-none"><code class="language-none">void QPoint::setX ( intx )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置这个点的x坐标为<em>x</em>。</p><pre class="line-numbers language-none"><code class="language-none">void QPoint::setY ( inty )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置这个点的y坐标为<em>y</em>。</p><pre class="line-numbers language-none"><code class="language-none">int QPoint::x () const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回这个点的x坐标。</p><pre class="line-numbers language-none"><code class="language-none">int QPoint::y () const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回这个点的y坐标。</p><p>也可以参考setY()和x()。</p><h2 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h2><pre class="line-numbers language-none"><code class="language-none">bool operator!&#x3D; ( constQPoint&amp;p1, constQPoint&amp;p2 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果<em>p1</em>和<em>p2</em>相等，返回真，否则返回假。</p><pre class="line-numbers language-none"><code class="language-none">constQPoint operator* ( constQPoint&amp;p, intc )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        返回由<em>p</em>的分量和<em>c</em>相乘构成的QPoint。</p><pre class="line-numbers language-none"><code class="language-none">constQPoint operator* ( intc, constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p><p>​        返回由<em>p</em>的分量和<em>c</em>相乘构成的QPoint。</p><pre class="line-numbers language-none"><code class="language-none">constQPoint operator* ( constQPoint&amp;p, doublec )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p><p>​        返回由<em>p</em>的分量和<em>c</em>相乘构成的QPoint。</p><p>​        注意这个结果被取整了，因为点是用整数保存的。</p><pre class="line-numbers language-none"><code class="language-none">constQPoint operator* ( doublec, constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p><p>​        返回由<em>p</em>的分量和<em>c</em>相乘构成的QPoint。</p><p>​        注意这个结果被取整了，因为点是用整数保存的。</p><pre class="line-numbers language-none"><code class="language-none">constQPoint operator+ ( constQPoint&amp;p1, constQPoint&amp;p2 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        返回<em>p1</em>和<em>p2</em>的和，每个分量都分别相加。</p><pre class="line-numbers language-none"><code class="language-none">constQPoint operator- ( constQPoint&amp;p1, constQPoint&amp;p2 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        返回<em>p1</em>减去<em>p2</em>得到的结果，每个分量都分别相减。</p><pre class="line-numbers language-none"><code class="language-none">constQPoint operator- ( constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p><p>​        返回<em>p</em>每个分量都变号后构成的QPoint，和<code>QPoint(0,0) - p</code>是一样的。</p><pre class="line-numbers language-none"><code class="language-none">constQPoint operator&#x2F; ( constQPoint&amp;p, intc )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        返回<em>p</em>每个分量除以<em>c</em>后构成的QPoint。</p><pre class="line-numbers language-none"><code class="language-none">constQPoint operator&#x2F; ( constQPoint&amp;p, doublec )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p><p>​        返回<em>p</em>每个分量除以<em>c</em>后构成的QPoint。</p><p>​        注意这个结果被取整了，因为点是用整数保存的。</p><pre class="line-numbers language-none"><code class="language-none">QDataStream&amp; operator&lt;&lt; ( QDataStream&amp;s, constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        把点<em>p</em>写到流<em>s</em>中并且返回流的引用。</p><p>​        也可以参考QDataStream操作符的格式。</p><pre class="line-numbers language-none"><code class="language-none">bool operator&#x3D;&#x3D; ( constQPoint&amp;p1, constQPoint&amp;p2 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果<em>p1</em>和<em>p2</em>相等，返回真，否则返回假。</p><pre class="line-numbers language-none"><code class="language-none">QDataStream&amp; operator&gt;&gt; ( QDataStream&amp;s, QPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        从流<em>s</em>中读取一个QPoint到点<em>p</em>并且返回这个流的引用。</p><h2 id="QPen"><a href="#QPen" class="headerlink" title="QPen"></a>QPen</h2><p>​        QPen 类定义了QPainter 应该怎样画线条和形状的轮廓。 </p><p>​        对于QPen 画笔有以下几个重要特性。</p><p>​        <code>1.color(): 定义了线条的颜色。使用setColor(QColor(255, 0, 0, 100))定义画笔的颜色。</code></p><p>​        <code>2.width():定义了线条的宽度。使用setWidth(int width)设置线条的宽度。</code></p><p>​        这里有个特殊情况，要说明一下，按照我们的理解，如果setWidth（0）的话，应该是线条宽度为0，应该是不显示线条啊。可是实际不是这样，当设置为线条宽度为0的时候，相当于使用了sosmetic（美化笔，自己翻译的，可能不对），意味着画笔的宽度一直是1像素宽。</p><p>​        如果我们想不显示线条的话，怎么办？有两种方式：</p><pre><code>1&gt; setStyle(Qt::NoPen)2&gt; setWidth(-1)</code></pre><p>​        这两种方式效果是一样的，都是不显示轮廓。</p><p>​        <code>3.style() : 定义了线条的类型，使用setStyle()设置画笔线条的类型。</code></p><p>​        具体线条的类型和形状 有Qt::solidLine, 虚线Qt::dotLine, Qt::dashLine具体如下</p><p>Pen Style</p><p>​        Qt provides several built-in styles represented by the Qt::PenStyle enum:</p><div class="table-container"><table><thead><tr><th>1<img src="70.png" alt="img"></th><th>2<img src="70-168596436330319.png" alt="img"></th><th>3<img src="70-168596436857522.png" alt="img"></th></tr></thead><tbody><tr><td>Qt::SolidLine</td><td>Qt::DashLine</td><td>Qt::DotLine</td></tr><tr><td>4<img src="70-168596437885725.png" alt="img"></td><td>5<img src="70-168596438197928.png" alt="img"></td><td>6<img src="70-168596438461531.png" alt="img"></td></tr><tr><td>Qt::DashDotLine</td><td>Qt::DashDotDotLine</td><td>Qt::CustomDashLine</td></tr></tbody></table></div><p>​        如果style设置为Qt::dashLine时候，我们怎样可以设置实线与空线（space）的比例呢？或者换种说法，我们怎样可以设置dashLine 两段实线相隔多远呢？ 幸好，我们有种方法 setDashPattern();来控制dashLine这种线条实线与虚线的比例。具体用法如下</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">pen.setDashPattern(QVector&lt;qreal&gt;() &lt;&lt; 10 &lt;&lt; 5 )&#x2F;&#x2F;实线：空线的比例为10 ：5 。每10个单位长度的实线，然后每5个单位长度的虚线。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <code>4.capStyle() :设置线条两头的形状，可以是矩形，也可以是圆形的头。通过setCapStyle()设置线条端点形状。</code></p><p>​         有以下选择和相关形状。enum Qt::PenCapStyle</p><div class="table-container"><table><thead><tr><th>1<img src="70-168596451184534.png" alt="img"></th><th>2<img src="70-168596451968937.png" alt="img"></th><th>3<img src="70-168596452229740.png" alt="img"></th></tr></thead><tbody><tr><td>Qt::SquareCap</td><td>Qt::FlatCap</td><td>Qt::RoundCap</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Constant</th><th>Description</th></tr></thead><tbody><tr><td>Qt::FlatCap</td><td>a square line end that does not cover the end point of the line.//方形头部，但是并不包含最后一个点</td></tr><tr><td>Qt::SquareCap</td><td>a square line end that covers the end point and extends beyond it by half the line width.//方形顶端，并且包含最后一个点</td></tr><tr><td>Qt::RoundCap</td><td>a rounded line end. //顶端是半圆形</td></tr></tbody></table></div><p><code>5.joinStyle() 是两条线的连接点的类型。可以通过setJoinStyle（）来设置两条线之间的连接点形状。</code></p><h4 id="enum-Qt-PenJoinStyle"><a href="#enum-Qt-PenJoinStyle" class="headerlink" title="enum Qt::PenJoinStyle"></a>enum Qt::PenJoinStyle</h4><div class="table-container"><table><thead><tr><th>1<img src="70-168596471419343.png" alt="img"></th><th>2<img src="70-168596471874246.png" alt="img"></th><th>3<img src="70-168596472194249.png" alt="img"></th></tr></thead><tbody><tr><td>Qt::BevelJoin</td><td>Qt::MiterJoin</td><td>Qt::RoundJoin</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Constant</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>Qt::MiterJoin</td><td>0x00</td><td>线的外缘延伸成一个角度，这个区域被填充。</td></tr><tr><td>Qt::BevelJoin</td><td>0x40</td><td>两条线之间的三角形缺口填满了。</td></tr><tr><td>Qt::RoundJoin</td><td>0x80</td><td>两条线之间有弧度，就是很圆滑</td></tr><tr><td>Qt::SvgMiterJoin</td><td>0x100</td><td>一个斜角连接对应一个斜切的定义加入SVG 1.2小规格。</td></tr></tbody></table></div><h2 id="文件读写QFile"><a href="#文件读写QFile" class="headerlink" title="文件读写QFile"></a>文件读写QFile</h2><p>​        <img src="image-20230608151236146.png" alt="image-20230608151236146"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QFileDialog&gt;#include&lt;QFile&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[&#x3D;]()&#123;        QString Path &#x3D; QFileDialog::getOpenFileName(this,&quot;打开文件&quot;,&quot;D:\\QT projects\\untitled\\1.txt&quot;);        ui-&gt;lineEdit-&gt;setText(Path);        QFile file(Path);        file.open(QIODevice::ReadOnly);        QByteArray array &#x3D; file.readAll();        ui-&gt;textEdit-&gt;setText(QString(array));    &#125;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        完成读写！</p><p>​        也可以用：<code>QFileInfo</code>获取信息：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">QFileInfo info(Path);qDebug() &lt;&lt; &quot;大小：&quot;&lt;&lt;info.size() &lt;&lt; &quot;后缀：&quot;&lt;&lt;info.suffix();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        完结撒花！</p><h3 id="Extensive-Reading-1"><a href="#Extensive-Reading-1" class="headerlink" title="Extensive Reading"></a>Extensive Reading</h3><p><a href="http://c.biancheng.net/view/9430.html">Qt QFile文件操作详解 (biancheng.net)</a></p><h3 id="QFile文件操作"><a href="#QFile文件操作" class="headerlink" title="QFile文件操作"></a>QFile文件操作</h3><p>​        QFile 类支持对文件进行读取、写入、删除、重命名、拷贝等操作，它既可以操作文件文件，也可以操作二进制文件。</p><p>​        使用 QFile 类操作文件之前，程序中需引入<code>&lt;QFile&gt;</code>头文件。创建 QFile 类的对象，常用的构造函数有：</p><pre class="line-numbers language-none"><code class="language-none">QFile::QFile()QFile::QFile(const QString &amp;name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        参数 name 用来指定要操作的目标文件，包含文件的存储路径和文件名，存储路径可以使用绝对路径（比如 “D:/Demo/test.txt”）或者相对路径（比如”./Demo/test.txt”），路径中的分隔符要用 “/“ 表示。</p><p>​        通常情况下，我们会调用第二个构造函数，直接指明要操作的文件。对于第一个构造函数创建的 QFile 对象，需要再调用 setFileName() 方法指明要操作的文件。</p><p>​        与 C++ 读写文件的规则一样，使用 QFile 读写文件之前必须先打开文件，调用 open() 成员方法即可，常用的语法格式为：</p><pre class="line-numbers language-none"><code class="language-none">bool QFile::open(OpenMode mode)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        mode 参数用来指定文件的打开方式，下表罗列了此参数的可选值以及各自的含义：</p><div class="table-container"><table><thead><tr><th>打开方式</th><th>含 义</th></tr></thead><tbody><tr><td>QIODevice::ReadOnly</td><td>只能对文件进行读操作</td></tr><tr><td>QIODevice::WriteOnly</td><td>只能对文件进行写操作，如果目标文件不存在，会自行创建一个新文件。</td></tr><tr><td>QIODevice::ReadWrite</td><td>等价于 ReadOnly \</td><td>WriteOnly，能对文件进行读和写操作。</td></tr><tr><td>QIODevice::Append</td><td>以追加模式打开文件，写入的数据会追加到文件的末尾（文件原有的内容保留）。</td></tr><tr><td>QIODevice::Truncate</td><td>以重写模式打开，写入的数据会将原有数据全部清除。注意，此打开方式不能单独使用，通常会和 ReadOnly 或 WriteOnly 搭配。</td></tr><tr><td>QIODevice::Text</td><td>读取文件时，会将行尾结束符（Unix 系统中是 “\n”，Windows 系统中是 “\r\n”）转换成‘\n’；将数据写入文件时，会将行尾结束符转换成本地格式，例如 Win32 平台上是‘\r\n’。</td></tr></tbody></table></div><p>​        根据需要，可以为 mode 参数一次性指定多个值，值和值之间用<code>|</code>分割。比如：</p><ul><li>QIODevice::ReadOnly | QIODevice::Text：表示只允许对文件进行读操作，读取文件时，会将行尾结束符转换为 ‘\n’；</li><li>QIODevice::WriteOnly | QIODevice::Text：表示只允许对文件进行写操作，将数据写入文件时，会将行尾结束符转换为本地格式；</li><li>QIODevice::ReadWrite | QIODevice::Append | QIODevice::Text：表示对文件进行写操作，写入的数据会存放到文件的尾部，同时数据中的行尾结束符转换为本地格式。</li></ul><blockquote><p>注意，传递给 mode 参数的多个值之间不能相互冲突，比如 Append 和 Truncate 不能同时使用。</p></blockquote><p>​        如果文件成功打开，open() 函数返回 true，否则返回 false。</p><p>​        QFile 类提供了很多功能实用的方法，可以快速完成对文件的操作，下表列举了常用的一些：</p><div class="table-container"><table><thead><tr><th>普通成员方法</th><th>功 能</th></tr></thead><tbody><tr><td>qint64 QFile::size() const</td><td>获取当前文件的大小。对于打开的文件，该方法返回文件中可以读取的字节数。</td></tr><tr><td>bool QIODevice::getChar(char *c)</td><td>从文件中读取一个字符，并存储到 c 中。读取成功时，方法返回 true，否则返回 false。</td></tr><tr><td>bool QIODevice::putChar(char c)</td><td>向文件中写入字符 c，成功时返回 true，否则返回 false。</td></tr><tr><td>QByteArray QIODevice::read(qint64 maxSize)</td><td>从文件中一次性最多读取 maxSize 个字节，然后返回读取到的字节。</td></tr><tr><td>qint64 QIODevice::read(char *data, qint64 maxSize)</td><td>从文件中一次性对多读取 maxSize 个字节，读取到的字节存储到 data 指针指定的内存控件中。该方法返回成功读取到的字节数。</td></tr><tr><td>QByteArray QIODevice::readAll()</td><td>读取文件中所有的数据。</td></tr><tr><td>qint64 QIODevice::readLine(char *data, qint64 maxSize)</td><td>每次从文件中读取一行数据或者读取最多 maxSize-1 个字节，存储到 data 中。该方法返回实际读取到的字节数。</td></tr><tr><td>qint64 QIODevice::write(const char *data, qint64 maxSize)</td><td>向 data 数据一次性最多写入 maxSize 个字节，该方法返回实际写入的字节数。</td></tr><tr><td>qint64 QIODevice::write(const char *data)</td><td>将 data 数据写入文件，该方法返回实际写入的字节数。</td></tr><tr><td>qint64 QIODevice::write(const QByteArray &amp;byteArray)</td><td>将 byteArray 数组中存储的字节写入文件，返回实际写入的字节数。</td></tr><tr><td>bool QFile::copy(const QString &amp;newName)</td><td>将当前文件的内容拷贝到名为 newName 的文件中，如果成功，方法返回 true，否则返回 false。  copy 方法在执行复制操作之前，会关闭源文件。</td></tr><tr><td>bool QFile::rename(const QString &amp;newName)</td><td>对当前文件进行重命名，新名称为 newName，成功返回 true，失败返回 false。</td></tr><tr><td>bool QFile::remove()</td><td>删除当前文件，成功返回 true，失败返回 false。</td></tr></tbody></table></div><p>【实例一】演示了 QFile 类读写文本文件的过程。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QFile&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123;    &#x2F;&#x2F;创建 QFile 对象，同时指定要操作的文件   QFile file(&quot;D:&#x2F;demo.txt&quot;);    &#x2F;&#x2F;对文件进行写操作    if(!file.open(QIODevice::WriteOnly|QIODevice::Text))&#123;        qDebug()&lt;&lt;&quot;文件打开失败&quot;;       &#125;        &#x2F;&#x2F;向文件中写入两行字符串        file.write(&quot;C语言中文网\n&quot;);        file.write(&quot;http:&#x2F;&#x2F;c.biancheng.net&quot;);        &#x2F;&#x2F;关闭文件       file.close();            &#x2F;&#x2F;重新打开文件，对文件进行读操作        if(!file.open(QIODevice::ReadOnly|QIODevice::Text))&#123;           qDebug()&lt;&lt;&quot;文件打开失败&quot;;        &#125;        &#x2F;&#x2F;每次都去文件中的一行，然后输出读取到的字符串        char * str &#x3D; new char[100];        qint64 readNum &#x3D; file.readLine(str,100);        &#x2F;&#x2F;当读取出现错误（返回 -1）或者读取到的字符数为 0 时，结束读取    while((readNum !&#x3D;0) &amp;&amp; (readNum !&#x3D; -1))&#123;               qDebug() &lt;&lt; str;                readNum &#x3D; file.readLine(str,100);        &#125;        file.close();        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        执行程序，”C语言中文网” 和 “<a href="http://c.biancheng.net">http://c.biancheng.net</a>“ 先写入 D 盘的 demo.txt 文件，然后再从文件中将它们读取出来。</p><p>【实例二】演示 QFile 读写二进制文件的过程。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QFile&gt;#include &lt;QDebug&gt;int main(int argc, char *argv[])&#123;        &#x2F;&#x2F;指定要写入文件的数据        qint32 nums[5]&#x3D;&#123;1,2,3,4,5&#125;;       &#x2F;&#x2F;写入文件之前，要将数据以二进制方式存储到字节数组中       QByteArray byteArr;        byteArr.resize(sizeof(nums));        for(int i&#x3D;0;i&lt;5;i++)&#123;                &#x2F;&#x2F;借助指针，将每个整数拷贝到字节数组中                memcpy(byteArr.data()+i*sizeof(qint32),&amp;(nums[i]),sizeof(qint32));    &#125;        &#x2F;&#x2F;将 byteArr 字节数组存储到文件中        QFile file(&quot;D:&#x2F;demo.dat&quot;);        file.open(QIODevice::WriteOnly);        file.write(byteArr);        file.close();        &#x2F;&#x2F;再次打开文件，读取文件中存储的二进制数据        file.open(QIODevice::ReadOnly);        QByteArray resArr &#x3D; file.readAll();        &#x2F;&#x2F;输出读取到的二进制数据        qDebug()&lt;&lt;&quot;resArr: &quot;&lt;&lt;resArr;        &#x2F;&#x2F;将二进制数据转化为整数        char* data &#x3D; resArr.data();       while(*data)&#123;                qDebug() &lt;&lt; *(qint32*)data;                data +&#x3D; sizeof(qint32);        &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        执行程序，demo.dat 文件中会存储 {1,2,3,4,5} 这 5 个整数的二进制形式，同时输出以下内容：</p><pre class="line-numbers language-none"><code class="language-none">resArr: &quot;\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00&quot;12345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        单独使用 QFile 类读写文件的过程既繁琐又复杂，Qt 提供了两个辅助类 QTextStream 和 QDataStream，前者用来读写文件文件，后者用来读写二进制文件，QFile 可以和它们搭配使用，从整体上提高读写文件的开发效率。</p><h4 id="QFile-QTextStream"><a href="#QFile-QTextStream" class="headerlink" title="QFile+QTextStream"></a>QFile+QTextStream</h4><p>​        和单独使用 QFile 类读写文本文件相比，QTextStream 类提供了很多读写文件相关的方法，还可以设定写入到文件中的数据格式，比如对齐方式、写入数字是否带前缀等等。</p><p>​        使用 QTextStream 类之前，程序中要先引入<code>&lt;QTextStream&gt;</code>头文件。QTextStream 类提供了很多种构造函数，常用的是：</p><pre class="line-numbers language-none"><code class="language-none">QTextStream(QIODevice *device)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        QIODevice 是 QFile 的父类，因此在构造 QTextStream 类的对象时，需要传递一个 QFile 类的对象。</p><p>下表罗列了 QTextStream 类常用的一些方法：</p><div class="table-container"><table><thead><tr><th>成员方法</th><th>功 能</th></tr></thead><tbody><tr><td>bool QTextStream::atEnd() const</td><td>判断是否读到文件末尾，如果已经达到末尾，返回 true，否则返回 false。</td></tr><tr><td>QString QTextStream::read(qint64 maxlen)</td><td>从文件中读最多 maxlen 个字符，返回这些字符组成的 QString 字符串。</td></tr><tr><td>QString QTextStream::readAll()</td><td>从文件中读取所有内容，返回由读取内容组成的 QString 字符串。</td></tr><tr><td>QString QTextStream::readLine(qint64 maxlen = 0)</td><td>默认读取一行文本，如果手动指定 maxlen 的值，则最多读取 maxlen 个字符，并返回读取内容组成的 QString 字符串。</td></tr><tr><td>void QTextStream::setFieldAlignment(FieldAlignment mode)</td><td>设置对齐方式，通常与 setFieldWidth() 一起使用。</td></tr><tr><td>void QTextStream::setFieldWidth(int width)</td><td>设置每份数据占用的位置宽度为 width。</td></tr></tbody></table></div><p>QTextStream 类重载了<code>&gt;&gt;</code>输入运算符和<code>&gt;&gt;</code>输出运算符，使读写文本文件变得更简单。例如，用 QTextStream 实现【实例一】的程序如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QFile&gt;#include &lt;QDebug&gt;#include &lt;QString&gt;#include &lt;QTextStream&gt;int main(int argc, char *argv[])&#123;        &#x2F;&#x2F;创建 QFile 对象，同时指定要操作的文件        QFile file(&quot;D:&#x2F;demo.txt&quot;);        &#x2F;&#x2F;对文件进行写操作        if(!file.open(QIODevice::WriteOnly|QIODevice::Text))    &#123;                qDebug()&lt;&lt;&quot;文件打开失败&quot;;        &#125;        QTextStream out(&amp;file);        &#x2F;&#x2F;向文件中写入两行字符串        out &lt;&lt; (QString)&quot;C语言中文网\n&quot; &lt;&lt; (QString)&quot;http:&#x2F;&#x2F;c.biancheng.net&quot;;    &#x2F;&#x2F;关闭文件        file.close();        &#x2F;&#x2F;重新打开文件，对文件进行读操作    if(!file.open(QIODevice::ReadOnly|QIODevice::Text))&#123;          qDebug()&lt;&lt;&quot;文件打开失败&quot;;       &#125;       QTextStream in(&amp;file);       &#x2F;&#x2F;一直读，直至读取失败       while(!in.atEnd())&#123;              QString str;                &#x2F;&#x2F;从文件中读取一个字符串            in &gt;&gt; str;        qDebug() &lt;&lt; str;       &#125;        file.close();       return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        和<code>&lt;iostream&gt;</code>类似，QTextStream 类提供了两种格式化输出的方法，一种是调用该类的成员方法，例如表 3 中的 setFieldAlignment()、setFieldWidth 等，另一种是调用 QTextStream 类提供的格式描述符，下表罗列了常用的一些：</p><div class="table-container"><table><thead><tr><th>描述符</th><th>功能相同的方法</th><th>功 能</th></tr></thead><tbody><tr><td>Qt::hex</td><td>QTextStream::setIntegerBase(16)</td><td>将指定整数对应的 16 进制数写入到文件中。</td></tr><tr><td>Qt::showbase</td><td>QTextStream::setNumberFlags(numberFlags() \</td><td>ShowBase)</td><td>对于非十进制数，写入到文件中时带上相应的前缀。二进制数前缀是 0b，八进制数前缀是 0，十六进制数前缀是 0x。</td></tr><tr><td>Qt::forcesign</td><td>QTextStream::setNumberFlags(numberFlags() \</td><td>ForceSign)</td><td>将数字写入文件时，带上正负号。</td></tr><tr><td>Qt::fixed</td><td>QTextStream::setRealNumberNotation(FixedNotation)</td><td>将浮点数以普通小数的形式写入文件。</td></tr><tr><td>Qt::scientific</td><td>QTextStream::setRealNumberNotation(ScientificNotation)</td><td>将浮点数以科学计数法的形式写入文件。</td></tr><tr><td>Qt::left</td><td>QTextStream::setFieldAlignment(AlignLeft)</td><td>左对齐</td></tr><tr><td>Qt::right</td><td>QTextStream::setFieldAlignment(AlignRight)</td><td>右对齐</td></tr><tr><td>Qt::center</td><td>QTextStream::setFieldAlignment(AlignCenter)</td><td>居中对齐</td></tr></tbody></table></div><p>​        举个简单的例子：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QFile&gt;#include &lt;QDebug&gt;#include &lt;QString&gt;#include &lt;QTextStream&gt;int main(int argc, char *argv[])&#123;        QFile file(&quot;D:&#x2F;demo.txt&quot;);    if(!file.open(QIODevice::WriteOnly|QIODevice::Text))&#123;          qDebug()&lt;&lt;&quot;文件打开失败&quot;;       &#125;        QTextStream out(&amp;file);       &#x2F;&#x2F;将 10 的十六进制数写入文件        out &lt;&lt; hex &lt;&lt; 10;        &#x2F;&#x2F;设置每份数据占用 10 个字符的位置        out.setFieldWidth(10);        &#x2F;&#x2F;以右对齐的方式写入 3.14        out &lt;&lt; left &lt;&lt; 3.14;        &#x2F;&#x2F;后续数据以左对齐的方式写入文件        out.setFieldAlignment(QTextStream::AlignRight);        out &lt;&lt; 2.7;        &#x2F;&#x2F;关闭文件        file.close();        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        程序运行后，demo.txt 存储的文本内容为：</p><p>a3.14       2.7</p><h4 id="QFile-QDataStream"><a href="#QFile-QDataStream" class="headerlink" title="QFile+QDataStream"></a>QFile+QDataStream</h4><p>​        QDataStream 类的用法和 QTextStream 非常类似，最主要的区别在于，QDataStream 用于读写二进制文件。</p><p>​        使用 QDataStream 类之前，程序中要引入<code>&lt;QDataStream&gt;</code>头文件。创建 QDataStream 对象常用的构造函数为：</p><pre class="line-numbers language-none"><code class="language-none">QDataStream::QDataStream(QIODevice *d)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        下表罗列了 QDataStream 类常用的成员方法：</p><div class="table-container"><table><thead><tr><th>成员方法</th><th>功 能</th></tr></thead><tbody><tr><td>bool QDataStream::atEnd() const</td><td>判断是否读到文件末尾，如果已经达到末尾，返回 true，否则返回 false。</td></tr><tr><td>QDataStream &amp;QDataStream::readBytes(char *&amp;s, uint &amp;l)</td><td>对于用 writeBytes() 方法写入文件的 l 和 s，只能使用 readBytes() 方法读取出来。</td></tr><tr><td>int QDataStream::readRawData(char *s, int len)</td><td>从文件中读取最多 len 字节的数据到 s 中，返回值表示实际读取的字节数。注意，调用该方法之前，需要先给 s 参数分配好内存空间。</td></tr><tr><td>void QDataStream::setVersion(int v)</td><td>不同版本的 Qt 中，同名称的数据类型也可能存在差异，通过调用此方法手动指定版本号，可以确保读取数据的一致性。</td></tr><tr><td>int QDataStream::skipRawData(int len)</td><td>跳过文件中的 len 个字节，返回实际跳过的字节数。</td></tr><tr><td>QDataStream &amp;QDataStream::writeBytes(const char *s, uint len)</td><td>将长度 len 和 s 一起写入到文件中，对于 writeBytes() 写入的数据，只能用 readBytes() 方法读取。</td></tr><tr><td>int QDataStream::writeRawData(const char *s, int len)</td><td>将 s 中前 len 字节的数据写入文件，返回值表示成功写入的字节数。</td></tr></tbody></table></div><p>​        QDataStream 类也对<code>&lt;&lt;</code>和<code>&gt;&gt;</code>进行了重载，举个简单的例子，用 QDataStream 重新实现实例二：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;QFile&gt;#include &lt;QDebug&gt;#include &lt;QDataStream&gt;int main(int argc, char *argv[])&#123;    &#x2F;&#x2F;指定要写入文件的数据    qint32 nums[5]&#x3D;&#123;1,2,3,4,5&#125;;    QFile file(&quot;D:&#x2F;demo.dat&quot;);    file.open(QIODevice::WriteOnly);    &#x2F;&#x2F;创建 QDataStream 对象    QDataStream out(&amp;file);    &#x2F;&#x2F;将 nums 数组中的整数逐个写入到二进制文件中    for(int i&#x3D;0;i&lt;5;i++)&#123;      out &lt;&lt; nums[i];    &#125;    file.close();    &#x2F;&#x2F;再次打开文件，读取文件中存储的二进制数据    file.open(QIODevice::ReadOnly);    QDataStream in(&amp;file);    &#x2F;&#x2F;读取二进制文件中的数据    while(!in.atEnd())&#123;        &#x2F;&#x2F;每次读取一个整数        qint32 num;        in &gt;&gt; num;        qDebug() &lt;&lt; num;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        输出结果为：</p><pre class="line-numbers language-none"><code class="language-none">12345<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="QFileInfo"><a href="#QFileInfo" class="headerlink" title="QFileInfo"></a>QFileInfo</h2><p>原文链接：<a href="https://blog.csdn.net/kenfan1647/article/details/120465102">https://blog.csdn.net/kenfan1647/article/details/120465102</a></p><p>一、描述<br>        QFileInfo 提供有关文件系统中文件的名称和位置（路径）、访问权限、文件类型等信息。</p><p>​        FileInfo 还可用于获取有关 Qt 资源的信息。这个类是隐式共享的。</p><p>二、成员函数<br>2.1、判断函数</p><pre class="line-numbers language-none"><code class="language-none">1、bool isAbsolute() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件路径是否绝对路径。</p><p>注意：以冒号 (:) 开头的路径始终被视为绝对路径，因为它们表示 QResource。</p><pre class="line-numbers language-none"><code class="language-none">2、bool isBundle() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对象是否指向一个包或指向 macOS 和 iOS 上的包的符号链接。</p><pre class="line-numbers language-none"><code class="language-none">3、bool isDir() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对象是否指向目录或指向目录的符号链接。</p><pre class="line-numbers language-none"><code class="language-none">4、bool isExecutable() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件是否是可执行的。</p><p>如果文件是符号链接，并且目标是可执行的，则此函数返回 true。</p><pre class="line-numbers language-none"><code class="language-none">5、bool isFile() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对象是否指向文件或指向文件的符号链接。</p><p>如果文件是符号链接，并且目标是常规文件，则此函数返回 true。</p><pre class="line-numbers language-none"><code class="language-none">6、bool isHidden() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是否隐藏文件。</p><pre class="line-numbers language-none"><code class="language-none">7、bool isJunction() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对象是否指向一个连接点。</p><p>连接仅存在于 Windows 的 NTFS 文件系统上，并且通常由 mklink 命令创建。 它们可以被认为是目录的符号链接，并且只能为本地卷上的绝对路径创建。</p><pre class="line-numbers language-none"><code class="language-none">8、bool isNativePath() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果文件路径可以直接用于本机 API，则返回 true。 如果 Qt 内的虚拟文件系统（例如 Qt 资源系统）支持该文件，则返回 false。</p><p>本机路径可能仍需要转换路径分隔符和字符编码，具体取决于本机 API 的平台和输入要求。</p><pre class="line-numbers language-none"><code class="language-none">9、bool isReadable() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用户是否可以读取文件。</p><p>如果文件是符号链接，并且目标可读，则此函数返回 true。</p><p>注意：如果未启用 NTFS 权限检查，Windows 上的结果将仅反映文件是否存在。</p><pre class="line-numbers language-none"><code class="language-none">10、bool isRelative() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件路径是否相对的。</p><p>注意：以冒号 (:) 开头的路径始终被视为绝对路径，因为它们表示 QResource。</p><pre class="line-numbers language-none"><code class="language-none">11、bool isRoot() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对象是否指向根目录或指向根目录的符号链接。</p><pre class="line-numbers language-none"><code class="language-none">12、bool isShortcut() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对象是否指向快捷方式。</p><p>快捷方式仅存在于 Windows 上，通常是 .lnk 文件。</p><p>快捷方式 (.lnk) 文件被视为常规文件。 打开这些将打开 .lnk 文件本身。 为了打开快捷方式引用的文件，必须在快捷方式上使用 symLinkTarget()。</p><p>注意：即使快捷方式（损坏的快捷方式）指向不存在的文件，isShortcut() 也会返回 true。</p><pre class="line-numbers language-none"><code class="language-none">13、bool isSymLink() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对象是否指向符号链接或快捷方式。</p><pre class="line-numbers language-none"><code class="language-none">14、bool isSymbolicLink()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对象是否指向符号链接。</p><pre class="line-numbers language-none"><code class="language-none">15、bool isWritable() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用户是否可以写入文件。</p><p>如果文件是符号链接，并且目标是可写的，则此函数返回 true。</p><p>注意：如果未启用 NTFS 权限检查，Windows 上的结果将仅反映文件是否标记为只读。</p><p>2.2、其他函数</p><pre class="line-numbers language-none"><code class="language-none">1、QFileInfo(const QDir &amp;dir, const QString &amp;file)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造一个 QFileInfo，它提供有关给定file相对于目录 dir 的信息。</p><p>如果 dir 是相对路径，则 QFileInfo 也将具有相对路径。<br>如果 file 是绝对路径，则 dir 指定的目录将被忽略。</p><pre class="line-numbers language-none"><code class="language-none">QFileInfo(const QString &amp;file)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>构造一个 QFileInfo，提供有关给定文件的信息。该文件可以是绝对或相对路径。</p><pre class="line-numbers language-none"><code class="language-none">2、QDir absoluteDir() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以 QDir 对象的形式返回文件的绝对路径。 </p><pre class="line-numbers language-none"><code class="language-none">3、QString absoluteFilePath() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>  std::filesystem::path filesystemAbsoluteFilePath()</code></pre><p>返回包含文件名的绝对路径。绝对路径名由完整路径和文件名组成。</p><p>在 Unix 上，这将始终以根目录“/”开头。<br>在 Windows 上，这将始终以“D:/”开头，其中 D 是驱动器号，但未映射到驱动器号的网络共享除外（在这种情况下，路径将以“//sharename/”开头）。驱动器号将大写。<br>警告：如果 filePath() 为空，则此函数的行为未定义。</p><pre class="line-numbers language-none"><code class="language-none">4、QString absolutePath() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">std::filesystem::path filesystemAbsolutePath()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件的路径绝对路径。 这不包括文件名。</p><p>在 Unix 上，绝对路径将始终以根目录“/”开头。<br>在 Windows 上，这将始终以“D:/”开头，其中 D 是驱动器号，但未映射到驱动器号的网络共享除外（在这种情况下，路径将以“//sharename/”开头）。<br>警告：如果 filePath() 为空，则此函数的行为未定义。</p><pre class="line-numbers language-none"><code class="language-none">5、QString baseName() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回不带路径的文件的基本名称。</p><pre class="line-numbers language-none"><code class="language-none">6、QDateTime birthTime() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件创建的日期和时间。如果文件是符号链接，则返回目标文件的时间。</p><pre class="line-numbers language-none"><code class="language-none">7、QString bundleName() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回包的名称。</p><p>在 macOS 和 iOS 上，如果路径 isBundle()，这将返回包的正确本地化名称。<br>在其他平台上，返回一个空的 QString。 </p><pre class="line-numbers language-none"><code class="language-none">QFileInfo fi(&quot;&#x2F;Applications&#x2F;Safari.app&quot;);QString bundle &#x3D; fi.bundleName();                &#x2F;&#x2F; name &#x3D; &quot;Safari&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">8、bool caching()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是否启用了缓存。</p><pre class="line-numbers language-none"><code class="language-none">9、QString canonicalFilePath()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>  std::filesystem::path filesystemCanonicalFilePath()</code></pre><p>返回包含文件名的规范路径。</p><pre class="line-numbers language-none"><code class="language-none">10、QString canonicalPath() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>   std::filesystem::path filesystemCanonicalPath()</code></pre><p>返回文件的路径规范路径（不包括文件名）。</p><pre class="line-numbers language-none"><code class="language-none">11、QString completeBaseName() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回不带路径的文件的完整基本名称。</p><pre><code>QFileInfo info(&quot;C:/Users/70957/Pictures/aaa.bbb.jpg&quot;);qDebug()&lt;&lt;info.baseName();qDebug()&lt;&lt;info.completeBaseName();</code></pre><pre class="line-numbers language-none"><code class="language-none">12、QString completeSuffix()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件的完整后缀（扩展名）。完整的后缀由文件中第一个 ‘.’ 之后的所有字符组成。</p><pre class="line-numbers language-none"><code class="language-none">QFileInfo fi(&quot;&#x2F;tmp&#x2F;archive.tar.gz&quot;);QString ext &#x3D; fi.completeSuffix();  &#x2F;&#x2F; ext &#x3D; &quot;tar.gz&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">13、QDir dir()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以 QDir 对象的形式返回对象的父目录的路径。</p><p>注意：返回的 QDir 总是对应于对象的父目录，即使 QFileInfo 代表一个目录。</p><p>对于以下每个 QFileInfo，dir() 返回 QDir“~/examples/191697”。</p><pre><code> QFileInfo fileInfo1(&quot;~/examples/191697/.&quot;); QFileInfo fileInfo2(&quot;~/examples/191697/..&quot;); QFileInfo fileInfo3(&quot;~/examples/191697/main.cpp&quot;);</code></pre><p>对于以下每个 QFileInfo，dir() 返回 QDir“.”。</p><pre><code> QFileInfo fileInfo4(&quot;.&quot;); QFileInfo fileInfo5(&quot;..&quot;); QFileInfo fileInfo6(&quot;main.cpp&quot;);</code></pre><pre class="line-numbers language-none"><code class="language-none">14、bool exists()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件是否存在。</p><p>注意：如果文件是指向不存在文件的符号链接，则返回 false。</p><pre><code>   [static] bool exists(const QString &amp;file)</code></pre><p>使用此静态函数比使用非静态的重载函数进行文件系统访问更快。</p><pre class="line-numbers language-none"><code class="language-none">15、QString fileName() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件的名称，不包括路径。</p><pre><code>QFileInfo info(&quot;C:/Users/70957/Pictures/aaa.bbb.jpg&quot;);qDebug()&lt;&lt;info.baseName();qDebug()&lt;&lt;info.completeBaseName();qDebug()&lt;&lt;info.fileName();</code></pre><pre class="line-numbers language-none"><code class="language-none">16、QString filePath()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>   std::filesystem::path filesystemFilePath()</code></pre><p>返回文件名，包括路径。</p><pre class="line-numbers language-none"><code class="language-none">17、QDateTime fileTime(QFile::FileTime time) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回时间指定的文件时间。如果文件是符号链接，则返回目标文件的时间。</p><p>enum QFileDevice::FileTime：</p><div class="table-container"><table><thead><tr><th>Enum</th><th>Descriptions</th></tr></thead><tbody><tr><td>FileAccessTime</td><td>最近一次访问文件的时间（例如读取或写入）。</td></tr><tr><td>FileBirthTime</td><td>创建文件时（在 UNIX 上可能不支持）。</td></tr><tr><td>FileMetadataChangeTime</td><td>上次更改文件元数据的时间。</td></tr><tr><td>FileModificationTime</td><td>最近一次修改文件的时间。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">18、QString group() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件的组。如果文件是符号链接，则此函数返回目标的拥有组。</p><p>在 Windows 、文件没有组的系统上返回空字符串。在 Unix 下可能很耗时（毫秒为单位）。</p><pre class="line-numbers language-none"><code class="language-none">19、uint groupId() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件所属组的 id。如果文件是符号链接，则此函数返回拥有目标的组的 ID（。 </p><p>在 Windows 、文件没有组的系统上，此函数始终返回 (uint) -2。</p><pre class="line-numbers language-none"><code class="language-none">20、QString junctionTarget() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>   std::filesystem::path filesystemJunctionTarget()</code></pre><p>将 NTFS 结点解析为它引用的路径。不能保证由 NTFS 联结命名的目录确实存在。</p><p>返回 NTFS 连接点指向的目录的绝对路径，如果对象不是 NTFS 连接点，则返回空字符串。</p><pre class="line-numbers language-none"><code class="language-none">21、QDateTime lastModified()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回上次修改文件的日期和本地时间。如果文件是符号链接，则返回目标文件的时间。</p><pre class="line-numbers language-none"><code class="language-none">22、QDateTime lastRead()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回上次读取文件的日期和本地时间。如果文件是符号链接，则返回目标文件的时间。</p><p>在此信息不可用的平台上，返回与 lastModified() 相同的内容。</p><pre class="line-numbers language-none"><code class="language-none">23、bool makeAbsolute()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果文件的路径不是绝对路径，则将文件的路径转换为绝对路径。</p><p>返回 true 表示路径已转换； 否则返回 false 表示路径已经是绝对路径。</p><pre class="line-numbers language-none"><code class="language-none">24、QDateTime metadataChangeTime()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件元数据更改的日期和时间。如果文件是符号链接，则返回目标文件的时间。</p><pre class="line-numbers language-none"><code class="language-none">25、QString owner() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件的所有者。在文件没有所有者的系统上，或者如果发生错误，则返回空字符串。</p><p>如果文件是符号链接，则此函数返回目标的所有者。 </p><p>这个函数在 Unix 下可能很耗时（毫秒为单位）。</p><p>在 Windows 上，除非启用了 NTFS 权限检查，否则它将返回一个空字符串。</p><pre class="line-numbers language-none"><code class="language-none">26、uint ownerId()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件所有者的 ID。如果文件是符号链接，则此函数返回目标所有者的 ID。</p><p>在 Windows 和文件没有所有者的系统上，此函数返回 ((uint) -2)。</p><pre class="line-numbers language-none"><code class="language-none">27、QString path() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>    std::filesystem::path filesystemPath() </code></pre><p>返回文件的路径。不包括文件名。</p><pre class="line-numbers language-none"><code class="language-none">28、bool permission(QFile::Permissions permissions) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试文件权限。权限参数可以是多个 QFile::Permissions 类型的标志或一起检查权限组合。</p><p>在文件没有权限的系统上，此函数始终返回 true。</p><p>注意：如果未启用 NTFS 权限检查，结果在 Windows 上可能不准确。</p><p>如果文件是符号链接，则此函数会检查目标的权限。</p><pre class="line-numbers language-none"><code class="language-none">enum QFileDevice::Permission：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件的权限和所有权。可以将这些值进行 OR 运算以测试多个权限和所有权值。</p><div class="table-container"><table><thead><tr><th>Enum</th><th>Descriptions</th></tr></thead><tbody><tr><td>ReadOwner：</td><td>文件可供所有者读取。</td></tr><tr><td>WriteOwner：</td><td>文件可供所有者写入。</td></tr><tr><td>ExeOwner：</td><td>文件可供所有者执行。</td></tr><tr><td>ReadUser：</td><td>文件可供用户读取。</td></tr><tr><td>WriteUser：</td><td>文件可供用户写入。</td></tr><tr><td>ExeUser：</td><td>文件可供用户执行。</td></tr><tr><td>ReadGroup：</td><td>文件可供组读取。</td></tr><tr><td>WriteGroup：</td><td>文件可供组写入。</td></tr><tr><td>ExeGroup：</td><td>文件可供组执行。</td></tr><tr><td>ReadOther：</td><td>文件可供任何人读取。</td></tr><tr><td>WriteOther：</td><td>文件可供任何人写入。</td></tr><tr><td>ExeOther</td><td>文件可供任何人执行。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">29、QFile::Permissions permissions()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件的 QFile::Permissions 的完整 OR 组合。</p><p>如果文件是符号链接，则此函数返回目标（而不是符号链接）的权限。</p><pre class="line-numbers language-none"><code class="language-none">30、void refresh()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>刷新有关文件的信息，即在下次获取缓存属性时从文件系统中读取信息。 </p><pre class="line-numbers language-none"><code class="language-none">31、void setCaching(bool enable)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置是否启用文件信息的缓存。默认情况下启用缓存。 </p><p>启用缓存后，将会首次在需要时从文件系统读取文件信息，之后从缓存中读取文件信息。</p><pre class="line-numbers language-none"><code class="language-none">32、void setFile(const QString &amp;file)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>    void setFile(const std::filesystem::path &amp;file)</code></pre><p>设置 QFileInfo 提供有关文件的信息的文件。</p><p>文件可以包括绝对或相对路径。绝对路径以目录分隔符（例如 Unix 下的“/”）或驱动器规范（Windows 下）开头。 相对文件名以目录名或文件名开头，并指定相对于当前目录的路径。</p><pre class="line-numbers language-none"><code class="language-none">QString absolute &#x3D; &quot;&#x2F;local&#x2F;bin&quot;;  QString relative &#x3D; &quot;local&#x2F;bin&quot;;  QFileInfo absFile(absolute);  QFileInfo relFile(relative);  QDir::setCurrent(QDir::rootPath());  &#x2F;&#x2F; absFile 和 relFile 现在指向同一个文件  QDir::setCurrent(&quot;&#x2F;tmp&quot;);  &#x2F;&#x2F; absFile 现在指向“&#x2F;local&#x2F;bin”，  &#x2F;&#x2F; 而 relFile 指向“&#x2F;tmp&#x2F;local&#x2F;bin”       void setFile(const QDir &amp;dir, const QString &amp;file)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置 QFileInfo 为目录 dir 中的 file 提供信息的文件。</p><p>如果 file 包含相对路径，则 QFileInfo 也将具有相对路径。</p><pre class="line-numbers language-none"><code class="language-none">33、qint64 size()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以字节为单位返回文件大小。如果文件不存在或无法获取，则返回 0。</p><p>如果文件是符号链接，则返回目标文件的大小。 </p><pre class="line-numbers language-none"><code class="language-none">34、void stat()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从文件系统中读取所有属性并缓存。</p><p>当有关文件系统的信息在工作线程中收集，然后以缓存 QFileInfo 实例的形式传递给 UI 时，这很有用。</p><p><img src="2021092513423551.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none">35、QString suffix() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回文件的后缀（扩展名）。后缀由文件中最后一个“.”之后的所有字符组成。</p><pre class="line-numbers language-none"><code class="language-none">36、QString symLinkTarget() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>    std::filesystem::path filesystemSymLinkTarget()</code></pre><p>返回符号链接指向的文件或目录的绝对路径，如果对象不是符号链接，则返回空字符串。</p><pre class="line-numbers language-none"><code class="language-none">37、bool operator&#x3D;&#x3D;(const QFileInfo &amp;fileinfo) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此 QFileInfo 对象是否引用与 fileinfo 位于同一位置的文件。</p><p>请注意，比较两个不包含文件引用（不存在或为空的文件路径）的空 QFileInfo 对象的结果是未定义的。</p><p>三、宏成员</p><pre class="line-numbers language-none"><code class="language-none">1、QT_IMPLICIT_QFILEINFO_CONSTRUCTION<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义这个宏会使大多数 QFileInfo 构造函数隐式而不是显式。由于 QFileInfo 对象的构建成本很高，因此应避免意外创建它们。例如：</p><pre><code>QDir dir(&quot;D:/迅雷下载&quot;);QDirIterator it(dir);while (it.hasNext())&#123;    QFileInfo fi = it.next();    qDebug()&lt;&lt;fi.fileName();&#125;</code></pre><p>默认情况下，会报错：试图将QString转成QFileInfo：</p><p><img src="2021092514073295.png" alt="img"></p><p>在 pro 文件中加入：</p><p>DEFINES += QT_IMPLICIT_QFILEINFO_CONSTRUCTION<br>则可编译通过。</p><p>要避免隐式构造 QFileInfo 对象的代价，应该不要使用这个宏。</p><p>同时，这里正确获取 QFileInfo 对象的方法：</p><p><img src="20210925141326177.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learn_Windows_API-Semester-I</title>
      <link href="/2023/06/06/Learn-Windows-API-Semester-I/"/>
      <url>/2023/06/06/Learn-Windows-API-Semester-I/</url>
      
        <content type="html"><![CDATA[<h1 id="系统学习Windows-API"><a href="#系统学习Windows-API" class="headerlink" title="系统学习Windows API"></a>系统学习Windows API</h1><h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>​        写在前面：这是本菜鸟首次对一个大的topic有巨大的兴趣，正好，本人对桌面应用开发有动力研究，这里就以Windows API　编程作为自己串起来操作系统，并发编程，C++基本程序设计应用，以及底层QT开发的一个Application demo了！</p><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>​        还记得你在实验课上使用老古董 VS2010，当你选择了空项目开发后必须手动使用</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">system(&quot;pause&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个函数嘛？不错，他就是我们Windows API的一个。目的是让程序暂停在此句！我们应用的头文件是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们的主角来了哈哈哈</p><h2 id="小试一手"><a href="#小试一手" class="headerlink" title="小试一手"></a>小试一手</h2><p>​        创建你的一个项目，不够今天，我们创建的是一个桌面向导项目，随后，我们选择空项目创建，将：</p><p><img src="image-20230504215411467.png" alt="image-20230504215411467"></p><p>改成：</p><p><img src="image-20230504215354973.png" alt="image-20230504215354973"></p><p>​    以及转到：（右键项目选择属性）</p><p>​    把控制台改成窗口输出！不然编译器会在下面的程序中报错！</p><p><img src="image-20230504215458663.png" alt="image-20230504215458663"></p><p>​        我们书写一个简单的C++程序！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)&#123;MessageBox(NULL, TEXT(&quot;Hello, World&quot;), TEXT(&quot;Captions&quot;), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        F5一下：</p><p><img src="image-20230504215640299.png" alt="image-20230504215640299"></p><p>​        6！</p><h2 id="逐一解释"><a href="#逐一解释" class="headerlink" title="逐一解释"></a>逐一解释</h2><h3 id="include-lt-Windows-h-gt"><a href="#include-lt-Windows-h-gt" class="headerlink" title="#include&lt; Windows.h &gt;"></a>#include&lt; Windows.h &gt;</h3><p>​        我们老规矩，先来看看Windows.h装了啥：</p><p><img src="image-20230504220523073.png" alt="image-20230504220523073"></p><p>​        反正一大堆，但是核心就这些，这是我们需要注意的！</p><h3 id="int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow"><a href="#int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow" class="headerlink" title="int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)"></a>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)</h3><p>​        </p><p>​        一个函数！有些人奇怪了，什么玩意？C++程序没有int main(), 就像西方没有耶路撒冷一样！不是的！</p><p>​        在Windows桌面开发下，他就是我们的main函数。在Microsoft API Platform SDK下，我们查阅到：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int WINAPI WinMain(  HINSTANCE hInstance,      &#x2F;&#x2F; handle to current instance   HINSTANCE hPrevInstance,  &#x2F;&#x2F; handle to previous instance   LPSTR lpCmdLine,        &#x2F;&#x2F; command line  int nCmdShow        &#x2F;&#x2F;  show stat)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230504222032978.png" alt="image-20230504222032978"></p><h4 id="What-is-WINAPI"><a href="#What-is-WINAPI" class="headerlink" title="What is WINAPI"></a>What is WINAPI</h4><p>​        光标移动到上面： __stdcall 这是啥呢？标准调用！</p><p>​        被这个关键字修饰的函数，其参数都是从右向左通过堆栈传递的(__fastcall 的前面部分由ecx,edx传)， 函数调用在返回前要由被调用者清理堆栈。</p><p>​        啥？你不相信？反汇编我们产生的EXE文件就OK了：在MessageW处打一个断点，运行之找到</p><p><img src="image-20230504231052021.png" alt="image-20230504231052021"></p><p>​        大多数电脑采用的是大端法，也就是说可以理解为：参数在右边的，先被推送进函数里去</p><h4 id="批注？"><a href="#批注？" class="headerlink" title="批注？"></a>批注？</h4><p><img src="image-20230504231254737.png" alt="image-20230504231254737"></p><p>​        什么是批注呢请看我们函数和头文件下的：</p><p><img src="image-20230504231338650.png" alt="image-20230504231338650"></p><p>​        看看_ In _这个宏，他就是一个说明参数性质的宏！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++"> &#x2F;&#x2F; from sal.h_In_     : input parameter to a function, unmodified by called function      _Out_    : output parameter, written to by called function, pointed-to                 location not expected to be initialized prior to call      _Outptr_ : like _Out_ when returned variable is a pointer type                 (so param is pointer-to-pointer type). Called function                 provides&#x2F;allocated space.      _Outref_ : like _Outptr_, except param is reference-to-pointer type.      _Inout_  : inout parameter, read from and potentially modified by                 called function.      _Ret_    : for return values      _Field_  : class&#x2F;struct field invariants<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        In 表明他是一个输入参数，有点像const 一样，函数读取值但是不可以修改它！</p><p>​        InOut就是表示这是一个这样的值：传入又传出，值会被修改</p><p>​        Out表示这个值会被这个函数设置</p><p>​        OutPtr 表示返回这个值的指针</p><p>​        Microsoft对参数合理性做出了更多的解释：类似于main函数一样</p><pre class="line-numbers language-none"><code class="language-none">[in] hInstance类型： HINSTANCE应用程序的当前实例的句柄。[in] hPrevInstance类型： HINSTANCE应用程序的上一个实例的句柄。 此参数始终为 NULL。 如果需要检测另一个实例是否已存在，请使用 CreateMutex 函数创建唯一命名的互斥体。 即使互斥体已存在，CreateMutex 也会成功，但函数将返回ERROR_ALREADY_EXISTS。 这表示应用程序的另一个实例存在，因为它首先创建了互斥体。 但是，恶意用户可以在执行之前创建此互斥体，并阻止应用程序启动。 为防止这种情况，请创建一个随机命名的互斥体并存储名称，以便它只能由授权用户获取。 或者，可以使用文件进行此目的。 若要将应用程序限制为每个用户的一个实例，请在用户配置文件目录中创建锁定的文件。[in] lpCmdLine类型： LPSTR应用程序的命令行，不包括程序名称。 若要检索整个命令行，请使用 GetCommandLine 函数。[in] nShowCmd类型： int控制窗口的显示方式。 此参数可以是可在 ShowWindow 函数的 nCmdShow 参数中指定的任何值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示一个模式对话框，其中包含系统图标、一组按钮和一条简短的应用程序特定消息，例如状态或错误信息。 消息框返回一个整数值，该值指示用户单击的按钮。</p><h3 id="MessageBox函数"><a href="#MessageBox函数" class="headerlink" title="MessageBox函数"></a>MessageBox函数</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> HWND    hWnd<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPCTSTR lpText<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPCTSTR lpCaption<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           UINT    uType<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] hWnd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型：<strong>HWND</strong></p><p>要创建的消息框的所有者窗口的句柄。 如果此参数为 <strong>NULL</strong>，则消息框没有所有者窗口。</p><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpText<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>LPCTSTR</strong></p><p>要显示的消息。 如果字符串包含多个行，则可以使用回车符和/或换行符分隔每行之间的行。</p><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpCaption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>LPCTSTR</strong></p><p>对话框标题。 如果此参数为 <strong>NULL</strong>，则默认标题为 <strong>Error</strong>。</p><pre class="line-numbers language-none"><code class="language-none">[in] uType<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>UINT</strong></p><p>对话框的内容和行为。 此参数可以是以下标志组中的标志的组合。</p><p>若要指示消息框中显示的按钮，请指定以下值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_ABORTRETRYIGNORE</strong>0x00000002L</td><td style="text-align:left">消息框包含三个推送按钮： <strong>中止</strong>、 <strong>重试</strong>和 <strong>忽略</strong>。</td></tr><tr><td style="text-align:left"><strong>MB_CANCELTRYCONTINUE</strong>0x00000006L</td><td style="text-align:left">消息框包含三个按下按钮： <strong>“取消</strong>”、“ <strong>重试</strong>”、“ <strong>继续</strong>”。 使用此消息框类型，而不是MB_ABORTRETRYIGNORE。</td></tr><tr><td style="text-align:left"><strong>MB_HELP</strong>0x00004000L</td><td style="text-align:left">向消息框添加 <strong>“帮助</strong> ”按钮。 当用户单击 <strong>“帮助</strong> ”按钮或按 F1 时，系统会向所有者发送 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/shell/wm-help">WM_HELP</a> 消息。</td></tr><tr><td style="text-align:left"><strong>MB_OK</strong>0x00000000L</td><td style="text-align:left">消息框包含一个按钮： <strong>确定</strong>。 这是默认值。</td></tr><tr><td style="text-align:left"><strong>MB_OKCANCEL</strong>0x00000001L</td><td style="text-align:left">消息框包含两个推送按钮： <strong>“确定</strong> ”和 <strong>“取消</strong>”。</td></tr><tr><td style="text-align:left"><strong>MB_RETRYCANCEL</strong>0x00000005L</td><td style="text-align:left">消息框包含两个按下按钮： <strong>重试</strong> 和 <strong>取消</strong>。</td></tr><tr><td style="text-align:left"><strong>MB_YESNO</strong>0x00000004L</td><td style="text-align:left">消息框包含两个按下按钮： <strong>是</strong> 和 <strong>否</strong>。</td></tr><tr><td style="text-align:left"><strong>MB_YESNOCANCEL</strong>0x00000003L</td><td style="text-align:left">消息框包含三个按钮： <strong>是</strong>、 <strong>否</strong>和 <strong>取消</strong>。</td></tr></tbody></table></div><p>若要在消息框中显示图标，请指定以下值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_ICONEXCLAMATION</strong>0x00000030L</td><td style="text-align:left">消息框中会显示一个感叹号图标。</td></tr><tr><td style="text-align:left"><strong>MB_ICONWARNING</strong>0x00000030L</td><td style="text-align:left">消息框中会显示一个感叹号图标。</td></tr><tr><td style="text-align:left"><strong>MB_ICONINFORMATION</strong>0x00000040L</td><td style="text-align:left">图标由圆圈中的小写字母 <em>i</em> 组成，显示在消息框中。</td></tr><tr><td style="text-align:left"><strong>MB_ICONASTERISK</strong>0x00000040L</td><td style="text-align:left">图标由圆圈中的小写字母 <em>i</em> 组成，显示在消息框中。</td></tr><tr><td style="text-align:left"><strong>MB_ICONQUESTION</strong>0x00000020L</td><td style="text-align:left">消息框中会显示一个问号图标。 不再建议使用问号消息图标，因为这种图标无法清楚地表示特定类型的消息，并且作为问题的消息表述可应用于任何消息类型。 此外，用户可能会将问号消息符号与帮助信息混淆。 因此，不要在消息框中使用问号消息符号。 系统继续支持它包含的内容，只为满足反向兼容性。</td></tr><tr><td style="text-align:left"><strong>MB_ICONSTOP</strong>0x00000010L</td><td style="text-align:left">消息框中会显示一个停止符号图标。</td></tr><tr><td style="text-align:left"><strong>MB_ICONERROR</strong>0x00000010L</td><td style="text-align:left">消息框中会显示一个停止符号图标。</td></tr><tr><td style="text-align:left"><strong>MB_ICONHAND</strong>0x00000010L</td><td style="text-align:left">消息框中会显示一个停止符号图标。</td></tr></tbody></table></div><p>若要指示默认按钮，请指定以下值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_DEFBUTTON1</strong>0x00000000L</td><td style="text-align:left">第一个按钮是默认按钮。除非指定<strong>了MB_DEFBUTTON2</strong>、MB_DEFBUTTON3或<strong>MB_DEFBUTTON4</strong>，<strong>否则</strong>MB_DEFBUTTON1<strong>是默认值</strong>。</td></tr><tr><td style="text-align:left"><strong>MB_DEFBUTTON2</strong>0x00000100L</td><td style="text-align:left">第二个按钮是默认按钮。</td></tr><tr><td style="text-align:left"><strong>MB_DEFBUTTON3</strong>0x00000200L</td><td style="text-align:left">第三个按钮是默认按钮。</td></tr><tr><td style="text-align:left"><strong>MB_DEFBUTTON4</strong>0x00000300L</td><td style="text-align:left">第四个按钮是默认按钮。</td></tr></tbody></table></div><p>若要指示对话框的形式，请指定以下值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_APPLMODAL</strong>0x00000000L</td><td style="text-align:left">在 <em>hWnd</em> 参数标识的窗口中继续工作之前，用户必须响应消息框。 但是，用户可以移动到其他线程的窗口，并在这些窗口中工作。根据应用程序中的窗口层次结构，用户可能能够移动到线程中的其他窗口。 消息框父级的所有子窗口都将自动禁用，但弹出窗口不是。如果未指定<strong>MB_SYSTEMMODAL</strong>或<strong>MB_TASKMODAL</strong>，<strong>则MB_APPLMODAL</strong>为默认值。</td></tr><tr><td style="text-align:left"><strong>MB_SYSTEMMODAL</strong>0x00001000L</td><td style="text-align:left">与MB_APPLMODAL相同，消息框具有 <strong>WS_EX_TOPMOST</strong> 样式。 使用系统模式消息框通知用户严重、潜在的破坏性错误，例如， (立即引起注意，) 内存不足。 此标志不会影响用户与 <em>与 hWnd</em> 关联的窗口以外的窗口交互的能力。</td></tr><tr><td style="text-align:left"><strong>MB_TASKMODAL</strong>0x00002000L</td><td style="text-align:left">与 <strong>MB_APPLMODAL</strong> 相同，如果 <em>hWnd</em> 参数为 <strong>NULL</strong>，则禁用属于当前线程的所有顶级窗口。 当调用应用程序或库没有可用的窗口句柄时，请使用此标志，但仍需要防止输入到调用线程中的其他窗口，而不会挂起其他线程。</td></tr></tbody></table></div><p>若要指定其他选项，请使用以下一个或多个值。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_DEFAULT_DESKTOP_ONLY</strong>0x00020000L</td><td style="text-align:left">与交互式窗口工作站的桌面相同。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/winstation/window-stations">窗口工作站</a>。如果当前输入桌面不是默认桌面，则在用户切换到默认桌面之前， <strong>MessageBox</strong> 不会返回。</td></tr><tr><td style="text-align:left"><strong>MB_RIGHT</strong>0x00080000L</td><td style="text-align:left">文本是右对齐的。</td></tr><tr><td style="text-align:left"><strong>MB_RTLREADING</strong>0x00100000L</td><td style="text-align:left">在希伯来语和阿拉伯语系统上使用从右到左阅读顺序显示消息和标题文本。</td></tr><tr><td style="text-align:left"><strong>MB_SETFOREGROUND</strong>0x00010000L</td><td style="text-align:left">消息框将成为前台窗口。 在内部，系统调用消息框的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> 函数。</td></tr><tr><td style="text-align:left"><strong>MB_TOPMOST</strong>0x00040000L</td><td style="text-align:left">消息框是使用 <strong>WS_EX_TOPMOST</strong> 窗口样式创建的。</td></tr><tr><td style="text-align:left"><strong>MB_SERVICE_NOTIFICATION</strong>0x00200000L</td><td style="text-align:left">调用方是通知用户某个事件的服务。 该函数在当前活动桌面上显示一个消息框，即使没有用户登录到计算机也是如此。<strong>终端服务：</strong> 如果调用线程具有模拟令牌，该函数会将消息框定向到模拟令牌中指定的会话。如果设置了此标志， <em>则 hWnd</em> 参数必须为 <strong>NULL</strong>。 这样，消息框可以出现在桌面上，而不是与 <em>hWnd</em> 对应的桌面。有关使用此标志的安全注意事项的信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/Services/interactive-services">Interactive Services</a>。 具体而言，请注意，此标志可以在锁定的桌面上生成交互式内容，因此应仅用于一组非常有限的方案，例如资源耗尽。</td></tr></tbody></table></div><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>类型： <strong>int</strong></p><p>如果消息框有 <strong>“取消</strong> ”按钮，则函数返回 <strong>IDCANCEL</strong> 值（如果按下 ESC 键或选中 <strong>“取消</strong> ”按钮）。 如果消息框没有 <strong>“取消</strong> ”按钮，则按 ESC 将不起作用 -除非存在MB_OK按钮。 如果显示MB_OK按钮，并且用户按 ESC，则返回值为 <strong>IDOK</strong>。</p><p>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><p>如果函数成功，则返回值为以下菜单项值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">返回代码/值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>IDABORT</strong>3</td><td style="text-align:left">已选择 <strong>“中止</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDCANCEL</strong>2</td><td style="text-align:left">已选择“ <strong>取消</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDCONTINUE</strong>11</td><td style="text-align:left">已选择 <strong>“继续</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDIGNORE</strong>5</td><td style="text-align:left">已选择 <strong>“忽略</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDNO</strong>7</td><td style="text-align:left">已选择 <strong>“无</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDOK</strong>1</td><td style="text-align:left">已选择 <strong>“确定</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDRETRY</strong>4</td><td style="text-align:left">已选择 <strong>“重试</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDTRYAGAIN</strong>10</td><td style="text-align:left">已选择 <strong>“重试</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDYES</strong>6</td><td style="text-align:left">已选择 <strong>“是</strong> ”按钮。</td></tr></tbody></table></div><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>通过将 <em>uType</em> 参数设置为相应的标志值，可以在消息框中使用以下系统图标。</p><div class="table-container"><table><thead><tr><th style="text-align:left">图标</th><th style="text-align:left">标志值</th></tr></thead><tbody><tr><td style="text-align:left"><img src="mb_iconhand.png" alt="MB_ICONHAND、MB_ICONSTOP和MB_ICONERROR图标"></td><td style="text-align:left"><strong>MB_ICONHAND</strong>、 <strong>MB_ICONSTOP</strong>或 <strong>MB_ICONERROR</strong></td></tr><tr><td style="text-align:left"><img src="mb_iconquestion.png" alt="MB_ICONQUESTION图标"></td><td style="text-align:left"><strong>MB_ICONQUESTION</strong></td></tr><tr><td style="text-align:left"><img src="mb_iconexclamation.png" alt="MB_ICONEXCLAMATION和MB_ICONWARNING图标"></td><td style="text-align:left"><strong>MB_ICONEXCLAMATION</strong> 或 <strong>MB_ICONWARNING</strong></td></tr><tr><td style="text-align:left"><img src="mb_iconasterisk.png" alt="MB_ICONASTERISK和MB_ICONINFORMATION图标"></td><td style="text-align:left"><strong>MB_ICONASTERISK</strong> 或 <strong>MB_ICONINFORMATION</strong></td></tr></tbody></table></div><p>在 MessageBox 显示字符串开头的 Unicode 格式字符 U+200F 表示 (RL) M 添加两个从右到左标记，以便使 MessageBox 的读取顺序呈现为从右到左 (RTL) 。</p><p>使用系统模式消息框指示系统内存不足时， <em>lpText</em> 和 <em>lpCaption</em> 参数指向的字符串不应从资源文件中获取，因为尝试加载资源可能会失败。</p><p>如果在对话框存在时创建消息框，请使用对话框的句柄作为 <em>hWnd</em> 参数。 <em>hWnd</em> 参数不应标识子窗口，如对话框中的控件。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在以下示例中，应用程序显示一个消息框，该消息框在出现错误条件后提示用户执行操作。 消息框显示描述错误条件以及如何解决错误条件的消息。 <strong>MB_CANCELTRYCONTINUE</strong>样式指示 <strong>MessageBox</strong> 提供三个按钮，用户可以选择如何继续操作。 <strong>MB_DEFBUTTON2</strong>样式将默认焦点设置为消息框的第二个按钮，在本例中为<strong>“重试”</strong>按钮。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;Windows.h></span></span><span class="token keyword">void</span> WINAPI <span class="token function">doSomethingHalt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> usrChoice <span class="token operator">=</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"Are you sure to move forward? That is supposed to be invalid... I convinced!"</span><span class="token punctuation">)</span>\<span class="token punctuation">,</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"Warning"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>MB_ICONWARNING<span class="token operator">|</span>MB_CANCELTRYCONTINUE<span class="token operator">|</span>MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>usrChoice<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> IDCANCEL<span class="token operator">:</span><span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"good"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"afterWard"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MB_OKCANCEL <span class="token operator">|</span> MB_ICONINFORMATION <span class="token operator">|</span> MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> IDRETRY<span class="token operator">:</span><span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"I mean: that is not good!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"afterWard"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MB_OKCANCEL <span class="token operator">|</span> MB_ICONINFORMATION <span class="token operator">|</span> MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> IDCONTINUE<span class="token operator">:</span><span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"I mean: that is not good!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"afterWard"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MB_OKCANCEL <span class="token operator">|</span> MB_ICONINFORMATION <span class="token operator">|</span> MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> WINAPI <span class="token function">WinMain</span><span class="token punctuation">(</span>HINSTANCE hInstance<span class="token punctuation">,</span> HINSTANCE hPrevInstance<span class="token punctuation">,</span> LPSTR ipCmdLine<span class="token punctuation">,</span> <span class="token keyword">int</span> nCmdShow<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//MessageBox(NULL, TEXT("Hello, World"), TEXT("Captions"), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);</span><span class="token function">doSomethingHalt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// design by CharlieChen</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串主题"><a href="#字符串主题" class="headerlink" title="字符串主题"></a>字符串主题</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>​        下面我们开始入门简单的字符串主题：啥意思呢？回顾我们C语言的API。我们是如下声明一个char类型或基于char类型的数组</p><pre class="line-numbers language-none"><code class="language-none">char typicalChar &#x3D; &#39;A&#39;;char* TCPtr &#x3D; &quot;Hello!My friend~&quot;;char arrayCPtr &#x3D; &quot;hello,my frined~&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我们马上可以看到，char是一份字节大小，那么下面的arrayCPtr就指明需要17个字节来存储。</p><h3 id="wchar-t类型"><a href="#wchar-t类型" class="headerlink" title="wchar_t类型"></a>wchar_t类型</h3><p>​        可是，仅仅使用char可能存储不下如今丰富的字符。所以，转向扩展char是必要的，wchar,也就是widechar应运而生。在Windows 2000之后所有的Windows系统都在底层上支持Unicode字符集。</p><p>​        我们这样声明与初始化一个wchar变量：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t wideChar &#x3D; L&#39;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230505135217906.png" alt="image-20230505135217906"></p><p>​        类似的：</p><pre class="line-numbers language-none"><code class="language-none">wchar* ptrW &#x3D; &quot;Hello&quot;;wchar ptr[7] &#x3D; &quot;Hello!&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        但是注意：如果我们还是选择</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%s&quot;, ptrW);printf(&quot;%s&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        则只会打印首元素，这是因为字符串类型不匹配，人话讲就是：wchar字符串不用%s打印，而是ls</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%ls&quot;, ptrW);printf(&quot;%ls&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        或者是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t* WPTR &#x3D; &#123;&#39;a&#39;,&#39;\0&#39;&#125;; wprintf(&quot;%s&quot;,WPTR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        或是直接调用setlocal函数做默认的设置！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;locale.h&gt;int main()&#123;&#x2F;&#x2F;使用系统默认的设置调用setlocale(LC_ALL, &quot;&quot;);setlocale(LC_ALL, &quot;&quot;);const wchar_t * chWord &#x3D; L&quot;疯狂程序人—码农哈哥&quot;;printf(&quot;%s&quot;,chWord);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Windows下的字符和宽字符"><a href="#Windows下的字符和宽字符" class="headerlink" title="Windows下的字符和宽字符"></a>Windows下的字符和宽字符</h3><p>​        Windows整理自己的活：他们定义了他们自己的字符类型：在winnt.h文件下可以找到：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;&#x2F;&#x2F; Basics&#x2F;&#x2F;#ifndef VOID#define VOID voidtypedef char CHAR;typedef short SHORT;typedef long LONG;#if !defined(MIDL_PASS)typedef int INT;#endif#endif&#x2F;&#x2F;&#x2F;&#x2F; UNICODE (Wide Character) types&#x2F;&#x2F;#ifndef _MACtypedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#else&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a chartypedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#endiftypedef WCHAR *PWCHAR, *LPWCH, *PWCH;typedef CONST WCHAR *LPCWCH, *PCWCH;typedef _Null_terminated_ WCHAR *NWPSTR, *LPWSTR, *PWSTR;typedef _Null_terminated_ PWSTR *PZPWSTR;typedef _Null_terminated_ CONST PWSTR *PCZPWSTR;typedef _Null_terminated_ WCHAR UNALIGNED *LPUWSTR, *PUWSTR;typedef _Null_terminated_ CONST WCHAR *LPCWSTR, *PCWSTR;typedef _Null_terminated_ PCWSTR *PZPCWSTR;typedef _Null_terminated_ CONST PCWSTR *PCZPCWSTR;typedef _Null_terminated_ CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;typedef _NullNull_terminated_ WCHAR *PZZWSTR;typedef _NullNull_terminated_ CONST WCHAR *PCZZWSTR;typedef _NullNull_terminated_ WCHAR UNALIGNED *PUZZWSTR;typedef _NullNull_terminated_ CONST WCHAR UNALIGNED *PCUZZWSTR;typedef  WCHAR *PNZWCH;typedef  CONST WCHAR *PCNZWCH;typedef  WCHAR UNALIGNED *PUNZWCH;typedef  CONST WCHAR UNALIGNED *PCUNZWCH;#if _WIN32_WINNT &gt;&#x3D; 0x0600 || (defined(__cplusplus) &amp;&amp; defined(WINDOWS_ENABLE_CPLUSPLUS))typedef CONST WCHAR *LPCWCHAR, *PCWCHAR;typedef CONST WCHAR UNALIGNED *LPCUWCHAR, *PCUWCHAR;&#x2F;&#x2F;&#x2F;&#x2F;  UCS (Universal Character Set) types&#x2F;&#x2F;typedef unsigned long UCSCHAR;&#x2F;&#x2F;&#x2F;&#x2F;  Even pre-Unicode agreement, UCS values are always in the&#x2F;&#x2F;  range U+00000000 to U+7FFFFFFF, so we&#39;ll pick an obvious&#x2F;&#x2F;  value.#define UCSCHAR_INVALID_CHARACTER (0xffffffff)#define MIN_UCSCHAR (0)&#x2F;&#x2F;&#x2F;&#x2F;  We&#39;ll assume here that the ISO-10646 &#x2F; Unicode agreement&#x2F;&#x2F;  not to assign code points after U+0010FFFF holds so that&#x2F;&#x2F;  we do not have to have separate &quot;UCSCHAR&quot; and &quot;UNICODECHAR&quot;&#x2F;&#x2F;  types.&#x2F;&#x2F;#define MAX_UCSCHAR (0x0010FFFF)typedef UCSCHAR *PUCSCHAR;typedef const UCSCHAR *PCUCSCHAR;typedef UCSCHAR *PUCSSTR;typedef UCSCHAR UNALIGNED *PUUCSSTR;typedef const UCSCHAR *PCUCSSTR;typedef const UCSCHAR UNALIGNED *PCUUCSSTR;typedef UCSCHAR UNALIGNED *PUUCSCHAR;typedef const UCSCHAR UNALIGNED *PCUUCSCHAR;#endif &#x2F;&#x2F; _WIN32_WINNT &gt;&#x3D; 0x0600&#x2F;&#x2F;&#x2F;&#x2F; ANSI (Multi-byte Character) types&#x2F;&#x2F;typedef CHAR *PCHAR, *LPCH, *PCH;typedef CONST CHAR *LPCCH, *PCCH;typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;typedef _Null_terminated_ PSTR *PZPSTR;typedef _Null_terminated_ CONST PSTR *PCZPSTR;typedef _Null_terminated_ CONST CHAR *LPCSTR, *PCSTR;typedef _Null_terminated_ PCSTR *PZPCSTR;typedef _Null_terminated_ CONST PCSTR *PCZPCSTR;typedef _NullNull_terminated_ CHAR *PZZSTR;typedef _NullNull_terminated_ CONST CHAR *PCZZSTR;typedef  CHAR *PNZCH;typedef  CONST CHAR *PCNZCH;&#x2F;&#x2F;&#x2F;&#x2F; Neutral ANSI&#x2F;UNICODE types and macros&#x2F;&#x2F;#ifdef  UNICODE                     &#x2F;&#x2F; r_winnt#ifndef _TCHAR_DEFINEDtypedef WCHAR TCHAR, *PTCHAR;typedef WCHAR TBYTE , *PTBYTE ;#define _TCHAR_DEFINED#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;typedef LPWCH LPTCH, PTCH;typedef LPCWCH LPCTCH, PCTCH;typedef LPWSTR PTSTR, LPTSTR;typedef LPCWSTR PCTSTR, LPCTSTR;typedef LPUWSTR PUTSTR, LPUTSTR;typedef LPCUWSTR PCUTSTR, LPCUTSTR;typedef LPWSTR LP;typedef PZZWSTR PZZTSTR;typedef PCZZWSTR PCZZTSTR;typedef PUZZWSTR PUZZTSTR;typedef PCUZZWSTR PCUZZTSTR;typedef PZPWSTR PZPTSTR;typedef PNZWCH PNZTCH;typedef PCNZWCH PCNZTCH;typedef PUNZWCH PUNZTCH;typedef PCUNZWCH PCUNZTCH;#define __TEXT(quote) L##quote      &#x2F;&#x2F; r_winnt#else   &#x2F;* UNICODE *&#x2F;               &#x2F;&#x2F; r_winnt#ifndef _TCHAR_DEFINEDtypedef char TCHAR, *PTCHAR;typedef unsigned char TBYTE , *PTBYTE ;#define _TCHAR_DEFINED#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;typedef LPCH LPTCH, PTCH;typedef LPCCH LPCTCH, PCTCH;typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;typedef PZZSTR PZZTSTR, PUZZTSTR;typedef PCZZSTR PCZZTSTR, PCUZZTSTR;typedef PZPSTR PZPTSTR;typedef PNZCH PNZTCH, PUNZTCH;typedef PCNZCH PCNZTCH, PCUNZTCH;#define __TEXT(quote) quote         &#x2F;&#x2F; r_winnt#endif &#x2F;* UNICODE *&#x2F;                &#x2F;&#x2F; r_winnt#define TEXT(quote) __TEXT(quote)   &#x2F;&#x2F; r_winnttypedef SHORT *PSHORT;  typedef LONG *PLONG;    #define ALL_PROCESSOR_GROUPS        0xffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在这里我们找到了两个东西：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef _MACtypedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#else&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a chartypedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        首先是wchar_t被重写位WCHAR。对于一些甚至没有wchar的编译器直接对unsigned short起别名。</p><p>​        其次是TEXT宏，这个宏便捷的帮助我们直接将普通的字符串升级为宽字符串，其做法不是强制转换，而是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define __TEXT(quote) L##quote#define TEXT(quote) __TEXT(quote)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        ##是令牌粘贴，就是直接把L和字符串连接在一起返回，比若说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TEXT(&quot;Hello&quot;)--- Compiler----&gt; L&quot;Hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们看到，上面的定义给出了：PSTR和LPSTR的小东西。他们都是CHAR（本质上就是Char），而P C STR 和 LP C STR则是Const类型的字符串。也就是常字符串！</p><p>​        那对于TCHAR这样Windows自己给出了字符串，我们应该怎么处理呢了，答案是万能的WIndows又帮我们干好了。使用P T STR和LP T STR就可以胜任这些工作！</p><h2 id="常见的字符串处理工作"><a href="#常见的字符串处理工作" class="headerlink" title="常见的字符串处理工作"></a>常见的字符串处理工作</h2><h3 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h3><p>​        下面我们要说的是如何获取字符串的长度，请看strlen和wstrlen.</p><pre class="line-numbers language-none"><code class="language-none">size_t strlen(const char* str);size_t wstrlen(const wchar_t* str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        size_t，如其所说的那样，衡量的是大小的类型。其定义查看建议自行搜索，这里做阐述。因为不是重点我想说的！</p><p>​        来试试看：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;tchar.h&gt;int main() &#123;CHAR str[] &#x3D; &quot;C语言\0&quot;; &#x2F;&#x2F; 这个函数返回占比字节的大小WCHAR wstr[] &#x3D; L&quot;C语言&quot;; &#x2F;&#x2F; 这个函数返回的是宽字符的个数_tprintf(TEXT(&quot;strlen(str) &#x3D; %d\n wcslen(wstr) &#x3D; %d&quot;), strlen(str), wcslen(wstr));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230505235033338.png" alt="image-20230505235033338"></p><p>​        注意到_tprintf是一个随系统环境而改变的宏函数，在支持UNICODE字符集的情况下，系统将会自动的转化之成为wprintf！</p><p>​        类似的：我们还有一个叫做tcslen这个函数，他是这样被定义的：</p><p><img src="image-20230505235214903.png" alt="image-20230505235214903"></p><p>​        好鸡肋啊，那如果我们改一下不支持Unicode子集呢？仍然是右键项目——属性，转到这个地方：</p><p><img src="image-20230505235414875.png" alt="image-20230505235414875"></p><p>​        改成</p><p><img src="image-20230505235429080.png" alt="image-20230505235429080"></p><p>​        发现变灰了！转向再看发现跳转到了：&gt;</p><p><img src="image-20230505235350688.png" alt="image-20230505235350688"></p><h2 id="字符串主题-1"><a href="#字符串主题-1" class="headerlink" title="字符串主题"></a>字符串主题</h2><h3 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h3><p>​        下面我们开始入门简单的字符串主题：啥意思呢？回顾我们C语言的API。我们是如下声明一个char类型或基于char类型的数组</p><pre class="line-numbers language-none"><code class="language-none">char typicalChar &#x3D; &#39;A&#39;;char* TCPtr &#x3D; &quot;Hello!My friend~&quot;;char arrayCPtr &#x3D; &quot;hello,my frined~&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我们马上可以看到，char是一份字节大小，那么下面的arrayCPtr就指明需要17个字节来存储。</p><h3 id="wchar-t类型-1"><a href="#wchar-t类型-1" class="headerlink" title="wchar_t类型"></a>wchar_t类型</h3><p>​        可是，仅仅使用char可能存储不下如今丰富的字符。所以，转向扩展char是必要的，wchar,也就是widechar应运而生。在Windows 2000之后所有的Windows系统都在底层上支持Unicode字符集。</p><p>​        我们这样声明与初始化一个wchar变量：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t wideChar &#x3D; L&#39;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230505135217906.png" alt="image-20230505135217906"></p><p>​        类似的：</p><pre class="line-numbers language-none"><code class="language-none">wchar* ptrW &#x3D; &quot;Hello&quot;;wchar ptr[7] &#x3D; &quot;Hello!&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        但是注意：如果我们还是选择</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%s&quot;, ptrW);printf(&quot;%s&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        则只会打印首元素，这是因为字符串类型不匹配，人话讲就是：wchar字符串不用%s打印，而是ls</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%ls&quot;, ptrW);printf(&quot;%ls&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        或者是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t* WPTR &#x3D; &#123;&#39;a&#39;,&#39;\0&#39;&#125;; wprintf(&quot;%s&quot;,WPTR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        或是直接调用setlocal函数做默认的设置！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;locale.h&gt;int main()&#123;&#x2F;&#x2F;使用系统默认的设置调用setlocale(LC_ALL, &quot;&quot;);setlocale(LC_ALL, &quot;&quot;);const wchar_t * chWord &#x3D; L&quot;疯狂程序人—码农哈哥&quot;;printf(&quot;%s&quot;,chWord);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Windows下的字符和宽字符-1"><a href="#Windows下的字符和宽字符-1" class="headerlink" title="Windows下的字符和宽字符"></a>Windows下的字符和宽字符</h3><p>​        Windows整理自己的活：他们定义了他们自己的字符类型：在winnt.h文件下可以找到：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;&#x2F;&#x2F; Basics&#x2F;&#x2F;#ifndef VOID#define VOID voidtypedef char CHAR;typedef short SHORT;typedef long LONG;#if !defined(MIDL_PASS)typedef int INT;#endif#endif&#x2F;&#x2F;&#x2F;&#x2F; UNICODE (Wide Character) types&#x2F;&#x2F;#ifndef _MACtypedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#else&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a chartypedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#endiftypedef WCHAR *PWCHAR, *LPWCH, *PWCH;typedef CONST WCHAR *LPCWCH, *PCWCH;typedef _Null_terminated_ WCHAR *NWPSTR, *LPWSTR, *PWSTR;typedef _Null_terminated_ PWSTR *PZPWSTR;typedef _Null_terminated_ CONST PWSTR *PCZPWSTR;typedef _Null_terminated_ WCHAR UNALIGNED *LPUWSTR, *PUWSTR;typedef _Null_terminated_ CONST WCHAR *LPCWSTR, *PCWSTR;typedef _Null_terminated_ PCWSTR *PZPCWSTR;typedef _Null_terminated_ CONST PCWSTR *PCZPCWSTR;typedef _Null_terminated_ CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;typedef _NullNull_terminated_ WCHAR *PZZWSTR;typedef _NullNull_terminated_ CONST WCHAR *PCZZWSTR;typedef _NullNull_terminated_ WCHAR UNALIGNED *PUZZWSTR;typedef _NullNull_terminated_ CONST WCHAR UNALIGNED *PCUZZWSTR;typedef  WCHAR *PNZWCH;typedef  CONST WCHAR *PCNZWCH;typedef  WCHAR UNALIGNED *PUNZWCH;typedef  CONST WCHAR UNALIGNED *PCUNZWCH;#if _WIN32_WINNT &gt;&#x3D; 0x0600 || (defined(__cplusplus) &amp;&amp; defined(WINDOWS_ENABLE_CPLUSPLUS))typedef CONST WCHAR *LPCWCHAR, *PCWCHAR;typedef CONST WCHAR UNALIGNED *LPCUWCHAR, *PCUWCHAR;&#x2F;&#x2F;&#x2F;&#x2F;  UCS (Universal Character Set) types&#x2F;&#x2F;typedef unsigned long UCSCHAR;&#x2F;&#x2F;&#x2F;&#x2F;  Even pre-Unicode agreement, UCS values are always in the&#x2F;&#x2F;  range U+00000000 to U+7FFFFFFF, so we&#39;ll pick an obvious&#x2F;&#x2F;  value.#define UCSCHAR_INVALID_CHARACTER (0xffffffff)#define MIN_UCSCHAR (0)&#x2F;&#x2F;&#x2F;&#x2F;  We&#39;ll assume here that the ISO-10646 &#x2F; Unicode agreement&#x2F;&#x2F;  not to assign code points after U+0010FFFF holds so that&#x2F;&#x2F;  we do not have to have separate &quot;UCSCHAR&quot; and &quot;UNICODECHAR&quot;&#x2F;&#x2F;  types.&#x2F;&#x2F;#define MAX_UCSCHAR (0x0010FFFF)typedef UCSCHAR *PUCSCHAR;typedef const UCSCHAR *PCUCSCHAR;typedef UCSCHAR *PUCSSTR;typedef UCSCHAR UNALIGNED *PUUCSSTR;typedef const UCSCHAR *PCUCSSTR;typedef const UCSCHAR UNALIGNED *PCUUCSSTR;typedef UCSCHAR UNALIGNED *PUUCSCHAR;typedef const UCSCHAR UNALIGNED *PCUUCSCHAR;#endif &#x2F;&#x2F; _WIN32_WINNT &gt;&#x3D; 0x0600&#x2F;&#x2F;&#x2F;&#x2F; ANSI (Multi-byte Character) types&#x2F;&#x2F;typedef CHAR *PCHAR, *LPCH, *PCH;typedef CONST CHAR *LPCCH, *PCCH;typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;typedef _Null_terminated_ PSTR *PZPSTR;typedef _Null_terminated_ CONST PSTR *PCZPSTR;typedef _Null_terminated_ CONST CHAR *LPCSTR, *PCSTR;typedef _Null_terminated_ PCSTR *PZPCSTR;typedef _Null_terminated_ CONST PCSTR *PCZPCSTR;typedef _NullNull_terminated_ CHAR *PZZSTR;typedef _NullNull_terminated_ CONST CHAR *PCZZSTR;typedef  CHAR *PNZCH;typedef  CONST CHAR *PCNZCH;&#x2F;&#x2F;&#x2F;&#x2F; Neutral ANSI&#x2F;UNICODE types and macros&#x2F;&#x2F;#ifdef  UNICODE                     &#x2F;&#x2F; r_winnt#ifndef _TCHAR_DEFINEDtypedef WCHAR TCHAR, *PTCHAR;typedef WCHAR TBYTE , *PTBYTE ;#define _TCHAR_DEFINED#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;typedef LPWCH LPTCH, PTCH;typedef LPCWCH LPCTCH, PCTCH;typedef LPWSTR PTSTR, LPTSTR;typedef LPCWSTR PCTSTR, LPCTSTR;typedef LPUWSTR PUTSTR, LPUTSTR;typedef LPCUWSTR PCUTSTR, LPCUTSTR;typedef LPWSTR LP;typedef PZZWSTR PZZTSTR;typedef PCZZWSTR PCZZTSTR;typedef PUZZWSTR PUZZTSTR;typedef PCUZZWSTR PCUZZTSTR;typedef PZPWSTR PZPTSTR;typedef PNZWCH PNZTCH;typedef PCNZWCH PCNZTCH;typedef PUNZWCH PUNZTCH;typedef PCUNZWCH PCUNZTCH;#define __TEXT(quote) L##quote      &#x2F;&#x2F; r_winnt#else   &#x2F;* UNICODE *&#x2F;               &#x2F;&#x2F; r_winnt#ifndef _TCHAR_DEFINEDtypedef char TCHAR, *PTCHAR;typedef unsigned char TBYTE , *PTBYTE ;#define _TCHAR_DEFINED#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;typedef LPCH LPTCH, PTCH;typedef LPCCH LPCTCH, PCTCH;typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;typedef PZZSTR PZZTSTR, PUZZTSTR;typedef PCZZSTR PCZZTSTR, PCUZZTSTR;typedef PZPSTR PZPTSTR;typedef PNZCH PNZTCH, PUNZTCH;typedef PCNZCH PCNZTCH, PCUNZTCH;#define __TEXT(quote) quote         &#x2F;&#x2F; r_winnt#endif &#x2F;* UNICODE *&#x2F;                &#x2F;&#x2F; r_winnt#define TEXT(quote) __TEXT(quote)   &#x2F;&#x2F; r_winnttypedef SHORT *PSHORT;  typedef LONG *PLONG;    #define ALL_PROCESSOR_GROUPS        0xffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在这里我们找到了两个东西：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef _MACtypedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#else&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a chartypedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        首先是wchar_t被重写位WCHAR。对于一些甚至没有wchar的编译器直接对unsigned short起别名。</p><p>​        其次是TEXT宏，这个宏便捷的帮助我们直接将普通的字符串升级为宽字符串，其做法不是强制转换，而是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define __TEXT(quote) L##quote#define TEXT(quote) __TEXT(quote)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        ##是令牌粘贴，就是直接把L和字符串连接在一起返回，比若说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TEXT(&quot;Hello&quot;)--- Compiler----&gt; L&quot;Hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们看到，上面的定义给出了：PSTR和LPSTR的小东西。他们都是CHAR（本质上就是Char），而P C STR 和 LP C STR则是Const类型的字符串。也就是常字符串！</p><p>​        那对于TCHAR这样Windows自己给出了字符串，我们应该怎么处理呢了，答案是万能的WIndows又帮我们干好了。使用P T STR和LP T STR就可以胜任这些工作！</p><h2 id="常见的字符串处理工作-1"><a href="#常见的字符串处理工作-1" class="headerlink" title="常见的字符串处理工作"></a>常见的字符串处理工作</h2><h3 id="获取字符串的长度-1"><a href="#获取字符串的长度-1" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h3><p>​        下面我们要说的是如何获取字符串的长度，请看strlen和wstrlen.</p><pre class="line-numbers language-none"><code class="language-none">size_t strlen(const char* str);size_t wstrlen(const wchar_t* str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        size_t，如其所说的那样，衡量的是大小的类型。其定义查看建议自行搜索，这里做阐述。因为不是重点我想说的！</p><p>​        来试试看：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;tchar.h&gt;int main() &#123;CHAR str[] &#x3D; &quot;C语言\0&quot;; &#x2F;&#x2F; 这个函数返回占比字节的大小WCHAR wstr[] &#x3D; L&quot;C语言&quot;; &#x2F;&#x2F; 这个函数返回的是宽字符的个数_tprintf(TEXT(&quot;strlen(str) &#x3D; %d\n wcslen(wstr) &#x3D; %d&quot;), strlen(str), wcslen(wstr));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230505235033338.png" alt="image-20230505235033338"></p><p>​        注意到_tprintf是一个随系统环境而改变的宏函数，在支持UNICODE字符集的情况下，系统将会自动的转化之成为wprintf！</p><p>​        类似的：我们还有一个叫做tcslen这个函数，他是这样被定义的：</p><p><img src="image-20230505235214903.png" alt="image-20230505235214903"></p><p>​        好鸡肋啊，那如果我们改一下不支持Unicode子集呢？仍然是右键项目——属性，转到这个地方：</p><p><img src="image-20230505235414875.png" alt="image-20230505235414875"></p><p>​        改成</p><p><img src="image-20230505235429080.png" alt="image-20230505235429080"></p><p>​        发现变灰了！转向再看发现跳转到了：&gt;</p><p><img src="image-20230505235350688.png" alt="image-20230505235350688"></p><h2 id="数据类型一看"><a href="#数据类型一看" class="headerlink" title="数据类型一看"></a>数据类型一看</h2><p>​        原生C数据类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int float double ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Windows自己的：</p><pre class="line-numbers language-none"><code class="language-none">BOOL BYTE CHAR CONST DWORD DOWRD32 DWORD64 FLOAT HANDLE HICON HINSTANCEHKEY HMODULE HWND INT INT_PTR INT32 INT64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        看看这个：</p><pre class="line-numbers language-none"><code class="language-none">LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        跳转得到：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;&#x2F;&#x2F; ANSI (Multi-byte Character) types&#x2F;&#x2F;typedef CHAR *PCHAR, *LPCH, *PCH;typedef CONST CHAR *LPCCH, *PCCH;typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        进一步针对CHAR类型跳转</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef char CHAR;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        微软搞那么多宏，一方面是历史遗留，另一方面是方便他们的工程师更容易区分</p><p>​        Dword是这个东西：一个四个字节的数据类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DWORD dwMax &#x3D; 0xFFFFFFFF<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef unsigned long       DWORD;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        于是INT就是有符号的，DWORD是无符号的。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;int main()&#123;LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;INT a &#x3D; 10;DWORD dwMax &#x3D; 0xFFFFFFFF;MessageBox(NULL, szString, TEXT(&quot;LPSTR&quot;), MB_OK);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在C中我们有：memcpy</p><p>​        在Windows下，有一个函数叫CopyMemory()</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">CopyMemory(IpStr, szString, lstrlen(szString) + 1); &#x2F;&#x2F; add one to include the \0.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define CopyMemory RtlCopyMemory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Handle,也就是句柄，是这样被定义的：</p><p>​        他有如下的句柄：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void *HANDLE;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        HICON图标</p><pre class="line-numbers language-X" data-language="X"><code class="language-X">DECLARE_HANDLE(HICON);#define DECLARE_HANDLE(name) struct name##__&#123;int unused;&#125;; typedef struct name##__ *name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        HInstance实例句柄</p><pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HINSTANCE);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        HKey注册表的句柄</p><pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HKEY);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Hmodule模块句柄</p><pre class="line-numbers language-none"><code class="language-none">typedef HINSTANCE HMODULE;      &#x2F;* HMODULEs can be used in place of HINSTANCEs *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        HWND窗口句柄</p><pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE            (HWND);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="API基础函数"><a href="#API基础函数" class="headerlink" title="API基础函数"></a>API基础函数</h2><p>​        WindowAPI大量的使用了Windows的数据类型！所有的API都有W版和A版，分别表示的是支持Unicode字符集和ASCII多字节字符集。下面我们来看一个Windows自己创建的demo，选择Win32项目创建。看到主文件下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; WindowsProject1.cpp : 定义应用程序的入口点。&#x2F;&#x2F;#include &quot;framework.h&quot;#include &quot;WindowsProject1.h&quot;#define MAX_LOADSTRING 100&#x2F;&#x2F; 全局变量:HINSTANCE hInst;                                &#x2F;&#x2F; 当前实例WCHAR szTitle[MAX_LOADSTRING];                  &#x2F;&#x2F; 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING];            &#x2F;&#x2F; 主窗口类名&#x2F;&#x2F; 此代码模块中包含的函数的前向声明:ATOM                MyRegisterClass(HINSTANCE hInstance);BOOL                InitInstance(HINSTANCE, int);LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance,                     _In_opt_ HINSTANCE hPrevInstance,                     _In_ LPWSTR    lpCmdLine,                     _In_ int       nCmdShow)&#123;    UNREFERENCED_PARAMETER(hPrevInstance);    UNREFERENCED_PARAMETER(lpCmdLine);    &#x2F;&#x2F; TODO: 在此处放置代码。    &#x2F;&#x2F; 初始化全局字符串    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);    MyRegisterClass(hInstance);    &#x2F;&#x2F; 执行应用程序初始化:    if (!InitInstance (hInstance, nCmdShow))    &#123;        return FALSE;    &#125;    HACCEL hAccelTable &#x3D; LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));    MSG msg;    &#x2F;&#x2F; 主消息循环:    while (GetMessage(&amp;msg, nullptr, 0, 0))    &#123;        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))        &#123;            TranslateMessage(&amp;msg);            DispatchMessage(&amp;msg);        &#125;    &#125;    return (int) msg.wParam;&#125;&#x2F;&#x2F;&#x2F;&#x2F;  函数: MyRegisterClass()&#x2F;&#x2F;&#x2F;&#x2F;  目标: 注册窗口类。&#x2F;&#x2F;ATOM MyRegisterClass(HINSTANCE hInstance)&#123;    WNDCLASSEXW wcex;    wcex.cbSize &#x3D; sizeof(WNDCLASSEX);    wcex.style          &#x3D; CS_HREDRAW | CS_VREDRAW;    wcex.lpfnWndProc    &#x3D; WndProc;    wcex.cbClsExtra     &#x3D; 0;    wcex.cbWndExtra     &#x3D; 0;    wcex.hInstance      &#x3D; hInstance;    wcex.hIcon          &#x3D; LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));    wcex.hCursor        &#x3D; LoadCursor(nullptr, IDC_ARROW);    wcex.hbrBackground  &#x3D; (HBRUSH)(COLOR_WINDOW+1);    wcex.lpszMenuName   &#x3D; MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);    wcex.lpszClassName  &#x3D; szWindowClass;    wcex.hIconSm        &#x3D; LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));    return RegisterClassExW(&amp;wcex);&#125;&#x2F;&#x2F;&#x2F;&#x2F;   函数: InitInstance(HINSTANCE, int)&#x2F;&#x2F;&#x2F;&#x2F;   目标: 保存实例句柄并创建主窗口&#x2F;&#x2F;&#x2F;&#x2F;   注释:&#x2F;&#x2F;&#x2F;&#x2F;        在此函数中，我们在全局变量中保存实例句柄并&#x2F;&#x2F;        创建和显示主程序窗口。&#x2F;&#x2F;BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123;   hInst &#x3D; hInstance; &#x2F;&#x2F; 将实例句柄存储在全局变量中   HWND hWnd &#x3D; CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);   if (!hWnd)   &#123;      return FALSE;   &#125;   ShowWindow(hWnd, nCmdShow);   UpdateWindow(hWnd);   return TRUE;&#125;&#x2F;&#x2F;&#x2F;&#x2F;  函数: WndProc(HWND, UINT, WPARAM, LPARAM)&#x2F;&#x2F;&#x2F;&#x2F;  目标: 处理主窗口的消息。&#x2F;&#x2F;&#x2F;&#x2F;  WM_COMMAND  - 处理应用程序菜单&#x2F;&#x2F;  WM_PAINT    - 绘制主窗口&#x2F;&#x2F;  WM_DESTROY  - 发送退出消息并返回&#x2F;&#x2F;&#x2F;&#x2F;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123;    switch (message)    &#123;    case WM_COMMAND:        &#123;            int wmId &#x3D; LOWORD(wParam);            &#x2F;&#x2F; 分析菜单选择:            switch (wmId)            &#123;            case IDM_ABOUT:                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);                break;            case IDM_EXIT:                DestroyWindow(hWnd);                break;            default:                return DefWindowProc(hWnd, message, wParam, lParam);            &#125;        &#125;        break;    case WM_PAINT:        &#123;            PAINTSTRUCT ps;            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...            EndPaint(hWnd, &amp;ps);        &#125;        break;    case WM_DESTROY:        PostQuitMessage(0);        break;        default:        return DefWindowProc(hWnd, message, wParam, lParam);    &#125;    return 0;&#125;&#x2F;&#x2F; “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123;    UNREFERENCED_PARAMETER(lParam);    switch (message)    &#123;    case WM_INITDIALOG:        return (INT_PTR)TRUE;    case WM_COMMAND:        if (LOWORD(wParam) &#x3D;&#x3D; IDOK || LOWORD(wParam) &#x3D;&#x3D; IDCANCEL)        &#123;            EndDialog(hDlg, LOWORD(wParam));            return (INT_PTR)TRUE;        &#125;        break;    &#125;    return (INT_PTR)FALSE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们尝试加点东西，留心到</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在switch语句下面添加点东西（有注释//）:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123;    LPCWSTR msg_str1 &#x3D; L&quot;你单击了左键（乐）&quot;;&#x2F;&#x2F;    LPCWSTR msg_str2 &#x3D; L&quot;你单击了右键（乐）&quot;;&#x2F;&#x2F;    LPCWSTR title_str &#x3D; L&quot;这是一个标题&quot;;&#x2F;&#x2F;    switch (message)    &#123;    case WM_COMMAND:        &#123;            int wmId &#x3D; LOWORD(wParam);            &#x2F;&#x2F; 分析菜单选择:            switch (wmId)            &#123;            case IDM_ABOUT:                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);                break;            case IDM_EXIT:                DestroyWindow(hWnd);                break;            default:                return DefWindowProc(hWnd, message, wParam, lParam);            &#125;        &#125;        break;    case WM_PAINT:        &#123;            PAINTSTRUCT ps;            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...            EndPaint(hWnd, &amp;ps);        &#125;        break;    case WM_DESTROY:        PostQuitMessage(0);        break;    case WM_LBUTTONDOWN:&#x2F;&#x2F;        MessageBoxW(NULL,msg_str1,title_str, MB_OKCANCEL);&#x2F;&#x2F;        break;&#x2F;&#x2F;    case WM_RBUTTONDOWN:&#x2F;&#x2F;        MessageBoxW(NULL, msg_str2, title_str, MB_OKCANCEL);&#x2F;&#x2F;        break;&#x2F;&#x2F;    default:        return DefWindowProc(hWnd, message, wParam, lParam);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是我们频繁点击会产生大量的窗口！那就更改父窗口就好了，传入一个句柄！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">case WM_LBUTTONDOWN:    MessageBoxW(hWnd,msg_str1,title_str, MB_OKCANCEL);    break;case WM_RBUTTONDOWN:    MessageBoxW(hWnd, msg_str2, title_str, MB_OKCANCEL);    break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在就好了！</p><p><img src="image-20230514113233694.png" alt="image-20230514113233694"></p><p><img src="image-20230514113445737.png" alt="image-20230514113445737"></p><p><img src="image-20230514113504873.png" alt="image-20230514113504873"></p><h2 id="读取文件demo"><a href="#读取文件demo" class="headerlink" title="读取文件demo"></a>读取文件demo</h2><p>​        在Windows下，使用</p><pre class="line-numbers language-none"><code class="language-none">CreateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        宏来打开并创建一个文件句柄！</p><blockquote><p>from Microsoft API</p></blockquote><h2 id="read-file"><a href="#read-file" class="headerlink" title="read file"></a>read file</h2><p>​        我们使用readFile来读取文件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;iostream&gt;#define BUFSIZE 256#include&lt;tchar.h&gt;11int main()&#123;setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;); &#x2F;&#x2F; 设置正确的编码环境，防止读取乱码！HANDLE hFileRead;&#x2F;&#x2F; 创建文件句柄hFileRead &#x3D; CreateFile(L&quot;1.txt&quot;, GENERIC_READ, FILE_SHARE_READ, \NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);if (hFileRead &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;printf(&quot;Error in open the file:%x&quot;,GetLastError());&#125;DWORD nIn &#x3D; 0;CHAR buffer[BUFSIZE];while (ReadFile(hFileRead, buffer, BUFSIZE, &amp;nIn, NULL) &amp;&amp; nIn &gt; 0) &#123;printf(&quot;%s\n&quot;, buffer);&#125;CloseHandle(hFileRead);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230514113206643.png" alt="image-20230514113206643"></p><h3 id="createFileW-函数-fileapi-h"><a href="#createFileW-函数-fileapi-h" class="headerlink" title="createFileW 函数 (fileapi.h)"></a>createFileW 函数 (fileapi.h)</h3><p>​        创建或打开文件或 I/O 设备。 最常用的 I/O 设备如下所示：文件、文件流、目录、物理磁盘、卷、控制台缓冲区、磁带驱动器、通信资源、mailslot 和管道。 该函数返回一个句柄，该句柄可用于访问不同类型的 I/O 的文件或设备，具体取决于文件或设备以及指定的标志和属性。</p><p>若要将此操作作为事务处理操作执行，这会导致可用于事务处理 I/O 的句柄，请使用 CreateFileTransacted 函数。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">HANDLE CreateFileW(  [in]           LPCWSTR               lpFileName,  [in]           DWORD                 dwDesiredAccess,  [in]           DWORD                 dwShareMode,  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,  [in]           DWORD                 dwCreationDisposition,  [in]           DWORD                 dwFlagsAndAttributes,  [in, optional] HANDLE                hTemplateFile);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数<br>        [in] lpFileName</p><p>​        要创建或打开的文件或设备的名称。 可以在此名称中使用正斜杠 (/) 或反斜杠 () 。</p><p>​        在此函数的 ANSI 版本中，名称限制为 MAX_PATH 个字符。 若要将此限制扩展到 32，767 宽字符，请使用此 Unicode 版本的函数，并将“\\？\”前面附加到路径。 有关详细信息，请参阅命名文件、路径和命名空间。</p><p>​        有关特殊设备名称的信息，请参阅 定义 MS-DOS 设备名称。</p><p>​        若要创建文件流，请指定文件的名称、冒号，然后指定流的名称。 有关详细信息，请参阅 文件流。</p><p>​        提示从Windows 10版本 1607 开始，对于此函数的 unicode 版本 (CreateFileW) ，你可以选择加入以删除MAX_PATH限制，而无需附加“\\？\”。 有关详细信息，请参阅 命名文件、路径和命名空间 的“最大路径长度限制”部分。<br>[in] dwDesiredAccess</p><p>​        请求对文件或设备的访问权限，可汇总为读取、写入或两者均不) 。</p><p>​        最常用的值是 GENERIC_READ、 GENERIC_WRITE或两者 () GENERIC_READ | GENERIC_WRITE 。 有关详细信息，请参阅 通用访问权限、 文件安全性和访问权限、 文件访问权限常量和 ACCESS_MASK。</p><p>​        如果此参数为零，则应用程序可以在不访问该文件或设备的情况下查询某些元数据，例如文件、目录或设备属性，即使 拒绝了GENERIC_READ 访问。</p><p>​        不能请求与已打开句柄的打开请求中 dwShareMode 参数指定的共享模式冲突的访问模式。</p><p>​        有关详细信息，请参阅本主题的“备注”部分和 “创建和打开文件”。</p><p>​        [in] dwShareMode</p><p>​        文件或设备请求的共享模式，可以读取、写入、删除、所有这些或无 (引用下表) 。 对属性或扩展属性的访问请求不受此标志的影响。</p><p>​        如果此参数为零且 CreateFile 成功，则文件或设备无法共享，并且无法在文件或设备的句柄关闭之前再次打开。 有关详细信息，请参见“备注”部分。</p><p>​        无法请求与具有打开句柄的现有请求中指定的访问模式冲突的共享模式。 CreateFile 将失败， GetLastError 函数将返回 ERROR_SHARING_VIOLATION。</p><p>​        若要启用进程在打开文件或设备时共享文件或设备，请使用以下一个或多个值的兼容组合。 有关此参数与 dwDesiredAccess 参数的有效组合的详细信息，请参阅 创建和打开文件。</p><p>​        <strong>注意</strong> 无论进程上下文如何，每个打开句柄的共享选项都将有效，直到该句柄关闭。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>0</strong>0x00000000</td><td style="text-align:left">如果文件或设备请求删除、读取或写入访问权限，则阻止对文件或设备上的后续打开操作。</td></tr><tr><td style="text-align:left"><strong>FILE_SHARE_DELETE</strong>0x00000004</td><td style="text-align:left">在文件或设备上启用后续打开操作以请求删除访问权限。否则，如果文件或设备请求删除访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以删除访问权限，则函数将失败。<strong>注意</strong> 删除访问权限允许删除和重命名操作。</td></tr><tr><td style="text-align:left"><strong>FILE_SHARE_READ</strong>0x00000001</td><td style="text-align:left">在文件或设备上启用后续打开操作以请求读取访问权限。否则，如果文件或设备请求读取访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以供读取访问，则函数将失败。</td></tr><tr><td style="text-align:left"><strong>FILE_SHARE_WRITE</strong>0x00000002</td><td style="text-align:left">在文件或设备上启用后续打开操作以请求写入访问权限。否则，如果文件或设备请求写入访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开进行写入访问或具有写入访问权限的文件映射，则函数将失败。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpSecurityAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向包含两个独立但相关数据成员的 <a href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES</a>) 结构的指针：可选的安全描述符，以及一个布尔值，该值确定返回的句柄是否可以由子进程继承。</p><p>​        此参数可以为 NULL。</p><p>​        如果此参数为 <strong>NULL</strong>，则 <strong>由 CreateFile</strong> 返回的句柄不能由应用程序可能创建的任何子进程继承，并且与返回的句柄关联的文件或设备获取默认的安全描述符。</p><p>​        结构的 <strong>lpSecurityDescriptor</strong> 成员指定文件或设备的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> 。 如果此成员为 <strong>NULL</strong>，则会为与返回的句柄关联的文件或设备分配一个默认的安全描述符。</p><p>​        <strong>CreateFile</strong> 在打开现有文件或设备时忽略 <strong>lpSecurityDescriptor</strong> 成员，但继续使用 <strong>bInheritHandle</strong> 成员。</p><p>​        结构的 <strong>bInheritHandle</strong> 成员指定是否可以继承返回的句柄。</p><p>​        有关详细信息，请参见“备注”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in] dwCreationDisposition<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        对存在或不存在的文件或设备执行的操作。</p><p>​        对于文件以外的设备，此参数通常设置为 <strong>OPEN_EXISTING</strong>。</p><p>​        有关详细信息，请参见“备注”部分。</p><p>​        此参数必须是以下值之一，不能合并：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>CREATE_ALWAYS</strong>2</td><td style="text-align:left">始终创建新文件。如果指定的文件存在且可写，则函数将覆盖文件、函数成功，最后错误代码设置为 <strong>ERROR_ALREADY_EXISTS</strong> (183) 。如果指定的文件不存在且路径有效，则会创建一个新文件，该函数成功，最后一个错误代码设置为零。有关详细信息，请参阅本主题的“备注”部分。</td></tr><tr><td style="text-align:left"><strong>CREATE_NEW</strong>1</td><td style="text-align:left">仅当该文件尚不存在时才创建一个新文件。如果指定的文件存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_EXISTS (</strong> 80) 。如果指定的文件不存在并且是可写位置的有效路径，则会创建新文件。</td></tr><tr><td style="text-align:left"><strong>OPEN_ALWAYS</strong>4</td><td style="text-align:left">始终打开文件。如果指定文件存在，则函数成功，最后一个错误代码设置为 <strong>ERROR_ALREADY_EXISTS (</strong> 183) 。如果指定的文件不存在并且是可写位置的有效路径，则函数将创建一个文件，最后一个错误代码设置为零。</td></tr><tr><td style="text-align:left"><strong>OPEN_EXISTING</strong>3</td><td style="text-align:left">仅当文件或设备存在时，才打开该文件或设备。如果指定的文件或设备不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND (</strong> 2) 。有关设备的详细信息，请参阅“备注”部分。</td></tr><tr><td style="text-align:left"><strong>TRUNCATE_EXISTING</strong>5</td><td style="text-align:left">打开文件并截断该文件，使其大小为零字节，仅当它存在时。如果指定的文件不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND</strong> (2) 。调用过程必须打开文件，并将 <strong>GENERIC_WRITE</strong> 位设置为 <em>dwDesiredAccess</em> 参数的一部分。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[in] dwFlagsAndAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件或设备属性和标志， <strong>FILE_ATTRIBUTE_NORMAL</strong> 是文件最常见的默认值。</p><p>​        此参数可以包含可用文件属性的任意组合， <strong>(FILE_ATTRIBUTE_*</strong>) 。 所有其他文件属性都替代 <strong>FILE_ATTRIBUTE_NORMAL</strong>。</p><p>​        此参数还可以包含标志组合 <strong>， (FILE_FLAG_)</strong> <em>来控制文件或设备缓存行为、访问模式和其他特殊用途标志。 这些值与任何 <strong>FILE_ATTRIBUTE_</strong></em> 值结合使用。</p><p>​        此参数还可以通过指定 <strong>SECURITY_SQOS_PRESENT</strong> 标志来包含安全服务质量 (SQOS) 信息。 下表显示了其他与 SQOS 相关的标志信息，这些属性和标志表如下。</p><p>​        <strong>注意当CreateFile</strong> 打开现有文件时，它通常将文件标志与现有文件的文件属性组合在一起，并忽略作为 <em>dwFlagsAndAttributes</em> 的一部分提供的任何文件属性。 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”中详细介绍了特殊情况。</p><p>​        以下某些文件属性和标志只能应用于文件，不一定是 <strong>CreateFile</strong> 可以打开的所有其他类型的设备。 有关详细信息，请参阅本主题的“备注”部分和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。    </p><p>​        有关对文件属性的更高级访问，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>。 有关所有文件属性及其值和说明的完整列表，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-attribute-constants">文件属性常量</a>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Attribute</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_ARCHIVE</strong>32 (0x20)</td><td style="text-align:left">该文件应存档。 应用程序使用此属性来标记要备份或删除的文件。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_ENCRYPTED</strong>16384 (0x4000)</td><td style="text-align:left">此文件或目录已加密。 对于文件来说，表示文件中的所有数据都是加密的。 对于目录，这意味着加密是新创建的文件和子目录的默认值。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。如果还指定 <strong>了FILE_ATTRIBUTE_SYSTEM</strong> ，则此标志无效。家庭版、家庭高级版、初学者版或 ARM 版 Windows 不支持此标志。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_HIDDEN</strong>2 (0x2)</td><td style="text-align:left">文件被隐藏。 不要将其包含在普通目录列表中。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_NORMAL</strong>128 (0x80)</td><td style="text-align:left">该文件没有设置其他属性。 此属性仅在单独使用时有效。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_OFFLINE</strong>4096 (0x1000)</td><td style="text-align:left">文件的数据不能立即可用。 此属性指示文件数据以物理方式移动到脱机存储。 此属性由远程存储（分层存储管理软件）使用。 应用程序不应随意更改此属性。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_READONLY</strong>1 (0x1)</td><td style="text-align:left">文件为只读文件。 应用程序可以读取文件，但无法写入或删除该文件。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_SYSTEM</strong>4 (0x4)</td><td style="text-align:left">该文件是操作系统的一部分或完全使用的文件。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_TEMPORARY</strong>256 (0x100)</td><td style="text-align:left">该文件用于临时存储。有关详细信息，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">标志</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>FILE_FLAG_BACKUP_SEMANTICS</strong>0x02000000</td><td style="text-align:left">正在为备份或还原操作打开或创建该文件。 系统确保调用进程在进程具有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权时替代文件安全检查。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/changing-privileges-in-a-token">更改令牌中的特权</a>。必须设置此标志才能获取目录的句柄。 目录句柄可以传递给某些函数，而不是文件句柄。 有关详细信息，请参见“备注”部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_DELETE_ON_CLOSE</strong>0x04000000</td><td style="text-align:left">文件在其所有句柄都关闭后立即被删除，其中包括指定的句柄和任何其他打开或重复的句柄。如果文件存在现有的打开句柄，则调用会失败，除非这些句柄都使用 <strong>FILE_SHARE_DELETE</strong> 共享模式打开。针对文件的后续打开请求将失败，除非指定 FILE_SHARE_DELETE 共享模式。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_NO_BUFFERING</strong>0x20000000</td><td style="text-align:left">文件或设备正在打开，没有系统缓存来读取和写入数据。 此标志不会影响硬盘缓存或内存映射文件。使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <strong>CreateFile</strong> 打开的文件有严格的要求，有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_OPEN_NO_RECALL</strong>0x00100000</td><td style="text-align:left">请求文件数据，但它应继续位于远程存储中。 不应将其传输回本地存储。 此标志供远程存储系统使用。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>0x00200000</td><td style="text-align:left">不会进行正常的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/reparse-points">重新分析点</a> 处理; <strong>CreateFile</strong> 将尝试打开重新分析点。 打开文件时，将返回文件句柄，无论控制重新分析点的筛选器是否正常运行。此标志不能与 <strong>CREATE_ALWAYS</strong> 标志一起使用。如果文件不是重新分析点，则忽略此标志。有关详细信息，请参见“备注”部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_OVERLAPPED</strong>0x40000000</td><td style="text-align:left">文件或设备正在为异步 I/O 打开或创建。在此句柄上完成后续 I/O 操作时， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件将设置为信号状态。如果指定了此标志，则该文件可用于同时读取和写入操作。如果未指定此标志，则即使对读取和写入函数的调用指定 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">了 OVERLAPPED</a> 结构，I/O 操作也会序列化。有关使用此标志创建的文件句柄时的注意事项，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#synchronous_and_asynchronous_i_o_handles">同步和异步 I/O 句柄</a> 部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_POSIX_SEMANTICS</strong>0x01000000</td><td style="text-align:left">访问将根据 POSIX 规则进行。 这包括允许具有名称的多个文件，仅在支持该命名的文件系统时有所不同。 使用此选项时应小心，因为使用此标志创建的文件可能无法由为 MS-DOS 或 16 位 Windows 编写的应用程序访问。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_RANDOM_ACCESS</strong>0x10000000</td><td style="text-align:left">访问是随机的。 系统可将此选项用作优化文件缓存的提示。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_SESSION_AWARE</strong>0x00800000</td><td style="text-align:left">文件或设备正在使用会话感知打开。 如果未指定此标志，则会话中的每个会话设备 (（例如使用 RemoteFX USB 重定向的设备) ）无法由会话 0 中运行的进程打开。 对于不在会话 0 中的调用方，此标志无效。 此标志仅在 Windows 的服务器版本上受支持。<strong>Windows Server 2008 R2 和 Windows Server 2008：</strong> Windows Server 2012之前不支持此标志。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong>0x08000000</td><td style="text-align:left">访问旨在从头到尾的顺序。 系统可将此选项用作优化文件缓存的提示。如果读取隐藏 (（即使用反向扫描) ），则不应使用此标志。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_WRITE_THROUGH</strong>0x80000000</td><td style="text-align:left">写入操作不会经历任何中间缓存，它们将直接转到磁盘。有关详细信息，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td></tr></tbody></table></div><p><em>dwFlagsAndAttributes</em> 参数还可以指定 SQOS 信息。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/impersonation-levels">模拟级别</a>。 当调用应用程序将 <strong>SECURITY_SQOS_PRESENT</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分时，它还可以包含以下一个或多个值。</p><div class="table-container"><table><thead><tr><th style="text-align:left">安全标志</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>SECURITY_ANONYMOUS</strong></td><td style="text-align:left">模拟匿名模拟级别的客户端。</td></tr><tr><td style="text-align:left"><strong>SECURITY_CONTEXT_TRACKING</strong></td><td style="text-align:left">安全跟踪模式是动态的。 如果未指定此标志，则安全跟踪模式是静态的。</td></tr><tr><td style="text-align:left"><strong>SECURITY_DELEGATION</strong></td><td style="text-align:left">模拟委托模拟级别的客户端。</td></tr><tr><td style="text-align:left"><strong>SECURITY_EFFECTIVE_ONLY</strong></td><td style="text-align:left">只有客户端安全上下文的已启用方面可供服务器使用。 如果未指定此标志，则客户端安全上下文的所有方面都可用。这允许客户端限制服务器在模拟客户端时可以使用的组和特权。</td></tr><tr><td style="text-align:left"><strong>SECURITY_IDENTIFICATION</strong></td><td style="text-align:left">模拟标识模拟级别的客户端。</td></tr><tr><td style="text-align:left"><strong>SECURITY_IMPERSONATION</strong></td><td style="text-align:left">模拟模拟级别的客户端。 如果未指定其他标志以及 <strong>SECURITY_SQOS_PRESENT</strong> 标志，则这是默认行为。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[in, optional] hTemplateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        具有 <strong>GENERIC_READ</strong> 访问权限的模板文件的有效句柄。 模板文件为正在创建的文件提供文件属性和扩展属性。</p><p>​        此参数可以为 NULL。</p><p>​        打开现有文件时， <strong>CreateFile</strong> 将忽略此参数。</p><p>​        打开新的加密文件时，该文件将从其父目录继承任意访问控制列表。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是指定文件、设备、命名管道或邮件槽的打开句柄。</p><p>​        如果函数失败，则返回值为 INVALID_HANDLE_VALUE。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>​        <strong>CreateFile</strong> 最初专为文件交互而开发，但此后已扩展和增强，以包括 Windows 开发人员可用的大多数其他类型的 I/O 设备和机制。 本部分尝试介绍开发人员在不同上下文中使用不同的 I/O 类型使用 <strong>CreateFile</strong> 时可能遇到的各种问题。 仅当专门引用存储在文件系统上实际文件中的数据时，文本才会尝试使用单词 <em>文件</em> 。 但是，某些文件用法可能更普遍地引用支持类似 <em>文件的</em> I/O 对象。 由于前面提到的历史原因，这种自由使用术语 <em>文件</em> 在常量名称和参数名称中尤其普遍。</p><p>​        使用 <strong>CreateFile</strong> 返回的对象句柄完成应用程序后，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数关闭句柄。 这不仅释放了系统资源，而且可以对共享文件或设备以及将数据提交到磁盘等内容产生更广泛的影响。 本主题中会相应地说明具体内容。</p><p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 如果尝试打开文件或目录以在远程计算机上删除，则发生共享冲突，当 <em>dwDesiredAccess</em> 参数的值是使用任何其他访问标志 (0x00010000) <strong>OR’ed</strong> 的 <strong>DELETE</strong> 访问标志，并且远程文件或目录尚未使用<strong>FILE_SHARE_DELETE</strong>打开。 为了避免此方案中的共享冲突，请仅打开具有 <strong>DELETE</strong> 访问权限的远程文件或目录，或者调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> ，而无需首先打开文件或目录进行删除。</p><p>​        某些文件系统（如 NTFS 文件系统）支持单个文件和目录的压缩或加密。 对于具有此支持的装载文件系统的卷，新文件继承其目录的压缩和加密属性。</p><p>​        不能使用 <strong>CreateFile</strong> 来控制文件或目录上的压缩、解压缩或解密。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">创建和打开文件</a>、 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-compression-and-decompression">文件压缩和解压缩</a>以及 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p><p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 出于向后兼容性目的，在 <em>lpSecurityAttributes</em> 中指定安全描述符时，<strong>CreateFile</strong> 不会应用继承规则。 为了支持继承，以后查询此文件的安全描述符的函数可能会启发性地确定并报告继承是否有效。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">可继承 ACE 的自动传播</a>。</p><p>​        如前所述，如果 <em>lpSecurityAttributes</em> 参数为 <strong>NULL</strong>，则应用程序可能创建的任何子进程都无法继承 <strong>CreateFile</strong> 返回的句柄。 有关此参数的以下信息也适用：</p><ul><li>如果 <strong>bInheritHandle</strong> 成员变量不是 <strong>FALSE</strong>，这是任何非零值，则可以继承句柄。 因此，如果不希望句柄可继承，则此结构成员必须正确初始化为 <strong>FALSE</strong> 。</li><li>访问控制列表 (文件或目录的默认安全描述符中的 ACL) 继承自其父目录。</li><li>目标文件系统必须支持 <strong>lpSecurityDescriptor</strong> 成员对文件和目录的安全性，才能对其产生影响，这可以通过 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">使用 GetVolumeInformation</a> 来确定。</li></ul><p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">请参阅备注</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">请参阅备注</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        请注意，如果对已打开的备用数据流的文件执行，具有取代处置的 <strong>CreateFile</strong> 将失败。</p><h4 id="符号链接行为"><a href="#符号链接行为" class="headerlink" title="符号链接行为"></a>符号链接行为</h4><p>​        如果对此函数的调用创建文件，则行为没有变化。 此外，请考虑有关 <strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>的以下信息：</p><ul><li>如果指定了FILE_FLAG_OPEN_REPARSE_POINT<ul><li>如果打开现有文件并且它是符号链接，则返回的句柄是符号链接的句柄。</li><li>如果指定 <strong>了TRUNCATE_EXISTING</strong> 或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是符号链接。</li></ul></li><li>如果未指定FILE_FLAG_OPEN_REPARSE_POINT：<ul><li>如果打开现有文件并且它是符号链接，则返回的句柄是目标句柄。</li><li>如果指定 <strong>CREATE_ALWAYS</strong>、 <strong>TRUNCATE_EXISTING</strong>或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是目标。</li></ul></li></ul><h4 id="缓存行为"><a href="#缓存行为" class="headerlink" title="缓存行为"></a>缓存行为</h4><p><strong>CreateFile</strong> 使用 <em>dwFlagsAndAttributes</em> 参数的多个可能值来控制或影响系统缓存与句柄关联的数据的方式。 它们是：</p><ul><li><strong>FILE_FLAG_NO_BUFFERING</strong></li><li><strong>FILE_FLAG_RANDOM_ACCESS</strong></li><li><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong></li><li><strong>FILE_FLAG_WRITE_THROUGH</strong></li><li><strong>FILE_ATTRIBUTE_TEMPORARY</strong></li></ul><p>如果未指定这些标志，系统将使用默认的常规用途缓存方案。 否则，系统缓存的行为与为每个标志指定。</p><p>不应合并其中一些标志。 例如，将 <strong>FILE_FLAG_RANDOM_ACCESS</strong> 与 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 相结合是自败。</p><p>指定 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 标志可以提高使用顺序访问读取大型文件的应用程序的性能。 对于主要按顺序读取大型文件的应用程序，性能提升可能更加明显，但偶尔会跳过小范围的字节。 如果应用程序移动文件指针进行随机访问，则很可能不会发生最佳缓存性能。 但是，仍可以保证正确的操作。</p><p><strong>标志FILE_FLAG_WRITE_THROUGH</strong>和<strong>FILE_FLAG_NO_BUFFERING</strong>是独立的，可以组合在一起。</p><p>如果使用 <strong>FILE_FLAG_WRITE_THROUGH</strong> 但 <strong>未指定FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存生效，则数据会写入系统缓存，但不会延迟地刷新到磁盘。</p><p>如果 <strong>同时指定了FILE_FLAG_WRITE_THROUGH</strong> 和 <strong>FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存无效，则数据会立即刷新到磁盘，而无需通过 Windows 系统缓存。 操作系统还会向永久性媒体请求硬盘本地硬件缓存的写入。</p><p><strong>注意</strong> 并非所有硬盘硬件都支持此写通功能。</p><p>正确使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志需要特殊的应用程序注意事项。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p><p>通过 <strong>FILE_FLAG_WRITE_THROUGH</strong> 的写通请求还会导致 NTFS 刷新任何元数据更改，例如时间戳更新或重命名操作，这会导致处理请求。 因此， <strong>FILE_FLAG_WRITE_THROUGH</strong> 标志通常与 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志一起使用，作为每次写入后调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数的替代项，这可能会导致不必要的性能损失。 将这些标志一起使用可避免这些处罚。 有关文件和元数据缓存的一般信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-caching">文件缓存</a>。</p><p><strong>当FILE_FLAG_NO_BUFFERING</strong>与<strong>FILE_FLAG_OVERLAPPED</strong>结合使用时，标志提供最大的异步性能，因为 I/O 不依赖于内存管理器的同步操作。 但是，某些 I/O 操作需要更多时间，因为缓存中未保留数据。 此外，在创建空文件) 时，文件元数据仍可能 (缓存。 若要确保元数据刷新到磁盘，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数。</p><p>如果有足够的缓存内存可用，则指定 <strong>FILE_ATTRIBUTE_TEMPORARY</strong> 属性会导致文件系统避免将数据写回到大容量存储，因为应用程序在关闭句柄后删除临时文件。 在这种情况下，系统可以完全避免写入数据。 尽管它不直接控制数据缓存的方式与前面提到的标志相同， <strong>但FILE_ATTRIBUTE_TEMPORARY</strong> 属性确实会告知系统在系统缓存中尽可能多地保留，而无需写入，因此可能对某些应用程序感到担忧。</p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>如果重命名或删除文件，然后在不久后还原该文件，系统将在缓存中搜索要还原的文件信息。 缓存信息包括其短/长名称对和创建时间。</p><p>如果在之前调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> 时挂起删除的文件上调用 <strong>CreateFile</strong>，该函数将失败。 操作系统会延迟文件删除，直到文件的所有句柄都关闭。 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_ACCESS_DENIED</strong>。</p><p><em>dwDesiredAccess</em> 参数可以是零，允许应用程序在不访问文件的情况下查询文件属性（如果应用程序正在运行且具有足够的安全设置）。 这可用于测试文件是否存在，而无需打开该文件进行读取和/或写入访问，或获取有关文件或目录的其他统计信息。 请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/obtaining-and-setting-file-information">获取和设置文件信息和</a><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>。</p><p>如果指定 <strong>了CREATE_ALWAYS</strong> 和 <strong>FILE_ATTRIBUTE_NORMAL</strong> ， <strong>则 CreateFile</strong> 将失败，并将最后一个错误设置为 <strong>ERROR_ACCESS_DENIED</strong> （如果文件存在并且具有 <strong>FILE_ATTRIBUTE_HIDDEN</strong> 或 <strong>FILE_ATTRIBUTE_SYSTEM</strong> 属性）。 若要避免此错误，请指定与现有文件相同的属性。</p><p>当应用程序跨网络创建文件时，最好将 <em>dwDesiredAccess 用于 dwDesiredAccess</em>，而不是单独使用 <strong>GENERIC_WRITE</strong>。<code>GENERIC_READ | GENERIC_WRITE</code> 生成的代码速度更快，因为重定向程序可以使用缓存管理器，并发送更少的 SMB 和更多数据。 这种组合还避免了写入网络中的文件偶尔会返回 <strong>ERROR_ACCESS_DENIED</strong>的问题。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。</p><h4 id="同步和异步-I-O-句柄"><a href="#同步和异步-I-O-句柄" class="headerlink" title="同步和异步 I/O 句柄"></a>同步和异步 I/O 句柄</h4><p><strong>CreateFile</strong> 用于创建同步或异步的文件或设备句柄。 同步句柄的行为使使用该句柄的 I/O 函数调用被阻止，直到它们完成，而异步文件句柄使系统能够立即从 I/O 函数调用返回，无论它们是否完成了 I/O 操作。 如前所述，此同步与异步行为通过指定 <em>dwFlagsAndAttributes</em> 参数中的<strong>FILE_FLAG_OVERLAPPED</strong>来确定。 使用异步 I/O 时存在多种复杂性和潜在缺陷;有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p><h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><p>在 NTFS 文件系统上，可以使用 <strong>CreateFile</strong> 在文件中创建单独的流。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-streams">文件流</a>。</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>应用程序无法使用 <strong>CreateFile</strong> 创建目录，因此对于此用例，只有 <strong>OPEN_EXISTING</strong> 值对 <em>dwCreationDisposition</em> 有效。 若要创建目录，应用程序必须调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>。</p><p>若要使用 <strong>CreateFile</strong> 打开目录，请将 <strong>FILE_FLAG_BACKUP_SEMANTICS</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分。 在没有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权的情况下使用此标志时，仍适用适当的安全检查。</p><p>使用 <strong>CreateFile</strong> 在对 FAT 或 FAT32 文件系统卷进行碎片整理期间打开目录时，请不要指定 <strong>MAXIMUM_ALLOWED</strong> 访问权限。 如果这样做，则拒绝对目录的访问。 请改为指定 <strong>GENERIC_READ</strong> 访问权限。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-directory-management">“关于目录管理</a>”。</p><h4 id="物理磁盘和卷"><a href="#物理磁盘和卷" class="headerlink" title="物理磁盘和卷"></a>物理磁盘和卷</h4><p>对磁盘或卷的直接访问受到限制。</p><p><strong>Windows Server 2003 和 Windows XP：</strong> 以这种方式不限制对磁盘或卷的直接访问。</p><p>可以使用 <strong>CreateFile</strong> 函数打开物理磁盘驱动器或卷，该驱动器返回直接访问存储设备 (DASD) 句柄，该句柄可与 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数一起使用。 这样，便可以直接访问磁盘或卷，例如分区表等磁盘元数据。 但是，这种类型的访问也会向潜在的数据丢失公开磁盘驱动器或卷，因为使用此机制对磁盘进行不正确的写入可能会使其内容无法访问操作系统。 为了确保数据完整性，请务必熟悉 <strong>DeviceIoControl</strong> ，以及其他 API 的行为方式与直接访问句柄不同，而不是文件系统句柄。</p><p>必须满足以下要求才能成功进行此类调用：</p><ul><li>调用方必须具有管理权限。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/running-with-special-privileges">使用特殊特权运行</a>。</li><li><em>dwCreationDisposition</em> 参数必须具有<strong>OPEN_EXISTING</strong>标志。</li><li>打开卷或软盘时， <em>dwShareMode</em> 参数必须具有 <strong>FILE_SHARE_WRITE</strong> 标志。</li></ul><p><strong>注意*</strong>dwDesiredAccess* 参数可以是零，允许应用程序在不访问设备的情况下查询设备属性。 这适用于应用程序来确定软盘驱动器的大小及其支持的格式，而无需驱动器中的软盘磁盘，例如。 它还可用于读取统计信息，而无需更高级别的数据读取/写入权限。</p><p>打开物理驱动器 <em>x</em>：时， <em>lpFileName</em> 字符串应采用以下形式：“.\PhysicalDrive<em>X</em>”。 硬盘编号从零开始。 下表显示了物理驱动器字符串的一些示例。</p><div class="table-container"><table><thead><tr><th style="text-align:left">String</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">“\.\PhysicalDrive0”</td><td style="text-align:left">打开第一个物理驱动器。</td></tr><tr><td style="text-align:left">“\.\PhysicalDrive2”</td><td style="text-align:left">打开第三个物理驱动器。</td></tr></tbody></table></div><p>若要获取卷的物理驱动器标识符，请打开卷的句柄，并使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-ioctl_volume_get_volume_disk_extents">IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS</a> 调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数。 此控制代码返回每个卷的一个或多个盘区的磁盘数和偏移量;卷可以跨越多个物理磁盘。</p><p>有关打开物理驱动器的示例，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/calling-deviceiocontrol">调用 DeviceIoControl</a>。</p><p>例如，打开卷或可移动媒体驱动器 (时，软盘驱动器或闪存内存拇指驱动器) ， <em>lpFileName</em> 字符串应采用以下形式：“.*X*：”。 请勿使用尾随反斜杠 () ，指示驱动器的根目录。 下表显示了驱动器字符串的一些示例。</p><div class="table-container"><table><thead><tr><th style="text-align:left">String</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">“\.\A：”</td><td style="text-align:left">打开软盘驱动器 A。</td></tr><tr><td style="text-align:left">“\.\C：”</td><td style="text-align:left">打开 C： 卷。</td></tr><tr><td style="text-align:left">“\.\C：\”</td><td style="text-align:left">打开 C： 卷的文件系统。</td></tr></tbody></table></div><p>还可以通过引用其卷名称打开卷。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-volume">命名卷</a>。</p><p>卷包含一个或多个装载的文件系统。 即使 <strong>CreateFile</strong> 中未指定非缓存选项，也可以按特定文件系统的任意方式打开卷句柄。 应假定所有 Microsoft 文件系统都以非缓存的形式打开卷句柄。 对文件的非缓存 I/O 的限制也适用于卷。</p><p>即使数据未缓存，文件系统也可能不需要缓冲区对齐。 但是，如果在打开卷时指定了非缓存选项，则会强制实施缓冲区对齐方式，而不管卷上的文件系统如何。 建议在所有文件系统上以非缓存方式打开卷句柄，并遵循非缓存 I/O 限制。</p><p><strong>注意</strong> 若要读取或写入卷的最后几个扇区，必须调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 并指定 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-fsctl_allow_extended_dasd_io">FSCTL_ALLOW_EXTENDED_DASD_IO</a>。 这表示文件系统驱动程序不会对分区读取或写入调用执行任何 I/O 边界检查。 相反，边界检查由设备驱动程序执行。</p><h4 id="更改器设备"><a href="#更改器设备" class="headerlink" title="更改器设备"></a>更改器设备</h4><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 的 <strong>IOCTL_CHANGER_*</strong> 控制代码接受变更器设备的句柄。 若要打开变更器设备，请使用以下格式的文件名：“\.\Changer<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的设备，从零开始。 若要在用 C 或 C++ 编写的应用程序中打开变更器设备零，请使用以下文件名：“\\.\\Changer0”。</p><h4 id="磁带驱动器"><a href="#磁带驱动器" class="headerlink" title="磁带驱动器"></a>磁带驱动器</h4><p>可以使用以下格式的文件名打开磁带驱动器：“\.\TAPE<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的驱动器，从磁带驱动器零开始。 若要在以 C 或 C++ 编写的应用程序中打开磁带驱动器零，请使用以下文件名：“\\.\\TAPE0”。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/Backup/backup">备份</a>。</p><h4 id="通信资源"><a href="#通信资源" class="headerlink" title="通信资源"></a>通信资源</h4><p><strong>CreateFile</strong> 函数可以创建通信资源的句柄，例如串行端口 COM1。 对于通信资源， <em>dwCreationDisposition</em> 参数必须 <strong>OPEN_EXISTING</strong>， <em>dwShareMode</em> 参数必须是零 (独占访问) ， <em>并且 hTemplateFile</em> 参数必须为 <strong>NULL</strong>。 可以指定读取、写入或读/写访问权限，并且可以为重叠 I/O 打开句柄。</p><p>若要指定大于 9 的 COM 端口号，请使用以下语法：“.\COM10”。 此语法适用于允许指定 COM 端口号的所有端口号和硬件。</p><p>有关通信的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/communications-resources">通信</a>。</p><h4 id="机"><a href="#机" class="headerlink" title="机"></a>机</h4><p><strong>CreateFile</strong> 函数可以创建控制台输入 (CONIN$) 句柄。 如果进程由于继承或重复而具有打开的句柄，则它还可以创建活动屏幕缓冲区 (CONOUT$) 的句柄。 调用进程必须附加到继承的控制台或 <a href="https://learn.microsoft.com/zh-cn/windows/console/allocconsole">由 AllocConsole</a> 函数分配的控制台。 对于控制台句柄，请按如下所示设置 <strong>CreateFile</strong> 参数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left">lpFileName</td><td style="text-align:left">使用 CONIN$ 值指定控制台输入。使用 CONOUT$ 值指定控制台输出。CONIN$ 获取控制台输入缓冲区的句柄，即使 <a href="https://learn.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 函数重定向标准输入句柄。 若要获取标准输入句柄，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a> 函数。CONOUT$ 获取活动屏幕缓冲区的句柄，即使 <a href="https://learn.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 重定向标准输出句柄。 若要获取标准输出句柄，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a>。</td></tr><tr><td style="text-align:left">dwDesiredAccess</td><td style="text-align:left">`GENERIC_READ</td><td>GENERIC_WRITE` 首选，但任一限制访问。</td></tr><tr><td style="text-align:left">dwShareMode</td><td style="text-align:left">打开 CONIN$时，请指定 <strong>FILE_SHARE_READ</strong>。 打开 CONOUT$时，请指定 <strong>FILE_SHARE_WRITE</strong>。如果调用进程继承控制台，或者子进程应能够访问控制台，则必须是 `FILE_SHARE_READ</td><td>FILE_SHARE_WRITE`此参数。</td></tr><tr><td style="text-align:left">lpSecurityAttributes</td><td style="text-align:left">如果希望继承控制台，<a href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES结构的</a>)<strong>bInheritHandle</strong> 成员必须为 <strong>TRUE</strong>。</td></tr><tr><td style="text-align:left">dwCreationDisposition</td><td style="text-align:left">使用 <strong>CreateFile</strong> 打开控制台时，应指定<strong>OPEN_EXISTING</strong>。</td></tr><tr><td style="text-align:left">dwFlagsAndAttributes</td><td style="text-align:left">已忽略。</td></tr><tr><td style="text-align:left">hTemplateFile</td><td style="text-align:left">已忽略。</td></tr></tbody></table></div><p>下表显示了 <em>dwDesiredAccess</em> 和 <em>lpFileName</em> 的各种设置。</p><div class="table-container"><table><thead><tr><th style="text-align:left">lpFileName</th><th style="text-align:left">dwDesiredAccess</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left">“CON”</td><td style="text-align:left"><strong>GENERIC_READ</strong></td><td style="text-align:left">打开用于输入的控制台。</td></tr><tr><td style="text-align:left">“CON”</td><td style="text-align:left"><strong>GENERIC_WRITE</strong></td><td style="text-align:left">打开用于输出的控制台。</td></tr><tr><td style="text-align:left">“CON”</td><td style="text-align:left">`GENERIC_READ</td><td style="text-align:left">GENERIC_WRITE`</td><td>导致 <strong>CreateFile</strong> 失败; <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_FILE_NOT_FOUND</strong>。</td></tr></tbody></table></div><h4 id="Mailslots"><a href="#Mailslots" class="headerlink" title="Mailslots"></a>Mailslots</h4><p>如果 <strong>CreateFile</strong> 打开 mailslot 的客户端端，则函数将返回 <strong>INVALID_HANDLE_VALUE</strong> 如果 mailslot 客户端尝试在 mailslot 服务器使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailSlot 函数创建本地 mailslot 之前打开本地 mailslot</a> 。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/mailslots">Mailslots</a>。</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>如果 <strong>CreateFile</strong> 打开命名管道的客户端端，该函数将使用处于侦听状态的命名管道的任何实例。 打开过程可以根据需要多次复制句柄，但在打开该句柄之后，另一个客户端无法打开命名管道实例。 打开管道时指定的访问必须与 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数的 <em>dwOpenMode</em> 参数中指定的访问兼容。</p><p>如果在此操作之前未在服务器上成功调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数，则管道将不存在， <strong>并且 CreateFile</strong> 将失败 <strong>并出现ERROR_FILE_NOT_FOUND</strong>。</p><p>如果至少有一个活动管道实例，但服务器上没有可用的侦听器管道，这意味着所有管道实例当前都已连接， <strong>则 CreateFile</strong> 会失败 <strong>并ERROR_PIPE_BUSY</strong>。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p><h3 id="ReadFile-函数-fileapi-h"><a href="#ReadFile-函数-fileapi-h" class="headerlink" title="ReadFile 函数 (fileapi.h)"></a>ReadFile 函数 (fileapi.h)</h3><p>从指定的文件或输入/输出 (I/O) 设备读取数据。 如果设备支持，则读取发生在文件指针指定的位置。</p><p>此函数适用于同步操作和异步操作。 有关专为异步操作设计的类似函数，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a>。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">ReadFile</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>                HANDLE       hFile<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span>               LPVOID       lpBuffer<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>                DWORD        nNumberOfBytesToRead<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>     LPDWORD      lpNumberOfBytesRead<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPOVERLAPPED lpOverlapped<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] hFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设备句柄 (例如文件、文件流、物理磁盘、卷、控制台缓冲区、磁带驱动器、套接字、通信资源、mailslot 或管道) 。</p><p>必须使用读取访问权限创建 <em>hFile</em> 参数。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/generic-access-rights">通用访问权限</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-security-and-access-rights">文件安全性和访问权限</a>。</p><p>对于异步读取操作，<em>hFile</em> 可以是使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 函数的<strong>FILE_FLAG_OVERLAPPED</strong>标志打开的任何句柄，也可以是套接字或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> 函数返回的<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-socket">套接字</a>句柄。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向接收从文件或设备读取数据的缓冲区的指针。</p><p>此缓冲区必须在读取操作期间保持有效。 在读取操作完成之前，调用方不得使用此缓冲区。</p><pre class="line-numbers language-none"><code class="language-none">[in] nNumberOfBytesToRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要读取的最多字节数。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpNumberOfBytesRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向使用同步 <em>hFile</em> 参数时接收读取的字节数的变量的指针。 <strong>ReadFile</strong> 将此值设置为零，然后再执行任何工作或错误检查。 如果这是一个异步操作，请对此参数使用 <strong>NULL</strong> ，以避免潜在的错误结果。</p><p>仅当 <em>lpOverlapped</em> 参数不为 <strong>NULL</strong> 时，此参数才可为 <strong>NULL</strong>。</p><p><strong>Windows 7：</strong> 此参数不能为 <strong>NULL</strong>。</p><p>有关详细信息，请参见“备注”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in, out, optional] lpOverlapped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em> 参数，则需要指向 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的指针，否则可为 <strong>NULL</strong>。</p><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，<em>则 lpOverlapped</em> 参数必须指向有效且唯一的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数无法错误地报告读取操作已完成。</p><p>对于支持字节偏移量的 <em>hFile</em> ，如果使用此参数，则必须指定从文件或设备开始读取的字节偏移量。 通过设置 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的 <strong>Offset</strong> 和 <strong>OffsetHigh</strong> 成员来指定此偏移量。 对于不支持字节偏移量的 <em>hFile</em>，将忽略 <strong>Offset 和 OffsetHigh</strong>。</p><p>有关 <em>lpOverlapped</em> 和 <strong>FILE_FLAG_OVERLAPPED</strong>的不同组合的详细信息，请参阅“备注”部分和 <strong>“同步和文件位置</strong> ”部分。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>如果函数成功，则返回值为非零 (<strong>TRUE</strong>) 。</p><p>如果函数失败或异步完成，则返回值为零， (<strong>FALSE</strong>) 。 若要获取扩展的错误信息，请调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数。</p><p><strong>注意</strong><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 代码<strong>ERROR_IO_PENDING</strong>不是失败;它指定读取操作正在异步等待完成。 有关详细信息，请参阅“备注”。</p><h4 id="注解-2"><a href="#注解-2" class="headerlink" title="注解"></a>注解</h4><p>发生以下情况之一时， <strong>ReadFile</strong> 函数将返回：</p><ul><li></li><li><p>读取请求的字节数。</p></li><li>写入操作在管道的写入端完成。</li><li>正在使用异步句柄，读取正在异步发生。</li><li>发生错误。</li></ul><p>每当有过多未完成的异步 I/O 请求时，<strong>ReadFile</strong> 函数可能会失败<strong>，**</strong>ERROR_INVALID_USER_BUFFER或ERROR_NOT_ENOUGH_MEMORY**。</p><p>若要取消所有挂起的异步 I/O 操作，请使用以下任一操作：</p><ul><li></li><li><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelio">CancelIo</a> - 此函数仅取消由指定文件句柄的调用线程发出的操作。</p></li><li><a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelioex-func">CancelIoEx</a> - 此函数取消指定文件句柄的线程发出的所有操作。</li></ul><p>使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> 取消挂起的同步 I/O 操作。</p><p>取消的 I/O 操作已完成，错误 <strong>ERROR_OPERATION_ABORTED</strong>。</p><p><strong>ReadFile</strong> 函数可能会失败<strong>，ERROR_NOT_ENOUGH_QUOTA</strong>，这意味着调用进程的缓冲区无法锁定页。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-setprocessworkingsetsize">SetProcessWorkingSetSize</a>。</p><p>如果某个文件的一部分被另一个进程锁定，并且读取操作与锁定部分重叠，则此函数将失败。</p><p>读取操作使用缓冲区时访问输入缓冲区可能会导致读取到该缓冲区的数据损坏。 在读取操作完成之前，应用程序不得读取、写入、重新分配或释放读取操作使用的输入缓冲区。 使用异步文件句柄时，这尤其有问题。 有关同步与异步文件句柄的其他信息，可以在 <a href="https://learn.microsoft.com/zh-cn/">“同步和文件位置</a> ”部分以及 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 参考主题中找到。</p><p>可以使用具有控制台输入句柄的 <strong>ReadFile</strong> 从控制台输入缓冲区读取字符。 控制台模式确定 <strong>ReadFile</strong> 函数的确切行为。 默认情况下，控制台模式 <strong>ENABLE_LINE_INPUT</strong>，指示 <strong>ReadFile</strong> 应在到达回车前读取。 如果按 Ctrl+C，则调用成功，但 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_OPERATION_ABORTED</strong>。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>。</p><p>从通信设备读取时， <strong>ReadFile</strong> 的行为由当前通信超时确定为集，并使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-setcommtimeouts">SetCommTimeouts</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-getcommtimeouts">GetCommTimeouts</a> 函数进行检索。 如果无法设置超时值，则可能会出现不可预知的结果。 有关通信超时的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a>。</p><p>如果 <strong>ReadFile</strong> 尝试从具有太小缓冲区的邮件图中读取，则函数返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_INSUFFICIENT_BUFFER</strong>。</p><p>使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 打开的文件有严格的要求。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em>，则以下条件有效：</p><ul><li></li><li><p><em>lpOverlapped</em> 参数必须指向有效且唯一的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数可以错误地报告读取操作已完成。</p></li><li><em>lpNumberOfBytesRead</em> 参数应设置为 <strong>NULL</strong>。 使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 函数获取读取的实际字节数。 如果 <em>hFile</em> 参数与 I/O 完成端口相关联，则还可以通过调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> 函数获取读取的字节数。</li></ul><h4 id="同步和文件位置"><a href="#同步和文件位置" class="headerlink" title="同步和文件位置"></a>同步和文件位置</h4><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，则它是异步文件句柄;否则为同步。 使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的规则对每个结构略有不同，如前所述。</p><p><strong>注意</strong> 如果为异步 I/O 打开文件或设备，则使用该句柄对 <strong>ReadFile</strong> 等函数的后续调用通常会立即返回，但对于被阻止的执行，也可以同步执行。 有关更多信息，请参见<a href="https://support.microsoft.com/kb/156932">http://support.microsoft.com/kb/156932</a>。</p><p>使用异步文件句柄的注意事项：</p><ul><li><p><strong>ReadFile</strong> 可能会在读取操作完成之前返回。 在此方案中， <strong>ReadFile</strong> 返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数返回 <strong>ERROR_IO_PENDING</strong>，这允许调用进程在系统完成读取操作时继续。</p></li><li><p>lpOverlapped</p></li></ul><p>  参数不得为</p><p>  NULL</p><p>  ，应与以下事实一起使用：</p><ul><li>尽管 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件由系统自动设置和重置，但 <strong>在 OVERLAPPED</strong> 结构中指定的偏移量不会自动更新。</li><li><strong>ReadFile</strong> 在开始 I/O 操作时将事件重置为非对齐状态。</li><li>在 READ 操作完成时， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件设置为信号状态;直到该时间，读取操作被视为挂起。</li><li>由于读取操作从 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始，并且 <strong>ReadFile</strong> 可能会在系统级读取操作完成 (读取挂起) 之前返回，因此，应用程序不应修改、释放或重用结构的任何其他部分，直到向事件发出信号 (（即） 读取完成) 。</li><li>如果在异步操作期间检测到文件结束 (EOF) ，则对该操作的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 的调用将返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li></ul><p>使用同步文件句柄的注意事项：</p><ul><li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则读取操作从当前文件位置开始， <strong>ReadFile</strong> 在操作完成之前不会返回，并且系统会在 <strong>ReadFile</strong> 返回之前更新文件指针。</li><li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则读取操作从 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始， <strong>ReadFile</strong> 在读取操作完成之前不会返回。 系统在 <strong>ReadFile</strong> 返回之前更新 <strong>OVERLAPPED</strong> 偏移量和文件指针。</li><li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>TRUE</strong> 并将设置为 <code>*lpNumberOfBytesRead</code> 零。</li><li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li></ul><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p><h4 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h4><p>如果使用匿名管道并且写入句柄已关闭，则 <strong>当 ReadFile</strong> 尝试使用管道的相应读取句柄进行读取时，函数将返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_BROKEN_PIPE</strong>。</p><p>如果在消息模式下读取命名管道，并且下一条消息的长度超过 <em>nNumberOfBytesToRead</em> 参数指定， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_MORE_DATA</strong>。 后续调用 <strong>ReadFile</strong> 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe">PeekNamedPipe</a> 函数可以读取消息的其余部分。</p><p>如果 <strong>ReadFile</strong> 在管道上返回 <strong>TRUE</strong> 时<em>，lpNumberOfBytesRead</em> 参数为零，则管道的另一端称为 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> 函数，<em>nNumberOfBytesToWrite</em> 设置为零。</p><p>有关管道的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p><h4 id="事务处理的操作"><a href="#事务处理的操作" class="headerlink" title="事务处理的操作"></a>事务处理的操作</h4><p>如果存在绑定到文件句柄的事务，则该函数将从文件的事务处理视图中返回数据。 保证事务处理读取句柄在句柄期间显示文件的相同视图。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-transactional-ntfs">关于事务 NTFS</a>。</p><p>在Windows 8和Windows Server 2012中，以下技术支持此函数。</p><h2 id="Windows数据结构"><a href="#Windows数据结构" class="headerlink" title="Windows数据结构"></a>Windows数据结构</h2><p>​        这里的数据结构指的是Windows文件体系的结构。</p><p>​        这里的结构是用老式的C定义与实现的，为了与之对应，我们采取打开一个文件的属性查看作为可视化的理解。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct _WIN32_FILE_ATTRIBUTE_DATA &#123;    DWORD dwFileAttributes;&#x2F;&#x2F; 文件属性    FILETIME ftCreationTime;&#x2F;&#x2F; 创建时间    FILETIME ftLastAccessTime;&#x2F;&#x2F; 最后访问时间    FILETIME ftLastWriteTime;&#x2F;&#x2F; 最后修改    DWORD nFileSizeHigh;&#x2F;&#x2F; 文件长度    DWORD nFileSizeLow; &#x2F;&#x2F; 文件长度&#125; WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230516204344506.png" alt="image-20230516204344506"></p><p>​        下面我们来看怎样使用这样的结构. </p><h2 id="一些函数的讲解"><a href="#一些函数的讲解" class="headerlink" title="一些函数的讲解"></a>一些函数的讲解</h2><p>​        我们获取文件属性使用Windows的<code>GetFileAttributesEx</code>函数宏,他需要参数文件地址,获取方式和<code>WIN32_FILE_ATTRIBUTE_DATA</code>结构体.这个函数跟我们熟悉的C变成一样,以参数的参数进入返回初始化后的参数.</p><h3 id="GetFileAttributesEx"><a href="#GetFileAttributesEx" class="headerlink" title="GetFileAttributesEx()"></a>GetFileAttributesEx()</h3><h4 id="GetFileAttributesExW-函数-fileapi-h"><a href="#GetFileAttributesExW-函数-fileapi-h" class="headerlink" title="GetFileAttributesExW 函数 (fileapi.h)"></a>GetFileAttributesExW 函数 (fileapi.h)</h4><p>反馈</p><p>检索指定文件或目录的属性。</p><p>若要将此操作作为事务处理操作执行，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-getfileattributestransacteda">GetFileAttributesTransacted</a> 函数。</p><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetFileAttributesExW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  LPCWSTR                lpFileName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  GET_FILEEX_INFO_LEVELS fInfoLevelId<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPVOID                 lpFileInformation<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h5><pre class="line-numbers language-none"><code class="language-none">[in] lpFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件或目录的名称。</p><p>​        在此函数的 ANSI 版本中，名称限制为 <strong>MAX_PATH</strong> 个字符。 若要将此限制扩展到 32，767 宽字符，请调用函数的 Unicode 版本 (<strong>GetFileAttributesExW</strong>) ，并将“\\？\”追加到路径。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-file">命名文件</a>。</p><p><strong>提示</strong></p><p>从 Windows 10 版本 1607 开始，对于此函数的 unicode 版本， (<strong>GetFileAttributesExW</strong>) ，可以选择加入以删除<strong>MAX_PATH</strong>字符限制，而无需追加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径限制”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in] fInfoLevelId<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        要检索的属性信息的类。</p><p>​        此参数可以是 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> 枚举中的以下值。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>GetFileExInfoStandard</strong></td><td style="text-align:left"><em>lpFileInformation</em> 参数是<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">一个WIN32_FILE_ATTRIBUTE_DATA</a>结构。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[out] lpFileInformation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收属性信息的缓冲区的指针。</p><p>​        存储在此缓冲区中的属性信息类型由 fInfoLevelId 的值决定。</p><h2 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为 0 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p><h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><p>​        现在我们拿到了初始化结束的结构体,我们想看看时间.要知道,显示时间是可以多样化的,意味着微软希望我们自己书写函数来展示之.</p><p>​        为了提高效率,时间被压缩在几个字节,需要我们自己来转化.这个也是一个结构体<code>FileTime</code>.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void showFileTime(PFILETIME aTime)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;iostream&gt;using namespace std;void showFileTime(PFILETIME aTime)&#123;FILETIME filetimeLocal;SYSTEMTIME sysFileTime;FileTimeToLocalFileTime(aTime, &amp;filetimeLocal);&#x2F;&#x2F; 转换成系统时区时间FileTimeToSystemTime(&amp;filetimeLocal, &amp;sysFileTime);cout &lt;&lt; sysFileTime.wYear &lt;&lt; &quot; 年 &quot; &lt;&lt; sysFileTime.wMonth &lt;&lt; &quot; 月 &quot; &lt;&lt; \sysFileTime.wDay &lt;&lt; &quot; 日 &quot; &lt;&lt; sysFileTime.wHour&lt;&lt;&quot;时&quot; &lt;&lt; sysFileTime.wMinute &lt;&lt; &quot; 分 &quot; &lt;&lt; sysFileTime.wSecond &lt;&lt; &quot; 秒&quot; &lt;&lt; endl;return;&#125;void showInfo(LPWIN32_FILE_ATTRIBUTE_DATA pWfad)&#123;if (pWfad &#x3D;&#x3D; NULL) &#123;cout &lt;&lt; &quot;Failed to get the file&quot;;return;&#125;showFileTime(&amp;pWfad-&gt;ftCreationTime);showFileTime(&amp;pWfad-&gt;ftLastAccessTime);&#125;int main()&#123;WIN32_FILE_ATTRIBUTE_DATA wfad;if (!GetFileAttributesEx(L&quot;1.cpp&quot;, GetFileExInfoStandard, &amp;wfad))&#123;cout &lt;&lt; &quot;Failed to get the file&quot;;return 1;&#125;showInfo(&amp;wfad);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230516211817965.png" alt="image-20230516211817965"></p><h2 id="获取系统目录"><a href="#获取系统目录" class="headerlink" title="获取系统目录"></a>获取系统目录</h2><p>​        为了获取系统目录信息，需要使用函数来完成这项工作！这个函数是<code>GetSystemDirectory()</code></p><p>​        使用它很简单：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;locale.h&gt;int main() &#123;setlocale(LC_ALL,&quot;&quot;);TCHAR szSystemDir[MAX_PATH];GetSystemDirectory(szSystemDir, MAX_PATH);printf(&quot;%ls&quot;, szSystemDir);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="GetSystemDirectoryW-函数-sysinfoapi-h"><a href="#GetSystemDirectoryW-函数-sysinfoapi-h" class="headerlink" title="GetSystemDirectoryW 函数 (sysinfoapi.h)"></a>GetSystemDirectoryW 函数 (sysinfoapi.h)</h3><p>​        检索系统目录的路径。 系统目录包含系统文件，如动态链接库和驱动程序。</p><p>​        此函数主要用于兼容性。 应用程序应将代码存储在 Program Files 文件夹中，并将持久数据存储在用户配置文件的 Application Data 文件夹中。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">ShGetFolderPath</a>。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">UINT <span class="token function">GetSystemDirectoryW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpBuffer<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  UINT   uSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向要接收路径的缓冲区的指针。 除非系统目录是根目录，否则此路径不会以反斜杠结尾。 例如，如果系统目录在驱动器 C 上命名为 Windows\System32，则此函数检索的系统目录的路径为 C：\Windows\System32。</p><pre class="line-numbers language-none"><code class="language-none">[in] uSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        缓冲区的最大大小（以 <strong>TCHAR</strong> 为单位）。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值为复制到缓冲区的字符串的长度（以 <strong>TCHAR</strong> 为单位），不包括终止 null 字符。 如果长度大于缓冲区的大小，则返回值是保存路径所需的缓冲区大小，包括终止 null 字符。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><p>​        </p><p><img src="image-20230518231050866.png" alt="image-20230518231050866"></p><p>​        下面写之进入一个文件！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;locale.h&gt;int main() &#123;setlocale(LC_ALL,&quot;&quot;);TCHAR szSystemDir[MAX_PATH];GetSystemDirectory(szSystemDir, MAX_PATH);printf(&quot;%ls&quot;, szSystemDir);DWORD dwWritten;HANDLE hFile;hFile &#x3D; CreateFile(L&quot;SystemRoot.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile !&#x3D; INVALID_HANDLE_VALUE) &#123;if (!WriteFile(hFile, szSystemDir, 2*lstrlen(szSystemDir), &amp;dwWritten, NULL)) &#123;return GetLastError();&#125;&#125;CloseHandle(hFile);printf(&quot;OK&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建窗口和消息处理"><a href="#创建窗口和消息处理" class="headerlink" title="创建窗口和消息处理"></a>创建窗口和消息处理</h2><p>​        两大方法：使用向导来创建窗口，或者是手写代码自己来写</p><p>​        我们来创建一个Windows应用程序。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; WindowsProject1.cpp : 定义应用程序的入口点。&#x2F;&#x2F;#include &quot;framework.h&quot;#include &quot;WindowsProject1.h&quot;#define MAX_LOADSTRING 100&#x2F;&#x2F; 全局变量:HINSTANCE hInst;                                &#x2F;&#x2F; 当前实例WCHAR szTitle[MAX_LOADSTRING];                  &#x2F;&#x2F; 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING];            &#x2F;&#x2F; 主窗口类名&#x2F;&#x2F; 此代码模块中包含的函数的前向声明:ATOM                MyRegisterClass(HINSTANCE hInstance);BOOL                InitInstance(HINSTANCE, int);LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance,                     _In_opt_ HINSTANCE hPrevInstance,                     _In_ LPWSTR    lpCmdLine,                     _In_ int       nCmdShow)&#123;    UNREFERENCED_PARAMETER(hPrevInstance);    UNREFERENCED_PARAMETER(lpCmdLine);    &#x2F;&#x2F; TODO: 在此处放置代码。    &#x2F;&#x2F; 初始化全局字符串    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);    MyRegisterClass(hInstance);    &#x2F;&#x2F; 执行应用程序初始化:    if (!InitInstance (hInstance, nCmdShow))    &#123;        return FALSE;    &#125;    HACCEL hAccelTable &#x3D; LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));    MSG msg;    &#x2F;&#x2F; 主消息循环:    while (GetMessage(&amp;msg, nullptr, 0, 0))    &#123;        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))        &#123;            TranslateMessage(&amp;msg);            DispatchMessage(&amp;msg);        &#125;    &#125;    return (int) msg.wParam;&#125;&#x2F;&#x2F;&#x2F;&#x2F;  函数: MyRegisterClass()&#x2F;&#x2F;&#x2F;&#x2F;  目标: 注册窗口类。&#x2F;&#x2F;ATOM MyRegisterClass(HINSTANCE hInstance)&#123;    WNDCLASSEXW wcex;    wcex.cbSize &#x3D; sizeof(WNDCLASSEX);    wcex.style          &#x3D; CS_HREDRAW | CS_VREDRAW;    wcex.lpfnWndProc    &#x3D; WndProc;    wcex.cbClsExtra     &#x3D; 0;    wcex.cbWndExtra     &#x3D; 0;    wcex.hInstance      &#x3D; hInstance;    wcex.hIcon          &#x3D; LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));    wcex.hCursor        &#x3D; LoadCursor(nullptr, IDC_ARROW);    wcex.hbrBackground  &#x3D; (HBRUSH)(COLOR_WINDOW+1);    wcex.lpszMenuName   &#x3D; MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);    wcex.lpszClassName  &#x3D; szWindowClass;    wcex.hIconSm        &#x3D; LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));    return RegisterClassExW(&amp;wcex);&#125;&#x2F;&#x2F;&#x2F;&#x2F;   函数: InitInstance(HINSTANCE, int)&#x2F;&#x2F;&#x2F;&#x2F;   目标: 保存实例句柄并创建主窗口&#x2F;&#x2F;&#x2F;&#x2F;   注释:&#x2F;&#x2F;&#x2F;&#x2F;        在此函数中，我们在全局变量中保存实例句柄并&#x2F;&#x2F;        创建和显示主程序窗口。&#x2F;&#x2F;BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123;   hInst &#x3D; hInstance; &#x2F;&#x2F; 将实例句柄存储在全局变量中   HWND hWnd &#x3D; CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);   if (!hWnd)   &#123;      return FALSE;   &#125;   ShowWindow(hWnd, nCmdShow);   UpdateWindow(hWnd);   return TRUE;&#125;&#x2F;&#x2F;&#x2F;&#x2F;  函数: WndProc(HWND, UINT, WPARAM, LPARAM)&#x2F;&#x2F;&#x2F;&#x2F;  目标: 处理主窗口的消息。&#x2F;&#x2F;&#x2F;&#x2F;  WM_COMMAND  - 处理应用程序菜单&#x2F;&#x2F;  WM_PAINT    - 绘制主窗口&#x2F;&#x2F;  WM_DESTROY  - 发送退出消息并返回&#x2F;&#x2F;&#x2F;&#x2F;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123;    switch (message)    &#123;    case WM_COMMAND:        &#123;            int wmId &#x3D; LOWORD(wParam);            &#x2F;&#x2F; 分析菜单选择:            switch (wmId)            &#123;            case IDM_ABOUT:                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);                break;            case IDM_EXIT:                DestroyWindow(hWnd);                break;            default:                return DefWindowProc(hWnd, message, wParam, lParam);            &#125;        &#125;        break;    case WM_PAINT:        &#123;            PAINTSTRUCT ps;            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...            EndPaint(hWnd, &amp;ps);        &#125;        break;    case WM_DESTROY:        PostQuitMessage(0);        break;    default:        return DefWindowProc(hWnd, message, wParam, lParam);    &#125;    return 0;&#125;&#x2F;&#x2F; “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123;    UNREFERENCED_PARAMETER(lParam);    switch (message)    &#123;    case WM_INITDIALOG:        return (INT_PTR)TRUE;    case WM_COMMAND:        if (LOWORD(wParam) &#x3D;&#x3D; IDOK || LOWORD(wParam) &#x3D;&#x3D; IDCANCEL)        &#123;            EndDialog(hDlg, LOWORD(wParam));            return (INT_PTR)TRUE;        &#125;        break;    &#125;    return (INT_PTR)FALSE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这就是一个demo,下面我们使用手写的办法来写一个超级简化版本</p><p><img src="image-20230519142819377.png" alt="image-20230519142819377"></p><p>​        基本原理</p><p>​        先看窗口：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct tagWNDCLASSEXW &#123;    UINT        cbSize;    &#x2F;* Win 3.x *&#x2F;    UINT        style;    WNDPROC     lpfnWndProc;    int         cbClsExtra;    int         cbWndExtra;    HINSTANCE   hInstance;    HICON       hIcon;    HCURSOR     hCursor;    HBRUSH      hbrBackground;    LPCWSTR     lpszMenuName;    LPCWSTR     lpszClassName;    &#x2F;* Win 4.0 *&#x2F;    HICON       hIconSm;&#125; WNDCLASSEXW, *PWNDCLASSEXW, NEAR *NPWNDCLASSEXW, FAR *LPWNDCLASSEXW;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;#include&lt;tchar.h&gt;HWND hwnd;HINSTANCE hInst;LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) &#123;&#x2F;&#x2F;窗口WNDCLASSEX wcx;&#x2F;&#x2F;消息MSG msg;BOOL fGotMsg;wcx.cbSize &#x3D; sizeof(wcx);wcx.style &#x3D; CS_HREDRAW | CS_VREDRAW; &#x2F;&#x2F; 发生大小改变时再次绘制窗口wcx.lpszClassName &#x3D; L&quot;MainWndProc&quot;;wcx.lpfnWndProc &#x3D; MainWndProc;wcx.cbClsExtra &#x3D; 0;&#x2F;&#x2F; 不使用额外内存wcx.cbWndExtra &#x3D; 0;wcx.hInstance &#x3D; hInstance;wcx.hIcon &#x3D; LoadIcon(NULL,IDI_APPLICATION);wcx.hCursor &#x3D; LoadCursor(NULL, IDC_ARROW);wcx.hbrBackground &#x3D; (HBRUSH)GetStockObject(WHITE_BRUSH);wcx.lpszMenuName &#x3D; NULL;wcx.hIconSm &#x3D; (HICON)LoadImage(hInstance, MAKEINTRESOURCE(5),IMAGE_ICON, GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CXSMICON),LR_DEFAULTCOLOR);&#x2F;&#x2F; 注册！在创建if (!RegisterClassEx(&amp;wcx)) &#123;return -1;&#125;TCHAR h1[] &#x3D; L&quot;hello&quot;;TCHAR h2[] &#x3D; L&quot;hello&quot;;hwnd &#x3D; CreateWindowEx(0, h1, h2, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, \CW_USEDEFAULT, 300, 180, NULL, NULL, hInstance, NULL);if (!hwnd) &#123;return GetLastError();&#125;ShowWindow(hwnd, nCmdShow);UpdateWindow(hwnd);&#x2F;&#x2F;提升优先级到最先&#x2F;&#x2F; 消息队列取消息while ((fGotMsg &#x3D; GetMessage(&amp;msg, (HWND)NULL, 0, 0))!&#x3D;0) &#123;TranslateMessage(&amp;msg); &#x2F;&#x2F; 一些消息需要翻译DispatchMessage(&amp;msg); &#x2F;&#x2F;转发消息给窗口过程&#125;return msg.wParam;&#125;&#x2F;&#x2F;LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) &#123;switch (uMsg) &#123;case WM_DESTROY:PostQuitMessage(0); &#x2F;&#x2F; 退出线程return 0;case WM_LBUTTONDOWN:MessageBox(hwnd, L&quot;hello&quot;, L&quot;hello&quot;, MB_OK);return 0;default:return DefWindowProc(hwnd, uMsg, wParam, lParam);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在QT中，我们已经看到了生成一个对话框是容易的——但是现在，让我们把目光聚焦在基于Windows API的MFC下如何召唤一个对话框。</p><p>​        跟QT类似的——我们找到资源文件 》添加新建项 》 对话框，添加即可。</p><p>​        我们随后设计也界面 </p><p><img src="image-20230523195326640.png" alt="image-20230523195326640"></p><p>​        随便整点。</p><p>​        现在看看你的resource.h，多了四个宏：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;&#123;&#123;NO_DEPENDENCIES&#125;&#125;&#x2F;&#x2F; Microsoft Visual C++ 生成的包含文件。&#x2F;&#x2F; 供 Project2.rc 使用&#x2F;&#x2F;#define IDD_DIALOG1                     101#define IDC_BUTTON1                     1001#define IDC_BUTTON2                     1002#define IDC_BUTTON3                     1003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        他们是我们操作之的接口。</p><p>​        下面开始写主函数的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int APIENTRY WinMain(_In_ HINSTANCE hInstance,    _In_opt_ HINSTANCE hPrevInstance,    _In_ LPSTR lpCmdLine,    _In_ int nShowCmd) &#123;    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, MainDlgProc);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="APIEntry"><a href="#APIEntry" class="headerlink" title="APIEntry:"></a>APIEntry:</h2><pre class="line-numbers language-none"><code class="language-none">APIENTRY系统函数的调用约定。此类型在 WinDef.h 中声明，如下所示：#define APIENTRY WINAPI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        也就是说，它本质上时WINAPI的重定义与重命名。</p><h2 id="DialogBox"><a href="#DialogBox" class="headerlink" title="DialogBox"></a>DialogBox</h2><p>​        从对话框模板资源创建模式对话框。 在指定的回调函数通过调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> 函数终止模式对话框之前，<strong>DialogBox</strong> 不会返回控件。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">DialogBoxA</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  hInstance<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            lpTemplate<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  hWndParent<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  lpDialogFunc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in, optional] hInstance<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>HINSTANCE</strong></p><p>包含对话框模板的模块的句柄。 如果此参数为 NULL，则使用当前可执行文件。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpTemplate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>LPCTSTR</strong></p><p>对话框模板。 此参数是指向指定对话框模板名称的以空字符结尾的字符串的指针，或者是指定对话框模板的资源标识符的整数值。 如果参数指定了资源标识符，则其高位字必须为零，其低位字必须包含该标识符。 你可以使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> 宏来创建此值。</p><pre class="line-numbers language-none"><code class="language-none">[in, optional] hWndParent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型：<strong>HWND</strong></p><p>拥有对话框的窗口的句柄。</p><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpDialogFunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>DLGPROC</strong></p><p>指向对话框过程的指针。 有关对话框过程的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>。</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p><strong>DialogBox</strong> 宏使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> 函数创建对话框。 然后，如果模板指定对话框过程DS_SETFONT<a href="https://learn.microsoft.com/zh-cn/windows/desktop/dlgbox/about-dialog-boxes">或DS_SHELLFONT</a>样式) ，<strong>则 DialogBox</strong> 会发送<a href="https://learn.microsoft.com/zh-cn/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a><a href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-setfont">消息 (</a>和WM_SETFONT消息。 该函数显示对话框 (，无论模板是否指定 <strong>WS_VISIBLE</strong> 样式) ，禁用所有者窗口，并启动其自己的消息循环来检索和调度对话框的消息。</p><p>当对话框过程调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> 函数时，<strong>DialogBox</strong> 将销毁对话框，结束消息循环，如果以前启用) ，则启用所有者窗口 (，并在调用 <strong>EndDialog</strong> 时返回对话框过程指定的 <em>nResult</em> 参数。</p><h2 id="MAKEINTERSOURCE"><a href="#MAKEINTERSOURCE" class="headerlink" title="MAKEINTERSOURCE"></a>MAKEINTERSOURCE</h2><p>VC的定义是(winuser.h):</p><pre class="line-numbers language-none"><code class="language-none">#define MAKEINTRESOURCEA(i) ([LPSTR](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;LPSTR&#x2F;9782867?fromModule&#x3D;lemma_inlink))((ULONG_PTR)((WORD)(i)))#define MAKEINTRESOURCEW(i) (LPWSTR)((ULONG_PTR)((WORD)(i)))#define MAKEINTRESOURCE MAKEINTRESOURCEW#else#define MAKEINTRESOURCE MAKEINTRESOURCEA[#endif](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;%23endif&#x2F;2834688?fromModule&#x3D;lemma_inlink) &#x2F;&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用这个宏的主要原因是有的资源是用序号定义的,而不是字符串.所以要把数字转换成字符串<a href="https://baike.baidu.com/item/指针?fromModule=lemma_inlink">指针</a>,然后再传递给<a href="https://baike.baidu.com/item/LoadResource/530202?fromModule=lemma_inlink">LoadResource</a>之类的函数,这样才加载了资源.</p><p>要释放资源(用LoadResource加载的)可以调用FreeResource函数把LoadResource返回的指针传递给FreeResource.</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>​        是把一个”数字形ID”,转化为”字符串”.但是执行前后,输入的数据的内容和长度是不变的!它只不过就是C语言里面”<a href="https://baike.baidu.com/item/强制类型转换/1580197?fromModule=lemma_inlink">强制类型转换</a>“而已.</p><p>​        请看 Winuser.h 代码:</p><pre class="line-numbers language-none"><code class="language-none">#define MAKEINTRESOURCEA(i) ([LPSTR](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;LPSTR&#x2F;9782867?fromModule&#x3D;lemma_inlink))(([DWORD](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;DWORD&#x2F;5043783?fromModule&#x3D;lemma_inlink))((WORD)(i)))#define MAKEINTRESOURCEW(i) (LPWSTR)((DWORD)((WORD)(i)))#define MAKEINTRESOURCE MAKEINTRESOURCEW#else#define MAKEINTRESOURCE MAKEINTRESOURCEA[#endif](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;%23endif&#x2F;2834688?fromModule&#x3D;lemma_inlink) &#x2F;&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        的用法.就用<a href="https://baike.baidu.com/item/FindResource/6375062?fromModule=lemma_inlink">FindResource</a>来说明.</p><pre class="line-numbers language-none"><code class="language-none">HRSRC FindResource(HMODULE hModule, &#x2F;&#x2F; module handleLPCTSTR lpName, &#x2F;&#x2F; resource nameLPCTSTR lpType &#x2F;&#x2F; resource type);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        就是lpName参数需要使用MAKEINTRESOURCE ,因为它需要<a href="https://baike.baidu.com/item/LPCTSTR/6495202?fromModule=lemma_inlink">LPCTSTR</a>类型的参数输入.那么,情况就很清楚了.凡涉及”资源”的API或者MFC类,在参数类型为LPCTSTR时,就应该使用 MAKEINTRESOURCE.这是针对”资源名字”为”数字类型”时的情况.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;Windows.h&gt;#include&quot;resource.h&quot;INT_PTR CALLBACK MainDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) &#123;    BOOL bRet &#x3D; TRUE;    int usrChoice;    switch (uMsg)    &#123;    case WM_LBUTTONDOWN:        MessageBox(hDlg, L&quot;Hello!&quot;, L&quot;A Greeting&quot;, MB_OK);    case WM_COMMAND:        switch (LOWORD(wParam)) &#123;        case IDC_BUTTON1:            usrChoice &#x3D; MessageBox(hDlg, L&quot;I convinced that you push the button1&quot;, L&quot;A greeting&quot;, MB_OK);            if (usrChoice &#x3D;&#x3D; MB_OK) &#123;                bRet &#x3D; FALSE;                break;            &#125;            break;        case IDC_BUTTON2:            usrChoice &#x3D; MessageBox(hDlg, L&quot;I convinced that you push the button2&quot;, L&quot;A greeting&quot;, MB_OK);            if (usrChoice &#x3D;&#x3D; MB_OK) &#123;                bRet &#x3D; FALSE;                break;            &#125;            break;        case IDC_BUTTON3:            EndDialog(hDlg, 0);            bRet &#x3D; FALSE;            break;        default:            bRet &#x3D; FALSE;            break;        &#125;        break;    default:        bRet &#x3D; FALSE;        break;    &#125;    return bRet;&#125;int APIENTRY WinMain(_In_ HINSTANCE hInstance,    _In_opt_ HINSTANCE hPrevInstance,    _In_ LPSTR lpCmdLine,    _In_ int nShowCmd) &#123;    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, MainDlgProc);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个demo生成一个有趣的对话框，可以试试看。</p><p>​    下面专门讲授<code>wchar_t</code>，他是宽字符的意思。</p><p>​        因为我们需要大量的输出中文，为了适配，我们常常使用<code>wchar_t</code></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;int main() &#123;char c &#x3D; &#39;A&#39;; &#x2F;&#x2F; 此类型在默认下只可以保存一个字节wchar_t c2 &#x3D; L&#39;牛&#39;; &#x2F;&#x2F; 现在就可以存下了。&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是这样还是会不认识，原因在于。。。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;locale.h&gt;int main() &#123;setlocale(LC_ALL, &quot;&quot;); &#x2F;&#x2F; 设置windows本地的编码char c &#x3D; &#39;A&#39;; &#x2F;&#x2F; 此类型在默认下只可以保存一个字节wchar_t c2 &#x3D; L&#39;牛&#39;; &#x2F;&#x2F; 现在就可以存下了。wprintf(L&quot;%c&quot;, c2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230526205326835.png" alt="image-20230526205326835"></p><p>​        那如何查看当前的地域呢？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%s\n&quot;, setlocale(LC_ALL, NULL));setlocale(LC_ALL, &quot;&quot;);printf(&quot;%s\n&quot;, setlocale(LC_ALL, NULL));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230526205514732.png" alt="image-20230526205514732"></p><p>​        对于宽字符，我们有跟char一样配饰的各式各样的函数。这里不再做什么介绍了！</p><h2 id="三大版本的char类型"><a href="#三大版本的char类型" class="headerlink" title="三大版本的char类型"></a>三大版本的char类型</h2><p>​        在微软中，有三大类型——CHAR , WCHAR, TCHAR（ASCII，Unicode和通用版本）</p><p>​        随后还有字符串版本的PSTR PWSTR, PTSTR, PC(onst)STR PCWSTR, PCTSTR…</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;int WINAPI WinMain(    _In_ HINSTANCE hInstance,    _In_opt_ HINSTANCE hPrevInstance,    _In_ LPSTR lpCmdLine,    _In_ int nShowCmd) &#123;    CHAR a &#x3D; &#39;a&#39;;    WCHAR b &#x3D; &#39;b&#39;;    TCHAR c &#x3D; &#39;c&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        看到TCHAR是根据平台的字符集选择而发生变动！建议我们的编程使用Unicode字符集。</p><h2 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h2><p>​        下面来看字符转换——将多字节字符和宽字符。为了使得转换方便，我们需要使用：</p><h3 id="MultiByteToWideChar"><a href="#MultiByteToWideChar" class="headerlink" title="MultiByteToWideChar();"></a>MultiByteToWideChar();</h3><p>​        这个函数将字符串映射到 UTF-16 (宽字符) 字符串。 字符串不一定来自多字节字符集。</p><p>​        注意！错误地使用 <strong>MultiByteToWideChar</strong> 函数可能会损害应用程序的安全性。 调用此函数很容易导致缓冲区溢出，因为 <em>lpMultiByteStr</em> 指示的输入缓冲区的大小等于字符串中的字节数，而 <em>lpWideCharStr</em> 指示的输出缓冲区的大小等于字符数。 为了避免缓冲区溢出，应用程序必须指定适合缓冲区接收的数据类型的缓冲区大小。</p><p>​        ANSI 代码页在不同计算机上可能不同，也可以更改单个计算机，从而导致数据损坏。 为了获得最一致的结果，应用程序应使用 Unicode（如 UTF-8 或 UTF-16），而不是特定代码页，除非旧标准或数据格式阻止使用 Unicode。 如果无法使用 Unicode，应用程序应在协议允许时使用适当的编码名称标记数据流。 HTML 和 XML 文件允许标记，但文本文件不会。</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            UINT                              CodePage<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            DWORD                             dwFlags<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            <span class="token function">_In_NLS_string_</span><span class="token punctuation">(</span>cbMultiByte<span class="token punctuation">)</span>LPCCH lpMultiByteStr<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            <span class="token keyword">int</span>                               cbMultiByte<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPWSTR                            lpWideCharStr<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            <span class="token keyword">int</span>                               cchWideChar<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] CodePage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用于执行转换的代码页。 此参数可以设置为在操作系统中安装或可用的任何代码页的值。 有关代码页的列表，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/Intl/code-page-identifiers">代码页标识符</a>。 应用程序还可以指定下表中显示的值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>CP_ACP</strong></td><td style="text-align:left">系统默认的 Windows ANSI 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td></tr><tr><td style="text-align:left"><strong>CP_MACCP</strong></td><td style="text-align:left">当前系统 Macintosh 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。 <strong>注意</strong> 此值主要用于旧代码，通常不需要，因为新式 Macintosh 计算机使用 Unicode 进行编码。</td></tr><tr><td style="text-align:left"><strong>CP_OEMCP</strong></td><td style="text-align:left">当前系统 OEM 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td></tr><tr><td style="text-align:left"><strong>CP_SYMBOL</strong></td><td style="text-align:left">符号代码页 (42) 。</td></tr><tr><td style="text-align:left"><strong>CP_THREAD_ACP</strong></td><td style="text-align:left">当前线程的 Windows ANSI 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td></tr><tr><td style="text-align:left"><strong>CP_UTF7</strong></td><td style="text-align:left">UTF-7。 仅当 7 位传输机制强制使用此值。 首选使用 UTF-8。</td></tr><tr><td style="text-align:left"><strong>CP_UTF8</strong></td><td style="text-align:left">UTF-8。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[in] dwFlags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指示转换类型的标志。 应用程序可以指定以下值的组合，MB_PRECOMPOSED为默认值。 MB_PRECOMPOSED和MB_COMPOSITE互斥。 无论其他标志的状态如何，都可以设置MB_USEGLYPHCHARS和MB_ERR_INVALID_CHARS。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_COMPOSITE</strong></td><td style="text-align:left">始终使用分解字符，即基字符和一个或多个非分步字符各具有不同的代码点值。 例如，Ä 由 A + ー 表示：拉丁文大写字母 A (U+0041) + 组合 DIAERESIS (U+0308) 。 请注意，此标志不能与MB_PRECOMPOSED一起使用。</td></tr><tr><td style="text-align:left"><strong>MB_ERR_INVALID_CHARS</strong></td><td style="text-align:left">如果遇到无效的输入字符，则失败。从 Windows Vista 开始，如果应用程序未设置此标志，函数不会删除非法代码点，而是将非法序列替换为根据指定的代码页) 编码的 U+FFFD (。<strong>Windows 2000 SP4 及更高版本，Windows XP：</strong> 如果未设置此标志，函数将无提示删除非法代码点。 对 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 的调用返回ERROR_NO_UNICODE_TRANSLATION。</td></tr><tr><td style="text-align:left"><strong>MB_PRECOMPOSED</strong></td><td style="text-align:left">默认;请勿与MB_COMPOSITE一起使用。 始终使用预编译字符，即具有基字符或非加速度字符组合的单个字符值。 例如，在字符 è 中，e 是基字符，重音符严重标记是非节奏字符。 如果为字符定义了单个 Unicode 码位，则应用程序应使用它而不是单独的基字符和非节奏字符。 例如，Ä 由单一 Unicode 码位 LATIN 大写字母 A WITH DIAERESIS (U+00C4) 表示。</td></tr><tr><td style="text-align:left"><strong>MB_USEGLYPHCHARS</strong></td><td style="text-align:left">使用字形字符而不是控制字符。</td></tr></tbody></table></div><p>​        对于下面列出的代码页， <em>dwFlags</em> 必须设置为 0。 否则，函数将失败并ERROR_INVALID_FLAGS。50220，50221，50222，50225，50227，，50229，57002 到 57011，65000 (UTF-7)，42 (符号)</p><p>​        对于 UTF-8 或代码页 54936 (GB18030，从 Windows Vista) 开始， <em>dwFlags</em> 必须设置为 0 或MB_ERR_INVALID_CHARS。 否则，函数将失败并ERROR_INVALID_FLAGS。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpMultiByteStr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向要转换的字符串的指针。</p><pre class="line-numbers language-none"><code class="language-none">[in] cbMultiByte<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <em>lpMultiByteStr</em> 参数指示的字符串的大小（以字节为单位）。 或者，如果字符串以 null 结尾，则可以将此参数设置为 -1。 请注意，如果 <em>cbMultiByte</em> 为 0，函数将失败。</p><p>​        如果此参数为 -1，则该函数将处理整个输入字符串，包括终止 null 字符。 因此，生成的 Unicode 字符串具有终止 null 字符，函数返回的长度包括此字符。</p><p>​        如果此参数设置为正整数，则函数将完全处理指定的字节数。 如果提供的大小不包括终止 null 字符，则生成的 Unicode 字符串不会以 null 结尾，并且返回的长度不包括此字符。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpWideCharStr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收转换后的字符串的缓冲区的指针。</p><pre class="line-numbers language-none"><code class="language-none">[in] cchWideChar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <em>lpWideCharStr</em> 指示的缓冲区的大小（以字符为单位）。 如果此值为 0，则该函数将返回所需的缓冲区大小（以字符为单位，包括任何终止 null 字符）并且不使用 <em>lpWideCharStr</em> 缓冲区。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>​        返回写入缓冲区的字符数，如果成功，则返回 <em>由 lpWideCharStr</em> 指示的字符数。 如果函数成功且 <em>cchWideChar</em> 为 0，则返回值是 <em>lpWideCharStr</em> 指示的缓冲区所需的大小（以字符为单位）。 另请参阅 <em>dwFlags</em> ，了解输入无效序列时MB_ERR_INVALID_CHARS标志如何影响返回值的信息。</p><p>​        如果函数不成功，则返回 0。 若要获取扩展的错误信息，应用程序可以调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>，后者可以返回以下错误代码之一：</p><ul><li>ERROR_INSUFFICIENT_BUFFER。 提供的缓冲区大小不够大，或者错误地设置为 <strong>NULL</strong>。</li><li>ERROR_INVALID_FLAGS。 为标志提供的值无效。</li><li>ERROR_INVALID_PARAMETER。 任何参数值都无效。</li><li>ERROR_NO_UNICODE_TRANSLATION。 在字符串中找到无效的 Unicode。</li></ul><h4 id="注解-3"><a href="#注解-3" class="headerlink" title="注解"></a>注解</h4><p>​        此函数的默认行为是转换为输入字符串的预编译形式。 如果预编译的窗体不存在，该函数将尝试转换为复合窗体。</p><p>​        使用MB_PRECOMPOSED标志对大多数代码页的影响很小，因为大多数输入数据已经组成。 考虑使用 <strong>MultiByteToWideChar</strong> 进行转换后调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a>。 <strong>NormalizeString</strong> 提供更准确、标准和一致的数据，还可以更快。 请注意，对于传递给 <strong>NormalizeString</strong><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnls/ne-winnls-norm_form">的NORM_FORM</a>枚举，NormalizationC 对应于MB_PRECOMPOSED，NormalizationD 对应于MB_COMPOSITE。</p><p>​        如上述警告中所述，如果未首先使用 <em>cchWideChar</em> 设置为 0 调用此函数，则输出缓冲区很容易溢出，以获取所需的大小。 如果使用MB_COMPOSITE标志，则每个输入字符的输出长度可以为三个或多个字符。</p><p>​        <em>lpMultiByteStr</em> 和 <em>lpWideCharStr</em> 指针不能相同。 如果它们相同，函数将失败， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回值ERROR_INVALID_PARAMETER。</p><p>​        如果显式指定输入字符串长度而不终止 null 字符，<strong>则 MultiByteToWideChar</strong> 不会终止输出字符串。 若要为此函数终止输出字符串，应用程序应传入 -1 或显式计算输入字符串的终止 null 字符。</p><p>​        如果设置了MB_ERR_INVALID_CHARS并且源字符串中遇到无效字符，则函数将失败。 无效字符为下列字符之一：</p><ul><li>不是源字符串中默认字符的字符，但在未设置MB_ERR_INVALID_CHARS时转换为默认字符</li><li>对于 DBCS 字符串，具有前导字节但没有有效尾随字节的字符</li></ul><p>​        从 Windows Vista 开始，此函数完全符合 UTF-8 和 UTF-16 的 Unicode 4.1 规范。 在早期操作系统上使用的函数编码或解码孤独 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/Intl/surrogates-and-supplementary-characters">代理项半</a> 部分或不匹配的代理项对。 在早期版本的 Windows 中编写的代码，这些代码依赖于此行为对随机非文本二进制数据进行编码可能会遇到问题。 但是，在有效的 UTF-8 字符串上使用此函数的代码的行为方式与早期 Windows 操作系统相同。</p><p>​        <strong>Windowsxp：</strong> 为了防止 UTF-8 字符的非最短格式版本的安全问题， <strong>MultiByteToWideChar</strong> 会删除这些字符。</p><p>​        <strong>从 Windows 8 开始：</strong>MultiByteToWideChar 在 Stringapiset.h 中声明。 在Windows 8之前，它在 Winnls.h 中声明。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// Save in-memory logging buffer to a log file on error.</span>    <span class="token double-colon punctuation">::</span>std<span class="token double-colon punctuation">::</span>wstring wideWhat<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> convertResult <span class="token operator">=</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>convertResult <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            wideWhat <span class="token operator">=</span> L<span class="token string">"Exception occurred: Failure to convert its message text using MultiByteToWideChar: convertResult="</span><span class="token punctuation">;</span>            wideWhat <span class="token operator">+=</span> convertResult<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            wideWhat <span class="token operator">+=</span> L<span class="token string">"  GetLastError()="</span><span class="token punctuation">;</span>            wideWhat <span class="token operator">+=</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            wideWhat<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>convertResult <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            convertResult <span class="token operator">=</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wideWhat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>wideWhat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>convertResult <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                wideWhat <span class="token operator">=</span> L<span class="token string">"Exception occurred: Failure to convert its message text using MultiByteToWideChar: convertResult="</span><span class="token punctuation">;</span>                wideWhat <span class="token operator">+=</span> convertResult<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                wideWhat <span class="token operator">+=</span> L<span class="token string">"  GetLastError()="</span><span class="token punctuation">;</span>                wideWhat <span class="token operator">+=</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                wideWhat<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> L<span class="token string">"Exception occurred: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        wideWhat <span class="token operator">=</span> L<span class="token string">"Exception occurred: Unknown."</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Platform<span class="token double-colon punctuation">::</span>String<span class="token operator">^</span> errorMessage <span class="token operator">=</span> ref <span class="token keyword">new</span> <span class="token class-name">Platform</span><span class="token double-colon punctuation">::</span><span class="token function">String</span><span class="token punctuation">(</span>wideWhat<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// The session added the channel at level Warning. Log the message at</span>    <span class="token comment">// level Error which is above (more critical than) Warning, which</span>    <span class="token comment">// means it will actually get logged.</span>    _channel<span class="token operator">-></span><span class="token function">LogMessage</span><span class="token punctuation">(</span>errorMessage<span class="token punctuation">,</span> LoggingLevel<span class="token double-colon punctuation">::</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SaveLogInMemoryToFileAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span>StorageFile<span class="token operator">^</span> logFile<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        _logFileGeneratedCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">StatusChanged</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ref <span class="token keyword">new</span> <span class="token function">LoggingScenarioEventArgs</span><span class="token punctuation">(</span>LoggingScenarioEventType<span class="token double-colon punctuation">::</span>LogFileGenerated<span class="token punctuation">,</span> logFile<span class="token operator">-></span>Path<span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="WideCharToMultiByte"><a href="#WideCharToMultiByte" class="headerlink" title="WideCharToMultiByte"></a>WideCharToMultiByte</h3><p>传送门：<a href="https://www.cnblogs.com/vranger/p/3793123.html">函数WideCharToMultiByte（） 详解 - vranger - 博客园 (cnblogs.com)</a></p><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><pre class="line-numbers language-none"><code class="language-none">int WideCharToMultiByte( UINT CodePage,  DWORD dwFlags,  LPWSTR lpWideCharStr,  int cchWideChar,  LPCSTR lpMultiByteStr,  int cchMultiByte,  LPCSTR lpDefaultChar,  PBOOL pfUsedDefaultChar );  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数功能：</strong></p><p>此函数把宽字符串转换成指定的新的字符串，如ANSI，UTF8等，新字符串不必是多字节字符集。 </p><p>(—-Unicode 转 ANSI(GB2312)，UTF8) </p><p><strong>参数：</strong></p><ul><li>CodePage：指定执行转换的代码页，这个参数可以为系统已安装或有效的任何代码页所给定的值。</li></ul><p>你也可以指定其为下面的任意一值：</p><p> (我想最常用的应该是CP_ACP和CP_UTF8了，前者将宽字符转 换为ANSI，后者转换为UTF8。 ) </p><div class="table-container"><table><thead><tr><th>CP_ACP</th><th>当前系统ANSI代码页</th></tr></thead><tbody><tr><td>CP_MACCP</td><td>当前系统Macintosh代码页</td></tr><tr><td>CP_OEMCP</td><td>当前系统OEM代码页，一种原始设备制造商硬件扫描码</td></tr><tr><td>CP_SYMBOL</td><td>符号代码页（42）</td></tr><tr><td>CP_THREAD_ACP</td><td>当前线程ANSI代码页</td></tr></tbody></table></div><ul><li>dwFlags：指定如何处理没有转换的字符，但不设此参数函数会运行的更快一些，我都是把它设为0。</li></ul><p>可设的值如下表所示：</p><pre class="line-numbers language-none"><code class="language-none">WC_NO_BEST_FIT_CHARS 把不能直接转换成相应多字节字符的Unicode字符转换成lpDefaultChar指定的默认字符。也就是说，如果把Unicode转换成多字节字符，然后再转换回来，你并不一定得到相同的Unicode字符，因为这期间可能使用了默认字符。此选项可以单独使用，也可以和其他选项一起使用。WC_COMPOSITECHECK 把合成字符转换成预制的字符。它可以与后三个选项中的任何一个组合使用，如果没有与他们中的任何一个组合，则与选项WC_SEPCHARS相同。WC_ERR_INVALID_CHARS 此选项会致使函数遇到无效字符时失败返回，并且GetLastError会返回错误码ERROR_NO_UNICODE_TRANSLATION。否则函数会自动丢弃非法字符。此选项只能用于UTF8。WC_DISCARDNS      转换时丢弃不占空间的字符，与WC_COMPOSITECHECK 一起使用WC_SEPCHARS 转换时产生单独的字符，此是默认转换选项，WC_COMPOSITECHECK一起使用WC_DEFAULTCHAR 转换时使用默认字符代替例外的字符，(最常见的如’?’)，与WC_COMPOSITECHECK一起使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <em>注意：当指定WC_COMPOSITECHECK时，函数会将合成字符转换成预制字符。合成字符由一个基字符和一个不占空间的字符(如欧洲国家及汉语拼音的音标)组成，</em></p><p><em>每一个都有不同的字符值。预制字符有一个用于表示基字符和不占空间字符的合成体的单一的字符值。</em></p><p><em>当指定WC_COMPOSITECHECK选项时，也可以使用上表列出的最后3个选项来定制预制字符的转换规则。这些选项决定了函数在遇到宽字符串的合成字符没有对</em></p><p><em>应的预制字符时的行为，他们与WC_COMPOSITECHECK一起使用，如果都没有指定，函数默认WC_SEPCHARS。</em><br><em>对于下列代码页，dwFlags必须为0，否则函数返回错误码ERROR_INVALID_FLAGS。</em><br><em>50220 50221 50222 50225 50227 50229 52936 54936 57002到57011 65000(UTF7) 42(Symbol)</em><br><em>对于UTF8，dwFlags必须为0或WC_ERR_INVALID_CHARS，否则函数都将失败返回并设置错误码ERROR_INVALID_FLAGS，你可以调用GetLastError获得。</em></p><ul><li>lpWideCharStr： 待转换的宽字符串。</li></ul><ul><li>cchWideChar： 待转换宽字符串的长度，-1表示转换到字符串结尾。</li></ul><ul><li>lpMultiByteStr： 接收转换后输出新串的缓冲区。</li></ul><ul><li>cbMultiByte：输出缓冲区大小，如果为0，lpMultiByteStr将被忽略，函数将返回所需缓冲区大小而不使用lpMultiByteStr。</li></ul><ul><li>lpDefaultChar： 指向字符的指针， 在指定编码里找不到相应字符时使用此字符作为默认字符代替。如果为NULL则使用系统默认字符。对于要求此参数为NULL的dwFlags而使用此参数，函数将失败返回并设置错误码ERROR_INVALID_PARAMETER。</li></ul><ul><li>lpUsedDefaultChar：开关变量的指针，用以表明是否使用过默认字符。对于要求此参数为NULL的dwFlags而使用此参数，函数将失败返回并设置错误码ERROR_INVALID_PARAMETER。lpDefaultChar和lpUsedDefaultChar都设为NULL，函数会更快一些。</li></ul><ul><li>返回值：如果函数成功，且cbMultiByte非0，返回写入lpMultiByteStr的字节数(包括字符串结尾的null)；cbMultiByte为0，则返回转换所需字节数。函数失败，返回0。</li></ul><p>​        注意：函数WideCharToMultiByte使用不当，会给影响程序的安全。调用此函数会很容易导致内存泄漏，因为lpWideCharStr指向的输入缓冲区大小是宽字符数，而lpMultiByteStr指向的输出缓冲区大小是字节数。为了避免内存泄漏，应确保为输出缓冲区指定合适的大小。我的方法是先使cbMultiByte为0调用WideCharToMultiByte一次以获得所需缓冲区大小，为缓冲区分配空间，然后再次调用WideCharToMultiByte填充缓冲区，详见下面的代码。另外，从Unicode UTF16向非Unicode字符集转换可能会导致数据丢失，因为该字符集可能无法找到表示特定Unicode数据的字符。</p><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><pre class="line-numbers language-none"><code class="language-none">wchar_t* pwszUnicode &#x3D; L&quot;Holle, word! 你好，中国！ &quot;;int iSize;char* pszMultiByte;iSize &#x3D; WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, NULL, 0, NULL, NULL);pszMultiByte &#x3D; (char*)malloc(iSize*sizeof(char));WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, pszMultiByte, iSize, NULL, NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;locale.h&gt;int main() &#123;DWORD dwNum &#x3D; 0;setlocale(LC_ALL, &quot;&quot;);char sText[] &#x3D; &quot;多字节转换为宽字符&quot;;&#x2F;&#x2F; 问题来了，我们给多少空间呢？&#x2F;*1. from ASCII 2. a control flag, we usually have no need of that3.what str 4. transform ALL 5.to where(here we don&#39;t want to get result), final: tha space that contain*&#x2F;dwNum &#x3D; MultiByteToWideChar(CP_ACP, 0, sText, -1, NULL, 0);WCHAR* pwText &#x3D; (WCHAR)malloc(sizeof(WCHAR) * dwNum*2);if (pwText &#x3D;&#x3D; NULL) &#123;free(pwText);return 1;&#125;MultiByteToWideChar(CP_ACP, 0, sText, -1, pwText, dwNum);wprintf(L&quot;M-&gt;W:%s&quot;, pwText);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="遍历卷-GetLogicalDriveStrings"><a href="#遍历卷-GetLogicalDriveStrings" class="headerlink" title="遍历卷 GetLogicalDriveStrings"></a>遍历卷 GetLogicalDriveStrings</h2><p>​        一个卷也叫做逻辑驱动器，或者叫盘！这是一个基本的概念。</p><p>​        注意到它一次性返回的是若干的字字符串：</p><p><img src="image-20230528180359422.png" alt="image-20230528180359422"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define BFSIZE 1024int main()&#123;WCHAR szLogicalDriveString[BFSIZE];PWCHAR szDrive;ZeroMemory(szLogicalDriveString, BFSIZE);&#x2F;&#x2F;清空内存szDrive &#x3D; szLogicalDriveString;GetLogicalDriveStrings(BFSIZE - 1, szLogicalDriveString);do &#123;printf(&quot;%s\n&quot;, szDrive);szDrive +&#x3D; (lstrlen(szDrive)+1);&#125; while (*szDrive !&#x3D; &#39;\0&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看第一个卷"><a href="#查看第一个卷" class="headerlink" title="查看第一个卷"></a>查看第一个卷</h2><p>​        我们可以使用<code>FindFirstVolume</code>这个函数的设备名称</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TCHAR buf[BFSIZE];HANDLE hVol;BOOL bFlag; &#x2F;&#x2F; as to see if the function work wellhVol &#x3D; FindFirstVolume(buf, BFSIZE);if (hVol &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;wprintf(TEXT(&quot;NO... Volumn has&#39;t been find!&quot;));return -1;&#125;printf(&quot;%ls\n&quot;, buf);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528181002554.png" alt="image-20230528181002554"></p><p>​        这是驱动设备的真正名称，他是唯一的标识符。</p><p>​        使用<code>FindNextVolume</code>来找到下一个：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TCHAR buf[BFSIZE];HANDLE hVol;BOOL bFlag; &#x2F;&#x2F; as to see if the function work wellhVol &#x3D; FindFirstVolume(buf, BFSIZE);if (hVol &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;wprintf(TEXT(&quot;NO... Volumn has&#39;t been find!&quot;));return -1;&#125;printf(&quot;%ls\n&quot;, buf);while (FindNextVolume(hVol, buf, BFSIZE)) &#123;printf(&quot;%ls\n&quot;, buf);&#125;bFlag &#x3D; FindVolumeClose(hVol);return bFlag;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528181246288.png" alt="image-20230528181246288"></p><h2 id="Extensive-Reading-for-Microsoft-API"><a href="#Extensive-Reading-for-Microsoft-API" class="headerlink" title="Extensive Reading for Microsoft API"></a>Extensive Reading for Microsoft API</h2><h3 id="ZeroMemory-宏-wdm-h"><a href="#ZeroMemory-宏-wdm-h" class="headerlink" title="ZeroMemory 宏 (wdm.h)"></a>ZeroMemory 宏 (wdm.h)</h3><p>​        <strong>ZeroMemory</strong> 例程使用零填充内存块，给定指向块的指针和要填充的长度（以字节为单位）。</p><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">RtlZeroMemory</span><span class="token punctuation">(</span>   <span class="token keyword">void</span><span class="token operator">*</span>  Destination<span class="token punctuation">,</span>   size_t Length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] Destination<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向要用零填充的内存块的指针。</p><pre class="line-numbers language-none"><code class="language-none">[in] Length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要用零填充的字节数。</p><h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>无</p><h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h4><p>​        若要将内存缓冲区归零以擦除安全敏感数据，请改用SecureZeroMemory</p><p>​        如果目标内存块位于非分页系统内存中， <strong>ZeroMemory</strong> 的调用方可以在任何 IRQL 上运行。 否则，调用方必须在 IRQL &lt;= APC_LEVEL 运行。</p><h4 id="本质上"><a href="#本质上" class="headerlink" title="本质上"></a>本质上</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">memset((Destination),0,(Length))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="getLogicalDriveStrings函数-fileapi-h"><a href="#getLogicalDriveStrings函数-fileapi-h" class="headerlink" title="getLogicalDriveStrings函数 (fileapi.h)"></a>getLogicalDriveStrings函数 (fileapi.h)</h3><p>​        用指定系统中有效驱动器的字符串填充缓冲区。</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">DWORD <span class="token function">GetLogicalDriveStrings</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  DWORD  nBufferLength<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] nBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>TCHAR</strong> 中<em>由 lpBuffer</em> 指向的缓冲区的最大大小。 此大小不包括终止 null 字符。 如果此参数为零，则不使用 <em>lpBuffer</em> 。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向一个缓冲区的指针，该缓冲区接收一系列以 null 结尾的字符串，一个用于系统中每个有效驱动器，另外还有一个 null 字符。 每个字符串都是设备名称。</p><h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是复制到缓冲区的字符串的长度（以字符为单位），不包括终止 null 字符。 请注意，ANSI-ASCII null 字符使用一个字节，但 Unicode (UTF-16) null 字符使用两个字节。</p><p>​        如果缓冲区不够大，则返回值大于 <em>nBufferLength</em>。 它是保存驱动器字符串所需的缓冲区大小。</p><p>​        如果函数失败，则返回值为零。 若要获取扩展的错误信息，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数。</p><h2 id="注解-4"><a href="#注解-4" class="headerlink" title="注解"></a>注解</h2><p>​        无论需要根目录（例如 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdrivetypea">GetDriveType</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> 函数），缓冲区中的每个字符串都可以使用。</p><p>​        此函数返回全局和本地 MS-DOS 设备命名空间中的驱动器串联。 如果这两个命名空间中都存在驱动器，此函数将返回本地 MS-DOS 设备命名空间中的条目。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/defining-an-ms-dos-device-name">定义 MS DOS 设备名称</a>。</p><p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        SMB 不支持卷管理功能。</p><h3 id="FindFirstVolume-函数-fileapi-h"><a href="#FindFirstVolume-函数-fileapi-h" class="headerlink" title="FindFirstVolume 函数 (fileapi.h)"></a>FindFirstVolume 函数 (fileapi.h)</h3><p>​        检索计算机上的卷的名称。 <strong>FindFirstVolume</strong> 用于开始扫描计算机的卷。</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">HANDLE <span class="token function">FindFirstVolume</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpszVolumeName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  DWORD  cchBufferLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] lpszVolumeName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收空终止字符串的缓冲区的指针，该字符串指定找到的第一个卷的卷 <strong>GUID</strong> 路径。</p><pre class="line-numbers language-none"><code class="language-none">[in] cchBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        要在 <strong>TCHAR</strong> 中接收卷 <strong>GUID</strong> 路径的缓冲区的长度。</p><h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是随后调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数时使用的搜索句柄。</p><p>​        如果函数找不到任何卷，则返回值为 <strong>INVALID_HANDLE_VALUE</strong> 错误代码。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解-5"><a href="#注解-5" class="headerlink" title="注解"></a>注解</h4><p>​        <strong>FindFirstVolume</strong> 函数打开卷搜索句柄，并返回有关计算机上找到的第一个卷的信息。 建立搜索句柄后，可以使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> 函数搜索其他卷。 不再需要搜索句柄时，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数将其关闭。</p><p>​        不应假定这些函数返回的卷的顺序与计算机上的卷顺序之间存在任何关联。 具体而言，如果) 或磁盘管理员，则不要假定由 BIOS (分配的卷顺序和驱动器号之间的任何关联。</p><p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        SMB 不支持卷管理功能。</p><h3 id="FindNextVolume-函数-fileapi-h"><a href="#FindNextVolume-函数-fileapi-h" class="headerlink" title="FindNextVolume 函数 (fileapi.h)"></a>FindNextVolume 函数 (fileapi.h)</h3><p>继续通过调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 函数开始的卷搜索。 <strong>FindNextVolume</strong> 为每个调用查找一个卷。</p><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">FindNextVolume</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  HANDLE hFindVolume<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpszVolumeName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  DWORD  cchBufferLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] hFindVolume<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        上一次调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 函数返回的卷搜索句柄。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpszVolumeName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收找到的卷 <strong>GUID</strong> 路径的字符串的指针。</p><pre class="line-numbers language-none"><code class="language-none">[in] cchBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        接收卷 <strong>GUID</strong> 路径的缓冲区的长度（以 <strong>TCHAR</strong> 为单位）。</p><h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。 如果未找到匹配的文件， <strong>GetLastError</strong> 函数将返回 <strong>ERROR_NO_MORE_FILES</strong> 错误代码。 在这种情况下，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数关闭搜索。</p><h4 id="注解-6"><a href="#注解-6" class="headerlink" title="注解"></a>注解</h4><p>​        通过调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 建立搜索句柄后，可以使用 <strong>FindNextVolume</strong> 函数搜索其他卷。</p><p>​        不应假定这些函数返回的卷的顺序与计算机上的卷顺序之间存在任何关联。 具体而言，如果存在任何) 或磁盘管理员，则不要假定 BIOS (分配的卷顺序和驱动器号之间的任何关联。</p><p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        SMB 不支持卷管理功能。</p><h2 id="查看驱动器属性-GetDriverType-amp-amp-GetVolumeInformation"><a href="#查看驱动器属性-GetDriverType-amp-amp-GetVolumeInformation" class="headerlink" title="查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation"></a>查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation</h2><p>​        我们在盘上右键查看属性。</p><p><img src="image-20230528182104767.png" alt="image-20230528182104767"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;BOOL GetDriverInfo(LPSTR szDriver) &#123;UINT uDriverType &#x3D; GetDriveType(szDriver);printf(&quot;%u&quot;, uDriverType);return TRUE;&#125;int main()&#123;GetDriverInfo(TEXT(&quot;c:\\&quot;));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528182835061.png" alt="image-20230528182835061"></p><p>​        有自己的特殊含义！在<code>WinBase.h</code>文件下</p><p><img src="image-20230528184406835.png" alt="image-20230528184406835"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define DRIVE_UNKNOWN     0#define DRIVE_NO_ROOT_DIR 1#define DRIVE_REMOVABLE   2#define DRIVE_FIXED       3#define DRIVE_REMOTE      4#define DRIVE_CDROM       5#define DRIVE_RAMDISK     6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     正是如此！</code></pre><p>​        下面是给出详细信息的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;BOOL GetDriverInfo(LPSTR szDriver) &#123;UINT uDriverType &#x3D; GetDriveType(szDriver);printf(&quot;%ls,the type is %u\n&quot;,szDriver, uDriverType);switch (uDriverType) &#123;case DRIVE_UNKNOWN: &#123;printf(&quot;can&#39;t get the driver type&quot;);break;&#125;case DRIVE_NO_ROOT_DIR: &#123;printf(&quot;the root path is invalid&quot;);break;&#125;case DRIVE_REMOVABLE:&#123;printf(&quot;the driver can be removed!&quot;);break;&#125;case DRIVE_FIXED :&#123;printf(&quot;this is a type that cannot move!&quot;);break;&#125;case DRIVE_REMOTE:&#123;printf(&quot;the driver is a remote drive!&quot;);break;&#125;case DRIVE_CDROM:&#123;printf(&quot;the driver is a CD-ROM!&quot;);break;&#125;case DRIVE_RAMDISK:&#123;printf(&quot;The driver is a RAM disk!&quot;);break;&#125;default:break;&#125;printf(&quot;\n&quot;);&#x2F;&#x2F; For more Information&#x2F;&#x2F; &#x2F;&#x2F; need to get Some valWCHAR szDriverName[MAX_PATH];DWORD dwVolumeSerialNumber;DWORD dwMaxComponentLength;DWORD dwFileSystemFlags;WCHAR szFileSystemNameBuffer[MAX_PATH];if (!GetVolumeInformation(szDriver,szDriverName,MAX_PATH,&amp;dwVolumeSerialNumber,&amp;dwMaxComponentLength,&amp;dwFileSystemFlags,szFileSystemNameBuffer,MAX_PATH)) &#123;return FALSE;&#125;if (lstrlen(szDriverName)) &#123;printf(&quot;\nDriverName is %ls\n&quot;, szDriverName);&#125;printf(&quot;Volumn Serial Number is %u\n&quot;, dwVolumeSerialNumber);printf(&quot;Maxinum Component Length is %u&quot;, dwMaxComponentLength);printf(&quot;Systems Type:%ls&quot;, szFileSystemNameBuffer);if (dwFileSystemFlags &amp; FILE_VOLUME_QUOTAS) &#123;&#x2F;&#x2F; 可以看到这是要求位判断printf(&quot;the file system does support the QUOTAS&quot;);&#125;&#x2F;&#x2F;...return TRUE;&#125;int main()&#123;GetDriverInfo(TEXT(&quot;c:\\&quot;));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Extensive-Reading-for-Microsoft-API-1"><a href="#Extensive-Reading-for-Microsoft-API-1" class="headerlink" title="Extensive Reading for Microsoft API"></a>Extensive Reading for Microsoft API</h2><h3 id="getDriveType-函数-fileapi-h"><a href="#getDriveType-函数-fileapi-h" class="headerlink" title="getDriveType 函数 (fileapi.h)"></a>getDriveType 函数 (fileapi.h)</h3><p>​        确定磁盘驱动器是可移动的、固定的、CD-ROM、RAM 磁盘还是网络驱动器。</p><p>​        若要确定驱动器是否为 USB 类型驱动器，请调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertya">SetupDiGetDeviceRegistryProperty</a> 并指定 <strong>SPDRP_REMOVAL_POLICY</strong> 属性。</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">UINT <span class="token function">GetDriveTypeW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPCWSTR lpRootPathName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        驱动器的根目录。</p><p>​        需要尾随反斜杠。 如果此参数为 <strong>NULL</strong>，则该函数使用当前目录的根目录。</p><h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>​        返回值指定驱动器的类型，可以是下列值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">返回代码/值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>DRIVE_UNKNOWN</strong>0</td><td style="text-align:left">无法确定驱动器类型。</td></tr><tr><td style="text-align:left"><strong>DRIVE_NO_ROOT_DIR</strong>1</td><td style="text-align:left">根路径无效;例如，在指定路径上没有装载卷。</td></tr><tr><td style="text-align:left"><strong>DRIVE_REMOVABLE</strong>2</td><td style="text-align:left">驱动器具有可移动媒体;例如，软盘驱动器、拇指驱动器或闪存卡读取器。</td></tr><tr><td style="text-align:left"><strong>DRIVE_FIXED</strong>3</td><td style="text-align:left">驱动器具有固定媒体;例如，硬盘驱动器或闪存驱动器。</td></tr><tr><td style="text-align:left"><strong>DRIVE_REMOTE</strong>4</td><td style="text-align:left">驱动器是远程 (网络) 驱动器。</td></tr><tr><td style="text-align:left"><strong>DRIVE_CDROM</strong>5</td><td style="text-align:left">驱动器是 CD-ROM 驱动器。</td></tr><tr><td style="text-align:left"><strong>DRIVE_RAMDISK</strong>6</td><td style="text-align:left">驱动器是一个 RAM 磁盘。</td></tr></tbody></table></div><h3 id="getVolumeInformationW-函数-fileapi-h"><a href="#getVolumeInformationW-函数-fileapi-h" class="headerlink" title="getVolumeInformationW 函数 (fileapi.h)"></a>getVolumeInformationW 函数 (fileapi.h)</h3><p>​        检索与指定根目录关联的文件系统和卷的相关信息。</p><p>​        若要在检索此信息时指定句柄，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationbyhandlew">GetVolumeInformationByHandleW</a> 函数。</p><p>​        若要检索文件或目录的当前压缩状态，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>。</p><h4 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetVolumeInformationW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  LPCWSTR lpRootPathName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPWSTR  lpVolumeNameBuffer<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            DWORD   nVolumeNameSize<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPDWORD lpVolumeSerialNumber<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPDWORD lpMaximumComponentLength<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPDWORD lpFileSystemFlags<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPWSTR  lpFileSystemNameBuffer<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            DWORD   nFileSystemNameSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向包含要描述的卷的根目录的字符串的指针。</p><p>​        如果此参数为 <strong>NULL</strong>，则使用当前目录的根目录。 尾随反斜杠是必需的。 例如，将 \\MyServer\MyShare 指定为“\\MyServer\MyShare\”，或将 C 驱动器指定为“C：\”。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpVolumeNameBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收指定卷名称的缓冲区的指针。 缓冲区大小由 <em>nVolumeNameSize</em> 参数指定。</p><pre class="line-numbers language-none"><code class="language-none">[in] nVolumeNameSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        卷名称缓冲区的长度（以 <strong>TCHAR 为单位</strong>）。 最大缓冲区大小为 <strong>MAX_PATH</strong>+1。</p><p>​        如果未提供卷名缓冲区，则忽略此参数。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpVolumeSerialNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收卷序列号的变量的指针。</p><p>​        如果不需要序列号，此参数可以为 <strong>NULL</strong> 。</p><p>​        此函数返回格式化硬盘时操作系统分配的卷序列号。 若要以编程方式获取制造商分配的硬盘序列号，请使用 Windows Management Instrumentation (WMI) <a href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> 属性 <strong>SerialNumber</strong>。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpMaximumComponentLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向变量的指针，该变量接收指定文件系统支持的文件名组件的最大长度（以 <strong>TCHAR 为单位</strong>）。</p><p>​        文件名组件是文件名在反斜杠之间的部分。</p><p>​        存储在 <em>*lpMaximumComponentLength</em> 指向的变量中的值用于指示指定的文件系统支持长名称。 例如，对于支持长名称的 FAT 文件系统，函数存储值 255，而不是以前的 8.3 指示器。 使用 NTFS 文件系统的系统上也支持长名称。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFileSystemFlags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收与指定文件系统关联的标志的变量的指针。</p><p>​        此参数可以是以下一个或多个标志。 但是， <strong>FILE_FILE_COMPRESSION</strong> 和 <strong>FILE_VOL_IS_COMPRESSED</strong> 是相互排斥的。</p><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>FILE_CASE_SENSITIVE_SEARCH</strong> 0x00000001</td><td style="text-align:left">指定的卷支持区分大小写的文件名。</td></tr><tr><td style="text-align:left"><strong>FILE_CASE_PRESERVED_NAMES</strong> 0x00000002</td><td style="text-align:left">指定的卷支持在磁盘上放置名称时保留文件名大小写。</td></tr><tr><td style="text-align:left"><strong>FILE_UNICODE_ON_DISK</strong> 0x00000004</td><td style="text-align:left">指定的卷支持在磁盘上显示的文件名中的 Unicode。</td></tr><tr><td style="text-align:left"><strong>FILE_PERSISTENT_ACLS</strong> 0x00000008</td><td style="text-align:left">指定的卷保留并强制实施访问控制列表 (ACL) 。 例如，NTFS 文件系统保留并强制实施 ACL，而 FAT 文件系统则不这样做。</td></tr><tr><td style="text-align:left"><strong>FILE_FILE_COMPRESSION</strong> 0x00000010</td><td style="text-align:left">指定的卷支持基于文件的压缩。</td></tr><tr><td style="text-align:left"><strong>FILE_VOLUME_QUOTAS</strong> 0x00000020</td><td style="text-align:left">指定的卷支持磁盘配额。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_SPARSE_FILES</strong> 0x00000040</td><td style="text-align:left">指定的卷支持稀疏文件。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_REPARSE_POINTS</strong> 0x00000080</td><td style="text-align:left">指定的卷支持重新分析点。  <strong>裁判：</strong> ReFS 支持重新分析点，但不对其进行索引，因此 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> 将无法按预期工作。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_REMOTE_STORAGE</strong> 0x00000100</td><td style="text-align:left">文件系统支持远程存储。</td></tr><tr><td style="text-align:left"><strong>FILE_RETURNS_CLEANUP_RESULT_INFO</strong> 0x00000200</td><td style="text-align:left">成功执行清理操作后，文件系统将返回描述清理期间执行的其他操作的信息，例如删除文件。 文件系统筛选器可以在清理后回调中检查此信息。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_POSIX_UNLINK_RENAME</strong> 0x00000400</td><td style="text-align:left">文件系统支持 POSIX 样式的删除和重命名操作。</td></tr><tr><td style="text-align:left"><strong>FILE_VOLUME_IS_COMPRESSED</strong> 0x00008000</td><td style="text-align:left">指定的卷是压缩卷，例如 DoubleSpace 卷。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_OBJECT_IDS</strong> 0x00010000</td><td style="text-align:left">指定的卷支持对象标识符。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_ENCRYPTION</strong> 0x00020000</td><td style="text-align:left">指定的卷支持 EFS) 加密文件系统 (。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/FileIO/file-encryption">文件加密</a>。</td></tr><tr><td style="text-align:left"><strong>FILE_NAMED_STREAMS</strong> 0x00040000</td><td style="text-align:left">指定的卷支持命名流。</td></tr><tr><td style="text-align:left"><strong>FILE_READ_ONLY_VOLUME</strong> 0x00080000</td><td style="text-align:left">指定的卷是只读的。</td></tr><tr><td style="text-align:left"><strong>FILE_SEQUENTIAL_WRITE_ONCE</strong> 0x00100000</td><td style="text-align:left">指定的卷支持单个顺序写入。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_TRANSACTIONS</strong> 0x00200000</td><td style="text-align:left">指定的卷支持事务。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/Ktm/about-ktm">关于 KTM</a>。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_HARD_LINKS</strong> 0x00400000</td><td style="text-align:left">指定的卷支持硬链接。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/hard-links-and-junctions">硬链接和交接点</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前不支持此值。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</strong> 0x00800000</td><td style="text-align:left">指定的卷支持扩展属性。 扩展属性是应用程序特定的元数据片段，应用程序可与文件关联，并且不属于文件数据。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_OPEN_BY_FILE_ID</strong> 0x01000000</td><td style="text-align:left">文件系统支持通过 FileID 打开。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_USN_JOURNAL</strong> 0x02000000</td><td style="text-align:left">指定的卷支持更新序列号 (USN) 日志。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/FileIO/change-journal-records">更改日记记录</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_INTEGRITY_STREAMS</strong> 0x04000000</td><td style="text-align:left">文件系统支持 <a href="https://learn.microsoft.com/zh-cn/windows-server/storage/refs/integrity-streams">完整性流</a>。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_BLOCK_REFCOUNTING</strong> 0x08000000</td><td style="text-align:left">指定的卷支持在同一卷上的文件之间共享逻辑群集。 文件系统在写入共享群集时重新分配。 指示 <strong>FSCTL_DUPLICATE_EXTENTS_TO_FILE</strong> 是受支持的操作。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_SPARSE_VDL</strong> 0x10000000</td><td style="text-align:left">文件系统跟踪文件的每个群集是否包含来自显式文件写入或自动零的有效数据 () 或无效数据 (尚未写入或归零) 。 使用稀疏的有效数据长度 (VDL) 的文件系统不会存储有效的数据长度，也不需要有效数据在文件中连续。</td></tr><tr><td style="text-align:left"><strong>FILE_DAX_VOLUME</strong> 0x20000000</td><td style="text-align:left">指定的卷是 DAX) 卷 (直接访问。  <strong>注意：</strong>此标志是在 Windows 10 版本 1607 中引入的。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_GHOSTING</strong> 0x40000000</td><td style="text-align:left">文件系统支持重影。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFileSystemNameBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收文件系统名称的缓冲区的指针，例如 FAT 文件系统或 NTFS 文件系统。 缓冲区大小由 <em>nFileSystemNameSize</em> 参数指定。</p><pre class="line-numbers language-none"><code class="language-none">[in] nFileSystemNameSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件系统名称缓冲区的长度（以 <strong>TCHAR 为单位</strong>）。 最大缓冲区大小为 <strong>MAX_PATH</strong>+1。</p><p>​        如果未提供文件系统名称缓冲区，则忽略此参数。</p><h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果检索了所有请求的信息，则返回值为非零值。</p><p>​        如果未检索所有请求的信息，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解-7"><a href="#注解-7" class="headerlink" title="注解"></a>注解</h4><p>​        当用户尝试获取有关没有软盘的软盘驱动器或没有光盘的 CD-ROM 驱动器的信息时，系统会显示一个消息框，供用户分别插入软盘或光盘。 若要防止系统显示此消息框，请使用 <strong>SEM_FAILCRITICALERRORS</strong>调用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> 函数。</p><p>​        <strong>FILE_VOL_IS_COMPRESSED</strong>标志是基于卷的压缩的唯一指示器。 文件系统名称不会更改以指示压缩，例如，此标志在 DoubleSpace 卷上返回设置。 如果压缩是基于卷的，则会压缩或未压缩整个卷。</p><p>​        <strong>FILE_FILE_COMPRESSION</strong>标志指示文件系统是否支持基于文件的压缩。 当压缩基于文件时，可以压缩或不压缩单个文件。</p><p>​        <strong>FILE_FILE_COMPRESSION</strong>和<strong>FILE_VOL_IS_COMPRESSED</strong>标志互斥。 不能设置这两个位。</p><p>​        <em>存储在 lpMaximumComponentLength</em> 中的最大组件长度值是唯一指示卷支持长于正常 FAT 文件系统 (或其他文件系统) 文件名。 不会更改文件系统名称以指示对长文件名的支持。</p><p>​        <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizea">GetCompressedFileSize</a> 函数获取文件的压缩大小。 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> 函数可以确定是否压缩单个文件。</p><h4 id="符号链接行为-1"><a href="#符号链接行为-1" class="headerlink" title="符号链接行为"></a>符号链接行为</h4><p>​        如果路径指向符号链接，则 函数将返回目标的卷信息。</p><p>​        从Windows 8和Windows Server 2012开始，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        SMB 不支持卷管理功能。</p><h4 id="事务处理操作"><a href="#事务处理操作" class="headerlink" title="事务处理操作"></a>事务处理操作</h4><p>​        如果卷支持文件系统事务，则函数返回 <em>lpFileSystemFlags</em> 中的<strong>FILE_SUPPORTS_TRANSACTIONS</strong>。</p><h5 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h5><p>​        标头 <code>fileapi.h</code> 将 <strong>GetVolumeInformation</strong> 定义为别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将非特定编码别名的使用与非非特定编码的代码混合使用可能会导致不匹配，从而导致编译或运行时错误。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/intl/conventions-for-function-prototypes">函数原型的约定</a></p><h2 id="查看磁盘容量"><a href="#查看磁盘容量" class="headerlink" title="查看磁盘容量"></a>查看磁盘容量</h2><h3 id="GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx"><a href="#GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx" class="headerlink" title="GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx"></a>GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx</h3><p>​        我们使用这些函数来得到我们想要的信息：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;int main() &#123;BOOL isFine;&#x2F;&#x2F; 蔟DWORD dwTotlaClusters;DWORD dwFreeCluster;&#x2F;&#x2F; 扇区DWORD dwSectPerClust;&#x2F;&#x2F;字节DWORD dwBytesPerSect;isFine &#x3D; GetDiskFreeSpace(TEXT(&quot;C:&#x2F;&quot;),&amp;dwSectPerClust,&amp;dwBytesPerSect,&amp;dwFreeCluster,&amp;dwTotlaClusters);if (!isFine) &#123;printf(&quot;Error&quot;);return GetLastError();&#125;printf(&quot;\nGet:&gt;\n&quot;);printf(&quot;总蔟：%d\t每一蔟的扇区数:%d\t空闲的数量：%d\t每个扇区的字节数：%d\t&quot;, dwTotlaClusters, dwSectPerClust, dwFreeCluster, dwBytesPerSect);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230529162144848.png" alt="image-20230529162144848"></p><p>​        OK的！</p><p>​        那这个Ex版本的是啥呢：精简的版本的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DWORD64 qwFreeBytes, qwFreeBytesToCaller, qwTotalBytes;isFine &#x3D; GetDiskFreeSpaceEx(TEXT(&quot;C:&quot;), (PULARGE_INTEGER)&amp; qwFreeBytesToCaller,(PULARGE_INTEGER)&amp;qwTotalBytes, (PULARGE_INTEGER)&amp;qwFreeBytes);if(!isFine) &#123;printf(&quot;Error&quot;);return GetLastError();&#125;printf(&quot;磁盘的总容量：%I64d\t磁盘的总空闲容量：%I64d\t&quot;, qwTotalBytes, qwFreeBytes);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230529163015847.png" alt="image-20230529163015847"></p><h3 id="getDiskFreeSpace-函数-fileapi-h"><a href="#getDiskFreeSpace-函数-fileapi-h" class="headerlink" title="getDiskFreeSpace 函数 (fileapi.h)"></a>getDiskFreeSpace 函数 (fileapi.h)</h3><p>​        本文内容<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#syntax">语法</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#parameters">参数</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#return-value">返回值</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#remarks">注解</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#requirements">要求</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#see-also">另请参阅</a></p><p>​        检索有关指定磁盘的信息，包括磁盘上的可用空间量。</p><h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetDiskFreeSpace</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  LPCSTR  lpRootPathName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpSectorsPerCluster<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpBytesPerSector<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpNumberOfFreeClusters<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpTotalNumberOfClusters<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        要为其返回信息的磁盘的根目录。 如果此参数为 <strong>NULL</strong>，则该函数使用当前磁盘的根目录。 如果此参数是 UNC 名称，则必须包含尾随反斜杠 (，例如“\\MyServer\MyShare\”) 。 此外，驱动器规范必须具有尾随反斜杠 (，例如“C：\”) 。 调用应用程序必须具有此目录 <strong>FILE_LIST_DIRECTORY</strong> 访问权限。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpSectorsPerCluster<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收每个群集扇区数的变量的指针。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpBytesPerSector<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收每个扇区字节数的变量的指针。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpNumberOfFreeClusters<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收磁盘上可用可用群集总数的变量的指针，该群集可供与调用线程关联的用户使用。</p><p>​        如果使用每用户磁盘配额，此值可能小于磁盘上的可用群集总数。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpTotalNumberOfClusters<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向一个变量的指针，该变量接收磁盘上可用于与调用线程关联的用户的群集总数。</p><p>​        如果使用每用户磁盘配额，此值可能小于磁盘上的群集总数。</p><h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解-8"><a href="#注解-8" class="headerlink" title="注解"></a>注解</h4><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespaceexa">        GetDiskFreeSpaceEx</a> 函数可避免 <strong>GetDiskFreeSpace</strong> 函数所需的一些算术。</p><p>​        符号链接行为 - 如果路径指向符号链接，则会对目标执行操作。</p><p> 备注</p><p>​        fileapi.h 标头将 GetDiskFreeSpace 定义为别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将非中性编码别名与非非编码的代码混合使用可能会导致编译或运行时错误不匹配。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/intl/conventions-for-function-prototypes">函数原型的约定</a>。</p><h3 id="getDiskFreeSpaceEx函数-fileapi-h"><a href="#getDiskFreeSpaceEx函数-fileapi-h" class="headerlink" title="getDiskFreeSpaceEx函数 (fileapi.h)"></a>getDiskFreeSpaceEx函数 (fileapi.h)</h3><p>​        本文内容<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#syntax">语法</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#parameters">参数</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#return-value">返回值</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#remarks">注解</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#requirements">要求</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#see-also">另请参阅</a></p><p>​        检索有关磁盘卷上可用空间量的信息，即总空间量、可用空间总量以及与调用线程关联的用户可用的可用空间总量。</p><h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetDiskFreeSpaceEx</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  LPCSTR          lpDirectoryName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> PULARGE_INTEGER lpFreeBytesAvailableToCaller<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> PULARGE_INTEGER lpTotalNumberOfBytes<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> PULARGE_INTEGER lpTotalNumberOfFreeBytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpDirectoryName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        磁盘上的目录。</p><p>​        如果此参数为 <strong>NULL</strong>，则该函数使用当前磁盘的根目录。</p><p>​        如果此参数是 UNC 名称，则必须包含尾随反斜杠，例如“\\MyServer\MyShare\”。</p><p>​        此参数不必在磁盘上指定根目录。 该函数接受磁盘上的任何目录。</p><p>​        调用应用程序必须对此具有 <strong>FILE_LIST_DIRECTORY</strong> 访问权限<br>“sample”目录中。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFreeBytesAvailableToCaller<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向一个变量的指针，该变量接收磁盘上的可用字节总数，这些字节可供与调用线程关联的用户使用。</p><p>​        此参数可以为 NULL。</p><p>​        如果使用每用户配额，此值可能小于磁盘上的可用字节总数。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpTotalNumberOfBytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向一个变量的指针，该变量接收磁盘上可用于与调用线程关联的用户的字节总数。</p><p>​        此参数可以为 NULL。</p><p>​        如果使用每用户配额，此值可能小于磁盘上的字节总数。</p><p>​        若要确定磁盘或卷上的字节总数，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpTotalNumberOfFreeBytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收磁盘上可用字节总数的变量的指针。</p><p>​        此参数可以为 NULL。</p><h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为 0 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解-9"><a href="#注解-9" class="headerlink" title="注解"></a>注解</h4><p>​        此函数获取的值的类型 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">为ULARGE_INTEGER</a>。 不要将这些值截断为 32 位。</p><p>​        <strong>GetDiskFreeSpaceEx</strong> 函数返回 <em>lpTotalNumberOfFreeBytes</em> 和 <em>lpFreeBytesAvailable</em> 的所有 CD 请求的零 (0) ，除非磁盘是 CD-RW 驱动器中的未写入 CD。</p><p>​        符号链接行为 - 如果路径指向符号链接，则会对目标执行操作。</p><h3 id="ULARGE-INTEGER-union-winnt-h"><a href="#ULARGE-INTEGER-union-winnt-h" class="headerlink" title="ULARGE_INTEGER union (winnt.h)"></a>ULARGE_INTEGER union (winnt.h)</h3><p>​        本文内容<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#syntax">语法</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#members">成员</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#remarks">备注</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#requirements">要求</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#see-also">另请参阅</a></p><p>表示 64 位无符号整数值。</p><p><strong>注意</strong> C 编译器可能本机支持 64 位整数。 例如，Microsoft Visual C++支持<a href="https://learn.microsoft.com/zh-cn/windows/desktop/Midl/--int64">__int64</a>大小的整数类型。 有关详细信息，请参阅 C 编译器随附的文档。</p><h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">union</span> _ULARGE_INTEGER <span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    DWORD LowPart<span class="token punctuation">;</span>    DWORD HighPart<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> DUMMYSTRUCTNAME<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    DWORD LowPart<span class="token punctuation">;</span>    DWORD HighPart<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> u<span class="token punctuation">;</span>  ULONGLONG QuadPart<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> ULARGE_INTEGER<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><pre class="line-numbers language-none"><code class="language-none">DUMMYSTRUCTNAMEDUMMYSTRUCTNAME.LowPartDUMMYSTRUCTNAME.HighPartuu.LowPartu.HighPartQuadPart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>64 位无符号整数。</p><h4 id="备注-3"><a href="#备注-3" class="headerlink" title="备注"></a>备注</h4><p><strong>ULARGE_INTEGER</strong>结构实际上是一个联合体。 如果编译器内置了对 64 位整数的支持，请使用 <strong>QuadPart</strong> 成员存储 64 位整数。 否则，请使用 <strong>LowPart</strong> 和 <strong>HighPart</strong> 成员存储 64 位整数。</p><h2 id="文件操作的四种方法"><a href="#文件操作的四种方法" class="headerlink" title="文件操作的四种方法"></a>文件操作的四种方法</h2><p>​        我们学习到现在，实质上有四种方法进行文件操作。<code>C++, C, Windows API, Windows MFC</code></p><p>​        合适的选取方法是十分重要的。下面，为了能够更好的演示，我们选择在Windows MFC下演示之。</p><h2 id="创建MFC"><a href="#创建MFC" class="headerlink" title="创建MFC"></a>创建MFC</h2><p>​        如果先前并没有勾选过VS桌面开发者，可以前往安装之。这里就不再多述了，创建一个MFC的基于对话框的应用程序即可！</p><p>​        用MFC工具集，我搭建一个演示平台：</p><p><img src="image-20230603090808135.png" alt="image-20230603090808135"></p><p>​        其中，事先准备好一个文本（我这里是随意的一个1.txt）放到工程文件目录下面去了。</p><h2 id="clear按钮"><a href="#clear按钮" class="headerlink" title="clear按钮"></a>clear按钮</h2><p>​        介绍一下函数：<code>SetDlgItemText</code></p><h3 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">SetDlgItemTextW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> HWND    hDlg<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token keyword">int</span>     nIDDlgItem<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCWSTR lpString<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in] hDlg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型：<strong>HWND</strong></p><p>包含控件的对话框的句柄。</p><pre class="line-numbers language-none"><code class="language-none">[in] nIDDlgItem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>int</strong></p><p>具有要设置的标题或文本的控件。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpString<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>LPCTSTR</strong></p><p>要复制到控件的文本。</p><h3 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h3><p>类型： <strong>BOOL</strong></p><p>如果该函数成功，则返回值为非零值。</p><p>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h3 id="注解-10"><a href="#注解-10" class="headerlink" title="注解"></a>注解</h3><p><strong>SetDlgItemText</strong> 函数将<a href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a>消息发送到指定的控件。</p><p>​        而在MFC中，只需要给定指定的控件编号和文本即可：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton5()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码SetDlgItemText(IDC_EDIT1, TEXT(&quot;&quot;));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-方式"><a href="#C-方式" class="headerlink" title="C  方式"></a>C  方式</h2><p>​        点击第一个按钮，书写响应函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton1()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码CString s &#x3D; TEXT(&quot;************C*************\r\n&quot;); &#x2F;&#x2F;一个MFC类FILE* pF; &#x2F;&#x2F; 声明文件指针char line[256]; &#x2F;&#x2F;准备字符空间fopen_s(&amp;pF,&quot;1.txt&quot;, &quot;r&quot;); &#x2F;&#x2F; 阅读内容while (fgets(line, 256, pF) !&#x3D; NULL) &#123;s +&#x3D; line;&#x2F;&#x2F; 使用Cstring的函数s +&#x3D; TEXT(&quot;\r\n&quot;);&#125;fclose(pF);SetDlgItemText(IDC_EDIT1, s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-方式-1"><a href="#C-方式-1" class="headerlink" title="C++ 方式"></a>C++ 方式</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton2()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码CString s &#x3D; TEXT(&quot;************C++*************\r\n&quot;);char line[256];std::ifstream ifs(&quot;1.txt&quot;);while (ifs.getline(line, 256)) &#123;s +&#x3D; line;s +&#x3D; TEXT(&quot;\r\n&quot;);&#125;ifs.close();SetDlgItemText(IDC_EDIT1, s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton3()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码CString c &#x3D; TEXT(&quot;*****************API********************\r\n&quot;);CHAR lpFileDataBuffer[4096];ZeroMemory(lpFileDataBuffer, 4096);DWORD dwReadSize;HANDLE hfile;hfile &#x3D; CreateFile(TEXT(&quot;1.txt&quot;),GENERIC_READ, FILE_SHARE_READ,NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);ReadFile(hfile, lpFileDataBuffer, 4096, &amp;dwReadSize, NULL);CloseHandle(hfile);c +&#x3D; lpFileDataBuffer;SetDlgItemText(IDC_EDIT1,c);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Windows-MFC"><a href="#Windows-MFC" class="headerlink" title="Windows MFC"></a>Windows MFC</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton4()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码CString s &#x3D; TEXT(&quot;******************MFC*******************\r\n&quot;);CString line;CStdioFile file(TEXT(&quot;1.txt&quot;),CFile::modeRead);while (file.ReadString(line))&#123;s +&#x3D; line;s +&#x3D; TEXT(&quot;\r\n&quot;);&#125;SetDlgItemText(IDC_EDIT1, s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="系统学习Windows-API-8"><a href="#系统学习Windows-API-8" class="headerlink" title="系统学习Windows API 8"></a>系统学习Windows API 8</h1><h2 id="前导-1"><a href="#前导-1" class="headerlink" title="前导"></a>前导</h2><p>​        首先，熟悉一下这个形式的main函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main(int argc, char* argv[])&#123;&#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​                在这里，<code>argc</code>指出了命令行有几个，<code>argv</code>给出了具体的参数是什么，来个demo:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;int main(int argc, char* argv[]) &#123;printf(&quot;个数：%d\n&quot;, argc);printf(&quot;第一个:%s\n&quot;, argv[0]);printf(&quot;第二个:%s\n&quot;, argv[1]);printf(&quot;第三个:%s\n&quot;, argv[2]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在只是<code>生成工程</code>！随后，使用<code>PowerShell</code>切换到工程的debug目录下面，找到这个自己的可执行文件。由于此时<code>int main(int argc, char* argv[])</code>带上了命令行参数，它可以接受命令！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./mu.exe <span class="token parameter variable">-d</span> a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230603094626567.png" alt="image-20230603094626567"></p><p><img src="image-20230603094646043.png" alt="image-20230603094646043"></p><p>​        这就是运行的结果。</p><h2 id="DeleteFile"><a href="#DeleteFile" class="headerlink" title="DeleteFile"></a>DeleteFile</h2><p>​        删除现有文件。</p><p>若要以事务处理操作的形式执行此操作，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-deletefiletransacteda">DeleteFileTransacted</a> 函数。</p><h3 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">DeleteFile</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpFileName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in] lpFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        要删除的文件的名称。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><h2 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p><h2 id="注解-11"><a href="#注解-11" class="headerlink" title="注解"></a>注解</h2><p>​        如果应用程序尝试删除不存在的文件， <strong>DeleteFile</strong> 函数将失败并 <strong>ERROR_FILE_NOT_FOUND</strong>。 如果文件是只读文件，则函数将失败并 <strong>ERROR_ACCESS_DENIED</strong>。</p><p>​        以下列表标识了删除、删除或关闭文件的一些提示：</p><ul><li>若要删除只读文件，首先必须删除只读属性。</li><li>若要删除或重命名文件，必须对文件具有删除权限，或者具有父目录中的删除子权限。</li><li>若要以递归方式删除目录中的文件，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> 函数。</li><li>若要删除空目录，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> 函数。</li><li>若要关闭打开的文件，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数。</li></ul><p>​        如果设置了除 delete 和 delete child 以外的所有访问权限的目录，并且访问控制列表 (ACL) 继承了新文件，则可以创建一个文件，但无法将其删除。 但是，你可以创建一个文件，然后获取在创建文件时返回给你的句柄上请求的所有访问权限。</p><p>​        如果在创建文件时请求删除权限，则可以使用该句柄删除或重命名文件，但不能使用任何其他句柄。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-security-and-access-rights">文件安全和访问权限</a>。</p><p>​        如果应用程序尝试删除具有打开正常 I/O 的其他句柄的文件或作为内存映射文件的文件 (<strong>FILE_SHARE_DELETE</strong>必须在打开其他句柄) 时指定，<strong>DeleteFile</strong> 函数将失败。</p><p>​        <strong>DeleteFile</strong> 函数在关闭时标记要删除的文件。 因此，在关闭文件的最后一个句柄之前，不会删除文件。 后续调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 以打开文件失败， <strong>并显示ERROR_ACCESS_DENIED</strong>。</p><p>​        符号链接行为 —</p><p>​        如果路径指向符号链接，则删除符号链接，而不是目标。 若要删除目标，必须调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 并指定 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong>。</p><h2 id="CopyFile"><a href="#CopyFile" class="headerlink" title="CopyFile"></a>CopyFile</h2><p>​        将现有文件复制到新文件。</p><p>​        <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-copyfileexa">CopyFileEx</a> 函数提供两个附加功能。 每次完成复制操作的一部分时，<strong>CopyFileEx</strong> 都可以调用指定的回调函数，并且可以在复制操作期间取消 <strong>CopyFileEx</strong>。</p><p>​        若要以事务处理操作的形式执行此操作，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-copyfiletransacteda">CopyFileTransacted</a> 函数。</p><h3 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">CopyFile</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpExistingFileName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpNewFileName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> BOOL    bFailIfExists<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-none"><code class="language-none">[in] lpExistingFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        现有文件的名称。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p> 提示</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><p>​        如果 <em>lpExistingFileName</em> 不存在， <strong>则 CopyFile</strong> 将失败， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 将返回 <strong>ERROR_FILE_NOT_FOUND</strong>。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpNewFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        新文件的名称。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p> 提示</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in] bFailIfExists<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果此参数为 <strong>TRUE</strong> 并且 <em>lpNewFileName</em> 指定的新文件已存在，则函数将失败。 如果此参数为 <strong>FALSE</strong> 且新文件已存在，则函数将覆盖现有文件并成功。</p><h2 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h2 id="注解-12"><a href="#注解-12" class="headerlink" title="注解"></a>注解</h2><p>​        现有文件 (<strong>ATTRIBUTE_SECURITY_INFORMATION</strong>) 的安全资源属性将复制到新文件。</p><p>​        <strong>Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在Windows 8和Windows Server 2012之前，现有文件的安全资源属性不会复制到新文件。</p><p>​        现有文件的文件属性将复制到新文件。 例如，如果现有文件具有 <strong>FILE_ATTRIBUTE_READONLY</strong> 文件属性，则通过调用 <strong>CopyFile</strong> 创建的副本也将具有 <strong>FILE_ATTRIBUTE_READONLY</strong> 文件属性。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/retrieving-and-changing-file-attributes">检索和更改文件属性</a>。</p><p>​        如果目标文件已存在并且设置了<strong>FILE_ATTRIBUTE_HIDDEN或FILE_ATTRIBUTE_READONLY</strong>属性，则此函数将失败<strong>并ERROR_ACCESS_DENIED</strong>。</p><p>​        当 <strong>CopyFile</strong> 用于复制加密的文件时，它会尝试使用源文件加密中使用的密钥来加密目标文件。 如果无法执行此操作，此函数将尝试使用默认密钥加密目标文件。 如果这两种方法都无法完成， <strong>则 CopyFile</strong> 将失败并 <strong>显示ERROR_ENCRYPTION_FAILED</strong> 错误代码。</p><p>​        符号链接行为 - 如果源文件是符号链接，则复制的实际文件是符号链接的目标。</p><p>​        如果目标文件已存在并且是符号链接，则符号链接的目标将被源文件覆盖。</p><h2 id="MoveFile"><a href="#MoveFile" class="headerlink" title="MoveFile"></a>MoveFile</h2><p>​        移动现有文件或目录，包括其子级。</p><p>​        若要指定如何移动文件，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefileexa">MoveFileEx</a> 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefilewithprogressa">MoveFileWithProgress</a> 函数。</p><p>​        若要以事务处理操作的形式执行此操作，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefiletransacteda">MoveFileTransacted</a> 函数。</p><h3 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">MoveFile</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpExistingFileName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpNewFileName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-none"><code class="language-none">[in] lpExistingFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        本地计算机上文件或目录的当前名称。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p> 提示</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpNewFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件或目录的新名称。 新名称不得已存在。 新文件可能位于不同的文件系统或驱动器上。 新目录必须位于同一驱动器上。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p> 提示</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><h2 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h2 id="注解-13"><a href="#注解-13" class="headerlink" title="注解"></a>注解</h2><p>​        <strong>MoveFile</strong> 函数将移动 (重命名) 文件或目录 (包括其子级) 在同一目录中或跨目录。 需要注意的是，当目标位于其他卷上时，移动目录时 <strong>，MoveFile</strong> 函数将失败。</p><p>​        如果文件跨卷移动， <strong>MoveFile</strong> 不会随文件一起移动安全描述符。 将为文件分配目标目录中的默认安全描述符。</p><p>​        <strong>MoveFile</strong> 函数将其操作与链接跟踪服务协调，因此可以在移动链接源时对其进行跟踪。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learn_Pytorch_1</title>
      <link href="/2023/06/06/Learn-Pytorch-1/"/>
      <url>/2023/06/06/Learn-Pytorch-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch学习"><a href="#Pytorch学习" class="headerlink" title="Pytorch学习"></a>Pytorch学习</h1><h2 id="学习加载数据集"><a href="#学习加载数据集" class="headerlink" title="学习加载数据集"></a>学习加载数据集</h2><p>​        我们首先需要学会导入数据集。在Pytorch里，负责导入数据集的有两个大类：DataSet 和DataLoader.</p><p>​        DataSet 可以认为是提供一种方式来获取数据和对应的标签</p><p>​        DataLoader为后面的网络提供不同的数据形式（需要dataSet来作为源数据集）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Dataset</span><span class="token punctuation">(</span>Generic<span class="token punctuation">[</span>T_co<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">r"""An abstract class representing a :class:`Dataset`.    All datasets that represent a map from keys to data samples should subclass    it. All subclasses should overwrite :meth:`__getitem__`, supporting fetching a    data sample for a given key. Subclasses could also optionally overwrite    :meth:`__len__`, which is expected to return the size of the dataset by many    :class:`~torch.utils.data.Sampler` implementations and the default options    of :class:`~torch.utils.data.DataLoader`.    .. note::      :class:`~torch.utils.data.DataLoader` by default constructs a index      sampler that yields integral indices.  To make it work with a map-style      dataset with non-integral indices/keys, a custom sampler must be provided.    """</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T_co<span class="token punctuation">:</span>        <span class="token keyword">raise</span> NotImplementedError    <span class="token keyword">def</span> <span class="token function">__add__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token string">'Dataset[T_co]'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'ConcatDataset[T_co]'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> ConcatDataset<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">,</span> other<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># No `def __len__(self)` default?</span>    <span class="token comment"># See NOTE [ Lack of Default `__len__` in Python Abstract Base Classes ]</span>    <span class="token comment"># in pytorch/torch/utils/data/sampler.py</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到这是抽象类，需要我们重写DataSet 来运行：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">import</span> os<span class="token keyword">class</span> <span class="token class-name">Mydata</span><span class="token punctuation">(</span>Dataset<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 准备一下路径</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>rootDir<span class="token punctuation">,</span>label_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :param rootDir: the root image source        :param label_dir: whether it is ants or bees        """</span>        self<span class="token punctuation">.</span>rootDir <span class="token operator">=</span> rootDir        self<span class="token punctuation">.</span>label_dir <span class="token operator">=</span>label_dir        self<span class="token punctuation">.</span>path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>rootDir<span class="token punctuation">,</span>self<span class="token punctuation">.</span>label_dir<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>imagePath <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>self<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token comment">#获取东西</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">:</span>        img_name <span class="token operator">=</span> self<span class="token punctuation">.</span>imagePath<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>        img_item_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>path<span class="token punctuation">,</span>img_name<span class="token punctuation">)</span>        img <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>img_item_path<span class="token punctuation">)</span>        label <span class="token operator">=</span> self<span class="token punctuation">.</span>label_dir        <span class="token keyword">return</span> img<span class="token punctuation">,</span>label    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>imagePath<span class="token punctuation">)</span>rootDir <span class="token operator">=</span> <span class="token string">"hymenoptera_data/train"</span>labelDir <span class="token operator">=</span> <span class="token string">"ants"</span>ants_dataset <span class="token operator">=</span> Mydata<span class="token punctuation">(</span>rootDir<span class="token punctuation">,</span>labelDir<span class="token punctuation">)</span>img<span class="token punctuation">,</span>label <span class="token operator">=</span> ants_dataset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>img<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TensorBoard的基本使用"><a href="#TensorBoard的基本使用" class="headerlink" title="TensorBoard的基本使用"></a>TensorBoard的基本使用</h2><p>​        我们为了使用 tensorBoard可视化，需要在我们自己的源代码文件中引入 SummaryWriter类。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们就是在这里实现可视化的！</p><p>​        来看看简介怎么说</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""Writes entries directly to event files in the log_dir to be   consumed by TensorBoard.   The `SummaryWriter` class provides a high-level API to create an event file   in a given directory and add summaries and events to it. The class updates the   file contents asynchronously. This allows a training program to call methods   to add data to the file directly from the training loop, without slowing down   training.   """</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        简单来讲。就是通过生成event file(事件文件)来预备可视化，在cmd或者是已经被激活的 pytorch环境下来整指令：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">tensorboard --logdir&#x3D;&lt;logFileName&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        SummaryWriter的构造函数（<strong> init </strong>()）是这样说的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>    self<span class="token punctuation">,</span> <span class="token comment"># this 指针一样的东西</span>    log_dir<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    comment<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span>    purge_step<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    max_queue<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>    flush_secs<span class="token operator">=</span><span class="token number">120</span><span class="token punctuation">,</span>    filename_suffix<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Creates a `SummaryWriter` that will write out events and summaries    to the event file.    Args:        log_dir (str): Save directory location. Default is          runs/**CURRENT_DATETIME_HOSTNAME**, which changes after each run.          Use hierarchical folder structure to compare          between runs easily. e.g. pass in 'runs/exp1', 'runs/exp2', etc.          for each new experiment to compare across them.        comment (str): Comment log_dir suffix appended to the default          ``log_dir``. If ``log_dir`` is assigned, this argument has no effect.        purge_step (int):          When logging crashes at step :math:`T+X` and restarts at step :math:`T`,          any events whose global_step larger or equal to :math:`T` will be          purged and hidden from TensorBoard.          Note that crashed and resumed experiments should have the same ``log_dir``.        max_queue (int): Size of the queue for pending events and          summaries before one of the 'add' calls forces a flush to disk.          Default is ten items.        flush_secs (int): How often, in seconds, to flush the          pending events and summaries to disk. Default is every two minutes.        filename_suffix (str): Suffix added to all event filenames in          the log_dir directory. More details on filename construction in          tensorboard.summary.writer.event_file_writer.EventFileWriter.    Examples::        from torch.utils.tensorboard import SummaryWriter        # create a summary writer with automatically generated folder name.        writer = SummaryWriter()        # folder location: runs/May04_22-14-54_s-MacBook-Pro.local/        # create a summary writer using the specified folder name.        writer = SummaryWriter("my_experiment")        # folder location: my_experiment        # create a summary writer with comment appended.        writer = SummaryWriter(comment="LR_0.1_BATCH_16")        # folder location: runs/May04_22-14-54_s-MacBook-Pro.localLR_0.1_BATCH_16/    """</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是，我们实例化一个SummaryWriter,只需要告诉构造函数一个文件夹的名字即可</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span><span class="token comment"># 产生一个logs文件夹，其事件文件就在里面！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        向里头输入样本点，比如说函数”y = x”，就需要加入：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">"y = x"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        不要忘记关闭文件流</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="经验来了"><a href="#经验来了" class="headerlink" title="经验来了"></a>经验来了</h3><p>​        首先，如果你打开终端，发现是PS控制台，那就麻烦你手动改成cmd控制台，他在Files - settings - tools - terminal里，选择CMD控制台</p><p><img src="image-20230329201937164.png" alt="image-20230329201937164"></p><p>​        回到终端，他就是这样的了。</p><p><img src="image-20230329202008458.png" alt="image-20230329202008458"></p><p>​        但是，这个时候输入 tensorboard —logdir=logs(你自己看看你指定的文件夹的名字是什么，比如说我的是这个，以及如果你发现你甚至没有log文件夹那就检查代码，去文件的上级找找，但大概率是你代码出错了！)</p><p><img src="image-20230329202055328.png" alt="image-20230329202055328"></p><p><img src="image-20230329202202553.png" alt="image-20230329202202553"></p><p>​        出现了上图的 bug，说明cmd没认识，不知道tensorboard.那就这样，输入</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pip install tensorboard -i --trusted-host  http:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是使用pip 来下载tensorboard, 其中，后面信任域名是为了防止下图种类的报错</p><p><img src="image-20230329202344121.png" alt="image-20230329202344121"></p><p>​        但是，即使这样，我还是遇到了另一个奇怪的错误：</p><p><img src="image-20230329202418314.png" alt="image-20230329202418314"></p><p>​        这个时候马上换源即可，是源的问题</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pip install tensorboard -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple --trusted-host https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230329202505259.png" alt="image-20230329202505259"></p><p>​        我们再试一次，成功了！</p><p>​        对了。如果发现端口冲突了，可以手动指定端口，就是在指令的后面在塞上一个—port=</p><p><img src="image-20230329202803683.png" alt="image-20230329202803683"></p><p>下面来看图片的添加！在Pytorch下，我们使用add_image来添加图片</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add_image</span><span class="token punctuation">(</span>    self<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> img_tensor<span class="token punctuation">,</span> global_step<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> walltime<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> dataformats<span class="token operator">=</span><span class="token string">"CHW"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Add image data to summary.    Note that this requires the ``pillow`` package.    Args:        tag (str): Data identifier        img_tensor (torch.Tensor, numpy.ndarray, or string/blobname): Image data        global_step (int): Global step value to record        walltime (float): Optional override default walltime (time.time())          seconds after epoch of event        dataformats (str): Image data format specification of the form          CHW, HWC, HW, WH, etc.    Shape:        img_tensor: Default is :math:`(3, H, W)`. You can use ``torchvision.utils.make_grid()`` to        convert a batch of tensor into 3xHxW format or call ``add_images`` and let us do the job.        Tensor with :math:`(1, H, W)`, :math:`(H, W)`, :math:`(H, W, 3)` is also suitable as long as        corresponding ``dataformats`` argument is passed, e.g. ``CHW``, ``HWC``, ``HW``.    Examples::        from torch.utils.tensorboard import SummaryWriter        import numpy as np        img = np.zeros((3, 100, 100))        img[0] = np.arange(0, 10000).reshape(100, 100) / 10000        img[1] = 1 - np.arange(0, 10000).reshape(100, 100) / 10000        img_HWC = np.zeros((100, 100, 3))        img_HWC[:, :, 0] = np.arange(0, 10000).reshape(100, 100) / 10000        img_HWC[:, :, 1] = 1 - np.arange(0, 10000).reshape(100, 100) / 10000        writer = SummaryWriter()        writer.add_image('my_image', img, 0)        # If you have non-default dimension setting, set the dataformats argument.        writer.add_image('my_image_HWC', img_HWC, 0, dataformats='HWC')        writer.close()    Expected result:    .. image:: _static/img/tensorboard/add_image.png       :scale: 50 %    """</span>    torch<span class="token punctuation">.</span>_C<span class="token punctuation">.</span>_log_api_usage_once<span class="token punctuation">(</span><span class="token string">"tensorboard.logging.add_image"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>_check_caffe2_blob<span class="token punctuation">(</span>img_tensor<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">from</span> caffe2<span class="token punctuation">.</span>python <span class="token keyword">import</span> workspace        img_tensor <span class="token operator">=</span> workspace<span class="token punctuation">.</span>FetchBlob<span class="token punctuation">(</span>img_tensor<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>_get_file_writer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>add_summary<span class="token punctuation">(</span>        image<span class="token punctuation">(</span>tag<span class="token punctuation">,</span> img_tensor<span class="token punctuation">,</span> dataformats<span class="token operator">=</span>dataformats<span class="token punctuation">)</span><span class="token punctuation">,</span> global_step<span class="token punctuation">,</span> walltime    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        是的，当我们加载图片的时候，函数的参数接受Tensor类型的图片和ndarray类型，这就需要我们调用API来进行转化</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from torch.utils.tensorboard import SummaryWriterfrom PIL import Imageimport numpy as npwriter &#x3D; SummaryWriter(&quot;logs&quot;)imgPath &#x3D; &quot;hymenoptera_data&#x2F;train&#x2F;ants&#x2F;0013035.jpg&quot;imgPIL &#x3D; Image.open(imgPath)imgArray &#x3D; np.array(imgPIL) # 转化writer.add_image(&quot;test&quot;,imgArray,1,dataformats&#x3D;&quot;HWC&quot;) #指明通道是如何的！writer.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="常见的transformer"><a href="#常见的transformer" class="headerlink" title="常见的transformer"></a>常见的transformer</h2><p><img src="image-20230503184731008.png" alt="image-20230503184731008"></p><p>​        下面我们通过Run Demo的方式来实现记忆常见的transformer！</p><p>​        这是我们要处理的图片：</p><p><img src="image-20230503185022804.png" alt="image-20230503185022804"></p><h3 id="PIL-Image库读入图片"><a href="#PIL-Image库读入图片" class="headerlink" title="PIL-Image库读入图片"></a>PIL-Image库读入图片</h3><p>​        下面通过PIL的Image库来读取图片文件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">from PIL import Imageimg &#x3D; Image.open(&quot;1.png&quot;);print(img);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;PIL.PngImagePlugin.PngImageFile image mode&#x3D;RGBA size&#x3D;1717x1227 at 0x21AEC1CB880&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是我们得到的！导入成功！</p><h4 id="小插曲：-call-的用法"><a href="#小插曲：-call-的用法" class="headerlink" title="小插曲： __call__的用法"></a>小插曲： __call__的用法</h4><p>​        在Python类里存在内置函数__call__，我们这样的使用它：我们选择新建一个Python文件，</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"__call__ calls for:"</span><span class="token operator">+</span> <span class="token string">"hello"</span><span class="token operator">+</span><span class="token string">"name"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token operator">+</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person <span class="token operator">=</span> Person<span class="token punctuation">(</span><span class="token punctuation">)</span>person<span class="token punctuation">.</span>hello<span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span>person<span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        书写上面的代码</p><p><img src="image-20230503190321481.png" alt="image-20230503190321481"></p><p>​        有点像C++的内置构建函数的感觉，只需要类对象（）后传对应参数就好了。</p><h4 id="继续："><a href="#继续：" class="headerlink" title="继续："></a>继续：</h4><p>​        看看这个Compose类：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Compose</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Composes several transforms together. This transform does not support torchscript.    Please, see the note below.    Args:        transforms (list of ``Transform`` objects): list of transforms to compose.    Example:        >>> transforms.Compose([        >>>     transforms.CenterCrop(10),        >>>     transforms.PILToTensor(),        >>>     transforms.ConvertImageDtype(torch.float),        >>> ])    .. note::        In order to script the transformations, please use ``torch.nn.Sequential`` as below.        >>> transforms = torch.nn.Sequential(        >>>     transforms.CenterCrop(10),        >>>     transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)),        >>> )        >>> scripted_transforms = torch.jit.script(transforms)        Make sure to use only scriptable transformations, i.e. that work with ``torch.Tensor``, does not require        `lambda` functions or ``PIL.Image``.    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> transforms<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> torch<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>is_scripting<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> torch<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>is_tracing<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            _log_api_usage_once<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>transforms <span class="token operator">=</span> transforms    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> t <span class="token keyword">in</span> self<span class="token punctuation">.</span>transforms<span class="token punctuation">:</span>            img <span class="token operator">=</span> t<span class="token punctuation">(</span>img<span class="token punctuation">)</span>        <span class="token keyword">return</span> img    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        format_string <span class="token operator">=</span> self<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__ <span class="token operator">+</span> <span class="token string">"("</span>        <span class="token keyword">for</span> t <span class="token keyword">in</span> self<span class="token punctuation">.</span>transforms<span class="token punctuation">:</span>            format_string <span class="token operator">+=</span> <span class="token string">"\n"</span>            format_string <span class="token operator">+=</span> <span class="token string-interpolation"><span class="token string">f"    </span><span class="token interpolation"><span class="token punctuation">&#123;</span>t<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span>        format_string <span class="token operator">+=</span> <span class="token string">"\n)"</span>        <span class="token keyword">return</span> format_string<span class="token keyword">class</span> <span class="token class-name">ToTensor</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Convert a PIL Image or ndarray to tensor and scale the values accordingly.    This transform does not support torchscript.    Converts a PIL Image or numpy.ndarray (H x W x C) in the range    [0, 255] to a torch.FloatTensor of shape (C x H x W) in the range [0.0, 1.0]    if the PIL Image belongs to one of the modes (L, LA, P, I, F, RGB, YCbCr, RGBA, CMYK, 1)    or if the numpy.ndarray has dtype = np.uint8    In the other cases, tensors are returned without scaling.    .. note::        Because the input image is scaled to [0.0, 1.0], this transformation should not be used when        transforming target image masks. See the `references`_ for implementing the transforms for image masks.    .. _references: https://github.com/pytorch/vision/tree/main/references/segmentation    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        _log_api_usage_once<span class="token punctuation">(</span>self<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pic<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Args:            pic (PIL Image or numpy.ndarray): Image to be converted to tensor.        Returns:            Tensor: Converted image.        """</span>        <span class="token keyword">return</span> F<span class="token punctuation">.</span>to_tensor<span class="token punctuation">(</span>pic<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__<span class="token punctuation">&#125;</span></span><span class="token string">()"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            先看后面的ToTensor这个类，其负责把一些PIL Image数据转换为Tensor数据类型，举个例子，就处理我刚刚说的那张图片！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transforms<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriterwriter <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span>img <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"1.png"</span><span class="token punctuation">)</span>trans <span class="token operator">=</span> transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span>img_tensor <span class="token operator">=</span> trans<span class="token punctuation">(</span>img<span class="token punctuation">)</span>writer<span class="token punctuation">.</span>add_image<span class="token punctuation">(</span><span class="token string">"ToTensor"</span><span class="token punctuation">,</span>img_tensor<span class="token punctuation">)</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="To-PILImage"><a href="#To-PILImage" class="headerlink" title="To PILImage"></a>To PILImage</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class ToPILImage:    &quot;&quot;&quot;Convert a tensor or an ndarray to PIL Image - this does not scale values.    This transform does not support torchscript.    Converts a torch.*Tensor of shape C x H x W or a numpy ndarray of shape    H x W x C to a PIL Image while preserving the value range.    Args:        mode (&#96;PIL.Image mode&#96;_): color space and pixel depth of input data (optional).            If &#96;&#96;mode&#96;&#96; is &#96;&#96;None&#96;&#96; (default) there are some assumptions made about the input data:            - If the input has 4 channels, the &#96;&#96;mode&#96;&#96; is assumed to be &#96;&#96;RGBA&#96;&#96;.            - If the input has 3 channels, the &#96;&#96;mode&#96;&#96; is assumed to be &#96;&#96;RGB&#96;&#96;.            - If the input has 2 channels, the &#96;&#96;mode&#96;&#96; is assumed to be &#96;&#96;LA&#96;&#96;.            - If the input has 1 channel, the &#96;&#96;mode&#96;&#96; is determined by the data type (i.e &#96;&#96;int&#96;&#96;, &#96;&#96;float&#96;&#96;,            &#96;&#96;short&#96;&#96;).    .. _PIL.Image mode: https:&#x2F;&#x2F;pillow.readthedocs.io&#x2F;en&#x2F;latest&#x2F;handbook&#x2F;concepts.html#concept-modes    &quot;&quot;&quot;    def __init__(self, mode&#x3D;None):        _log_api_usage_once(self)        self.mode &#x3D; mode    def __call__(self, pic):        &quot;&quot;&quot;        Args:            pic (Tensor or numpy.ndarray): Image to be converted to PIL Image.        Returns:            PIL Image: Image converted to PIL Image.        &quot;&quot;&quot;        return F.to_pil_image(pic, self.mode)    def __repr__(self) -&gt; str:        format_string &#x3D; self.__class__.__name__ + &quot;(&quot;        if self.mode is not None:            format_string +&#x3D; f&quot;mode&#x3D;&#123;self.mode&#125;&quot;        format_string +&#x3D; &quot;)&quot;        return format_string<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        把其他数据转换成PIL数据类型，不多讲，当成接口就好！</p><h3 id="Normalize方法类"><a href="#Normalize方法类" class="headerlink" title="Normalize方法类"></a>Normalize方法类</h3><p>​        </p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Normalize(torch.nn.Module):    &quot;&quot;&quot;Normalize a tensor image with mean and standard deviation.    This transform does not support PIL Image.    Given mean: &#96;&#96;(mean[1],...,mean[n])&#96;&#96; and std: &#96;&#96;(std[1],..,std[n])&#96;&#96; for &#96;&#96;n&#96;&#96;    channels, this transform will normalize each channel of the input    &#96;&#96;torch.*Tensor&#96;&#96; i.e.,    &#96;&#96;output[channel] &#x3D; (input[channel] - mean[channel]) &#x2F; std[channel]&#96;&#96;    .. note::        This transform acts out of place, i.e., it does not mutate the input tensor.    Args:        mean (sequence): Sequence of means for each channel.        std (sequence): Sequence of standard deviations for each channel.        inplace(bool,optional): Bool to make this operation in-place.    &quot;&quot;&quot;    def __init__(self, mean, std, inplace&#x3D;False):        super().__init__()        _log_api_usage_once(self)        self.mean &#x3D; mean        self.std &#x3D; std        self.inplace &#x3D; inplace    def forward(self, tensor: Tensor) -&gt; Tensor:        &quot;&quot;&quot;        Args:            tensor (Tensor): Tensor image to be normalized.        Returns:            Tensor: Normalized Tensor image.        &quot;&quot;&quot;        return F.normalize(tensor, self.mean, self.std, self.inplace)    def __repr__(self) -&gt; str:        return f&quot;&#123;self.__class__.__name__&#125;(mean&#x3D;&#123;self.mean&#125;, std&#x3D;&#123;self.std&#125;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        说白了这个就是标准化过程！重要的是这个公式</p><pre class="line-numbers language-none"><code class="language-none">output[channel] &#x3D; (input[channel] - mean[channel]) &#x2F; std[channel]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Resize(torch.nn.Module):    &quot;&quot;&quot;Resize the input image to the given size.    If the image is torch Tensor, it is expected    to have [..., H, W] shape, where ... means an arbitrary number of leading dimensions    .. warning::        The output image might be different depending on its type: when downsampling, the interpolation of PIL images        and tensors is slightly different, because PIL applies antialiasing. This may lead to significant differences        in the performance of a network. Therefore, it is preferable to train and serve a model with the same input        types. See also below the &#96;&#96;antialias&#96;&#96; parameter, which can help making the output of PIL images and tensors        closer.    Args:        size (sequence or int): Desired output size. If size is a sequence like            (h, w), output size will be matched to this. If size is an int,            smaller edge of the image will be matched to this number.            i.e, if height &gt; width, then image will be rescaled to            (size * height &#x2F; width, size).            .. note::                In torchscript mode size as single int is not supported, use a sequence of length 1: &#96;&#96;[size, ]&#96;&#96;.        interpolation (InterpolationMode): Desired interpolation enum defined by            :class:&#96;torchvision.transforms.InterpolationMode&#96;. Default is &#96;&#96;InterpolationMode.BILINEAR&#96;&#96;.            If input is Tensor, only &#96;&#96;InterpolationMode.NEAREST&#96;&#96;, &#96;&#96;InterpolationMode.NEAREST_EXACT&#96;&#96;,            &#96;&#96;InterpolationMode.BILINEAR&#96;&#96; and &#96;&#96;InterpolationMode.BICUBIC&#96;&#96; are supported.            The corresponding Pillow integer constants, e.g. &#96;&#96;PIL.Image.BILINEAR&#96;&#96; are accepted as well.        max_size (int, optional): The maximum allowed for the longer edge of            the resized image: if the longer edge of the image is greater            than &#96;&#96;max_size&#96;&#96; after being resized according to &#96;&#96;size&#96;&#96;, then            the image is resized again so that the longer edge is equal to            &#96;&#96;max_size&#96;&#96;. As a result, &#96;&#96;size&#96;&#96; might be overruled, i.e. the            smaller edge may be shorter than &#96;&#96;size&#96;&#96;. This is only supported            if &#96;&#96;size&#96;&#96; is an int (or a sequence of length 1 in torchscript            mode).        antialias (bool, optional): Whether to apply antialiasing.            It only affects **tensors** with bilinear or bicubic modes and it is            ignored otherwise: on PIL images, antialiasing is always applied on            bilinear or bicubic modes; on other modes (for PIL images and            tensors), antialiasing makes no sense and this parameter is ignored.            Possible values are:            - &#96;&#96;True&#96;&#96;: will apply antialiasing for bilinear or bicubic modes.              Other mode aren&#39;t affected. This is probably what you want to use.            - &#96;&#96;False&#96;&#96;: will not apply antialiasing for tensors on any mode. PIL              images are still antialiased on bilinear or bicubic modes, because              PIL doesn&#39;t support no antialias.            - &#96;&#96;None&#96;&#96;: equivalent to &#96;&#96;False&#96;&#96; for tensors and &#96;&#96;True&#96;&#96; for              PIL images. This value exists for legacy reasons and you probably              don&#39;t want to use it unless you really know what you are doing.            The current default is &#96;&#96;None&#96;&#96; **but will change to** &#96;&#96;True&#96;&#96; **in            v0.17** for the PIL and Tensor backends to be consistent.    &quot;&quot;&quot;    def __init__(self, size, interpolation&#x3D;InterpolationMode.BILINEAR, max_size&#x3D;None, antialias&#x3D;&quot;warn&quot;):        super().__init__()        _log_api_usage_once(self)        if not isinstance(size, (int, Sequence)):            raise TypeError(f&quot;Size should be int or sequence. Got &#123;type(size)&#125;&quot;)        if isinstance(size, Sequence) and len(size) not in (1, 2):            raise ValueError(&quot;If size is a sequence, it should have 1 or 2 values&quot;)        self.size &#x3D; size        self.max_size &#x3D; max_size        if isinstance(interpolation, int):            interpolation &#x3D; _interpolation_modes_from_int(interpolation)        self.interpolation &#x3D; interpolation        self.antialias &#x3D; antialias    def forward(self, img):        &quot;&quot;&quot;        Args:            img (PIL Image or Tensor): Image to be scaled.        Returns:            PIL Image or Tensor: Rescaled image.        &quot;&quot;&quot;        return F.resize(img, self.size, self.interpolation, self.max_size, self.antialias)    def __repr__(self) -&gt; str:        detail &#x3D; f&quot;(size&#x3D;&#123;self.size&#125;, interpolation&#x3D;&#123;self.interpolation.value&#125;, max_size&#x3D;&#123;self.max_size&#125;, antialias&#x3D;&#123;self.antialias&#125;)&quot;        return f&quot;&#123;self.__class__.__name__&#125;&#123;detail&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>size<span class="token punctuation">)</span>trans_size <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span>imgResize <span class="token operator">=</span> trans_size<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>imgResize<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样就好了！</p><p><img src="image-20230503193919990.png" alt="image-20230503193919990"></p><h2 id="Compose-组合变换"><a href="#Compose-组合变换" class="headerlink" title="Compose 组合变换"></a>Compose 组合变换</h2><pre class="line-numbers language-none"><code class="language-none">trans_resize_2 &#x3D; transforms.Resize(512)trans_compose &#x3D; transforms.Compose([trans_resize_2, trans])img_resize_2 &#x3D; trans_compose(img)writer.add_image(&quot;Composer111&quot;, img_resize_2,2)writer.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们这样把若干变换组合在一起一并完成！</p><h2 id="torchvision-学习"><a href="#torchvision-学习" class="headerlink" title="torchvision 学习"></a>torchvision 学习</h2><p>​        pytorch的很多API可以去pytorch.org </p><p>​        下面来看一个加载：</p><p><img src="image-20230511224505274.png" alt="image-20230511224505274"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">import torchvisiontrain_set &#x3D; torchvision.datasets.CIFAR10(root&#x3D;&quot;.&#x2F;dataset&quot;,train&#x3D;True,download&#x3D;True)test_set &#x3D; torchvision.datasets.CIFAR10(root&#x3D;&quot;.&#x2F;dataset&quot;,train&#x3D;False,download&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        稍等片刻，就会下载好数据！</p><p>​        来测试一下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>test_set<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230511224848459.png" alt="image-20230511224848459"></p><p>​        开debug发现还是很多属性的！</p><p>​        这里有相关的read_me:</p><p>The CIFAR-10 and CIFAR-100 are labeled subsets of the <a href="http://people.csail.mit.edu/torralba/tinyimages/">80 million tiny images</a> dataset. They were collected by Alex Krizhevsky, Vinod Nair, and Geoffrey Hinton.</p><h2 id="The-CIFAR-10-dataset"><a href="#The-CIFAR-10-dataset" class="headerlink" title="The CIFAR-10 dataset"></a>The CIFAR-10 dataset</h2><p>​        CIFAR-10数据集由10个类别的60000张32x32彩色图像组成，每个类别有6000张图像。有50000个训练图像和10000个测试图像。</p><p>​        数据集分为五个训练批次和一个测试批次，每个批次有10000张图像。测试批次包含从每个类别中随机选择的1000幅图像。训练批包含按随机顺序排列的剩余图像，但一些训练批可能包含来自一个类的图像多于来自另一类的图像。在它们之间，训练批次正好包含每个类的5000个图像。</p><p>​        以下是数据集中的类，以及每个类的10张随机图像：</p><div class="table-container"><table><thead><tr><th>airplane</th><th><img src="airplane1.png" alt="img"></th><th><img src="airplane2.png" alt="img"></th><th><img src="airplane3.png" alt="img"></th><th><img src="airplane4.png" alt="img"></th><th><img src="airplane5.png" alt="img"></th><th><img src="airplane6.png" alt="img"></th><th><img src="airplane7.png" alt="img"></th><th><img src="airplane8.png" alt="img"></th><th><img src="airplane9.png" alt="img"></th><th><img src="airplane10.png" alt="img"></th></tr></thead><tbody><tr><td>automobile</td><td><img src="automobile1.png" alt="img"></td><td><img src="automobile2.png" alt="img"></td><td><img src="automobile3.png" alt="img"></td><td><img src="automobile4.png" alt="img"></td><td><img src="automobile5.png" alt="img"></td><td><img src="automobile6.png" alt="img"></td><td><img src="automobile7.png" alt="img"></td><td><img src="automobile8.png" alt="img"></td><td><img src="automobile9.png" alt="img"></td><td><img src="automobile10.png" alt="img"></td></tr><tr><td>bird</td><td><img src="bird1.png" alt="img"></td><td><img src="bird2.png" alt="img"></td><td><img src="bird3.png" alt="img"></td><td><img src="bird4.png" alt="img"></td><td><img src="bird5.png" alt="img"></td><td><img src="bird6.png" alt="img"></td><td><img src="bird7.png" alt="img"></td><td><img src="bird8.png" alt="img"></td><td><img src="bird9.png" alt="img"></td><td><img src="bird10.png" alt="img"></td></tr><tr><td>cat</td><td><img src="cat1.png" alt="img"></td><td><img src="cat2.png" alt="img"></td><td><img src="cat3.png" alt="img"></td><td><img src="cat4.png" alt="img"></td><td><img src="cat5.png" alt="img"></td><td><img src="cat6.png" alt="img"></td><td><img src="cat7.png" alt="img"></td><td><img src="cat8.png" alt="img"></td><td><img src="cat9.png" alt="img"></td><td><img src="cat10.png" alt="img"></td></tr><tr><td>deer</td><td><img src="deer1.png" alt="img"></td><td><img src="deer2.png" alt="img"></td><td><img src="deer3.png" alt="img"></td><td><img src="deer4.png" alt="img"></td><td><img src="deer5.png" alt="img"></td><td><img src="deer6.png" alt="img"></td><td><img src="deer7.png" alt="img"></td><td><img src="deer8.png" alt="img"></td><td><img src="deer9.png" alt="img"></td><td><img src="deer10.png" alt="img"></td></tr><tr><td>dog</td><td><img src="dog1.png" alt="img"></td><td><img src="dog2.png" alt="img"></td><td><img src="dog3.png" alt="img"></td><td><img src="dog4.png" alt="img"></td><td><img src="dog5.png" alt="img"></td><td><img src="dog6.png" alt="img"></td><td><img src="dog7.png" alt="img"></td><td><img src="dog8.png" alt="img"></td><td><img src="dog9.png" alt="img"></td><td><img src="dog10.png" alt="img"></td></tr><tr><td>frog</td><td><img src="frog1.png" alt="img"></td><td><img src="frog2.png" alt="img"></td><td><img src="frog3.png" alt="img"></td><td><img src="frog4.png" alt="img"></td><td><img src="frog5.png" alt="img"></td><td><img src="frog6.png" alt="img"></td><td><img src="frog7.png" alt="img"></td><td><img src="frog8.png" alt="img"></td><td><img src="frog9.png" alt="img"></td><td><img src="frog10.png" alt="img"></td></tr><tr><td>horse</td><td><img src="horse1.png" alt="img"></td><td><img src="horse2.png" alt="img"></td><td><img src="horse3.png" alt="img"></td><td><img src="horse4.png" alt="img"></td><td><img src="horse5.png" alt="img"></td><td><img src="horse6.png" alt="img"></td><td><img src="horse7.png" alt="img"></td><td><img src="horse8.png" alt="img"></td><td><img src="horse9.png" alt="img"></td><td><img src="horse10.png" alt="img"></td></tr><tr><td>ship</td><td><img src="ship1.png" alt="img"></td><td><img src="ship2.png" alt="img"></td><td><img src="ship3.png" alt="img"></td><td><img src="ship4.png" alt="img"></td><td><img src="ship5.png" alt="img"></td><td><img src="ship6.png" alt="img"></td><td><img src="ship7.png" alt="img"></td><td><img src="ship8.png" alt="img"></td><td><img src="ship9.png" alt="img"></td><td><img src="ship10.png" alt="img"></td></tr><tr><td>truck</td><td><img src="truck1.png" alt="img"></td><td><img src="truck2.png" alt="img"></td><td><img src="truck3.png" alt="img"></td><td><img src="truck4.png" alt="img"></td><td><img src="truck5.png" alt="img"></td><td><img src="truck6.png" alt="img"></td><td><img src="truck7.png" alt="img"></td><td><img src="truck8.png" alt="img"></td><td><img src="truck9.png" alt="img"></td><td><img src="truck10.png" alt="img"></td></tr></tbody></table></div><p>​        这些类是完全互斥的。汽车和卡车之间没有重叠。“汽车”包括轿车、SUV之类的东西。“卡车”只包括大卡车。两者都不包括皮卡。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>如果您要使用此数据集，请引用本页底部的技术报告。</p><p>|版本|大小|md5sum|</p><p>| —————————————————————————————— | ——— | ———————————————— |</p><p>|[CIFAR-10 python版本](<a href="http://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz）|163">http://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz）|163</a> MB | c58f30108f718f92721af3b95e74349a|</p><p>|[CIFAR-10 Matlab版本](<a href="http://www.cs.toronto.edu/~kriz/cifar-10-matlab.tar.gz）|175">http://www.cs.toronto.edu/~kriz/cifar-10-matlab.tar.gz）|175</a> MB |70270af85842c9e89bb428ec9976c926|</p><p>|[CIFAR-10二进制版本（适用于C程序）](<a href="http://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz）|162">http://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz）|162</a> MB | c32a1d4ab5d03f1284b67883e8d87530|</p><h2 id="基线结果"><a href="#基线结果" class="headerlink" title="基线结果"></a>基线结果</h2><p>你可以在这个数据集上找到一些基线可复制的结果<a href="http://code.google.com/p/cuda-convnet/">在cuda convnet的项目页面上</a>. 这些结果是用卷积神经网络获得的。简单地说，在没有数据扩充的情况下，它们的测试误差为18%，在有数据扩充的条件下为11%。此外，<a href="http://www.cs.toronto.edu/~jasper/）有一篇[新论文](http://hips.seas.harvard.edu/content/practical-bayesian-optimization-machine-learning-algorithms">Jasper Snoek</a>其中，他使用贝叶斯超参数优化来找到权重衰减和其他超参数的良好设置，这使他能够使用获得18%的网络架构获得15%的测试错误率（没有数据扩充）。</p><h2 id="其他结果"><a href="#其他结果" class="headerlink" title="其他结果"></a>其他结果</h2><p>​        <a href="http://rodrigob.github.com/">罗德里戈·贝南森</a>好心地在他的网站上收集了CIFAR-10/100和其他数据集的结果；<a href="http://rodrigob.github.com/are_we_there_yet/build/classification_datasets_results.html">点击此处</a>查看。</p><p>​        数据集布局</p><p>​        Python/Matlab版本</p><p>​        我（这里指作者）将描述数据集的Python版本的布局。Matlab版本的布局是相同的。</p><p>​        档案包含文件data_batch_1，data_batch_2。。。，data_batch_5以及test_batch。这些文件中的每一个都是用[cPickle]生成的Python“pickle”对象(<a href="http://www.python.org/doc/2.5/lib/module-cPickle.html">http://www.python.org/doc/2.5/lib/module-cPickle.html</a>). 下面是一个python2例程，它将打开这样一个文件并返回一个字典：</p><pre class="line-numbers language-none"><code class="language-none">def unpickle（文件）：导入cPickle打开（文件，&#39;rb&#39;）为fo：dict&#x3D;cPickle.load（fo）返回dict<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一个蟒蛇3版本：</p><pre class="line-numbers language-none"><code class="language-none">def unpickle（文件）：进口泡菜打开（文件，&#39;rb&#39;）为fo：dict&#x3D;pickle.load（fo，编码&#x3D;“字节”）返回dict<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        以这种方式加载的每个批处理文件都包含一个字典，其中包含以下元素：</p><p>​        -<strong>数据</strong>—一个10000x3072<a href="http://numpy.scipy.org/">数字</a>uint8s的数组。阵列的每一行存储一个32x32颜色的图像。前1024个条目包含红色通道值，接下来的1024个条目为绿色，最后的1024个为蓝色。图像按行主顺序存储，因此阵列的前32个条目是图像第一行的红色通道值。</p><p>​        -<strong>标签</strong>—包含0-9范围内的10000个数字的列表。索引<em>i</em>处的数字表示数组<strong>数据</strong>中第<em>i</em>个图像的标签。</p><p>​        数据集包含另一个名为batches.meta的文件。它也包含一个Python字典对象。它包含以下条目：</p><p>​        -<strong>label_names</strong>——一个10元素列表，为上述<strong>标签</strong>数组中的数字标签提供有意义的名称。例如，label_names[0]=“飞机”、label_names[1]=“汽车”等。</p><h2 id="二进制版本"><a href="#二进制版本" class="headerlink" title="二进制版本"></a>二进制版本</h2><p>二进制版本包含文件data_batch_1.bin、data_batch_2.bin、…、data_back_5.bin以及test_batch.bin。这些文件的格式如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;1 x标签&gt;&lt;3072 x像素&gt;...&lt;1 x标签&gt;&lt;3072 x像素&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换句话说，第一个字节是第一个图像的标签，它是0-9范围内的数字。接下来的3072个字节是图像的像素值。第一个1024字节是红色通道值，接下来的1024字节是绿色，最后的1024字节为蓝色。这些值按行主顺序存储，因此前32个字节是图像第一行的红色通道值。</p><p>每个文件包含10000个这样的3073字节的图像“行”，尽管没有<strong>任何行的分隔符</strong>。因此，每个文件的长度应该恰好为30730000字节。</p><p>还有另一个文件，名为batches.meta.txt。这是一个ASCII文件，它将0-9范围内的数字标签映射到有意义的类名。它只是10个类名的列表，每行一个。第<em>i</em>行的类名对应于数字标签<em>i</em>。</p><p>这个数据集和CIFAR-10一样，只是它有100个类，每个类包含600个图像。每节课有500个训练图像和100个测试图像。CIFAR-100中的100个类被分组为20个超类。每个图像都带有一个“精细”标签（它所属的类）和一个“粗略”标签（其所属的超类）。</p><p>以下是CIFAR-100中的类列表：</p><p>|超类|类|</p><p>| ——————————————— | ——————————————————————————- |</p><p>|水生哺乳动物|海狸、海豚、水獭、海豹、鲸鱼|</p><p>|鱼类|水族馆鱼类、比目鱼、鳐鱼、鲨鱼、鳟鱼|</p><p>|花|兰花、罂粟、玫瑰、向日葵、郁金香|</p><p>|食品容器|瓶子、碗、罐头、杯子、盘子|</p><p>|水果和蔬菜|苹果、蘑菇、橙子、梨、甜椒|</p><p>|家用电器|时钟、电脑键盘、灯、电话、电视|</p><p>|家用家具|床、椅子、沙发、桌子、衣柜|</p><p>|昆虫|蜜蜂、甲虫、蝴蝶、毛毛虫、蟑螂|</p><p>|大型食肉动物|熊、豹、狮子、老虎、狼|</p><p>|大型人造户外物品|桥梁、城堡、房屋、道路、摩天大楼|</p><p>|大型自然户外场景|云、森林、山脉、平原、海洋|</p><p>|大型杂食动物和草食动物|骆驼、牛、黑猩猩、大象、袋鼠|</p><p>|中型哺乳动物|狐狸、豪猪、负鼠、浣熊、臭鼬|</p><p>|非昆虫无脊椎动物|螃蟹、龙虾、蜗牛、蜘蛛、蠕虫|</p><p>|人|婴儿，男孩，女孩，男人，女人|</p><p>|爬行动物|鳄鱼、恐龙、蜥蜴、蛇、乌龟|</p><p>|小型哺乳动物|仓鼠、老鼠、兔子、鼩鼩、松鼠|</p><p>|树木|枫树、橡树、棕榈树、松树、柳树|</p><p>|车辆1|自行车、公共汽车、摩托车、皮卡、火车|</p><p>|车辆2|割草机、火箭、有轨电车、坦克、拖拉机|</p><p>是的，我知道蘑菇不是真正的水果或蔬菜，熊也不是真正的食肉动物。</p><h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><p>|版本|大小|md5sum|</p><p>| —————————————————————————————— | ——— | ———————————————— |</p><p>|[CIFAR-100 python版本](<a href="http://www.cs.toronto.edu/~kriz/cifar-100-python.tar.gz）|161">http://www.cs.toronto.edu/~kriz/cifar-100-python.tar.gz）|161</a> MB | eb9058c3a382ffc7106e4002c42a8d85|</p><p>|[CIFAR-100 Matlab版本](<a href="http://www.cs.toronto.edu/~kriz/cifar-100-matlab.tar.gz）|175">http://www.cs.toronto.edu/~kriz/cifar-100-matlab.tar.gz）|175</a> MB |6a4bfa1dcd5c9453dda6bb54194911f4|</p><p>|[CIFAR-100二进制版本（适用于C程序）](<a href="http://www.cs.toronto.edu/~kriz/cifar-100-二进制.tar.gz）|161">http://www.cs.toronto.edu/~kriz/cifar-100-二进制.tar.gz）|161</a> MB |03b5dce0913d631647c71ecec9e9cb8|</p><p>数据集布局</p><p>python/Matlab版本</p><p>python和Matlab版本在布局上与CIFAR-10相同，所以我不会在这里浪费空间来描述它们。</p><p>二进制版本</p><p>CIFAR-100的二进制版本与CIFAR-10的二进制版本一样，只是每个图像都有两个标签字节（粗略和精细）和3072个像素字节，所以二进制文件看起来是这样的：</p><pre class="line-numbers language-none"><code class="language-none">&lt;1 x粗略标签&gt;&lt;1 x精细标签&gt;&lt;3072 x像素&gt;...&lt;1 x粗略标签&gt;&lt;1 x精细标签&gt;&lt;3072 x像素&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Sivan Sabato好心地提供了[这份文件](<a href="http://www.cs.toronto.edu/~kriz/cifar_indexes），它将cifar-100图像映射到8000万微小图像数据集中的图像。Sivan写道：">http://www.cs.toronto.edu/~kriz/cifar_indexes），它将cifar-100图像映射到8000万微小图像数据集中的图像。Sivan写道：</a></p><pre class="line-numbers language-none"><code class="language-none">该文件有60000行，每行都包含一个指向微小数据库的索引，其中微小数据库中的第一个图像被索引为“1”。“0”表示不是来自微小数据库的图像。前50000行对应于训练集，后10000行对应到测试集。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>​        本技术报告（第3章）更详细地描述了数据集以及收集数据时所遵循的方法。如果您打算使用此数据集，请引用它。</p><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>​        dataLoader意如其名，就是（从dataset）加载数据集</p><p><img src="image-20230520131556354.png" alt="image-20230520131556354"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token comment"># 测试集</span>test_data <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span>train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token operator">=</span>test_data<span class="token punctuation">,</span>batch_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>num_workers<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>drop_last<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># 第一张样本</span>img<span class="token punctuation">,</span>target <span class="token operator">=</span> test_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token comment"># 可以看看样本</span><span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span>targets <span class="token operator">=</span>data    <span class="token keyword">print</span><span class="token punctuation">(</span>imgs<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>targets<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以使用SummaryWriter 来展示之：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriter<span class="token comment"># 测试集</span>test_data <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span>train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token operator">=</span>test_data<span class="token punctuation">,</span>batch_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>num_workers<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>drop_last<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># 第一张样本</span>img<span class="token punctuation">,</span>target <span class="token operator">=</span> test_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>step <span class="token operator">=</span> <span class="token number">0</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"dataLoader"</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span>targets <span class="token operator">=</span>data    <span class="token comment"># print(imgs.shape)</span>    <span class="token comment"># print(targets)</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"test_data"</span><span class="token punctuation">,</span>imgs<span class="token punctuation">,</span>step<span class="token punctuation">)</span>    step <span class="token operator">=</span> step <span class="token operator">+</span> <span class="token number">1</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tensorboard <span class="token assign-left variable">logdir</span><span class="token operator">=</span><span class="token string">"dataLoader"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230520132604606.png" alt="image-20230520132604606"></p><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>​        先扔一个<code>pytorch</code>的官网！<a href="https://pytorch.org/docs">https://pytorch.org/docs</a>        </p><p>​        继续：</p><p>​        这是参数：作为图像处理常用的是Conv2d</p><div class="table-container"><table><thead><tr><th><a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv1d.html#torch.nn.Conv1d"><code>nn.Conv1d</code></a></th><th>Applies a 1D convolution over an input signal composed of several input planes.</th></tr></thead><tbody><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d"><code>nn.Conv2d</code></a></td><td>Applies a 2D convolution over an input signal composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv3d.html#torch.nn.Conv3d"><code>nn.Conv3d</code></a></td><td>Applies a 3D convolution over an input signal composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose1d.html#torch.nn.ConvTranspose1d"><code>nn.ConvTranspose1d</code></a></td><td>Applies a 1D transposed convolution operator over an input image composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose2d.html#torch.nn.ConvTranspose2d"><code>nn.ConvTranspose2d</code></a></td><td>Applies a 2D transposed convolution operator over an input image composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose3d.html#torch.nn.ConvTranspose3d"><code>nn.ConvTranspose3d</code></a></td><td>Applies a 3D transposed convolution operator over an input image composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConv1d.html#torch.nn.LazyConv1d"><code>nn.LazyConv1d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv1d.html#torch.nn.Conv1d"><code>torch.nn.Conv1d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>Conv1d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConv2d.html#torch.nn.LazyConv2d"><code>nn.LazyConv2d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d"><code>torch.nn.Conv2d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>Conv2d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConv3d.html#torch.nn.LazyConv3d"><code>nn.LazyConv3d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv3d.html#torch.nn.Conv3d"><code>torch.nn.Conv3d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>Conv3d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConvTranspose1d.html#torch.nn.LazyConvTranspose1d"><code>nn.LazyConvTranspose1d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose1d.html#torch.nn.ConvTranspose1d"><code>torch.nn.ConvTranspose1d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>ConvTranspose1d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConvTranspose2d.html#torch.nn.LazyConvTranspose2d"><code>nn.LazyConvTranspose2d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose2d.html#torch.nn.ConvTranspose2d"><code>torch.nn.ConvTranspose2d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>ConvTranspose2d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConvTranspose3d.html#torch.nn.LazyConvTranspose3d"><code>nn.LazyConvTranspose3d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose3d.html#torch.nn.ConvTranspose3d"><code>torch.nn.ConvTranspose3d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>ConvTranspose3d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold"><code>nn.Unfold</code></a></td><td>Extracts sliding local blocks from a batched input tensor.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Fold.html#torch.nn.Fold"><code>nn.Fold</code></a></td><td>Combines an array of sliding local blocks into a large containing tensor.</td></tr></tbody></table></div><p>​        点进去看看：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">CLASS <span class="token class-name">torch</span><span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> dilation<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> groups<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> padding_mode<span class="token operator">=</span><span class="token string">'zeros'</span><span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        Applies a 2D convolution over an input signal composed of several input planes.</p><p>In the simplest case, the output value of the layer with input size </p><script type="math/tex; mode=display">(N,C_{in},H,W)</script><p>​        and output</p><script type="math/tex; mode=display">(N,C_{out},H_{out},W_{out})</script><p>​         can be precisely described as:</p><script type="math/tex; mode=display">out(N_i,C_{outj}) = bias(C_{outj})+\sum_{k=0}^{C_{in}-1}weight(C_{out},k)*input(N_i,k)</script><p>​        where ⋆ is the valid 2D <a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a> operator, <em>N</em> is a batch size, C<em> denotes a number of channels, </em>H<em> is a height of input planes in pixels, and </em>W* is width in pixels.</p><p>​        This module supports <a href="https://pytorch.org/docs/stable/notes/cuda.html#tf32-on-ampere">TensorFloat32</a>.</p><p>​        On certain ROCm devices, when using float16 inputs this module will use <a href="https://pytorch.org/docs/stable/notes/numerical_accuracy.html#fp16-on-mi200">different precision</a> for backward.</p><ul><li><p><code>stride</code> controls the stride for the cross-correlation, a single number or a tuple.</p></li><li><p><code>padding</code> controls the amount of padding applied to the input. It can be either a string {‘valid’, ‘same’} or an int / a tuple of ints giving the amount of implicit padding applied on both sides.</p></li><li><p><code>dilation</code> controls the spacing between the kernel points; also known as the à trous algorithm. It is harder to describe, but this <a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a> has a nice visualization of what <code>dilation</code> does.</p></li><li><p><code>groups</code> controls the connections between inputs and outputs. <code>in_channels</code> and <code>out_channels</code> must both be divisible by <code>groups</code>. For example,</p><blockquote><ul><li>At groups=1, all inputs are convolved to all outputs.</li><li>At groups=2, the operation becomes equivalent to having two conv layers side by side, each seeing half the input channels and producing half the output channels, and both subsequently concatenated.</li><li>At groups= <code>in_channels</code>, each input channel is convolved with its own set of filters (of size $\frac{in_channels}{out_channels}$)</li></ul></blockquote></li></ul><p>​        The parameters <code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> can either be:</p><blockquote><ul><li>a single <code>int</code> – in which case the same value is used for the height and width dimension</li><li>a <code>tuple</code> of two ints – in which case, the first int is used for the height dimension, and the second int for the width dimension</li></ul></blockquote><p>​        When groups == in_channels and out_channels == K * in_channels, where K is a positive integer, this operation is also known as a “depthwise convolution”.</p><p>​        In other words, for an input of size $(N,C_{in},L_{in})$, a depthwise convolution with a depthwise multiplier<em>K</em> can be performed with the arguments ($C_{in}=C_{in},C_{out}=C_{in}×K,…,groups=C_{in}$.)</p><p>​        In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting </p><pre class="line-numbers language-none"><code class="language-none">torch.backends.cudnn.deterministic &#x3D; True. <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        See <a href="https://pytorch.org/docs/stable/notes/randomness.html">Reproducibility</a> for more information.</p><p>​        <code>padding=&#39;valid&#39;</code> is the same as no padding. <code>padding=&#39;same&#39;</code> pads the input so the output has the shape as the input. However, this mode doesn’t support any stride values other than 1.</p><p>​        This module supports complex data types i.e. <code>complex32, complex64, complex128</code>.</p><p>Parameters:</p><ul><li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>) – Number of channels in the input image</li><li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>) – Number of channels produced by the convolution</li><li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a>) – Size of the convolving kernel</li><li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>optional</em>) – Stride of the convolution. Default: 1</li><li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a><em>,</em> <em>optional</em>) – Padding added to all four sides of the input. Default: 0</li><li><strong>padding_mode</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a><em>,</em> <em>optional</em>) – <code>&#39;zeros&#39;</code>, <code>&#39;reflect&#39;</code>, <code>&#39;replicate&#39;</code> or <code>&#39;circular&#39;</code>. Default: <code>&#39;zeros&#39;</code></li><li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>optional</em>) – Spacing between kernel elements. Default: 1</li><li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em> <em>optional</em>) – Number of blocked connections from input channels to output channels. Default: 1</li><li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool"><em>bool</em></a><em>,</em> <em>optional</em>) – If <code>True</code>, adds a learnable bias to the output. Default: <code>True</code></li></ul><h2 id="what-is-Convolution-arithmetic-from-read-ME"><a href="#what-is-Convolution-arithmetic-from-read-ME" class="headerlink" title="what is Convolution arithmetic(from read ME)"></a>what is Convolution arithmetic(from read ME)</h2><p>​        A technical report on convolution arithmetic in the context of deep learning.</p><p>​        The code and the images of this tutorial are free to use as regulated by the<br>licence and subject to proper attribution:</p><ul><li>[1] Vincent Dumoulin, Francesco Visin - <a href="https://arxiv.org/abs/1603.07285">A guide to convolution arithmetic<br>for deep learning</a><br>(<a href="https://gist.github.com/fvisin/165ca9935392fa9600a6c94664a01214">BibTeX</a>)</li></ul><h2 id="Convolution-animations"><a href="#Convolution-animations" class="headerlink" title="Convolution animations"></a>Convolution animations</h2><p>_N.B.: Blue maps are inputs, and cyan maps are outputs._</p><table style="width:100%; table-layout:fixed;">  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/no_padding_no_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/arbitrary_padding_no_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/same_padding_no_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/full_padding_no_strides.gif"></td>  </tr>  <tr>    <td>No padding, no strides</td>    <td>Arbitrary padding, no strides</td>    <td>Half padding, no strides</td>    <td>Full padding, no strides</td>  </tr>  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/no_padding_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/padding_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/padding_strides_odd.gif"></td>    <td></td>  </tr>  <tr>    <td>No padding, strides</td>    <td>Padding, strides</td>    <td>Padding, strides (odd)</td>    <td></td>  </tr></table><h2 id="Transposed-convolution-animations"><a href="#Transposed-convolution-animations" class="headerlink" title="Transposed convolution animations"></a>Transposed convolution animations</h2><p>_N.B.: Blue maps are inputs, and cyan maps are outputs._</p><table style="width:100%; table-layout:fixed;">  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/no_padding_no_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/arbitrary_padding_no_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/same_padding_no_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/full_padding_no_strides_transposed.gif"></td>  </tr>  <tr>    <td>No padding, no strides, transposed</td>    <td>Arbitrary padding, no strides, transposed</td>    <td>Half padding, no strides, transposed</td>    <td>Full padding, no strides, transposed</td>  </tr>  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/no_padding_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/padding_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/padding_strides_odd_transposed.gif"></td>    <td></td>  </tr>  <tr>    <td>No padding, strides, transposed</td>    <td>Padding, strides, transposed</td>    <td>Padding, strides, transposed (odd)</td>    <td></td>  </tr></table><h2 id="Dilated-convolution-animations"><a href="#Dilated-convolution-animations" class="headerlink" title="Dilated convolution animations"></a>Dilated convolution animations</h2><p>_N.B.: Blue maps are inputs, and cyan maps are outputs._</p><table style="width:25%"; table-layout:fixed;>  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/dilation.gif"></td>  </tr>  <tr>    <td>No padding, no stride, dilation</td>  </tr></table><h2 id="Generating-the-Makefile"><a href="#Generating-the-Makefile" class="headerlink" title="Generating the Makefile"></a>Generating the Makefile</h2><p>From the repository’s root directory:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./bin/generate_makefile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Generating-the-animations"><a href="#Generating-the-animations" class="headerlink" title="Generating the animations"></a>Generating the animations</h2><p>From the repository’s root directory:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> all_animations<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The animations will be output to the <code>gif</code> directory. Individual animation steps<br>will be output in PDF format to the <code>pdf</code> directory and in PNG format to the<br><code>png</code> directory.</p><h2 id="Compiling-the-document"><a href="#Compiling-the-document" class="headerlink" title="Compiling the document"></a>Compiling the document</h2><p>From the repository’s root directory:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230528203415187.png" alt="image-20230528203415187"></p><p>​        其实就是这样，我们3 x 3的扫过图像，并且对之求和输出到新单元，我们发现他会做九次。，故得到了一个 3 x 3的表。</p><p><img src="image-20230528203830290.png" alt="image-20230528203830290"></p><p>​        这样就可以升维了，从而提取信息特征。</p><p><img src="image-20230528213941244.png" alt="image-20230528213941244"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> Conv2d<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoaderdataset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span><span class="token string">"../data"</span><span class="token punctuation">,</span>train <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span>                                       transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        download<span class="token operator">=</span><span class="token boolean">True</span>                                       <span class="token punctuation">)</span>dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span>batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">cc</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>cc<span class="token punctuation">,</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>out_channels<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> xc <span class="token operator">=</span> cc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> dataloader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span>data    output <span class="token operator">=</span> c<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>imgs<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们把它输出到tensorboard里去：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> Conv2d<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriterdataset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span><span class="token string">"../data"</span><span class="token punctuation">,</span>train <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span>                                       transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        download<span class="token operator">=</span><span class="token boolean">True</span>                                       <span class="token punctuation">)</span>dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span>batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">cc</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>cc<span class="token punctuation">,</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>out_channels<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> xc <span class="token operator">=</span> cc<span class="token punctuation">(</span><span class="token punctuation">)</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"../logs"</span><span class="token punctuation">)</span>step <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> data <span class="token keyword">in</span> dataloader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span>data    output <span class="token operator">=</span> c<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>imgs<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    output <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span>imgs<span class="token punctuation">,</span>step<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">,</span> output<span class="token punctuation">,</span> step<span class="token punctuation">)</span>    step <span class="token operator">=</span> step <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>yolofacev5<span class="token punctuation">)</span> pythonProject<span class="token operator"><span class="token file-descriptor important">1</span>></span> <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span class="token punctuation">(</span>yolofacev5<span class="token punctuation">)</span> pythonProject<span class="token operator"><span class="token file-descriptor important">1</span>></span> tensorboard <span class="token parameter variable">--logdir</span><span class="token operator">=</span>logs      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230528214836000.png" alt="image-20230528214836000"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> AI </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP_ExtensiveReadingNotes-2-MoreEffectiveCPP</title>
      <link href="/2023/06/06/CPP-ExtensiveReadingNotes-2-MoreEffectiveCPP/"/>
      <url>/2023/06/06/CPP-ExtensiveReadingNotes-2-MoreEffectiveCPP/</url>
      
        <content type="html"><![CDATA[<h1 id="More-Effective-C"><a href="#More-Effective-C" class="headerlink" title="More Effective C++"></a>More Effective C++</h1><h2 id="Basic-Issues"><a href="#Basic-Issues" class="headerlink" title="Basic Issues"></a>Basic Issues</h2><p>我们现在开始C++的一大名著阅读.在这个sections，更多关注的是基础的C++议题。</p><h3 id="条款1-区分pointers-和-reference"><a href="#条款1-区分pointers-和-reference" class="headerlink" title="条款1 区分pointers 和 reference"></a>条款1 区分pointers 和 reference</h3><p>​        Pointers和reference确实不一样。在使用方式上，我们对Pointers是*（解引用）和<code>-&gt;</code>的方式来访问Reference确跟对象本身一样，访问成员使用 . </p><p>​        作为Reference，不存在空引用！也就是说，不存在一个引用不指向任何对象。这点上，真是跟指针不大一样！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char* pc &#x3D; 0;char* pc1 &#x3D; &amp;aCh; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        当然，那这样如何呢？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char *pc &#x3D; 0;char&amp; rc &#x3D; *pc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        答案是未定义行为！千万别显示的，或者是隐式的做这样的事情！</p><p>​        其二，基于上面的阐述，被引用的对象——必须——在引用之前就被初始化！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string&amp; rs; &#x2F;&#x2F; 不存在这样的代码！这是非法的string s(&quot;xxyyzz&quot;);string&amp; rs &#x3D; s;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        相对应的——</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string* ps;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        通过编译！但是，比如说我的编译器会警告你没有初始化。于是，有必要对指针的合法性进行判断，而引用从来没有必要关注这件事情。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;void checkPointersValid(double* pt) &#123;if (pt &#x3D;&#x3D; nullptr) &#123;throw &quot;trying to use empty double pointer! that&#39;s really bad :(&quot;;return;&#125;std::cout &lt;&lt; &quot;Got value:&gt; &quot; &lt;&lt; *pt &lt;&lt; std::endl;return;&#125;void Processing(double* pt) &#123;try &#123;checkPointersValid(pt);&#125;catch (const char* errorStr) &#123;std::cout &lt;&lt; errorStr &lt;&lt; std::endl;exit(-1);&#125;return;&#125;int main() &#123;double val &#x3D; 10;double* p1 &#x3D; &amp;val;double* null &#x3D; nullptr;Processing(p1);Processing(null);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        很是复杂。。。</p><p>​        另一个重要的区别在于：pointers是可变的，它可以从指向一个内存，原生的话，不加以说明的——指向另一块内存，而不会告诉你这件事情——这是很危险的（对于指向堆内存的话，容易造成泄漏）。但是reference就相当于常指针，总是指向那个对象不会改变。</p><p>​        总结来看：当你——需要考虑到“不指向任何对象”的可能性时，或者考虑：在不同时间需要指向不同对象的可能性时，有必要使用指针来完成你的工作，其余的情况下可以使用reference。</p><h3 id="条款2：最好使用C-转型操作符"><a href="#条款2：最好使用C-转型操作符" class="headerlink" title="条款2：最好使用C++转型操作符"></a>条款2：最好使用C++转型操作符</h3><p>​        在旧时的C语言，我们如下转换类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">(target_type)expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然而，这样的作法没有经过检查且辨识度太低了：为了解决这个问题，C++引入了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">static_cast&lt;target_type&gt;(expression)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        来个例子：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int res1 &#x3D; 10, res2 &#x3D; 20;double do_res &#x3D; static_cast&lt;double&gt;(res1)&#x2F;res2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        static_cast跟旧时的C一样有威力，也拥有一样的限制。甚至不可以移除const修饰符，于是const_cast来干这个事情了。</p><p>​        const_cast只可以改变变量的常量性和变易性。其余的都改变不了！</p><p><img src="image-20230514123125051-16844694129151.png" alt="image-20230514123125051"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class widget &#123;public:int a;&#125;;class specialWidget :public widget &#123;public:int b;&#125;;void update(specialWidget* psw) &#123;&#125;int main() &#123;specialWidget sw;const specialWidget&amp; csw &#x3D; sw;update(&amp;csw); &#x2F;&#x2F; invalidupdate(const_cast&lt;specialWidget*&gt;(&amp;csw)); &#x2F;&#x2F; finish work properly!update((specialWidget*)&amp;csw);widget* pw &#x3D; new specialWidget;update(pw);&#x2F;&#x2F;error ： 类型错误，不可以需要孩子传父亲！update(const_cast&lt;specialWidget*&gt;(pw)); &#x2F;&#x2F; error&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还有个dynamic_cast，特别用在了安全的向下转性或者跨系转型的动作。也就是说，可以将指向基类的指针或引用转向指向派生或者是兄弟类的类的指针或者是引用。他没有办法用在缺乏虚函数的类型，也不可改变常量性！</p><h3 id="条款3：不要以多态的方式处理数组"><a href="#条款3：不要以多态的方式处理数组" class="headerlink" title="条款3：不要以多态的方式处理数组"></a>条款3：不要以多态的方式处理数组</h3><p>​        继承的最重要的性质之一就是可以通过指向基类的指针或者是引用来操纵派生类。比如说</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class BST&#123;...&#125;class BalancedBST: public BST&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        打印这些东西，我们涉及到：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PrintBSTArray(ostream&amp; os,const BSTarray[],int numElems)&#123;    &#x2F;&#x2F; omit some basic check    for(int i &#x3D; 0; i &lt; int numElems; i++)&#123;        os&lt;&lt;array[i]; &#x2F;&#x2F; pretended that it has already been designed for using &lt;&lt;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是下一次传入：BalancedBST的时候，我们却依然实际上生成的是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">os &lt;&lt; array + sizeof(BST)*i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        而不是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">os &lt;&lt; array + sizeof(BalancedBST)*i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这很麻烦了！倘若这个函数是删除元素的话，就意味着删除是不完全的！因为基类总是不会比派生类小的！而且行为未定义！极易造成程序的崩溃！所以不要一多态的方式来处理数组，是啥就是啥的处理！</p><h3 id="条款四：非必要不提供默认构造函数"><a href="#条款四：非必要不提供默认构造函数" class="headerlink" title="条款四：非必要不提供默认构造函数"></a>条款四：非必要不提供默认构造函数</h3><p>​        Default constructors是C++从无到有的生成一个对象的办法。这个东西你不指定初始化方法，其成员也会拥有一些值——对于数值者是０或者是其他些什么无意义的随机值，对于指针者是nullptr。一些内置的数据结构被初始化作空容器。</p><p>​        但是有一些类，倘若我们不提供任何其他信息，是不应该存在的！也就是说：一些可以从无到有的类才适合default constructor.反之不需要。比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class EquipmentPieces&#123;      public:    EquipmentPieces(int ID);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是不难意料到：这样的初始化不可能合法：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">EquipmentPieces EqVec[10];&#x2F;&#x2F; no Default constructors<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        哪有该怎么办嘞，要不我们：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int IDArray[]&#x3D;&#123;1,2,3,...&#125;;&#x2F;&#x2F; make the Id valid previouslyEquipmentPiece eqVec[10] &#x3D; &#123;        EquipmentPiece(IDArray[0]),    EquipmentPiece(IDArray[1]),    ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是这没办法解决我们在堆上完成类似的行为。于是，我们不妨先声明指针数组</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef EquipmentPieces* PEP;PEP aPointerArray[10];&#x2F;&#x2F; in stackPEP aPointerArrayInHeap[10] &#x3D; new PEP[10];for(int i &#x3D; 0; i &lt; 10; i++)&#123;        aPointerArrayInHeap[i] &#x3D; new EquipmentPieces(ID[i]);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        麻烦在于，我们必须记住我们在这里开辟了内存，是需要我们手动释放的。其次，可能指针本身还要占据内存，这是不好的。</p><p>​        于是还有第三种方法，那就是类似于C式的——先分配空数据，让数组指针指向之！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* rawMem &#x3D; operator new[](10*sizeof(EquipmentPiece));EquipmentPiece* EPArray &#x3D; static_cast&lt;EquipmentPiece*&gt; (rawMem);for(int i &#x3D; 0; i &lt; 10; i++)&#123;    new(&amp;bestPieces[i]) EquipmentPieces(ID[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        就算如此，你会发现还得是要手动初始化！况且，释放掉他需要很麻烦的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for(int i &#x3D; 0 i &gt;&#x3D; 0; i--)&#123;epVec[i].~EquipmentPieces();&#125;operator delete[](rawMem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        一个没有默认构造器的类很快还会有第二个麻烦，那就是没办法直接调用大部分的模板！你当然可以谨慎的设计之来回避这个问题。但是大部分人只有会在出现问题的时候想起来这回事情。</p><p>​        所以要不要它呢？注意到如果一切类都给了默认构造器，我们就必须手动的检查它，否则会产生大量的问题！</p><p>​        于是，还是回到这里：倘若我们不提供任何其他信息，是不应该存在的！也就是说：一些可以从无到有的类才适合default constructor.反之不需要！</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="条款5：对定制的类型转换符保持警觉"><a href="#条款5：对定制的类型转换符保持警觉" class="headerlink" title="条款5：对定制的类型转换符保持警觉"></a>条款5：对定制的类型转换符保持警觉</h3><p>​        C++自然允许不同类型之间的隐式转换，我是说，比如说</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">short a &#x3D; 10;double b &#x3D; a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        居然是可行的！这还好，C++甚至可以：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">double b &#x3D; 10.00；char a &#x3D; b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这样会造成信息丢失的转换都是可以正常运行的！ 这是因为C++编译器会想尽办法的找到</p><p>​        于是，在C++的类设计上，有必要专门提供一个转换函数来促使之客户程序员调用，</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Rational&#123;public:    Rational(double a, double b); &#x2F;&#x2F; make a&#x2F;b &#125;;Rational r(1,2);cout &lt;&lt; r;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这居然是可以输出的：0.5！</p><p>​        这是因为C++编译器会想尽办法的找到转化方式。这就很容易造成自己不期望你被调用的函数被调用了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Rational&#123;public:    Rational(double a, double b); &#x2F;&#x2F; make a&#x2F;b 、    double asDouble() const;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，显示的调用即可：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cout &lt;&lt; r.asDouble()&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        或者，采用关键字explict来防止隐式转换！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class Array&#123;    public:    ...        explicit Array(int num);    ...&#125;;Array&lt;int&gt; a(10);Array&lt;int&gt; b(10);if(a &#x3D;&#x3D; b[i])&#x2F;&#x2F; invalid!!! as it is expicited, you can not transform it underconciously!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款6区分前置操作符和后置操作符"><a href="#条款6区分前置操作符和后置操作符" class="headerlink" title="条款6区分前置操作符和后置操作符"></a>条款6区分前置操作符和后置操作符</h3><p>​        在很久以前的C++，没办法区分前置＋＋和后置＋＋（或者－－）。于是，我们这样设计类来防止语法混淆：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;class UpInt &#123;public:UpInt(int i) :_val(i) &#123;&#125;;UpInt&amp; operator++() &#123; this-&gt;_val++; return *this; &#125;;const UpInt operator++(int) &#123; UpInt old &#x3D; *this; ++(*this); return old; &#125;;UpInt&amp; operator--()&#123; this-&gt;_val--; return *this; &#125;const UpInt operator--(int) &#123; UpInt old &#x3D; *this; --(*this); return old; &#125;;int getVal()const &#123; return _val; &#125;private:int _val;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; os, const UpInt&amp; my_data) &#123; os &lt;&lt; my_data.getVal() &lt;&lt; endl; return os; &#125;;int main() &#123;UpInt val(10);++val;cout &lt;&lt; val;--val;cout &lt;&lt; val;val++;cout &lt;&lt; val;val--;cout &lt;&lt; val;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为什么:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const UpInt operator++(int) &#123; UpInt old &#x3D; *this; ++(*this); return old; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为我们是为了防止:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int i &#x3D; 0;i++++; &#x2F;&#x2F; invalid! C++ abandon this behaviors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        所以就是直接禁止!只需要加个const将返回的对象常量化!就好了</p><h3 id="条款7：千万不要重载-amp-amp-和-操作符"><a href="#条款7：千万不要重载-amp-amp-和-操作符" class="headerlink" title="条款7：千万不要重载&amp;&amp;,|| 和 , 操作符"></a>条款7：千万不要重载&amp;&amp;,|| 和 , 操作符</h3><p>​        继承于C的，C++对真假值的逻辑表达式也是采用“骤死式”的判别表达式。也就是说，针对这样的表达式：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char* p;...&#x2F;&#x2F; probably init the string or notif((p !&#x3D; NULL) &amp;&amp; (strlen(p) &gt; 10))&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不需要担心strlen(p)会使用空指针，事实上，一旦判定 p == NULL，那就意味着这个表达式一定为假，就不需要我们去计算第二个式子。于是第二条甚至不会执行。</p><p>​        但是，一旦我们重载了，就无法预期编译器的行为。</p><p>​        于是在C++中，一些运算符是不可以重载的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">..*::?: new  deletesizeoftypeidstatic_castdynamic_castconst_castreinterpret_cast<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="条款8：了解不同含义的new和delete"><a href="#条款8：了解不同含义的new和delete" class="headerlink" title="条款8：了解不同含义的new和delete"></a>条款8：了解不同含义的new和delete</h3><p>​        我们必须指出，C++的语言有时候确实令人感到难绷，比如说我们会说new operator和operator new 不是一件事情！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string* phs &#x3D; new string(&quot;Memory Managements&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        首先，这个new式语言内建的，就是说：首先他分配足够多的内存，放置一个东西。然后调用编译器找到的最合适的初始constructor来完成初始化工作！这样的行为不可以我们改变。</p><p>​        我们可以改变什么啥呢？改变operator new。什么意思？我们发现，new在一些适合调用一个函数执行必要的内存分配空间。这个函数我们可以重写！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* operator new(size_t size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也就是说，这是一个操作符函数，该函数返回一个空的内存！嘿，就像malloc函数一样！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* rawMem &#x3D; operator new(sizeof(string));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        于是，new operator实际上就是operator new + 内存初始化了</p><pre class="line-numbers language-none"><code class="language-none">string* phs &#x3D; new string(&quot;Memory Managements&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        等价于</p><pre class="line-numbers language-none"><code class="language-none">void* tempName &#x3D; operator new(sizeof(string));call the func &gt;&gt; string::string(&quot;Memory Managements&quot;); on tempmemorystring* ps &#x3D; static_cast&lt;string*&gt;(memory);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        还有一种有趣的new ，叫placement new. 啥意思？就是我们已经知道了指定了一个地方就要放摸一个类的对象，那就可以用之</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Widget&#123;    public:    Widget(size_t size);    ...&#125;;Widget* constructWidgetInBuffer(void* buffer,size_t size)&#123; return new(buffer) Widget(size);   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        欸我的嘛，抽象！其实这是在隐式的调用operator new</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* operator new(size_t size,void* locations)&#123;        return locations;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Deletion-amp-amp-Deallocation"><a href="#Deletion-amp-amp-Deallocation" class="headerlink" title="Deletion &amp;&amp; Deallocation"></a>Deletion &amp;&amp; Deallocation</h4><p>​        为了避免 resource leak （资源泄露），每一个动态分配行为都必须分配一个。函数operator delete 对于内建的delete operator 对于内建的 delete operator ，好像operator new 对于 new operator 一样。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string* ps;&#x2F;&#x2F;...delete ps;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>     你的编译器必须产生怎样的代码？它必须可以析构ps所指对象。又可以释放该对象占用的内存。</code></pre><p>​        内存释放动作由于函数operator delete 执行。通常声明如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void operator delete(void* memoryToBeDeallocated);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        由此delete ps;</p><p>​        造成编译器产生这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ps-&gt;~string();operator delete(ps);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这里呈现的一个暗示就是，如果你只打算处理原始的，未设置初值的内存，应该完全回避new operator 和 delete operators。改用operator new取得内存并以 operator delete 归还给系统。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* buffer &#x3D; operator new(50*sizeof(char));&#x2F;&#x2F;...operator delete(buffer);    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>     这组行为在C++相当于malloc和free.</code></pre><p>​        如果你使用placement new, 在某内存块中产生的对象，你应该避免对那块内存使用 delete operator. 因为delete operator调用operator delete释放内存，但是该内存含有的对象最初并非是由operator new 分配得来的。毕竟placement new只是返回它所接受的指针而已，谁知道那个指针从哪里来呢？所以为了抵消该对象的构建器的影响，我们选择直接调用对象的destructor。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* mallocShared(size_t size);void freeShared(void *memory);void *sharedMemory &#x3D; mallocShared(sizeof(Widget));Widget* pW &#x3D; constructWidgetInBuffer(sharedMemory,10);...&#x2F;&#x2F; delete pW; 不要这样做！没有意义，因为sharedMemory来自mallocShared函数而不是new 出来的！pW-&gt;~Widget();&#x2F;&#x2F;可以的！手动调用析构器是允许的freeShared(pW);&#x2F;&#x2F; 可以的！释放pW所指向的内存，不调用任何destructor!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Arrays数组"><a href="#Arrays数组" class="headerlink" title="Arrays数组"></a>Arrays数组</h4><p>​        下面，我们考虑一些更远的事情，我是说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string* ps &#x3D; new string[10];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用的还是new operator，但是这次是数组！于是，我们实际上调用的是它的兄弟oprator new[ ]!当然这也就意味着我们可以重写之，但是往往重写全局的new函数是不明智的，因为其他的new operator也会发生行为的改变而使得程序发生剧烈的变化！</p><p>​        类似的，删除使用了new operator</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>​        C++增加了Exceptions 之后，改变了太多的事情。比如说原始指针的使用成为了一个高风险事件，资源泄露的风险也是大增。</p><p>​        但是为了使程序可以在触发异常后安全的退出程序，就必须使用它来处理推出前的工作！</p><h3 id="条款9：使用destructor来防止内存泄漏"><a href="#条款9：使用destructor来防止内存泄漏" class="headerlink" title="条款9：使用destructor来防止内存泄漏"></a>条款9：使用destructor来防止内存泄漏</h3><p>​        假设我们现在正在书写一个类（Adorable Little Animal）ALA，我们在之后派生出来了小猫和小狗两个类</p><p><img src="image-20230519100041781-16844694129162.png" alt="image-20230519100041781"></p><p>​        为了实现领养工作，我们在抽象类下书写虚函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class ALA &#123;public:virtual void processAdoption() &#x3D; 0;&#x2F;&#x2F; 强迫重写protected:string name;&#125;;class Puppy : public ALA&#123;public:virtual void processAdoption();&#125;;class Kitten :public ALA &#123;public:virtual void processAdoption();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        大致如此</p><p>​        现在我们需要读取星系返回一个ALA指针</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ALA* readALA(istream&amp; s);&#x2F;&#x2F; 不在谈论怎么实现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        于是，我们的收养问题实际上可以这样书写：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 框架void processAdoption(istream&amp; dataSource)&#123;while(dataSource)&#123;        ALA *pa &#x3D; readALA(dataSource);        pa-&gt;processAdoption();        delete pa;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这要求我们函数走遍dataSource，处理所有的信息，显然的——我们调用一次，就必须释放一次！</p><p>​        现在出现问题了：假如说我们的 <code>pa-&gt;processAdoption()</code>抛出了一个异常！麻烦大了，这个异常会追溯到调用端，导致<code>delete pa;</code>被跳过了，也就是说，只要触发一次异常，资源泄露一次！</p><p>​        这个时候，C++的Exception就可以出马了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void processAdoption(istream&amp; dataSource)&#123;while(dataSource)&#123;        ALA *pa &#x3D; readALA(dataSource);       try&#123;           pa-&gt;processAdoption();       &#125;        catch(...)&#123;            delete pa;            throw;&#x2F;&#x2F;再把异常传递出去        &#125;        delete pa;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        嘿！实在是太麻烦了！为什么不让delete代码剧中于一处呢？这就是智能指针的来源！我们只需要使用智能指针指向之，当发现需要被析构的时候就直接析构就好了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void processAdoption(istream&amp; dataSource)&#123;    while(dataSource)&#123;        unique_ptr&lt;ALA&gt; pa(readALA(dataSource));        pa-&gt;processAdoption();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        隐藏在智能指针背后的理念是——以一个对象存放“必须自动释放的资源”，并且是依赖他自己的destructor来干这样的事情。</p><p>​        下面来看窗口设计，比如说我们来看使用窗口显示信息</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void displayInfo(const Information&amp; info)&#123;    WINDOW_HANDLE w(createWindow());        &#x2F;&#x2F;displayInfo here        destroyWindow(w);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是先前的问题，如果允许时发生了exception，我们怎么办？</p><p>​        我们设计一个class：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class WindowHandle&#123;    public:    WindowHnadle(WINDOW_HANDLE handle):w(handle)&#123;&#125;;    ~WindowHandle()&#123;destroyWindow(w)&#125;;    operator WINDOW_HANDLE()&#123;return w;&#125;;        private:    WINDOW_HANDLE w;    WindowHandle(const WindowHandle&amp;);    WindowHandle&amp; operator&#x3D;(const WindowHandle);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们把复制和赋值行为给静止了，同时还给予了一个隐式操作符！，于是，这个函数的设计变得十分的简单：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void displayInfo(const Information&amp; info)&#123;   WindowHandle w(createWindow());    &#x2F;&#x2F;displayInfo here&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们把它作为临时对象可以销毁了！</p><h3 id="条款10：在constructor内部阻止内存泄漏"><a href="#条款10：在constructor内部阻止内存泄漏" class="headerlink" title="条款10：在constructor内部阻止内存泄漏"></a>条款10：在constructor内部阻止内存泄漏</h3><p>​        我们再说一遍，Exception的出现不太好，比如说我们正在写通讯录：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;list&gt;using namespace std;class Image &#123;public:Image(const string&amp; imageDataFileName);&#125;;class AudioClip &#123;public:AudioClip(const string&amp; audioDataFileName);&#125;;class PhoneNumber &#123;&#125;;class BookEntry &#123;public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;Image* theImage;AudioClip* theAudioClip;&#125;;BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(0), theAudioClip(0) &#123;if (imageFile !&#x3D; &quot;&quot;) &#123;theImage &#x3D; new Image(imageFile);&#125;if (audioClipFile !&#x3D; &quot;&quot;) &#123;theAudioClip &#x3D; new AudioClip(audioClipFile);&#125;&#125;BookEntry::~BookEntry() &#123;delete theImage;delete theAudioClip;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是当现在有了异常之后，假使我们正在初始化的对象抛出异常，就还会发生资源泄漏，即使使用智能指针也不行，因为其调用的destructor要求对象必须已经构建完整！</p><p>​        解决的办法是，在constructor内部就完成异常处理！</p><p>​        </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(0), theAudioClip(0) &#123;try&#123;if (imageFile !&#x3D; &quot;&quot;) &#123;theImage &#x3D; new Image(imageFile);&#125;if (audioClipFile !&#x3D; &quot;&quot;) &#123;theAudioClip &#x3D; new AudioClip(audioClipFile);&#125;&#125;catch (...) &#123;delete theImage;delete theAudioClip;throw;&#x2F;&#x2F; &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        清除这个过程还是可以抽象成一个私有函数！把他放到类里去：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;list&gt;using namespace std;class Image &#123;public:Image(const string&amp; imageDataFileName);&#125;;class AudioClip &#123;public:AudioClip(const string&amp; audioDataFileName);&#125;;class PhoneNumber &#123;&#125;;class BookEntry &#123;public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;Image* theImage;AudioClip* theAudioClip;void cleanUp();&#125;;void BookEntry::cleanUp() &#123;delete theImage;delete theAudioClip;&#125;BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(0), theAudioClip(0) &#123;try&#123;if (imageFile !&#x3D; &quot;&quot;) &#123;theImage &#x3D; new Image(imageFile);&#125;if (audioClipFile !&#x3D; &quot;&quot;) &#123;theAudioClip &#x3D; new AudioClip(audioClipFile);&#125;&#125;catch (...) &#123;cleanUp();throw;&#x2F;&#x2F; &#125;&#125;BookEntry::~BookEntry() &#123;cleanUp();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们再次改进：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class BookEntry &#123;public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;Image* const theImage;AudioClip* const theAudioClip;void cleanUp();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在外面就必须通过初值链表的方式才会给予之赋值。这样就可以这样给予一个安全的初始化方式</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(imageFile !&#x3D; &quot;&quot;?new Image(ImageFile):0), theAudioClip(audioClipFile !&#x3D; &quot;&quot;? new AudioClip(audioClipFile):0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是这又把问题绕回去了！</p><p>​        于是，为了使异常不流到外面，外面直接使用组合的方式完成任务：其构造函数放到类私有的地方：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class BookEntry&#123;    public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;Image* const theImage;AudioClip* const theAudioClip;void cleanUp();    Image* initImage(const string&amp; imageFile);    AudioClip* initAudioClipFile(const string&amp; audioClipFile);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是可以改写了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(initImage(imageFile)), theAudioClip(initAudioClipFile(audioClipFile))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        把异常处理转换到函数的内部：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Image* BookEntry::initImage(const string&amp; imageFile)&#123;    if(imageFile !&#x3D; &quot;&quot;)        return new ImageFile(imageFile);    else return 0;&#125;&#x2F;&#x2F;这里不用，因为他是第一个被初始化，出现了其他问题会直接被释放<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">AudioClip* BookEntry::initAudioClipFile(const string&amp; audioClipFile)&#123;try&#123;        if(audioClipFile !&#x3D; &quot;&quot;)&#123;            return new AudioClip(audioClipFile);        &#125;       else return 0;    &#125;    catch(...)&#123;        delete theImage;        throw;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        好吧，维护有些困难！那就是用<code>unique_ptr</code>!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class BookEntry&#123;    public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;const unique_ptr&lt;Image&gt; theImage;const unique_ptr&lt;AudioClip&gt; theAudioClip;void cleanUp();    Image* initImage(const string&amp; imageFile);    AudioClip* initAudioClipFile(const string&amp; audioClipFile);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，就可以回到上一个设计了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(imageFile !&#x3D; &quot;&quot;?new Image(ImageFile):0), theAudioClip(audioClipFile !&#x3D; &quot;&quot;? new AudioClip(audioClipFile):0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        同时，不在需要构建手写destructor了，直接放：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::~BookEntry()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款11-禁止异常流出destructor"><a href="#条款11-禁止异常流出destructor" class="headerlink" title="条款11 禁止异常流出destructor"></a>条款11 禁止异常流出destructor</h3><p>​        假设现在外面的析构爆发问题了，我们的办法是：在里头使用try_catch语句接受处理之，甚至是这样：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Session::~Session()&#123;    try&#123;        logDestruction(this);    &#125;    catch(...)&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这使得异常直接被吸收，防止程序调用std::abort()造成释放不完全！</p><h3 id="条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”"><a href="#条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”" class="headerlink" title="条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”"></a>条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”</h3><p>​        首先声明：我们调用函数返回到的是函数的调用端（除非失败了），而异常抛出一定不会回到抛出端！</p><p>​        如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">istream operator&lt;&lt;(istream&amp; s,Widget&amp; w);void passAndThrowWidget()&#123;    Widget localWidget;    cin &gt;&gt; localWidget;    throw localWidget;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们把localWidget交到operator&gt;&gt;手里的时候，没有发生复制行为，而是绑定到reference上操作！（passByReference）,但是Exception不一样！无论是值传递还是引用传递，他都会发生复制行为！这是容易理解的：我们一旦调用了<code>throw localWidget</code>，程序离开函数，造成了<code>localWidget</code>析构，我们的catch如果是reference传递，那传的是一具尸体！好吧，我们就不得不复制了！这造成了throw是很慢的（特别是对象很大的时候）</p><p>​        现在事情复杂起来了！假使我们：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Widget&#123;&#125;;class SpecialWidget:public Widget&#123;&#125;;void passAndThrowWidget()&#123;    SpecialWidget localSpecialWidget;    ...    Widget&amp; rw &#x3D; localSpecialWidget;    throw rw;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不是SpeicalWidget类型！因为这里抛出的是静态类型！复制的永远会是对象的静态类型！这是我们需要注意的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">catch(Widget&amp; w)&#123;    ...    throw;&#125;&#x2F;&#x2F; andcatch(Widget&amp; w)&#123;    ...    throw w;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不是一回事情，前者传入的啥抛出的就是啥！不会发生复制行为。但是第二种就会！于是，有必要对那些就是想要处理的一场样本的对象直接使用</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">throw;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        即可！</p><p>​        对于继承体制的异常处理：必须指出：一个接受基类的catch会接受基类和其派生类！而接受派生类的catch只管派生类：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">try&#123;    ...&#125;catch(base_error)&#123;&#125;catch(derived_error)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的这个设计不合适！因为derived_error catch不到任何异常！这跟虚函数：”最吻合调用机制“不同，catch是最先吻合的调用机制。</p><p>​        总结一下我们的长篇大论：</p><p>​        首先：exception object总是会被复制，使用pass by val会被复制两次！而传递函数的参数则不会</p><p>​        其次：跑出去成为exception的对象允许类转换的动作，比被传递到函数去的对象少。</p><p>​        最后，catch字句是源码顺序调用优先而不是吻合度调用优先！</p><h3 id="条款13-以引用传递捕捉异常"><a href="#条款13-以引用传递捕捉异常" class="headerlink" title="条款13 以引用传递捕捉异常"></a>条款13 以引用传递捕捉异常</h3><p>​        我们有三种方式传递异常：值传递，引用传递，指针传递。</p><p>​        先考虑指针传递：不得不说因为不复制对象而显得十分搞笑，但是不大好，程序员们往往会忘记：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void someFunc&#123;    exception ex;        &#x2F;&#x2F;...        throw &amp;ex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对象早就被析构了！传递了一个非法指针！</p><p>​        好吧，开堆上：</p><pre class="line-numbers language-none"><code class="language-none">void someFunc&#123;    exception ex;        &#x2F;&#x2F;...        throw new ex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那问题更大了，用户程序员没有办法知道：他们什么时候需要释放，什么时候不需要释放！这下麻烦了！还是不要用之为妙。</p><p>​        值传递呢？除了低效以外，如果我们传递了派生类指针，那意味着后续的处理下，对象都是基类，调用的虚函数是基类虚函数！程序爆炸了！</p><p>​        于是还是引用传递好！避免了上述的问题！</p><h3 id="条款14：明智使用exception-specification"><a href="#条款14：明智使用exception-specification" class="headerlink" title="条款14：明智使用exception specification"></a>条款14：明智使用exception specification</h3><p>​        谨慎使用他！</p><p>​        如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void f1();&#x2F;&#x2F; throw anythingvoid f2()throw(int)&#123;    ...    f1();    ...&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这下麻烦了，我们承诺了f2只会抛出int的意外，但是是事实f1会抛出一堆其他的意外！编译器不会帮助你检查这个事情，他默许了这样非法的行为。</p><p>​        同时，不要将template和 特殊异常一起使用！因为我们无法知道template会抛出什么异常，导致未定义行为的发生！</p><p>​        其二，如果A函数调用了B函数，若B没有特殊异常，A也不要有！但是很容易出错的：就是回调函数的问题：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef void(*CallBackPtr)(int X,int Y,void* dataToPassBack);class CallBack&#123;    public:    CallBack(CallBackPtr fPtr,void* dataToPassBack):    func(fPtr),data(dataToPassBack);    void makeCallBack(int X,int Y)const throw();    private:    CallBackPtr func;    void* data;&#125;;void CallBack::makeCallBack(int X,int Y)const throw()&#123;    func(X,Y,data);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>makeCallBack</code>函数内部就违反了特殊异常，谁知道func里面抛出了什么异常呢？但是这就可以：</p><pre class="line-numbers language-none"><code class="language-none">typedef void(*CallBackPtr)(int X,int Y,void* dataToPassBack) throw();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样就强迫函数必须书写<code>throw()</code>后缀保证函数不会跑出任何异常！</p><p>​        还有其三：可以使用转化异常的方式防止出事情：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class UnexpectedExeception&#123;&#125;;void convertException()&#123;    throw UnexpectedExeception();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样就好了！</p><h2 id="条款15：了解异常处理的代价"><a href="#条款15：了解异常处理的代价" class="headerlink" title="条款15：了解异常处理的代价"></a>条款15：了解异常处理的代价</h2><p>​        我的评价是简单的：一坨大便，下一个（）</p><p>​        好吧，异常处理是能少用就少用的：首先是程序开销巨大，其次：跳转使得程序逻辑结构不再清晰。完事！</p><h2 id="条款22-考虑以操作符复合形式（op-）来取代独身形式"><a href="#条款22-考虑以操作符复合形式（op-）来取代独身形式" class="headerlink" title="条款22 考虑以操作符复合形式（op=）来取代独身形式"></a>条款22 考虑以操作符复合形式（op=）来取代独身形式</h2><p>​        对于大部分的程序员，他们希望——</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; x + y;x &#x3D; x - y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        的同时</p><pre class="line-numbers language-none"><code class="language-none">x +&#x3D; y;x -&#x3D; y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        的形式也可以被接受。</p><p>​        为了让复合形式和独身形式都可以很好的运作——我们选则：让前者作为基础来实现</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Rational&#123;    public:    Rational&amp; operator+&#x3D;(const Rational&amp; rhs);    Rational&amp; operator-&#x3D;(const Rational&amp; rhs);&#125;const Rational operator+(const Rational&amp; lhs,const Rational&amp; rhs)&#123;    return Rational(lhs) +&#x3D; rhs;&#125;const Rational operator-(const Rational&amp; lhs,const Rational&amp; rhs)&#123;    return Rational(lhs) -&#x3D; rhs;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的话，我们就只需要维护符合操作符就好了。</p><p>​        事实上，为了扩展性更强一些，我们一般的使用模板来完成通用化的工作：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;const T operator+(const T&amp; lhs,const T&amp; rhs)&#123;    return T(lhs) +&#x3D; rhs;&#125; template&lt;class T&gt;const T operator-(const T&amp; lhs,const T&amp; rhs)&#123;    return T(lhs) -&#x3D; rhs;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是现在为止我们都没有考虑效率的问题。</p><p>​        注意到复合操作类型不会花费时间构造一个巨大的对象返回。于是我们这样的设计可以让客户程序员选择效率与方便维护中二选一：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 易于维护的Rational a,b,c,d,result;result &#x3D; a + b + c + d;&#x2F;&#x2F; 追求效率的result &#x3D; a;result +&#x3D; b;result +&#x3D; c;result +&#x3D; d;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        程序的灵活性更好了！</p><h2 id="条款23：考虑使用其他库"><a href="#条款23：考虑使用其他库" class="headerlink" title="条款23：考虑使用其他库"></a>条款23：考虑使用其他库</h2><h2 id="条款24：了解virtual-functions-multiple-functions-virtual-base-classes-runtime-type-identification的成本"><a href="#条款24：了解virtual-functions-multiple-functions-virtual-base-classes-runtime-type-identification的成本" class="headerlink" title="条款24：了解virtual functions, multiple functions, virtual base classes runtime type identification的成本"></a>条款24：了解virtual functions, multiple functions, virtual base classes runtime type identification的成本</h2><p>​        当一个虚函数被调用，执行的代码必须对应于调用者的动态类型。我们的编译器可以做到虚函数的处理得益于 virtual table 或 virtual table pointers</p><p>​        我们的vtbl 通常是函数指针架构产生的数组。</p><p>比如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class C1&#123;    public:    C1();    virtual ~C1();    virtual void f1();    void f4() const;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230527133400105.png" alt="image-20230527133400105"></p><p>​        现在，一旦我们的子类继承了父类，并且自己重新实现了一些虚函数，那么——C2（假使它继承了C1）这张虚函数表的新改写函数就会换成子类自己的！</p><p>​        避免将虚函数声明为内联的inline,编译器也会自动忽视之。下面我会提到为什么</p><p>​        当然，只有虚函数表是不够的——我们的类中往往会增加一个函数数组指针，指向这个表！一旦发生继承，这个表就会被一大堆成员包围。</p><p>​        下面来看对于体系类的虚函数调用。还是回到C1，C2类的表</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void makeACall(C1* pC1)&#123;pC1()-&gt;f1();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        如果我们只看这点代码，完全不知道程序运行时会调用哪一段代码。编译器是这样处理的：</p><ol><li><p>根据对象的vptr 找到 vtbl</p></li><li><p>找到被调用的函数在vtbl的指针，然后调用之。</p><pre class="line-numbers language-none"><code class="language-none">(*pC1-&gt;vptr[i])(pC1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 你瞧！只有在运行的时候我们才会直到究竟是哪个！而inline跟virtual的设计理念完全冲突！这就是为什么不要给虚函数添加inline!</p></li></ol><p>​        下面考虑多重继承（相当恐怖的）</p><p>​        这是一个菱形继承：</p><p><img src="image-20230527134602652.png" alt="image-20230527134602652"></p><p>​        现在，我们视A作为最基本的类：</p><p><img src="image-20230527134822239.png" alt="image-20230527134822239"></p><p>​        当A内有任何一点虚函数</p><p><img src="image-20230527134941853.png" alt="image-20230527134941853"></p><p>​        我们看到了虚函数是如何使得对象变大的了</p><p>​        RTTI作为运行时获取对象类型，一个class只需要一个就可以了。我们在vtbl的开头加上一个 type_info对象就可以帮助识别。</p><div class="table-container"><table><thead><tr><th>性质</th><th>对象大小</th><th>Class数据量增加</th><th>内联几率降低</th></tr></thead><tbody><tr><td>虚函数</td><td>是</td><td>是</td><td>是</td></tr><tr><td>多重继承</td><td>是</td><td>是</td><td>否</td></tr><tr><td>虚拟基类</td><td>往往如此</td><td>有时候</td><td>否</td></tr><tr><td>RTTI</td><td>否</td><td>是</td><td>否</td></tr></tbody></table></div><h2 id="条款25：将构造函数和非成员函数虚化"><a href="#条款25：将构造函数和非成员函数虚化" class="headerlink" title="条款25：将构造函数和非成员函数虚化"></a>条款25：将构造函数和非成员函数虚化</h2><p>​        我们有必要将构造函数和非成员函数虚化——这是因为我们之间有关系的类可以做到一个构造函数完成更多的事情。而且更加的省精力。</p><p>​        构造函数的虚化有助于我们在实际调用的时候返回期望对象的构造函数！</p><h2 id="条款26-限制某个class所能产生的对象数量"><a href="#条款26-限制某个class所能产生的对象数量" class="headerlink" title="条款26 限制某个class所能产生的对象数量"></a>条款26 限制某个class所能产生的对象数量</h2><h3 id="允许0个或者1-个对象产出"><a href="#允许0个或者1-个对象产出" class="headerlink" title="允许0个或者1 个对象产出"></a>允许0个或者1 个对象产出</h3><p>​        阻止一个类的产生的最简单的方法就是把构造器放private里面。</p><p>​        那一个呢？配合static和接口函数！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class PrinterJob;class Printer&#123;    public:    void submitJob(const PrinterJob&amp; job);    void reset();    void performSelfTest();    friend Printer&amp; thePrinter();    private:    Printer();    Printer(const Printer&amp; rhs);    ...&#125;Printer&amp; thePrinter()&#123;    static Printer p;    return p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样一调用，我们就总是调用那个在静态区的变量。</p><p>​        我们也可以把这一大堆东西放到namespace里去，防止冲突！</p><p>​        有一个细节：我们为什么不把这个函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Printer&amp; thePrinter()&#123;    static Printer p;    return p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        设置成inline呢？答案是，防止被复制——因为我们把调用函数这个动作直接改成执行代码，这就意味着——这个对象可能会被复制！不要在带有locale static对象的函数中内联！</p><p>​        注意，<strong>一个构造函数是private 的类是不允许被继承的！</strong>（没办法显著的调用构造器）于是，<strong>避免一个具体类继承另一个具体类！</strong></p><h3 id="允许对象生生灭灭"><a href="#允许对象生生灭灭" class="headerlink" title="允许对象生生灭灭"></a>允许对象生生灭灭</h3><p>​        注意到：</p><pre class="line-numbers language-none"><code class="language-none">create Printer object p1;use p1;delete p1;create Printer object p2;use p2;delete p2;create Printer object p3;use p3;delete p3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的事情不违反只允许一个对象！但是却不被允许，那么我们有必要整一个新办法</p><p>​        我们加上一个计数器就好了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Printer&#123;public:    class TooManyObj&#123;&#125;;    static Printer* makePrinter();    ~Printer();    void submitJob(const PrinterJob&amp; job);    void reset();    void performSelfTest();        private:    static size_t numObjects;    static size_t numObjects &#x3D; 10;    Printer();    Printer(const Printer&amp; rhs);&#125;size_t Printer::numObjects &#x3D; 0;Printer::Printer()&#123;        if(numObjects &gt;&#x3D; max_obj)&#123;            throw TooManyObj();        &#125;        ...        ++numObjects;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        也有程序员使用专门计数的类！但这里就不再展开了。</p><h3 id="判断对象在哪里（在不在heap-）"><a href="#判断对象在哪里（在不在heap-）" class="headerlink" title="判断对象在哪里（在不在heap?）"></a>判断对象在哪里（在不在heap?）</h3><p>​        不应当直接在class里声明一个bool变量，然后塞到operator new这个函数下，因为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">UPNumber* numArr &#x3D; new UPNumber[100];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这下坏了，编译器可能是：先调用operator new在调用构建器！（先开空间，在初始化，我们上面的办法就失效了！）</p><p>​        于是，不妨使用计组学的特性?</p><p><img src="image-20230527142543682.png" alt="image-20230527142543682"></p><p>​        可以给出这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool onHeap(const void* addr)&#123;char onStack;    return address &lt; &amp;onTheStack&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是别忘了，我们还有静态区！它无法区分和heap对象和static对象！</p><p>​        事实上，没有通用的办法！</p><h3 id="静止对象产生在heap上"><a href="#静止对象产生在heap上" class="headerlink" title="静止对象产生在heap上"></a>静止对象产生在heap上</h3><p>​        很简单了：直接把operator new 和operator delete直接扔到私有区！</p><h2 id="条款27：auto-ptr"><a href="#条款27：auto-ptr" class="headerlink" title="条款27：auto_ptr"></a>条款27：auto_ptr</h2><p>​        <strong>智能指针主要用于动态内存的管理,同时提供给用户与内置指针一样的使用方法,本条款主要涉及智能指针在构造与析构,复制和赋值,解引等方面的注意点,而非智能指针的实现细节.</strong></p><h3 id="智能指针的构造-赋值-析构"><a href="#智能指针的构造-赋值-析构" class="headerlink" title="智能指针的构造,赋值,析构"></a>智能指针的构造,赋值,析构</h3><pre><code>  智能指针的copy constructor,assignment operator,destructor对应于不同的观念而有不同的实现,主要有三种选择:  不允许对象的共享,在调用copy constructor和assignment时转移对象所有权,这样在调用destructor时就可以直接delete智能指针内含的内置指针,如标准库的auto_ptr,其实现可能像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class auto_ptr &#123;public:    ...    auto_ptr(auto_ptr&lt;T&gt;&amp; rhs);     auto_ptr&lt;T&gt;&amp;  operator&#x3D;(auto_ptr&lt;T&gt;&amp; rhs);     ...&#125;;template&lt;class T&gt;auto_ptr&lt;T&gt;::auto_ptr(auto_ptr&lt;T&gt;&amp; rhs)&#123;    pointee &#x3D; rhs.pointee;     rhs.pointee &#x3D; 0; &#x2F;&#x2F; 转移对象所有权&#125; template&lt;class T&gt;auto_ptr&lt;T&gt;&amp; auto_ptr&lt;T&gt;::operator&#x3D;(auto_ptr&lt;T&gt;&amp; rhs)&#123;    if (this &#x3D;&#x3D; &amp;rhs) &#x2F;&#x2F; 自我赋值的情况        return *this;     delete pointee;     pointee &#x3D; rhs.pointee; &#x2F;&#x2F; 转移对象所有权    rhs.pointee &#x3D; 0;     return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      值得注意的是,由于auto_ptr的copy constructor被调用时,对象所有权便转移了,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void printTreeNode(ostream&amp; s, auto_ptr&lt;TreeNode&gt; p)&#123; s &lt;&lt; *p; &#125;int main()&#123;    auto_ptr&lt;TreeNode&gt; ptn(new TreeNode);    ...    printTreeNode(cout, ptn); &#x2F;&#x2F;通过传值方式传递auto_ptr    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      调用printTreeNode后,ptn所指向的内存便被释放,内含的内置指针也被置为0,但这并不符合用户的预期.这说明不能使用pass-by-value的方式传递auto_ptr给函数,只能使用pass-by-reference.      使用这种策略实现的智能指针的destructor可能像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;SmartPtr&lt;T&gt;::~SmartPtr()&#123;    if (*this owns *pointee) &#123;        delete pointee;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  2). 不允许对象的共享,调用copy constructor和assignment operator时进行深度拷贝——产生新对象.这种设计思想较简单,缺点也较明显:新对象的产生需要消耗资源.这里不再讨论  3). 允许对象的共享,使用引用计数,调用copy constructor和assignment operator增加引用计数的个数.当引用计数的个数为0时便析构对象并释放内存,如标准库的shared_ptr,关于引用计数的具体实现见[条款29](http://i.cnblogs.com/PostDone.aspx?postid=4857432&amp;actiontip=存为草稿成功).</code></pre><h3 id="实现Dereference-Operators-解引操作符"><a href="#实现Dereference-Operators-解引操作符" class="headerlink" title="实现Dereference Operators(解引操作符)"></a>实现Dereference Operators(解引操作符)</h3><pre><code>  主要讨论operator*和operator-&gt;的实现,前者放回所指对象的引用,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;T&amp; SmartPtr&lt;T&gt;::operator*() const&#123;    perform &quot;smart pointer&quot; processing;    return *pointee;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  如果程序采用了lazy fetching(见[条款17](http://www.cnblogs.com/reasno/p/4830677.html))策略,就有可能需要为pointers变换出一个新对象.需要注意的是,operator*返回的是引用,如果返回对象,可能会产生由于SmartPtr指向的是T的派生类对象而非T类对象而造成的切割问题.  operator-&gt;和operator*类似,operator-&gt;返回指针.  对于使用引用计数的shared_ptr,问题还未停止,它允许多个智能指针共享相同对象,但前提是这些指针所指向的对象相同.由于operator*和operator-&gt;返回所指对象的引用和指针,这可能导致其所指对象被更改,但原则上共享同一块内存的其他智能指针却要求所指对象保持不变.因此有必要在调用operator*和operator-&gt;的时候开辟一块新内存,使调用operator*和operator-&gt;的智能指针指向这块新内存以防止共享内存被篡改,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;T&amp; SmartPtr&lt;T&gt;::operator*() const&#123;    if(number of reference!&#x3D;1)&#123;        pointee&#x3D;new T(*pointee);        --reference number of the old object;        set the reference number of the new object to 1;     &#125;    return *pointee;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试Smart-Pointers是否为Null"><a href="#测试Smart-Pointers是否为Null" class="headerlink" title="测试Smart Pointers是否为Null"></a>测试Smart Pointers是否为Null</h3><pre><code>  直接的策略是定义隐式转换操作符operator void*,使得以下操作可以通过编译:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if (ptn &#x3D;&#x3D; 0) ... &#x2F;&#x2F; 正确if (ptn) ... &#x2F;&#x2F; 正确if (!ptn) ... &#x2F;&#x2F;正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>  但隐式转换操作符很容易被滥用,它使得不同类型的指针可以相比较,以下代码可以通过编译:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;Apple&gt; pa;SmartPtr&lt;Orange&gt; po;...if (pa &#x3D;&#x3D; po) ...&#x2F;&#x2F;可以通过编译<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  尽管pa和po是不同类型的智能指针,但由于没有定义Smart&lt;Apple&gt;和Smart&lt;Orange&gt;为参数的operator==,因此编译器默认调用operator void*,使得以上代码通过编译.  一种差强人意的方法是允许测试null,但使用!操作符,如果内置指针为null,便返回true,客户端要测试智能指针是否为null,就要像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;TreeNode&gt; ptn;...if (!ptn) &#123;     ...&#125;else &#123;    ... &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  但以下做法却被禁止:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if (ptn &#x3D;&#x3D; 0) ... if (ptn) ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>  `iostream`程序库不仅允许隐式类型转换`void*`,还提供`operator!` ,C++标准库中,&quot;隐式转换为void*&quot;已被&quot;隐式转换为bool&quot;取代,而operator bool总是返回operator!的反.</code></pre><h3 id="将Smart-Pointers转换为Dumb-Pointers"><a href="#将Smart-Pointers转换为Dumb-Pointers" class="headerlink" title="将Smart Pointers转换为Dumb Pointers"></a>将Smart Pointers转换为Dumb Pointers</h3><pre><code>  有时要兼容并未使用智能指针的程序库,就要允许智能指针到内置指针的转换,直接的思路还是隐式转换操作符:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class DBPtr &#123;public:    ...    operator T*() &#123; return pointee; &#125;    ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  但是正如多次强调的,隐式转换操作符很容易被滥用,它使得客户可以轻易获得内置指针,从而绕过智能指针的控制,像这样:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Tuple&#123;...&#125;;void processTuple(DBPtr&lt;Tuple&gt;&amp; pt)&#123;    Tuple *rawTuplePtr &#x3D; pt; &#x2F;&#x2F; 得到内置指针    use rawTuplePtr to modify the tuple&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      像这样的操作也会被通过:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">DBPtr&lt;Tuple&gt; pt&#x3D;new Tuple;delete pt;&#x2F;&#x2F;通过,执行隐式类型转换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>      但这几乎肯定会造成错误,因为pt的析构函数执行时可能再次delete同一块内存.      此外,对于采用引用计数的实现版本来说,&quot;允许clinets直接使用dumb pointers&quot;往往会导致导致簿记方面的错误,造成严重后果,      即使实现了隐式转换操作符,但它还是不能做到提供和内置指针完全一样的行为,因为编译器禁止连续隐式调用自定义的隐式类型转换,像这样的使用会失败:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class TupleAccessors &#123;public:    TupleAccessors(const Tuple *pt); &#x2F;&#x2F; Tuple到TupleAccessor的转换    ... &#125;;TupleAccessors merge(const TupleAccessor&amp; ta1,const TupleAccessors&amp; ta2);DBPtr&lt;Tuple&gt; pt1, pt2;...merge(pt1,pt2);&#x2F;&#x2F;调用会出错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      尽管`DBPtr&lt;Tuple&gt;`到`Tuple*`再到`TupleAccessor`的转换就可以匹配merge的参数,但编译器禁止这么做.</code></pre><p>​          解决方法是使用普通成员函数进行显式转换以代替隐式转换操作符,像这样:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class DBPtr &#123;public:    ...    T* toPrimary() &#123; return pointee; &#125;    ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Smart-Pointers和”与继承有关的”类型转换"><a href="#Smart-Pointers和”与继承有关的”类型转换" class="headerlink" title="Smart Pointers和”与继承有关的”类型转换"></a>Smart Pointers和”与继承有关的”类型转换</h3><pre><code>      两个类之间有继承关系,但以这两个类为参数具现化的类模板却没有继承关系,由于智能指针是类模板,因此智能指针的包装会屏蔽内置指针的继承关系,例如对于以下继承层次:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MusicProduct &#123;public:    MusicProduct(const string&amp; title);    virtual void play() const &#x3D; 0;    virtual void displayTitle() const &#x3D; 0;    ...&#125;;class Cassette: public MusicProduct &#123;public:    Cassette(const string&amp; title);    virtual void play() const;    virtual void displayTitle() const;    ...&#125;;class CD: public MusicProduct &#123;public:    CD(const string&amp; title);    virtual void play() const;    virtual void displayTitle() const;    ...&#125;void displayAndPlay(const MusicProduct* pmp, int numTimes)&#123;    for (int i &#x3D; 1; i &lt;&#x3D; numTimes; ++i) &#123;    pmp-&gt;displayTitle();    pmp-&gt;play();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  整个继承体系像这样:</code></pre><p><img src="699942-20151006212730503-151239962.png" alt="img"></p><pre><code>  由于各个类的继承关系,可以利用指针的多态实现面向对象编程,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Cassette *funMusic &#x3D; new Cassette(&quot;Alapalooza&quot;);CD *nightmareMusic &#x3D; new CD(&quot;Disco Hits of the 70s&quot;);displayAndPlay(funMusic, 10);displayAndPlay(nightmareMusic, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  但当指针经过封装成为智能指针之后,正如开始所说,以下代码将无法通过编译：</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void displayAndPlay(const SmartPtr&lt;MusicProduct&gt;&amp; pmp,int numTimes);SmartPtr&lt;Cassette&gt; funMusic(new Cassette(&quot;Alapalooza&quot;));SmartPtr&lt;CD&gt; nightmareMusic(new CD(&quot;Disco Hits of the 70s&quot;));displayAndPlay(funMusic, 10); &#x2F;&#x2F; 错误!displayAndPlay(nightmareMusic, 0); &#x2F;&#x2F; 错误!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是由于<code>MusicProduct,Cassette,CD</code>之间有继承关系,但智能指<code>SmartPtr&lt;MusicProduct&gt;,SmartPtr&lt;Cassette&gt;,SmartPtr&lt;CD&gt;</code>之间却没有内在的继承关系.</p><pre><code>      最直接的解决方法是为每一个智能指针类定义一个隐式类型转换操作符,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class SmartPtr&lt;Cassette&gt; &#123;public:    operator SmartPtr&lt;MusicProduct&gt;()    &#123; return SmartPtr&lt;MusicProduct&gt;(pointee); &#125;    ...private:    Cassette *pointee;&#125;;class SmartPtr&lt;CD&gt; &#123;public:    operator SmartPtr&lt;MusicProduct&gt;()    &#123; return SmartPtr&lt;MusicProduct&gt;(pointee); &#125;    ...private:    CD *pointee;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  这种方法可以解决类型转换的问题,但是却治标不治本:一方面,必须为每一个智能指针实例定义隐式类型转换操作符,这无疑与模板的初衷背道相驰;另一方面,类的继承层次可能很庞大,采用以上方式,继承层次的最底层类的负担将会非常大——必须为对象直接或间接继承的每一个基类提供隐式类型转换操作符.      &quot;将nonvirtual member function声明为templates&quot;是C++后来接入的一个性质,使用它可以从根本上解决饮食类型转换的问题,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt; class SmartPtr &#123; public:    SmartPtr(T* realPtr &#x3D; 0);    T* operator-&gt;() const;    T&amp; operator*() const;    template&lt;class newType&gt; &#x2F;&#x2F; 模板成员函数    operator SmartPtr&lt;newType&gt;()     &#123;        return SmartPtr&lt;newType&gt;(pointee);    &#125;    ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      这个成员函数模板将智能指针之间的隐式类型转换交由底层内置指针来完成,保证了指针转换的&quot;原生态&quot;:如果底层指针能够转换,那么包装后的智能指针也能够进行转换.唯一的缺点是它是通过指针之间的隐式类型转换来实现指针的多态,也就是说,它实际上并不能区分对象之间的继承层次,假如扩充MusicProduct的继承体系,加上一个新的CasSingle class,像这样:</code></pre><p><img src="699942-20151006213007737-1835434124.png" alt="img"> </p><p>  那么对于以下代码:</p><p><img src="ContractedBlock.gif" alt="img"> <img src="ExpandedBlockStart.gif" alt="img"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class SmartPtr &#123; ... &#125;; void displayAndPlay(const SmartPtr&lt;MusicProduct&gt;&amp; pmp,int howMany);void displayAndPlay(const SmartPtr&lt;Cassette&gt;&amp; pc,int howMany);SmartPtr&lt;CasSingle&gt; dumbMusic(new CasSingle(&quot;Achy Breaky Heart&quot;));displayAndPlay(dumbMusic, 1);&#x2F;&#x2F;错误，隐式类型转换函数的调用具有二义性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  正如之前所言,使用隐式类型转换操作符实现的指针多态并不能区分对象的继承层次,也就是说将SmartPtr&lt;CasSingle&gt;转为SmartPtr&lt;Cassette&gt;&amp;和转为SmartPtr&lt;MusicProduct&gt;&amp;具有同样的优先级,因此造成二义性.而内置指针却能做到这一点,它优先将CasSingle绑定到Cassette&amp;,因为CaSingle直接继承自Cassette.此外,以上策略还有移植性不高的缺点:有些编译器可能并不支持member templates.  对于内置指针,const修饰的含义因其位置而不同:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CD goodCD(&quot;Flood&quot;);const CD *p; &#x2F;&#x2F; p 是一个non-const 指针,指向 const CD 对象CD * const p &#x3D; &amp;goodCD; &#x2F;&#x2F; p 是一个const 指针,指向non-const CD 对象;因为 p 是const,它必须在定义时就被初始化const CD * const p &#x3D; &amp;goodCD; &#x2F;&#x2F; p 是一个const 指针,指向一个 const CD 对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      但对于智能指针,只有一个地方可以放置const,因此cosnt只能施行于指针之上,而不能施行于指针所指对象之上:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const SmartPtr&lt;CD&gt; p&#x3D;&amp;goodCD;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>      要是const修饰所值对象很简单,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;const CD&gt; p&#x3D;&amp;goodCD;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>      由此方法可以实现和内置指针相同的四种指针:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;CD&gt; p; &#x2F;&#x2F; non-const 对象, non-const 指针SmartPtr&lt;const CD&gt; p; &#x2F;&#x2F; const 对象,non-const 指针const SmartPtr&lt;CD&gt; p &#x3D; &amp;goodCD; &#x2F;&#x2F; non-const 对象,const 指针const SmartPtr&lt;const CD&gt; p &#x3D; &amp;goodCD; &#x2F;&#x2F; const 对象,const 指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      但这种方法仍有缺陷,正如经由模板包装之后,有继承关系的两个类完全没有关系一样,经由智能指针模板包装后的const和non-const对象完全不同,像这样看起来理所当然的代码通不过编译:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;CD&gt; pCD &#x3D; new CD(&quot;Famous Movie Themes&quot;);SmartPtr&lt;const CD&gt; pConstCD &#x3D; pCD;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>      使用之前的隐式类型转换技术可以顺带解决这个问题,但又有所区别:const与non-const的转换是单向的,即可以对const指针做的事也可以对non-const指针进行,但可以对non-const指针做的事未必可以对const指针进行.这与public继承类似,利用这种性质,令每一个smart pointer-to-T-class public继承一个对应的smart pointer-to-const-T class:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt; &#x2F;&#x2F; 指向const 对象的class SmartPtrToConst &#123;protected:    union &#123;        const T* constPointee; &#x2F;&#x2F; 提供给SmartPtrToConst 访问        T* pointee; &#x2F;&#x2F; 提供给SmartPtr 访问    &#125;;&#125;;template&lt;class T&gt; class SmartPtr: public SmartPtrToConst&lt;T&gt; &#123;public:    template&lt;class constType&gt;    operator SmartPtrToConst&lt;constType&gt;();    ... &#x2F;&#x2F;没有额外数据成员&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>       SmartPtrToConst使用了union,这样constPointee和pointee共享同一块内存SmartPtrToConst使用constPointee,SmartPtr使用pointee.        现在,使用SmartPtrToConst和SmartPtr分别代表指向const和non-const对象的智能指针,以下代码可以通过编译:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;CD&gt; pCD &#x3D; new CD(&quot;Famous Movie Themes&quot;);SmartPtrToConst&lt;CD&gt; pConstCD &#x3D; pCD;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>\8. 从2-7的讨论可以看出,智能指针功能强大,但索要付出的代价也很高,此外,智能指针无论如何也不能完全替代内置指针.当然,尽管内置指针在实现和维护方面需要大量技巧,但与其强大的功能相比在多数情况下还是值得的.</p><h2 id="条款28：引用计数"><a href="#条款28：引用计数" class="headerlink" title="条款28：引用计数"></a>条款28：引用计数</h2><p>​        引用计数是这样一个技巧，它允许多个有相同值的对象共享这个值的实现。这个技巧有两个常用动机。第一个是简化跟踪堆中的对象的过程。一旦一个对象通过调用new被分配出来，最要紧的就是记录谁拥有这个对象，因为其所有者－－并且只有其所有者－－负责对这个对象调用delete。但是，所有权可以被从一个对象传递到另外一个对象（例如通过传递指针型参数），所以跟踪一个对象的所有权是很困难的。象auto_ptr（见Item M9）这样的类可以帮助我们，但经验显示大部分程序还不能正确地得到这样的类。引用计数可以免除跟踪对象所有权的担子，因为当使用引用计数后，对象自己拥有自己。当没人再使用它时，它自己自动销毁自己。因此，引用计数是个简单的垃圾回收体系。</p><p>​        第二个动机是由于一个简单的常识。如果很多对象有相同的值，将这个值存储多次是很无聊的。更好的办法是让所有的对象共享这个值的实现。这么做不但节省内存，而且可以使得程序运行更快，因为不需要构造和析构这个值的拷贝。</p><p>​        和大部分看似简单的主意一样，这个动机也有一个曲折而有趣的细节。在其中必须有一个正确实现的引用计数体系。在开始钻研细节前，让我们掌握一些基础。一个好主意是先着眼于我们将可能如何遇到多个对象有相同的值。这儿有一个：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;                     &#x2F;&#x2F; the standard string type maypublic:                            &#x2F;&#x2F; employ the techniques in this Item, but that is not required  String(const char *value &#x3D; &quot;&quot;);  String&amp; operator&#x3D;(const String&amp; rhs);...private:  char *data;&#125;;String a, b, c, d, e;a &#x3D; b &#x3D; c &#x3D; d &#x3D; e &#x3D; &quot;Hello&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        看起来，对象a到e都有相同的值“Hello”。其值的形态取决于String类是怎么实现的，但通常的实现是每个string对象有一个这个值的拷贝。例如，String的赋值操作可能实现为这样：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String&amp; String::operator&#x3D;(const String&amp; rhs)&#123;  if (this &#x3D;&#x3D; &amp;rhs) return *this;         &#x2F;&#x2F; see Item E17  delete [] data;  data &#x3D;   new char[strlen(rhs.data) + 1];  strcpy(data, rhs.data);  return *this;                           &#x2F;&#x2F; see Item E15&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据这个实现，我们可以推测，这5个对象及其值如下：</p><p> <img src="20191114165634252.png" alt="img"></p><p>其冗余是显然的。在一个理想的世界中，我们希望将上图改为这样：</p><p> <img src="20191114165703168.png" alt="img"></p><p>​        这里，只存储了一个“Hello”的拷贝，所有具有此值的String对象共享其实现。</p><p>​        实际世界中，实现这个主意是不可能的，因为我们需要跟踪多少对象共享同一个值。如果上面的对象a被赋了“Hello”以外的另外一个值，我们不能摧毁值“Hello”，因为还有四个对象需要它。另一方面，如果只有一个对象有“Hello”这个值，当其超出生存空间时，没有对象具有这个值了，我们必须销毁这个值以避免资源泄漏。</p><p>​        保存当前共享/引用同一个值的对象数目的需求意味着我们的那张图必须增加一个计数值（引用计数）：</p><p> <img src="2019111416593759.png" alt="img"></p><p>​        （有些人将其叫作use count，但我不是其中之一。C++有很多它自己的特性，最后需要的一个是专业名词的派别之争。）</p><p>​        创建一个带引用计数的String类并不困难，但需要注意一些细节，所以我们将略述这样一个类的大部分常用成员函数的实现。然而，在开始之前，认识到“我们需要一个地方来存储这个计数值”是很重要的。这个地方不能在String对象内部，因为需要的是每个String值一个引用计数值，而不是每个String对象一个引用计数。这意味着String值和引用计数间是一一对应的关系，所以我们将创建一个类来保存引用计数及其跟踪的值。我们叫这个类StringValue，又因为它唯一的用处就是帮助我们实现String类，所以我们将它嵌套在String类的私有区内。另外，为了便于Sting的所有成员函数读取其数据区，我们将StringValue申明为struct。需要知道的是：将一个struct内嵌在类的私有区内，能便于这个类的所有成员访问这个结构，但阻止了其它任何人对它的访问（当然，除了友元）。</p><p>​        基本设计是这样的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  ... &#x2F;&#x2F; the usual String member&#x2F;&#x2F; functions go hereprivate:  struct StringValue &#123; ... &#125;;        &#x2F;&#x2F; holds a reference count and a string value  StringValue *value;                &#x2F;&#x2F; value of this String&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们可以给这个类起个其它名字（如RCString）以强调它使用了引用计数，但类的实现不该是类的用户必须关心的东西，用户只关心类的公有接口。而我们带引用计数的String版本与不带引用计数的版本，其接口完全相同，所以为什么要用类的名字来把问题搅混呢？真的需要吗？所以我们没有这么做。</p><p>​        这是StringValue的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:struct StringValue &#123;  int refCount;  char *data;  StringValue(const char *initValue); ~StringValue();&#125;;...&#125;;String::StringValue::StringValue(const char *initValue): refCount(1)&#123;  data &#x3D; new char[strlen(initValue) + 1];  strcpy(data, initValue);&#125;String::StringValue::~StringValue()&#123;  delete [] data;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是其所有的一切，很清楚，这不足以实现带引用计数的String类。一则，没有拷贝构造函数和赋值运算；</p><p>​        二则，没有提供对refCount的操作。别担心，少掉的功能将由String类提供。StringValue的主要目的是提供一个空间将一个特别的值和共享此值的对象的数目联系起来。StringValue给了我们这个，这就足够了。</p><p>​        我们现在开始处理String的成员函数。首先是构造函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  String(const char *initValue &#x3D; &quot;&quot;);  String(const String&amp; rhs);  ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        第一个构造函数被实现得尽可能简单。我们用传入的char *字符串创建了一个新的StringValue对象，并将我们正在构造的string对象指向这个新生成的StringValue：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String::String(const char *initValue): value(new StringValue(initValue))&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的用户代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s(&quot;More Effective C++&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        生成的数据结构是这样的：</p><p> <img src="20191114170009545.png" alt="img"></p><p>​        String对象是独立构造的，有同样初始化值的对象并不共享数据，所以，这样的用户代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s1(&quot;More Effective C++&quot;);String s2(&quot;More Effective C++&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        产生这样的数据结构：</p><p> <img src="2019111417004483.png" alt="img"></p><p>​        消除这样的副本是可能的：通过让String（或StringValue）对象跟踪已存在的StringValue对象，并只在是不同串时才创建新的对象。但这样的改进有些偏离目标。于是，我将它作为习题留给读者。</p><p>​        String的拷贝构造函数很高效：新生成的String对象与被拷贝的对象共享相同的StringValue对象：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String::String(const String&amp; rhs): value(rhs.value)&#123;  ++value-&gt;refCount;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s1(&quot;More Effective C++&quot;);String s2 &#x3D; s1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>产生这样的数据结构：</p><p> <img src="2019111417004483-168517039708711.png" alt="img"></p><p>​        这肯定比通常的（不带引用计数的）string类高效，因为不需要为新生成的string值分配内存、释放内存以及将内容拷贝入这块内存。现在，我们只不过是拷贝了一个指针并增加了一次引用计数。</p><p>​        String类的析构函数同样容易实现，因为大部分情况下它不需要做任何事情。只要引用计数值不是0，也就是至少有一个String对象使用这个值，这个值就不可以被销毁。只有当唯一的使用者被析构了（也就是引用计数在进入函数前已经为1时），String的析构函数才摧毁StringValue对象：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  ~String();  ...&#125;;String::~String()&#123;  if (--value-&gt;refCount &#x3D;&#x3D; 0) &#123;      delete value;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        和没有引用计数的版本比较一下效率。那样的函数总调用delete，当然会有一个相当程度的运行时间的代价。现在提供的String对象们实际上有时具有相同的值，上面的这个实现在此时只需要做一下减少引用计数并与0进行比较。</p><p>​        如果在这个问题上引用计数没有向外界表现出来，你就根本不需要花注意力。</p><p>​        这就是String的构造和析构，我们现在转到赋值操作：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  String&amp; operator&#x3D;(const String&amp; rhs);  ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        当用户写下这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">s1 &#x3D; s2;                              &#x2F;&#x2F; s1 and s2 are both String objects<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        其结果应该是s1和s2指向相同的StringValue对象。对象的引用计数应该在赋值时被增加。并且，s1原来指向的StringValue对象的引用计数应该减少，因为s1不再具有这个值了。如果s1是拥有原来的值的唯一对象，这个值应该被销毁。在C++中，其实现看起来是这样的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String&amp; String::operator&#x3D;(const String&amp; rhs)&#123;  if (value &#x3D;&#x3D; rhs.value)     &#123;         &#x2F;&#x2F; do nothing if the values    return *this;                    &#x2F;&#x2F; are already the same; this&#125;                                     &#x2F;&#x2F; subsumes the usual test of&#x2F;&#x2F; this against &amp;rhs (see Item E17)  if (--value-&gt;refCount &#x3D;&#x3D; 0)     &#123;      &#x2F;&#x2F; destroy *this&#39;s value if    delete value;                    &#x2F;&#x2F; no one else is using it&#125;  value &#x3D; rhs.value;                 &#x2F;&#x2F; have *this share rhs&#39;s  ++value-&gt;refCount;                 &#x2F;&#x2F; value  return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        围绕我们的带引用计数的String类，考虑一下数组下标操作（[]），它允许字符串中的单个字符被读或写：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  const char&amp;    operator[](int index) const;       &#x2F;&#x2F; for const Strings  char&amp; operator[](int index);           &#x2F;&#x2F; for non-const Strings...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个函数的const版本的实现很容易，因为它是一个只读操作，String对象的值不受影响：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const char&amp; String::operator[](int index) const&#123;  return value-&gt;data[index];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    （这个函数实现了C++传统意义上的下标索引（根本不会说“不”）。如果你想加上参数检查，这是非常容易的。）</p><p>非const的operator[]版本就是一个完全不同的故事了。它可能是被调用了来读一个字符，也可能被调用了来写一个字符：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s;...cout &lt;&lt; s[3];                        &#x2F;&#x2F; this is a reads[5] &#x3D; &#39;x&#39;;                          &#x2F;&#x2F; this is a write<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们希望以不同的方式处理读和写。简单的读操作，可以用与const的operator[]类似的方式实现，而写操作必须用完全不同的方式来实现。</p><p>​        当我们修改一个String对象的值时，必须小心防止修改了与它共享相同StringValue对象的其它String对象的值。不幸的是，C++编译器没有办法告诉我们一个特定的operator[]是用作读的还是写的，所以我们必须保守地假设“所有”调用非const operator[]的行为都是为了写操作。（Proxy类可以帮助我们区分读还是写，见Item M30。）</p><p>​        为了安全地实现非const的operator[]，我们必须确保没有其它String对象在共享这个可能被修改的StringValue对象。简而言之，当我们返回StringValue对象中的一个字符的引用时，必须确保这个StringValue的引用计数是1。这儿是我们的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char&amp; String::operator[](int index)&#123;  &#x2F;&#x2F; if we&#39;re sharing a value with other String objects,  &#x2F;&#x2F; break off a separate copy of the value for ourselves  if (value-&gt;refCount &gt; 1) &#123;    --value-&gt;refCount;                    &#x2F;&#x2F; decrement current value&#39;srefCount, because we won&#39;t be using that value any more    value &#x3D;                               &#x2F;&#x2F; make a copy of the      new StringValue(value-&gt;data);       &#x2F;&#x2F; value for ourselves  &#125;  &#x2F;&#x2F; return a reference to a character inside our  &#x2F;&#x2F; unshared StringValue object  return value-&gt;data[index];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个“与其它对象共享一个值直到写操作时才拥有自己的拷贝”的想法在计算机科学中已经有了悠久而著名的历史了，尤其是在操作系统中：进程共享内存页直到它们想在自己的页拷贝中修改数据为止。这个技巧如此常用，以至于有一个名字：写时拷贝。它是提高效率的一个更通用方法－－缓式评估原则－－的特例。</p><p>​        大部分情况下，写时拷贝可以同时保证效率和正确性。只有一个挥之不去的问题。看一下这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s1 &#x3D; &quot;Hello&quot;;char *p &#x3D; &amp;s1[1];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数据结构是这样的：</p><p> <img src="20191114170147593.png" alt="img"></p><p>​        现在看增加一条语句：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s2 &#x3D; s1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        String的拷贝构造函数使得s2共享s1的StringValue对象，所以数据结构将是：</p><p> <img src="20191114170246431.png" alt="img"></p><p>​        下面这样的语句将有不受欢迎的结果：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">*p &#x3D; &#39;x&#39;;                     &#x2F;&#x2F; modifies both s1 and s2!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        String的拷贝构造函数没有办法检测这样的问题，因为它不知道指向s1拥有的StringValue对象的指针的存在。并且，这个问题不局限于指针：它同样存在于有人保存了一个String的非const operator[]的返回值的引用的情况下。</p><p>​        至少有三种方法来应付这个问题。第一个是忽略它，假装它不存在。这是实现带引用计数的String类的类库中令人痛苦的常见问题。如果你有带引用计数的String类，试一下上面的例子，看你是否很痛苦。即使你不能确定你操作的是否是带引用计数的String类，也无论如何应该试一下这个例子。由于封装，你可能使用了一个这样的类型而不自知。</p><p>​        不是所以的实现都忽略这个问题。稍微好些的方法是明确说明它的存在。通常是将它写入文档，或多或少地说明“别这么做。如果你这么做了，结果为未定义。”无论你以哪种方式这么做了（有意地或无意地），并抱怨其结果时，他们辩解道：“好了，我们告诉过你别这么做的。”这样的实现通常很方便，但它们在可用性方面留下了太多的期望。</p><p>​        第三个方法是排除这个问题。它不难实现，但它将降低一个值共享于对象间的次数。它的本质是这样的：在每个StringValue对象中增加一个标志以指出它是否为可共享的。在最初（对象可共享时）将标志打开，在非const的operator[]被调用时将它关闭。一旦标志被设为false，它将永远保持在这个状态（注10）。</p><p>​        这是增加了共享标志的修改版本：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue &#123;    int refCount;    bool shareable;                &#x2F;&#x2F; add this        char *data;        StringValue(const char *initValue);       ~StringValue();  &#125;;...&#125;;String::StringValue::StringValue(const char *initValue):refCount(1),shareable(true)                &#x2F;&#x2F; add this&#123;  data &#x3D; new char[strlen(initValue) + 1];  strcpy(data, initValue);&#125;String::StringValue::~StringValue()&#123;  delete [] data;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如你所见，并不需要太多的改变；需要修改的两行都有注释。当然，String的成员函数也必须被修改以处理这个共享标志。这里是拷贝构造函数的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String::String(const String&amp; rhs)&#123;  if (rhs.value-&gt;shareable) &#123;    value &#x3D; rhs.value;    ++value-&gt;refCount;  &#125;  else &#123;    value &#x3D; new StringValue(rhs.value-&gt;data);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        所有其它的成员函数也都必须以类似的方法检查这个共享标志。非const的operator[]版本是唯一将共享标志设为false的地方：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char&amp; String::operator[](int index)&#123;  if (value-&gt;refCount &gt; 1) &#123;    --value-&gt;refCount;value &#x3D; new StringValue(value-&gt;data);  &#125;  value-&gt;shareable &#x3D; false;           &#x2F;&#x2F; add this  return value-&gt;data[index];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果使用Item M30中的proxy类的技巧以区分读写操作，你通常可以降低必须被设为不可共享的StringValue对象的数目。</p><p>​        引用计数不只用在字符串类上，只要是多个对象具有相同值的类都可以使用引用计数。改写一个类以获得引用计数需要大量的工作，而我们已经有太的工作需要做了。这样不好吗：如果我们将引用计数的代码写成与运行环境无关的，并能在需要时将它嫁接到其它类上？当然很好。很幸运，有一个方法可以实现它（至少完成了绝大部分必须的工作）。</p><p>​        第一步是构建一个基类RCObject，任何需要引用计数的类都必须从它继承。RCObject封装了引用计数功能，如增加和减少引用计数的函数。它还包含了当这个值不再被需要时摧毁值对象的代码（也就是引用计数为0时）。最后，它包含了一个字段以跟踪这个值对象是否可共享，并提供查询这个值和将它设为false的函数。不需将可共享标志设为true的函数，因为所有的值对象默认都是可共享的。如上面说过的，一旦一个对象变成了不可共享，将没有办法使它再次成为可共享。</p><p>​        RCObject的定义如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class RCObject &#123;public:  RCObject();  RCObject(const RCObject&amp; rhs);  RCObject&amp; operator&#x3D;(const RCObject&amp; rhs); virtual ~RCObject() &#x3D; 0;  void addReference();  void removeReference();void markUnshareable();bool isShareable() const;bool isShared() const;private:int refCount;bool shareable;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        RCObjcet可以被构造（作为派生类的基类部分）和析构；可以有新的引用加在上面以及移除当前引用；其可共享性可以被查询以及被禁止；它们可以报告当前是否被共享了。这就是它所提供的功能。对于想有引用计数的类，这确实就是我们所期望它们完成的东西。注意虚析构函数，它明确表明这个类是被设计了作基类使用的（见Item E14）。同时要注意这个析构函数是纯虚的，它明确表明这个类只能作基类使用。</p><p>​        RCOject的实现代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">RCObject::RCObject(): refCount(0), shareable(true) &#123;&#125;RCObject::RCObject(const RCObject&amp;): refCount(0), shareable(true) &#123;&#125;RCObject&amp; RCObject::operator&#x3D;(const RCObject&amp;)&#123;     return *this; &#125;RCObject::~RCObject() &#123;&#125;               &#x2F;&#x2F; virtual dtors must always                                       &#x2F;&#x2F; be implemented, even if                                           &#x2F;&#x2F; they are pure virtual                                           &#x2F;&#x2F; and do nothing (see also                                           &#x2F;&#x2F; Item M33 and Item E14)void RCObject::addReference() &#123;    ++refCount; &#125;void RCObject::removeReference()&#123;       if (--refCount &#x3D;&#x3D; 0)        delete this; &#125;void RCObject::markUnshareable()&#123;     shareable &#x3D; false; &#125;bool RCObject::isShareable() const&#123;     return shareable; &#125;bool RCObject::isShared() const&#123;     return refCount &gt; 1; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可能很奇怪，我们在所有的构造函数中都将refCount设为了0。这看起来违反直觉。确实，最少，构造这个RCObject对象的对象引用它！在它构造后，只需构造它的对象简单地将refCount设为1就可以了，所以我们没有将这个工作放入RCObject内部。这使得最终的代码看起来很简短。</p><p>​        另一个奇怪之处是拷贝构造函数也将refCount设为0，而不管被拷贝的RCObject对象的refCount的值。这是因为我们正在构造新的值对象，而这个新的值对象总是未被共享的，只被它的构造者引用。再一次，构造者负责将refCount设为正确的值。</p><p>​        RCObject的赋值运算看起来完全出乎意料：它没有做任何事情。这个函数不太可能被调用的。RCObject是基于引用计数来共享的值对象的基类，它不该被从一个赋给另外一个，而应该是拥有这个值的对象被从一个赋给另外一个。在我们这个设计里，我们不期望StringValue对象被从一个赋给另外一个，我们期望在赋值过程中只有String对象被涉及。在String参与的赋值语句中，StringValue的值没有发生变化，只是它的引用计数被修改了。</p><p>​        不过，可以想象，一些还没有写出来的类在将来某天可能从RCObject派生出来，并希望允许被引用计数的值被赋值（见Item M23和Item E16）。如果这样的话，RCObject的赋值操作应该做正确的事情，而这个正确的事情就是什么都不做。想清楚了吗？假设我们希望允许在StringValue对象间赋值。对于给定的StringValue对象sv1和sv2，在赋值过程中，它们的引用计数值上发生什么？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">sv1 &#x3D; sv2;                    &#x2F;&#x2F; how are sv1&#39;s and sv2&#39;s reference counts affected?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在赋值之前，已经有一定数目的String对象指向sv1。这个值在赋值过程中没有被改变，因为只是sv1的值被改变了。同样的，一定数目的String对象在赋值之前指向前v2，在赋值后，同样数目的对象指向sv2。sv2的引用计数同样没有改变。当RCObject在赋值过程中被涉及时，指向它的对象的数目没有受影响，因此RCObject::operator=不应该改变引用计数值。上面的实现是正确的。违反直觉？可能吧，但它是正确的。</p><p>​        RCObject::removeReference的代码不但负责减少对象的refCount值，还负责当refCount值降到0时析构对象。后者是通过delete this来实现的，如Item M27中解释的，这只当我们知道*this是一个堆对象时才安全。要让这个类正确，我们必须确保RCObject只能被构建在堆中。实现这一点的常用方法见Item M27，但我们这次采用一个特别的方法，这将在本条款最后讨论。</p><p>​        为了使用我们新写的引用计数基类，我们将StringValue修改为是从RCObject继承而得到引用计数功能的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue: public RCObject &#123;    char *data;    StringValue(const char *initValue);        ~StringValue();&#125;;...&#125;;String::StringValue::StringValue(const char *initValue)&#123;  data &#x3D; new char[strlen(initValue) + 1]; strcpy(data, initValue);&#125;String::StringValue::~StringValue()&#123;  delete [] data;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个版本的StringValue和前面的几乎一样，唯一改变的就是StringValue的成员函数不再处理refCount字段。RCObject现在接管了这个工作。</p><p>​        不用感觉不舒服，如果你注意到嵌套类（StringValue）从一个与包容类（String）无关的类（RCObject）继承而来的话。它第一眼看上去是有些古怪，但完全合理。嵌套类和其它类是完全相同的，所以它有自由从它喜欢的任何其它类继承。以后，你不用第二次思考这种继承关系了。   </p><p>​        RCObject类给了我们一个存储引用计数的地方，并提供了成员函数供我们操作引用计数，但调用这些函数的动作还必须被手工加入其它类中。仍然需要在String的拷贝构造函数和赋值运算函数中调用StringValue的addReference和 removeReference函数。这很笨拙。我们想将这些调用也移入一个可重用的类中，以使得String这样的类的作者不用再担心引用计数的任何细节。能实现吗？C++支持这样的重用吗？</p><p>​        能。没有一个简单的方法将所有引用计数方面的工作从所有的类中移出来；但有一个方法可以从大部分类中将大部分工作移出来。（在一些类中，你可以消除所有引用计数方面的代码，但我们的String类不是其中之一。有一个成员函数搞坏了这件事，我希望你别吃惊，它是我们的老对头：非const版本的operator[]。别放心上，我们最终制服了这家伙。）</p><p>​        每个String对象包含一个指针指向StringValue对象：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue: public RCObject &#123; ... &#125;;  StringValue *value;                &#x2F;&#x2F; value of this String  ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们必须操作StringValue对象的refCount字段，只要任何时候任一个指向它的指针身上发生了任何有趣的事件。“有趣的事件”包括拷贝指针、给指针赋值和销毁指针。如果我们能够让指针自己检测这些事件并自动地执行对refCount字段的必须操作，那么我们就自由了。不幸的是，指针功能很弱，对任何事情作检测并作出反应都是不可能的。还好，有一个办法来增强它们：用行为类似指针的对象替代它们，但那样要多做很多工作了。</p><p>​        这样的对象叫灵巧指针，你可以在Item M28这看到它的更多细节。就我们这儿的用途，只要知道这些就足够了：灵巧指针对象支持成员选择（-&gt;）和反引用（*）这两个操作符，就象真的指针一样，并和内建指针一样是强类型的：你不能将一个指向T的灵巧指针指向一个非T类型的对象。</p><p>​        这儿是供引用计数对象使用的灵巧指针模板：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; template class for smart pointers-to-T objects. T must&#x2F;&#x2F; support the RCObject interface, typically by inheriting&#x2F;&#x2F; from RCObjecttemplate&lt;class T&gt;class RCPtr &#123;public:  RCPtr(T* realPtr &#x3D; 0);  RCPtr(const RCPtr&amp; rhs);  ~RCPtr();  RCPtr&amp; operator&#x3D;(const RCPtr&amp; rhs);  T* operator-&gt;() const;            &#x2F;&#x2F; see Item 28  T&amp; operator*() const;             &#x2F;&#x2F; see Item 28private:  T *pointee;                       &#x2F;&#x2F; dumb pointer this                                    &#x2F;&#x2F; object is emulating  void init();                      &#x2F;&#x2F; common initialization&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个模板让灵巧指针对象控制在构造、赋值、析构时作什么操作。当这些事件发生时，这些对象可以自动地执行正确的操作来处理它们指向的对象的refCount字段。</p><p>​        例如，当一个RCPtr构建时，它指向的对象需要增加引用计数值。现在不需要程序员手工处理这些细节了，因为RCPtr的构造函数自己处理它。两个构造函数几乎相同，除了初始化列表上的不同，为了不写两遍，我们将它放入一个名为init的私有成员函数中供二者调用：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;RCPtr&lt;T&gt;::RCPtr(T* realPtr): pointee(realPtr)&#123;  init();&#125;template&lt;class T&gt;RCPtr&lt;T&gt;::RCPtr(const RCPtr&amp; rhs): pointee(rhs.pointee)&#123;  init();&#125;template&lt;class T&gt;void RCPtr&lt;T&gt;::init()&#123;  if (pointee &#x3D;&#x3D; 0) &#123;                &#x2F;&#x2F; if the dumb pointer is    return;                          &#x2F;&#x2F; null, so is the smart one  &#125;if (pointee-&gt;isShareable() &#x3D;&#x3D; false) &#123;           &#x2F;&#x2F; if the value    pointee &#x3D; new T(*pointee);                   &#x2F;&#x2F; isn&#39;t shareable,  &#125;                                              &#x2F;&#x2F; copy itpointee-&gt;addReference();             &#x2F;&#x2F; note that there is now a&#125;                                    &#x2F;&#x2F; new reference to the value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        将相同的代码移入诸如init这样的一个独立函数是很值得效仿的，但它现在暗淡无光，因为在此处，这个函数的行为不正确。</p><p>​        问题是这个：当init需要创建value的一个新拷贝时（因为已存在的拷贝处于不可共享状态），它执行下面的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">pointee &#x3D; new T(*pointee);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        pointee的类型是指向T的指针,所以这一语句构建了一个新的T对象，并用拷贝构造函数进行了初始化。由于RCPtr是在String类内部，T将是String::StringValue，所以上面的语句将调用String::StringValue的拷贝构造函数。我们没有为这个类申明拷贝构造函数，所以编译器将为我们生成一个。这个生成的拷贝构造函数遵守C++的自动生成拷贝构造函数的原则，只拷贝了StringValue的数据pointer，而没有拷贝所指向的char *字符串。这样的行为对几乎任何类（而不光是引用计数类）都是灾难，这就是为什么你应该养成为所有含有指针的类提供拷贝构造函数（和赋值运算）的习惯（见Item E11）。</p><p>​        RCPtr<T>模板的正确行为取决于T含有正确的值拷贝行为（如深拷贝）的拷贝构造函数。我们必须在StringValue中增加这样的一个构造函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue: public RCObject &#123;    StringValue(const StringValue&amp; rhs);    ...  &#125;;  ...&#125;;String::StringValue::StringValue(const StringValue&amp; rhs)&#123;  data &#x3D; new char[strlen(rhs.data) + 1];  strcpy(data, rhs.data);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        深拷贝的构造函数的存在不是RCPtr<T>的唯一假设。它还要求T从RCObject继承，或至少提供了RCObject的所提供的函数。事实上由于RCPtr对象只是被设计了指向引用计数对象的，这个假设并不过分。不过，这个假设必须被明确写入文档。</p><p>​        RCPtr<T>的最后一个假设是它所指向的对象类型为T。这似乎是显然的。毕竟，pointee的类型被申明为T*。但pointee可能实际上指向T的一个派生类。例如，如果我们有一个类SpecialStringValue是从String::StringValue继承的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue: public RCObject &#123; ... &#125;;  struct SpecialStringValue: public StringValue &#123; ... &#125;;  ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以生成一个String，包容的RCPtr<StringValue>指向一个SpecialStringValue对象。这时，我们希望init的这句：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">pointee &#x3D; new T(*pointee);                &#x2F;&#x2F; T is StringValue, but pointee really points to a SpecialStringValue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        调用的是SpecialStringValue的拷贝构造函数，而不是StringValue的拷贝构造函数。我们可以提供使用虚拷贝构造函数（见Item M25）来实现这一点。对于我们的String类，我们不期望从StringValue派生子类，所以我们忽略这个问题。</p><p>​        用这种方式实现了RCPtr的构造函数后，类的其它函数实现得很轻快。赋值运算很简洁明了，虽然“需要测试源对象的可共享状态”将问题稍微复杂化了。幸好，同样的问题已经在我们为构造函数写的init函数中处理了。我们可以爽快地再度使用它：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::operator&#x3D;(const RCPtr&amp; rhs)&#123;  if (pointee !&#x3D; rhs.pointee)    &#123;              &#x2F;&#x2F; skip assignments， where the value doesn&#39;t changeif (pointee) &#123;  pointee-&gt;removeReference();        &#x2F;&#x2F; remove reference to&#125;                                    &#x2F;&#x2F; current valuepointee &#x3D; rhs.pointee;               &#x2F;&#x2F; point to new valueinit();                              &#x2F;&#x2F; if possible, share it  &#125;                                      &#x2F;&#x2F; else make own copy  return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>析构函数很容易。当一个RCPtr被析构时，它只是简单地将它对引用计数对象的引用移除：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;RCPtr&lt;T&gt;::~RCPtr()&#123;  if (pointee)pointee-&gt;removeReference();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果这个RCPtr是最后一个引用它的对象，这个对象将在RCObject的成员函数removeReference中被析构。因此，RCPtr对象无需关心销毁它们指向的值的问题。</p><p>​        最后，RCPtr的模拟指针的操作就是你在Item M28中看到的灵巧指针的部分：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;T* RCPtr&lt;T&gt;::operator-&gt;() const &#123; return pointee; &#125;template&lt;class T&gt;T&amp; RCPtr&lt;T&gt;::operator*() const &#123; return *pointee; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        够了！完结！最后，我们将各个部分放在一起，构造一个基于可重用的RCObject和RCPtr类的带引用计数的String类。或许，你还没有忘记这是我们的最初目标。</p><p>​        每个带引用计数的Sting对象被实现为这样的数据结构：</p><p>类的定义是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;                       &#x2F;&#x2F; template class for smartclass RCPtr &#123;                           &#x2F;&#x2F; pointers-to-T objects; Tpublic:                                 &#x2F;&#x2F; must inherit from RCObject  RCPtr(T* realPtr &#x3D; 0);  RCPtr(const RCPtr&amp; rhs);  ~RCPtr();  RCPtr&amp; operator&#x3D;(const RCPtr&amp; rhs);  T* operator-&gt;() const;  T&amp; operator*() const;private:  T *pointee;  void init();&#125;;class RCObject &#123;                       &#x2F;&#x2F; base class for reference-public:                                &#x2F;&#x2F; counted objects  void addReference();  void removeReference();  void markUnshareable();  bool isShareable() const;  bool isShared() const;protected:  RCObject();  RCObject(const RCObject&amp; rhs);  RCObject&amp; operator&#x3D;(const RCObject&amp; rhs);  virtual ~RCObject() &#x3D; 0;private:  int refCount;  bool shareable;&#125;;class String &#123;                           &#x2F;&#x2F; class to be used bypublic:                                  &#x2F;&#x2F; application developers  String(const char *value &#x3D; &quot;&quot;);  const char&amp; operator[](int index) const;  char&amp; operator[](int index);private:  &#x2F;&#x2F; class representing string values  struct StringValue: public RCObject &#123;    char *data;StringValue(const char *initValue);StringValue(const StringValue&amp; rhs);void init(const char *initValue);~StringValue();  &#125;;  RCPtr&lt;StringValue&gt; value;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        绝大部分都是我们前面写的代码的翻新，没什么奇特之处。仔细检查后发现，我们在String::StringValue中增加了一个init函数，但，如我们下面将看到的，它的目的和RCPtr中的相同：消除构造函数中的重复代码。</p><p>​        这里有一个重大的不同：这个String类的公有接口和本条款开始处我们使用的版本不同。拷贝构造函数在哪里？赋值运算在哪里？析构函数在哪里？这儿明显有问题。</p><p>​        实际上，没问题。它工作得很好。如果你没看出为什么，需要重学C++了（prepare yourself for a C++ epiphany）。</p><p>​        我们不再需要那些函数了！确实，String对象的拷贝仍然被支持，并且，这个拷贝将正确处理藏在后面的被引用计数的StringValue对象，但String类不需要写下哪怕一行代码来让它发生。因为编译器为String自动生成的拷贝构造函数将自动调用其RCPtr成员的拷贝构造函数，而这个拷贝构造函数完成所有必须的对StringValue对象的操作，包括它的引用计数。RCPtr是一个灵巧指针，所以这是它将完成的工作。它同样处理赋值和析构，所以String类同样不需要写出这些函数。我们的最初目的是将不可重用的引用计数代码从我们自己写的String类中移到一个与运行环境无关的类中以供任何其它类使用。现在，我们完成了这一点（用RCObject和RCPtr两个类），所以当它突然开始工作时别惊奇。它本来就应该能工作的。</p><p>​        将所以东西放在一起，这儿是RCObject的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">RCObject::RCObject(): refCount(0), shareable(true) &#123;    &#125;RCObject::RCObject(const RCObject&amp;): refCount(0), shareable(true) &#123;    &#125;RCObject&amp; RCObject::operator&#x3D;(const RCObject&amp;)&#123;     return *this; &#125;RCObject::~RCObject() &#123;&#125;void RCObject::addReference() &#123;     ++refCount; &#125;void RCObject::removeReference()&#123;     if (--refCount &#x3D;&#x3D; 0) delete this; &#125;void RCObject::markUnshareable()&#123;     shareable &#x3D; false;&#125;bool RCObject::isShareable() const&#123;     return shareable; &#125;bool RCObject::isShared() const&#123;    return refCount &gt; 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是RCPtr的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;void RCPtr&lt;T&gt;::init()&#123;  if (pointee &#x3D;&#x3D; 0)       return;  if (pointee-&gt;isShareable() &#x3D;&#x3D; false)   &#123;    pointee &#x3D; new T(*pointee);  &#125;  pointee-&gt;addReference();&#125;template&lt;class T&gt;RCPtr&lt;T&gt;::RCPtr(T* realPtr): pointee(realPtr)&#123; init(); &#125;template&lt;class T&gt;RCPtr&lt;T&gt;::RCPtr(const RCPtr&amp; rhs): pointee(rhs.pointee)&#123; init(); &#125;template&lt;class T&gt;RCPtr&lt;T&gt;::~RCPtr()&#123; if (pointee)pointee-&gt;removeReference(); &#125;template&lt;class T&gt;RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::operator&#x3D;(const RCPtr&amp; rhs)&#123;  if (pointee !&#x3D; rhs.pointee)     &#123;    if (pointee)         &#123;            pointee-&gt;removeReference();        &#125;pointee &#x3D; rhs.pointee;init();  &#125;return *this;&#125;template&lt;class T&gt;T* RCPtr&lt;T&gt;::operator-&gt;() const &#123; return pointee; &#125;template&lt;class T&gt;T&amp; RCPtr&lt;T&gt;::operator*() const &#123; return *pointee; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是String::StringValue的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void String::StringValue::init(const char *initValue)&#123;  data &#x3D; new char[strlen(initValue) + 1];  strcpy(data, initValue);&#125;String::StringValue::StringValue(const char *initValue)&#123;     init(initValue); &#125;String::StringValue::StringValue(const StringValue&amp; rhs)&#123;     init(rhs.data); &#125;String::StringValue::~StringValue()&#123;     delete [] data; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，归结到String，它的实现是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String::String(const char *initValue): value(new StringValue(initValue)) &#123;&#125;const char&amp; String::operator[](int index) const&#123;     return value-&gt;data[index]; &#125;char&amp; String::operator[](int index)&#123;  if (value-&gt;isShared()) &#123;    value &#x3D; new StringValue(value-&gt;data);  &#125; value-&gt;markUnshareable();  return value-&gt;data[index];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果你将它和我们用内建指针实现的版本相比较，你会受到两件事的打击。第一，代码有很多的减少。因为RCPtr完成了大量以前在String内部完成的处理引用计数的担子。第二，剩下的代码几乎没有变化：灵巧指针无缝替换了内建指针。实际上，唯一的变化是在operator[]里，我们用调用isShared函数代替了直接检查refCount的值，并用灵巧指针RCPtr对象消除了写时拷贝时手工维护引用计数值的工作。</p><p>​        这当然全都很漂亮。谁能反对减少代码？谁能反对成功的封装？然而，这个全新的String类本身对用户的冲击远胜过它的实现细节，这才是真正的闪光点。如果没有什么消息是好消息的话，这本身就是最好的消息。String的接口没有改变！我们增加了引用计数，我们增加了标记某个String的值为不可共享的能力，我们将引用计数功能移入一个新类，我们增加了灵巧指针来自动处理引用计数，但用户的一行代码都不需要修改。当然，我们改变了String类的定义，所以用户需要重新编译和链接，但他们在自己代码上的投资受到了完全的保护。你看到了吗？封装确实是个很好的东西。</p><p>​        到现在为止，我们所讨论的都假设我们能够访问有关类的源码。但如果我们想让一个位于支撑库中而无法修改的类获得引用计数的好处呢？不可能让它们从RCObject继承的，所以也不能对它们使用灵巧指针RCPtr。我们运气不好吗？</p><p>​        不是的。只要对我们的设计作小小的修改，我们就可以将引用计数加到任意类型上。</p><p>​        首先考虑如果从RCObject继承的话，我们的设计看起来将是什么样子。在这种情况下，我们需要增加一个类RCWidget以供用户使用，而所有的事情都和String/StringValue的例子一样，RCWidget和String相同，Widget和StringValue相同。设计看起来是这样的：</p><p>​        <strong>我们现在可以应用这句格言：计算机科学中的绝大部分问题都可以通过增加一个中间层次来解决。</strong>我们增加一个新类CountHolder以处理引用计数，它从RCObject继承。我们让CountHolder包含一个指针指向Widget。然后用等价的灵巧指针RCIPter模板替代RCPtr模板，它知道CountHolder类的存在。（名字中的“i”表示间接“indirect”。）修改后的设计为：</p><p>​        如同StringValue一样，CountHolder对用户而言，是RCWidget的实现细节。实际上，它是RCIPtr的实现细节，所以它嵌套在这个类中。RCIPtr的实现如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class RCIPtr &#123;public:  RCIPtr(T* realPtr &#x3D; 0);  RCIPtr(const RCIPtr&amp; rhs);  ~RCIPtr();  RCIPtr&amp; operator&#x3D;(const RCIPtr&amp; rhs);  const T* operator-&gt;() const;               &#x2F;&#x2F; see below for an  T* operator-&gt;();                           &#x2F;&#x2F; explanation of why  const T&amp; operator*() const;                &#x2F;&#x2F; these functions are  T&amp; operator*();                            &#x2F;&#x2F; declared this wayprivate:  struct CountHolder: public RCObject   &#123;    ~CountHolder() &#123;        delete pointee;     &#125;    T *pointee;  &#125;;  CountHolder *counter;  void init();  void makeCopy();                                &#x2F;&#x2F; see below&#125;;template&lt;class T&gt;void RCIPtr&lt;T&gt;::init()&#123;  if (counter-&gt;isShareable() &#x3D;&#x3D; false)  &#123;    T *oldValue &#x3D; counter-&gt;pointee;counter &#x3D; new CountHolder;counter-&gt;pointee &#x3D; new T(*oldValue); &#125;  counter-&gt;addReference();&#125;template&lt;class T&gt;RCIPtr&lt;T&gt;::RCIPtr(T* realPtr): counter(new CountHolder)&#123;  counter-&gt;pointee &#x3D; realPtr;  init();&#125;template&lt;class T&gt;RCIPtr&lt;T&gt;::RCIPtr(const RCIPtr&amp; rhs): counter(rhs.counter)&#123;     init();&#125;template&lt;class T&gt;RCIPtr&lt;T&gt;::~RCIPtr()&#123;     counter-&gt;removeReference(); &#125;template&lt;class T&gt;RCIPtr&lt;T&gt;&amp; RCIPtr&lt;T&gt;::operator&#x3D;(const RCIPtr&amp; rhs)&#123;  if (counter !&#x3D; rhs.counter)     &#123;    counter-&gt;removeReference();     counter &#x3D; rhs.counter; init();  &#125;  return *this;&#125;template&lt;class T&gt;                          &#x2F;&#x2F; implement the copyvoid RCIPtr&lt;T&gt;::makeCopy()                 &#x2F;&#x2F; part of copy-on-&#123;                                          &#x2F;&#x2F; write (COW)  if (counter-&gt;isShared())   &#123;    T *oldValue &#x3D; counter-&gt;pointee;counter-&gt;removeReference();counter &#x3D; new CountHolder;counter-&gt;pointee &#x3D; new T(*oldValue);counter-&gt;addReference();    &#125;    &#125;template&lt;class T&gt;                           &#x2F;&#x2F; const access;const T* RCIPtr&lt;T&gt;::operator-&gt;() const      &#x2F;&#x2F; no COW needed&#123;    return counter-&gt;pointee; &#125;template&lt;class T&gt;                           &#x2F;&#x2F; non-constT* RCIPtr&lt;T&gt;::operator-&gt;()                  &#x2F;&#x2F; access; COW&#123;     makeCopy();     return counter-&gt;pointee; &#125;    &#x2F;&#x2F; neededtemplate&lt;class T&gt;                           &#x2F;&#x2F; const access;const T&amp; RCIPtr&lt;T&gt;::operator*() const       &#x2F;&#x2F; no COW needed&#123;     return *(counter-&gt;pointee);&#125;template&lt;class T&gt;                           &#x2F;&#x2F; non-constT&amp; RCIPtr&lt;T&gt;::operator*()                   &#x2F;&#x2F; access; do the&#123;    makeCopy();     return *(counter-&gt;pointee); &#125; &#x2F;&#x2F; COW thing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        RCIPtr与RCPtr只两处不同。第一，RCPtr对象直接指向值对象，而RCIptr对象通过中间层的CountHolder对象指向值对象。第二，RCIPtr重载了operator-&gt;和operator*，当有对被指向的对象的非const的操作时，写时拷贝自动被执行。</p><p>​        有了RCIPtr，很容易实现RCWidget，因为RCWidget的每个函数都是将调用传递给RCIPtr以操作Widget对象。举个例子，如果Widget是这样的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Widget &#123;public:  Widget(int size);  Widget(const Widget&amp; rhs);  ~Widget();  Widget&amp; operator&#x3D;(const Widget&amp; rhs);  void doThis();  int showThat() const;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那么RCWidget将被定义为这样：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class RCWidget &#123;public:  RCWidget(int size): value(new Widget(size)) &#123;&#125;  void doThis() &#123; value-&gt;doThis(); &#125;  int showThat() const &#123; return value-&gt;showThat(); &#125;private:  RCIPtr&lt;Widget&gt; value;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意RCWidget的构造函数是怎么用它被传入的参数调用Widget的构造函数的（通过new操作符，见Item M8）；RCWidget的doThis怎么调用Widget的doThis函数的；以及RCWidget的showThat怎么返回Widget的showThat的返回值的。同样要注意RCWidget没有申明拷贝构造函数和赋值操作函数，也没有析构函数。如同String类一样，它不需要这些函数。感谢于RCIPtr的行为，RCWidget的默认版本将完成正确的事情。</p><p>​        如果认为生成RCWidget的行为很机械，它应该自动进行，那么你是对的。不难写个小程序接受如Widget这样的类而输出RCWidget这样的类。如果你写了一个这样的程序，请让我知道。</p><p>​        让我们从Widget、String、值、灵巧指针和引用计数基类中摆脱一下。给个机会回顾一下，在更广阔的环境下看一下引用计数。在更大的环境下，我们必须处理一个更高层次的问题，也就是什么时候使用引用计数？</p><p>​        实现引用计数不是没有代价的。每个被引用的值带一个引用计数，其大部分操作都需要以某种形式检查或操作引用计数。对象的值需要更多的内存，而我们在处理它们时需要执行更多的代码。此外，就内部的源代码而言，带引用计数的类的复杂度比不带的版本高。没有引用计数的String类只依赖于自己，而我们最终的String类如果没有三个辅助类（StringValue、RCObject和RCPtr）就无法使用。确实，我们这个更复杂的设计确保在值可共享时的更高的效率；免除了跟踪对象所有权的需要，提高了引用计数的想法和实现的可重用性。但，这四个类必须写出来、被测试、文档化、和被维护，比单个类要多做更多的工作。即使是管理人员也能看出这点。</p><p>​        引用计数是基于对象通常共享相同的值的假设的优化技巧（参见Item M18）。如果假设不成立的话，引用计数将比通常的方法使用更多的内存和执行更多的代码。另一方面，如果你的对象确实有具体相同值的趋势，那么引用计数将同时节省时间和空间。共享的值所占内存越大，同时共享的对象数目越多，节省的内存也就越大。创建和销毁这个值的代价越大，你节省的时间也越多。总之，引用计数在下列情况下对提高效率很有用：</p><p>​        少量的值被大量的对象共享。这样的共享通常通过调用赋值操作和拷贝构造而发生。对象/值的比例越高，越是适宜使用引用计数。</p><p>​        对象的值的创建和销毁代价很高昂，或它们占用大量的内存。即使这样，如果不是多个对象共享相同的值，引用计数仍然帮不了你任何东西。</p><p>​        只有一个方法来确认这些条件是否满足，而这个方法不是猜测或依赖直觉（见Item M16）。这个方法是使用profiler或其它工具来分析。使用这种方法，你可以发现是否创建和销毁值的行为是性能瓶颈，并能得出对象/值的比例。只有当你手里有了这些数据，你才能得出是否从引用计数上得到的好处超过其缺点。</p><p>​        即使上面的条件满足了，使用引用计数仍然可能是不合适的。有些数据结构（如有向图）将导致自我引用或环状结构。这样的数据结构可能导致孤立的自引用对象，它没有被别人使用，而其引用计数又绝不会降到零。因为这个无用的结构中的每个对象被同结构中的至少一个对象所引用。商用化的垃圾收集体系使用特别的技术来查找这样的结构并消除它们，但我们现在使用的这个简单的引用计数技术不是那么容易扩充出这个功能的。</p><p>​        即使效率不是主要问题，引用计数仍然很吸引人。如果你不放心谁应该去执行删除动作，那么引用计数正是这种让你放下担子的技巧。很多程序员只因为这个原因就使用引用计数。</p><p>​        让我们用最后一个问题结束讨论。当RCObject::removeReference减少对象的引用计数时，它检查新值是否为0。如果是，removeReference通过调用delete this销毁对象。这个操作只在对象是通过调用new生成时才安全，所以我们需要一些方法以确保RCObject只能用这种方法产生。</p><p>​        此处，我们用习惯方法来解决。RCObject被设计为只作被引用计数的值对象的基类使用，而这些值对象应该只通过灵巧指针RCPtr引用。此外，值对象应该只能由值会共享的对象来实例化；它们不能被按通常的方法使用。在我们的例子中，值对象的类是StringValue，我们通过将它申明为String的私有而限制其使用。只有String可以创建StringValue对象，所以String类的作者应该确保这些值对象都是通过new操作产成的。</p><p>​        于是，我们限制RCObject只能在堆上创建的方法就是指定一组满足这个要求的类，并确保只有这些类能创建RCObject对象。用户不可能无意地（或有意地）用一种不恰当的方法创建RCObject对象。我们限制了创建被引用计数对象的权力，当我们交出这个权力时，必须明确其附带条件是满足创建对象的限制条件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP_ExtensiveReadingNotes-1-EssentialCPP</title>
      <link href="/2023/06/06/CPP-ExtensiveReadingNotes-1-EssentialCPP/"/>
      <url>/2023/06/06/CPP-ExtensiveReadingNotes-1-EssentialCPP/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础编程"><a href="#C-基础编程" class="headerlink" title="C++基础编程"></a>C++基础编程</h1><p>​        下面，我们开始正式的入门Ｃ++这个语言，通过一些简单的分析来了解一些简单的概念！我们将会在这些sections中认识</p><p>​        基本的数据类型：不二之，自负，证书，浮点数等概念</p><p>​        还要认识算术运算符，关系运算符和逻辑运算符，用在操作上树基础数据类型。这些运算符包括诸如+ ,==, &lt;=等，还会有赋值，也包括Ｃ/Ｃ++的++自增运算，条件运算（？：）和复合赋值运算（+=）</p><p>​        一些基本结构语句，比如说ifwhile等来改变程序的流程</p><p>​        一些复合类型、比如说指针和数组。</p><p>​        一套标准而又通用的抽象化库，比如字符串（string）和向量(vector)</p><h2 id="1-1简单程序的书写"><a href="#1-1简单程序的书写" class="headerlink" title="1.1简单程序的书写"></a>1.1简单程序的书写</h2><p>​        下面开始书写简单的程序，我们的要求是将一小段信息发送到用户的终端，是请求用户输入一小段自己的姓名，程序读取后用这个姓名来跟用户打招呼。</p><p>​        在Ｃ/C++中，程序是从一个叫做main()的地方开始入手执行程序的，格式如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;    &#x2F;&#x2F; this is he place you input the code &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        int是Ｃ++程序的一个关键字，什么是关键字呢？就是程序语言预先定义好了的具有特殊含义的名称。言之：int是用来表示内置的数据类型的，它表明这一个整形。</p><p>​        函数是一块独立的程序代码序列，main函数返回一个整形，事实上，它的逻辑含义正式说明程序是否正确允许运行，原则上正确运行返回0，否则返回其他值。这表达出程序产生了其他错误需要处理！</p><p>​        当然，其他函数的名称可以由程序员自己选择，当然，最好名称是让人一下子就明白这是要干什么的！比如对于一个实现了排序的函数，你给他起名字叫sort()也比叫他q()强的多</p><p>​        函数的参数列表，是函数执行时候可能用到的参数，我们把它放在（）里面，比如：void sort(int* arr, unsigned int arrLen)，而当你直接书写（）表明函数不接受参数！</p><p>​        随后，当我们制定完函数的返回类型，参数列表函数名称之后，就用一个大括号将实现代码阔起来{}</p><p>​        // 是C/C++的注释符号！</p><p>​        下面我们开始完成任务：第一个工作就是向用户给出提示输入！事实上，在Ｃ++中，我们是调用面对对象的类层次体系来完成这个工作的</p><p>​        所谓的类就是用户自己定义的数据类型，在Ｃ++中这个关键字就是class。我们使用基本的数据类型将他们组合起来构成新的自定义的对象！比如说：我们选择三个浮点型来表现一个点的空间坐标！等等。</p><p>​        class给我们了抽象事物的能力！虽然说还是没到该使用class的时候，但还是先要声明一下，我妈实现一个class类即要声明又要实现！它们要被放在不同的文件下。想要使用这些类呢，就要引用他们的声明文件，也就是头文件！标准格式如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这里，有标准库已经封装好C++了的控制台输出对象：cout，这样的使用，就可以把我们想要输入的东西输出到控制台上：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cout&lt;&lt; “offer me your name please!”;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这就是一条单独的语句。如果我们书写这样的代码，C++用户就会看见一条信息了！但是先别急，还没讲完，这个时候运行会报错的。</p><p>​        我们要找一个东西来储存用户的输入，不错，选取标准库的string 是一个汗不错的主意。声明的方式可以类比：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string usr_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是止步于此系统不认识你的string是什么，于是声明一下头文件就好了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;string&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以后运用cin来输入东西读入进程序就好了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cin &gt;&gt; usr_name; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而在我们读取成功之后，我们利用收集到的信息，来完成打招呼：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cout&lt;&lt;“hello,” &lt;&lt;usr_name&lt;&lt;“ nice to meet you!”&lt;&lt;“\n”;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        是的，我们的Cout可以这样使用来达到连续输出的效果！</p><p>​        下面我们组合起来，完成我们第一个大程序：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt; using namespace std; &#x2F;&#x2F; using in declaring the functions that belongs to which! int main()&#123;string usr_namel;cout &lt;&lt; “sbmit your first name”; cin &gt;&gt; usr_name; cout &lt;&lt; “ hello !”&lt;&lt; usr_name&lt;&lt; “nice to meet you\n”; ,&#x2F;&#x2F; 表示换行return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们的程序会在后面很成功的完成我们的任务。</p><p>​        程序中间的有一行，是我们需要留心的，那就是C++</p><p>​        using namespace std;</p><p>​        这一行程序将标准库里的函数所在的空间暴露给我们的程序，意味着我们不再需要指明这是哪里的某函数便可以直接使用之！</p><h2 id="对象的定义和初始化问题"><a href="#对象的定义和初始化问题" class="headerlink" title="对象的定义和初始化问题"></a>对象的定义和初始化问题</h2><p>​        下面想要集中说明的是关于对象初始化和定义的问题！</p><p>​        这是一块内存地址对于我们程序员的抽象！换而言之，我们给这块内存地址取一个名字，映射这块内存地址，赋予它数据类型。注意的是名称是任何字母，数字和下划线_的若干组合！大小写是区分的！！！对象名称也不可以由名字打头！比如说1_User是一个不合法的名称。</p><p>​        每个对象都有自己的数据类型，他们决定了这个对象有多大，范围如何。一个标准的声明对象的格式是：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int usr_val &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也就是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typename varName &#x3D; Val;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在这行语句里，我们实际上做了两件事情：对象的定义和初始化，我们都做了！定义只是声明了这个变量是什么，赋值，也就是初始化的具体行为，是用assignment这个行为，使用= 这个运算符完成的。</p><p>​        简单的对象只需要一次复制就可以有效的完成。但是对于复杂的对象，也就是比如说复数：学过几本数学的都知道，复数是由实数和虚数构成的。那么，这样的行为大多数情况下就是未定义的！</p><pre class="line-numbers language-C++C++" data-language="C++C++"><code class="language-C++C++">complex anError &#x3D; 1; &#x2F;&#x2F; Error ,this is a compound variable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那，我们就需要使用这样的方式，比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Complex ok(10,20);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>标准库是怎么说的呢？标准库是使用了模版来进行编程的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;complex&gt;C++Complex&lt;double&gt; aComplex(10,29);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        好好好，那这个<double>又是几个意思呢？事实上这涉及到另一个高级的概念叫做模版编程。对于一类大对象，我们需要知道具体的（用户和用户程序员给出才能完全确定的）数据结构才能进行完全的初始化。这个是模版</p><p>​        当然，对于一些常量，我们使用const修饰符来让编译器知道这个变量是不允许修改的！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> typeName varName <span class="token operator">=</span> initialVal<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="书写表达式"><a href="#书写表达式" class="headerlink" title="书写表达式"></a>书写表达式</h2><p>​        下面我们来开始另一个Ｃ++编程的主要活动，也就是书写表达式指挥编译器，从而间接的指挥CPU等各个硬件来完成我们希望完成的工作。事实上，我们刚刚阐述的赋值就是一种赋值表达式。</p><p>​        表达式可以是简单的：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">i <span class="token operator">+=</span> <span class="token number">2</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也可以是复杂的，比如说下面的式子实现了自动检测行数来实现自动换行的语句</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> textInLine <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>cnt <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">?</span> ‘’ <span class="token operator">:</span> ‘\n’ <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        %这个运算符是取余操作符，同时，还有一个崭新的三目操作符</p><pre class="line-numbers language-none"><code class="language-none">EXPR1 ? EXPR2 : EXPR3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是什么意思呢？我换一下：你吃饭了吗？ 吃了：没吃也就是说，只有对着EXPR1 求值返回的是真，才会执行EXPR2 ，否则就是执行3</p><pre><code>     表达式的核心是运算符，对于赋值行为我们常常会遇到自己操作自己的情况。Ｃ++使用+=，++ 等行为来简化我们的自增行为。</code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cnt <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        特别的 ++ 和 — 是递增递减运算符，专门的，有前置的与后置的运算符。</p><p>​        前置是先加后用，也就是说</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// demo </span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>val<span class="token punctuation">;</span><span class="token comment">// On console , we see the res is 11</span>cout <span class="token operator">&lt;&lt;</span> val<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// On console , we see the res is 11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        除了赋值运算符，我们还有关系运算符。这里有== != &lt; &gt; &lt;= &gt;= 这个关系式返回的是布尔值。这样的特性使之可以用在if 等结构语句。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if( BOOL_EXPR)&#123;&#x2F;&#x2F; the statements that executing only when EXPR is true.&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个经典的应用我想就是用户反馈判断的代码了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(usr_choice &#x3D;&#x3D; ‘Y’)&#123;usr_more &#x3D; false;&#125;else&#123;usr_more &#x3D; true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值的我们反复警示的是！很多人上手就会写好玩的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(choice &#x3D; ‘Y’)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样就是一个赋值行为，表达式返回赋值的结果，也就是说，除非是赋值0，否则这个if判断将会是永远成立的！而且choice的值将会被赋值‘Y’，灾难！</p><p>​        在if中的表达式可以使用&amp;&amp; || !等运算符来避免不必要的嵌套if从句，后者对于阅读代码的人来讲是一个灾难。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(password &amp;&amp; validate( password) &amp;&amp; (get_account &#x3D; retrieve_account_info(password)  )  )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如上，我们首先看password是不是false，是的话，后面的表达式不执行直接跳过！</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>我们运算符也有优先级的，运算符从上到下运算符优先级逐步降低：</p><p>NOT ！</p><p>算术运算符 * / %</p><p>算术运算符 + -</p><p>关系运算符 &lt; &gt; &lt;= &gt;=</p><p>关系运算符 == !=</p><p>逻辑运算符AND</p><p>逻辑运算符 OR</p><p>赋值运算符 =</p><p>因此，当我们试图判断 i可不可以被2惩整除的时候，不可以写作：</p><p>if(!i %2)</p><p>因为！i会被先计算，所以，这样才是合适的：</p><p>if（!(i%2)）</p><p>条件语句和循环语句</p><p>下面要讲述简单的循环语句和条件语句。</p><p>条件语句很简单，就是if ,else ,else if三件套，这个我们不再多说，没有新鲜的东西！</p><p>但是值得一提的是switch语句！我们如果发现可以使用一系列的整数来代替选择的话就不妨使用switch语句，其格式是这样的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">switch(num)&#123;case 1:cout &lt;&lt; “this is the case 1”;break; &#x2F;&#x2F; break is using to jump out the structure .case 2:cout &lt;&lt; “this is the case 2”;break;default:break;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环语句</p><p>我们如果希望程序在某一个条件之下一直做一些什么事情，那while for do{}while什么的最合适了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(get_Correct)&#123;get_Correct &#x3D; usrInput();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>while循环表达式会在开始执行循环体的时候先计算（）内部的表达式是不是真，若果是真循环体执行一直到表达式循环为假，这就强迫我们提供循环的出口！</p><p>当然，有的时候可以用break 直接干掉循环，或者是使用 continue结束当前循环。</p><p>比如说</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(cin &gt;&gt; word)&#123; if(word.size() &lt; min_size)&#123;continue; &#x2F;&#x2F; 只是不再收录小于 min 长度的字符串&#125;if(word.size() &gt;&#x3D; max_size)&#123;break; &#x2F;&#x2F; 则是遇到大于最大长度的直接跳出循环继续执行其他的程序&#125;Proceed_text(word)&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用标准库的array-和vector"><a href="#使用标准库的array-和vector" class="headerlink" title="使用标准库的array 和vector"></a>使用标准库的array 和vector</h2><p>我们的程序经常需要存储一系列的元素，这需要我们使用数组来完成这个工作，在Ｃ++中，前辈们已经帮我们封装好了 array 和 vector使用。</p><p>想要使用之，就必须首先引用头文件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;array&gt;#include&lt;vector&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在初始化的时候，就需要注意到我们首先要指明存什么</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int sq_size &#x3D; 10;vector&lt;int&gt; pell_seq(sq_size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你瞧，这样就好了，int指明了我们的动态数组（vector是动态数组）存储整形的，而pell_seq 是这个动态数组的名字，（）里面提供的是初始化时提供的参数。</p><p>对于数组的赋值，我们使用[]，里头提供下标来作为在数组哪里赋值的依据。</p><p>这里为了方便使用for语句来赋值</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for(init-statement; condition_of_continueForLoop; expression)&#123; &#125; for(int i &#x3D; 0; i &lt; 10; i++)&#123;pell_seq[i] &#x3D; i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你看这样就好了。至于如何打印我们将在后面学习！</p><p>array是类似的，不过，array是静态的数组，不支持动态扩展，这是我们需要注意的。</p><h2 id="指针小论"><a href="#指针小论" class="headerlink" title="指针小论"></a>指针小论</h2><p>我们可以通过被告知元素在哪里而不是他叫什么来访问元素。这正是指针的用处！声明一个指针，赋予其地址，也就是他在计算机内存的何处。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> pVal <span class="token operator">=</span> <span class="token operator">&amp;</span>Val<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用这个方法拿到一个元素的地址，这下，指针就像钥匙一般找到元素本身来对其本身进行操作了：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token keyword">if</span>（<span class="token operator">*</span>pVal <span class="token operator">!=</span> <span class="token number">1024</span>）<span class="token punctuation">&#123;</span><span class="token operator">*</span>pVal <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们不在声明中对指针变量使用*时，正是解引用的意思。</p><p>我们需要指出的是，在指针本身，也可以存在：指针不指向任何东西，在习惯上赋值为NULL，当然在后面的Ｃ++中又使用nullptr作为不指向任何东西的指针。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">*</span> pVec <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> pVec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，这也提醒我们，在我们通过指针来对对象进行若干操作的时候，就需要首先了解一下这个指针是不是空：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>pVec <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>pVec<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// pVec 有效吗 &amp;&amp; pVec指向的对象元素是不是空    </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文件流操作"><a href="#文件流操作" class="headerlink" title="文件流操作"></a>文件流操作</h2><p>操纵文件，对文件输入输出东西在Ｃ++中十分常见！</p><p>来看一个DEMO。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ofstream <span class="token function">outfile</span><span class="token punctuation">(</span>“something<span class="token punctuation">.</span>txt”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这行代码的作用效果是：打开一个文件，它是something.txt 如果文件并不存在，那我们就创建一个叫something的文本文件。并且让他处于打开的状态，从而程序可以对之输入。</p><p>但是，如我们每次都这样书写，带来的作用是新的会覆盖旧的书写，如果我们不想这样，那就提供一个参数： ios_base::app表明我们现在对文件施以追加输入。现在，可以通过outfile这个对象来给文件重定向内容了！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>outfile <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cerr <span class="token operator">&lt;&lt;</span> “Sadly unable to open <span class="token operator">and</span> write something <span class="token keyword">int</span> the file <span class="token operator">:</span><span class="token punctuation">(</span>”<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>outfile <span class="token operator">&lt;&lt;</span> usr_name <span class="token operator">&lt;&lt;</span> “is ” <span class="token operator">&lt;&lt;</span> someString <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件的输入到程序中至可读，我们使用的是ifstream, 定义个ifstream 类的对象</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ifstream infile(“seq.txt”);if(!infile)&#123;cerr &lt;&lt; “Oops, seemingly you are new here…”;&#x2F;&#x2F; do others&#125;while(infile &gt;&gt; name)&#123;cout &lt;&lt; name &lt;&lt; endl;&#125;        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="面向过程的函数编程"><a href="#面向过程的函数编程" class="headerlink" title="面向过程的函数编程"></a>面向过程的函数编程</h2><p>​        为了更好的开发更大的程序，我们往往采用函数来完成我们的编程任务，从而提高代码的复用性。</p><h2 id="如何编写一个函数"><a href="#如何编写一个函数" class="headerlink" title="如何编写一个函数"></a>如何编写一个函数</h2><p>​        每一个函数都必须由下面四个部分构成：</p><p>​        1）返回类型 returnType : 简单的讲就是函数返回啥的问题</p><p>​        2）函数名： 函数的命名也有讲究，如何给函数命名是一门艺术，简单的讲：使用名称来告诉用户程序员这个函数的功能！</p><p>​        3）参数列表： 函数需要什么？这就是参数列表的用处了，参数列表列出了函数需要什么！</p><p>​        4）函数体： 函数是怎么实现的？结构如何，从这里看</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">returnType funcName(typePackage parameters)&#123;        &#x2F;&#x2F; do things here    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        比如说，我们对一个vector里的元素寻求最大值</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long findMax(vector&lt;int&gt; vec)&#123;long curMax &#x3D; vec[0];    for(auto i &#x3D; vec.begin(); i !&#x3D; vec.end(); i++)&#123;                if(*i &gt; curMax)&#123;            curMax &#x3D; *i;        &#125;            &#125;    return curMax;&#x2F;&#x2F; return the val back in here.&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们就这样把函数抽象做子程序了！在这些子程序中，一个重要的issue就是异常处理，这里是一个简单的demo</p><p>​        我们来看这个函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long getElemFromVector(vector&lt;int&gt; vector, int pos)&#123;if(pos &lt; 0 || pos &gt; vector.size())&#123;                exit( -1 );            &#125;        return vector[pos];    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        很显然这是一个返回第pos位置上的元素的函数。那哪里是异常处理被？就是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(pos &lt; 0 || pos &gt; vector.size())&#123;                exit( -1 );&#x2F;&#x2F; should include the &lt;cstdlib&gt; to use the functions        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="传参方法：passByReference"><a href="#传参方法：passByReference" class="headerlink" title="传参方法：passByReference"></a>传参方法：passByReference</h2><p>​        先别说！看一个这个玩意：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void swapInt(int a, int b)&#123;int temp &#x3D; b    b &#x3D; a;    a &#x3D; temp;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        函数可以成功交换两数嘛，答案是否定的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;   int a &#x3D; 10;   int b &#x3D;20;   swap(a,b);       cout &lt;&lt; a &lt;&lt;&quot; &quot; &lt;&lt; b;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt;&gt; a.out&gt;&gt; 10 20 &#x2F;&#x2F; sadly make no swap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这是因为调用函数的时候，只是把a,b的拷贝传入到函数的内部而不是他们本身，这样就意味着非常坏的事情：做无用功，玩弄形参而已，现在我们使用 reference 这个C++概念 。实际上，当我们使用引用的时候就意味着我们是传入它的地址：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; new type of codingvoid swap(int&amp; a, int&amp; b)&#123;        int temp &#x3D; a;    a &#x3D; b;    b &#x3D; temp;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们为什么传参传引用呢？原因是简单的：对于值传递，编译器必须复制传入对象，有时，这样的工作被证明是复杂耗时的。并不利于我们的程序性能的提升。其次，使用引用传递使的函数的作用可以有效地反馈至程序！当然，那为什么不用指针呢？区别在于，可以简单的理解为引用是特殊的常指针。而且在写法上更为简便。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>​        我们下面要说的是作用域的问题。我们为什么函数结束后一些临时变量会被销毁？就是因为我们的变量到达了他们的生命周期而被释放。一个变量的生命周期正是从他被创造开始到他被释放的实践间隔。这就是为什么传回函数临时变量的地址是非法的。因为我们拿到的是已经还给操作系统的内存——换而言之，我们在非法访问！于是，如果我们真的想返回函数的什么东西，应当使用值返回（return by val），这是因为函数此时返回了变量的副本。抑或是选择在内存中开辟！也就是说：在堆上开辟数据，他们会存留到程序结束为止，抑或是选择程序员自动释放。</p><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><p>​        一个big issue! 我们需要在堆上放置数据，就很有必要使用操作符 new.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Type* pobj &#x3D; new Type(Initial Val)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int* pInt &#x3D; new int(1024);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        使用delete来删除我们在堆上开辟的内存！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">delete pobj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果我们开辟的是一个数组，那就记得：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">delete[] pArray<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="提供默认的参数值"><a href="#提供默认的参数值" class="headerlink" title="提供默认的参数值"></a>提供默认的参数值</h2><p>​        我们有时候一些函数的参数总是使用一个默认的值，只在另一个时候才会使用别的值，那我们可不可以使用默认的值来减轻我们的开发负担呢？答案是可以的。</p><p>​        现在我们来考虑使用冒泡排序，在默认的情况下我们是要向控制台输出。但是有时候还是会向其他地方输出。怎么办？如何有效的设计这个函数？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void bubbleSort(vector&lt;int&gt; &amp;vec, ofstream *ofil &#x3D; 0)&#123;    for(int i &#x3D; 0; i &lt; vec.size(); i++)&#123;                for(int j &#x3D; i+1 ; j &lt; vec.size(); j++)&#123;            if(vec[i] &gt; vec[j])&#123;                                if(ofil !&#x3D; 0)&#123;                    (*ofil)&lt;&lt; &quot;About to call the debug&quot;;                &#125;                swap(vec[i],vec[j],ofil);            &#125;                    &#125;            &#125;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到我们为了提供默认使之给ofil对象使用的是指针传递。这是因为我们如果是使用的引用传递，就意味着我们无法置0. 不太好设置初始值！</p><p>​        关于默认值，值得注意的是有两个基本的注意点：首先是默认值必须放在最右边，不可以插入中间指定默认值而后面不指定</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a(int a &#x3D; 5, int b);&#x2F;&#x2F; invalid!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意还有，必须只能指定一次默认值！不可以指定两次！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a(int a, int b &#x3D; 2);int a(int a, int b &#x3D; 3);&#x2F;&#x2F;编译器不知道调用哪一个！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="使用局部静态变量"><a href="#使用局部静态变量" class="headerlink" title="使用局部静态变量"></a>使用局部静态变量</h2><p>​        一些常用的东西，可以存在静态区，我们使用的是static关键字完成这项工作的！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int someFunc(...)&#123;static int a &#x3D; 10;&#x2F;&#x2F;当这里被定义了过后。。。下一次再次调用直接取先前被创造出的地方a++;&#x2F;&#x2F;第一次调11 第二次调用12.。。以此类推&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="可以考虑inline"><a href="#可以考虑inline" class="headerlink" title="可以考虑inline"></a>可以考虑inline</h2><p>​        对于一些频繁调用的函数，我们加上inline声明。编译器调用的时候选择在调用点处用一份函数代码副本代替。也就是说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int f1()&#123;        ...        f2();        ...            f3();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，本来是编译器要跳转三次到其他函数，现在加上inline声明，f2,f3的代码直接移动到f1内部，编译器之跳转到f1工作完毕再跳出！我们由此获得了性能提升。</p><p>​        但是这只是一种请求，编译器会根据自己运行的情况进行判断！一般而言，我们倾向于选择体积小，常被调用和从事工作不复杂的函数加上inline。</p><h2 id="提供重载函数"><a href="#提供重载函数" class="headerlink" title="提供重载函数"></a>提供重载函数</h2><p>​        有时候，我们的函数只是因为工作相同，但是参数不同而不得不命名不同的函数。这不方便我们的工作！于是我们选择使用重载函数来完成我们的操作</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void display(string a);void display(int a);&#x2F;&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        注意到参数类型要不同！</p><h2 id="定义并使用模板"><a href="#定义并使用模板" class="headerlink" title="定义并使用模板"></a>定义并使用模板</h2><p>​        但是重载函数面对太多不同的类型，也不能写那么多重载函数，怎么办呢？使用模板就好了！</p><p>​        模板的格式定义是： template&lt; typename name&gt;</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename nameType&gt;void display(nameType msg);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>      当我们传一个string的时候，编译器把这里解释成string，如果传入一个int 就是int。</code></pre><h2 id="使用头文件"><a href="#使用头文件" class="headerlink" title="使用头文件"></a>使用头文件</h2><p>​        我们可以分离 声明——实现这个抽象工作，只需要我们把声明放到头文件就可以了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;#include&quot;MyFile.h&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        简单来讲，&lt;&gt; 和“”的区别在于。 尖括号包下的文件被认为是标准的或者是项目专属的文件，编译器回去默认磁盘项目里去找，而“”被认为是用户头文件，编译器从当下的文件目录开始找！</p><h2 id="泛型编程风格"><a href="#泛型编程风格" class="headerlink" title="泛型编程风格"></a>泛型编程风格</h2><p>​        STL,就是泛型编程的良好体现,它由两个基本组件组成.1是容器, 2是泛型算法.</p><h3 id="从指针运算讲起"><a href="#从指针运算讲起" class="headerlink" title="从指针运算讲起"></a>从指针运算讲起</h3><p>​        我们现在考虑从一个容器里找到一个元素,  比如说在一个vector容器中找到我们想要的整数: int. 算法是轻而易举就可以写出来的:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int* find(const vector&lt;int&gt; &amp;r_vec,int&amp; val)&#123;for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;                if(vec[i] &#x3D;&#x3D; value)&#123;            return &amp;vec[i];        &#125;            &#125;return nullptr;&#x2F;&#x2F; same as NULL in C &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果,我们的容器时任何什么东西又该怎么办呢?</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename elem&gt;&#x3D;elem* find(const vector&lt;elem&gt;&amp; r_vec, elem&amp; val)&#123;for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;                if(vec[i] &#x3D;&#x3D; value)&#123;&#x2F;&#x2F; 当然要求elem存在 equal 方法或者是重载了 &#x3D;&#x3D;            return &amp;vec[i];        &#125;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是,貌似若我们不是在vector里找,而是list里找,那又该怎么办呢. 我们没办法对list找下标的(list 是离散容器)</p><h2 id="采用纯指针访问"><a href="#采用纯指针访问" class="headerlink" title="采用纯指针访问"></a>采用纯指针访问</h2><p>​        anyway, 我们想一下啊: 本质上[]就是一个语法糖,对于一个连续容器的, 本质上讲:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">array[i]  &lt;----------&gt; (array+i)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样就启发我们这样书写当传入类型是array类型的时候(经典数组)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">elem* find(elem* begin,int elemSize,elem&amp; befoundElem)&#123;if(begin &amp;&amp; elemSize &lt; 0)&#123;        return nullptr;    &#125;        for(int i &#x3D; 0; i &lt; size; i++,begin++)&#123;        if(*begin &#x3D;&#x3D; beFoundElem)&#123;                        return begin;                    &#125;    &#125;return nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        嗯,但是传入要访问多少个,不如试试全部传入指针?</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">elem* find(elem* begin,elem* end,elem&amp; befoundElem)&#123;if(begin &amp;&amp; elemSize &lt; 0)&#123;        return nullptr;    &#125;        for(; begin !- end; i++,begin++)&#123;        if(*begin &#x3D;&#x3D; beFoundElem)&#123;                        return begin;                    &#125;    &#125;return nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们发现,我们无意的抽象出来一个对象, 什么意思?我们抽象出来一个指针类型,使之可以有 ++ — * -&gt;等若干行为,我们的容器只需要提供begin 和 end就可以使用最广泛的泛型算法!这就是 iterator迭代器的来源!</p><h2 id="泛型指针-迭代器"><a href="#泛型指针-迭代器" class="headerlink" title="泛型指针:迭代器"></a>泛型指针:迭代器</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;string&gt; :: iterator IT &#x3D; svec.begin()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        就是一个指针指向了begin!如果我们希望是一个常指针帮助我们做事情,那使用const_iterator会好很多!</p><p>​        为了可以让iterator正常工作,有必要指出与实现:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1 -&gt; equlity( &#x3D;&#x3D; ) and inequlity ( !&#x3D; )2 -&gt; assignment(&#x3D; 赋值)3. empty(空)4. size(衡量元素大小)5.clear()删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化一个容器的基本五大接口"><a href="#初始化一个容器的基本五大接口" class="headerlink" title="初始化一个容器的基本五大接口"></a>初始化一个容器的基本五大接口</h2><ol><li>初始化默认的空容器</li><li>产生特定的容器,并且所有的成员都要有默认的初始值</li><li>产生特定大小的容器,并为之赋初始值</li><li>通过iterator给与值</li><li>复制构造</li></ol><h2 id="泛型编程风格-1"><a href="#泛型编程风格-1" class="headerlink" title="泛型编程风格"></a>泛型编程风格</h2><p>​        STL,就是泛型编程的良好体现,它由两个基本组件组成.1是容器, 2是泛型算法.</p><h3 id="从指针运算讲起-1"><a href="#从指针运算讲起-1" class="headerlink" title="从指针运算讲起"></a>从指针运算讲起</h3><p>​        我们现在考虑从一个容器里找到一个元素,  比如说在一个vector容器中找到我们想要的整数: int. 算法是轻而易举就可以写出来的:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int* find(const vector&lt;int&gt; &amp;r_vec,int&amp; val)&#123;for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;                if(vec[i] &#x3D;&#x3D; value)&#123;            return &amp;vec[i];        &#125;            &#125;return nullptr;&#x2F;&#x2F; same as NULL in C &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果,我们的容器时任何什么东西又该怎么办呢?</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename elem&gt;&#x3D;elem* find(const vector&lt;elem&gt;&amp; r_vec, elem&amp; val)&#123;for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;                if(vec[i] &#x3D;&#x3D; value)&#123;&#x2F;&#x2F; 当然要求elem存在 equal 方法或者是重载了 &#x3D;&#x3D;            return &amp;vec[i];        &#125;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是,貌似若我们不是在vector里找,而是list里找,那又该怎么办呢. 我们没办法对list找下标的(list 是离散容器)</p><h2 id="采用纯指针访问-1"><a href="#采用纯指针访问-1" class="headerlink" title="采用纯指针访问"></a>采用纯指针访问</h2><p>​        anyway, 我们想一下啊: 本质上[]就是一个语法糖,对于一个连续容器的, 本质上讲:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">array[i]  &lt;----------&gt; (array+i)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样就启发我们这样书写当传入类型是array类型的时候(经典数组)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">elem* find(elem* begin,int elemSize,elem&amp; befoundElem)&#123;if(begin &amp;&amp; elemSize &lt; 0)&#123;        return nullptr;    &#125;        for(int i &#x3D; 0; i &lt; size; i++,begin++)&#123;        if(*begin &#x3D;&#x3D; beFoundElem)&#123;                        return begin;                    &#125;    &#125;return nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        嗯,但是传入要访问多少个,不如试试全部传入指针?</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">elem* find(elem* begin,elem* end,elem&amp; befoundElem)&#123;if(begin &amp;&amp; elemSize &lt; 0)&#123;        return nullptr;    &#125;        for(; begin !- end; i++,begin++)&#123;        if(*begin &#x3D;&#x3D; beFoundElem)&#123;                        return begin;                    &#125;    &#125;return nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们发现,我们无意的抽象出来一个对象, 什么意思?我们抽象出来一个指针类型,使之可以有 ++ — * -&gt;等若干行为,我们的容器只需要提供begin 和 end就可以使用最广泛的泛型算法!这就是 iterator迭代器的来源!</p><h2 id="泛型指针-迭代器-1"><a href="#泛型指针-迭代器-1" class="headerlink" title="泛型指针:迭代器"></a>泛型指针:迭代器</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;string&gt; :: iterator IT &#x3D; svec.begin()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        就是一个指针指向了begin!如果我们希望是一个常指针帮助我们做事情,那使用const_iterator会好很多!</p><p>​        为了可以让iterator正常工作,有必要指出与实现:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1 -&gt; equlity( &#x3D;&#x3D; ) and inequlity ( !&#x3D; )2 -&gt; assignment(&#x3D; 赋值)3. empty(空)4. size(衡量元素大小)5.clear()删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化一个容器的基本五大接口-1"><a href="#初始化一个容器的基本五大接口-1" class="headerlink" title="初始化一个容器的基本五大接口"></a>初始化一个容器的基本五大接口</h2><ol><li>初始化默认的空容器</li><li>产生特定的容器,并且所有的成员都要有默认的初始值</li><li>产生特定大小的容器,并为之赋初始值</li><li>通过iterator给与值</li><li>复制构造</li></ol><h2 id="基于对象的编程风格"><a href="#基于对象的编程风格" class="headerlink" title="基于对象的编程风格"></a>基于对象的编程风格</h2><p>​        我们在先前已经体验过class了，就像vector一样。</p><p>​        首先，我们知道：类必须要声明！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;string&gt;string pooh[4] &#x3D;&#123;&quot;winnie&quot;,    &quot;robin&quot;,    &quot;eeyole&quot;,    &quot;piglet&quot;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        class 名称将会被视作类型（type）名称，就像内置类型int, double一样。 class object的初始化做法有很多种！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;vector&gt;string path(&quot;dummy&quot;);vector&lt;string&gt; svc1(4);vector&lt;string&gt; svc2(4,&quot;dummy&quot;);vector&lt;string&gt; svc3(pooh,pooh+4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        每个class都会提供一组操作数，让我们可以作用之在object.比如说，我们提供函数func(), </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class sth;sth Sth;Sth.func(obj object)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        一般的, class有三个部分组成，我更愿意说：class里的成员是分为三个类别的：private的，protected的，和 public 的。Public区域下的成员和对象都是对外开放。Private则只能在类内访问！举个例子：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class aClass&#123;public:int pub_Val; &#x2F;&#x2F; can be used in public space    int* returnAIntVal();&#123;        return new int(10); &#x2F;&#x2F; can be used in public space    &#125;int returnPri_Val()&#123;        return pri_Val; &#x2F;&#x2F; valid    &#125;;private:    int pri_Val;     int* returnSomethong();&#123;        return new int(11);    &#125;&#125;int main()&#123;        aClass sth;    int a &#x3D; sth.pub_Val; &#x2F;&#x2F; valid     int* pa &#x3D; sth.returnPri_Val();&#x2F;&#x2F; valid     int priAVal &#x3D; sth.rereturnPri_Val();        &#x2F;&#x2F; Also valid! This is the Interface of private.             &#x2F;&#x2F; followings are invalid        int wrongA &#x3D; sth.pri_Val; &#x2F;&#x2F; Invalid!!! cannot visit private    int* wrongB &#x3D; sth.returnSomethong();&#x2F;&#x2F; Invalid!!! cannot visit private &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现一个Class"><a href="#实现一个Class" class="headerlink" title="实现一个Class"></a>实现一个Class</h3><p>​        我们的main topic 在使用C++手写一个stack！关键在于怎么写</p><p><img src="image-20230506140557771.png" alt="image-20230506140557771"></p><p>​        这是一个声明！</p><p><img src="image-20230506140519165.png" alt="image-20230506140519165"></p><p>​        这是一个Stack的标准声明与定义。</p><p>​        下面，编写接口：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class Stack &#123;public:bool push(const string&amp; pString);bool pop(string&amp; pString);bool peek(string&amp; pString);bool isEmpty();bool isFull();int size() &#123; return _stack.size(); &#125;;private:vector&lt;string&gt; _stack;&#125;;void fill_stack(Stack&amp; stack, istream&amp; is &#x3D; cin) &#123;string str;while (is &gt;&gt; str &amp;&amp; !stack.isFull()) &#123;stack.push(str);&#125;cout &lt;&lt; &quot;Read in&quot; &lt;&lt; stack.size() &lt;&lt; &quot;elements\n&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是接口没有实现！那怎么办！</p><p>​        我们是这样书写类内的成员函数的：只需要声明这是哪个类的函数。。。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool Stack::pop(string&amp; elem) &#123;if (empty()) &#123;return false;&#125;elem &#x3D; _stack.back();_stack.pop_back();return true;&#125;inline bool Stack::empty() &#123;return this-&gt;_stack.empty();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        类和其成员函数的定义和实现是，应当放在头文件里去。</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>​        我们先不说的这样抽象！转向直接阐述：构造函数是一种初始化函数，同</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a &#x3D; new int;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        是一回事。但是由于我们的类是若干基础变量组合产生。有必要使用函数来包装！比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Tri&#123;private:m_Val1;m_Val2;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Tri::Tri()&#123;        m_Val1 &#x3D; 10;    m_Val2 &#x3D; 20;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的函数就是一个构造函数，我们初始化了类内的变量！</p><p>​        构造函数是可以重载的！我们可以重载构造函数，使之给用户提供不同的初始化方式。</p><pre class="line-numbers language-none"><code class="language-none">Tri::Tri(int mVal1, int mVal2)&#123;        m_Val1 &#x3D; mVal1;    m_Val2 &#x3D; mVal2;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>​        我们对于一些变量可以使之直接在表内初始化</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Tri::Tri(int mVal1, int mVal2): m_Val1(mVal1),m_Val2(mVal2)&#123;    &#x2F;&#x2F; ... other things    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们会在程序的结尾调用析构器。事实上，在上面的函数中没有必须调用析构器！因为对象都是简单对象，直接释放即可。这就说明一件事情：对于简单的类和简单的尚未在堆上开辟内存的类，可以直接调用析构器从而实现内存释放</p><h2 id="逐一初始化的"><a href="#逐一初始化的" class="headerlink" title="逐一初始化的"></a>逐一初始化的</h2><p>​        下面想要说的是浅拷贝的知识点：这是在我们使用等号赋值的一种较为常见的错误</p><p>​        对于一些简单的类，那些成员不在堆上的类，我们当然可以选择浅拷贝来解决问题：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Easy&#123;        public: anSample(int val1, int val2);       int m_Val1;    int m_Val2;        &#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的行为被称为浅拷贝：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Easy anSample(1, 2);&#x2F;&#x2F; call the anSample(int,int)Easy aCopy &#x3D; anSample;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        本质上，我们实际上调用了这样一个被编译器隐藏起来的函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Easy&amp; operator&#x3D;(Easy&amp; beCopied)&#123;        this-&gt;m_Val1 &#x3D; beCopied-&gt;m_Val1;    this-&gt;m_Val2 &#x3D; beCopied-&gt;m_Val2;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那也就意味着，假使我们这样操作：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Diff&#123;    public:    diff(int val)&#123;                this-&gt;m_Val1 &#x3D; val;                this-&gt;m_inHeapArray &#x3D; new int[10];    &#125;                int m_Val1;        int* m_inHeapArray;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        而这样的话，就意味着我们在赋值的时候</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Diff dif(10);Diff copy &#x3D; dif;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        调用的是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Easy&amp; operator&#x3D;(Easy&amp; beCopied)&#123;        this-&gt;m_Val1 &#x3D; beCopied-&gt;m_Val1;    this-&gt;m_inHeapArray &#x3D; beCopied-&gt;m_inHeapArray;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这分明是开了两个指针指向同一块内存，这就意味着，只需要我们的被拷贝对象或者是拷贝对象被调用了正确的（就是说我们的程序员正确的释放了内存）析构函数，那么，当程序结束或者是准备析构另一个对象的时候，我们就会拿起来它，释放（危险行为），但是先前这块地方已经被释放过了！坏了，这下寄了，程序就会崩溃！</p><p>​        解决办法是：自己老老实实重写，比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Diff&amp; operator&#x3D;(Diff&amp; beCopied)&#123;        this-&gt;m_Val1 &#x3D; beCopied-&gt;m_Val1;        this-&gt;m_inHeapArray &#x3D; new int[10];        memcpy(this-&gt;m_inHeapArray,beCopied-&gt;m_inHeapArray,10*sizeof(int));        return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TIPS：小心坑"><a href="#TIPS：小心坑" class="headerlink" title="TIPS：小心坑"></a>TIPS：小心坑</h2><p>​        由于引用的出现，我们赋值方式很多，但是这样的等号赋值，编译器调用哪一个呢？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Diff copy &#x3D; sample; &#x2F;&#x2F; 调用了默认的还是自己重载的？&#x2F;&#x2F;Diff copy2;copy2 &#x3D; sample; &#x2F;&#x2F; sample is already inited<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        答案是，上面的调用的是默认的拷贝构造函数（构！造！），下面调用的是自己手动重载的函数。这是等号赋值函数。这是我们需要注意的！！！</p><p>​        下面供一个小小的DEMO给大伙看看：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;cstdlib&gt;class Diff &#123;public:Diff();Diff(int val);~Diff();Diff&amp; operator&#x3D;(Diff&amp; dif);void showDetail()const;private:int m_Val;int* m_inHeap;&#125;;Diff::Diff() &#123;this-&gt;m_Val &#x3D; 0;this-&gt;m_inHeap &#x3D; NULL;&#125;Diff::Diff(int val) &#123;this-&gt;m_Val &#x3D; val;this-&gt;m_inHeap &#x3D; new int[10];&#125;Diff::~Diff() &#123;delete[] this-&gt;m_inHeap;std::cout &lt;&lt; &quot;Finished calling the destructor!&quot; &lt;&lt; &#39;\n&#39;;&#125;Diff&amp; Diff::operator&#x3D;(Diff&amp; dif) &#123;this-&gt;m_Val &#x3D; dif.m_Val;this-&gt;m_inHeap &#x3D; new int[10];memcpy(this-&gt;m_inHeap, dif.m_inHeap, 10 * sizeof(int));return *this;&#125;void Diff::showDetail()const &#123;std::cout &lt;&lt; &quot;the Val &gt;&quot; &lt;&lt; this-&gt;m_Val &lt;&lt; &quot;   &quot; \&lt;&lt; &quot; the addr name :&gt;&quot; &lt;&lt; this-&gt;m_inHeap &lt;&lt; &quot;   &quot; &lt;&lt; std::endl;&#125;int main() &#123;Diff sample(10);Diff copy;copy &#x3D; sample;copy.showDetail();sample.showDetail();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="mutable-和-const"><a href="#mutable-和-const" class="headerlink" title="mutable 和 const"></a>mutable 和 const</h2><p>​        查阅你的英文字典，哈哈一笑，一个是可变的，一个不是可变。</p><p>​        我们来看一个Demo函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;class wrapArray &#123;public:wrapArray();wrapArray(size_t size);inline size_t getSize() const &#123; return this-&gt;arrSize; &#125;;inline int* getAddr(int* emptySpace &#x3D; nullptr)const &#123; int* space &#x3D; new int[arrSize]; memcpy(space, this-&gt;arr, sizeof(int) * arrSize); return space; &#125;;void simpleInitArr();long addSum()const;private:int* arr;size_t arrSize;&#125;;wrapArray::wrapArray() &#123;this-&gt;arrSize &#x3D; 0;this-&gt;arr &#x3D; nullptr;&#125;wrapArray::wrapArray(size_t size) &#123;this-&gt;arrSize &#x3D; size;this-&gt;arr &#x3D; new int[size];&#125;void wrapArray::simpleInitArr() &#123;for (int i &#x3D; 0; i &lt; this-&gt;arrSize; i++) &#123;this-&gt;arr[i] &#x3D; i;&#125;return;&#125;long wrapArray::addSum()const &#123;long sum &#x3D; 0;int* arr &#x3D; getAddr();for (auto i &#x3D; 0; i &lt; getSize(); i++) &#123;sum +&#x3D; arr[i];&#125;return sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <strong>类</strong>的成员函数后面加 const，表明这个函数不会对这个类对象的 数据成员（准确地说是非静态数据成员）作任何改变 。 在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。</p><p>​        可以看到上面的函数就是这样做的！</p><p>​        但是注意到！一些函数虽然是 const 的，向编译器承诺不会改变成员的值的。但是他们有可能返回一个 non-const接口，对于那些拿起这些接口的对象，他们是<strong>可以</strong>改变对象的值的！这是十分不好的！最好的办法是设计一个non-const类型从而分别处理比较好</p><p>​        那mutable呢？他们用在这样希望其他不变而就这个改变的变量上，比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;class Person &#123;public:    Person();    ~Person();    int getAge() const; &#x2F;*调用方法*&#x2F;    int getCallingTimes() const; &#x2F;*获取上面的getAge()方法被调用了多少次*&#x2F;private:    int age;    char* name;    float score;    mutable int m_nums;            &#x2F;*用于统计次数*&#x2F;&#125;;Person::Person()&#123;    m_nums &#x3D; 0;&#125;Person::~Person() &#123;&#125;int Person::getAge() const&#123;    std::cout &lt;&lt; &quot;Calling the method&quot; &lt;&lt; std::endl;    m_nums++; &#x2F;&#x2F; 你看这个就突破了const 的修饰    &#x2F;&#x2F;age &#x3D; 4; 仍然无法修改该成员变量    return age;&#125;int Person::getCallingTimes()const&#123;    return m_nums;&#125;int main()&#123;    Person* person &#x3D; new Person();    for (int i &#x3D; 0; i &lt; 10; i++) &#123;        person-&gt;getAge();    &#125;    std::cout &lt;&lt; &quot;getAge()方法被调用了&quot; &lt;&lt; person-&gt;getCallingTimes() &lt;&lt; &quot;次&quot; &lt;&lt; std::endl;    delete person;    getchar();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>​        什么是this指针？其实，它就相当于一个self!也就是说指向他自己的一个指针！</p><p>​        by the way, 针对拷贝构造函数的时候注意一定要查看这两个对象是不是一致的。这是一个好习惯。</p><h2 id="静态类成员与函数"><a href="#静态类成员与函数" class="headerlink" title="静态类成员与函数"></a>静态类成员与函数</h2><p>​        什么是静态类的呢?我们回想一下静态类变量：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static int times &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        一回事情！而且，static变量可以定义在类的外面：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class isSomeThing&#123;    &#x2F;&#x2F;...    inline static getAStaticVal()&#123;return aStaticVal;&#125;&#125;int isSomeThing:: aStaticVal &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        值得注意的是：静态成员函数是只可以访问静态变量成员的，为什么呢？</p><p>​        在类中，static 除了可以声明静态成员变量，还可以声明静态成员函数。普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。</p><p>​        编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。</p><p>​        普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。</p><p>​        普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。</p><p>​        静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</p><h2 id="面对对象的编程风格"><a href="#面对对象的编程风格" class="headerlink" title="面对对象的编程风格"></a>面对对象的编程风格</h2><p>​        我们面对对象的程序语言风格的主要两大特质是：继承和多态。前者让一群相关的类组织起来，使之可以共享共同的数据和操作行为，后者让我们在这些类上进行编程时，像是在操纵一个单一的个体，赋予我们更多的弹性加入或者移除任何特定的类。</p><p>​        继承产生了父类和子类的说法，父类定义了子类的共同之处和私有实现，而每一个子类都可以增加或者覆盖继承而来的东西，从而实现自身独特的行为。举个例子： AudioBook 从更大的父类 BOOK 继承了作者和标题之外，还有脸属于自己的播讲者和其他东西。</p><p>​        父类在C++中还有基类之称， 而子类则是作为派生类出现的。我们可以绘制一幅图来展示类之间的层级关系，如图所示：</p><p><img src="1.jpg" alt="1"></p><p>​        那啥是多态呢：来看一个程序：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void general_check_in(LibMat&amp; mat)&#123;    &#x2F;&#x2F; 但是我们不会传入一个基类 libmat，而是传入一个具体的派生类，如Magazines,AudioBook, Book这类的    mat.check_in();        if(mat.is_late())&#123;        mat.assess_fine();    &#125;    if(mat.waitinglist())&#123;        mat.notify_available();    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        demo:&gt;</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class LibMat &#123;public:virtual void isCheckIn() &#123; cout &lt;&lt; &quot;is a LibMat\n&quot;; &#125;;&#125;;class Book : public LibMat &#123;public:void isCheckIn() &#123; cout &lt;&lt; &quot;is a Book\n&quot;; &#125;&#125;;class Magazine :public LibMat &#123;public:void isCheckIn() &#123; cout &lt;&lt; &quot;is a magazine\n&quot;; &#125;&#125;;void isChecked(LibMat&amp; Mat) &#123;Mat.isCheckIn();&#125;int main() &#123;&#x2F;&#x2F; 继承LibMat libmat;libmat.isCheckIn();Book book;book.isCheckIn();Magazine mag;mag.isCheckIn();&#x2F;&#x2F; 多态isChecked(book);isChecked(mag);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的程序很有意思，我们的Interface分明要求的是LibMat，但是我们传入的是它的若干子类，程序却能正确的运行！只是因为编译器在运行时候确定具体应该调啥函数，而不是在编写程序时才指定！</p><h2 id="面向对象的编程运作流程"><a href="#面向对象的编程运作流程" class="headerlink" title="面向对象的编程运作流程"></a>面向对象的编程运作流程</h2><p>​        上面的例子太过简单，我们复杂一点：为了持续的跟踪个对象的构造，调用和析构，我们给个行为塞上向控制台打印Debug信息的语句</p><p>​        virtual这个关键字表明当下的被修饰函数时虚函数，可以被子类改写：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class LibMat:&#123;public:        LibMat()&#123;cout&lt;&lt;&quot; calling for the libmat constructor&quot;;&#125;    virtual ~LibMat()&#123;cout&lt;&lt;&quot; calling for the LibMat destructor&quot;;&#125;        virtual void printInfo const&#123; cout &lt;&lt;&quot;LibMat!&quot;;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是一个类，我们跟踪一下这个对象的流程：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;class LibMat&#123;public:    LibMat() &#123; cout &lt;&lt; &quot; calling for the libmat constructor\n&quot;; &#125;    virtual ~LibMat() &#123; cout &lt;&lt; &quot; calling for the LibMat destructor\n&quot;; &#125;    virtual void printInfo() const&#123; cout &lt;&lt; &quot;[printInfo] LibMat!\n&quot;; &#125;&#125;;void callPrint(LibMat&amp; aLib) &#123;    cout &lt;&lt; &quot;Call relevant functions\n&quot;;    aLib.printInfo();&#125;int main()&#123;    LibMat lib;    callPrint(lib);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230510091108469.png" alt="image-20230510091108469"></p><p>​        下面呢，我们派生一个类。叫Book（先前似乎用过，但是这里改变层级关系）。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;&#x2F;&#x2F; 这是基类class LibMat&#123;public:    LibMat() &#123; cout &lt;&lt; &quot; calling for the libmat constructor\n&quot;; &#125;    virtual ~LibMat() &#123; cout &lt;&lt; &quot; calling for the LibMat destructor\n&quot;; &#125;    virtual void printInfo() const&#123; cout &lt;&lt; &quot;[printInfo] LibMat!\n&quot;; &#125;&#125;;&#x2F;&#x2F; 这是派生类class Book : public LibMat &#123;public:    Book() &#123; cout &lt;&lt; &quot; calling for the book constructor&quot;; &#125;    Book(string bookName, string authorWho) &#123;        cout &lt;&lt; &quot; calling for the book constructor&quot;;         this-&gt;authorWho &#x3D; authorWho;        this-&gt;bookName &#x3D; bookName;    &#125;    virtual ~Book() &#123; cout &lt;&lt; &quot; calling for book destructor&quot;; &#125;;    virtual void printInfo()const &#123; cout &lt;&lt; &quot;[printInfo] Book: Author  &quot;&lt;&lt;authorWho\        &lt;&lt;&quot;  and the title is:&quot;&lt;&lt;bookName&lt;&lt;endl; &#125;private:    string bookName;    string authorWho;&#125;;void callPrint(LibMat&amp; aLib) &#123;    cout &lt;&lt; &quot;Call relevant functions\n&quot;;    aLib.printInfo();&#125;int main()&#123;    Book book(&quot;A note for Essential C++&quot;, &quot;CharlieChen&quot;);    callPrint(book);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230511093009133.png" alt="image-20230511093009133"></p><p>​        这就是我们的调用结果！</p><p>​        首先我们高兴的发现：编译器自动识别了我们传入的是LibMat的一个子类 Book。从而在调用时调用了Book的Print Info。也就是说，我们在一个需要父类接口的函数处传入一个子类时，往往会调用子类重写父类的方法而隐藏其父类的方法！</p><p>​        其二，我们留意到，程序中我们并没有显示的构造父类，或者说是基类，但是运行程序的时候依旧调用了父类的构造函数！</p><p>​        我们不止步于此，继续派生Book类！我们的书本种类繁多，不如整一个AudioBook,他派生于Book，但是还多出来narrator！也就是播讲者。那就是说：我们的私有成员在其自己的直接父类中又多了narrator!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;&#x2F;&#x2F; 基类class LibMat&#123;public:    LibMat() &#123; cout &lt;&lt; &quot; calling for the libmat constructor\n&quot;; &#125;    virtual ~LibMat() &#123; cout &lt;&lt; &quot; calling for the LibMat destructor\n&quot;; &#125;    virtual void printInfo() const&#123; cout &lt;&lt; &quot;[printInfo] LibMat!\n&quot;; &#125;&#125;;&#x2F;&#x2F; 直接父类class Book : public LibMat &#123;public:    Book() &#123; cout &lt;&lt; &quot; calling for the book constructor&quot;; &#125;    Book(string bookName, string authorWho) &#123;        cout &lt;&lt; &quot; calling for the book constructor\n&quot;;         this-&gt;authorWho &#x3D; authorWho;        this-&gt;bookName &#x3D; bookName;    &#125;    virtual ~Book() &#123; cout &lt;&lt; &quot; calling for book destructor\n&quot;; &#125;;    virtual void printInfo()const &#123; cout &lt;&lt; &quot;[printInfo] Book: Author  &quot;&lt;&lt;authorWho\        &lt;&lt;&quot;  and the title is:&quot;&lt;&lt;bookName&lt;&lt;endl; &#125;protected:    string bookName;    string authorWho;&#125;;&#x2F;&#x2F;子类class AudioBook : public Book &#123;public:    AudioBook(const string&amp; title, const string&amp; author, \        const string&amp; narrator) :Book(title, author), narrator(narrator) &#123;        cout &lt;&lt; &quot;calling for the audiobook construtor:\n&quot;;    &#125;    virtual void printInfo()const &#123;        cout &lt;&lt; &quot;[printInfo] AudioBook: Author &quot; &lt;&lt; authorWho &lt;&lt; \            &quot; bookName  &quot; &lt;&lt; bookName &lt;&lt; &quot;  narrator :&quot; &lt;&lt; narrator &lt;&lt; endl;    &#125;protected:    string narrator;&#125;;void callPrint(LibMat&amp; aLib) &#123;    cout &lt;&lt; &quot;Call relevant functions\n&quot;;    aLib.printInfo();&#125;int main()&#123;    AudioBook audioBook(&quot;A note for Essential C++&quot;, &quot;CharlieChen&quot;,&quot;Charliechen&quot;);    callPrint(audioBook);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            对于那些希望可以直接访问继承来的父类私有成员，有必要声明之为protected 的。而那些希望自己独有而不被其他甚至是自己子类访问，则声明之private！正如上面所示的那样！</p><h2 id="定义一个抽象的基类"><a href="#定义一个抽象的基类" class="headerlink" title="定义一个抽象的基类"></a>定义一个抽象的基类</h2><p>​        对于我们想要设计的若干类，不如找出他们的共同点，设计出来一个只有共同的成员和行为的——基类！现在，我们拿一个——叫做num  sequence 的基类来抽象出所有的数列的共同点！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class num_sequence &#123;public:&#x2F;*getElembyPos( pos ) offering a returned value by giving posgenerate_elem( pos ) create a subSequence that locates [0, pos]arrayType() return type of the arrayprint( os ) written all elements into ostreamcheck_integrity( pos ) whether the pos is validmax_pos() return the max position*&#x2F;int getElembyPos(int pos);void generate_elem(int pos);string arrayType();void print(ostream&amp; os);bool check_integrity(int pos);static int  max_pos();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        随后，指定哪些行为，是子类可能需要重写的！我们把它抽象成virtual的虚函数！表明他们可以被子类重写！</p><p>​        下一步，指定哪些成员我们希望子类继承并直接可以访问！</p><p>​        我们把两步整合一下，再次修理：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class num_sequence &#123;public:&#x2F;*getElembyPos( pos ) offering a returned value by giving posgenerate_elem( pos ) create a subSequence that locates [0, pos]arrayType() return type of the arrayprint( os ) written all elements into ostreamcheck_integrity( pos ) whether the pos is validmax_pos() return the max position*&#x2F;virtual ~num_sequence() &#123;&#125;; &#x2F;&#x2F; diffrent type of sequence has different waysvirtual int getElembyPos(int pos) &#x3D; 0; &#x2F;&#x2F; absolute virtual, contemporily need to overwrite!virtual string arrayType() const &#x3D; 0;virtual ostream&amp; print(ostream&amp; os) &#x3D; 0;static int max_pos() &#123; return _max_elems; &#125;;    protected:virtual void generate_elem(int pos) const &#x3D; 0;bool check_integrity(int pos) const;const static int _max_elems &#x3D; 1024;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到，如果想要程序员强制重写虚函数，可以指定之为纯虚函数：</p><pre class="line-numbers language-none"><code class="language-none">virtual type funcName(funcList) &#x3D; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        由于基类的接口不完整，编译器不允许为之产生对象！只能作为派生类的子对象使用！于是，一个拥有纯虚函数的基类<strong>没有必要，也不应该拥有构造函数</strong>，同时，不同的子类析构方式可能不一样，由此指定析构函数为virtual 的！</p><p>​        带上实现看看：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class num_sequence &#123;public:&#x2F;*getElembyPos( pos ) offering a returned value by giving posgenerate_elem( pos ) create a subSequence that locates [0, pos]arrayType() return type of the arrayprint( os ) written all elements into ostreamcheck_integrity( pos ) whether the pos is validmax_pos() return the max position*&#x2F;virtual ~num_sequence() &#123;&#125;; &#x2F;&#x2F; diffrent type of sequence has different waysvirtual int getElembyPos(int pos) &#x3D; 0; &#x2F;&#x2F; absolute virtual, contemporily need to overwrite!virtual string arrayType()const &#x3D; 0;virtual ostream&amp; print(ostream&amp; os &#x3D; cout)&#x3D; 0;static int max_pos() &#123; return _max_elems; &#125;;protected:virtual void generate_elem(int pos) &#x3D; 0;bool check_integrity(int pos, int size);const static int _max_elems &#x3D; 1024;&#125;; bool num_sequence::check_integrity(int pos,int size) &#123;if (pos &lt; 0 || pos &gt; _max_elems) &#123;cerr &lt;&lt; &quot; invalid position! request rejected!&quot;;return false;&#125;return true;&#125;ostream&amp; operator&lt;&lt; (ostream &amp; os, num_sequence&amp; ns) &#123;return ns.print(os);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义一个派生类"><a href="#定义一个派生类" class="headerlink" title="定义一个派生类"></a>定义一个派生类</h2><p>​        下面开始使用num_sequence干活！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Fib :public num_sequence &#123;public:Fib(int len &#x3D; 1, int begin_pos &#x3D; 1) :length(len), begin_pos(begin_pos) &#123;&#125;;virtual int getElembyPos(int pos);virtual ostream&amp; print(ostream&amp; os &#x3D; cout;int getlength() const&#123; return length; &#125;;int getBeginPos() const &#123; return begin_pos; &#125;;protected:virtual void generate_elem(int pos) ;int length;int begin_pos;vector&lt;int&gt; _elems;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面继续实现！</p><p>​        我们先实现一个返回指定位置的值的函数，大致看起来这样！值得注意的是我们在写实现的时候不用带上virtual！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int Fib::getElembyPos(int pos) &#123;if (!check_integrity(pos)) &#123;return 0;&#125;if (pos &gt; _elems.size()) &#123;Fib::generate_elem(pos);&#125;return _elems[pos - 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到：1. 我们使用public 继承下来的<code>check_integrity(pos)</code>可以直接使用！因为这正是protected的成员！其二，建议载函数前指定这是哪个类的！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Fib::generate_elem(int pos) &#123;if (_elems.empty()) &#123;_elems.push_back(1);_elems.push_back(1);&#x2F;&#x2F; the first two should be 1,1&#125;if (_elems.size() &lt;&#x3D; pos) &#123;int i &#x3D; _elems.size();int n2 &#x3D; _elems[i - 2];int n1 &#x3D; _elems[i - 1];for (; i &lt; pos; i++) &#123;int elem &#x3D; n1 + n2;_elems.push_back(elem);n2 &#x3D; n1;n1 &#x3D; elem;&#125;&#125;&#125;ostream&amp; Fib::print(ostream&amp; os) &#123;int elem_pos &#x3D; begin_pos - 1;int end_pos &#x3D; elem_pos + length;if (end_pos &gt; _elems.size()) &#123;Fib::generate_elem(end_pos);&#125;while (elem_pos &lt; end_pos)os &lt;&lt; _elems[elem_pos++] &lt;&lt; &quot; &quot;;return os;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            下面综合一下实现+小小的调整</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class num_sequence &#123;public:&#x2F;*getElembyPos( pos ) offering a returned value by giving posgenerate_elem( pos ) create a subSequence that locates [0, pos]arrayType() return type of the arrayprint( os ) written all elements into ostreamcheck_integrity( pos ) whether the pos is validmax_pos() return the max position*&#x2F;virtual ~num_sequence() &#123;&#125;; &#x2F;&#x2F; diffrent type of sequence has different waysvirtual int getElembyPos(int pos) &#x3D; 0; &#x2F;&#x2F; absolute virtual, contemporily need to overwrite!virtual string arrayType()const &#x3D; 0;virtual ostream&amp; print(ostream&amp; os &#x3D; cout)&#x3D; 0;static int max_pos() &#123; return _max_elems; &#125;;protected:virtual void generate_elem(int pos) &#x3D; 0;bool check_integrity(int pos, int size);const static int _max_elems &#x3D; 1024;&#125;; bool num_sequence::check_integrity(int pos,int size) &#123;if (pos &lt; 0 || pos &gt; _max_elems) &#123;cerr &lt;&lt; &quot; invalid position! request rejected!&quot;;return false;&#125;return true;&#125;ostream&amp; operator&lt;&lt; (ostream &amp; os, num_sequence&amp; ns) &#123;return ns.print(os);&#125;class Fib :public num_sequence &#123;public:Fib(int len &#x3D; 1, int begin_pos &#x3D; 1) :length(len), begin_pos(begin_pos) &#123;&#125;;virtual int getElembyPos(int pos);virtual ostream&amp; print(ostream&amp; os &#x3D; cout);int getlength() const&#123; return length; &#125;;int getBeginPos() const &#123; return begin_pos; &#125;;string arrayType()const;protected:virtual void generate_elem(int pos) ;int length;int begin_pos;vector&lt;int&gt; _elems;bool check_integrity(int pos, int size);&#125;;string Fib::arrayType() const&#123;return &quot;Fib&quot;;&#125;int Fib::getElembyPos(int pos) &#123;if (!check_integrity(pos,_elems.size())) &#123;return 0;&#125;if (pos &gt; _elems.size()) &#123;Fib::generate_elem(pos);&#125;return _elems[pos - 1];&#125;void Fib::generate_elem(int pos) &#123;if (_elems.empty()) &#123;_elems.push_back(1);_elems.push_back(1);&#x2F;&#x2F; the first two should be 1,1&#125;if (_elems.size() &lt;&#x3D; pos) &#123;int i &#x3D; _elems.size();int n2 &#x3D; _elems[i - 2];int n1 &#x3D; _elems[i - 1];for (; i &lt; pos; i++) &#123;int elem &#x3D; n1 + n2;_elems.push_back(elem);n2 &#x3D; n1;n1 &#x3D; elem;&#125;&#125;&#125;ostream&amp; Fib::print(ostream&amp; os) &#123;int elem_pos &#x3D; begin_pos - 1;int end_pos &#x3D; elem_pos + length;if (end_pos &gt; _elems.size()) &#123;Fib::generate_elem(end_pos);&#125;while (elem_pos &lt; end_pos)os &lt;&lt; _elems[elem_pos++] &lt;&lt; &quot; &quot;;return os;&#125;bool Fib::check_integrity(int pos, int size) &#123;if (pos &lt;&#x3D; 0 || pos &gt; _max_elems) &#123;cerr &lt;&lt; &quot; invalid position! request rejected!&quot;;return false;&#125;if (pos &gt; size) &#123;generate_elem(pos);&#125;return true;&#125;int main()&#123;Fib fib;cout &lt;&lt; fib&lt;&lt;endl;Fib fib2(16);cout &lt;&lt; fib2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化，析构和复制"><a href="#初始化，析构和复制" class="headerlink" title="初始化，析构和复制"></a>初始化，析构和复制</h2><p>​        我再重复一遍：对于一个派生类的构造，他总是先递归的调用父类的构造函数！最后调用自己的构造函数！如果没有指定，则父类构造调用默认构造！对于复制，也是一样的，可以重写 operator = 来实现有效的深拷贝</p><h2 id="覆盖，定义虚函数"><a href="#覆盖，定义虚函数" class="headerlink" title="覆盖，定义虚函数"></a>覆盖，定义虚函数</h2><p>​        注意到，假使我们重写虚函数，特别是纯虚函数，必须在：参数列表，返回类型，常量性等<strong>完全</strong>跟父类一致！！！</p><p>​        对于虚函数的静态解析，当（1）基类的constructor和destructor （2）调用基类对象而不是对象的pointer 或者引用！</p><p>​        也就是说，如果我们的父类构造函数调用了一个虚函数，则会调用父类自己的而不是派生类的！！！（很好理解，先有鸡还是先有蛋的问题）</p><h2 id="运行时的类型鉴定机制"><a href="#运行时的类型鉴定机制" class="headerlink" title="运行时的类型鉴定机制"></a>运行时的类型鉴定机制</h2><p>​        C++中有一个接口函数叫typeid，可以在动态运行时查看类的类型是什么！需要引用头文件#include&lt; typeinfo &gt;</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(typeid(*ps) &#x3D;&#x3D; typeid(Fib))...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab_Learning-1</title>
      <link href="/2023/06/06/Matlab-Learning-1/"/>
      <url>/2023/06/06/Matlab-Learning-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab基础学习"><a href="#Matlab基础学习" class="headerlink" title="Matlab基础学习"></a>Matlab基础学习</h1><h2 id="Guidance-Level"><a href="#Guidance-Level" class="headerlink" title="Guidance Level"></a>Guidance Level</h2><h3 id="1-matlab（2014a）的界面介绍"><a href="#1-matlab（2014a）的界面介绍" class="headerlink" title="1.matlab（2014a）的界面介绍"></a>1.matlab（2014a）的界面介绍</h3><p><img src="image-20221224193149319.png" alt="image-20221224193149319"></p><p>​        左边是Current Folders:也就是文件区，正中心是命令窗口：输入命令的地方。右上角的WorkSpace（工作区）是储存变量的地方，而右下角的Command History则是命令的历史记录。</p><p><img src="image-20221224193538040.png" alt="image-20221224193538040"></p><p>​        这是2021A版的界面，不过，默认是没有命令历史窗口，需要从布局&gt;&gt;命令历史记录&gt;&gt;勾选停靠，才可以调出历史记录。</p><h3 id="2-matlab的运算符"><a href="#2-matlab的运算符" class="headerlink" title="2.matlab的运算符"></a>2.matlab的运算符</h3><p>​        运算符有以下几种：+，-，*，/，^(这是次方)</p><p><img src="image-20221224193919840.png" alt="image-20221224193919840"></p><p>​                                                                                             （实例）</p><p>​        Precedence Rules（运算优先级规则）</p><p>​        1.在同一级上从左到右</p><p>​        2.从高到底：</p><p>​            1.括号（）</p><p>​            2.次方（^）</p><p>​            3.乘除（*，/）</p><p>​            4.加减（+，-）</p><p>下面可以做一些练习：</p><ol><li><script type="math/tex; mode=display"></script><script type="math/tex; mode=display">cos(\sqrt{\frac{(1+2+3+4)^3}5})2.</script></li></ol><p>2.</p><script type="math/tex; mode=display">sin(\sqrt{\pi})+ln(tan(1))</script><p>3.</p><script type="math/tex; mode=display">2^{3.5\times1.7}</script><p>4.</p><script type="math/tex; mode=display">e^{sin(10)}</script><p>答案：<img src="ans.png" alt="ans"></p><p>​        函数可以嵌条调用，由此，我们可以分布，减少错误</p><p>​        如：</p><p><img src="1.png" alt="1"></p><p>​        对于非常复杂的运算，下面的那个是推介的</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>​        在Matlab里面，我们不需要声明变量的类型，就可以创造一个变量（LHS=RHS）</p><p><img src="image-20221224201954977.png" alt="image-20221224201954977"></p><p>​        此时，我们的WorkSpace：</p><p><img src="image-20221224202037986.png" alt="image-20221224202037986"></p><p>​        注意：</p><p>​        （1）大小写是敏感的，A与a是不一样的</p><p>​        （2）不要以数字开头，但是可以变量里有数字</p><p>​            变量的种类：</p><p><img src="image-20221224202401689.png" alt="image-20221224202401689"></p><p>​        我们默认创造的数字类型是double(不是int!)</p><p>​        查看变量的种类的方法：</p><p>​        双击workspace变量跳出表格：其名字为1 * 1 double,或者,在命令窗口打whos:</p><p><img src="image-20221224202650334.png" alt="image-20221224202650334"></p><p>​        注意：下面是一些特殊的关键字（Keyword）：</p><p><img src="image-20221224202919711.png" alt="image-20221224202919711"></p><p>​    （iskeyword查看已有关键字）</p><p>​        这是Matlab调用的优先级：</p><p><img src="image-20221224203437595.png" alt="image-20221224203437595"></p><h3 id="标准输出调整"><a href="#标准输出调整" class="headerlink" title="标准输出调整"></a>标准输出调整</h3><p>​        Format格式有以下几种</p><p><img src="image-20221224203627494.png" alt="image-20221224203627494"></p><p><img src="image-20221224203819131.png" alt="image-20221224203819131"></p><p><img src="image-20221224203840545.png" alt="image-20221224203840545"></p><p>​        （rat让一个小数以分数形式表示）</p><p>​        a=10;打上分号让matlab不会显示这句话的运算结果。</p><p>​        回溯历史指令：按上回到之前的指令</p><p><img src="image-20221224204349793.png" alt="image-20221224204349793"></p><p>​         vector and matrix</p><p>​        向量（vector）</p><p>​        行向量（row vector）</p><p>​        格式：var=[(num num2 …) ]或者是var=[num,num2,num3,…]</p><p>​        a=[1 2 3 4] or a=[1,2,3,4]</p><p><img src="image-20221224204934420.png" alt="image-20221224204934420"></p><p>​        列向量（column vector）</p><p>​        var=[num1;num2;num3;…]</p><p>​        a=[1;2;3;4]</p><p><img src="image-20221224205359229.png" alt="image-20221224205359229"></p><p>​        当然：a<em>b与b</em>a显然是不太一样的</p><p><img src="image-20221224205457245.png" alt="image-20221224205457245"></p><p>​        输入一个矩阵是这样的：</p><p>​        matrix=[num11,num12,num13…(Row1);num21,num22,…]</p><p>​        m=[1,2,3;4,5,6;7,8,9]</p><p><img src="image-20221224205752715.png" alt="image-20221224205752715"></p><p>​        索引方法</p><p>​        vector（index）(直接取第index个数)</p><p>​        matrix:</p><p>​        法一：matrix（rownum,colnum）</p><p>​        如m(1,2)</p><p><img src="image-20221224210140942.png" alt="image-20221224210140942"></p><p>​        法二：matrix([num1 num2],[num3 num4])</p><p>​        (取其排列组合的组合下表的数组成新的矩阵)</p><p>​        m([1 3],[1 3])</p><p><img src="image-20221224210443939.png" alt="image-20221224210443939"></p><p>​        方法三：matrix(a)</p><p>​        矩阵按列存储，故：m(1)=1,m(2)=4,m(4)=2…</p><p><img src="image-20221224210642070.png" alt="image-20221224210642070"></p><p>​        方法四：matrix([num1 num2 num3…（row1）；num4 num5,num6,…(row n)])</p><p>​        以方法三的排列为基础，取出m(num i)构成一个矩阵</p><p><img src="image-20221224211142755.png" alt="image-20221224211142755"></p><p>​        于是，我们也可以用如此的索引更改矩阵的数</p><h3 id="矩阵里有规律的快速输入"><a href="#矩阵里有规律的快速输入" class="headerlink" title="矩阵里有规律的快速输入"></a>矩阵里有规律的快速输入</h3><p>​    colon operator(:)</p><p>​    用于声明等差的vector</p><p>​    （1）a=num1:num2;(差为1的等差数列)</p><p><img src="image-20221224211635032.png" alt="image-20221224211635032"></p><p>​        (2)a=num1:num2:num3(差为num2的等差数列)</p><p><img src="image-20221224211754286.png" alt="image-20221224211754286"></p><p>​        (3)a=[num1:num2;num3:num4:num5;…]生成矩阵</p><p>​        (4)a=((num1,):)(表示全部)</p><p><img src="image-20221224212148933.png" alt="image-20221224212148933"></p><p>​        空[]去掉一行or一列</p><p><img src="image-20221224212232261.png" alt="image-20221224212232261"></p><p>​        对于可以合并为[A|B]的矩阵，matlab支持[A B]或者[A;B]的操作</p><p><img src="image-20221224212455824.png" alt="image-20221224212455824"></p><p>​        matlab的矩阵运算</p><p><img src="image-20221224212731039.png" alt="image-20221224212731039"></p><p>​        点乘点除是对应位置的数直接乘or除</p><p>​        特殊矩阵：</p><p><img src="image-20221224212922825.png" alt="image-20221224212922825"></p><p>​        matlab的特殊函数：</p><p><img src="image-20221224213011614.png" alt="image-20221224213011614"></p><h2 id="Matlab程序书写"><a href="#Matlab程序书写" class="headerlink" title="Matlab程序书写"></a>Matlab程序书写</h2><p>1.新建一个脚本程序</p><p>单击新建脚本后开始编写</p><p><img src="image-20221225192111703.png" alt="image-20221225192111703"></p><p>之后按F5或者是单击运行。</p><p>在一句最前面加上%表明这是注解</p><p>%%之间划分“节”，让脚本可以分块执行（其中变黄区块表面选中节）</p><p><img src="image-20221225193608481.png" alt="image-20221225193608481"></p><p>（Run：全部执行与Run Section：选中节执行）</p><p>Breaking point：对想检查的语句的下一句和行数处单击产生断点，从而在这一句停下来，随后可以再按continue或者是F5继续。</p><p>在Debug模式下可以将光标停在变量上查看具体属性</p><h3 id="基本的程序结构"><a href="#基本的程序结构" class="headerlink" title="基本的程序结构"></a>基本的程序结构</h3><p><img src="image-20221225194455880.png" alt="image-20221225194455880"></p><h3 id="基本的逻辑符号"><a href="#基本的逻辑符号" class="headerlink" title="基本的逻辑符号"></a>基本的逻辑符号</h3><p><img src="image-20221225194615602.png" alt="image-20221225194615602"></p><p>1.if/elseif/else结构</p><p>if condition1</p><p>​        statement1</p><p>elseif condition2</p><p>​        statement2</p><p>else</p><p>​        statement3</p><p>end</p><p>2.switch结构</p><p><img src="image-20221225195627982.png" alt="image-20221225195627982"></p><p>注意这里不同于C/C++:这里不需要break.</p><p>3.while</p><p><img src="image-20221225195751347.png" alt="image-20221225195751347"></p><p>(prod(1:n)表示阶乘)</p><p>4.for循环</p><p><img src="image-20221225200500864.png" alt="image-20221225200500864"></p><p>注意：</p><p>对于大矩阵要先初始化：</p><p>如A=zeros(2000,2000)</p><p>5.break</p><p>在while里break以中断while循环</p><p><img src="image-20221225201538350.png" alt="image-20221225201538350"></p><p>一些小提示：</p><p><img src="image-20221225201616354.png" alt="image-20221225201616354"></p><p>补充：clc：清空历史</p><h2 id="Matlab的自定义函数"><a href="#Matlab的自定义函数" class="headerlink" title="Matlab的自定义函数"></a>Matlab的自定义函数</h2><p>对于一个function文件：分为三个部分</p><p>function y=func()</p><p>comment：表明这个func的功能</p><p>功能代码</p><p><img src="image-20221225202351453.png" alt="image-20221225202351453"></p><p>为了可以使用自定义代码：请跳转到工作文件夹</p><p>Matlab可以定义多输入与多输出的函数：</p><p><img src="image-20221225203129714.png" alt="image-20221225203129714"></p><p>Matlab也支持定义匿名函数：</p><p><img src="image-20221225203836565.png" alt="image-20221225203836565"></p><h3 id="基本的变量结构"><a href="#基本的变量结构" class="headerlink" title="基本的变量结构"></a>基本的变量结构</h3><p><img src="image-20221226155045231.png" alt="image-20221226155045231"></p><p>这是常见的种类</p><h5 id="char-character"><a href="#char-character" class="headerlink" title="char:character"></a>char:character</h5><p>这是字符变量</p><h5 id="string：字符串"><a href="#string：字符串" class="headerlink" title="string：字符串"></a>string：字符串</h5><p>可以理解 为用数组储存的若干的char</p><p>于是可以这样加长：</p><p>s3=[s1 s2];</p><p>s4=[s1;s2];</p><h5 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct:结构"></a>struct:结构</h5><p><img src="image-20221226160704872.png" alt="image-20221226160704872"></p><h5 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h5><p><img src="image-20221226161005675.png" alt="image-20221226161005675"></p><p>Cell可以是一个大杂烩：里面可以储存不一样的数据</p><p><img src="image-20221226161237213.png" alt="image-20221226161237213"></p><p>一些函数：</p><p><img src="image-20221226161752014.png" alt="image-20221226161752014"></p><h1 id="matlab使用教程"><a href="#matlab使用教程" class="headerlink" title="matlab使用教程"></a>matlab使用教程</h1><p>如何把我们的数据存成文件：</p><p>save 文件名.mat（把文件以二进制的形式存储）</p><p>save 文件名.mat -ascii（把文件以ASCII的形式存储）</p><p>从excel中读取信息：</p><p>xlsread(‘filename.xlsx’,’列与行’)</p><p>xlswrite向Excel写入数据</p><p>（‘filename.xlsx’,数据,sheet,location）</p><p><img src="image-20221226163047228.png" alt="image-20221226163047228"></p><h3 id="Basic绘图"><a href="#Basic绘图" class="headerlink" title="Basic绘图"></a>Basic绘图</h3><p>​        我们怎么绘制一个函数呢？首先啊，我们知道函数是由足够密集的点连成的。也就是说，我们只需要把一个区间段的函数的X—Y点连起来就好了</p><p>​        我们使用plot函数来绘制图像：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>#<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>是一对点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        也可以这样使用</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>#where xx<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token function">length</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        如：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0</span>：<span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230122201210020.png" alt="image-20230122201210020"></p><p>​        运行上面的这句话，这就是结果</p><p>​        可不可以两个图像叠在一起嘞？可以</p><p><img src="image-20230122202456650.png" alt="image-20230122202456650"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold on<span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以绘制多个图像了：hold on表明重复画不刷新画布</p><p>我们当然可以设置函数曲线的格式：</p><p><img src="image-20230122203054085.png" alt="image-20230122203054085"></p><p>​        这样：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold on<span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'or'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'xg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230122203329996.png" alt="image-20230122203329996"></p><p>字符串里的格式顺序没有要求，有什么需求就塞。</p><p>有的时候，我们的函数很多很乱，</p><p>比如说在脚本里运行如下的代码：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold onx<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">4</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">;</span>y<span class="token operator">=</span><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>h<span class="token operator">=</span><span class="token function">cos</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token operator">=</span><span class="token number">1.</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>g<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token operator">.*</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.</span><span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token operator">.^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">./</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'bd-'</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>h<span class="token punctuation">,</span><span class="token string">'gp:'</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>w<span class="token punctuation">,</span><span class="token string">'ro-'</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>g<span class="token punctuation">,</span><span class="token string">'c^-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230122204242509.png" alt="image-20230122204242509"></p><p>我们可不可以做一点注记嘞？可以，使用legend函数就好了</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'L1'</span><span class="token punctuation">,</span><span class="token punctuation">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，这需要和你依次绘制函数的图像的顺序是一致的：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">#<span class="token punctuation">...</span><span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'sin(x)'</span><span class="token punctuation">,</span><span class="token string">'cos(x)'</span><span class="token punctuation">,</span><span class="token string">'Sigmoid'</span><span class="token punctuation">,</span><span class="token string">'Gauss Functions'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230122204721499.png" alt="image-20230122204721499"></p><p>那。。。可不可以多上一个坐标轴的标记</p><p>使用函数xlabel(‘showstr’),ylabel(“showstr”)和图像标题title(‘showstr’)</p><p><img src="image-20230122205415466.png" alt="image-20230122205415466"></p><p>text()和annotation()</p><p>我们有的时候需要在图片上来打一些字符：这需要我们来使用$LaTex$实现！比如说：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token operator">=</span>x<span class="token operator">.^</span><span class="token number">2.</span><span class="token operator">*</span><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token number">i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">:</span><span class="token number">0.01</span><span class="token operator">:</span><span class="token number">2</span>    <span class="token function">line</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token operator">^</span><span class="token number">i</span><span class="token operator">*</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span>str<span class="token operator">=</span><span class="token string">'$$\int_&#123;0&#125;^&#123;2&#125;x^2\sin(x) dx$$'</span><span class="token punctuation">;</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token number">0.25</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span><span class="token string">'Interpreter'</span><span class="token punctuation">,</span><span class="token string">'latex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#固定用法<span class="token function">annotation</span><span class="token punctuation">(</span><span class="token string">'arrow'</span><span class="token punctuation">,</span><span class="token string">'X'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.32</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'Y'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230202185243199.png" alt="image-20230202185243199"></p><h4 id="图像字体的调整："><a href="#图像字体的调整：" class="headerlink" title="图像字体的调整："></a>图像字体的调整：</h4><p>​        我们的绘图本身就是由很多个元素构成：图像本身，线条，文字等等。我们现在想办法使用代码去更改他们！</p><p><img src="image-20230202190117981.png" alt="image-20230202190117981"></p><p>​        类似于C指针的，我们的操作也可以返回这些对象的句柄（指针），比如说：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">h<span class="token operator">=</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        返回了函数画布的句柄！</p><p><img src="image-20230202190810805.png" alt="image-20230202190810805"></p><p>​        相关的可以了解对象树的概念！</p><p>​        我们使用get()方法来取回对象！set()来设定对象属性。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token operator">=</span><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>h<span class="token operator">=</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">get</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们的控制台返回了这样一串东西：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">AlignVertexCenters<span class="token operator">:</span> off           Annotation<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> matlab<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>eventdata<span class="token punctuation">.</span>Annotation<span class="token punctuation">]</span>         BeingDeleted<span class="token operator">:</span> off           BusyAction<span class="token operator">:</span> <span class="token string">'queue'</span>        ButtonDownFcn<span class="token operator">:</span> <span class="token string">''</span>             Children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>             Clipping<span class="token operator">:</span> on                Color<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">0.4470</span> <span class="token number">0.7410</span><span class="token punctuation">]</span>            ColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>          ContextMenu<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>            CreateFcn<span class="token operator">:</span> <span class="token string">''</span>      DataTipTemplate<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> matlab<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>datatip<span class="token punctuation">.</span>DataTipTemplate<span class="token punctuation">]</span>            DeleteFcn<span class="token operator">:</span> <span class="token string">''</span>          DisplayName<span class="token operator">:</span> <span class="token string">''</span>     HandleVisibility<span class="token operator">:</span> <span class="token string">'on'</span>              HitTest<span class="token operator">:</span> on        Interruptible<span class="token operator">:</span> on             LineJoin<span class="token operator">:</span> <span class="token string">'round'</span>            LineStyle<span class="token operator">:</span> <span class="token string">'-'</span>        LineStyleMode<span class="token operator">:</span> <span class="token string">'auto'</span>            LineWidth<span class="token operator">:</span> <span class="token number">0.5000</span>               Marker<span class="token operator">:</span> <span class="token string">'none'</span>      MarkerEdgeColor<span class="token operator">:</span> <span class="token string">'auto'</span>      MarkerFaceColor<span class="token operator">:</span> <span class="token string">'none'</span>        MarkerIndices<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1000</span> uint64<span class="token punctuation">]</span>           MarkerMode<span class="token operator">:</span> <span class="token string">'auto'</span>           MarkerSize<span class="token operator">:</span> <span class="token number">6</span>               Parent<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Axes<span class="token punctuation">]</span>        PickableParts<span class="token operator">:</span> <span class="token string">'visible'</span>             Selected<span class="token operator">:</span> off   SelectionHighlight<span class="token operator">:</span> on          SeriesIndex<span class="token operator">:</span> <span class="token number">1</span>                  Tag<span class="token operator">:</span> <span class="token string">''</span>                 Type<span class="token operator">:</span> <span class="token string">'line'</span>             UserData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>              Visible<span class="token operator">:</span> on                XData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1000</span> double<span class="token punctuation">]</span>            XDataMode<span class="token operator">:</span> <span class="token string">'manual'</span>          XDataSource<span class="token operator">:</span> <span class="token string">''</span>                YData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1000</span> double<span class="token punctuation">]</span>          YDataSource<span class="token operator">:</span> <span class="token string">''</span>                ZData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">0</span> double<span class="token punctuation">]</span>          ZDataSource<span class="token operator">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后运行:get(gca)</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ALim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>                    ALimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                  AlphaScale<span class="token operator">:</span> <span class="token string">'linear'</span>                    Alphamap<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">64</span> double<span class="token punctuation">]</span>           AmbientLightColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                BeingDeleted<span class="token operator">:</span> off                         Box<span class="token operator">:</span> on                    BoxStyle<span class="token operator">:</span> <span class="token string">'back'</span>                  BusyAction<span class="token operator">:</span> <span class="token string">'queue'</span>               ButtonDownFcn<span class="token operator">:</span> <span class="token string">''</span>                        CLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>                    CLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>              CameraPosition<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3.5000</span> <span class="token number">0</span> <span class="token number">17.3205</span><span class="token punctuation">]</span>          CameraPositionMode<span class="token operator">:</span> <span class="token string">'auto'</span>                CameraTarget<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3.5000</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">]</span>            CameraTargetMode<span class="token operator">:</span> <span class="token string">'auto'</span>              CameraUpVector<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">]</span>          CameraUpVectorMode<span class="token operator">:</span> <span class="token string">'auto'</span>             CameraViewAngle<span class="token operator">:</span> <span class="token number">6.6086</span>         CameraViewAngleMode<span class="token operator">:</span> <span class="token string">'auto'</span>                    Children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Line<span class="token punctuation">]</span>                    Clipping<span class="token operator">:</span> on               ClippingStyle<span class="token operator">:</span> <span class="token string">'3dbox'</span>                       Color<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                  ColorOrder<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">7</span>×<span class="token number">3</span> double<span class="token punctuation">]</span>             ColorOrderIndex<span class="token operator">:</span> <span class="token number">2</span>                  ColorScale<span class="token operator">:</span> <span class="token string">'linear'</span>                    Colormap<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">256</span>×<span class="token number">3</span> double<span class="token punctuation">]</span>                 ContextMenu<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>                   CreateFcn<span class="token operator">:</span> <span class="token string">''</span>                CurrentPoint<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">2</span>×<span class="token number">3</span> double<span class="token punctuation">]</span>             DataAspectRatio<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3.5000</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>         DataAspectRatioMode<span class="token operator">:</span> <span class="token string">'auto'</span>                   DeleteFcn<span class="token operator">:</span> <span class="token string">''</span>                   FontAngle<span class="token operator">:</span> <span class="token string">'normal'</span>                    FontName<span class="token operator">:</span> <span class="token string">'Helvetica'</span>                    FontSize<span class="token operator">:</span> <span class="token number">10</span>                FontSizeMode<span class="token operator">:</span> <span class="token string">'auto'</span>               FontSmoothing<span class="token operator">:</span> on                   FontUnits<span class="token operator">:</span> <span class="token string">'points'</span>                  FontWeight<span class="token operator">:</span> <span class="token string">'normal'</span>                   GridAlpha<span class="token operator">:</span> <span class="token number">0.1500</span>               GridAlphaMode<span class="token operator">:</span> <span class="token string">'auto'</span>                   GridColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>               GridColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>               GridLineStyle<span class="token operator">:</span> <span class="token string">'-'</span>            HandleVisibility<span class="token operator">:</span> <span class="token string">'on'</span>                     HitTest<span class="token operator">:</span> on               InnerPosition<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1300</span> <span class="token number">0.1100</span> <span class="token number">0.7750</span> <span class="token number">0.8150</span><span class="token punctuation">]</span>                Interactions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> matlab<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>interaction<span class="token punctuation">.</span>interface<span class="token punctuation">.</span>DefaultAxesInteractionSet<span class="token punctuation">]</span>               Interruptible<span class="token operator">:</span> on     LabelFontSizeMultiplier<span class="token operator">:</span> <span class="token number">1.1000</span>                       Layer<span class="token operator">:</span> <span class="token string">'bottom'</span>                      Layout<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> matlab<span class="token punctuation">.</span>ui<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>LayoutOptions<span class="token punctuation">]</span>                      Legend<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>              LineStyleOrder<span class="token operator">:</span> <span class="token string">'-'</span>         LineStyleOrderIndex<span class="token operator">:</span> <span class="token number">1</span>                   LineWidth<span class="token operator">:</span> <span class="token number">0.5000</span>              MinorGridAlpha<span class="token operator">:</span> <span class="token number">0.2500</span>          MinorGridAlphaMode<span class="token operator">:</span> <span class="token string">'auto'</span>              MinorGridColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1000</span> <span class="token number">0.1000</span> <span class="token number">0.1000</span><span class="token punctuation">]</span>          MinorGridColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>          MinorGridLineStyle<span class="token operator">:</span> <span class="token string">':'</span>                    NextPlot<span class="token operator">:</span> <span class="token string">'replace'</span>             NextSeriesIndex<span class="token operator">:</span> <span class="token number">2</span>               OuterPosition<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                      Parent<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Figure<span class="token punctuation">]</span>               PickableParts<span class="token operator">:</span> <span class="token string">'visible'</span>          PlotBoxAspectRatio<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">0.7896</span> <span class="token number">0.7896</span><span class="token punctuation">]</span>      PlotBoxAspectRatioMode<span class="token operator">:</span> <span class="token string">'auto'</span>                    Position<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1300</span> <span class="token number">0.1100</span> <span class="token number">0.7750</span> <span class="token number">0.8150</span><span class="token punctuation">]</span>          PositionConstraint<span class="token operator">:</span> <span class="token string">'outerposition'</span>                  Projection<span class="token operator">:</span> <span class="token string">'orthographic'</span>                    Selected<span class="token operator">:</span> off          SelectionHighlight<span class="token operator">:</span> on                  SortMethod<span class="token operator">:</span> <span class="token string">'childorder'</span>                    Subtitle<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>          SubtitleFontWeight<span class="token operator">:</span> <span class="token string">'normal'</span>                         Tag<span class="token operator">:</span> <span class="token string">''</span>                     TickDir<span class="token operator">:</span> <span class="token string">'in'</span>                 TickDirMode<span class="token operator">:</span> <span class="token string">'auto'</span>        TickLabelInterpreter<span class="token operator">:</span> <span class="token string">'tex'</span>                  TickLength<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.0100</span> <span class="token number">0.0250</span><span class="token punctuation">]</span>                  TightInset<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.0512</span> <span class="token number">0.0540</span> <span class="token number">0.0071</span> <span class="token number">0.0206</span><span class="token punctuation">]</span>                       Title<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>     TitleFontSizeMultiplier<span class="token operator">:</span> <span class="token number">1.1000</span>             TitleFontWeight<span class="token operator">:</span> <span class="token string">'normal'</span>    TitleHorizontalAlignment<span class="token operator">:</span> <span class="token string">'center'</span>                     Toolbar<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> AxesToolbar<span class="token punctuation">]</span>                        Type<span class="token operator">:</span> <span class="token string">'axes'</span>                       Units<span class="token operator">:</span> <span class="token string">'normalized'</span>                    UserData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                        View<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">90</span><span class="token punctuation">]</span>                     Visible<span class="token operator">:</span> on                       XAxis<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> NumericRuler<span class="token punctuation">]</span>               XAxisLocation<span class="token operator">:</span> <span class="token string">'bottom'</span>                      XColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>                  XColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>                        XDir<span class="token operator">:</span> <span class="token string">'normal'</span>                       XGrid<span class="token operator">:</span> off                      XLabel<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>                        XLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">7</span><span class="token punctuation">]</span>                    XLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                XLimitMethod<span class="token operator">:</span> <span class="token string">'tickaligned'</span>                  XMinorGrid<span class="token operator">:</span> off                  XMinorTick<span class="token operator">:</span> off                      XScale<span class="token operator">:</span> <span class="token string">'linear'</span>                       XTick<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">]</span>                  XTickLabel<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token number">8</span>×<span class="token number">1</span> cell<span class="token punctuation">&#125;</span>              XTickLabelMode<span class="token operator">:</span> <span class="token string">'auto'</span>          XTickLabelRotation<span class="token operator">:</span> <span class="token number">0</span>                   XTickMode<span class="token operator">:</span> <span class="token string">'auto'</span>                       YAxis<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> NumericRuler<span class="token punctuation">]</span>               YAxisLocation<span class="token operator">:</span> <span class="token string">'left'</span>                      YColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>                  YColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>                        YDir<span class="token operator">:</span> <span class="token string">'normal'</span>                       YGrid<span class="token operator">:</span> off                      YLabel<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>                        YLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                    YLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                YLimitMethod<span class="token operator">:</span> <span class="token string">'tickaligned'</span>                  YMinorGrid<span class="token operator">:</span> off                  YMinorTick<span class="token operator">:</span> off                      YScale<span class="token operator">:</span> <span class="token string">'linear'</span>                       YTick<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">11</span> double<span class="token punctuation">]</span>                  YTickLabel<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token number">11</span>×<span class="token number">1</span> cell<span class="token punctuation">&#125;</span>              YTickLabelMode<span class="token operator">:</span> <span class="token string">'auto'</span>          YTickLabelRotation<span class="token operator">:</span> <span class="token number">0</span>                   YTickMode<span class="token operator">:</span> <span class="token string">'auto'</span>                       ZAxis<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> NumericRuler<span class="token punctuation">]</span>                      ZColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>                  ZColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>                        ZDir<span class="token operator">:</span> <span class="token string">'normal'</span>                       ZGrid<span class="token operator">:</span> off                      ZLabel<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>                        ZLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                    ZLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                ZLimitMethod<span class="token operator">:</span> <span class="token string">'tickaligned'</span>                  ZMinorGrid<span class="token operator">:</span> off                  ZMinorTick<span class="token operator">:</span> off                      ZScale<span class="token operator">:</span> <span class="token string">'linear'</span>                       ZTick<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>                  ZTickLabel<span class="token operator">:</span> <span class="token string">''</span>              ZTickLabelMode<span class="token operator">:</span> <span class="token string">'auto'</span>          ZTickLabelRotation<span class="token operator">:</span> <span class="token number">0</span>                   ZTickMode<span class="token operator">:</span> <span class="token string">'auto'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，我们很想设定GCA属性，就是使用set指令：我们找到了这个的指针（句柄）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">set</span><span class="token punctuation">(</span>gca<span class="token punctuation">,</span><span class="token string">'XLim'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">set</span><span class="token punctuation">(</span>gca<span class="token punctuation">,</span><span class="token string">'YLim'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1.2</span><span class="token punctuation">,</span><span class="token number">1.2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        当然。。。其实还有更简单的：</p><pre class="line-numbers language-none"><code class="language-none">xlim([0,2*pi]);ylim([-1.2,1.2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="多重图像展示"><a href="#多重图像展示" class="headerlink" title="多重图像展示"></a>多重图像展示</h3><p>​        我们可以使用figure来分开画图：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>y1<span class="token operator">=</span>x<span class="token operator">.^</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">;</span>y2<span class="token operator">=</span><span class="token function">exp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>figure<span class="token punctuation">,</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span>figure<span class="token punctuation">,</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230202195804959-167534035717165.png" alt="image-20230202195804959"></p><p>也可以在一个窗口上显示多个图像</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">subplot</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230202200620906.png" alt="image-20230202200620906"></p><p><img src="image-20230202200718788.png" alt="image-20230202200718788"></p><p><img src="image-20230202200912381.png" alt="image-20230202200912381"></p><p><img src="image-20230202200933449.png" alt="image-20230202200933449"></p><h2 id="Self-Learning"><a href="#Self-Learning" class="headerlink" title="Self Learning"></a>Self Learning</h2><h2 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h2><p>​        我们来做个假设，假设我们已经熟知了Matlab的矩阵操作，基础概念和基本编程框架。我们下面就开始来围绕Matlab的绘图展开说说。</p><h3 id="离散数据绘制"><a href="#离散数据绘制" class="headerlink" title="离散数据绘制"></a>离散数据绘制</h3><p>​        什么离散的数据呢？简而言之，就是单蹦的数据，而不是连续的数据。比若说【1，2，3，4，5，6】这就是离散的数据，而集合{x | 9 &gt; x &gt; 6}就不是离散的，而是连续的。换而言之，一个简单的说法，正是这些数据要是可数可列的，我们才说他们是离散的。</p><p>​        现在，打开我们的matlab，来尝试绘制一下离散的数据。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear all# 清除所有的变量X1 <span class="token operator">=</span> <span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span> # 产生一个从 <span class="token number">1</span> 到 <span class="token number">100</span> 的离散行向量Y1 <span class="token operator">=</span> <span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span> # 产生一个从 <span class="token number">2</span> 到 <span class="token number">200</span> 的离散行向量<span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span># 注意，这是指绘制在第一个弹窗上，可以用一个变量接受返回值！自行查看他是啥吧！<span class="token function">plot</span><span class="token punctuation">(</span>X1<span class="token punctuation">,</span>Y1<span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'MarkerSize'</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span> # 绘图关键指令，他表示绘制一个 Y <span class="token operator">-</span> X 离散关系图， 这个MarkerSize就是点画多大<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230407125527093.png" alt="image-20230407125527093"></p><h3 id="连续函数"><a href="#连续函数" class="headerlink" title="连续函数"></a>连续函数</h3><p>​        下面，我们来尝试一下，绘制连续的函数。</p><p>​        注意到，matlab没有那么聪明，可以不带脑子的直接传入函数就直接帮你开画的，我们回顾函数绘制的一般办法，那就是，转向通过化连续 为 离散的变量 的关系来绘制函数，说白了，就是使用足够密集的点来绘制图像。这不正是我们从离散推向连续的过程嘛！</p><p>​        我们只需要像手绘函数图像那样，离散的点出 $[X_i, Y_i ]$那样就好了。那样的话：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear all# 划定X的范围， Y的离散值（第一个函数）X1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">144</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">72</span><span class="token punctuation">;</span>Y1 <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">*</span><span class="token function">cos</span><span class="token punctuation">(</span>X1<span class="token punctuation">)</span><span class="token punctuation">;</span># 划定X的范围， Y的离散值（第二个函数）X2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">1080</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">740</span><span class="token punctuation">;</span>Y2 <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>X2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span># subplot指令，这里是用来多图像绘制的，subplot正是子图像的意思<span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> # 一行几个？ 一共几行？ 这是第几个子图像？<span class="token function">plot</span><span class="token punctuation">(</span>X1<span class="token punctuation">,</span>Y1<span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'MarkerSize'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> # 函数用来限定X的绘制范围#下面雷同了。。。<span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token function">plot</span><span class="token punctuation">(</span>X1<span class="token punctuation">,</span>Y1<span class="token punctuation">,</span><span class="token string">'LineWidth'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token function">plot</span><span class="token punctuation">(</span>X2<span class="token punctuation">,</span>Y2<span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'MarkerSize'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token function">plot</span><span class="token punctuation">(</span>X2<span class="token punctuation">,</span>Y2<span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'LineWidth'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230407130913302.png" alt="image-20230407130913302"></p><p>​        当然，也不是那麽麻烦，实际上，这样也可以：</p><pre class="line-numbers language-none"><code class="language-none">X1 &#x3D; -pi&#x2F;2:0.001:pi&#x2F;2;Y1 &#x3D; x + sin(x) + exp(x);plot(X1,Y1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230407131223232.png" alt="image-20230407131223232"></p><p>​        好像这个不太好点对点啊，可不可以加上网格便于观察呢， 当然可以，加上点东西就好了！</p><p>​        首先介绍一下刚才一直没说的那个：plot里的那些’ xxx ‘是什么呢？ 查阅一下，发现是一个叫 PropertyName的东西，就是属性名称，比如说， MarkerSize 就是点的大小， 而 LineWidth 就是绘制图像线宽的属性名称，注意一定要输对，大小写都不要错（尽可能），后面跟上的就是属性值 PropertyValue 了。 当然有一个例外就是图形的样式。 这是不用说 PropertyName的，直接在输完X,Y 之后，直接用单引号括起来想要的款式。</p><p>​        来来，例子上了！</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">,</span><span class="token string">'ro'</span><span class="token punctuation">)</span> # 就是对上面那个函数，加点东西就好了grid on #打开网格显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230407131949917.png" alt="image-20230407131949917"></p><p>​        可是，就是这样拿给别人看，这不好。这是啥啊？？？不知道，含义是啥，不知道。可不可以加点注释呢？可以！</p><pre class="line-numbers language-none"><code class="language-none">title(&#39;I think this is a sample of 1dim image demonstration&#39;);xlabel(&#39;I am X&#39;);ylabel(&#39;I am Y, the function&#39;s val&#39;);legend(&#39;y &#x3D; x + sin(x) + e^x&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230407132306428.png" alt="image-20230407132306428"></p><p>​        很有意思了。 注意到legend 就是图例的意思！</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>​        我们绘制简单的离散数据与连续函数，使用的就是如下的步骤来完成我们的工作！</p><p>（1）准备数据， 就是准备好你的X Y</p><p>（2）确定好在那里画，第一个子图，还是哪里，但一定不是你的草稿纸！</p><p>（3）调用图像绘制函数来画！ plot是我们现在搞到的</p><p>（4）制定好坐标轴的范围</p><p>（5）添加绘制的属性（懒狗可以不管）</p><p>（6）添加一些注释（针对要不要做的话。。。你知道我要说什么）</p><p>（7）图像导出与展示</p><h2 id="Systematically-Learn"><a href="#Systematically-Learn" class="headerlink" title="Systematically Learn"></a>Systematically Learn</h2><p>(先看先前的Matlab版本)</p><p>Matlab是一门语言：</p><p><img src="image-20230513075306507.png" alt="image-20230513075306507"></p><p>一些注意点：</p><p><img src="image-20230513075357872.png" alt="image-20230513075357872"></p><h2 id="开始入门"><a href="#开始入门" class="headerlink" title="开始入门"></a>开始入门</h2><p>首先，Matlab自己也是一门编程语言。这意味着它可以有变量的命名。同其他编程语言类似，</p><p>1.Matlab区分大小写，</p><p>2.变量名长度不得超过63位，</p><p>3.并且由字母，数字和下划线组成。但不可以使用标点。</p><p>By the way。同其他命名规则一致——变量名应当简洁明了！</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>有以下几种类形：</p><p>数字，字符和字符串，<strong>矩阵（数组）</strong>，元胞数据，结构体（对，C语言那种）。</p><h2 id="demo与散记"><a href="#demo与散记" class="headerlink" title="demo与散记"></a>demo与散记</h2><p>1.在Matlab里，我们用%%表达注释，我们开一个脚本看看：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token comment">%% I. 清空环境变量及其Command Window的所有命令</span>clear allclc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.变量名规则展示</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token comment">%% II. </span>A <span class="token operator">=</span> <span class="token number">2</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token comment">%% abcdefgjfpwoejfoba4ett4gbamjofwoFP3VN0R92UDX023gag3w523cd2n3o823apc7i$3rc7i34vc98p = 2</span><span class="token comment">%% 取消注释看看</span><span class="token comment">%% 3b = 4 (x)</span>a_2 <span class="token operator">=</span> <span class="token number">5</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.几种常见的类型</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token comment">%% 数字</span>s <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token comment">%% 字符</span><span class="token function">abs</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">%% 返回字符的ASCII码值</span><span class="token function">char</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token punctuation">)</span> <span class="token comment">%% 返回对应的ASCII：A</span><span class="token function">num2str</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token punctuation">)</span> <span class="token comment">%%返回字符串的65</span>str <span class="token operator">=</span> <span class="token string">'Learning matlabs machine learning'</span><span class="token function">length</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>doc num2str<span class="token punctuation">;</span> <span class="token comment">%% 快速查看文档</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230513080824005.png" alt="image-20230513080824005"></p><h2 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h2><h3 id="定义-初始化"><a href="#定义-初始化" class="headerlink" title="定义+初始化"></a>定义+初始化</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">4</span> <span class="token number">5</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">7</span><span class="token punctuation">]</span> <span class="token comment">%%可以直接赋值指定</span>B <span class="token operator">=</span> A<span class="token operator">'</span> <span class="token comment">%%转置</span>C <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token comment">%%降维至一个列向量</span>D <span class="token operator">=</span> <span class="token function">inv</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token comment">%%求解逆矩阵</span>A<span class="token operator">*</span>D <span class="token comment">%%计算精度问题，往往可能会有-0.0000出现</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h2><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">E <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">%% 10*5*3的数组</span><span class="token function">E</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token function">E</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">randi</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token function">E</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">randn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230513081459200.png" alt="image-20230513081459200"></p><pre class="line-numbers language-none"><code class="language-none">X &#x3D; rand 返回一个在区间 (0,1) 内均匀分布的随机数。X &#x3D; rand(n) 返回一个 n×n 的随机数矩阵。X &#x3D; rand(sz1,...,szN) 返回由随机数组成的 sz1×...×szN 数组，其中 sz1,...,szN 指示每个维度的大小。例如：rand(3,4) 返回一个 3×4 的矩阵。X &#x3D; rand(sz) 返回由随机数组成的数组，其中大小向量 sz 指定 size(X)。例如：rand([3 4]) 返回一个 3×4 的矩阵。X &#x3D; rand(___,typename) 返回由 typename 数据类型的随机数组成的数组。typename 输入可以是 &#39;single&#39; 或 &#39;double&#39;。您可以使用上述语法中的任何输入参数。X &#x3D; rand(___,&#39;like&#39;,p) 返回由 p 等随机数组成的数组；也就是与 p 同一对象类型。您可以指定 typename 或 &#39;like&#39;，但不能同时指定两者。X &#x3D; rand(s,___) 从随机数流 s 而不是默认全局流生成数字。要创建一个流，请使用 RandStream。指定 s，后跟上述语法中的任意参数组合，但涉及 &#39;like&#39; 的组合除外。此语法不支持 &#39;like&#39; 输入。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X &#x3D; randi(imax) 返回一个介于 1 和 imax 之间的伪随机整数标量。X &#x3D; randi(imax,n) 返回 n×n 矩阵，其中包含从区间 [1,imax] 的均匀离散分布中得到的伪随机整数。X &#x3D; randi(imax,sz1,...,szN) 返回 sz1×...×szN 数组，其中 sz1,...,szN 指示每个维度的大小。例如，randi(10,3,4) 返回一个由介于 1 和 10 之间的伪随机整数组成的 3×4 数组。X &#x3D; randi(imax,sz) 返回一个数组，其中大小向量 sz 定义 size(X)。例如，randi(10,[3,4]) 返回一个由介于 1 和 10 之间的伪随机整数组成的 3×4 数组。X &#x3D; randi(imax,classname) 返回一个伪随机整数，其中 classname 指定数据类型。classname 可以为 &#39;single&#39;、&#39;double&#39;、&#39;int8&#39;、&#39;uint8&#39;、&#39;int16&#39;、&#39;uint16&#39;、&#39;int32&#39; 或 &#39;uint32&#39;。X &#x3D; randi(imax,n,classname) 返回数据类型为 classname 的 n×n 数组。X &#x3D; randi(imax,sz1,...,szN,classname) 返回数据类型为 classname 的 sz1×...×szN 数组。X &#x3D; randi(imax,sz,classname) 返回一个数组，其中大小向量 sz 定义 size(X)，classname 定义 class(X)。X &#x3D; randi(imax,&#39;like&#39;,p) 返回一个类如 p 的伪随机整数；即，具有相同的数据类型（类）。X &#x3D; randi(imax,n,&#39;like&#39;,p) 返回一个类如 p 的 n×n 数组。X &#x3D; randi(imax,sz1,...,szN,&#39;like&#39;,p) 返回一个类如 p 的 sz1×...×szN 数组。X &#x3D; randi(imax,sz,&#39;like&#39;,p) 返回一个类如 p 的数组，其中大小向量 sz 定义 size(X)。X &#x3D; randi([imin,imax],___) 使用以上任何语法返回一个数组，其中包含从区间 [imin,imax] 的均匀离散分布中得到的整数。X &#x3D; randi(s,___) 从随机数流 s 而不是默认全局流生成整数。要创建一个流，请使用 RandStream。指定 s，后跟上述语法中的任意参数组合，但涉及 &#39;like&#39; 的组合除外。此语法不支持 &#39;like&#39; 输入。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X &#x3D; randn 返回一个从标准正态分布中得到的随机标量。X &#x3D; randn(n) 返回由正态分布的随机数组成的 n×n 矩阵。X &#x3D; randn(sz1,...,szN) 返回由随机数组成的 sz1×...×szN 数组，其中 sz1,...,szN 指示每个维度的大小。例如：randn(3,4) 返回一个 3×4 的矩阵。X &#x3D; randn(sz) 返回由随机数组成的数组，其中大小向量 sz 定义 size(X)。例如：randn([3 4]) 返回一个 3×4 的矩阵。X &#x3D; randn(___,typename) 返回由 typename 数据类型的随机数组成的数组。typename 输入可以是 &#39;single&#39; 或 &#39;double&#39;。您可以使用上述语法中的任何输入参数。X &#x3D; randn(___,&#39;like&#39;,p) 返回由 p 等随机数组成的数组；也就是与 p 同一对象类型。您可以指定 typename 或 &#39;like&#39;，但不能同时指定两者。X &#x3D; randn(s,___) 从随机数流 s 而不是默认全局流生成数字。要创建一个流，请使用 RandStream。指定 s，后跟上述语法中的任意参数组合，但涉及 &#39;like&#39; 的组合除外。此语法不支持 &#39;like&#39; 输入。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token function">cell</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>A<span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">eye</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>A<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">magic</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>B <span class="token operator">=</span> A<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230513082005943.png" alt="image-20230513082005943"></p><p>​        元胞数组是一种包含名为元胞的索引数据容器的数据类型，其中的每个元胞都可以包含任意类型的数据。元胞数组通常包含文本列表、文本和数字的组合或者不同大小的数值数组。通过将索引括在圆括号 () 中可以引用元胞集。使用花括号 {} 进行索引来访问元胞的内容。</p><p>​        结构体不多用，可以参看C的结构体怎样操作的，一样的。</p><pre class="line-numbers language-matla" data-language="matla"><div class="caption"><span>b</span></div><code class="language-matla">B &#x3D; 1:2:9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        生成一个列向量：使之从1起到9停，间隔为2 的列向量！</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">repmat</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        拷贝B至三行一列</p><p><img src="image-20230513082352045.png" alt="image-20230513082352045"></p><p>​        矩阵里有六种常见操做：加减，矩阵乘(<em>)，矩阵除( / )（求逆），对应元素相乘(.\</em>)，相除(./)</p><h2 id="程序控制模块"><a href="#程序控制模块" class="headerlink" title="程序控制模块"></a>程序控制模块</h2><p><img src="image-20230513082823827.png" alt="image-20230513082823827"></p><pre class="line-numbers language-none"><code class="language-none">if expression    statementselseif expression    statementselse    statementsendif expression, statements, end 计算表达式并在表达式为 true 时执行一组语句。表达式的结果非空并且仅包含非零元素（逻辑值或实数值）时，该表达式为 true。否则，表达式为 false。elseif 和 else 模块是可选的。这些语句仅在 if...end 块中前面的表达式为 false 时才会执行。if 块可以包含多个 elseif 块。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">switch switch_expression   case case_expression      statements   case case_expression      statements    ...   otherwise      statementsendswitch switch_expression, case case_expression, end 计算表达式并选择执行多组语句中的一组。每个选项为一个 case。switch 块会测试每个 case，直至一个 case 表达式为 true。case 在以下情况下为 true：对于数字，case_expression &#x3D;&#x3D; switch_expression。对于字符向量，strcmp(case_expression,switch_expression) &#x3D;&#x3D; 1。对于支持 eq 函数的对象，case_expression &#x3D;&#x3D; switch_expression。重载的 eq 函数的输出必须为逻辑值或可转换为逻辑值。对于元胞数组 case_expression，元胞数组的至少一个元素与 switch_expression 匹配，如上述对数字、字符向量和对象的定义。当 case 表达式为 true 时，MATLAB® 执行对应的语句，然后退出 switch 块。计算的 switch_expression 必须为标量或字符向量。计算的 case_expression 必须为标量、字符向量或者标量或字符向量的元胞数组。otherwise 块是可选的。仅当没有 case 为 true 时，MATLAB 才会执行这些语句。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">for index &#x3D; values   statementsendfor index &#x3D; values, statements, end 在循环中将一组语句执行特定次数。values 为下列形式之一：initVal:endVal - index 变量从 initVal 至 endVal 按 1 递增，重复执行 statements 直到 index 大于 endVal。initVal:step:endVal - 每次迭代时按值 step 对 index 进行递增，或在 step 是负数时对 index 进行递减。valArray - 每次迭代时从数组 valArray 的后续列创建列向量 index。例如，在第一次迭代时，index &#x3D; valArray(:,1)。循环最多执行 n 次，其中 n 是 valArray 的列数，由 numel(valArray(1,:)) 给定。输入 valArray 可属于任何 MATLAB® 数据类型，包括字符向量、元胞数组或结构体。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">语法while expression    statementsendwhile expression, statements, end 计算一个表达式，并在该表达式为 true 时在一个循环中重复执行一组语句。表达式的结果非空并且仅包含非零元素（逻辑值或实数值）时，该表达式为 true。否则，表达式为 false。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        很是类似，哈哈。</p><h2 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a>基本绘图</h2><p>​        重点讲过了先前，就略过了</p><pre class="line-numbers language-none"><code class="language-none">plot(X,Y)plot(X,Y,LineSpec)plot(X1,Y1,...,Xn,Yn)plot(X1,Y1,LineSpec1,...,Xn,Yn,LineSpecn)plot(Y)plot(Y,LineSpec)plot(___,Name,Value)plot(ax,___)h &#x3D; plot(___)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>plot(X,Y)</code> 创建 <code>Y</code> 中数据对 <code>X</code> 中对应值的二维线图。</p><ul><li>如果 <code>X</code> 和 <code>Y</code> 都是向量，则它们的长度必须相同。<code>plot</code> 函数绘制 <code>Y</code> 对 <code>X</code> 的图。</li><li>如果 <code>X</code> 和 <code>Y</code> 均为矩阵，则它们的大小必须相同。<code>plot</code> 函数绘制 <code>Y</code> 的列对 <code>X</code> 的列的图。</li><li>如果 <code>X</code> 或 <code>Y</code> 中的一个是向量而另一个是矩阵，则矩阵的各维中必须有一维与向量的长度相等。如果矩阵的行数等于向量长度，则 <code>plot</code> 函数绘制矩阵中的每一列对向量的图。如果矩阵的列数等于向量长度，则该函数绘制矩阵中的每一行对向量的图。如果矩阵为方阵，则该函数绘制每一列对向量的图。</li><li>如果 <code>X</code> 或 <code>Y</code> 之一为标量，而另一个为标量或向量，则 <code>plot</code> 函数会绘制离散点。但是，要查看这些点，您必须指定标记符号，例如 <code>plot(X,Y,&#39;o&#39;)</code>。</li></ul><p><code>plot(X,Y,LineSpec)</code> 设置线型、标记符号和颜色。</p><p><code>plot(X1,Y1,...,Xn,Yn)</code> 绘制多个 <code>X</code>、<code>Y</code> 对组的图，所有线条都使用相同的坐标区。</p><p><code>plot(X1,Y1,LineSpec1,...,Xn,Yn,LineSpecn)</code> 设置每个线条的线型、标记符号和颜色。您可以混用 <code>X</code>、<code>Y</code>、<code>LineSpec</code> 三元组和 <code>X</code>、<code>Y</code> 对组：例如，<code>plot(X1,Y1,X2,Y2,LineSpec2,X3,Y3)</code>。</p><p><code>plot(Y)</code> 创建 <code>Y</code> 中数据对每个值索引的二维线图。</p><ul><li>如果 <code>Y</code> 是向量，<em>x</em> 轴的刻度范围是从 1 至 <code>length(Y)</code>。</li><li>如果 <code>Y</code> 是矩阵，则 <code>plot</code> 函数绘制 <code>Y</code> 中各列对其行号的图。<em>x</em> 轴的刻度范围是从 1 到 <code>Y</code> 的行数。</li><li>如果 <code>Y</code> 是复数，则 <code>plot</code> 函数绘制 <code>Y</code> 的虚部对 <code>Y</code> 的实部的图，使得 <code>plot(Y)</code> 等效于 <code>plot(real(Y),imag(Y))</code>。</li></ul><p><code>plot(Y,LineSpec)</code> 设置线型、标记符号和颜色。</p><p><code>plot(___,Name,Value)</code> 使用一个或多个 <code>Name,Value</code> 对组参数指定线条属性。有关属性列表，请参阅 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">Line 属性</a>。可以将此选项与前面语法中的任何输入参数组合一起使用。名称-值对组设置将应用于绘制的所有线条。</p><p><code>plot(ax,___)</code> 将在由 <code>ax</code> 指定的坐标区中，而不是在当前坐标区 (<code>gca</code>) 中创建线条。选项 <code>ax</code> 可以位于前面的语法中的任何输入参数组合之前。</p><p><code>h = plot(___)</code> 返回由图形线条对象组成的列向量。在创建特定的图形线条后，可以使用 <code>h</code> 修改其属性。有关属性列表，请参阅 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">Line 属性</a>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="创建线图"><a href="#创建线图" class="headerlink" title="创建线图"></a>创建线图</h3><p>将 <code>x</code> 创建为由 0 和 2<em>π</em> 之间的线性间隔值组成的向量。在各值之间使用递增量 <em>π</em>/100。将 <code>y</code> 创建为 <code>x</code> 的正弦值。创建数据的线图。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; 0:pi&#x2F;100:2*pi;y &#x3D; sin(x);plot(x,y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="createlineplotexample_01_zh_CN.png" alt="img"></p><h3 id="绘制多个线条"><a href="#绘制多个线条" class="headerlink" title="绘制多个线条"></a>绘制多个线条</h3><p>   (matlab:openExample(‘graphics/PlotMultipleLinesExample’))</p><p>将 <code>x</code> 定义为 100 个介于 −2<em>π</em> 和 2<em>π</em> 之间的线性间隔值。将 <code>y1</code> 和 <code>y2</code> 定义为 <code>x</code> 的正弦和余弦值。创建上述两个数据集的线图。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; linspace(-2*pi,2*pi);y1 &#x3D; sin(x);y2 &#x3D; cos(x);figureplot(x,y1,x,y2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="plotmultiplelinesexample_01_zh_CN.png" alt="img"></p><h3 id="根据矩阵创建线图"><a href="#根据矩阵创建线图" class="headerlink" title="根据矩阵创建线图"></a>根据矩阵创建线图</h3><p>将 <code>Y</code> 定义为 <code>magic</code> 函数返回的 4×4 矩阵。</p><pre class="line-numbers language-none"><code class="language-none">Y &#x3D; magic(4)Y &#x3D; 4×4    16     2     3    13     5    11    10     8     9     7     6    12     4    14    15     1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建 <code>Y</code> 的二维线图。MATLAB® 将矩阵的每一列绘制为单独的线条。</p><pre class="line-numbers language-none"><code class="language-none">figureplot(Y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="createlineplotfrommatrixexample_01_zh_CN.png" alt="img"></p><h3 id="指定线型"><a href="#指定线型" class="headerlink" title="指定线型"></a>指定线型</h3><p>绘制三条正弦曲线，每条曲线之间存在较小的相移。第一条曲线使用默认的线型。为第二条曲线指定虚线样式，为第三条曲线指定点线样式。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; 0:pi&#x2F;100:2*pi;y1 &#x3D; sin(x);y2 &#x3D; sin(x-0.25);y3 &#x3D; sin(x-0.5);figureplot(x,y1,x,y2,&#39;--&#39;,x,y3,&#39;:&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="specifylinestyleexample_01_zh_CN.png" alt="img"></p><p>MATLAB® 按默认的色序循环使用线条颜色。</p><h3 id="指定线型、颜色和标记"><a href="#指定线型、颜色和标记" class="headerlink" title="指定线型、颜色和标记"></a>指定线型、颜色和标记</h3><p>绘制三条正弦曲线，每条曲线之间存在较小的相移。第一条正弦曲线使用绿色线条，不带标记。第二条正弦曲线使用蓝色虚线，带圆形标记。第三条正弦曲线只使用青蓝色星号标记。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; 0:pi&#x2F;10:2*pi;y1 &#x3D; sin(x);y2 &#x3D; sin(x-0.25);y3 &#x3D; sin(x-0.5);figureplot(x,y1,&#39;g&#39;,x,y2,&#39;b--o&#39;,x,y3,&#39;c*&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="specifylinestylecolorandmarkerexample_01_zh_CN.png" alt="img"></p><h3 id="在特定的数据点显示标记"><a href="#在特定的数据点显示标记" class="headerlink" title="在特定的数据点显示标记"></a>在特定的数据点显示标记</h3><p>通过指定标记符号并将 <code>MarkerIndices</code> 属性设置为名称-值对组，创建一个线图并每隔四个数据点显示一个标记。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; linspace(0,10);y &#x3D; sin(x);plot(x,y,&#39;-o&#39;,&#39;MarkerIndices&#39;,1:5:length(y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="displaymarkersatspecificdatapointsexample_01_zh_CN.png" alt="img"></p><h3 id="指定线宽、标记大小和标记颜色"><a href="#指定线宽、标记大小和标记颜色" class="headerlink" title="指定线宽、标记大小和标记颜色"></a>指定线宽、标记大小和标记颜色</h3><p>   (matlab:openExample(‘graphics/SpecifyLineWidthMarkerSizeAndMarkerColorExample’))</p><p>创建线图并使用 <code>LineSpec</code> 选项指定带正方形标记的绿色虚线。使用 <code>Name,Value</code> 对组来指定线宽、标记大小和标记颜色。将标记边颜色设置为蓝色，并使用 RGB 颜色值设置标记面颜色。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; -pi:pi&#x2F;10:pi;y &#x3D; tan(sin(x)) - sin(tan(x));figureplot(x,y,&#39;--gs&#39;,...    &#39;LineWidth&#39;,2,...    &#39;MarkerSize&#39;,10,...    &#39;MarkerEdgeColor&#39;,&#39;b&#39;,...    &#39;MarkerFaceColor&#39;,[0.5,0.5,0.5])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="specifylinewidthmarkersizeandmarkercolorexample_01_zh_CN.png" alt="img"></p><h3 id="添加标题和轴标签"><a href="#添加标题和轴标签" class="headerlink" title="添加标题和轴标签"></a>添加标题和轴标签</h3><p>使用 <code>linspace</code> 函数将 <code>x</code> 定义为 0 到 10 之间 150 个值组成的向量。将 <code>y</code> 定义为 <code>x</code> 的余弦值。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; linspace(0,10,150);y &#x3D; cos(5*x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建余弦曲线的二维线图。使用 RGB 颜色值将线条颜色更改为蓝绿色。使用 <code>title</code>、<code>xlabel</code> 和 <code>ylabel</code> 函数为图形添加标题和轴标签。</p><pre class="line-numbers language-none"><code class="language-none">figureplot(x,y,&#39;Color&#39;,[0,0.7,0.9])title(&#39;2-D Line Plot&#39;)xlabel(&#39;x&#39;)ylabel(&#39;cos(5x)&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="addtitleandaxislabelsexample_01_zh_CN.png" alt="img"></p><h3 id="绘制持续时间并指定刻度格式"><a href="#绘制持续时间并指定刻度格式" class="headerlink" title="绘制持续时间并指定刻度格式"></a>绘制持续时间并指定刻度格式</h3><p>将 <code>t</code> 定义为 7 个介于 0 到 3 分钟之间的 <code>duration</code> 线性间隔值。绘制随机数据并使用 <code>&#39;DurationTickFormat&#39;</code> 名称-值对组参数指定 <code>duration</code> 刻度线的格式。</p><pre class="line-numbers language-none"><code class="language-none">t &#x3D; 0:seconds(30):minutes(3);y &#x3D; rand(1,7);plot(t,y,&#39;DurationTickFormat&#39;,&#39;mm:ss&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="specifydurationtickformatsexample_01_zh_CN.png" alt="img"></p><h3 id="指定线图的坐标区"><a href="#指定线图的坐标区" class="headerlink" title="指定线图的坐标区"></a>指定线图的坐标区</h3><p>​        可以使用 <code>tiledlayout</code> 和 <code>nexttile</code> 函数显示分块图。调用 <code>tiledlayout</code> 函数以创建一个 2×1 分块图布局。调用 <code>nexttile</code> 函数创建一个坐标区对象，并将该对象返回为 <code>ax1</code>。通过将 <code>ax1</code> 传递给 <code>plot</code> 函数来创建顶部绘图。通过将坐标区传递给 <code>title</code> 和 <code>ylabel</code> 函数，为图添加标题和 <em>y</em> 轴标签。重复该过程以创建底部绘图。</p><pre class="line-numbers language-none"><code class="language-none">% Create data and 2-by-1 tiled chart layoutx &#x3D; linspace(0,3);y1 &#x3D; sin(5*x);y2 &#x3D; sin(15*x);tiledlayout(2,1)% Top plotax1 &#x3D; nexttile;plot(ax1,x,y1)title(ax1,&#39;Top Plot&#39;)ylabel(ax1,&#39;sin(5x)&#39;)% Bottom plotax2 &#x3D; nexttile;plot(ax2,x,y2)title(ax2,&#39;Bottom Plot&#39;)ylabel(ax2,&#39;sin(15x)&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="plotspecifyaxes19bexample_01_zh_CN.png" alt="img"></p><h3 id="创建并修改线条"><a href="#创建并修改线条" class="headerlink" title="创建并修改线条"></a>创建并修改线条</h3><p>将 <code>x</code> 定义为 100 个介于 −2<em>π</em> 和 2<em>π</em> 之间的线性间隔值。将 <code>y1</code> 和 <code>y2</code> 定义为 <code>x</code> 的正弦和余弦值。为上述两个数据集分别创建线图，并在 <code>p</code> 中返回两个图形线条。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; linspace(-2*pi,2*pi);y1 &#x3D; sin(x);y2 &#x3D; cos(x);p &#x3D; plot(x,y1,x,y2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="changelinepropertiesusinghandlesexample_01_zh_CN.png" alt="img"></p><p>将第一个线条的线宽更改为 2。向第二行添加星形标记。使用圆点表示法设置属性。</p><pre class="line-numbers language-none"><code class="language-none">p(1).LineWidth &#x3D; 2;p(2).Marker &#x3D; &#39;*&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="changelinepropertiesusinghandlesexample_02_zh_CN.png" alt="img"></p><h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><p>绘制以点 (4,3) 为中心以 2 为半径的圆。使用 <code>axis equal</code> 可沿每个坐标方向使用相等的数据单位。</p><pre class="line-numbers language-none"><code class="language-none">r &#x3D; 2;xc &#x3D; 4;yc &#x3D; 3;theta &#x3D; linspace(0,2*pi);x &#x3D; r*cos(theta) + xc;y &#x3D; r*sin(theta) + yc;plot(x,y)axis equal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="plotcircleexample_01_zh_CN.png" alt="img"></p><h2 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h2><h3 id="Y-y-值-标量-向量-矩阵"><a href="#Y-y-值-标量-向量-矩阵" class="headerlink" title="Y - y 值 标量 | 向量 | 矩阵"></a><code>Y</code> - y 值 标量 | 向量 | 矩阵</h3><p><em>y</em> 值，指定为标量、向量或矩阵。要根据特定的 <em>x</em> 值绘图，还必须指定 <code>X</code>。</p><p><strong>数据类型：</strong> <code>single</code> | <code>double</code> | <code>int8</code> | <code>int16</code> | <code>int32</code> | <code>int64</code> | <code>uint8</code> | <code>uint16</code> | <code>uint32</code> | <code>uint64</code> | <code>categorical</code> | <code>datetime</code> | <code>duration</code></p><h3 id="X-x-值-标量-向量-矩阵"><a href="#X-x-值-标量-向量-矩阵" class="headerlink" title="X - x 值 标量 | 向量 | 矩阵"></a><code>X</code> - x 值 标量 | 向量 | 矩阵</h3><p><em>x</em> 值，指定为标量、向量或矩阵。</p><p><strong>数据类型：</strong> <code>single</code> | <code>double</code> | <code>int8</code> | <code>int16</code> | <code>int32</code> | <code>int64</code> | <code>uint8</code> | <code>uint16</code> | <code>uint32</code> | <code>uint64</code> | <code>categorical</code> | <code>datetime</code> | <code>duration</code></p><h3 id="LineSpec-线型、标记和颜色-字符向量-字符串"><a href="#LineSpec-线型、标记和颜色-字符向量-字符串" class="headerlink" title="LineSpec - 线型、标记和颜色 字符向量 | 字符串"></a><code>LineSpec</code> - 线型、标记和颜色 字符向量 | 字符串</h3><p>线型、标记和颜色，指定为包含符号的字符向量或字符串。符号可以按任意顺序显示。您不需要同时指定所有三个特征（线型、标记和颜色）。例如，如果忽略线型，只指定标记，则绘图只显示标记，不显示线条。</p><p><strong>示例：</strong> <code>&#39;--or&#39;</code> 是带有圆形标记的红色虚线</p><div class="table-container"><table><thead><tr><th style="text-align:left">线型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">实线</td></tr><tr><td style="text-align:left"><code>--</code></td><td style="text-align:left">虚线</td></tr><tr><td style="text-align:left"><code>:</code></td><td style="text-align:left">点线</td></tr><tr><td style="text-align:left"><code>-.</code></td><td style="text-align:left">点划线</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">标记</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;o&#39;</code></td><td style="text-align:left">圆圈</td></tr><tr><td style="text-align:left"><code>&#39;+&#39;</code></td><td style="text-align:left">加号</td></tr><tr><td style="text-align:left"><code>&#39;*&#39;</code></td><td style="text-align:left">星号</td></tr><tr><td style="text-align:left"><code>&#39;.&#39;</code></td><td style="text-align:left">点</td></tr><tr><td style="text-align:left"><code>&#39;x&#39;</code></td><td style="text-align:left">叉号</td></tr><tr><td style="text-align:left"><code>&#39;_&#39;</code></td><td style="text-align:left">水平线条</td></tr><tr><td style="text-align:left">`’</td><td style="text-align:left">‘`</td><td>垂直线条</td></tr><tr><td style="text-align:left"><code>&#39;s&#39;</code></td><td style="text-align:left">方形</td></tr><tr><td style="text-align:left"><code>&#39;d&#39;</code></td><td style="text-align:left">菱形</td></tr><tr><td style="text-align:left"><code>&#39;^&#39;</code></td><td style="text-align:left">上三角</td></tr><tr><td style="text-align:left"><code>&#39;v&#39;</code></td><td style="text-align:left">下三角</td></tr><tr><td style="text-align:left"><code>&#39;&gt;&#39;</code></td><td style="text-align:left">右三角</td></tr><tr><td style="text-align:left"><code>&#39;&lt;&#39;</code></td><td style="text-align:left">左三角</td></tr><tr><td style="text-align:left"><code>&#39;p&#39;</code></td><td style="text-align:left">五角形</td></tr><tr><td style="text-align:left"><code>&#39;h&#39;</code></td><td style="text-align:left">六角形</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">颜色</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>y</code></td><td style="text-align:left">黄色</td></tr><tr><td style="text-align:left"><code>m</code></td><td style="text-align:left">品红色</td></tr><tr><td style="text-align:left"><code>c</code></td><td style="text-align:left">青蓝色</td></tr><tr><td style="text-align:left"><code>r</code></td><td style="text-align:left">红色</td></tr><tr><td style="text-align:left"><code>g</code></td><td style="text-align:left">绿色</td></tr><tr><td style="text-align:left"><code>b</code></td><td style="text-align:left">蓝色</td></tr><tr><td style="text-align:left"><code>w</code></td><td style="text-align:left">白色</td></tr><tr><td style="text-align:left"><code>k</code></td><td style="text-align:left">黑色</td></tr></tbody></table></div><h3 id="ax-目标坐标区-Axes-对象-PolarAxes-对象-GeographicAxes-对象"><a href="#ax-目标坐标区-Axes-对象-PolarAxes-对象-GeographicAxes-对象" class="headerlink" title="ax - 目标坐标区 Axes 对象 | PolarAxes 对象 | GeographicAxes 对象"></a><code>ax</code> - 目标坐标区 <code>Axes</code> 对象 | <code>PolarAxes</code> 对象 | <code>GeographicAxes</code> 对象</h3><p>目标坐标区，指定为 <code>Axes</code> 对象、<code>PolarAxes</code> 对象或 <code>GeographicAxes</code> 对象。如果不指定坐标区或当前坐标区是笛卡尔坐标区，<code>plot</code> 函数将使用当前坐标区。要在极坐标区上绘图，请指定 <code>PolarAxes</code> 对象作为第一个输入参数，或者使用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/polarplot.html"><code>polarplot</code></a> 函数。要在地理坐标区上绘图，请指定 <code>GeographicAxes</code> 对象作为第一个输入参数，或者使用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/geoplot.html"><code>geoplot</code></a> 函数。</p><h3 id="名称-值对组参数"><a href="#名称-值对组参数" class="headerlink" title="名称-值对组参数"></a>名称-值对组参数</h3><p>指定可选的、以逗号分隔的 <code>Name,Value</code> 对组参数。<code>Name</code> 为参数名称，<code>Value</code> 为对应的值。<code>Name</code> 必须放在引号中。您可采用任意顺序指定多个名称-值对组参数，如 <code>Name1,Value1,...,NameN,ValueN</code> 所示。</p><p><strong>示例：</strong> <code>&#39;Marker&#39;,&#39;o&#39;,&#39;MarkerFaceColor&#39;,&#39;red&#39;</code></p><p>此处列出的图形线条属性只是一个子集。有关完整列表，请参阅 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">Line 属性</a>。</p><h3 id="39-Color-39-线条颜色-0-0-4470-0-7410-（默认）-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…"><a href="#39-Color-39-线条颜色-0-0-4470-0-7410-（默认）-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…" class="headerlink" title="&#39;Color&#39; - 线条颜色 [0 0.4470 0.7410] （默认） | RGB 三元组 | 十六进制颜色代码 | &#39;r&#39; | &#39;g&#39; | &#39;b&#39; | …"></a><code>&#39;Color&#39;</code> - 线条颜色 <code>[0 0.4470 0.7410]</code> （默认） | RGB 三元组 | 十六进制颜色代码 | <code>&#39;r&#39;</code> | <code>&#39;g&#39;</code> | <code>&#39;b&#39;</code> | …</h3><p>线条颜色，指定为 RGB 三元组、十六进制颜色代码、颜色名称或短名称。</p><p>对于自定义颜色，请指定 RGB 三元组或十六进制颜色代码。</p><ul><li>RGB 三元组是包含三个元素的行向量，其元素分别指定颜色中红、绿、蓝分量的强度。强度值必须位于 <code>[0,1]</code> 范围内，例如 <code>[0.4 0.6 0.7]</code>。</li><li>十六进制颜色代码是字符向量或字符串标量，以井号 (<code>#</code>) 开头，后跟三个或六个十六进制数字，范围可以是 <code>0</code> 到 <code>F</code>。这些值不区分大小写。因此，颜色代码 <code>&#39;#FF8800&#39;</code> 与 <code>&#39;#ff8800&#39;</code>、<code>&#39;#F80&#39;</code> 与 <code>&#39;#f80&#39;</code> 是等效的。</li></ul><p>此外，还可以按名称指定一些常见的颜色。下表列出了命名颜色选项、等效 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">颜色名称</th><th style="text-align:left">短名称</th><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;red&#39;</code></td><td style="text-align:left"><code>&#39;r&#39;</code></td><td style="text-align:left"><code>[1 0 0]</code></td><td style="text-align:left"><code>&#39;#FF0000&#39;</code></td><td style="text-align:left"><img src="hg_red.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;green&#39;</code></td><td style="text-align:left"><code>&#39;g&#39;</code></td><td style="text-align:left"><code>[0 1 0]</code></td><td style="text-align:left"><code>&#39;#00FF00&#39;</code></td><td style="text-align:left"><img src="hg_green.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;blue&#39;</code></td><td style="text-align:left"><code>&#39;b&#39;</code></td><td style="text-align:left"><code>[0 0 1]</code></td><td style="text-align:left"><code>&#39;#0000FF&#39;</code></td><td style="text-align:left"><img src="hg_blue.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;cyan&#39;</code></td><td style="text-align:left"><code>&#39;c&#39;</code></td><td style="text-align:left"><code>[0 1 1]</code></td><td style="text-align:left"><code>&#39;#00FFFF&#39;</code></td><td style="text-align:left"><img src="hg_cyan.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;magenta&#39;</code></td><td style="text-align:left"><code>&#39;m&#39;</code></td><td style="text-align:left"><code>[1 0 1]</code></td><td style="text-align:left"><code>&#39;#FF00FF&#39;</code></td><td style="text-align:left"><img src="hg_magenta.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;yellow&#39;</code></td><td style="text-align:left"><code>&#39;y&#39;</code></td><td style="text-align:left"><code>[1 1 0]</code></td><td style="text-align:left"><code>&#39;#FFFF00&#39;</code></td><td style="text-align:left"><img src="hg_yellow.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;black&#39;</code></td><td style="text-align:left"><code>&#39;k&#39;</code></td><td style="text-align:left"><code>[0 0 0]</code></td><td style="text-align:left"><code>&#39;#000000&#39;</code></td><td style="text-align:left"><img src="hg_black.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;white&#39;</code></td><td style="text-align:left"><code>&#39;w&#39;</code></td><td style="text-align:left"><code>[1 1 1]</code></td><td style="text-align:left"><code>&#39;#FFFFFF&#39;</code></td><td style="text-align:left"><img src="hg_white.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">无颜色</td></tr></tbody></table></div><p>以下是 MATLAB® 在许多类型的绘图中使用的默认颜色的 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>[0 0.4470 0.7410]</code></td><td style="text-align:left"><code>&#39;#0072BD&#39;</code></td><td style="text-align:left"><img src="colororder1.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.8500 0.3250 0.0980]</code></td><td style="text-align:left"><code>&#39;#D95319&#39;</code></td><td style="text-align:left"><img src="colororder2.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.9290 0.6940 0.1250]</code></td><td style="text-align:left"><code>&#39;#EDB120&#39;</code></td><td style="text-align:left"><img src="colororder3.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4940 0.1840 0.5560]</code></td><td style="text-align:left"><code>&#39;#7E2F8E&#39;</code></td><td style="text-align:left"><img src="colororder4.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4660 0.6740 0.1880]</code></td><td style="text-align:left"><code>&#39;#77AC30&#39;</code></td><td style="text-align:left"><img src="colororder5.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.3010 0.7450 0.9330]</code></td><td style="text-align:left"><code>&#39;#4DBEEE&#39;</code></td><td style="text-align:left"><img src="colororder6.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.6350 0.0780 0.1840]</code></td><td style="text-align:left"><code>&#39;#A2142F&#39;</code></td><td style="text-align:left"><img src="colororder7.png" alt="img"></td></tr></tbody></table></div><p><strong>示例：</strong> <code>&#39;blue&#39;</code></p><p><strong>示例：</strong> <code>[0 0 1]</code></p><p><strong>示例：</strong> <code>&#39;#0000FF&#39;</code></p><h3 id="39-LineStyle-39-线型-39-39-（默认）-39-39-39-39-39-39-39-none-39"><a href="#39-LineStyle-39-线型-39-39-（默认）-39-39-39-39-39-39-39-none-39" class="headerlink" title="&#39;LineStyle&#39; - 线型 &#39;-&#39; （默认） | &#39;--&#39; | &#39;:&#39; | &#39;-.&#39; | &#39;none&#39;"></a><code>&#39;LineStyle&#39;</code> - 线型 <code>&#39;-&#39;</code> （默认） | <code>&#39;--&#39;</code> | <code>&#39;:&#39;</code> | <code>&#39;-.&#39;</code> | <code>&#39;none&#39;</code></h3><p>线型，指定为下表中列出的选项之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">线型</th><th style="text-align:left">说明</th><th style="text-align:left">表示的线条</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;-&#39;</code></td><td style="text-align:left">实线</td><td style="text-align:left"><img src="linestyle_solid.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;--&#39;</code></td><td style="text-align:left">虚线</td><td style="text-align:left"><img src="linestyle_dashed.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;:&#39;</code></td><td style="text-align:left">点线</td><td style="text-align:left"><img src="linestyle_dotted.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;-.&#39;</code></td><td style="text-align:left">点划线</td><td style="text-align:left"><img src="linestyle_dashdotted.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">无线条</td><td style="text-align:left">无线条</td></tr></tbody></table></div><h3 id="39-LineWidth-39-线条宽度-0-5-（默认）-正值"><a href="#39-LineWidth-39-线条宽度-0-5-（默认）-正值" class="headerlink" title="&#39;LineWidth&#39; - 线条宽度 0.5 （默认） | 正值"></a><code>&#39;LineWidth&#39;</code> - 线条宽度 <code>0.5</code> （默认） | 正值</h3><p>线宽，指定为以磅为单位的正值，其中 1 磅 = 1/72 英寸。如果该线条具有标记，则线条宽度也会影响标记边。</p><p>线宽不能小于像素的宽度。如果将线宽设置为小于系统上像素宽度的值，则线条显示为一个像素的宽度。</p><h3 id="39-Marker-39-标记符号-39-none-39-（默认）-39-o-39-39-39-39-39-39-39-…"><a href="#39-Marker-39-标记符号-39-none-39-（默认）-39-o-39-39-39-39-39-39-39-…" class="headerlink" title="&#39;Marker&#39; - 标记符号 &#39;none&#39; （默认） | &#39;o&#39; | &#39;+&#39; | &#39;*&#39; | &#39;.&#39; | …"></a><code>&#39;Marker&#39;</code> - 标记符号 <code>&#39;none&#39;</code> （默认） | <code>&#39;o&#39;</code> | <code>&#39;+&#39;</code> | <code>&#39;*&#39;</code> | <code>&#39;.&#39;</code> | …</h3><p>标记符号，指定为下表中列出的值之一。默认情况下，对象不显示标记。指定标记符号可在每个数据点或顶点添加标记。</p><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;o&#39;</code></td><td style="text-align:left">圆圈</td></tr><tr><td style="text-align:left"><code>&#39;+&#39;</code></td><td style="text-align:left">加号</td></tr><tr><td style="text-align:left"><code>&#39;*&#39;</code></td><td style="text-align:left">星号</td></tr><tr><td style="text-align:left"><code>&#39;.&#39;</code></td><td style="text-align:left">点</td></tr><tr><td style="text-align:left"><code>&#39;x&#39;</code></td><td style="text-align:left">叉号</td></tr><tr><td style="text-align:left"><code>&#39;_&#39;</code></td><td style="text-align:left">水平线条</td></tr><tr><td style="text-align:left">`’</td><td style="text-align:left">‘`</td><td>垂直线条</td></tr><tr><td style="text-align:left"><code>&#39;square&#39;</code> 或 <code>&#39;s&#39;</code></td><td style="text-align:left">方形</td></tr><tr><td style="text-align:left"><code>&#39;diamond&#39;</code> 或 <code>&#39;d&#39;</code></td><td style="text-align:left">菱形</td></tr><tr><td style="text-align:left"><code>&#39;^&#39;</code></td><td style="text-align:left">上三角</td></tr><tr><td style="text-align:left"><code>&#39;v&#39;</code></td><td style="text-align:left">下三角</td></tr><tr><td style="text-align:left"><code>&#39;&gt;&#39;</code></td><td style="text-align:left">右三角</td></tr><tr><td style="text-align:left"><code>&#39;&lt;&#39;</code></td><td style="text-align:left">左三角</td></tr><tr><td style="text-align:left"><code>&#39;pentagram&#39;</code> 或 <code>&#39;p&#39;</code></td><td style="text-align:left">五角星（五角形）</td></tr><tr><td style="text-align:left"><code>&#39;hexagram&#39;</code> 或 <code>&#39;h&#39;</code></td><td style="text-align:left">六角星（六角形）</td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">无标记</td></tr></tbody></table></div><h3 id="39-MarkerIndices-39-要显示标记的数据点的索引-1-length-YData-（默认）-正整数向量-正整数标量"><a href="#39-MarkerIndices-39-要显示标记的数据点的索引-1-length-YData-（默认）-正整数向量-正整数标量" class="headerlink" title="&#39;MarkerIndices&#39; - 要显示标记的数据点的索引 1:length(YData) （默认） | 正整数向量 | 正整数标量"></a><code>&#39;MarkerIndices&#39;</code> - 要显示标记的数据点的索引 <code>1:length(YData)</code> （默认） | 正整数向量 | 正整数标量</h3><p>要显示标记的数据点的索引，指定为正整数向量。如果不指定索引，MATLAB 将在每个数据点显示一个标记。</p><p><strong>注意</strong></p><p>要查看标记，还必须指定标记符号。</p><p><strong>示例：</strong> <code>plot(x,y,&#39;-o&#39;,&#39;MarkerIndices&#39;,[1 5 10])</code> 在第一、第五和第十个数据点处显示圆形标记。</p><p><strong>示例：</strong> <code>plot(x,y,&#39;-x&#39;,&#39;MarkerIndices&#39;,1:3:length(y))</code> 每隔三个数据点显示一个交叉标记。</p><p><strong>示例：</strong> <code>plot(x,y,&#39;Marker&#39;,&#39;square&#39;,&#39;MarkerIndices&#39;,5)</code> 在第五个数据点显示一个正方形标记。</p><h3 id="39-MarkerEdgeColor-39-标记轮廓颜色-39-auto-39-（默认）-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…"><a href="#39-MarkerEdgeColor-39-标记轮廓颜色-39-auto-39-（默认）-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…" class="headerlink" title="&#39;MarkerEdgeColor&#39; - 标记轮廓颜色 &#39;auto&#39; （默认） | RGB 三元组 | 十六进制颜色代码 | &#39;r&#39; | &#39;g&#39; | &#39;b&#39; | …"></a><code>&#39;MarkerEdgeColor&#39;</code> - 标记轮廓颜色 <code>&#39;auto&#39;</code> （默认） | RGB 三元组 | 十六进制颜色代码 | <code>&#39;r&#39;</code> | <code>&#39;g&#39;</code> | <code>&#39;b&#39;</code> | …</h3><p>标记轮廓颜色，指定为 <code>&#39;auto&#39;</code>、RGB 三元组、十六进制颜色代码、颜色名称或短名称。默认值 <code>&#39;auto&#39;</code> 使用与 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/plot.html?searchHighlight=plot&amp;s_tid=doc_srchtitle#btzitot-Color"><code>Color</code></a> 属性相同的颜色。</p><p>对于自定义颜色，请指定 RGB 三元组或十六进制颜色代码。</p><ul><li>RGB 三元组是包含三个元素的行向量，其元素分别指定颜色中红、绿、蓝分量的强度。强度值必须位于 <code>[0,1]</code> 范围内，例如 <code>[0.4 0.6 0.7]</code>。</li><li>十六进制颜色代码是字符向量或字符串标量，以井号 (<code>#</code>) 开头，后跟三个或六个十六进制数字，范围可以是 <code>0</code> 到 <code>F</code>。这些值不区分大小写。因此，颜色代码 <code>&#39;#FF8800&#39;</code> 与 <code>&#39;#ff8800&#39;</code>、<code>&#39;#F80&#39;</code> 与 <code>&#39;#f80&#39;</code> 是等效的。</li></ul><p>此外，还可以按名称指定一些常见的颜色。下表列出了命名颜色选项、等效 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">颜色名称</th><th style="text-align:left">短名称</th><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;red&#39;</code></td><td style="text-align:left"><code>&#39;r&#39;</code></td><td style="text-align:left"><code>[1 0 0]</code></td><td style="text-align:left"><code>&#39;#FF0000&#39;</code></td><td style="text-align:left"><img src="hg_red.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;green&#39;</code></td><td style="text-align:left"><code>&#39;g&#39;</code></td><td style="text-align:left"><code>[0 1 0]</code></td><td style="text-align:left"><code>&#39;#00FF00&#39;</code></td><td style="text-align:left"><img src="hg_green.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;blue&#39;</code></td><td style="text-align:left"><code>&#39;b&#39;</code></td><td style="text-align:left"><code>[0 0 1]</code></td><td style="text-align:left"><code>&#39;#0000FF&#39;</code></td><td style="text-align:left"><img src="hg_blue.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;cyan&#39;</code></td><td style="text-align:left"><code>&#39;c&#39;</code></td><td style="text-align:left"><code>[0 1 1]</code></td><td style="text-align:left"><code>&#39;#00FFFF&#39;</code></td><td style="text-align:left"><img src="hg_cyan.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;magenta&#39;</code></td><td style="text-align:left"><code>&#39;m&#39;</code></td><td style="text-align:left"><code>[1 0 1]</code></td><td style="text-align:left"><code>&#39;#FF00FF&#39;</code></td><td style="text-align:left"><img src="hg_magenta.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;yellow&#39;</code></td><td style="text-align:left"><code>&#39;y&#39;</code></td><td style="text-align:left"><code>[1 1 0]</code></td><td style="text-align:left"><code>&#39;#FFFF00&#39;</code></td><td style="text-align:left"><img src="hg_yellow.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;black&#39;</code></td><td style="text-align:left"><code>&#39;k&#39;</code></td><td style="text-align:left"><code>[0 0 0]</code></td><td style="text-align:left"><code>&#39;#000000&#39;</code></td><td style="text-align:left"><img src="hg_black.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;white&#39;</code></td><td style="text-align:left"><code>&#39;w&#39;</code></td><td style="text-align:left"><code>[1 1 1]</code></td><td style="text-align:left"><code>&#39;#FFFFFF&#39;</code></td><td style="text-align:left"><img src="hg_white.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">无颜色</td></tr></tbody></table></div><p>以下是 MATLAB 在许多类型的绘图中使用的默认颜色的 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>[0 0.4470 0.7410]</code></td><td style="text-align:left"><code>&#39;#0072BD&#39;</code></td><td style="text-align:left"><img src="colororder1.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.8500 0.3250 0.0980]</code></td><td style="text-align:left"><code>&#39;#D95319&#39;</code></td><td style="text-align:left"><img src="colororder2.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.9290 0.6940 0.1250]</code></td><td style="text-align:left"><code>&#39;#EDB120&#39;</code></td><td style="text-align:left"><img src="colororder3.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4940 0.1840 0.5560]</code></td><td style="text-align:left"><code>&#39;#7E2F8E&#39;</code></td><td style="text-align:left"><img src="colororder4.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4660 0.6740 0.1880]</code></td><td style="text-align:left"><code>&#39;#77AC30&#39;</code></td><td style="text-align:left"><img src="colororder5.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.3010 0.7450 0.9330]</code></td><td style="text-align:left"><code>&#39;#4DBEEE&#39;</code></td><td style="text-align:left"><img src="colororder6.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.6350 0.0780 0.1840]</code></td><td style="text-align:left"><code>&#39;#A2142F&#39;</code></td><td style="text-align:left"><img src="colororder7.png" alt="img"></td></tr></tbody></table></div><h3 id="39-MarkerFaceColor-39-标记填充颜色-39-none-39-（默认）-39-auto-39-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…"><a href="#39-MarkerFaceColor-39-标记填充颜色-39-none-39-（默认）-39-auto-39-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…" class="headerlink" title="&#39;MarkerFaceColor&#39; - 标记填充颜色 &#39;none&#39; （默认） | &#39;auto&#39; | RGB 三元组 | 十六进制颜色代码 | &#39;r&#39; | &#39;g&#39; | &#39;b&#39; | …"></a><code>&#39;MarkerFaceColor&#39;</code> - 标记填充颜色 <code>&#39;none&#39;</code> （默认） | <code>&#39;auto&#39;</code> | RGB 三元组 | 十六进制颜色代码 | <code>&#39;r&#39;</code> | <code>&#39;g&#39;</code> | <code>&#39;b&#39;</code> | …</h3><p>标记填充颜色，指定为 <code>&#39;auto&#39;</code>、RGB 三元组、十六进制颜色代码、颜色名称或短名称。<code>&#39;auto&#39;</code> 选项使用与父坐标区的 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.axis.axes-properties.html#budumk7-Color"><code>Color</code></a> 属性相同的颜色。如果您指定 <code>&#39;auto&#39;</code>，并且坐标区图框不可见，则标记填充颜色为图窗的颜色。</p><p>对于自定义颜色，请指定 RGB 三元组或十六进制颜色代码。</p><ul><li>RGB 三元组是包含三个元素的行向量，其元素分别指定颜色中红、绿、蓝分量的强度。强度值必须位于 <code>[0,1]</code> 范围内，例如 <code>[0.4 0.6 0.7]</code>。</li><li>十六进制颜色代码是字符向量或字符串标量，以井号 (<code>#</code>) 开头，后跟三个或六个十六进制数字，范围可以是 <code>0</code> 到 <code>F</code>。这些值不区分大小写。因此，颜色代码 <code>&#39;#FF8800&#39;</code> 与 <code>&#39;#ff8800&#39;</code>、<code>&#39;#F80&#39;</code> 与 <code>&#39;#f80&#39;</code> 是等效的。</li></ul><p>此外，还可以按名称指定一些常见的颜色。下表列出了命名颜色选项、等效 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">颜色名称</th><th style="text-align:left">短名称</th><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;red&#39;</code></td><td style="text-align:left"><code>&#39;r&#39;</code></td><td style="text-align:left"><code>[1 0 0]</code></td><td style="text-align:left"><code>&#39;#FF0000&#39;</code></td><td style="text-align:left"><img src="hg_red.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;green&#39;</code></td><td style="text-align:left"><code>&#39;g&#39;</code></td><td style="text-align:left"><code>[0 1 0]</code></td><td style="text-align:left"><code>&#39;#00FF00&#39;</code></td><td style="text-align:left"><img src="hg_green.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;blue&#39;</code></td><td style="text-align:left"><code>&#39;b&#39;</code></td><td style="text-align:left"><code>[0 0 1]</code></td><td style="text-align:left"><code>&#39;#0000FF&#39;</code></td><td style="text-align:left"><img src="hg_blue.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;cyan&#39;</code></td><td style="text-align:left"><code>&#39;c&#39;</code></td><td style="text-align:left"><code>[0 1 1]</code></td><td style="text-align:left"><code>&#39;#00FFFF&#39;</code></td><td style="text-align:left"><img src="hg_cyan.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;magenta&#39;</code></td><td style="text-align:left"><code>&#39;m&#39;</code></td><td style="text-align:left"><code>[1 0 1]</code></td><td style="text-align:left"><code>&#39;#FF00FF&#39;</code></td><td style="text-align:left"><img src="hg_magenta.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;yellow&#39;</code></td><td style="text-align:left"><code>&#39;y&#39;</code></td><td style="text-align:left"><code>[1 1 0]</code></td><td style="text-align:left"><code>&#39;#FFFF00&#39;</code></td><td style="text-align:left"><img src="hg_yellow.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;black&#39;</code></td><td style="text-align:left"><code>&#39;k&#39;</code></td><td style="text-align:left"><code>[0 0 0]</code></td><td style="text-align:left"><code>&#39;#000000&#39;</code></td><td style="text-align:left"><img src="hg_black.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;white&#39;</code></td><td style="text-align:left"><code>&#39;w&#39;</code></td><td style="text-align:left"><code>[1 1 1]</code></td><td style="text-align:left"><code>&#39;#FFFFFF&#39;</code></td><td style="text-align:left"><img src="hg_white.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">无颜色</td></tr></tbody></table></div><p>以下是 MATLAB 在许多类型的绘图中使用的默认颜色的 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>[0 0.4470 0.7410]</code></td><td style="text-align:left"><code>&#39;#0072BD&#39;</code></td><td style="text-align:left"><img src="colororder1.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.8500 0.3250 0.0980]</code></td><td style="text-align:left"><code>&#39;#D95319&#39;</code></td><td style="text-align:left"><img src="colororder2.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.9290 0.6940 0.1250]</code></td><td style="text-align:left"><code>&#39;#EDB120&#39;</code></td><td style="text-align:left"><img src="colororder3.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4940 0.1840 0.5560]</code></td><td style="text-align:left"><code>&#39;#7E2F8E&#39;</code></td><td style="text-align:left"><img src="colororder4.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4660 0.6740 0.1880]</code></td><td style="text-align:left"><code>&#39;#77AC30&#39;</code></td><td style="text-align:left"><img src="colororder5.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.3010 0.7450 0.9330]</code></td><td style="text-align:left"><code>&#39;#4DBEEE&#39;</code></td><td style="text-align:left"><img src="colororder6.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.6350 0.0780 0.1840]</code></td><td style="text-align:left"><code>&#39;#A2142F&#39;</code></td><td style="text-align:left"><img src="colororder7.png" alt="img"></td></tr></tbody></table></div><h3 id="39-MarkerSize-39-标记大小-6-（默认）-正值"><a href="#39-MarkerSize-39-标记大小-6-（默认）-正值" class="headerlink" title="&#39;MarkerSize&#39; - 标记大小 6 （默认） | 正值"></a><code>&#39;MarkerSize&#39;</code> - 标记大小 <code>6</code> （默认） | 正值</h3><p>标记大小，指定为以磅为单位的正值，其中 1 磅 = 1/72 英寸。</p><h3 id="39-DatetimeTickFormat-39-datetime-刻度标签的格式-字符向量-字符串"><a href="#39-DatetimeTickFormat-39-datetime-刻度标签的格式-字符向量-字符串" class="headerlink" title="&#39;DatetimeTickFormat&#39; - datetime 刻度标签的格式 字符向量 | 字符串"></a><code>&#39;DatetimeTickFormat&#39;</code> - <code>datetime</code> 刻度标签的格式 字符向量 | 字符串</h3><p><code>datetime</code> 刻度标签的格式，指定为以逗号分隔的对组，该对组由 <code>&#39;DatetimeTickFormat&#39;</code> 和一个包含日期格式的字符向量或字符串组成。可使用字母 <code>A-Z</code> 和 <code>a-z</code> 构造一个自定义格式。这些字母对应于日期的 Unicode® 区域设置数据标记语言 (LDML) 标准。可以使用连字符、空格或冒号等非 ASCII 字母字符来分隔字段。</p><p>如果未为 <code>&#39;DatetimeTickFormat&#39;</code> 指定值，则 <code>plot</code> 将基于坐标轴范围自动优化和更新刻度标签。</p><p>下表列举了多种常见的显示格式和纽约市 2014 年 4 月 19 日（星期六）下午 9:41:06 的格式化输出示例。</p><div class="table-container"><table><thead><tr><th style="text-align:left"><code>DatetimeTickFormat</code> 的值</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;yyyy-MM-dd&#39;</code></td><td style="text-align:left"><code>2014-04-19</code></td></tr><tr><td style="text-align:left"><code>&#39;dd/MM/yyyy&#39;</code></td><td style="text-align:left"><code>19/04/2014</code></td></tr><tr><td style="text-align:left"><code>&#39;dd.MM.yyyy&#39;</code></td><td style="text-align:left"><code>19.04.2014</code></td></tr><tr><td style="text-align:left"><code>&#39;yyyy年 MM月 dd日&#39;</code></td><td style="text-align:left"><code>2014年 04月 19日</code></td></tr><tr><td style="text-align:left"><code>&#39;MMMM d, yyyy&#39;</code></td><td style="text-align:left"><code>April 19, 2014</code></td></tr><tr><td style="text-align:left"><code>&#39;eeee, MMMM d, yyyy HH:mm:ss&#39;</code></td><td style="text-align:left"><code>Saturday, April 19, 2034 21:41:06</code></td></tr><tr><td style="text-align:left"><code>&#39;MMMM d, yyyy HH:mm:ss Z&#39;</code></td><td style="text-align:left"><code>April 32, 2023 11:45:14 -0400</code></td></tr></tbody></table></div><p>有关有效字母标识符的完整列表，请参阅日期时间数组的 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/datetime.html#buhzxmk-1-Format"><code>Format</code></a> 属性。</p><p><code>DatetimeTickFormat</code> 不是图形线条属性。创建绘图时，必须使用名称-值对组参数设置刻度格式。或者，使用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/xtickformat.html"><code>xtickformat</code></a> 和 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/ytickformat.html"><code>ytickformat</code></a> 函数设置格式。</p><p>日期时间标尺的 <code>TickLabelFormat</code> 属性存储格式。</p><h3 id="39-DurationTickFormat-39-duration-刻度标签的格式-字符向量-字符串"><a href="#39-DurationTickFormat-39-duration-刻度标签的格式-字符向量-字符串" class="headerlink" title="&#39;DurationTickFormat&#39; - duration 刻度标签的格式 字符向量 | 字符串"></a><code>&#39;DurationTickFormat&#39;</code> - <code>duration</code> 刻度标签的格式 字符向量 | 字符串</h3><p><code>duration</code> 刻度标签的格式，指定为以逗号分隔的对组，该对组由 <code>&#39;DurationTickFormat&#39;</code> 和一个包含持续时间格式的字符向量或字符串组成。</p><p>如果未为 <code>&#39;DurationTickFormat&#39;</code> 指定值，则 <code>plot</code> 将基于坐标轴范围自动优化和更新刻度标签。</p><p>要将持续时间显示为包含小数部分的单个数字，例如 1.234 小时，请指定下表中的值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left"><code>DurationTickFormat</code> 的值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;y&#39;</code></td><td style="text-align:left">精确定长年的数目。固定长度的一年等于 365.2425 天。</td></tr><tr><td style="text-align:left"><code>&#39;d&#39;</code></td><td style="text-align:left">精确定长天的数目。固定长度的一天等于 24 小时。</td></tr><tr><td style="text-align:left"><code>&#39;h&#39;</code></td><td style="text-align:left">小时数</td></tr><tr><td style="text-align:left"><code>&#39;m&#39;</code></td><td style="text-align:left">分钟数</td></tr><tr><td style="text-align:left"><code>&#39;s&#39;</code></td><td style="text-align:left">秒数</td></tr></tbody></table></div><p><strong>示例：</strong> <code>&#39;DurationTickFormat&#39;,&#39;d&#39;</code> 以固定长度的天数显示持续时间值。</p><p>要以数字计时器的形式显示持续时间，请指定下列值之一。</p><ul><li><code>&#39;dd:hh:mm:ss&#39;</code></li><li><code>&#39;hh:mm:ss&#39;</code></li><li><code>&#39;mm:ss&#39;</code></li><li><code>&#39;hh:mm&#39;</code></li></ul><p>此外，可以通过附加多达 9 个 <code>S</code> 字符显示多达 9 位小数的秒位。</p><p><strong>示例：</strong> <code>&#39;DurationTickFormat&#39;,&#39;hh:mm:ss.SSS&#39;</code> 以三位数显示持续时间的毫秒数。</p><p><code>DurationTickFormat</code> 不是图形线条属性。创建绘图时，必须使用名称-值对组参数设置刻度格式。或者，使用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/xtickformat.html"><code>xtickformat</code></a> 和 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/ytickformat.html"><code>ytickformat</code></a> 函数设置格式。</p><p>持续时间标尺的 <code>TickLabelFormat</code> 属性存储格式。</p><h3 id="h-一个或多个图形线条对象-标量-向量"><a href="#h-一个或多个图形线条对象-标量-向量" class="headerlink" title="h - 一个或多个图形线条对象 标量 | 向量"></a><code>h</code> - 一个或多个图形线条对象 标量 | 向量</h3><p>一个或多个图形线条对象，以标量或向量的形式返回。这些是唯一标识符，可以用来查询和修改特定图形线条的属性。有关属性列表，请参阅 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">Line 属性</a>。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><p>使用 <code>NaN</code> 和 <code>Inf</code> 值将行断开。例如，以下代码绘制前两个元素，跳过第三个元素，并使用最后两个元素绘制另一线条：</p><pre class="line-numbers language-none"><code class="language-none">plot([1,2,NaN,4,5])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ul><li><p><code>plot</code> 基于坐标区的 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.axis.axes-properties.html#budumk7_sep_shared-ColorOrder"><code>ColorOrder</code></a> 和 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.axis.axes-properties.html#budumk7_sep_shared-LineStyleOrder"><code>LineStyleOrder</code></a> 属性选用颜色和线型。<code>plot</code> 先对第一种线型依序使用每种颜色，直至用尽。然后，再对下一个线型依序使用每种颜色，以此类推。</p><p>从 R2019b 开始，通过在坐标区中设置 <code>ColorOrder</code> 或 <code>LineStyleOrder</code> 属性，可以在绘图后更改颜色和线型。可以调用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/colororder.html"><code>colororder</code></a> 函数来更改图窗中所有坐标区的色序。</p></li></ul><h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><h3 id="tall-数组-对行数太多而无法放入内存的数组进行计算。"><a href="#tall-数组-对行数太多而无法放入内存的数组进行计算。" class="headerlink" title="tall 数组 对行数太多而无法放入内存的数组进行计算。"></a>tall 数组 对行数太多而无法放入内存的数组进行计算。</h3><p>用法说明和限制：</p><ul><li>对于 tall 数组 <code>X</code> 和 <code>Y</code>，支持的语法包括：<ul><li><code>plot(X,Y)</code></li><li><code>plot(Y)</code></li><li><code>plot(___,LineSpec)</code></li><li><code>plot(___,Name,Value)</code></li><li><code>plot(ax,___)</code></li></ul></li><li><code>X</code> 必须为单调递增顺序。</li><li>不支持分类输入。</li><li>tall 输入必须为实数列向量。</li><li>处理 tall 数组时，<code>plot</code> 函数将以迭代方式逐步绘图，一边读取数据，一边添加到绘图中。在更新过程中，进度指示条显示已绘制数据的比例。在绘图完成之前，支持在更新过程中进行缩放和平移。要停止更新过程，请按进度指示条中的暂停按钮。</li></ul><p>（from MathWork）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快捷高数教程（1）</title>
      <link href="/2023/06/06/%E5%BF%AB%E6%8D%B7%E9%AB%98%E6%95%B0%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/06/06/%E5%BF%AB%E6%8D%B7%E9%AB%98%E6%95%B0%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学教程笔记1"><a href="#高等数学教程笔记1" class="headerlink" title="高等数学教程笔记1"></a>高等数学教程笔记1</h1><h2 id="极限运算与函数分析基础"><a href="#极限运算与函数分析基础" class="headerlink" title="极限运算与函数分析基础"></a>极限运算与函数分析基础</h2><h4 id="函数与极限"><a href="#函数与极限" class="headerlink" title="函数与极限"></a>函数与极限</h4><p>函数部分主要是奠基于高中的一些基础，这里做一些简单的复习</p><p>1.映射与函数</p><p>首先来了解以下映射：4</p><p>​        先定义X，Y是两个非空集合。现在有一个法则f，使得X中的每个元素$x$（$X$={$x_0$,$x_1$,$x_2$,…}）,都有<strong>唯一</strong>的y($Y$={$y_0$,$y_1$,$y_2$,$y_3$,…})与之对应。那么，我们称f是一个<strong>映射</strong>。</p><p>​        也就是说，这个定义是围绕f的。他是一个这样的法则（或者说规则）让两个非空的集合建立起如定义所言的联系，仅此而已。</p><p>​        也不必太过担心，映射在这本笔记里大概不会再次出现了。</p><p>不过，我们把它引出来必有我们的目的：回过头来，我们实际上用一大长串定义干了这样一件事：</p><script type="math/tex; mode=display">{X}\xrightarrow{f}Y</script><p>现在，让我们开始取其名字：</p><p>X：是一个定义域，有写法D,或者写法更明确一些：$D_f$</p><p>实际上这是Domain的意思</p><p>Y：是一个值域，有写法R,或者同样更明确一些：$R_f$</p><p>实际上这是Range的意思。</p><p>至于：f，我们刚刚讲过了，这就是一个法则，表明一种对应关系。</p><p>依然有这样的更简单的写法：</p><script type="math/tex; mode=display">X\xrightarrow{f}R_f</script><p>重复一些以下的要点：</p><p>（1）上述定义阐述了三要素：X（定义域），f(法则)，Rf(对应值域)</p><p>（2）对于x属于X这回事，对应的y是唯一的。不可以又对应y1同时对应y2.</p><p>Q:可以多个x对应一个y吗？可以！事实上，用图片表示是这样的：</p><p><img src="image-20221226141035208.png" alt="image-20221226141035208"></p><p>（3）Rf属于Y，但不是Y！！！但特别的：当Rf=Y下，我们又称这样厉害的f叫满射。</p><p>（4）在众多的映射中，还有一种特殊的映射：单射。人话就是一一对应</p><p>（5）那么，又是单射又是满射如何？这又有名字：一一映射（一夫一妻）因为必须全部对应且一一对应。</p><p>正过来叫映射，倒过来又如何？</p><p>设 f有如下关系：</p><script type="math/tex; mode=display">X\longrightarrow{Y}</script><p>是一个单射，那么，我们可以倒过来：对于Y属于Rf而言都有唯一的一个$x$属于$X$.这又是一组对应关系，不过是倒过来的。记作如下：</p><script type="math/tex; mode=display">g:R_f\longrightarrow{X}</script><p>这样看不出什么联系，我们采用与 f 相关的表示：</p><script type="math/tex; mode=display">f^-1:D_{f^-1}\longrightarrow{D_f}</script><p>好吧，太复杂了，好好回味一下，我们继续折磨：</p><p>现在我们来看这样一个内容：</p><p>在学习完映射之后，我们来看这样的一个D(定义域),且</p><script type="math/tex; mode=display">D\subset{R}</script><p>换而言之，这个数集是R里的一部分，而f是一个使得：</p><script type="math/tex; mode=display">f:D\longrightarrow{R}</script><p>的映射。</p><p>那么，这样来看我们构造了一个映射使得一个实数集映射到了另一个实数集上。这样的映射有一个大家熟悉的名字：函数，简记作：</p><script type="math/tex; mode=display">y=f(x),x\in{D}</script><p>这下看懂了：</p><p>x是一个自变量，y是一个因变量 ，定义域为D，值域是R（不是实数集的R！！！）</p><p>构成一个函数的两要素，就可以从动态的角度来看了，这使得我们信息的表达可以更为浓缩：$D_f$ ,$ f$ 就可以了</p><p>函数的表达有三种：表格法，图形法，解析法。这个是大家高中就已经熟知的了</p><p>说完了定义和表示，我们来看一个函数最广泛的几个性质：</p><h4 id="1-有界性"><a href="#1-有界性" class="headerlink" title="1.有界性"></a>1.有界性</h4><p>听名字就知道：表明的是一些函数可能是有界限的。但这样的表达不规范。</p><p>仔细思考，函数的界限分为两种：不大于一个数和不小于一个数（当然，也可以说是小于一个数或者是大于一个数）</p><p>那么，我们说：对于总是一个小于一个数或者是不大于一个数的函数，我们说他有上界。表达是这样的：</p><script type="math/tex; mode=display">\exists{k_1},f(x)\leqslant{k_1}</script><p>这是什么东西呢？先别急，它还有另一个符号，也是在数学中相当常见的：$\exists$ , $\forall$</p><p>上面的两个符号，一个表示：存在；另一个表示任意。</p><p>那么，上界是唯一的吗？不是的。比如说：</p><script type="math/tex; mode=display">f(x)=x , x\in{(-\infty,1]}</script><p>这就有无穷个上界：可以是1，可以是2，可以是$\pi$…总而言之，并不唯一。</p><p>那么与之对应的，还会有一个下界：</p><script type="math/tex; mode=display">\exists{k_2} ,f(x)\geqslant{k_2}</script><p>我们说：对于总是一个大于一个数或者是不小于一个数的函数，我们说他有下界。</p><p>同样的，下界也不唯一。</p><p>这在我们后面证明极限的存在时是很有必要的！！！</p><p>统称起来，我们就可以说：函数是有界的：上下界都有！总而言之，这种情况称为有界的。反之，一个函数若是既没有上界有没有下界，或者是只有上界，或者是只有下界，则称这个函数无界。用数学符号定义有界是这样的：</p><script type="math/tex; mode=display">\exists M>0,|f(x)|\leqslant{M}</script><p>那么，无界的是这样定义的：</p><script type="math/tex; mode=display">\forall{M}>0,\exists x_1\in{x},|f(x)|>M</script><h4 id="2-单调性"><a href="#2-单调性" class="headerlink" title="2.单调性"></a>2.单调性</h4><p>这个性质是讨论函数的变化趋势的：是增加还是减少？我们用这个性质衡量：</p><p>当在一个区间里：</p><script type="math/tex; mode=display">x_1<x_2,f(x_1)<f(x_2)</script><p>这样的性质叫单调递增，</p><p>反之：</p><script type="math/tex; mode=display">x_1 < x_2,f( x_1 )>f( x_2 )</script><p>这样的性质叫单调递减，但是注意，这称之为严格单调，后面我们会讲述什么是严格单调什么是广义单调的。</p><h4 id="3-奇偶性"><a href="#3-奇偶性" class="headerlink" title="3.奇偶性"></a>3.奇偶性</h4><p>首先声明一点：我们的函数的定义域必须对称：也就是说：函数的$D_f$必须关于原点对称：</p><p>实数域$R$是对称的，$[-1,1]$是对称的，以此类推。当：$f(x)=f(-x)$时，我们称呼这样的函数是一个偶函数，反之：$f(-x)=-f(x)$或者$-f(-x)=f(x)$ 则称之为奇函数。</p><p>有趣的是：在图像法表达函数时：奇函数关于原点对称，偶函数关于$y$轴对称。</p><h4 id="4-周期性"><a href="#4-周期性" class="headerlink" title="4.周期性"></a>4.周期性</h4><p>有一些函数很有意思，伴随$x$的增大，我们甚至可以看到$f(x)$会有周期的重现。这时候，我们说这个函数具有周期性，用数学语言的表达是如下的：</p><script type="math/tex; mode=display">\exists l>0 , f(x+l)=f(x)</script><p>这个$l$就是周期，同时，我们讨论的周期常常是最小正周期。</p><p>比如说：</p><script type="math/tex; mode=display">y=\sin(x)</script><p>这个函数的（最小正）周期就是2$\pi$。</p><p>但是，不是所有的函数都有最小的正周期。如</p><script type="math/tex; mode=display">D(x)=\begin{cases}1 &  x\in{Q}\\ 0 & x\in{Q^C} \\\end{cases}</script><h4 id="5-反函数"><a href="#5-反函数" class="headerlink" title="5.反函数"></a>5.反函数</h4><p>有点像逆映射的感觉了：</p><p>设$f:D\rightarrow{f(D)}$是一个单射，且$f$单调 则有$f^-1:f(D)\rightarrow{D}$ ，且$f^-1$单调，单调性跟 $f$一致</p><p>那么称$x=f^-1(y)$ 是$y=f(x)$的反函数，且这两个函数的图像是关于$y=x$对称的</p><h4 id="6-复合函数"><a href="#6-复合函数" class="headerlink" title="6.复合函数"></a>6.复合函数</h4><p>引入两个函数：$y=f(t) , t=g(x)$ ,把$t$换成$g(x)$，我们就得到了一个复合函数$f(g(x))$。</p><p>值得注意的是：我们如此操作是把 $t =g(x)$视作了一个自变量， $t$的取值范围（f(x)的自变量范围）由我们的$g(x)$决定了，这就是$g(x)$的值域决定了$f(x)$的定义域， 于是，复合函数想要有定义，其$g(x)$的值域必须在$f(x)$的定义域内部才可以。</p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>下面引入两个函数：$f(x),g(x)$ 其中：其定义域以次为$D_f,D_g$ ，产生的新函数的定义域为$D=D_f\cap{D_g}$</p><p>函数的和差：</p><script type="math/tex; mode=display">(f\pm{g})(x)=f(x)\pm{g(x)}</script><p>函数的乘积：</p><script type="math/tex; mode=display">(f\cdot{g})(x)=f(x)\cdot{g(x)}</script><p>函数的相除：</p><script type="math/tex; mode=display">(\frac{f}{g})(x)=\frac{f(x)}{g(x)}, g(x)\neq0</script><h4 id="常见的初等函数"><a href="#常见的初等函数" class="headerlink" title="常见的初等函数"></a>常见的初等函数</h4><p>幂函数：$y=a^{\mu}$</p><p>指数函数:$y=a^x$</p><p>对数函数$y=log_a{x}$, 当$a=e$时，记作：$y=e^x$</p><p>特别的：当$a=e$时，又记成$y=\ln(x)$，当$a=10$时，又记成 $y=\lg(x)$.</p><p>三角函数：$\sin(x)$</p><p>反三角函数:$\arcsin(x)$</p><p>所有的这些函数经过有限次数的组合，运算得到的函数都是初等函数。</p><h2 id="极限定义与使用"><a href="#极限定义与使用" class="headerlink" title="极限定义与使用"></a>极限定义与使用</h2><h4 id="数列的极限的定义"><a href="#数列的极限的定义" class="headerlink" title="数列的极限的定义"></a>数列的极限的定义</h4><p>​            数列可以简单的理解为一列数：按照一定的规律排放：{$x_1,x_2,x_3,x_4,x_5…$}，我们简记作：$\{x_n\}$（注意到N是无穷大的）,比如说：</p><p>​                                                        $\{\frac{1}{2^n}\}$:$\{\frac{1}{2},\frac{1}{4},\frac{1}{8},\frac{1}{16}…\}$</p><p>其中，我们单取出来一项：这是数列的一个项。对于$\frac{1}{2^n}$这个东西，则我们叫做一般项：因为我们可以通过带入N的值来求得第N项的值来。</p><p>​        再来看一些数列：</p><p>​                                            $\{\frac{1}{n}\}$:{1,$\frac{1}{2},\frac{1}{3},\frac{1}{4},\frac{1}{5},\frac{1}{6},\frac{1}{7}$…}</p><p>​        这些数列似乎都随着N的增大逼近一个数，比如说，上面的这些数列都在$N\rightarrow\infty$下，{$x_n$}都在逼近一个数，比如和上面两个都在向0逼近。</p><p><img src="image-20221227094255924.png" alt="image-20221227094255924"></p><p>​        这是$\{\frac{1}{n}\}$在数轴上的表示：当N越来越大下，数代表的点越来越靠近0代表的点。</p><p>我们称数列随着$N\rightarrow\infty$下，逼近的那一个数称之为这个数列的极限。</p><p>​        大概如此，所以我们来看看数学分析下定义的极限：</p><p>​        定义：$\{x_n\}$作为一个数列，$\forall \varepsilon&gt;0$，总$\exists{N},$当$n&gt;N$下，$|x_n-a|&lt;\varepsilon$</p><p>​        好吧，看一脸懵逼。那这个是什么意思呢？为什么引出这个抽象的定义？</p><p>​        注意到：$\forall \varepsilon&gt;0$ :这个是表明任意的一个$ \varepsilon$，只要它大于0都算，都要让上面的式子成立。</p><p>​        这就是说，我的$ \varepsilon$可以取得任意的小，多小都得行！，而$\exists{N},$表明了存在数列的一个项：使得在之后的项（这在$n&gt;N$已经说明白了）都与一个数a的差的绝对值（嘛，就是之后的项与这个数a的距离）为任意小。还不是相等，是一个动态的过程，因为如同</p><p>$\{\frac{1}{n}\}$中$n=10000000000000$一样，只是$x_n=\frac{1}{10000000000000}$罢了，但绝对不是0！但是，伴随这N取的越来越大，我们的{$x_n$}会越来越逼近0的。这描述的是一个动态的过程。</p><p>下面我们来引入一道经典例题：</p><p>​                                                            $2,\frac{1}{2},\frac{4}{3},\frac{3}{4}…\frac{n+(-1)^{n-1}}{n}$</p><p>​        这个数列的极限如何？</p><p>​        首先分析以下大通项：$\frac{n+(-1)^{n-1}}{n}$，它可以做出分离：$1+\frac{(-1)^{n-1}}{n}$ 注意到$(-1)^{n-1}$是一个震荡的数，在-1与1之间震荡，如果看作是一个函数的话，他是有界的，而$\frac{1}{n}$或者是$-\frac{1}{n}$无论如何都会随N增大而趋向于0.那么，这个数列的极限很明了了：</p><p>​    那我们使用数列的极限来证明：</p><p>​    $证明：$</p><p>​    $    因为 |x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}$</p><p>​    $于是\forall \varepsilon&gt;0,取{N=[\frac{1}{n}]+1}, 此时|x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}&lt;\varepsilon$</p><p>​    于是数列的极限是1.</p><p>​    我们再来看一个例题：</p><p>​    证明：$x_n=\frac{(-1)^n}{(n+1)^2}$的极限是0：</p><p>​    这是好说的：我们照猫画虎：</p><p>​    $证明：$</p><p>​    $    因为：|x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}$</p><p>​    $于是\forall \varepsilon&gt;0，取N=[\frac{1}{\sqrt{ \varepsilon}}]+1,此时有 |x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}&lt;\varepsilon$</p><p>​    于是数列的极限为0.</p><p>​    收敛数列的性质：</p><p>​    我们讨论一个收敛数列，是要关注他有什么特性的：</p><p>​    显然：</p><p>（1）收敛数列的极限唯一。</p><p>​    不太好证，所以我们来引入反证法：</p><p>​    证明：假设$x_n\rightarrow{a}同时x_n\rightarrow{b}$ ($a\neq{b}$),我们取$\varepsilon=\frac{b-a}{2}$（1）,</p><p>​    $于是：\exists{N_1},当n&gt;N_1下 |x_n-a|&lt;\frac{b-a}{2}$（2）</p><p>​    同时，又有$\exists{N_2},当n&gt;N_2下 |x_n-b|&lt;\frac{b-a}{2}$</p><p>​    这个时候，我们处理一下上面的式子：（展开我们的绝对值写成不等式）</p><p>​    此时由（1）得到的是：$x_n&lt;\frac{a+b}{2}$</p><p>​    由（2）得到的是：$x_n&gt;\frac{a+b}{2}$</p><p>​    毫无疑问这是矛盾的。所以，我们的极限不可以同时趋近于两个数。</p><p>​    （2）收敛数列一定有界。</p><p>​    证明：设$\lim\limits_{n\to+\infty}{x_n}=a$，此时此刻，我们可以随意的取一个$\varepsilon=1,\exists {N},当n&gt;N下，|x_n-a|&lt;1$</p><p>​    这个时候：</p><p>​    $    |x_n|=|x_n-a+a|\leqslant|x_n-a|+|a|&lt;1+|a|$</p><p>​        这显然符合有界的定义。但是呢？这是保证了$x&gt;N$的形况下，这个时候，我们只需要取出$M=max\{x_1,x_2,…x_N,1+|a|\}$（取出前N个里中最大的与1+$|a|$中还要大的那个，此时，M就是$\{x_n\}$下最大的一项了），这下子：$x_n\leqslant{M}$肯定有界了</p><p>（3）收敛数列具有保号性</p><p>​        这是什么意思呢？就是说：如果一个数列的极限为正（为负），那么，我们的数列在某一项之后肯定都是正的（负的）</p><p>​        数学的表达是这样的：</p><p>​        $\lim\limits_{n\to+\infty}{x_n}=a$,且$a&gt;0$，$\exists{N},$当$n&gt;N下,x_n&gt;0$</p><p>证明：</p><p>​        $a&gt;0$时，取$\varepsilon=\frac{a}{2}&gt;0,\exists{N},$当$n&gt;N$下,$|x_n-a|&lt;\frac{a}{2},$此后，我们的$0&lt;\frac{a}{2}&lt;x_n&lt;\frac{3a}{2}$</p><p>证毕。</p><p>​        反过来讲，如果数列从一项起都大于（小于）0，并且：$\lim\limits_{n\to+\infty}{x_n}=a$，那么：$a\geqslant0(\leqslant0)$</p><p>​    （4）收敛数列的任意子数列都收敛于同一极限</p><p>子数列：就是从原本的数列中抽取一些元素组成一个全新的数列。</p><p>$x_{n_k}$就是一种表示。</p><p>​        证明:</p><p>记：$\{x_{n_k}\}$是$\{x_{n}\}$的一个子数列，并且$\lim\limits_{n\to+\infty}{x_n}=a$</p><p>则$\forall \varepsilon&gt;0,\exists N&gt;0,n&gt;N下$</p><p>$|x_n-a|&lt;\varepsilon,这时，我们取K=N,k&gt;K时，n_k&gt;n_K=n_N\geqslant{N}$</p><p>${|x_{n_k}-a|}&lt;\varepsilon$</p><p><img src="image-20221228145330449.png" alt=""></p><p>​        于是，我们又多了一种证明方式：如果一个数列中，存在两个子数列收敛于不同的极限，则我们说这个数列是发散。</p><p>补充：</p><p>​        反三角函数：三角函数的反函数时反三角函数。有如下的对应关系：</p><p>$sin(x)\rightarrow{arcsin(x)}$</p><p>$cos(x)\rightarrow{arccos(x)}$</p><p>$tan(x)\rightarrow{arctan(x)}$</p><p>​        实际上，就是$x=siny$的离谱写法我们看不惯，于是我们选择用一个全新的表达来表达一个全新的函数</p><p>​        图像上，回忆第一小节的笔记，图像关于$y=x$对称，做出来的图像就如下图所示：</p><p><img src="image-20221228145914221.png" alt="image-20221228145914221"></p><p>​        同时，为了保证是函数（还是第一小节的知识），截取我们的函数得到：</p><p><img src="image-20221228145933050.png" alt="image-20221228145933050"></p><p>​        于是：$x\in[-1,1],y\in[-\frac{\pi}{2},\frac{\pi}{2}]$</p><p>​        一些常见的函数值对应表：</p><p><img src="image-20221228150223124.png" alt="image-20221228150223124"></p><p>其他的：</p><p><img src="image-20221228150313511.png" alt="image-20221228150313511"></p><h5 id="（二）函数的极限"><a href="#（二）函数的极限" class="headerlink" title="（二）函数的极限"></a>（二）函数的极限</h5><p>​        1）$x\rightarrow{a}$下的函数极限</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.这一大长串，简记成如下：</p><p>法1）$\lim\limits_{x\rightarrow{x_0}}f(x)=A$</p><p>法2)$f(x)\rightarrow{A}(x\rightarrow{x_0})$</p><p>​        这定义还是很抽象：我们用人话讲：就是只要$x到{x_0}$是充分接近的，$f(x)$到$A$的距离可以为任意小。</p><p>​        但是，我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>下面我们就使用这个定义来证明一些命题：</p><p>$(1)\lim\limits_{x\rightarrow x_0}C=C$</p><p>证明：$\forall\varepsilon&gt;0,\exists\delta=N(N&gt;0)$</p><p>使得$0&lt;|x-x_0|&lt;\delta,|f(x)-A|=0,这明显小于\varepsilon$</p><p>证毕</p><p>$(2)\lim\limits_{x\rightarrow{1}}(2x-1)=1$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta=\frac{\varepsilon}{2}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=2|x-1|&lt;\varepsilon$</p><p>$(3)\lim\limits_{x\rightarrow{1}}\frac{x^2-1}{x-1}=2$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta={\varepsilon}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=|x-1|&lt;\varepsilon$</p><p>证毕</p><p>​        回到我刚刚讲到的：因为我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。为了方便描述，我们引入左，右极限的概念来描述从左侧右侧来逼近函数一点时产生的极限</p><p>左极限:$\lim\limits_{x\rightarrow{x_0^-}}f(x)=A$</p><p>右极限:$\lim\limits_{x\rightarrow{x_0^+}}f(x)=A$</p><p>那么，回到这个定义：</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.</p><p>​    其中$x$怎么趋近的方式是已经确定的，于是上面的$|x-x_0|$就可以拆成$x-x_0$或者是$x_0-x$了</p><p>那么，我们再次阐述：</p><p>​        我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>这个定理：$x\rightarrow{x_0}$,$f(x)$的极限存在$\Leftrightarrow$ 左右极限存在且相等</p><p>比如说</p><p>$\begin{equation}f(x)=\left\{\begin{array}{cl}x+1 &amp;  x &gt; 0 \\0  &amp;  x = 0 \\x-1 &amp;  x &lt; 0 \\\end{array} \right.\end{equation}$</p><p>$\lim\limits_{x\rightarrow{0^-}}f(x)=-1$</p><p>$\lim\limits_{x\rightarrow{0^+}}f(x)=1$</p><p>两者不相等，于是$f(x)$在0处的极限是不存在的。</p><p>​        2）$x\rightarrow{\infty}$下的函数极限</p><p>​        假设啊，我们的函数在无穷远处有定义的：这个时候，我们的$x$越远，我们的函数值越是接近某一个数。用数学语言表达是这样的：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X&gt;0,\mbox{使得}|x|&gt;X时，|f(x)-A|&lt;\varepsilon$</p><p>此时，我们简记作$\lim\limits_{x\rightarrow{\infty}}=A$</p><p>例题：</p><p>​        $(1)\lim\limits_{x\rightarrow{\infty}}{\frac{1}{x}=0}$</p><p>证明：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X=\frac{1}{\varepsilon},\mbox{使得}|x|&gt;X时，|\frac{1}{x}|&lt;\varepsilon$</p><p>证明完毕</p><p>​        </p><p>​        说完了，让我们谈谈性质</p><p>​        1)函数的极限唯一性</p><p>​        2)函数的局部有界限：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\exists{M&gt;0},\forall{\delta&gt;0},0&lt;|x-x_0|&lt;\delta时，|f(x)|\leqslant{M}$</p><p>​        3)局部保号性：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,A&gt;0,\exists{\delta&gt;0}则在0&lt;|x-x_0|&lt;\delta,f(x)&gt;0$</p><p>​        4）$Henn$定理：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\{x_n\}\rightarrow{x_0},\lim\limits_{n\rightarrow{\infty}}f(x_n)=\lim\limits_{x\rightarrow{x_0}}f(x)$</p><h6 id="无穷小和无穷大"><a href="#无穷小和无穷大" class="headerlink" title="无穷小和无穷大"></a>无穷小和无穷大</h6><p>​        无穷小：趋于0的一个量（动态的！），是正是负和0都叫无穷小。同时，无穷小除了0意外，无穷小都不确定。具体的定义是这样的：</p><p>​        定义：$x\rightarrow{x_0}(x\rightarrow{\infty})$时，$f(x)$ 的极限为0，称$f(x)$是当$x\rightarrow{x_0}(x\rightarrow{\infty})$下的无穷小</p><p>​        这么说来，无穷小并不唯一，有无穷多个无穷小</p><p>下面介绍以下无穷小的一些性质:</p><p>​        定义$a,b$是两个无穷小</p><p>​        $a+b$是一个无穷小；</p><p>​        $a-b$是一个无穷小;</p><p>​        $a\times b$是一个无穷小;</p><p>​        $c\times{a}$是一个无穷小;</p><p>​        注意！！！$a\div{b}$是未定式，在没有给定a,b的具体情况，我们是不知道这个值究竟是多少的！它本身可以是任何数！！！</p><p>​        无穷大：这个有特定的符号：$\infty$</p><p>​        他也是有定义的：$\lim\limits_{ {x\rightarrow{x_0} } }f(x)= \infty$或者$\lim\limits_{ {x\rightarrow{\infty} } }f(x)=\infty$</p><p>​        注意！！！注意！！！无穷大可以是正无穷大或者是负无穷大！！！于是</p><p>​        引入两个无穷大记作$a,b$</p><p>​        无论是$a+b还是a-b$都是未定义的</p><p>​        但是$a\times{b}$一定是无穷大，$c\times{ \infty }(c\neq{ 0 })$一定是无穷大</p><p>​        $a\div{ b }$结果未知</p><p>​        定理：$f(x)$如果是无穷大，那么$\frac{1}{f(x)}$是无穷小。</p><p>​        $f(x)$如果是无穷小，那么$\frac{1}{f(x)}$是无穷大。（$f(x)\neq{0}$）</p><p>​        极限运算法则</p><p>​        法则1：两个甚至是若干有限个的无穷小的和是无穷小的</p><p>​        <strong>法则2：有界函数与无穷小的乘积是无穷小</strong></p><p>​        推论：常数乘以无穷小还是无穷小</p><p>​                    有限个无穷小的乘积还是无穷小</p><p>​        定理：记：$\lim{f(x)}=A,\lim{g(x)}=B$</p><p>​        1)$\lim{f(x)\pm{g(x)}}=A\pm{B}$</p><p>​        2)$\lim{f(x)\times{g(x)}}=A\times{B}$</p><p>​        3)$\lim{\frac{f(x)}{g(x)}}=\frac{A}{B}(B\neq{0})$</p><p>​        4)$\lim{cf(x)}=c\lim{f(x)}$</p><p>​        5)$\lim{ {f(x)}^n}=[{\lim{f(x) } }]^n$</p><p>对于数列还是一样的</p><p>​        定理:$\psi(x)\geqslant\varphi(x)$,$\lim{\psi(x)}&gt;\lim{\varphi(x)}$</p><p>哎，这后面这么没有等号了呢?举个例子:$\frac{1}{x}$,$-\frac{1}{x}$</p><h5 id="极限存在准则，两个重要极限"><a href="#极限存在准则，两个重要极限" class="headerlink" title="极限存在准则，两个重要极限"></a>极限存在准则，两个重要极限</h5><p>准则I：对于数列$\{x_n\},\{y_n\}$,${z_n}$ (1)$\exists {n_0}\in{N},y_n\leqslant{x_n}\leqslant{z_n}$(2)$\lim{y_n}=lim{z_n}=a$那么：$\lim{x_n}=a$</p><p>准则I’ :对于函数f(x),g(x),h(x),且(1)$g(x)\leqslant{f(x)}\leqslant{h(x)}$(2)$\lim{g(x)}=\lim{h(x)}=A$那么：$lim{f(x)}=A$</p><p>两个重要极限：</p><h6 id="I-lim-limits-x-rightarrow-0-frac-sin-x-x-1"><a href="#I-lim-limits-x-rightarrow-0-frac-sin-x-x-1" class="headerlink" title="I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$"></a>I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$</h6><p>注意一定是$x\rightarrow{0}$！！！</p><p>同时！！！也可以有推广：</p><h6 id="I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1"><a href="#I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1" class="headerlink" title="I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$"></a>I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$</h6><p>其他派生的极限：</p><p>$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=1$</p><p>这是因为：$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=\lim\limits_{x\rightarrow{0}}(\frac{\sin{x}}{x})\times(\frac{1}{\cos{x}})$=1</p><p>例题：$\lim\limits_{x\rightarrow{0}}\frac{1-\cos{x}}{x^2}$</p><p>解：<img src="image-20221229164852173.png" alt="image-20221229164852173"></p><p>等价无穷小：（I派生）</p><p>$\sin{x}\backsim{x}$ , $\tan{x}\backsim{x}$, $\arcsin{x}\backsim{x}$</p><h4 id="准则II：单调有界数列必有极限！"><a href="#准则II：单调有界数列必有极限！" class="headerlink" title="准则II：单调有界数列必有极限！"></a>准则II：单调有界数列必有极限！</h4><p>性质：收敛必有界，而有界不一定收敛</p><p>为什么有界不一定收敛呢？举个反例：$\{(-1)^{N}\}$就可以了，这个数列显然有界：</p><p>II:$\lim\limits_{x\rightarrow{\infty}}(1+\frac{1}{x})^{x}=e$</p><p>注意$x$一定是趋于无穷！！！</p><p>派生的还有。。。</p><p>II’$\lim\limits_{\Box\rightarrow{\infty}}(1+\frac{1}{\Box})^{\Box}=e$</p><p>II’’$\lim\limits_{x\rightarrow{0}}(1+{x})^\frac{1}{x}=e$</p><p>补充：Cauchy极限审敛法：</p><p>$\{x_n\}收敛\Leftrightarrow \forall{\varepsilon&gt;0},\exists N,当m&gt;N时，|x_n-x_m|&lt;\varepsilon$</p><p>无穷小的比较：</p><p>​        不同无穷小趋于0的速度不一样，我们比较无穷小就是比较不同无穷小趋于0的速度：</p><p>方法是简单的，看他们的商的极限即可：</p><p>如：$\lim\limits_{x\rightarrow{0}}x=0,\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$,而$\lim\limits_{x\rightarrow{0}}\frac{x}{\sqrt{x}}=\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$</p><p>于是：我们发现这个极限为0，说明在趋近速度上$x&gt;\sqrt{x}$</p><p>这样，我们就比较出来了</p><p>定义：</p><p>$若\lim\frac{\beta}{\alpha}=0,则称\beta是\alpha的高阶无穷小，记作\beta=o(\alpha)$</p><p>$若\lim\frac{\beta}{\alpha}=\infty,则称\beta是\alpha的低阶无穷小$</p><p>$若\lim\frac{\beta}{\alpha}=c(c\neq{0}),则称\beta是\alpha的同阶无穷小,特别的，当c=1时，又称等价无穷小,记作{\beta}\backsim{\alpha}$</p><p>$若\lim\frac{\beta}{\alpha^k}=c(c\neq{0}),则称\beta是\alpha的k阶无穷小$</p><p>下面是一些常见的等价无穷小：</p><p>1)$x\rightarrow{0}时，\sqrt[n]{1+x}-1\backsim\frac{x}{n},\sin(x)\sim{x}$</p><p>定理：</p><p>1）$\beta于\alpha等价\Leftrightarrow \beta=\alpha+o(\alpha)$</p><p>2)$\alpha\sim\widetilde{\alpha},\beta\sim\widetilde{\beta},且\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}是存在的，则:\lim\frac {\alpha}{\beta}=\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}$</p><p>于是：</p><p>2)$\tan{x}\sim{x},\arcsin{x}\sim{x}$</p><p>上面的$x$都可以被替换成$\Box$</p><p>定理：</p><p>1）两个无穷小相比的极限时，分子分母可以用等价无穷小替换</p><p>2）如果分子或分母是若干因子的乘积，则我们可以对其中一个或者几个无穷小做替换，但是因子用加减法是不可以的！！！！！！！！！！！！！！！！</p><h4 id="函数的连续性"><a href="#函数的连续性" class="headerlink" title="函数的连续性"></a>函数的连续性</h4><p>对于函数增量的定义：</p><p><img src="image-20221229174949222.png" alt="image-20221229174949222"></p><p>则增量$\Delta f(x)=f(x+\Delta{x})-f(x)$</p><p>实际上，叫做改变量更切合实际，因为函数也可以递减</p><p>那么，连续的定义由此引出：</p><p>若$\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=\lim\limits_{\Delta{x}\rightarrow{0}}(f(x_0+\Delta{x})-f(x_0))=0$时，则函数在$x_0$处连续</p><p>或者</p><p>$\lim\limits_{x\rightarrow{x_0}}f(x)=f(x_0)$时，则函数在$x_0$处连续</p><p>总结而言，一个函数若是想在$x_0$ 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！</p><p>既然有左右极限，于是也使得函数也有左右连续。函数的左右极限就是由$x$以不同的方向逼近产生的。</p><p>左连续：$\lim\limits_{x\rightarrow{x_0^-}}f(x)=f(x_0)$</p><p>右连续：$\lim\limits_{x\rightarrow{x_0^+}}f(x)=f(x_0)$</p><p>类似的：函数的连续的充要条件是函数即左连续又右连续。</p><h4 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h4><p>回到连续需要满足的条件：</p><p>一个函数若是想在x_0 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！于是，间断点也就有三种产生原因：</p><p>1)在$x_0$无定义</p><p>2)$\lim\limits_{x\rightarrow{x_0}}f(x)$不存在</p><p>3）$\lim\limits_{x\rightarrow{x_0}}f(x)\neq{f(x_0)}$</p><p>举例子：</p><p>1)$y=\tan{x}在x=\frac{\pi}{2}$处无定义，所以在这一点上不连续这是可去间断点.</p><p>2)$y=\sin{\frac{1}{x}}$在x=0处极限不存在，所以在这一点上不连续.</p><p>3）</p><script type="math/tex; mode=display">\begin{equation}f(x)=\left\{\begin{array}{cl}\frac{x^2-1}{x-1} &  x \neq 0 \\0  & x = 0 \\\end{array} \right.\end{equation}</script><p>，这个函数在x=1处不连续。这个间断点叫跳跃间断点</p><p>间断点有两类：</p><p>第一类：左右极限都存在</p><p>有可去间断点，跳跃间断点</p><p>第二类：左右极限不都存在</p><p>有震荡间断点</p><p>连续函数的性质：</p><p>对于$[a,b]$上，且$f(a)f(b)&lt;0$时，则其中至少存在一个点$\xi \in[a,b]，$使得$f(\xi)=0$</p><p>推广：</p><p>定理：$f(x)在[a,b]$上连续,$f(a)=A,f(b)=B$,则$\exists C\in[A ,B]$,至少有一个$\xi \in [a,b]$使得，$f(\xi)=C$</p><h2 id="一-基本定义和性质"><a href="#一-基本定义和性质" class="headerlink" title="一.基本定义和性质"></a>一.基本定义和性质</h2><h3 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h3><p>​        恭喜！你来到了导数这一章！现在，我们可以使用它来更精确的描述函数是怎么增长变动的！！！</p><p>​        首先，引入一个场景：讨论速度与位移，并且我们都用时间来表示：</p><p>那么，一个平均速度可以用如下这个式子来表达：$v=\frac{f(t)-f(t_0)}{t-t_0}$</p><p>​        这是我们中学就已经熟知的。</p><p>​        现在，让我们让$t\rightarrow{t_0}$ 也就是让t逼近$t_0$。这样，回到高中物理，我们就知道我们得到了瞬时速度。</p><p>​        其实，很多函数变化，都可以类比的使用这种办法得到函数在一个点的变化情况，下面，让我们统一一下，使用一个定义来综述：</p><p>$定义 y=f(x)在x_0的领域内有定义，对x_0取增量\Delta{x}，那么函数的增量就是\Delta{y}=f(x_0+\Delta{x})-f(x_0)，如果\lim\limits_{\Delta{x}\rightarrow{0}}\frac{\Delta{y}}{\Delta{x}}=\lim\limits_{\Delta{x}\rightarrow{0}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}$ $是存在的，我们就称呼y=f(x)在x_0处可导，且这个极限值就是y=f(x)在x_0处的导数$</p><p>​        记作$y’| _{x=x_0},f’(x_0),\frac{dy}{dx}|_{x=x_0}，\frac{df(x)}{dx}|_{x=x_0}$上面四个选一个</p><p>当然，导数还有另一个定义：就是</p><p>​      $如果\lim\limits_{x\rightarrow{x_0}}\frac{\Delta{y}}{\Delta{x}}=\lim\limits_{x\rightarrow{x_0}}\frac{f(x)-f(x_0)}{x-x_0}是存在的，我们就称呼y=f(x)在x_0处可导，且这个极限值就是y=f(x)在x_0处的导数$ </p><p>​        如果函数在一个区间内处处可导，我们就可以再用一个函数刻画导数：导函数$f’(x)$</p><p>​        下面来看一些函数的导（函）数（方便起见使用h代替$\Delta{x}$）</p><p>（1）$f(x)=C$</p><p>则：$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=0$</p><p>故$C’=0$</p><p>(2)$f(x)=x^n$</p><p>1.当n=1时:$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=1$</p><p>2.当n&gt;1时：$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\rightarrow{0}}\frac{(x+h)^n-x^n}{h}$</p><p>而：$(x+y)^n=x^n+nx^{n-1}y+\frac{n(n-1)}{2}x^{n-2}y^{2}+…+ny^{n-1}x+y^n$</p><p>于是$极限=\lim\limits_{h\rightarrow{0}}nx^{n-1}+(…)\times{h}=nx^{n-1}$</p><p>3.当$f(x)=x^{\mu},\mu\in{R}，(x\neq{0})$</p><p>于是：</p><p><img src="image-20221230201314473.png" alt="image-20221230201314473"></p><p>$(x^\mu)’=\mu{x^{\mu-1}}$</p><p>4.$f(x)=\sin{x}$</p><p>$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\rightarrow{0}}\frac{\sin{(x+h)}-\sin{x}}{h}=\lim\limits_{h\rightarrow{0}}\frac{\cos(x+\frac{h}{2})\times{\sin{\frac{h}{2}}}}{\frac{h}{2}}=\cos{x}$</p><p>所以：$\sin’{x}=\cos{x}$</p><p>类似的$\cos’{x}=-\sin{x}$</p><p>5.$(a^x)’=a^x\ln{a},特别的(e^x)’=e^x$</p><p>6.$\log’_{a}{x}=\frac{1}{x\ln{a}},特别的\ln’x=\frac{1}{x}$</p><h3 id="单侧导数"><a href="#单侧导数" class="headerlink" title="单侧导数"></a>单侧导数</h3><p>​        导数也有单侧导数的这一概念，直观的讲，正是导数以不同的方式逼近一个点所产生的：</p><p>​        回忆我们先前的类似概念，左侧导数的定义是这样的：</p><p>​        </p><script type="math/tex; mode=display">f'_{-}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^-} }\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        更容易理解的：右导数的定义是这样的：</p><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^+}}\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        当然，也有第二定义</p><p>​        左导数：</p>$$f'_{-}(x_0)=\lim \limits_{ { x } \rightarrow{x_0^-} } \frac{f(x_0+h)-f(x_0)} {h}$$<p>​        右导数：</p><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{ { x} \rightarrow{x_0^+} }\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        于是，可导的一种判断方式有了：在一个点的左右导数存在相等。</p><p>​        对于$y=|x|$ ，在$x_0$左侧的左导数为-1，右导数为1，这两个不相等，故$|x|$在$x=0$处不存在导数。</p><h3 id="导数也有几何意义"><a href="#导数也有几何意义" class="headerlink" title="导数也有几何意义"></a>导数也有几何意义</h3><p>​        导数也有几何意义，不错。那么，导数的几何意义是什么呢？直接说：导数的几何意义就是函数图像在某一点上的切线的斜率，一个处处可导的曲线必然光滑。</p><p><img src="image-20230104153906913.png" alt="image-20230104153906913"></p><p>​        于是，切线方程可以这样给出</p><script type="math/tex; mode=display">l:y-y_0=f'(x_0)(x-x_0)</script><p>​        有切线了，法线也会有：法线就是过切点的，垂直于切线的线：</p><script type="math/tex; mode=display">l':y-y_0=-\frac{1}{f'(x_0)}(x-x_0)</script><p>​        比如说，让我们求$y=\frac{1}{x}$在$(\frac{1}{2},2)$上的切线：</p><script type="math/tex; mode=display">证明:显然在x_0=\frac{1}{2}这个点上，f'(x_0)=-4</script><script type="math/tex; mode=display">于是切线方程为:y-2=-4(x-\frac{1}{2})</script><script type="math/tex; mode=display">法线方程为：y-2=\frac{1}{4}(x-\frac{1}{2})</script><h3 id="联系起来：探寻可导与连续的关系"><a href="#联系起来：探寻可导与连续的关系" class="headerlink" title="联系起来：探寻可导与连续的关系"></a>联系起来：探寻可导与连续的关系</h3><p>​        我们可以简单的理解认为可导就说明函数曲线的光滑，连续就是函数图像不产生间断。看来：函数如果光滑，则一定没有间断，函数没有间断却不一定光滑。那我们认为：<strong>可导必然连续，连续不一定可导。</strong></p><p>​        对于这件事情：可以想象一排自行车：如果他们想多米诺骨牌一样倒下了 （可 倒（导））说明他们一定连续的放置，反之，如果不去动他们，则他们就算连续放置也不会倒下，可以这样记。</p><p>​        回到数学的定义上，我们对比一下：</p><script type="math/tex; mode=display">连续:\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=0</script><script type="math/tex; mode=display">可导:\lim\limits_{\Delta{x}\rightarrow{0}}\frac{\Delta{y}}{\Delta{x}}=C(const)</script><p>​        于是，如果一个$\Delta{x}\rightarrow{0}$，同时，可导定义比出来的比值还必须是一个常数，由同阶无穷小的定义，我们不得不得出$\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=0$的结论，也就是连续。</p><p>​        反之，我们的$\Delta{y}$可能并不会与$\Delta{x}$属于同阶无穷小，因此，我们的可导定义极限可能发散。于是：就可能并不可导</p><h3 id="求导法则：和差商积"><a href="#求导法则：和差商积" class="headerlink" title="求导法则：和差商积"></a>求导法则：和差商积</h3><p>​        高中我们就接触过了：</p><p>​        首先定义$u,v$是两个可导函数，其值为$u’,v’$</p><script type="math/tex; mode=display">法则1: (u+v)'=u'+v'</script><script type="math/tex; mode=display">法则2:(u-v)'=u'-v'</script><script type="math/tex; mode=display">法则3:(uv)'=uv'+vu'</script><script type="math/tex; mode=display">法则4:(cu)'=cu'(c是常数)</script><script type="math/tex; mode=display">法则5:(\frac{u}{v})'=\frac{u'v-uv'}{v^2}</script><p>法则1234都可以扩展：</p><p>对于有限个$u_i$的可导函数：他们的和的导数为各自导数的和</p><script type="math/tex; mode=display">(u+v+w+...+...+s)'=u'+v'+w'+...+...+s'</script><p>对于有限个$u_i$的可导函数：他们的积的导数为所有$u_i$的积中轮流取出一个$u_k(k\in{(1,i)})$求一次导</p><script type="math/tex; mode=display">(uvw...s)'=u'vw...s+uv'w...s+uvw'...s+...+uvw...s'</script><h3 id="反函数的求导法则"><a href="#反函数的求导法则" class="headerlink" title="反函数的求导法则"></a>反函数的求导法则</h3><p>​        反函数也能求导。</p><script type="math/tex; mode=display">定理:x=f(y)在I_y内单调且可导，同时f'(y)\neq{0},</script><script type="math/tex; mode=display">那么反函数y=f^{-1}(x)的导函数如下：</script><script type="math/tex; mode=display">[f^{-1}(x)]'=\frac{1}{f'(y)}</script><p>​        超前一点，可以引入记号$\frac{dy}{dx}$表达$f(x)$的导数，而$\frac{dx}{dy}$就是反函数，于是：</p><script type="math/tex; mode=display">\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}</script><p>​        他让我们的导数公式可以扩充了：</p><p>​        例如:$x=\sin{y}$作为$y=\sin{x}$的反函数的公式</p><script type="math/tex; mode=display">因为:\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}=\frac{1}{\cos{y}}</script><script type="math/tex; mode=display">且:\sin^2{y}+\cos^2{y}=1\Longrightarrow{\cos{y}=\sqrt{1-\sin^2{y}}=\sqrt{1-x^2}}</script><p>​        于是：$y=\arcsin{x}$的导数公式正是：$\arcsin{x}’=\frac{1}{\sqrt{1-x^2}}$.</p><p>​        这样，我们也还可以求出其他公式：</p><script type="math/tex; mode=display">\arccos{x}'=-\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arctan{x}'=\frac{1}{1+x^2}</script><h3 id="复合函数的求导法则"><a href="#复合函数的求导法则" class="headerlink" title="复合函数的求导法则"></a>复合函数的求导法则</h3><p>​        下面，我们先从严肃的讲起：</p><p>​        假设，我说假设：$f(x)$是一个很复杂的东西：但好消息是，可以是做若干函数的嵌套：比如说$\ln{\sqrt{\frac{1}{cos{\ln{\sin^2{x}}}}}{sin{x}}}$云者，那这样的函数这么求导呢？复合求导法来力！</p><p>​        </p><script type="math/tex; mode=display">法则:简单的，视函数f(x)是由f(u),u=g(x)嵌套，那么它的导数是:</script><script type="math/tex; mode=display">f'(x)=f'(u)\times{g'(x)}</script><p>​        就是说，我们可以视$u$作一个整体，先想象成单一函数$f(x)$求导，不过$x$是$u$,随后对$u$求导，乘起来的时候u要换成x.</p><p>​        使用微分语言是这样描述的：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{dy}{du}\times\frac{du}{dx}</script><p>​        想象成分式乘法，我们自然可以：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{dy}{du}\times\frac{du}{dk}\times\frac{dk}{dw}...\times\frac{ds}{dx}</script><p>​        例如说：对$e^{x^{3}}$求导</p><p>​        我们首先设$u=x^3$，而$e^u$对$u$求导显然是$e^u$，那么$u$对$x$是$3x^2$根据法则，我们要把连着直接相乘$3e^u{x^2}$，但是还没换回来$x$,因此将$u=x^3$换回来得到结果$3e^{x^3}{x^2}$</p><p>​        那么：$y=\ln{\cos{e^x}}$如何？</p><p>​        直接设置$y=\ln{u},u=\cos{v},v=e^x$结合复合函数求导法则。</p><p>​        $y’=\frac{1}{u}\times{-\sin{v}}\times{e^x}$</p><p>​        换元：$y’=\frac{-\sin{e^x}\times{e^x}}{\cos{e^x}}$</p><h3 id="导数公式表"><a href="#导数公式表" class="headerlink" title="导数公式表"></a>导数公式表</h3><p>​        介绍完导数的求导法则，我们也就可以引入一系列的求导表了：</p><script type="math/tex; mode=display">(C)'=0</script><script type="math/tex; mode=display">(x^{\mu})'=\mu{x^{\mu-1}}</script><script type="math/tex; mode=display">\sin{x}'=\cos{x}</script><script type="math/tex; mode=display">\cos{x}'=-\sin{x}</script><script type="math/tex; mode=display">\tan{x}'=\sec^2{x}</script><script type="math/tex; mode=display">\cot{x}'=-\csc^2{x}</script><script type="math/tex; mode=display">\sec{x}'=\sec{x}\tan{x}</script><script type="math/tex; mode=display">\csc{x}'=-\csc{x}\cot{x}</script><script type="math/tex; mode=display">(a^x)'=\ln{a}\times{a^x},(e^x)'={e^x}</script><script type="math/tex; mode=display">\log_a{x}'=\frac{1}{x\ln{a}}</script><script type="math/tex; mode=display">\ln{x}'=\frac{1}{x}</script><script type="math/tex; mode=display">\arcsin{x}'=\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arccos{x}'=-\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arctan{x}'=\frac{1}NaN</script><script type="math/tex; mode=display">arccot{x}'=-\frac{1}NaN</script><h3 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h3><p>​        就是对一个函数求有限次导数：比如说</p><script type="math/tex; mode=display">y=x^3,y'=3x^2,y''=6x,y'''=6,y^{(4)}=0</script><p>​        在微分学里也有专门的符号表示</p><script type="math/tex; mode=display">一阶导数:\frac{dy}{dx}</script><script type="math/tex; mode=display">二阶导数:\frac{d}{dx}(\frac{dy}{dx})=\frac{d^2y}{dx^2}</script><script type="math/tex; mode=display">N阶导数:\underbrace{\frac{d}{dx}\frac{d}{dx}...\frac{d}{dx}\frac{dx}{dy}}_{Ntimes}=\frac{d^ny}{dx^n}</script><p>一些常见的N阶导数公式是如下的：</p><script type="math/tex; mode=display">\sin^{(x)}x=\sin{(x+\frac{n}{2}{\pi})}</script><script type="math/tex; mode=display">\cos^{(x)}x=\cos{(x+\frac{n}{2}{\pi})}</script><script type="math/tex; mode=display">\ln^{(n)}{(x+1)}=(-1)^{n-1}\frac{(n-1)!}{(1+x)^n}</script><script type="math/tex; mode=display">x^{\mu{(n)}}=\mu{(\mu-1)}{(\mu-2)}...{(\mu-n+1)}x^{\mu-n}</script><p>一些法则也是成立的：</p><script type="math/tex; mode=display">(u+v)^{(n)}=u^{(n)}+v^{(n)}</script><p>但是乘法不是，是莱布尼兹公式：</p><script type="math/tex; mode=display">(uv)^{(n)}=\sum^{n}_{k=0}C^{k}_{n}u^{(u-k)}v^{k}</script><h3 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h3><p>​        我们现在接触的函数都是显函数，$y$与$x$都是显然分离的，比如说$y=\sin{x}$云者，有一些函数是$x$和$y$混在一起的，比如说如下的几个式子</p><p>​                                                $                e^{xy}+\sin{y^2}+x^3+8=0$</p><p>​                                                    $e^y-xy-e=0$</p><p>云者。这些被称为隐函数，或者说：关于x的一个方程。</p><p>​        下面，我们介绍这样函数的求导方式：</p><p>​        我们假设$y=y(x)$是一个x的函数，于是，这样的方程成为了一个恒等式：一个关于x的一个大函数$F(x,f(x))=0$的式子。，现在我们求导，就是使用求导法则运算解决问题：右侧作为常数，导数恒为0，对左侧求导即可。下面对：</p><p>​                                                    $e^y-xy-e=0$</p><p>求导</p><p>​        左侧：$e^y\cdot{y’}+y+xy’$</p><p>​        右侧：0</p><p>​        现在参数分离：$y’=-\frac{y}{e^y+x}$</p><p>​                                            $y^5+2y-x-3x^7=0$</p><p>求导：</p><p>​        左侧：$5y^4y’+2y’-1-21x^6=0$</p><p>​        右侧：0</p><p>​        现在参数分离：$y’=\frac{1+21x^6}{5y^4+2}$</p><h3 id="参数方程求导"><a href="#参数方程求导" class="headerlink" title="参数方程求导"></a>参数方程求导</h3><p>​        我们说一些函数可以用</p><script type="math/tex; mode=display">\begin{align*}\begin{split}\left \{\begin{array}{ll}  x= \psi{(t)}                    \\  y=  \varphi{(t)}                               \end{array}\right.\end{split}\end{align*}</script><p>表示，这个时候，可以使用微分形式的公式更好的表达求导：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{\frac{dy}{dt}}{\frac{dx}{dt}}=\frac{\varphi{(x)}'}{\psi{(x)}'}</script><p>微分可以视作增量的一种表达：</p><p>​        回顾增量公式$\Delta{y}=f(x_0+\Delta{x})-f(x_0)$,我们常常发现以这种形式表达的$\Delta{y}$经常可以被写成$A\Delta{x}+o(\Delta{x})$的形式，注意到$A$与$\Delta{x}$是无关的。如果函数的增量可以这样表达：</p><script type="math/tex; mode=display">\Delta{y}=A\Delta{x}+o(\Delta{x})</script><p>​        $A$与$\Delta{x}$是无关,</p><p>​        那么，我们就改写成这样的形式：</p><script type="math/tex; mode=display">dy=Adx</script><p>​        同时，我们还说这样的函数在这一点是可微的：并且，可微一定可导，可导也一定可微：事实上，以此为基准</p><script type="math/tex; mode=display">dy=f'(x_0)dx</script><p>​        微分与导数就是变化率问题的等价表达</p><p>​        于是任何微分公式都可以由上述公式给出：</p><p>​        比如说：$y=x^2,dy=2xdx$</p><h3 id="微分在近似计算的应用"><a href="#微分在近似计算的应用" class="headerlink" title="微分在近似计算的应用"></a>微分在近似计算的应用</h3><p>​        回到上面讲的公式：</p><script type="math/tex; mode=display">\Delta{y}=f(x_0+\Delta{x})-f(x_0)</script><p>​        这个公式，我们可以对一个已知临近量的函数值求另一点相近的函数值的近似值，我们对公式移项：</p><script type="math/tex; mode=display">f(x_0+\Delta{x})=f'(x_0)\Delta{x}+f(x_0)</script><p><img src="image-20230104175543374.png" alt="image-20230104175543374"></p><h2 id="二-导数的应用"><a href="#二-导数的应用" class="headerlink" title="二.导数的应用"></a>二.导数的应用</h2><h4 id="Rolle（罗尔）定理"><a href="#Rolle（罗尔）定理" class="headerlink" title="Rolle（罗尔）定理"></a>Rolle（罗尔）定理</h4><p>​        事实上，为了更好的证明罗尔定理，一般我们需要严格的引入费马定理：</p><h4 id="费马定理"><a href="#费马定理" class="headerlink" title="费马定理"></a>费马定理</h4><p><strong>$f(x)$在$x_0$及其领域有定义，且在$x_0$处可导，如果$f(x)\leqslant{f(x_0)}$(或者$f(x)\geqslant{f(x_0)}$)</strong></p><p><strong>则$\forall{x}\in \cup(x_0)$(这表示领域)，$f’(x_0)=0$</strong></p><p><img src="image-20230106084644861.png" alt="image-20230106084644861"></p><p>​        看起来容易，怎么证明？我们不妨从$x_0$可导入手：</p><p>证明：以$f(x_0)$是最大值为例：函数$f(x)$在$x_0$处可导，那就要求：</p><script type="math/tex; mode=display">x\in \cup(x_0),f(x)\leqslant{f(x_0)}</script><p>​        同时注意到$x_0+\Delta{x}$也是在$\cup(x_0)$上的，于是也有：</p><script type="math/tex; mode=display">x_0+\Delta{x} \in \cup(x_0),f(x_0+\Delta{x})\leqslant{f(x_0)}</script><p>​        同时函数$f(x)$在$x_0$处可导：</p><script type="math/tex; mode=display">f'_{-}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^-}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}\leqslant{0}</script><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^+}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}\geqslant{0}</script><p>​        </p><script type="math/tex; mode=display">f'_{-}(x_0)=f'_{+}(x_0)</script><p>​        上面的三个式子联立：得到$f’_{-}(x_0)=f’_{+}(x_0)=f’(x_0)=0$</p><p>证毕。</p><p>​        于是：又把导数为0的点成为驻点，因为函数在这一点停靠在$y=f(x_0)$上不变化，他们是可能的极值点（会在后面阐述为什么是可能）</p><h4 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h4><p><strong>首先函数$f(x)$满足</strong></p><p><strong>1）在$[a,b]$上连续 2)在$(a,b)$上可导 3）$f(a)=f(b)$</strong></p><p><strong>则至少存在一点$\xi\in(a,b),f’(\xi)=0$</strong></p><p><img src="image-20230106090148355.png" alt="image-20230106090148355"></p><p>这个定理说明了在端点值相等的区间里函数必有<strong>至少</strong>一个驻点。</p><h4 id="拉格朗日中值定理"><a href="#拉格朗日中值定理" class="headerlink" title="拉格朗日中值定理"></a>拉格朗日中值定理</h4><p><strong>要求：1)$[a,b]$连续          2)$(a,b)$可导：</strong></p><p><strong>则函数$f(x)$在$(a,b)$上至少有一个点$\xi$,使得下面的式子成立：</strong></p><script type="math/tex; mode=display">f'(\xi)=\frac{f(b)-f(a)}{b-a}</script><p><img src="image-20230106090806236.png" alt="image-20230106090806236"></p><p>​        说白了，就是罗尔定理的扩展，我们链接两个端点，产生的直线称为函数的一条<strong>弦</strong>在函数上我们至少可以找到一个点的切线斜率等于这条线的斜率的大小。</p><h4 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h4><p>如果$f(x)$和$F(x)$满足：</p><p>1）$[a,b]$连续          2)$(a,b)$可导          3）$\forall{x}\in(a,b),F’(x)\neq{0}$</p><p>则至少有一个点$\xi$,使得$\frac{f(b)-f(a)}{F(b)-F(a)}=\frac{f’(\xi)}{F’(\xi)}$</p><p>​        这又是拉格朗日中值定理的推广。</p><h4 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h4><p>​        这玩意干嘛的？求解未定式$\frac{0}{0}$,$\frac{\infty}{\infty}$的式子</p><p>注意：法则内容如下：</p><p>1）两个函数$f(x),F(x)$在$x\rightarrow a$都同时倾向于$0$或者$\infty$ </p><p>2）在$a$的去心领域内$f’(x),F’(x)$都存在且$F’(x)\neq 0$</p><p>3）$\lim\limits_{x\rightarrow a}\frac{f’(x)}{F’(x)}$存在（或者无穷大）</p><p>则$\lim\limits_{x\rightarrow a}\frac{f(x)}{F(x)}=\lim\limits_{x\rightarrow a}\frac{f(x)}{F(x)}$</p><p>例子：</p><script type="math/tex; mode=display">1)\lim\limits_{x\rightarrow 0}\frac{\sin{ax}}{\sin bx}=\lim\limits_{x\rightarrow 0}\frac{a\cos ax}{b \cos bx}=\frac{a}{b}</script><p>注意：如果使用完一次洛必达后的式子<strong>仍满足洛必达的条件</strong>可以继续使用</p><p>比如说</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow 1}\frac{x^3-3x+2}{x^3-x^2-x+1}=\lim\limits_{x\rightarrow 1}\frac{3x^2-3}{3x^2-2x-1}=\lim\limits_{x\rightarrow 1}\frac{6x}{6x-2}</script><p>​        到这里就不能再使用洛必达法则了：因为$\lim\limits_{x\rightarrow 1}\frac{6x}{6x-2}$不满足条件1)，所以：直接带值得到$\frac{3}{2}$结束</p><p>​        注意，我们可以使用这个法则分析一些常见函数的发散速度：</p><p>命题：比较$\ln x,x^n,e^{\lambda{x}}$的发散速度</p><p>比较$\ln x,x^n$</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{\ln x}{x^n}=\lim\limits_{x\rightarrow \infty}\frac{1}{nx^{n-1}\cdot{x}}=0</script><p>​        这意味这$\ln{x}$的发散速度小于$x^n$的发散速度。</p><p>比较$x^n，e^{\lambda{x}}$</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{x^n}{e^{\lambda{x}}}=\lim\limits_{x\rightarrow \infty}\frac{nx^{n-1}}{\lambda e^{\lambda{x}}}=\lim\limits_{x\rightarrow \infty}\frac{n(n-1)x^{n-2}}{\lambda ^2e^{\lambda{x}}}=...=\lim\limits_{x\rightarrow \infty}\frac{n!}{\lambda ^ne^{\lambda{x}}}=0</script><p>​    这意味这$x^n$的发散速度小于$e^{\lambda{x}}$的发散速度。</p><h4 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h4><p>​        泰勒公式是用若干多项式近似描述函数的一个公式：</p><script type="math/tex; mode=display">P_n(x)=\sum_{k=0}^{n} a_k(x-x_0)^k +R(x)=f(x)</script><p>​        这样一个过程。$R(x)$是高于n阶的一个误差数。</p><p>​        我们求$x_0$一阶导数得到：$f’(x_0)=a_1$</p><p>​        类似的$f’’(x_0)=1\cdot 2a_2$</p><p>​        $f’’’(x_0)=1\cdot 2 \cdot 3a_3$</p><p>​        …</p><p>​        $f^{(n)}(x)=n!a_n$</p><p>​        这样多项式的系数就确定了！替换一下：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)</script><p>其中$R_n(x)=o(x-x_0)^n$当然，由拉格朗日中值定理，$R_n(x)$也可以这样表达：</p><script type="math/tex; mode=display">R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}</script><p>当然还有更紧凑的形式：</p><script type="math/tex; mode=display">f(x)=\sum_{k=0}^{n}\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k+R_n(x)</script><p>我们使用泰勒公式看看一些函数的近似,为了简便，我们自然取$x_0=0$</p><script type="math/tex; mode=display">e^x=1+x+\frac{x^2}{2}+\frac{x^3}{6}+...+\frac{x^n}{n!}+R_n(x)=\sum_{k=0}^{n}\frac{(x-x_0)^k}{k!}+R_n(x)</script><script type="math/tex; mode=display">\sin{x}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-...(-1)^{(m-1)}\frac{x^{(2m-1)}}{(2m-1)!}+R_{2m}(x)=\sum_{k=0}^{n}\frac{(-1)^{(m-1)}(x-x_0)^k}{(2m-1)!}+R_{2m}(x)</script><script type="math/tex; mode=display">\cos{x}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-...(-1)^{(m-1)}\frac{x^{2m}}{(2m)!}+R_{2m}(x)=\sum_{k=0}^{n}\frac{(-1)^{(m-1)}(x-x_0)^k}{(2m)!}+R_{2m}(x)</script><script type="math/tex; mode=display">\ln{(x+1)}=x-\frac{x^2}{2}+\frac{x^3}{3}-...+(-1)^{(n-1)}\frac{x^n}{n}+\sum_{k=1}^{n}(-1)^{(n-1)}\frac{x^n}{n}+R_n(x)</script><script type="math/tex; mode=display">(1+x)^\alpha=1+\alpha{x}+\frac{\alpha(\alpha-1)}{2!}x^2+...+\frac{\alpha(\alpha-1)...(\alpha-n+1)}{n!}(x-x_0)^n=\sum_{k=0}^{n}\frac{C_k^{\alpha}}{k!}(x-x_0)^k</script><h4 id="函数的单调性"><a href="#函数的单调性" class="headerlink" title="函数的单调性"></a>函数的单调性</h4><p>​        现在，我们可以系统的分析函数的单调性了：</p><p>​        函数的单调性分为单调递增和单调递减：( x 在区间 I ,且函数连续)</p><script type="math/tex; mode=display">函数单调递增:f'(x)>0</script><script type="math/tex; mode=display">函数单调递减:f'(x)<0</script><p>​        于是下面给出定理：</p><script type="math/tex; mode=display">y=f(x)在[a,b]连续,(a,b)可导 且f'(x)\geqslant{0},更进一步的等号在有限个点取到</script><script type="math/tex; mode=display">那么我们说：函数在区间(a,b)上单调递增</script><p>​        同理：单调递减的也是类似的</p><script type="math/tex; mode=display">y=f(x)在[a,b]连续,(a,b)可导 且f'(x)\leqslant{0},更进一步的等号在有限个点取到</script><script type="math/tex; mode=display">那么我们说：函数在区间(a,b)上单调递减</script><p>​        函数的单调性与一阶导数息息相关，看一些例题 </p><script type="math/tex; mode=display">分析y=x-\sin x [-\pi,\pi]的单调性</script><p>​        </p><p>​        因为：</p><script type="math/tex; mode=display">y'=1-\cos{x}\geqslant 0</script><p>​        故函数总在$[-\pi,\pi]$单调递增。</p><p>​        这样的一些点是我们在求解一阶导数的时候需要注意的：</p><p>1）$f’(x)=0$  的点：又叫驻点。</p><p>2)导数不存在的点</p><p>例题：</p><script type="math/tex; mode=display">分析f(x)=2x^3-9x^2+12x-3 的单调性</script><script type="math/tex; mode=display">f'(x)=6x^2-18x+12=6(x-1)(x-2)</script><script type="math/tex; mode=display">所以：x<1单增，1\leqslant{x}\leqslant{2}单减，x\geqslant{2} 单增</script><h4 id="函数的凹凸性"><a href="#函数的凹凸性" class="headerlink" title="函数的凹凸性"></a>函数的凹凸性</h4><p>​        我们还要关注函数是怎样的单调递增或者单调递减，这就需要我们使用二阶导数分析函数的凹凸性。</p><p>​        首先我们来看定义：</p><p>​        <strong>仍对于$f(x)$在区间$I$上连续，如果对任意的$x_1,x_2 \in I (x_1\neq{x_2})$</strong></p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2})<\frac{f(x_1)+f(x_2)}{2}</script><p>​        <strong>我们就称呼$f(x)$在区间$I$上的图像是凹的（上凹）</strong></p><p>​        <strong>类比的：如果：</strong></p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2})>\frac{f(x_1)+f(x_2)}{2}</script><p>​        <strong>那么我们又称呼$f(x)$在区间I上的图像是凸的（下凹的）</strong></p><p><img src="image-20230107152418652.png" alt="image-20230107152418652"></p><p>​        函数$f(x)$如果在$I$上是凹（凸）的，那么$-f(x)$是凸(凹)的。</p><p><img src="image-20230107152556639.png" alt="image-20230107152556639"></p><p>​        我们先前就提到过：函数的凸凹性和函数的二阶导数密切相关，下面我们来一睹定理的芳容：</p><p>​        <strong>设$f(x)$在区间$I$上二阶可导，那么：</strong></p><p>​        <strong>（1）若在$I$上$f’’(x)&gt;0$，那么我们说函数是凹的</strong></p><p>​        <strong>（2）若在$I$上$f’’(x)&lt;0$，那么我们说函数是凹的</strong></p><h4 id="极值及其求法"><a href="#极值及其求法" class="headerlink" title="极值及其求法"></a>极值及其求法</h4><p>​        首先我们需要区分一下极值和最值：</p><p>​        极值：邻域内函数的最大最小值</p><p>​        最值：在全函数的定义域内函数的最大最小值</p><p>下面给出严肃的定义：</p><p>​        定义：$f(x)$在$x_0$的领域$\cup (x_0)$下有定义且连续,$\forall{x}\in\mathring{U}(x_0)$,$f(x)<f(x_0)(或者)(f(x)>f(x_0))$那么我们说$f(x_0)$是函数的极大值 or 极小值。</p><p>​        极值的定理 I:(必要条件)函数可导，且在此点$x_0$的导数 $f’(x_0)=0$</p><p>​        极值的定理 II:(第一充分条件)：$f(x)$在$x_0$处连续,且在$\mathring{U}(x_0)$处可导</p><p>（1）$x \in(x_0-\delta,x_0)$ 且$f’(x)&gt;0$,而$x \in(x_0,x_0+\delta)$ 且$f’(x)&lt;0$我们说函数在此点取上极大值</p><p>（2）$x \in(x_0-\delta,x_0)$ 且$f’(x)&lt;0$,而$x \in(x_0,x_0+\delta)$ 且$f’(x)&gt;0$我们说函数在此点取上极小值</p><p>如果不变号，那就不是极值点。</p><p>​        下面总结流程：</p><p>​        （1）求$f’(x)$</p><p>​        （2）求驻点和不可导点</p><p>​        （3）考察上面这些点的变号情况</p><p>例题：$f(x)=(x-4)\sqrt[3]{(x+1)^2}$的极值点.</p><p>$f’(x)=\frac{5(x-1)}{3\sqrt[3]{x+1}}$令$f’(x)=0$</p><p>得到 $x=1$是驻点，$x=-1$是不可导点</p><p>1)$x=-1$,$x&lt;-1$时，$f’(x)&gt;0$, $x&gt;-1$时，$f’(x)&lt;0$,所以这是一个极大值点</p><p>2）$x=1$,$x<1$时，$f'(x)<0$, $x>-1$时，$f'(x)>0$,所以这是一个极小值点</p><p>当然还有别的判断方式：</p><p>​        定理 II’（第二充分条件）函数$f(x)$二阶可导，$f’(x_0)=0,f’’(x_0)\neq{0}$</p><p>当：</p><p>1)$f’’(x)&lt;0$在$x_0$处取极大值</p><p>2)$f’’(x)&gt;0$,在$x_0$处极小值</p><h4 id="函数图像的绘制"><a href="#函数图像的绘制" class="headerlink" title="函数图像的绘制"></a>函数图像的绘制</h4><p>​        下面我们开始绘制函数的图像！这也是系统分析函数的步骤</p><p>​        1）分析函数的定义域，以及可能的奇偶性，周期性</p><p>​        2)求出一阶导数，二阶导数，和他们等于0的点</p><p>​        3)找出函数的间断点（从定义域得到），以及一阶导数，二阶导数不存在的点</p><p>​        4）由此求出函数的单调性凹凸性</p><p>​        5）看看是否有渐近线（铅锤，水平，斜的渐近线）</p><p>​        6）确定极值（带点）</p><p>例如：$y=x^3-x^2-x+1$</p><p>​        显然函数的定义域为$R$，且无奇偶性，周期性</p><p>​        $f’(x)=3x^2-2x-1,f’’(x)=2(3x-1)$</p><p>​        令$f’(x)=0,x=-\frac{1}{3}或x=1$,当$f’’(x)=0,x=\frac{1}{3}$</p><p>​        确定函数的分间断是：$(-\infty,-\frac{1}{3}),[-\frac{1}{3},\frac{1}{3}],[\frac{1}{3},1],[1,+\infty]$</p><p>​        并且列表时按照如下格式列</p><p>![image-20230107161122390]image-20230107161122390.png)</p><p>补充：函数的渐近线是如下公式确定的：</p><script type="math/tex; mode=display">if :\lim{\frac{f(x)}{x}}=k存在，那就有斜渐近线存在</script><script type="math/tex; mode=display">如果存在:则b=\lim{(f(x)-kx)},直线的方程就是y=kx+b</script><p>至于水平渐近线就是$\lim\limits_{x\rightarrow{\infty}}(f(x)-b)=0$那么就是$y=b$</p><p>铅锤渐近线:$\lim\limits_{x\rightarrow{a}}f(x)\rightarrow\infty$则就是$x=a$</p><h4 id="曲率分析："><a href="#曲率分析：" class="headerlink" title="曲率分析："></a>曲率分析：</h4><p>​        我们使用曲率来分析曲线的弯曲程度：</p><p><img src="image-20230107161834749.png" alt="image-20230107161834749"></p><p>​        这样看</p><p><img src="image-20230107161907141.png" alt="image-20230107161907141"></p><p>​        可以看到，如果$M$移动相同单位，其倾角变化越大，那就称之曲率越大：</p><script type="math/tex; mode=display">\overline{K}=|\frac{\Delta{\alpha}}{\Delta s}|</script><p>​        如果我们让图片里的$M,M’$靠拢，不久类比的得到一个点的曲率了吗 ？（ds是弧微分，后面有图片展示）</p><p>​        </p><script type="math/tex; mode=display">K=\lim\limits_{\Delta s \rightarrow 0}|\frac{\Delta{\alpha}}{\Delta s}|=|\frac{d\alpha}{ds}|</script><p>​        这样：直线的曲率:$K=0$</p><p>​        圆的曲率:$K=\frac{1}{r}$（ r 是圆的半径）</p><p><img src="image-20230107162607705.png" alt="image-20230107162607705"></p><p>​        曲率的公式在直角坐标系的公式可以从定义得到:</p><p>​        $y’=\tan{\alpha}$,$y’’=\sec^2{\alpha}$,于是:</p><script type="math/tex; mode=display">|\frac{d\alpha}{dx}|=\frac{y''}{\sec^2{x}}=\frac{y''}{1+\tan^2{\alpha}}=\frac{y''}{1+y'^2}</script><p>​        而$ds=$$\sqrt{1+y’^2}$</p><p><img src="image-20230107163229852.png" alt="image-20230107163229852"></p><p>​                                                                        弧微分</p><p>​        于是：</p><script type="math/tex; mode=display">|\frac{d\alpha}{ds}|=|\frac{\frac{y''}{1+y'^2}}{\sqrt{1+y'^2}}|=|\frac{y''}{(1+y'^2)^\frac{3}{2}}|</script><p>​        类比的，在参数方程下：</p><p><img src="image-20230107163642181.png" alt="image-20230107163642181"></p><p>​    这一章内容通俗的说：就是求导的反向操作：我们需要求出谁求导的到现在的东西</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​        假设一个函数$f(x)$是一个函数$F(x)$求导的结果，那么称$F(x)$是$f(x)$的一个愿函数</p><p>这是因为$F(x)+C$(C是一个常数)求导也是$f(x)$</p><p>​        原函数存在定理：<strong>连续的函数一定有原函数</strong></p><p>​        说了这么多，我们又该怎么表示一个函数的原函数呢</p><script type="math/tex; mode=display">\int f(x)dx=F(x)+C</script><p>​        比如说：$\int x^2dx=\frac{x^3}{3}+C$</p><p>​        但是注意：这个容易错：$\int \frac{1}{x}dx=\ln{|x|}+C$</p><p>​        因为（x&lt;0）下$\ln{x}$无定义，可以把$\frac{-1}{-x}$看，这样就好了。</p><p>​        下面来看一些式子：</p><script type="math/tex; mode=display">\frac{d}{dx}[\int f(x)dx]=f(x)</script><script type="math/tex; mode=display">d[\int f(x)dx]=f(x)dx</script><p>​        说明了积分号在内微分号在外的式子，没有常数C（本质是$df(x)=f’(x)dx$）</p><p>​        </p><script type="math/tex; mode=display">\int F'(x)dx=F(x)+C</script><p>​        说明了积分号在外微分号在内的式子，有常数C（本质是$\int f(x)dx=F(x)+C$）</p><h3 id="积分表"><a href="#积分表" class="headerlink" title="积分表"></a>积分表</h3><p>​        幂函数的积分</p><script type="math/tex; mode=display">\int x^\mu dx=\frac{x^{\mu+1}}{\mu+1}+C</script><p>​        常数的不定积分：</p><script type="math/tex; mode=display">\int kdx=kx+C</script><p>​        </p><script type="math/tex; mode=display">\int \frac{dx}{1+x^2}dx=\arctan{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\sqrt {1-x^2}}dx=\arcsin{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\cos^2{x}}=\int \sec^2{x}=\tan{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\sin^2{x}}=\int \csc^2{x}=-\cot{x}+C</script><script type="math/tex; mode=display">\int \sec{x}\tan xdx=\sec{x}+C</script><script type="math/tex; mode=display">\int \csc{x}\cot{x}dx=-\csc{x}+C</script><script type="math/tex; mode=display">\int \frac{1}{x}dx=\ln |x|+C</script><script type="math/tex; mode=display">\int \cos{x}dx=\sin{x}+C</script><script type="math/tex; mode=display">\int \sin{x}dx=-\cos{x}+C</script><script type="math/tex; mode=display">\int e^xdx=e^x+C</script><script type="math/tex; mode=display">\int a^xdx=\frac{a^x}{\ln{a}}+C</script><h3 id="不定积分的性质"><a href="#不定积分的性质" class="headerlink" title="不定积分的性质"></a>不定积分的性质</h3><p>​        1）$\int [f(x)\pm g(x)]dx=\int f(x)dx \pm \int g(x)dx$</p><p>​        2)$\int kf(x)dx=k\int f(x)dx$</p><h3 id="第一类换元积分（凑微分法）"><a href="#第一类换元积分（凑微分法）" class="headerlink" title="第一类换元积分（凑微分法）"></a>第一类换元积分（凑微分法）</h3><p>​        首先回到这里：$\int 1 dF(u)=F(u)+C$,现在假设$u=\varphi (x)$,这样，我们就有$\int 1dF(\varphi(x))=F(\varphi(x))+C$,进一步的：$\int f(\varphi(x))\varphi ‘(x)dx=F(\varphi(x))+C$</p><p>说白了，就是复合求导的逆过程，我们的核心过程就是通过合并至d后面从而化简函数：</p><p>1）$\int 2\cos 2xdx$</p><p>解：$\int \cos 2xd(2x)=sin(2x)+C$</p><p>2)$\int \frac{1}{3+2x}dx$</p><p>解：$\int \frac{1}{2}\frac{1}{3+2x}d(2x+3)=\frac{1}{2}\ln|(2x+3)|+C$</p><p>3)$\int 2x e^{x^2}dx$</p><p>解：$\int  e^{x^2}dx^2= e^{x^2}+C$</p><p>4)$\int x\sqrt{1-x^2}dx$</p><p>解：$-\frac{1}{2}\int \sqrt{1-x^2}d(1-x^2)=-\frac{1}{3}(1-x^2)^{1.5}+C$</p><p>5)$\int \frac{x^2}{(x+2)^3}dx$</p><p>解:</p><p>$令:x+2=u$,$\int \frac{(u-2)^2}{u^3}du=\int (\frac{1}{u}-\frac{4}{u^2}+\frac{4}{u^3})du=\ln |u|+\frac{4}{u}-2\frac{1}{u^2}$</p><p>于是:$\ln |x+2|+\frac{4}{x+2}-2\frac{1}{(x+2)^2}$</p><p>6)$\int \frac{1}{a^2+x^2}dx(a\neq 0)$</p><p>解：$=\frac{1}{a}\int \frac{1}{1+(\frac{x}{a})^2}d(\frac{x}{a})=\frac{1}{a}\arctan \frac{x}{a}+C$</p><p>7)$\int \frac{dx}{\sqrt{a^2-x^2}}$</p><p>解：$\frac{1}{a}\int \frac{dx}{\sqrt{1-(\frac{x}{a})^2}}=\arcsin \frac{x}{a}+C$</p><p>8)$\int \frac{dx}{x^2-a^2}$</p><p>解：$\frac{1}{2a}\int (\frac{1}{x-a}-\frac{1}{x+a})dx=\frac{1}{2a}\ln|\frac{x-a}{x+a}|+C$</p><p>9)$\int \frac{dx}{x(1+2\ln x)}$</p><p>解：$\int \frac{d\ln{x}}{1+2\ln x}=\frac{1}{2}\ln|1+2\ln x|+C$</p><p>10）$\int \frac{e^{3\sqrt{x}}}{\sqrt{x}}dx$</p><p>解：$=2\int e^{3\sqrt{x}}d{\sqrt{x}}=\frac{2}{3}e^{3\sqrt{x}}+C$</p><p>11)$\int \sin^3xdx$</p><p>解：$\int sin^2xd\cos x=\int (1-cos^2x)d\cos x=-\cos x-\frac{1}{3}\cos^3x+C$</p><p>12)$\int \sin^2x\cos^5xdx$</p><p>解：$\int \sin^2\cos^4xd\sin x=\int \sin^2x(1-\sin^2x)^2d\sin x=\frac{\sin^3x}{3}-\frac{2\sin^5x}{5}+\frac{\sin^7x}{7}+C$</p><p>13)$\int \tan xdx$</p><p>解：</p><p>$\int \frac{\sin x}{\cos x}dx=-\int \frac{1}{\cos x}d\cos x=-\ln|cos(x)|+C$</p><p>14)$\int \cos^2xdx$</p><p>解：$\int \frac{1+\cos2x}{2}dx=\frac{x}{2}+\frac{\sin 2x}{4}+C$</p><p>15)$\int \sin^2x\cos^4xdx$</p><p>解：$\int \frac{1-\cos{2x}}{2}(\frac{1+\cos{2x}}{2})^2dx=\frac{1}{8}(x+\frac{1}{2}\sin 2x-\frac{1}{2}x-\frac{1}{8}\sin 4x-\frac{1}{2}(\sin 2x-\frac{sin^3 2x}{3}))+C$</p><p>16)$\int \sec^6xdx$</p><p>解：$\int \sec^4xd\tan x=\int (\tan^2x+1)^2d\tan x=\frac{\tan^5x}{5}+\frac{2\tan^3x}{3}+\tan x+C$</p><p>17)$\int \csc xdx$</p><p>解：$\int \frac{1}{\sin x}dx=\frac{\cos \frac{x}{2}dx}{2\sin \frac{x}{2}\cos^2\frac{x}{2}}=\int \frac{\sec^2\frac{x}{2}}{\tan\frac{x}{2}}d(\frac{x}{2})=\int \frac{d\tan\frac{x}{2}}{\tan \frac{x}{2}}=\ln|\tan \frac{x}{2}|+C$</p><p>总结下：三角函数者：奇次提，偶次被倍角公式替换</p><h3 id="第二类换元积分"><a href="#第二类换元积分" class="headerlink" title="第二类换元积分"></a>第二类换元积分</h3><p>​        我们把d()内的东西往外提，化而言之：就是换元$x=\varphi(t)$再求积分：</p><p>$\int f(x)dx=\int f(\varphi(t))\varphi’(t)dt$</p><p>1)$\int \sqrt{a^2-x^2}dx(a&gt;0)$</p><p>解:令：$x=a\sin t,t\in(-\frac{\pi}{2},\frac{\pi}{2})$</p><p>故：$\int \sqrt{a^2-x^2}dx=a\cos tdx$</p><p>$dx=a\cos t$</p><p>因此：$\int a^2\cos^2tdt=a^2(\frac{t}{2}+\frac{\sin2t}{4})+C=a^2t+a^2\frac{\sin t\cos t}{2}+C$</p><p>又$\sin t=\frac{x}{a},\cos t=\frac{\sqrt{a^2-x^2}}{a}$</p><p>这样：$\frac{a^2}{2}\arcsin\frac{x}{a}+\frac{x}{2}\sqrt{a^2-x^2}+C$</p><p>2)$\int \frac{dx}{\sqrt{x^2+a^2}}(a&gt;0)$</p><p>现令：$x=a\tan t$</p><p>则：$\int \frac{dx}{a\sec x}$</p><p>又：$dx=a\sec^2 tdt$</p><p>那么：$\int \sec tdt=\ln|\sec t+\tan t|+C$</p><p>我们可以使用三角形法来看：</p><p><img src="image-20230120122352772.png" alt="image-20230120122352772"></p><p>这下，我们找到了：$\tan t=\frac{x}{a},\sec t= \frac{\sqrt{x^2+a^2}}{a}$</p><p>于是：$=\ln|\frac{\sqrt{x^2+a^2}}{a}+\frac{x}{a}|+C=\ln(\sqrt{x^2+a^2}+x)+C’$</p><p>3)$\int \frac{dx}{\sqrt{x^2-a^2}}$</p><p>解：</p><p>令：$x=a\sec t,则：\int \frac{dx}{a\tan t}$</p><p>$dx=a\sec t\tan tdt$</p><p>于是：$\int \sec tdt=\ln(x+\sqrt{x^2-a^2})+C$</p><p><strong>小总结：</strong></p><p>$\sqrt{a^2-x^2}\longrightarrow x=a\sin t,|a\cos t|$</p><p><strong>$\sqrt{x^2-a^2}\longrightarrow x=a\sec t,|a\tan t|$</strong></p><p>$\sqrt{a^2+x^2}\longrightarrow x=a\tan t,|a\sec t|$</p><p>4)$\int \frac{\sqrt{a^2-x^2}}{x^4}dx$</p><p>解：令：$x=\frac{1}{t}$得：</p><p>$dx=-\frac{1}{t^2}dt,-\int (a^2t^2-1)^{0.5}|t|dt$</p><p>由此：$x&gt;0下 ,=-\frac{(a^2-x^2)^{1.5}}{2a^2x^3}+C$</p><p>或者使用三角函数也可以：</p><p><img src="image-20230120124326362.png" alt="image-20230120124326362"></p><h3 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h3><p>​        我们来看：$\int udv=uv-\int vdu$</p><p>我们就可以化简积分了：如：</p><p>1)$\int xe^xdx=\int xde^x=xe^x-e^x=(x-1)e^x+C$</p><p>有的时候，我们可以尝试的去试试看谁做微分是简单的</p><p>往往$e^x$要放到微分里。</p><p>2)$\int x\cos xdx=\int xd\sin x=x\sin x-\int \sin xdx=x\sin x+\cos x+C$</p><p>往往三角函数要放到微分里。</p><p>那这样呢：</p><p>$\int \sin x e^xdx$</p><p>注意：$=\sin xe^x-\int e^x\cos xdx=\sin x e^x-\cos xe^x-\int \sin x e^xdx$</p><p>居然出现了我们要求的东西：</p><p>于是：$\int \sin x e^xdx=\frac{1}{2}(\sin x e^x-\cos xe^x)$</p><p>3)$\int \arccos xdx=x\arccos x-\frac{1}{2}\int \frac{d(1-x^2)}{\sqrt{1-x^2}}=x\arccos x-\sqrt{1-x^2}+C$</p><h3 id="有理函数"><a href="#有理函数" class="headerlink" title="有理函数"></a>有理函数</h3><p>​        这是针对$\frac{P(x)}{Q(x)}$的有理分式的积分方法：我们主要是添项拆项从而分离成若干简单分式的和差，从而方便我们的积分</p><p>1）P(x)的阶高于Q(x)</p><p>​        我们分离常数使之所有的子分式的分母阶比分子高：</p><p>2）P(x)的阶低于Q(x)</p><p>i.分母一阶的，直接$\ln$</p><p>ii.分母二阶的：</p><p>可以因式分解的：分解因式化简</p><p>不可以因式分解的：配方后变成$(ax+b)^2+C$的$\arctan$类型积分</p><p><img src="image-20230120130430538.png" alt="image-20230120130430538"></p><p>iii.分子分母差一次、</p><p>把分子扔进d里面升次</p><p><img src="image-20230120130642841.png" alt="image-20230120130642841"></p><p>iv.一般的</p><p>我们假设一个式子可以分解成若干的分式和，其分式的特点是：分子比分母底一阶，分子假设为全项的多项式：</p><p>如</p><p><img src="image-20230120130943140.png" alt="image-20230120130943140"></p><p>根式：</p><p>令t为根式，换元即可</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    定积分是从求解曲边梯形的面积产生的：就是说求解类似于如下的图像的面积</p><p><img src="image-20230124151114672.png" alt="image-20230124151114672"></p><p>​        怎么搞？我们试想一下，使用如下的方式：通过把面积切成很小的小块：</p><p>由于这些面积可以近似成矩形甚至是梯形，我们可以用面积和近似代替曲边梯形的面积。</p><p><img src="image-20230124151244623.png" alt="image-20230124151244623"></p><p>数学上是这么</p><script type="math/tex; mode=display">假设分点:a=x_0<x_1<x_2...<x_{n-1}<x_n=b</script><p>产生了</p><script type="math/tex; mode=display">\Delta x_1,\Delta x_2,...,\Delta x_n,随后令\lambda=max\{\Delta x_1,\Delta x_2,...,\Delta x_n\}</script><p>​        只要切的够小，我们就可以:$S\approx \sum_{k=1}^n \Delta x_kf(\sigma_k)$</p><p>​        其中$\sigma_k$是小区间上的一个任意点。怎么逼近真实值呢？让点取的密集一些：就是令$\lambda \rightarrow 0$就好了：产生的极限就是面积。</p><p>​        我们可以引入定积分了：</p><p>​        定义：$f(x)$在[a,b]有界，在[a,b]上任意插入若干个分点（随便插入），产生N个小区间，其长度为:$x_k(0&lt;k\leq n)$,又在区间上任意取一点$\sigma_i$，现在取出这些区间内最大长度的长度值记成$\lambda$,也就是$\lambda=max\{\Delta x_1,\Delta x_2,…\Delta x_n\}$。这下有了假设和的极限：$\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)$ 假设他存在：就引入这样的记号：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        其中a,b叫积分下限和积分上限，被积函数是f(x),积分区间是[a,b],积分变量是x</p><p>​        注意，这个值（或者说这个定积分）与积分变量无关，也就是说：</p><script type="math/tex; mode=display">\int_a^b f(t)dt=\int_a^b f(x)dx</script><p>​        定理1：函数只要连续就一定可积。</p><p>​        定理2：函数<strong>有界</strong>且<strong>有有限个间断点</strong>也可积。</p><h3 id="定积分的几何意义"><a href="#定积分的几何意义" class="headerlink" title="定积分的几何意义"></a>定积分的几何意义</h3><p>​        1.$f(x)\geq0$</p><p>​        <img src="image-20230124153747909.png" alt="image-20230124153747909"></p><p>​        就是阴影部分面积</p><p>​        2.$f(x)\leq0$</p><p><img src="image-20230124153828323.png" alt="image-20230124153828323"></p><p>​        注意是阴影部分面积的相反数，这是因为：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        中：$f(\sigma_k)&lt;0$</p><h6 id="矩阵法"><a href="#矩阵法" class="headerlink" title="矩阵法"></a>矩阵法</h6><p>​        我们使用切分成矩阵的方式来计算定积分</p><p><img src="image-20230124154130711.png" alt="image-20230124154130711"></p><h6 id="梯形法"><a href="#梯形法" class="headerlink" title="梯形法"></a>梯形法</h6><p><img src="image-20230124154214737.png" alt="image-20230124154214737"></p><p>看看就好，不用他来计算</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1）a=b下：$\int_a^b f(x)dx=0$</p><p>2)$\int_a^b f(x)dx=-\int_b^a f(x)dx$</p><p>3)$\int_a^b (\alpha f(x)+\beta g(x))dx=\alpha \int_a^b f(x)dx+\beta\int_a^b g(x)dx$</p><p>4)$\int_a^b f(x)dx=\int_a^c f(x)dx+\int_c^b f(x)dx$(切成两块加)</p><p>5)$f(x)\equiv 1,\int_a^b 1dx=b-a,\int_a^b kdx=k(b-a)$</p><p>6)$f(x)\geq 0,\int_a^b f(x)dx\geq0$</p><p>7)$f(x)\leq 0,\int_a^b f(x)dx\leq0$</p><p>8)$f(x)\leq g(x),\int_a^b f(x)dx\leq\int_a^b g(x)dx$</p><p>来点推论：</p><p>1.</p><script type="math/tex; mode=display">|\int_a^b f(x)dx|\leq\int_a^b |f(x)|dx</script><p>2.函数的极大值和极小值为$M,m$</p><script type="math/tex; mode=display">m(b-a)\leq\int_a^b f(x)dx\leq M(b-a)</script><p>9)定积分中值定理：$f(x)$连续,$\exists \xi\in[a,b]$</p><script type="math/tex; mode=display">\int_a^b f(x)dx=f(\xi)(b-a)</script><p>这个定理可以用来化简带有积分的极限</p><p><img src="image-20230124155256516.png" alt="image-20230124155256516"></p><h3 id="微积分的基本公式"><a href="#微积分的基本公式" class="headerlink" title="微积分的基本公式"></a>微积分的基本公式</h3><h4 id="积分上限函数"><a href="#积分上限函数" class="headerlink" title="积分上限函数"></a>积分上限函数</h4><p>我们把一个限变成一个变量，有点像把一边可以自由滑动，这样就有一个变限积分函数，我们把目光集中在x上：</p><script type="math/tex; mode=display">\int_a^x f(t)dt</script><p>这样定积分就从一个值变成一个函数</p><script type="math/tex; mode=display">\phi(x)=\int_a^x f(t)dt</script><p>定理1：</p><script type="math/tex; mode=display">\phi'(x)=\frac{d}{dx}\int_a^x f(t)dt=f(x)</script><p>这样来看，$\phi(x)$就是$f(x)$的一个原函数。值得一提的是：</p><script type="math/tex; mode=display">(\int_x^a f(t)dt)'=-f(x)</script><script type="math/tex; mode=display">(\int_a^{\varphi(x)} f(t)dt)'=f(\varphi(x))\varphi'(x)</script><script type="math/tex; mode=display">[\int_{\varphi(x)}^{\phi(x)}f(t)dt]'=f(\phi(x))\varphi'(x)-f(\varphi(x))\phi'(x)</script><p>上面那个可能太抽象，可以使用性质2）插入一个常数点a</p><h4 id="牛顿莱布尼兹公式"><a href="#牛顿莱布尼兹公式" class="headerlink" title="牛顿莱布尼兹公式"></a>牛顿莱布尼兹公式</h4><script type="math/tex; mode=display">\int_a^bf(x)dx=F(x)|_a^b=F(b)-F(a)</script><p>​        其中$F(x)$是$f(x)$的原函数。</p><p>例如：$\int_0^1 x^2dx$</p><p>解：=$\frac{1}{3}x^3|_0^1=\frac{1}{3}$</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><h4 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h4><p>​        定理：我们令$x=\varphi(t)$使之$\varphi(\alpha)=a,\varphi(\beta)=b$</p><script type="math/tex; mode=display">\int_a^bf(x)dx=\int_\alpha^\beta(\varphi(t))\varphi'(t)dt</script><p>例题：</p><p>1）$\int_0^a\sqrt{a^2-x^2}dx$</p><p>解：$令x=a\sin t$,$dx=a\cos tdt$</p><p>$=\int_0^{\frac{\pi}{2}}a^2\cos^2tdt=\frac{\pi}{4}a^2$</p><p>一些技巧：</p><p>1）$[-a,a]$下：$f(x)$偶：$\int_{-a}^{a}f(x)dx=2\int_{0}^{a}f(x)dx$,$f(x)$奇则为0。</p><p>2）$\int_{0}^{\frac{\pi}{2}}f(\sin x)dx=\int_{0}^{\frac{\pi}{2}}f(\cos x)dx$</p><p>3)$\int_{0}^{\pi}xf(\sin x)dx=\frac{\pi}{2}\int_0^{\pi}f(\sin x)dx$</p><p>（2）（3）怎么说？</p><p>2）令：$x=\frac{\pi}{2}-t,dx=-dt$就可以了</p><p>3）令：$x=\pi-t,dx=-dt$带入之后化简一下得到：</p><script type="math/tex; mode=display">\int_{0}^{\pi}xf(\sin x)dx=\int_{0}^{\pi}(\pi-t)f(\sin t)dt=\pi\int_{0}^{\pi}f(\sin x)dx-\int_{0}^{\pi}xf(\sin x)dx</script><p>(上面中因为与积分变量无关由此可以直接替换)</p><p>例题：$\int_0^{\pi}\frac{x\sin x}{1+\cos^2x}dx=\frac{\pi}{2}\int_0^{\pi}\frac{\sin x}{1+\cos^2x}dx=-\frac{\pi}{2}\arctan(\cos x)|_0^\pi=\frac{\pi^2}{4}$</p><p>4)$\int_a^{a+T}f(x)dx=\int_0^Tf(x)dx$(f(x)是一个周期函数，周期是T)</p><p>5）$\int_a^{a+nT}f(x)dx=n\int_0^af(x)dx$</p><h4 id="分部积分"><a href="#分部积分" class="headerlink" title="分部积分"></a>分部积分</h4><p>​        首先回顾$\int udv=uv-\int vdu$这个公式，于是，在定积分的也自然就是：</p><script type="math/tex; mode=display">\int_a^b udv=uv|_a^b - \int_a^b vdu</script><p>​        例如：$\int _0^\frac{1}{2} \arcsin xdx$</p><p>​        注意到$x$也是一个函数：于是$\int _0^\frac{1}{2} \arcsin xdx=x\arcsin x|_0^\frac{1}{2} - \int_0^\frac{1}{2} \frac{x}{\sqrt {1-x^2} }dx=\frac{\pi}{12}+\frac{\sqrt 3}{2}-1$</p><p>​        也有上面提到的方法一块用的积分：</p><p>​        $\int_0^1 e^\sqrt{x}dx$</p><p>​        令:$t=\sqrt x$, 则:$2\int_0^1 te^tdt$=$2te^t|_0^1-2\int_0^1 e^tdt=2$</p><h3 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h3><h4 id="无穷限的反常积分"><a href="#无穷限的反常积分" class="headerlink" title="无穷限的反常积分"></a>无穷限的反常积分</h4><p>​        什么叫反常积分呢？就是说积分区域下函数在这一点反常。比如说，因为积分区域含有无穷的积分：</p><script type="math/tex; mode=display">\int_a^{+\infty} f(x)dx</script><p>​        或者是这样的：</p><script type="math/tex; mode=display">\int_{-\infty}^b  f(x)dx</script><p>​        这样的积分是无穷限的反常积分。我们不妨采用动态的方法：</p><script type="math/tex; mode=display">\int_a^{+\infty} f(x)dx=\lim_\limits{t\rightarrow +\infty}\int_a^t f(x)dx</script><p>​        这下也有类似的：</p><script type="math/tex; mode=display">\int_{-\infty}^b  f(x)dx=\lim_\limits{t\rightarrow -\infty}\int_t^b f(x)dx</script><p>​        牵扯到了极限，因此：如果上面的极限是存在的，那就：之人格积分是收敛的，反之发散。</p><p>​        还有上下限均是无穷的积分，仍采用上面的处理方式。在实际求值的时候，也是直接</p><script type="math/tex; mode=display">\int_a^{+\infty}f(x)dx=F(x)|_a^{+\infty}</script><p>​        一个结论：对于</p><script type="math/tex; mode=display">\int_a^{+\infty}\frac{dx}{x^p}(a>0)</script><p>​        <strong>p&gt;1收敛，p$\leq 1$手来你</strong></p><h4 id="反常积分：无界函数的反常积分"><a href="#反常积分：无界函数的反常积分" class="headerlink" title="反常积分：无界函数的反常积分"></a>反常积分：无界函数的反常积分</h4><p>​        什么意思？就是说函数在某一点没有定义，我们的积分区域却包含了它。比如说</p><script type="math/tex; mode=display">\int_0^1 \frac{1}{x}dx</script><p>​        结合上一小节的类似方法，我们得到</p><script type="math/tex; mode=display">\int_0^1 \frac{1}{x}dx=\lim\limits_{t\rightarrow 0^+}\int_t^1\frac{1}{t}dx</script><p>​        类似的： </p><script type="math/tex; mode=display">\int_{-1}^0 \frac{1}{x}dx=\lim\limits_{t\rightarrow 0^-}\int_{-1}^t\frac{1}{t}dx</script><p>​        如果这样的点在中间，我们就拆开积分区域就好了。</p><h4 id="补充：-Gamma-s-函数"><a href="#补充：-Gamma-s-函数" class="headerlink" title="补充：$\Gamma(s)$函数"></a>补充：$\Gamma(s)$函数</h4><p>​        $\Gamma(s)$函数是这样定义的：</p><script type="math/tex; mode=display">\Gamma(s)=\int_0^{+\infty}e^{-x}x^{s-1}dx(s>0)</script><p>​        具有以下非常好推导的性质：</p><script type="math/tex; mode=display">1)\Gamma(s+1)=s\Gamma(s)</script><script type="math/tex; mode=display">2)\Gamma(1)=1</script><p>基于2)，我们发现了这个函数的一个奇妙公式：</p><script type="math/tex; mode=display">\Gamma(s+1)=s!</script><h4 id="补充：比较审敛原理"><a href="#补充：比较审敛原理" class="headerlink" title="补充：比较审敛原理"></a>补充：比较审敛原理</h4><p>​        我们假设:$f(x)$和$g(x)$在[a,$\infty$ ]上连续，$60 \leq f(x)\leq g(x)$如果：</p><script type="math/tex; mode=display">1)\int_a^{+\infty}g(x)dx收敛\rightarrow\int_a^{+\infty}f(x)dx收敛</script><script type="math/tex; mode=display">1)\int_a^{+\infty}f(x)dx发散\rightarrow\int_a^{+\infty}g(x)dx发散</script><p>​        很好理解：大哥收敛小弟也收敛，小弟嚣张大哥肯定也嚣张。</p><h4 id="补充：比较审敛法"><a href="#补充：比较审敛法" class="headerlink" title="补充：比较审敛法"></a>补充：比较审敛法</h4><p>​    设$f(x)$在[a,$\infty$]连续(a&gt;0)，且$f(x)\geq 0,\exists M&gt;0,p&gt;1$</p><p>​        如果使得:$f(x)\leq \frac{M}{x^p}$那就$\int_a^{+\infty}f(x)dx$收敛</p><p>​        反之：$f(x)\geq \frac{M}{x},$那就$\int_a^{+\infty}f(x)dx$发散</p><h4 id="补充：绝对审敛法"><a href="#补充：绝对审敛法" class="headerlink" title="补充：绝对审敛法"></a>补充：绝对审敛法</h4><p>​        如果$f(x)$在设$f(x)$在[a,$\infty$]连续（a&gt;0), $\int_a^{+\infty}|f(x)|dx$收敛，那么$\int_a^{+\infty}f(x)dx$收敛。</p><p>​        最后不难得到这个定理</p><h4 id="补充：无界函数反常积分的审敛法"><a href="#补充：无界函数反常积分的审敛法" class="headerlink" title="补充：无界函数反常积分的审敛法"></a>补充：无界函数反常积分的审敛法</h4><p>​        回到这个积分</p><script type="math/tex; mode=display">\int_a^b \frac{dx}{(x-a)^q}</script><p>​        $x=a$显然是一个瑕点$q&lt;1$收敛，q$\geq$1发散。</p><p>​        基于这个积分，我们再次应用比较原理：</p><p>​        如果$f(x)$在(a,b]连续,f(x)$\geq$0,如果$\exists M&gt;0$及其$q&lt;1$使得</p><script type="math/tex; mode=display">1)f(x)\leq \frac{M}{(x-a)^q}收敛</script><script type="math/tex; mode=display">2)f(x)\geq \frac{M}{x-a}发散</script><h4 id="补充：极限审敛法"><a href="#补充：极限审敛法" class="headerlink" title="补充：极限审敛法"></a>补充：极限审敛法</h4><p>​        如果$f(x)$在(a,b]连续,f(x)$\geq$0，$x=a$为$f(x)$的瑕点</p><p>​        1）$\exists 0&lt;q&lt;1$使得$\lim\limits_{x\rightarrow a^+}(x-a)^qf(x)=A$直接说明一件事：$\int_a^b f(x)dx$收敛。</p><p>​        2）类比的$\lim\limits_{x\rightarrow a^+}(x-a)f(x)=A$或者是$\infty$，我们直接认为$\int_a^b f(x)dx$发散。</p><h3 id="定积分的元素法"><a href="#定积分的元素法" class="headerlink" title="定积分的元素法"></a>定积分的元素法</h3><p>​        回到定积分的这个定义式：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        <strong>本质上，这样的一个定积分就是描述瞬时元素在某一个维度的积累效应的量化程度</strong>，这就是说：它既可以用来描述面积，又可以描述体积，只需要我们掌握了相应的边界函数，只要对应积分即可。</p><p><img src="image-20230130163127477.png" alt="image-20230130163127477"></p><p>​        比如说，这个的体积就是面积函数A(x)对于高度x的积分</p><script type="math/tex; mode=display">V=\int_{x_1}^{x_2}A(x)dx</script><h3 id="补充一下极坐标"><a href="#补充一下极坐标" class="headerlink" title="补充一下极坐标"></a>补充一下极坐标</h3><p>​        我们重新用一种全新的角度来看待坐标系：我们改用距离原点的距离+偏离X轴正方向的描述方法描述点的坐标。</p><p><img src="image-20230130163636247.png" alt="image-20230130163636247"></p><p>这样，一个点就总是可以表示为$A=(\rho, \theta)$，比如说极坐标下(1,1)变成了$(\sqrt 2,\frac{\pi}{4})$,现在，我们试着求：</p><p><img src="image-20230130174155076.png" alt="image-20230130174155076"></p><p>这个阴影面积：怎么办？延续老方法：假设点沿着曲线挪动一丁点，那么我们的产生的微小的面积则是：</p><script type="math/tex; mode=display">dS=\frac{\rho^2d\theta}{2}</script><p>然后从哪到哪？$\alpha$到$\beta$。</p><script type="math/tex; mode=display">S=\int_\alpha^\beta \frac{\rho^2d\theta}{2}</script><p>结束。</p><h3 id="平面图形的面积"><a href="#平面图形的面积" class="headerlink" title="平面图形的面积"></a>平面图形的面积</h3><h4 id="直角坐标系"><a href="#直角坐标系" class="headerlink" title="直角坐标系"></a>直角坐标系</h4><p>​        我们说函数相交也可以产生一些面积</p><p><img src="image-20230130174758444.png" alt="image-20230130174758444"></p><p>​        这个怎么求呢？</p><p><img src="image-20230130174916021.png" alt="image-20230130174916021"></p><p>​        我们的差面积就是：</p><script type="math/tex; mode=display">S=\int_a^bf(x)dx-\int_a^b g(x)dx=\int_a^bf(x)-g(x)dx</script><p>​        这样的差是X型的面积积分，因为我们拿X作为梯形的高</p><p>​        那就还有Y型面积：</p><p><img src="image-20230130175121419.png" alt="image-20230130175121419"></p><p>​        类比的：</p><script type="math/tex; mode=display">S=\int_c^d \varphi(y)-\phi(y)dy</script><p>​        也即是：</p><p>​            X:$S=\int 上-下dx$</p><p>​            Y:$S=\int 右-左dy$</p><p>​        </p><p>​        总结一下：我们对面积先大致画出来图长什么样：如果是这样的</p><p>​        <img src="image-20230130175729566.png" alt="image-20230130175729566"></p><p>​        就这样使用X，Y对应当打，如果不好判断，就都先试试，哪个更加容易用哪个。</p><p>​        举例：求$y=\frac{1}{2}x^2$,$y=\frac{1}{1+x^2}$在$x \in [-\sqrt 3,\sqrt 3]$下的定积分。</p><p>​        我们可以做出图像：</p><p><img src="image-20230202133001296.png" alt="image-20230202133001296"></p><p>​        砍开来看：</p><script type="math/tex; mode=display">S=\int_{-\sqrt{3}}^{-1}(\frac{1}{2}x^2-\frac{1}{1+x^2})+\int_{-1}^1(\frac{1}{1+x^2}-\frac{1}{2}x^2)+\int_{1}^{\sqrt{3}}(\frac{1}{2}x^2-\frac{1}{1+x^2})</script><p>​        随后使用偶函数的对称性结束计算。</p><p>​        求椭圆的面积：$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$</p><p>​        可以拆开四分之一的部分$S_1=\int_0^aydx$</p><p>​        现在，我们引入椭圆参数方程来消去参数：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=a\cos t \\y=a\sin t \end{aligned} \right . \end{equation}</script><p>来看看变成什么了：</p><script type="math/tex; mode=display">S_1=-\int_0^{\frac{\pi}{2}}a\sin t \times a(-\sin t)dt=\frac{\pi ab}{4}</script><p>这就是为什么：</p><script type="math/tex; mode=display">S=\pi ab</script><h4 id="极坐标下"><a href="#极坐标下" class="headerlink" title="极坐标下"></a>极坐标下</h4><p>​        回忆前面所叙述的：对于方程$R=\rho (\theta)$</p><script type="math/tex; mode=display">S=\frac{1}{2}\int_{\alpha}^{\beta}(\rho (\theta))^2d\theta</script><p>​        比如说：$\rho=a\theta$</p><script type="math/tex; mode=display">S=\frac{1}{2}\int_0^{2\pi}(a\theta)^2d\theta=\frac{4}{3}a^2\pi^3</script><h3 id="旋转体体积求法"><a href="#旋转体体积求法" class="headerlink" title="旋转体体积求法"></a>旋转体体积求法</h3><p>说白了可以切成以$f(x)$为半径的圆，在叠起来（求积分）</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2}\pi f^2(x)dx</script><p> 是通过</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2} A(x)dx</script><p>​        派生来的，只是因为面积恰好是圆。</p><p>​        但是，这样的体积求解的是绕X轴的。绕Y轴的怎么办哪？</p><p>​        简单：那就改写方程为$x=x(y)$就好了：</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2}x^2(y)dy</script><h3 id="弧长的求解"><a href="#弧长的求解" class="headerlink" title="弧长的求解"></a>弧长的求解</h3><h4 id="通用："><a href="#通用：" class="headerlink" title="通用："></a>通用：</h4><p>回来看看这个参数方程：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=\varphi(t) \\y=\phi(t)\end{aligned} \right . \end{equation}</script><p>​        弧微分很容易说：</p><script type="math/tex; mode=display">ds=\sqrt{(dx)^2+(dy)^2}dt=\sqrt{(\varphi'(t))^2+(\phi'(t))^2}dt</script><p>​        于是：</p><script type="math/tex; mode=display">L=\int_\alpha^\beta \sqrt{(\varphi'(t))^2+(\phi'(t))^2}dt</script><p>​        作为积分结果，就是弧长。</p><p>​        以此为源头，开始推广其他的公式：</p><h4 id="直角坐标系下"><a href="#直角坐标系下" class="headerlink" title="直角坐标系下"></a>直角坐标系下</h4><p>​        假如参数方程很容易被表达为$y=y(x)$，那我们就：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=x \\ y=y(x)\\\end{aligned} \right . \end{equation}</script><p>​        那带入：</p><script type="math/tex; mode=display">ds=\sqrt{1+y'^2(x)}dx</script><p>​        再积分：</p><script type="math/tex; mode=display">L=\int_a^b\sqrt{1+y'^2(x)}dx</script><h4 id="极坐标系下"><a href="#极坐标系下" class="headerlink" title="极坐标系下"></a>极坐标系下</h4><p>​        如果不知道的话：科普一下</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=\rho(\theta)\cos \theta \\ y=\rho(\theta)\sin \theta\\\end{aligned} \right . \end{equation}</script><p>​        所有呢，求个导：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x'=\rho'(\theta)\cos \theta- \rho(\theta)\sin \theta\\ y'=\rho(\theta)\cos \theta+\rho'(\theta)\sin \theta\\\end{aligned} \right . \end{equation}</script><p>​        老样子：</p><script type="math/tex; mode=display">ds=\sqrt{(x'^2+y'^2)} d\theta=\sqrt{\rho^2(\theta)+\rho'^2(\theta)d\theta}</script><p>​         嘛，不就完事了！</p><script type="math/tex; mode=display">L=\int_\alpha^\beta\sqrt{\rho^2(\theta)+\rho'^2(\theta)d\theta}</script><h3 id="向量与线性计算"><a href="#向量与线性计算" class="headerlink" title="向量与线性计算"></a>向量与线性计算</h3><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>​        一个<strong>有大小，又有方向的量</strong> 我们有概念：模长（长度），假使 向量被记作:$\vec\alpha$，则它的长度就是它的模长：$|\vec\alpha|$,</p><p>​        我们又让长度就是1的向量成为单位向量。长度是0的向量是零向量。</p><p>​        位置关系上：有共线，垂直和相等的关系。</p><p>​        平行指的是夹角是0或者是180度。垂直就是90度等。</p><h4 id="线性运算"><a href="#线性运算" class="headerlink" title="线性运算"></a>线性运算</h4><p><img src="image-20230202144129473.png" alt="image-20230202144129473"></p><p><img src="image-20230202144231912.png" alt="image-20230202144231912"></p><p><img src="image-20230202144315494.png" alt="image-20230202144315494"></p><p><img src="image-20230202144356921.png" alt="image-20230202144356921"></p><h4 id="方向余弦"><a href="#方向余弦" class="headerlink" title="方向余弦"></a>方向余弦</h4><p>​        我们有时只考虑方向，我们可以把它归一化：这需要：</p><script type="math/tex; mode=display">\vec{e}=(\frac{x}{r},\frac{y}{r},\frac{z}{r})</script><p>其中：$r=\sqrt{x^2+y^2+z^2}$</p><p>​        有时也这样记：</p><script type="math/tex; mode=display">\vec{e}=(\cos\alpha,\cos\beta,\cos\gamma)</script><p>​        由于这样，我们可以把任意向量拆解为方向向量和长度的数量积</p><script type="math/tex; mode=display">\vec{\alpha}=L\vec{e}</script><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>​        我们实际上可以使用如下的公式来计算一个向量在另一个向量的投影</p><script type="math/tex; mode=display">Prj_u\vec{a}=|\vec{a}|\cos\varphi</script><p>$\varphi$ 是两个向量的夹角</p><h5 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h5><script type="math/tex; mode=display">1)Prj_u(\vec{a}+\vec{b})=Prj_u\vec{a}+Prj_u\vec{b}</script><script type="math/tex; mode=display">2)Prj_u\lambda\vec{a}=\lambda Prj_u\vec{a}</script><h3 id="数量积"><a href="#数量积" class="headerlink" title="数量积"></a>数量积</h3><p><img src="image-20230202145138671.png" alt="image-20230202145138671"></p><p><img src="image-20230202145200044.png" alt="image-20230202145200044"></p><p><img src="image-20230202145233436.png" alt="image-20230202145233436"></p><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3><p>​        这是我们不熟悉的：</p><script type="math/tex; mode=display">\vec{c}=\vec{a}\times \vec{b}</script><p>​        首先模长是：</p><script type="math/tex; mode=display">|\vec{c}|=|\vec{a}||\vec{b}|\sin\theta</script><pre><code>     方向：右手从a到b。</code></pre><p>​        注意结果是一个向量！</p><p><img src="image-20230202145456287.png" alt="image-20230202145456287"></p><p><img src="image-20230202145504892.png" alt="image-20230202145504892"></p><h3 id="平面"><a href="#平面" class="headerlink" title="平面"></a>平面</h3><h4 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h4><p>​        曲面可以看成运动曲线的结果，我们常常使用方程：</p><script type="math/tex; mode=display">F(x,y,z)=0</script><p>来描述！</p><p>​        由此，曲线可以视作两个曲面的交：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}F(x,y,z) & = 0 \\G(x,y,z) & =  0\end{aligned}\right.\end{equation}</script><p>其法线垂直于平面。</p><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><h5 id="点法式"><a href="#点法式" class="headerlink" title="点法式"></a>点法式</h5><p>​        如果我们已知一个点和一个法线：我们可以求出方程：</p><p>​        已知：$n(A,B,C)，M(x_0,y_0,z_0)$</p><script type="math/tex; mode=display">L:A(x-x_0)+B(y-y_0)+C(z-z_0)=0</script><p>一般式</p><p>​        拆开上面的式子，将常数化作一个指标D</p><script type="math/tex; mode=display">L:Ax+By+Cz+D=0</script><p><img src="image-20230202150419737.png" alt="image-20230202150419737"></p><h3 id="平面的夹角"><a href="#平面的夹角" class="headerlink" title="平面的夹角"></a>平面的夹角</h3><p>我们回忆高中两直线的夹角：</p><script type="math/tex; mode=display">\cos \theta=|\cos(\vec{n_1},\vec{n_2})|</script><p>平面是一样的：</p><script type="math/tex; mode=display">\cos \theta=|\cos(\vec{n_1},\vec{n_2})|</script><p>只不过：</p><script type="math/tex; mode=display">\cos \theta=\frac{A_1A_2+B_1B_2+C_1C_2}{\sqrt{(A_1^2+B_1^2+C_1^2)(A_2^2+B_2^2+C_2^2)}}</script><p>推广了一个维度！</p><h3 id="空间直线与方程"><a href="#空间直线与方程" class="headerlink" title="空间直线与方程"></a>空间直线与方程</h3><p>回到这个概念：</p><p>曲线可以视作两个曲面的交：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}F(x,y,z) & = 0 \\G(x,y,z) & =  0\end{aligned}\right.\end{equation}</script><p>直线就是：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}A_1x+B_1y+C_1z+D_1 & = 0 \\A_2x+B_2y+C_2z+D_2 & =  0\end{aligned}\right.\end{equation}</script><h4 id="对称式"><a href="#对称式" class="headerlink" title="对称式"></a>对称式</h4><p>​        如果已知：$M(x_0,y_0,z_0),S(m,n,p)$则：</p><script type="math/tex; mode=display">\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}</script><h4 id="参数式"><a href="#参数式" class="headerlink" title="参数式"></a>参数式</h4><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = mt+x_0 \\y & =  nt+y_0\\y & =  pt+z_0\end{aligned}\right.\end{equation}</script><p>​        就是在对称式的基础上加上了等于T的条件！</p><h4 id="平面与直线的夹角"><a href="#平面与直线的夹角" class="headerlink" title="平面与直线的夹角"></a>平面与直线的夹角</h4><p>​        类似的，我们可以得到：</p><script type="math/tex; mode=display">\sin\varphi=|\cos(\vec{s},\vec{n})|=\frac{|Am+Bn+Cp|}{\sqrt{(A^2+B^2+C^2)(m^2+n^2+p^2)}}</script><p>​        于是：</p><script type="math/tex; mode=display">垂直: \frac{A}{m}=\frac{B}{n}=\frac{C}{p}</script><script type="math/tex; mode=display">平行:Am+Bn+Cp=0</script><h3 id="曲面-1"><a href="#曲面-1" class="headerlink" title="曲面"></a>曲面</h3><h4 id="旋转曲面"><a href="#旋转曲面" class="headerlink" title="旋转曲面"></a>旋转曲面</h4><p>​        由曲线旋转产生</p><p>​        假设我们原先的曲线的方程是：$f(y,z)=0$，他显然位于$yOz$平面上，其上有一点:$M_1(0,y_1,z_1)$</p><p>​        旋转之后：$M(x,y,z)$一定有：</p><script type="math/tex; mode=display">z=z_1且y_1=\pm\sqrt{x^2+y^2}</script><p>​        于是：</p><script type="math/tex; mode=display">f(\pm\sqrt{x^2+y^2},z)=0</script><p>​        相同的办法推理：对于$f(y,z)=0$绕Y轴旋转：</p><script type="math/tex; mode=display">f(y,\pm\sqrt{x^2+z^2})=0</script><p><img src="image-20230202152227760.png" alt="image-20230202152227760"></p><p>绕谁转，谁不变：剩下两个在旁边。</p><h4 id="曲面类型"><a href="#曲面类型" class="headerlink" title="曲面类型"></a>曲面类型</h4><h5 id="柱面："><a href="#柱面：" class="headerlink" title="柱面："></a>柱面：</h5><p>​        把一个平面作为准线，沿一条线（母线）移动：</p><script type="math/tex; mode=display">x^2+y^2=R^2</script><p>​        是一个代表</p><p><img src="image-20230202152508816.png" alt="image-20230202152508816"></p><p>​        如果是抛物线：就产生抛物面：</p><p><img src="image-20230202152605842.png" alt="image-20230202152605842"></p><p>​        缺什么以什么为准线移动！</p><h5 id="二次曲面"><a href="#二次曲面" class="headerlink" title="二次曲面"></a>二次曲面</h5><p>1）椭圆锥面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}=z^2</script><p>​        只要令$z=t$，我们马上发现这就是个椭圆</p><p><img src="image-20230202152818674.png" alt="image-20230202152818674"></p><p>​        这里引入伸缩的概念：我们对变量可以伸缩：拉长或缩短，直接是令$y’=\lambda y$带入方程来看</p><p>2）椭球面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1</script><p>3)单叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1</script><p>本质上是$\frac{x^2}{a^2}-\frac{z^2}{c^2}=1$先绕Y轴旋转，随后伸缩$\frac{b}{a}$倍数</p><p>4）双叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=-1</script><p>5）椭圆抛物面：</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}=z</script><p>​        可以看作一个$P^2=C$的类抛物线看待</p><p>6）双曲抛物面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}-\frac{y^2}{b^2}=z</script><h3 id="平面点集"><a href="#平面点集" class="headerlink" title="平面点集"></a>平面点集</h3><p>​        下面我们要引入多元函数，这就要求我们需要有点集的概念：我们定义一些点，如果满足一些特有的性质，就称之为他们是一个点集：</p><script type="math/tex; mode=display">E=\{(x,y)|(x,y)有特定关系\}</script><p>​        我们举个例子：一些点再一个半径为R的圆上：</p><script type="math/tex; mode=display">E=\{(x,y)|x^2+y^2=R^2\}</script><p>​        由于在平面上更有扩展性，我们就需要引入跟一元函数一样的概念：领域，这一次指的是P周围的地方：记作</p><script type="math/tex; mode=display">\mathring U(P_0,\sigma)=\{P||PP_0|<\sigma\}</script><p>​        点有几种：在一个圈住的特定范围下：有外点（不属于），边界点（处于边界），内点（就属于里面）</p><p>​        对于这些集合：有开集，闭集（就是说白了：取不取等的问题），有有界集无界集的概念，这里不多做阐述。</p><h3 id="N维空间"><a href="#N维空间" class="headerlink" title="N维空间"></a>N维空间</h3><p>​        N维空间表示</p><script type="math/tex; mode=display">R^n=\{(x_1,x_2,...,x_n)|x_i \in R,i=1,2,3,..,n\}</script><p>​        说白了，就像二维空间只用两个分量表达就可以阐述完全一样。</p><h3 id="多元函数的极限"><a href="#多元函数的极限" class="headerlink" title="多元函数的极限"></a>多元函数的极限</h3><p>​        比较一下：我们的一元函数的极限是单一主元趋向一个值：$x\rightarrow x_0$,一元函数也是这样的逼近！（从左边逼近，从右边逼近）。</p><p>​        那么多元函数又如何？（多元函数就像是：z=x+2y这样的玩意），注意到这一次我们的点可以在平面上移动而不是在线上移动！</p><script type="math/tex; mode=display">(x,y)\rightarrow(x_0,y_0)</script><p>​        这样的逼近方式是任意方式逼近的，这就让我们：可以直线逼近，可以曲线逼近！</p><p>​        <img src="image-20230206111243619.png" alt="image-20230206111243619"></p><p>​        如此：如果就算这样我们的极限值还是都不变：那么我们说函数的极限存在</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow(x_0,y_0)}f(x,y)=A</script><p>​        举个例子：$f(x,y)=(x^2+y^2)\sin\frac{1}{x^2+y^2}$求解：</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow(0,0)}(x^2+y^2)\sin\frac{1}{x^2+y^2}</script><p>​        很容易看出：$\sin\frac{1}{x^2+y^2}$有界的，这样，函数极限怎么样都是0！</p><p>​        如果极限不满足任何方式逼近相等，那就不存在！</p><p>​        比如说：求解$\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(x,y)$</p><script type="math/tex; mode=display">\begin{equation}f(x,y)=\left\{    \begin{aligned}    \frac{xy}{x^2+y^2} \quad x^2+y^2\neq 0\\    0 \quad x^2+y^2=0\\    \end{aligned}    \right    .\end{equation}</script><p>​        只需要：$y=kx$逼近:</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(x,y)=\frac{k}{k^2+1}</script><p>​        而若是：$y=-kx$逼近：</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(x,y)=-\frac{k}{k^2+1}</script><p>​         这下显然不存在了！</p><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>​        在一元导数中，我们这样定义导数：</p><script type="math/tex; mode=display">1)x\rightarrow x_0 ,\lim\limits_{x\rightarrow x_0}\frac{f(x)-f(x_0)}{x-x_0}</script><script type="math/tex; mode=display">2)\Delta x\rightarrow 0 ,\lim\limits_{\Delta x\rightarrow 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}</script><p>​        类似的，<strong>我们的多元函数不过就是多个主元一同影响函数值！</strong>这就是为什么我们的导数多了一个“偏”：如果说我们有一个函数$z=f(x,y)$，我们把目光聚焦在$x$上：我们就说$z$对$x$的偏导数就是这样定义的：</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=\lim\limits_{\Delta x\rightarrow0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}</script><p>​        当然还有这个简单的写法：</p><p>1）$z_x’$                         2）$f’_x(x,y)$</p><p>​        试试看，对$y$的偏导又是如何？</p><script type="math/tex; mode=display">\frac{\partial z}{\partial y}=\lim\limits_{\Delta y\rightarrow0}\frac{f(x_0,y_0+\Delta y)-f(x_0,y_0)}{\Delta y}</script><p>​        实际上，我们直接其他变量视作常数就好了</p><p>1）$z=x^2+3xy+y^2$在（1,2）处求偏导:</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=2x+3y,\frac{\partial z}{\partial y}=2y+3x</script><p>​        带入值就好了！</p><h4 id="几何含义"><a href="#几何含义" class="headerlink" title="几何含义"></a>几何含义</h4><p>​        说白了还是切线，不过是什么方向上的切线而已：过对应点切面产生的曲线的切线</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>​        对于一元函数来讲：可导一定连续！</p><p>​        对于二元函数来讲，可导不一定连续（因为此时退化为偏导，只是一个方向才是连续，其他的方式不一定！此时一个函数的连续指的是函数怎么逼近都是连续）</p><h4 id="高阶偏导"><a href="#高阶偏导" class="headerlink" title="高阶偏导"></a>高阶偏导</h4><p>​        因为主元具有多样性：在二阶偏导中，有了：</p><script type="math/tex; mode=display">\frac{\partial^2 z}{\partial x^2}=z'_{xx}=f''_{xx}</script><script type="math/tex; mode=display">\frac{\partial^2 z}{\partial x\partial y}=z'_{xy}=f''_{xy}</script><script type="math/tex; mode=display">\frac{\partial^2 z}{\partial y\partial x}=z'_{yx}=f''_{yx}</script><script type="math/tex; mode=display">\frac{\partial^2 z}{\partial y^2}=z'_{yy}=f''_{yy}</script><p>​        注意到：中间两个我们先后对函数的不同变量求导，故称之为混合偏导：<strong>当函数连续的时候：$z’’_{xy}=z’’_{yx}$</strong></p><h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><h4 id="可微的定义"><a href="#可微的定义" class="headerlink" title="可微的定义"></a>可微的定义</h4><p>​        还是跟微分很是相似：$\Delta z_x=f(x_0+\Delta x,y_0)-f(x_0,y_0)$是对X的偏增量，$\Delta z_y=f(x_0,y_0+\Delta y)-f(x_0,y_0)$是对Y的偏增量。现在，我们让两个都变：这就是全微分</p><script type="math/tex; mode=display">\Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)</script><p>​        定义：如果这个$\Delta z=A\Delta x+B\Delta y+o(\rho)$其中A，B还是跟增量无关的一个函数，随后就会有：</p><script type="math/tex; mode=display">dz=A\Delta x+B\Delta y</script><h4 id="可微的必要条件"><a href="#可微的必要条件" class="headerlink" title="可微的必要条件"></a>可微的必要条件</h4><p>​        <strong>定理：若z=f(x,y)在点( x,y )处可微，则偏导数$f’_x(x,y),f’_y(x,y)$存在且：</strong></p><script type="math/tex; mode=display">dz=f'_x(x,y)\Delta x+f'_y(x,y)\Delta y</script><p>​        还是跟上一个一样：偏导数只是说明了一个方向上可微，其他的不一定。</p><h4 id="可微的充分条件"><a href="#可微的充分条件" class="headerlink" title="可微的充分条件"></a>可微的充分条件</h4><p>​        如果：$f(x,y)$在(x,y)的某一个领域内有连续的偏导数$f’_x(x,y),f’_y(x,y)$那就说明（x,y）是可微的：</p><script type="math/tex; mode=display">dz=d_xz+d_yz</script><h3 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h3><p>​        现在事情准备复杂起来！我们利用链式求导法则</p><p>​        情况1：$z=f(u,v),u=\phi(t),v=\varphi(t)$求导！</p><p>​        注意，跟复合类似，结合我们之前的固有经验：</p><script type="math/tex; mode=display">\frac{dz}{dt}=\frac{\partial z}{\partial u}\cdot\frac{du}{dt}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dt}</script><p>​        </p><p><img src="image-20230209185128299.png" alt="image-20230209185128299"></p><p>​        情况2：$z=f(u,v),u=\phi(x,y),v=\varphi(x,y)$求导</p><script type="math/tex; mode=display">\frac{dz}{\partial x}=\frac{\partial z}{\partial u}\cdot\frac{du}{dx}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dx}\\\frac{\partial z}{\partial y}=\frac{\partial z}{\partial u}\cdot\frac{du}{dx}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dy}</script><p><img src="image-20230209185348990.png" alt="image-20230209185348990"></p><p>​        情况3：$z=f(u,v,w),u=\phi(x,y),v=\varphi(x,y),w=\omega(x,y)$</p><script type="math/tex; mode=display">\frac{dz}{\partial x}=\frac{\partial z}{\partial u}\cdot\frac{du}{dx}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dx}+\frac{\partial z}{\partial w}\cdot\frac{dw}{dx}\\\frac{\partial z}{\partial y}=\frac{\partial z}{\partial u}\cdot\frac{du}{dx}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dy}+\frac{\partial z}{\partial w}\cdot\frac{dw}{dy}</script><p><img src="image-20230209185641030.png" alt="image-20230209185641030"></p><p>​        情况4：$z=f(u,x,y),u=\varphi(x,y)$</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u}\cdot\frac{\partial u}{\partial x}+\frac{\partial f}{\partial x}\\\frac{\partial z}{\partial y}=\frac{\partial z}{\partial u}\cdot\frac{\partial u}{\partial y}+\frac{\partial f}{\partial y}</script><p><img src="image-20230209185926111.png" alt="image-20230209185926111"></p><p>​        例子：$z=e^u \sin v , u=xy , v=x+y$</p><p>$解: \frac{\partial z}{\partial x}=e^u\cdot \sin v\cdot y+e^u\cos v=e^{xy}\sin(x+y)y+e^{xy}\cos(x+y)\\<br>\frac{\partial z}{\partial x}=e^u\cdot \sin v\cdot x+e^u\cos v=e^{xy}\sin(x+y)x+e^{xy}\cos(x+y)$</p><h3 id="隐函数的求导公式"><a href="#隐函数的求导公式" class="headerlink" title="隐函数的求导公式"></a>隐函数的求导公式</h3><p>​        对于$F(x,y)=0$这个方程：</p><script type="math/tex; mode=display">当:F(x_0,y_0)=0,F_y'(x_0,y_0)\neq 0 \\\frac{dy}{dx}=-\frac{F_x'}{F_y'}</script><p>​        对于 $F(x,y,z)=0,F’_z(x_0,y_0,z_0)\neq 0$</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=-\frac{F_x'}{F'_z}\\\frac{\partial z}{\partial y}=-\frac{F_y'}{F'_z}</script><p>​        对于方程组的情况</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}F(x,y,u,v)& = & 0 \\G(x,y,u,v)& = & 0 \\\end{aligned}\right.\end{equation}</script><p>​            稍微复杂一点：</p><p>​        定义Jacobi行列式：</p><script type="math/tex; mode=display">J=\frac{\partial(F,G)}{\partial(u,v)}=\left | \begin{matrix}\frac{\partial F}{\partial u}  \frac{\partial F}{\partial v} \\ \frac{\partial G}{\partial u}\frac{\partial G}{\partial v}\end{matrix} \right |</script><script type="math/tex; mode=display">\frac{\partial u}{\partial x}=-\frac{1}{J}\frac{\partial(F,G)}{\partial(x,v)}=-\frac{\left | \begin{matrix}\frac{\partial F}{\partial x}  \frac{\partial F}{\partial v} \\ \frac{\partial G}{\partial x}\frac{\partial G}{\partial v}\end{matrix} \right |}{\left | \begin{matrix}\frac{\partial F}{\partial u}  \frac{\partial F}{\partial v} \\ \frac{\partial G}{\partial u}\frac{\partial G}{\partial v}\end{matrix} \right |}</script><p>​        其他类比</p><p>​        由线性代数里的克莱默法则推出。但是太难背了！我们可以直接对方程求导，然后解方程组就好了</p><p><img src="image-20230209195732899.png" alt="image-20230209195732899"></p><h2 id="一元向量值函数及其导数"><a href="#一元向量值函数及其导数" class="headerlink" title="一元向量值函数及其导数"></a>一元向量值函数及其导数</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = & \varphi(t) \\y & = & \phi(t) \\z & = & \omega (t)\end{aligned}\right.\end{equation}</script><p>​        可以看到，我们对于空间点的坐标可以使用</p><script type="math/tex; mode=display">\vec{r}=\vec{x}i+\vec{y}j+\vec{z}k</script><p>​        这样的方式表达！</p><p>​        于是对于一个点，可以使用一个类似于函数的表达方式：</p><script type="math/tex; mode=display">\vec{f(t)}=f_1(t)\vec{x}+f_2(t)\vec{y}+f_3(t)\vec{z}</script><h3 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h3><p>定义：</p><p>当</p><script type="math/tex; mode=display">t\rightarrow t_0,f(t)\rightarrow r_0,\lim\limits_{t\rightarrow t_0}\vec{f(t)}=r_0</script><p>下，我们可以记作：</p><script type="math/tex; mode=display">\lim\limits_{t\rightarrow t_0}\vec{f(t)}=(\lim\limits_{t\rightarrow t_0}{f_1(t)},\lim\limits_{t\rightarrow t_0}{f_2(t)},\lim\limits_{t\rightarrow t_0}{f_3(t)})</script><h3 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h3><p>现在定义：</p><script type="math/tex; mode=display">\lim\limits_{\Delta t\rightarrow 0}\frac{\Delta r}{\Delta t}=\lim\limits_{\Delta t\rightarrow 0}\frac{f(t_0+\Delta{t})-f(t_0)}{\Delta t}</script><p>于是展开，可以得到：</p><script type="math/tex; mode=display">f'(t_0)=(f'_1(t_0),f'_2(t_0),f'_3(t_0))</script><h3 id="相关求导法则"><a href="#相关求导法则" class="headerlink" title="相关求导法则"></a>相关求导法则</h3><p>​        跟数量函数一致，我们来看：</p><p><img src="image-20230210170814278.png" alt="image-20230210170814278"></p><h3 id="空间曲线的切线与法平面"><a href="#空间曲线的切线与法平面" class="headerlink" title="空间曲线的切线与法平面"></a>空间曲线的切线与法平面</h3><p><img src="image-20230210170906185.png" alt="image-20230210170906185"></p><p>​        回到上面我们讲到的：一个空间曲线的切向量就是：</p><script type="math/tex; mode=display">T=(\varphi'(t_0),\phi'(t_0),\omega'(t_0))</script><p>​        于是切线方程就是：</p><script type="math/tex; mode=display">\frac{x-x_0}{\varphi'(t_0)}=\frac{y-y_0}{\phi'(t_0)}=\frac{z-z_0}{\omega'(t_0)}</script><p>​        法平面：</p><script type="math/tex; mode=display">(x-x_0){\varphi'(t_0)}+(y-y_0){\phi'(t_0)}+(z-z_0){\omega'(t_0)}=0</script><p>​        对于方程式形式的，还是跟上一节的方程组求导一致</p><p><img src="image-20230210171628902.png" alt="image-20230210171628902"></p><h3 id="空间曲面的切平面和法线"><a href="#空间曲面的切平面和法线" class="headerlink" title="空间曲面的切平面和法线"></a>空间曲面的切平面和法线</h3><p>1.$F(x,y,z)=0$</p><p>​        切平面：</p><script type="math/tex; mode=display">F_x'(x-x_0)+F_y'(y-y_0)+F_z'(z-z_0)=0</script><p>​        法线：</p><script type="math/tex; mode=display">\frac{x-x_0}{F'_x}=\frac{y-y_0}{F'_y}=\frac{z-z_0}{F'_z}</script><p>2.$z=f(x,y)$</p><p>​        挪个位置：$F(x,y,z)=f(x,y)-z$</p><p>​        切平面：</p><script type="math/tex; mode=display">F_x'(x-x_0)+F_y'(y-y_0)-(z-z_0)=0</script><p>​        法线：</p><script type="math/tex; mode=display">\frac{x-x_0}{F'_x}=\frac{y-y_0}{F'_y}=\frac{z-z_0}{-1}</script><h3 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h3><p>求方向导数，可以理解为曲面上的点$P(x_0,y_0)$出发的一条射线</p><p><img src="image-20230210172637380.png" alt="image-20230210172637380"></p><p>我们出发产生的射线方程：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = & x_0+t\cos\alpha \\y & = & y_0+t\cos\beta \\\end{aligned}\right.\end{equation}</script><p>这个时候：</p><script type="math/tex; mode=display">\lim\limits_{t\rightarrow 0^+}\frac{f(x_0+t\cos\alpha,y_0+t\cos\beta)-f(x_0,y_0)}{t}=\frac{\partial f}{\partial l}|_{(x_0,y_0)}</script><p>​        可以看作：<strong>F（x,y）在方向L上的偏导数！</strong>，方向导数这一节就是对偏导的推广！</p><p>​        但是，我们的方向导数是射线，是从一个方向逼近的，于是有：</p><pre class="line-numbers language-none"><code class="language-none">方向导数存在，但是偏导未必因此存在！想要成为充要条件，则需要正负两个方向导数相等<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230210173343849.png" alt="image-20230210173343849"></p><p>​        定理：若函数$f(x,y)$在$(x_0,y_0)$可微，方向导数存在且$\frac{\partial f}{\partial l}|_{(x_0,y_0)}=f’_x\cos \alpha+f_y’\cos \beta $</p><h3 id="关系整理"><a href="#关系整理" class="headerlink" title="关系整理"></a>关系整理</h3><p><img src="image-20230210173813570.png" alt="image-20230210173813570"></p><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>​        定义：</p><script type="math/tex; mode=display">\nabla f(x_0,y_0)=gradf(x_0,y_0)=(f'_x(x_0,y_0),f_y'(x_0,y_0))</script><p>​        为梯度，<strong>他是个向量！</strong></p><p>​        回到这里：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial l}|_{(x_0,y_0)}=(f'_x(x_0,y_0),f_y'(x_0,y_0))\cdot(\cos \alpha,\cos \beta)=|gradf(x_0,y_0)|\cos \theta</script><p>​        1)当$\theta=0$,此时方向导数最大，于是</p><pre class="line-numbers language-none"><code class="language-none">梯度是在这一点方向导数取最大值的方向<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        2）当$\theta = \pi$,此时方向导数最小，为$|-gradf(x_0,y_0)|$</p><p>​        3)当$\theta = \frac{\pi}{2}$此时，方向导数为0，可以看作平行于等高线了！也可以理解为：在这个方向增长最快。</p><h3 id="极大值（极小值）"><a href="#极大值（极小值）" class="headerlink" title="极大值（极小值）"></a>极大值（极小值）</h3><p>定理一：极值必要条件：</p><p>$z=f(x,y)偏导，且(x_0,y_0)是极值点，则f’_x(x_0,y_0)=0,f’_y(x_0,y_0)=0$</p><p>驻点：$f’_x(x_0,y_0)=0,f’_y(x_0,y_0)=0$同时成立！</p><p>定理二：充分条件</p><p>$A=f’’_{xx}(x_0,y_0),B=f’’_{xy}(x_0,y_0),C=f’’_{yy}(x_0,y_0)$</p><p>则：</p><p>1）$AC&gt;B^2$:极值，且$A&gt;0是极小值，A&lt;0是极大值$</p><p>2）$AC&lt;B^2$:不是极值</p><p>3）$AC=B^2$:另作判断！</p><h3 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h3><p>​        什么叫条件极值，就是在一定约束之下函数的最大值，于是拉格朗日数乘就有：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}f_x'+\lambda\varphi_x'=0 \\f_y'+\lambda\varphi_y'=0  \\\varphi(x_0,y_0)=0\end{aligned}\right.\end{equation}</script><p>​        实际上，我们常常直接构造拉格朗日函数：</p><script type="math/tex; mode=display">L(x,y)=f(x,y)+\lambda \varphi(x,y)</script><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}L_x'=0 \\L_y'=0  \\\end{aligned}\right.\end{equation}</script><h1 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h1><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>​        他表示一个曲顶柱体的体积，现在把区间里的小区快切割一下</p><p><img src="image-20230213134721131.png" alt="image-20230213134721131"></p><p>​        现在朝上面做一个柱体，产生了一个微元体积</p><p><img src="image-20230213134825844.png" alt="image-20230213134825844"></p><p>​        现在对小区间求和：</p><script type="math/tex; mode=display">\lim\limits_{\lambda \rightarrow 0}\sum_{i=1}^n \Delta \sigma_i f(x_i,y_i)</script><p>​        这个$\lambda$每个小区域的大小。若这个的极限存在，那就有：</p><script type="math/tex; mode=display">\lim\limits_{\lambda \rightarrow 0}\sum_{i=1}^n \Delta \sigma_i f(x_i,y_i)=\iint_{D}f(x,y)d\sigma</script><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p>​    1）</p><script type="math/tex; mode=display">\iint_D[\alpha f(x,y)+\beta g(x,y)]d\sigma=\alpha\iint_Df(x,y)d\sigma+\beta\iint_D g(x,y)d\sigma</script><p>​        2)如果$D = D_1+D_2$,然后就有</p><script type="math/tex; mode=display">\iint_D f(x,y)d\sigma = \iint_{D_1} f(x,y)d\sigma+\iint_{D_2} f(x,y)d\sigma</script><p>​        3)对于$f(x,y) \equiv 1$</p><script type="math/tex; mode=display">\iint_D 1 d\sigma =\sigma</script><p>​        4)$f(x,y)\leq g(x,y)$</p><script type="math/tex; mode=display">\iint_D f(x,y) d\sigma\leq \iint_D g(x,y) d\sigma</script><p>​        5)</p><script type="math/tex; mode=display">|\iint_Df(x,y)d\sigma|\leq \iint_D|f(x,y)|d\sigma</script><p>​        6)假设$m\leq f(x,y)\leq M$,</p><script type="math/tex; mode=display">m\sigma \leq \iint_Df(x,y)d\sigma \leq M\sigma</script><p>​        推广：</p><script type="math/tex; mode=display">f(\xi,y)=\frac{1}{\sigma}\iint_Df(x,y)d\sigma</script><h4 id="计算-直角坐标"><a href="#计算-直角坐标" class="headerlink" title="计算(直角坐标)"></a>计算(直角坐标)</h4><p><img src="image-20230213140515497.png" alt="image-20230213140515497"></p><p>​        </p><p>​        假设截面是这个</p><p><img src="image-20230213140555154.png" alt="image-20230213140555154"></p><p>​        于是，可以看作先对 y 再对 x做积分：</p><script type="math/tex; mode=display">V = \int_a^b[\int_{\varphi_1(x)}^{\varphi_2(x)}f(x,y)dy]dx</script><p>于是：</p><p>例题1：</p><p>​        $\iint_D xyd\sigma,y=1,x=2,y=x$</p><p>​        原式=$\int_1^2\int_{1}^{x}xydydx=\int_1^2x[\frac{y^2}{2}|_1^x]dx=\int_1^2{x(\frac{x^2}{2}-\frac{1}{2})}=\frac{x^4}{8}-\frac{x^2}{4}|_1^2=\frac{9}{8}$</p><p>​        我们也有先对X再对Y做积分：</p><script type="math/tex; mode=display">=\int_1^2dy\int_y^2 f(x,y)dx</script><p>​        注意，对于Y，左边是下限，右边是上限</p><p>例题2：</p><p>$\iint_D y\sqrt{1+x^2-y^2}d\sigma,D:y=x,x=-1,y=1$</p><p>法一：$\int_{-1}^1dx\int_{x}^{1}y\sqrt{1+x^2-y^2}dy=0.5$</p><p>法二：$\int_{-1}^1dy\int_{-1}^{y}y\sqrt{1+x^2-y^2}dx$</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        对于积分区域是长方形的：</p><script type="math/tex; mode=display">\int_a^bdx\int_c^d f(x,y)dy = \int_c^ddy\int_a^b f(x,y)dx</script><p><img src="image-20230213141904801.png" alt="image-20230213141904801"></p><p>​        对于积分区域是长方形的，且<code>f(x,y)</code>=$f_1(x)f_2(x)$</p><script type="math/tex; mode=display">\int_a^bdx\int_c^df_1(x)f_2(y)dy=\int_a^bf_1(x)dx\cdot\int_C^df_2(x)dy</script><h4 id="计算（极坐标）"><a href="#计算（极坐标）" class="headerlink" title="计算（极坐标）"></a>计算（极坐标）</h4><p>​        主要应用在曲线（圆类）比较多</p><p><img src="image-20230213142436470.png" alt="image-20230213142436470"></p><p>​        </p><p><img src="image-20230213142548063.png" alt="image-20230213142548063"></p><p>​        于是：</p><script type="math/tex; mode=display">\iint_D f(x,y)d\sigma = \iint_D \rho f(\rho\cos\theta,\rho\sin\theta) d\rho d\theta</script><p>​        小心不要丢掉$\rho$!</p><p>如：</p><p>例题:$\iint_D e^{-x^2-y^2}dxdy$</p><p>​        做代换，得到：</p><script type="math/tex; mode=display">\int_0^{2\pi}d\theta\int_0^ae^{-\rho^2}\rho d\rho = \pi(1-e^{-a^2})</script><h4 id="一个重要的推论："><a href="#一个重要的推论：" class="headerlink" title="一个重要的推论："></a>一个重要的推论：</h4><p><img src="image-20230213143049432.png" alt="image-20230213143049432"></p><p>​        同时，作为长方形底面积式子：得到：</p><p><img src="image-20230213143210280.png" alt="image-20230213143210280"></p><script type="math/tex; mode=display">\frac{\pi}{4}(1-e^{-R^2})\leq(\int_0^Re^{-x^2}dx)^2\leq\frac{\pi}{4}(1-e^{-2R^2})</script><p>​        于是有一个著名的结论：</p><script type="math/tex; mode=display">\int_0^R e^{-x^2}dx=\frac{\sqrt \pi}{2}</script><p>例子：$\iint_D \arctan\frac{y}{x}dxdy$</p><p><img src="image-20230213143631579.png" alt="image-20230213143631579"></p><p>D见上图：</p><p>解答：=$\int_0^{\frac{\pi}{4}}d\theta \int_1^3 \arctan(\tan\theta)\rho d\rho=\int_0^{\frac{\pi}{4}}\theta\int_1^3\rho d\rho=\frac{\pi^2}{8}$</p><h4 id="二重积分的换元法"><a href="#二重积分的换元法" class="headerlink" title="二重积分的换元法"></a>二重积分的换元法</h4><p>​        首先可以有：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = & \rho\cos(t) \\y & = & \rho\sin(t) \\\end{aligned}\right.\end{equation}</script><p>​        作为一个经典的变换！对于更一般的：</p><p>1)$x=x(u,v),y=y(u,v)$</p><p>2)$J_{(u,v)}=\frac{\partial (x,y)}{\partial (u,v)}$下：</p><script type="math/tex; mode=display">\iint_D f(x,y)dxdy=\iint_{D'}f(x(u,v),y(u,v))|J_{(u,v)}|</script><p>例题：$\iint_D e^{\frac{y-x}{y+x}}dxdy$</p><p><img src="image-20230213144715490.png" alt="image-20230213144715490"></p><p>令：$u=y-x,v=y+x$于是：</p><script type="math/tex; mode=display">x=\frac{v-u}{2},y=\frac{u+v}{2}</script><p><code>-&gt;</code></p><script type="math/tex; mode=display">x=0 \rightarrow v=u\\y=0 \rightarrow v=-u\\x+y=2\rightarrow v=2\\J=-0.5</script><script type="math/tex; mode=display">\iint_D e^{\frac{u}{v}}dudv=\frac{1}{2}\int_0^2dv\int_{-v}^{v}e^{\frac{u}{v}}du=e-e^{-1}</script><h2 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h2><p>​        定义：</p><script type="math/tex; mode=display">\lim\limits_{\lambda\rightarrow 0}\sum_{i=0}^{n}f(x_i,y_i,z_i)\Delta v_i =\iiint_\Omega f(x,y,z)dxdydz</script><p>​        可以理解为：将密度考虑成一个关于空间的函数即可，然后在原有空间上增加一个维度！</p><p>​        使用切丝法逐步切：</p><script type="math/tex; mode=display">\iiint_\Omega f(x,y,z)dxdydz= \int_{x_1}^{x_2}dx\int_{y(x_1)}^{y(x_2)}dy\int_{z(x_1,y_1)}^{z(x_2,y_2)}f(x,y,z)dz</script><p>例如：</p><p><img src="image-20230213150010068.png" alt="image-20230213150010068"></p><script type="math/tex; mode=display">=\iint_{D_ {xy} }[\int_0^{1-x-2y}xdz]dxdy=\int_0^1dx\int_0^{\frac{1-x}{2}}dy\int_0^{1-x-2y}xdz</script><p>例如：$\iiint_D z^2dxdydz$,$D:\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1$</p><script type="math/tex; mode=display">=\int_{-c}^{c}z^2dz\iint_{D_{xy} }dxdy</script><p>而长轴短轴的变化是：</p><script type="math/tex; mode=display">a' = a\sqrt{1-\frac{z^2}{c^2} },b' = b\sqrt{1-\frac{z^2}{c^2} }</script><p>故：因为椭圆的面试是$\pi a’b’$</p><script type="math/tex; mode=display">=\pi ab\int_{-c}^{c}z^2(1-\frac{z^2}{c^2})dz=\frac{4}{15}\pi abc^3</script><h3 id="柱面坐标"><a href="#柱面坐标" class="headerlink" title="柱面坐标"></a>柱面坐标</h3><p>​        使用：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = & \rho\cos(t) \\y & = & \rho\sin(t) \\z & = & z\end{aligned}\right.\end{equation}</script><p>​        表达坐标的系统叫柱坐标系统！</p><p>​        </p><script type="math/tex; mode=display">dv=\rho d\rho d\theta dz</script><p>对于一个长方体：$a \leq x \leq b,c \leq x \leq d,e \leq x \leq f$且函数可以完全分离：</p><script type="math/tex; mode=display">\int_a^bf_1(x)dx\int_c^df_2(y)dy\int_e^ff_3(z)dz= \\(\int_a^bf_1(x)dx)\cdot(\int_c^df_2(y)dy)\cdot(\int_e^ff_3(z)dz)</script>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv_learning_Python(1)</title>
      <link href="/2023/06/06/Opencv-learning-Python-1/"/>
      <url>/2023/06/06/Opencv-learning-Python-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Opencv-in-Python-1"><a href="#Opencv-in-Python-1" class="headerlink" title="Opencv in Python(1)"></a>Opencv in Python(1)</h1><p>​        PS: Opencv in Pycharm 的合并重置版本</p><h3 id="在Pycharm中导入opencv"><a href="#在Pycharm中导入opencv" class="headerlink" title="在Pycharm中导入opencv"></a>在Pycharm中导入opencv</h3><p>​        笔者被<code>C++</code>实现的<code>opencv</code>干到心态炸裂了，所以这里先整一篇基于<code>python</code>的<code>opencv</code>的博客。</p><p>​        在<code>pycharm</code>中导入<code>opencv</code>很容易：只需要在<code>Project</code>的<code>setting</code>里给解释器安装上<code>opencv-python</code>库就好了。使用这个程序跑一下看看可不可以读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#向工程文件下新建一个img文件夹,放好你的图片，我这里放的是test.png</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230129194508512.png" alt="image-20230129194508512"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2img_path<span class="token operator">=</span><span class="token string">"img/test.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Test img can be shown below!"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        跳出这个即为成功！开始你的opencv的欢乐时间！</p><p><img src="image-20230129194919800.png" alt="image-20230129194919800"></p><h3 id="计算机眼中的图片"><a href="#计算机眼中的图片" class="headerlink" title="计算机眼中的图片"></a>计算机眼中的图片</h3><p>​        在计算机眼中，图像由矩阵构成</p><p><img src="image-20230115212443109.png" alt="image-20230115212443109"></p><p>​        </p><p>​        数值的大小表明了图像的亮度，而通道表明了一个颜色：一个R通道上的255表明这是在Red上很亮</p><p>​        下面，我们来介绍一下我们应该怎么读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment">#不同于RGB，我们读取的格式是BGR</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#caution:the input should be the addr of the img</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        读取的结果是：一个nd array</p><p>​        好抽象：可不可以直接展示图片啊：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我们试一下这个：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> showimg <span class="token keyword">as</span> simg<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'1.png'</span><span class="token punctuation">)</span>simg<span class="token punctuation">.</span>imgshow<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        也可以封装一个函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cv_show</span><span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span>     cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们也可以查看一个图片的大小：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>shape<span class="token comment">#(175, 286, 3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        我们可以设置读入的方式：比如说读入灰度图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span>，cv2<span class="token punctuation">.</span>IMREAD_GREYSCALE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        保存我们产出的图像</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">'savedfilename'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>     可以计算像素点的个数：</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>​            视频由图像组成，也就是说，我们可以读取视频：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">vc<span class="token operator">=</span>cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">'videofilepath'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​            我们是不是读取成功了？这个看如下的代码判断：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> vc<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">open</span><span class="token punctuation">.</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token builtin">open</span><span class="token operator">=</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>    我们来运行的读取视频</code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> <span class="token builtin">open</span><span class="token punctuation">:</span>ret<span class="token punctuation">,</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> frame <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">if</span> ret<span class="token operator">==</span><span class="token boolean">True</span><span class="token punctuation">:</span>        gray<span class="token operator">=</span>cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>frame<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">,</span>gray<span class="token punctuation">)</span>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token operator">==</span><span class="token number">27</span><span class="token punctuation">:</span><span class="token comment">#按下ESC退出或者视频播放完毕</span>            <span class="token keyword">break</span>vc<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="截取部分图片（ROI）"><a href="#截取部分图片（ROI）" class="headerlink" title="截取部分图片（ROI）"></a>截取部分图片（ROI）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imgread<span class="token punctuation">(</span><span class="token string">'Path'</span><span class="token punctuation">)</span>cat<span class="token operator">=</span>img<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">]</span>cv_show<span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span>cat<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样我们就利用切片截取了部分图片了.</p><h3 id="颜色通道提取"><a href="#颜色通道提取" class="headerlink" title="颜色通道提取"></a>颜色通道提取</h3><p>我们可以分离图片，通过不同的颜色通道提取：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token operator">=</span>cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是效果：1，2，3分别代表b,g,r</p><p><img src="2.png" alt="2"> </p><p>1:</p><p><img src="b.png" alt="b"></p><p>2:</p><p><img src="g.png" alt="g"></p><p>3:<img src="r.png" alt="r"></p><p>当然也可以合回去：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以单独保留，直接修改：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#只保留R</span>cur_img<span class="token operator">=</span>img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span>cur_img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><p>我们可以扩充图像，通过一些方式来对图像进行扩充：请看这里：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token comment">#定位点</span>replicate<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REPLICATE<span class="token punctuation">)</span>reflect<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT<span class="token punctuation">)</span>reflect101<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT_101<span class="token punctuation">)</span>wrap<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_WRAP<span class="token punctuation">)</span>constant<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span>value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>    我们得到了五张图像，随后，我们使用imwrite输出图像，同时导入matplotlib的pyplot子库进行观察：    这是总的效果：</code></pre><p><img src="matplot_version.png" alt="matplot_version"></p><p>​     仔细观察：</p><p><img src="replicate.png" alt="replicate"></p><p><img src="reflect.png" alt="reflect"></p><p><img src="reflect101.png" alt="reflect101"></p><p><img src="wrap.png" alt="wrap"></p><p><img src="constant.png" alt="constant"></p><p>​    第一张图是展示了</p><div class="table-container"><table><thead><tr><th>方法</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>replicate</td><td>这个单词是复制的意思：直接复制最边缘的像素</td><td>///</td></tr><tr><td>reflect：</td><td>对感兴趣的部分进行两边复制：</td><td>`fedcba</td><td>abcdef</td><td>fedcba`</td></tr><tr><td>reflect101:</td><td>但是是对最边缘的像素为对称轴进行复制:</td><td>`gfedcba</td><td>abcdefgh</td><td>gfedcba`</td></tr><tr><td>wrap:</td><td>外包装：</td><td>`cdefgh</td><td>abcdefgh</td><td>abcdefg`</td></tr><tr><td>constant:</td><td>对图像以默认黑值填充</td><td>///</td></tr></tbody></table></div><h3 id="对图像进行数值操作"><a href="#对图像进行数值操作" class="headerlink" title="对图像进行数值操作"></a>对图像进行数值操作</h3><p>​            我们可以对numpy进广播操作。人话翻译成C++就是cv2库重载了运算符号，使之我们可以对矩阵进行广义的加法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'cat.jpg'</span><span class="token punctuation">)</span>img_cat_GeneralAdd<span class="token operator">=</span>img_cat<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>img_cat<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>img_cat2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​            在控制台上输出就可以发现矩阵里每一个数值都加上了一个10。</p><p><img src="image-20230129191422226.png" alt="image-20230129191422226"></p><p>​    （懒得自己跑，截个图）</p><p>​        那可不可以狭义相加呢？当然可以，结合线性代数的常识，相加的矩阵必须满足大小完全一致。假设我们已经满足了这个前提，直接相加得到的结果是不是就是放到矩阵的值呢？</p><p>​        显然不是！因为RGB有界，不可以超过255.在重载的+中，矩阵的RGB值自动%256，就是除以2256取它的余数放到矩阵里。那还有别的加法吗？有：使用方法add，传入<code>cv2.add(img_cat,img_cat2)</code>就可以了，达到255之后就不会取模，只会停在255不动</p><h3 id="图像叠加"><a href="#图像叠加" class="headerlink" title="图像叠加"></a>图像叠加</h3><p>​        我们也可以对图像进行叠加。但是注意，我们首先要调整图像大小一致：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token punctuation">.</span>shapeimg_dog<span class="token operator">=</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token comment"># path是路径</span>img_dog<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_dog<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token operator">*</span>size required to resize<span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230129192417117.png" alt="image-20230129192417117"></p><p>​        同样的还有其他resize方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">required_pic<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_required_resize<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>fx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>fy<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是个什么玩意呢？指的是我们依照某个点把图像在X轴上拉长3倍数，Y轴不变。</p><p>​        现在，我们使用addWeighted来叠加图像，以混合图片特征。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res<span class="token operator">=</span>cv2<span class="token punctuation">.</span>addWeighted<span class="token punctuation">(</span>img_cat<span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">,</span>img_dog<span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#img_cat*0.4+img_dog*0.6+0//最后一项是亮度提升</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h3><p>​        我们可以使用一些参数，对图像进行有条件的处理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ret<span class="token punctuation">,</span>dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>src<span class="token punctuation">,</span>thresh<span class="token punctuation">,</span>maxval<span class="token punctuation">,</span><span class="token builtin">type</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><div class="table-container"><table><thead><tr><th>参数</th><th>备注</th></tr></thead><tbody><tr><td>src</td><td>输入，只能输入单通道图像，通常是灰度图</td></tr><tr><td>dst</td><td>输出图</td></tr><tr><td>thresh</td><td>执行阈值</td></tr><tr><td>maxval</td><td>超过或小于阈值后所赋予的值</td></tr><tr><td>type</td><td>方法</td></tr></tbody></table></div><p>​        type方法如下所示</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>cv2.THRESH_BINARY</td><td>超过阈值的取maxval,否则取0</td></tr><tr><td>cv2.THRESH_BINARY_INV</td><td>反过来</td></tr><tr><td>THRESH_TRUNC</td><td>大于阈值的设置成阈值</td></tr><tr><td>THRESH_TOZERO</td><td>大于阈值的不变，否则设置成0</td></tr><tr><td>THRESH_TOZERO_INV</td><td>反转</td></tr></tbody></table></div><p>​        我们依旧使用matplotlib的pyplot库放送一下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'2.png'</span><span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY_INV<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh3<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TRUNC<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh4<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh5<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO_INV<span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original Image'</span><span class="token punctuation">,</span><span class="token string">'BINARY'</span><span class="token punctuation">,</span><span class="token string">'BINARY_INV'</span><span class="token punctuation">,</span><span class="token string">'THRESH_TRUNC'</span><span class="token punctuation">,</span><span class="token string">'TOZERO'</span><span class="token punctuation">,</span><span class="token string">'TOZERO_INV'</span><span class="token punctuation">]</span>images<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>thresh1<span class="token punctuation">,</span>thresh2<span class="token punctuation">,</span>thresh3<span class="token punctuation">,</span>thresh4<span class="token punctuation">,</span>thresh5<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        看看：</p><p><img src="Figure_1.png" alt="Figure_1"></p><h3 id="腐蚀操作"><a href="#腐蚀操作" class="headerlink" title="腐蚀操作"></a>腐蚀操作</h3><p>​        对于这样的一些图片：</p><p><img src="1.png" alt="1"></p><p>​        我们可以使用腐蚀操作来钝化特征：删除掉一些边界的像素点（置黑色）。其中：腐蚀的大小，范围是由kernel决定的。在Python中，我们需要这样指定一个核：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kernel<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        还是需要指定一个迭代次数的参数，这行代码完成了这样的工作：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">erosion<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>                  kernel<span class="token punctuation">,</span>                  iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#迭代次数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们首先看看效果怎么样：</p><p><img src="erosion.png" alt="erosion"></p><p>​        可以看到，腐蚀核在检测到边界条件的时候（白转黑and黑转白）自动将这些像素点填充成黑色，除非核内的像素点都是统一的，否则都会腐蚀！</p><p>​        可以来点控制变量！比如说指定不同的腐蚀核来观察效果</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> nppath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion33<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion55<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>erosion33<span class="token punctuation">,</span>erosion55<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"comp"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Kernel Diff compararison.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Kernel Diff compararison.png" alt="Kernel Diff compararison"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion33<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion55<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>imgs_ero1<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>erosion33<span class="token punctuation">,</span>erosion55<span class="token punctuation">]</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original'</span><span class="token punctuation">,</span><span class="token string">'3 times 3 '</span><span class="token punctuation">,</span><span class="token string">'5 times t '</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>imgs_ero1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_1-16756699063337.png" alt="Figure_1"></p><p>​        可以看到，核越大，就越会腐蚀图像！</p><p>​        下面看看图像迭代影响：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> nppath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>erosion1<span class="token punctuation">,</span>erosion2<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"comp"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Iterator Diff comparasion.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Iterator Diff comparasion.png" alt="Iterator Diff comparasion"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>imgs_ero1<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>erosion1<span class="token punctuation">,</span>erosion2<span class="token punctuation">]</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original'</span><span class="token punctuation">,</span><span class="token string">'1 '</span><span class="token punctuation">,</span><span class="token string">'2 '</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>imgs_ero1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_2.png" alt="Figure_2"></p><p>可以看见：越是迭代，图像腐蚀的越严重！</p><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>​        这个操作可以视作腐蚀操作的反操作：就是将特征明显化：</p><p><img src="dilate.png" alt="dilate"></p><p>​        老规矩：还是看看改变核大小和迭代次数产生的效果如何：</p><p>​        先看核大小：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> nppath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>dilate1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>dilate2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>dilate1<span class="token punctuation">,</span>dilate2<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"comp"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"kernel_in_dilate Diff comparasion.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="kernel_in_dilate Diff comparasion.png" alt="kernel_in_dilate Diff comparasion"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>dilate1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>dilate2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'org'</span><span class="token punctuation">,</span><span class="token string">'3 times 3'</span><span class="token punctuation">,</span><span class="token string">'5 times 5'</span><span class="token punctuation">]</span>img_group<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>dilate1<span class="token punctuation">,</span>dilate2<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img_group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_3.png" alt="Figure_3"></p><p>​        再来看看迭代器的影响：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>dilate1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>dilate2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'org'</span><span class="token punctuation">,</span><span class="token string">'3 times 3'</span><span class="token punctuation">,</span><span class="token string">'5 times 5'</span><span class="token punctuation">]</span>img_group<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>dilate1<span class="token punctuation">,</span>dilate2<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img_group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_4.png" alt="Figure_4"></p><p>​        还是很容易看出来：核越大，迭代次数越多，图片的特征就被放大的越明显！</p><h4 id="扩展阅读1"><a href="#扩展阅读1" class="headerlink" title="扩展阅读1"></a>扩展阅读1</h4><p>​        版权声明：本文为CSDN博主「我有一個夢想」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>​        原文链接：<a href="https://blog.csdn.net/B08370108/article/details/118028678">https://blog.csdn.net/B08370108/article/details/118028678</a></p><p>​        <strong>图像的腐蚀过程与图像的卷积操作类似，都需要模板矩阵来控制运算的结果</strong>，在图像的腐蚀和膨胀中这个模板矩阵被称为结构元素。与图像卷积相同，结构元素可以任意指定图像的中心点，并且结构元素的尺寸和具体内容都可以根据需求自己定义。定义结构元素之后，将结构元素的中心点依次放到图像中每一个非0元素处，如果此时结构元素内所有的元素所覆盖的图像像素值均不为0，则保留结构元素中心点对应的图像像素，否则将删除结构元素中心点对应的像素。图像的腐蚀过程示意图如图6-12所示，图6-12中左侧为待腐蚀的原图像，中间为结构元素，<strong>首先将结构元素的中心与原图像中的A像素重合，此时结构元素中心点的左侧和上方元素所覆盖的图像像素值均为0，因此需要将原图像中的A像素删除</strong>；<strong>当把结构元素的中心点与B像素重合时，此时结构元素中所有的元素所覆盖的图像像素值均为1</strong>，因此保留原图像中的B像素。将结构元素中心点依次与原图像中的每个像素重合，判断每一个像素点是否保留或者删除，最终原图像腐蚀的结果如图中下侧图像所示。</p><p>​        <img src="2021011613033220.png" alt="img"></p><p>​        图像腐蚀可以用“Θ”表示，其数学表示形式如式(6.4)所示，通过公式可以发现，其实对图像A的腐蚀运算就是寻找图像中能够将结构元素B全部包含的像素点。</p><p>​        生成常用的矩形结构元素、十字结构元素和椭圆结构：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat getStructuringElement(int shape, Size ksize, Point anchor &#x3D; Point(-1,-1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;shape：结构元素的种类，可以选择的参数及含义在表6-5中给出。&#x2F;&#x2F;ksize：结构元素的尺寸大小&#x2F;&#x2F;anchor：中心点的位置，默认参数为结构元素的几何中心点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>     该函数用于生成图像形态学操作中常用的矩形结构元素、十字结构元素和椭圆结构元素。函数第一个参数为生成结构元素的种类，可以选择的参数及含义在表给出，函数第二个参数是结构元素的尺寸大小，能够影响到图像腐蚀的效果，一般情况下，结构元素的种类相同时，结构元素的尺寸越大腐蚀效果越明显。函数的最后一个参数是结构元素的中心点，只有十字结构元素的中心点位置会影响图像腐蚀后的轮廓形状，其他种类的结构元素的中心点位置只影响形态学操作结果的平移量。</code></pre><p><img src="20210116131530359.png" alt="表6-5 getStructuringElement( 20210116131530359.png)函数结构元素形状可选择参数"></p><p>腐蚀函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void erode( InputArray src,            OutputArray dst,            InputArray kernel,           Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,           int borderType &#x3D; BORDER_CONSTANT,           const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue()           );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;src：输入的待腐蚀图像，图像的通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。&#x2F;&#x2F;dst：腐蚀后的输出图像，与输入图像src具有相同的尺寸和数据类型。&#x2F;&#x2F;kernel：用于腐蚀操作的结构元素，可以自己定义，也可以用getStructuringElement()函数生成。&#x2F;&#x2F;anchor：中心点在结构元素中的位置，默认参数为结构元素的几何中心点&#x2F;&#x2F;iterations：腐蚀的次数，默认值为1。&#x2F;&#x2F;borderType：像素外推法选择标志，取值范围在表3-5中给出。默认参数为BORDER_DEFAULT，表示不包含边界值倒序填充。&#x2F;&#x2F;borderValue：使用边界不变外推法时的边界值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        该函数根据结构元素对输入图像进行腐蚀，在腐蚀多通道图像时每个通道独立进行腐蚀运算。<br>​        函数的第一个参数为待腐蚀的图像，图像通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。<br>​        函数第二个参数为腐蚀后的输出图像，与输入图像具有相同的尺寸和数据类型。<br>​        函数第三个和第四个参数都是与结构元素相关的参数，第三个参数为结构元素，第四个参数为结构元素的中心位置，第四个参数的默认值为Point(-1,-1)，表示结构元素的几何中心处为结构元素的中心点。<br>​        函数第五个参数是使用结构元素腐蚀的次数，腐蚀次数越多效果越明显，参数默认值为1，表示只腐蚀1次。<br>​        函数第六个参数是图像像素外推法的选择标志，<br>​        第七个参数为使用边界不变外推法时的边界值，这两个参数对图像中主要部分的腐蚀操作没有影响，因此在多数情况下使用默认值即可。</p><p>​        需要注意的是该函数的腐蚀过程只针对图像中的非0像素，因此如果图像是以0像素为背景，那么腐蚀操作后会看到图像中的内容变得更瘦更小；如果图像是以255像素为背景，那么腐蚀操作后会看到图像中的内容变得更粗更大。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">   简单示例&#x2F;&#x2F;&#x2F;&#x2F; Created by smallflyfly on 2021&#x2F;6&#x2F;18.&#x2F;&#x2F;#include &quot;opencv2&#x2F;opencv.hpp&quot;#include &lt;iostream&gt;using namespace std;using namespace cv;void drawResult(Mat im, int num, Mat stats, Mat centroids, const string&amp; name) &#123;    for (int i &#x3D; 1; i &lt; num; ++i)     &#123;        int x &#x3D; centroids.at&lt;double&gt;(i, 0);        int y &#x3D; centroids.at&lt;double&gt;(i, 1);        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;        circle(im, Point(x, y), 2, Scalar(0, 0, 255), -1);        int xmin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_LEFT);        int ymin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_TOP);        int w &#x3D; stats.at&lt;int&gt;(i, CC_STAT_WIDTH);        int h &#x3D; stats.at&lt;int&gt;(i, CC_STAT_HEIGHT);Rect rect(xmin, ymin, w, h);    rectangle(im, rect, Scalar(255, 255, 255), 2);    putText(            im,                 to_string(i),                 Point(x+5, y),                 FONT_HERSHEY_SCRIPT_SIMPLEX,                 0.3,                 Scalar(0, 0, 255),                 1);&#125;imshow(name, im);&#125;int main() &#123;Mat src &#x3D; (            Mat_&lt;uchar&gt;(6, 6) &lt;&lt;                    0, 0, 0, 0, 255, 0,                    0, 255, 255, 255, 255, 255,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 0, 0, 0, 255, 0        );resize(src, src, Size(0, 0), 50, 50, INTER_NEAREST);Mat m1, m2;m1 &#x3D; getStructuringElement(0, Size(3, 3));m2 &#x3D; getStructuringElement(1, Size(3, 3)); Mat erodeM1, erodeM2;erode(src, erodeM1, m1, Point(-1, -1), 10);erode(src, erodeM2, m2, Point(-1, -1), 10); imshow(&quot;src&quot;, src);imshow(&quot;erodeM1&quot;, erodeM1);imshow(&quot;erodeM2&quot;, erodeM2); Mat xbim &#x3D; imread(&quot;xiaobai.jpg&quot;);Mat xbM1, xbM2;erode(xbim, xbM1, m1, Point(-1, -1), 2);erode(xbim, xbM2, m2, Point(-1, -1), 2); imshow(&quot;xb&quot;, xbim);imshow(&quot;xbM1&quot;, xbM1);imshow(&quot;xbM2&quot;, xbM2); Mat im &#x3D; imread(&quot;rice.jfif&quot;);Mat im1 &#x3D; im.clone();Mat im2 &#x3D; im.clone();Mat im3 &#x3D; im.clone(); Mat gray;cvtColor(im, gray, CV_BGR2GRAY);Mat riceBin;threshold(gray, riceBin, 125, 255, THRESH_BINARY); Mat out, stats, centroids;int count1 &#x3D; connectedComponentsWithStats(riceBin, out, stats, centroids, 8, CV_16U);drawResult(im1, count1, stats, centroids, &quot;no erode&quot;); Mat erodeIm1, erodeIm2;erode(riceBin, erodeIm1, m1, Point(-1, -1), 5);erode(riceBin, erodeIm2, m2, Point(-1, -1), 5); int count2 &#x3D; connectedComponentsWithStats(erodeIm1, out, stats, centroids, 8, CV_16U);drawResult(erodeIm1, count2, stats, centroids, &quot;erode1&quot;);int count3 &#x3D; connectedComponentsWithStats(erodeIm2, out, stats, centroids, 8, CV_16U);drawResult(erodeIm2, count3, stats, centroids, &quot;erode2&quot;); waitKey(0);destroyAllWindows();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0IwODM3MDEwOA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="扩展阅读2"><a href="#扩展阅读2" class="headerlink" title="扩展阅读2"></a>扩展阅读2</h4><p>​        版权声明：本文为CSDN博主「我有一個夢想」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>​        原文链接：<a href="https://blog.csdn.net/B08370108/article/details/118029682">https://blog.csdn.net/B08370108/article/details/118029682</a></p><p>​        图像的膨胀与图像腐蚀是一对相反的过程，与图像腐蚀相似，图像膨胀同样需要结构元素用于控制图像膨胀的效果。结构元素可以任意指定结构的中心点，并且结构元素的尺寸和具体内容都可以根据需求自己定义。<strong>定义结构元素之后，将结构元素的中心点依次放到图像中每一个非0元素处，如果原图像中某个元素被结构元素覆盖，但是该像素的像素值不与结构元素中心点对应的像素点的像素值相同，那么将原图像中的该像素的像素值修改为结构元素中心点对应点的像素值。</strong>图像的膨胀过程示意图如图所示，图中左侧为待膨胀的原图像，中间为结构元素，首先将结构元素的中心与原图像中的A像素重合，将结构元素覆盖的所有像素的像素值都修改为1，将结构元素中心点依次与原图像中的每个像素重合，判断是否有需要填充的像素。原图像膨胀的结果如图中右侧图像所示。</p><p><img src="20210117230235852.png" alt="在这里插入图片描述"></p><pre><code>     图像膨胀数学表示形式如式(6.5)所示，通过公式可以发现，其实图像A的膨胀运算就是生成能够将结构元素B全部包含的图像。</code></pre><p><img src="20210117230534606.png" alt="在这里插入图片描述"></p><p>膨胀函数</p><pre class="line-numbers language-none"><code class="language-none">void dilate( InputArray src, OutputArray dst, InputArray kernel,Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,int borderType &#x3D; BORDER_CONSTANT,const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue() );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;src：输入的待膨胀图像，图像的通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。&#x2F;&#x2F;dst：膨胀后的输出图像，与输入图像src具有相同的尺寸和数据类型。&#x2F;&#x2F;kernel：用于膨胀操作的结构元素，可以自己定义，也可以用getStructuringElement()函数生成。&#x2F;&#x2F;anchor：中心点在结构元素中的位置，默认参数为结构元素的几何中心点&#x2F;&#x2F;iterations：膨胀的次数，默认值为1。&#x2F;&#x2F;borderType：像素外推法选择标志，取值范围在表3-5中给出。默认参数为BORDER_DEFAULT，表示不包含边界值倒序填充。&#x2F;&#x2F;borderValue：使用边界不变外推法时的边界值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     该函数根据结构元素对输入图像进行膨胀，在膨胀多通道图像时每个通道独立进行膨胀运算。函数的第一个参数为待膨胀的图像，图像通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。</code></pre><p>​        函数第二个参数为膨胀后的输出图像，与输入图像具有相同的尺寸和数据类型。函数第三个和第四个参数都是与结构元素相关的参数，</p><p>​        第三个参数为结构元素，膨胀时使用的结构元素尺寸越大效果越明显，第四个参数为结构元素的中心位置，</p><p>​        第四个参数的默认值为Point(-1,-1)，表示结构元素的几何中心处为结构元素的中心点。</p><p>​        函数第五个参数是使用结构元素膨胀的次数，膨胀次数越多效果越明显，默认参数为1，表示只膨胀1次。</p><p>​        函数第六个参数是图像像素外推法的选择标志，</p><p>​        第七个参数为使用边界不变外推法时的边界值，这两个参数对图像中主要部分的膨胀操作没有影响，因此在多数情况下使用默认值即可。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">    简单示例&#x2F;&#x2F;&#x2F;&#x2F; Created by smallflyfly on 2021&#x2F;6&#x2F;18.&#x2F;&#x2F;#include &quot;opencv2&#x2F;opencv.hpp&quot;#include &lt;iostream&gt;using namespace cv;using namespace std;void drawResult(Mat im, int num, Mat stats, Mat centroids, const string&amp; name) &#123;    for (int i &#x3D; 1; i &lt; num; ++i) &#123;        int x &#x3D; centroids.at&lt;double&gt;(i, 0);        int y &#x3D; centroids.at&lt;double&gt;(i, 1);        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;        circle(im, Point(x, y), 2, Scalar(0, 0, 255), -1);        int xmin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_LEFT);        int ymin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_TOP);        int w &#x3D; stats.at&lt;int&gt;(i, CC_STAT_WIDTH);        int h &#x3D; stats.at&lt;int&gt;(i, CC_STAT_HEIGHT);    Rect rect(xmin, ymin, w, h);   rectangle(im, rect, Scalar(255, 255, 255), 2);    putText(    im,     to_string(i),     Point(x+5, y),     FONT_HERSHEY_SCRIPT_SIMPLEX,     0.3,        Scalar(0, 0, 255),         1);&#125;imshow(name, im);&#125;int main() &#123;    Mat src &#x3D; (            Mat_&lt;uchar&gt;(6, 6) &lt;&lt;                              0, 0, 0, 0, 255, 0,                    0, 255, 255, 255, 255, 255,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 0, 0, 0, 255, 0    );    resize(src, src, Size(0, 0), 50, 50, INTER_NEAREST);    Mat m1, m2;    m1 &#x3D; getStructuringElement(0, Size(3, 3));    m2 &#x3D; getStructuringElement(1, Size(3, 3));Mat dilateM1, dilateM2;dilate(src, dilateM1, m1, Point(-1, -1), 5);dilate(src, dilateM2, m2, Point(-1, -1), 5); imshow(&quot;src&quot;, src);imshow(&quot;dilateM1&quot;, dilateM1);imshow(&quot;dilateM2&quot;, dilateM2); Mat xbim &#x3D; imread(&quot;xiaobai.jpg&quot;);Mat xbM1, xbM2;dilate(xbim, xbM1, m1, Point(-1, -1), 2);dilate(xbim, xbM2, m2, Point(-1, -1), 2); imshow(&quot;xbim&quot;, xbim);imshow(&quot;xbM1&quot;, xbM1);imshow(&quot;xbM2&quot;, xbM2); Mat im &#x3D; imread(&quot;rice.jfif&quot;);resize(im, im, Size(0, 0), 0.6, 0.6);Mat im1 &#x3D; im.clone(); Mat gray;cvtColor(im, gray, CV_BGR2GRAY);Mat riceBin;threshold(gray, riceBin, 125, 255, THRESH_BINARY); Mat out, stats, centroids;int count1 &#x3D; connectedComponentsWithStats(riceBin, out, stats, centroids, 8, CV_16U);drawResult(im, count1, stats, centroids, &quot;no dilate&quot;); Mat dilateIm1, dilateIm2;dilate(riceBin, dilateIm1, m1, Point(-1, -1), 5);dilate(riceBin, dilateIm2, m2, Point(-1, -1), 5); int count2 &#x3D; connectedComponentsWithStats(dilateIm1, out, stats, centroids, 8, CV_16U);drawResult(dilateIm1, count2, stats, centroids, &quot;dilateIm1&quot;);int count3 &#x3D; connectedComponentsWithStats(dilateIm2, out, stats, centroids, 8, CV_16U);drawResult(dilateIm2, count3, stats, centroids, &quot;dilateIm2&quot;); waitKey(0);destroyAllWindows();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="xiaobaixueshijue.png" alt="img"></p><h3 id="开运算与闭运算"><a href="#开运算与闭运算" class="headerlink" title="开运算与闭运算"></a>开运算与闭运算</h3><p>​        刚刚我们整完了腐蚀和膨胀,现在我们一起用：</p><p>​        开运算指的是：<strong>先腐蚀后膨胀</strong></p><p>​        闭运算指的是：<strong>先膨胀后腐蚀</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath <span class="token operator">=</span> <span class="token string">"1.png"</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33 <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>opening <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_OPEN<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"opening"</span><span class="token punctuation">,</span>opening<span class="token punctuation">)</span>closing <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"closing"</span><span class="token punctuation">,</span>closing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"open.png"</span><span class="token punctuation">,</span>opening<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"close.png"</span><span class="token punctuation">,</span>closing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        开运算：</p><p><img src="open.png" alt="open"></p><p>​        闭运算：</p><p><img src="close.png" alt="close"></p><h3 id="梯度运算"><a href="#梯度运算" class="headerlink" title="梯度运算"></a>梯度运算</h3><p>​        放大边界信息！很简单：膨胀的减去腐蚀的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">import cv2import numpy as npfrom matplotlib import pyplot as pltpath &#x3D; &quot;1.png&quot;img &#x3D; cv2.imread(path)kernel33 &#x3D; np.ones((3,3),np.uint8)gradient&#x3D;cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel33)cv2.imshow(&quot;gra&quot;,gradient)cv2.imwrite(&quot;gradient.png&quot;,gradient)cv2.waitKey(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="gradient.png" alt="gradient"></p><h3 id="礼貌与黑帽"><a href="#礼貌与黑帽" class="headerlink" title="礼貌与黑帽"></a>礼貌与黑帽</h3><p>​        <strong>礼貌就是原始输入-开运算结果！</strong></p><p>​        <strong>黑猫就是闭运算-原始输入！</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath <span class="token operator">=</span> <span class="token string">"1.png"</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33 <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>tophat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>blackhat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_BLACKHAT<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"to"</span><span class="token punctuation">,</span>tophat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"bl"</span><span class="token punctuation">,</span>blackhat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"tophat.png"</span><span class="token punctuation">,</span>tophat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"blackhat.png"</span><span class="token punctuation">,</span>blackhat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tophat：</p><p><img src="tophat.png" alt="tophat"></p><p>blackhat:</p><p><img src="blackhat.png" alt="blackhat"></p><h3 id="扩展阅读1-1"><a href="#扩展阅读1-1" class="headerlink" title="扩展阅读1"></a>扩展阅读1</h3><p>阅读链接：<a href="https://zhuanlan.zhihu.com/p/541851526">数字图像处理(c++ opencv)：形态学图像处理-开运算与闭运算 - 知乎 (zhihu.com)</a></p><h4 id="开运算与闭运算-1"><a href="#开运算与闭运算-1" class="headerlink" title="开运算与闭运算"></a>开运算与闭运算</h4><p>（1）开运算</p><p>原理方法：先腐蚀后膨胀；</p><p>功能作用：平滑物体轮廓、断开狭窄的狭颈、消除细长的突出和物体。</p><p>（2）闭运算</p><p>原理方法：先膨胀后腐蚀；</p><p>功能作用：弥合狭窄的狭颈或断裂处、消除小孔、填补轮廓缝隙。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;int main()&#123;Mat image, image_gray, image_bw;   &#x2F;&#x2F;定义输入图像，灰度图像，二值图像image &#x3D; imread(&quot;开运算闭运算.png&quot;);  &#x2F;&#x2F;读取图像；if (image.empty())&#123;cout &lt;&lt; &quot;读取错误&quot; &lt;&lt; endl;return -1;&#125;imshow(&quot;image&quot;, image);&#x2F;&#x2F;转换为灰度图像cvtColor(image, image_gray, COLOR_BGR2GRAY);&#x2F;&#x2F;转换为二值图threshold(image_gray, image_bw, 120, 255, 1); &#x2F;&#x2F;通过0，1调节二值图像背景颜色imshow(&quot;image_bw&quot;, image_bw);&#x2F;&#x2F;闭运算Mat se &#x3D; getStructuringElement(0, Size(3, 3)); &#x2F;&#x2F;构造矩形结构元素dilate(image_bw, image_bw, se, Point(-1, -1), 5); &#x2F;&#x2F;执行膨胀操作erode(image_bw, image_bw, se, Point(-1, -1), 5); &#x2F;&#x2F;执行腐蚀操作&#x2F;&#x2F;开运算&#x2F;&#x2F;Mat se &#x3D; getStructuringElement(0, Size(3, 3)); &#x2F;&#x2F;构造矩形结构元素&#x2F;&#x2F;erode(image_bw, image_bw, se, Point(-1, -1), 2); &#x2F;&#x2F;执行腐蚀操作&#x2F;&#x2F;dilate(image_bw, image_bw, se, Point(-1, -1), 2); &#x2F;&#x2F;执行膨胀操作imshow(&quot;image_bw&quot;, image_bw);waitKey(0);  &#x2F;&#x2F;暂停，保持图像显示，等待按键结束return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="v2-996d420c6bd384ca11957a8745f672b4_1440w.png" alt="img"></p><hr><p><strong>除了使用腐蚀膨胀的函数组合来进行开运算闭运算，还可以通过opencv函数进行处理（morphologyex函数）</strong></p><h3 id="扩展阅读2-1"><a href="#扩展阅读2-1" class="headerlink" title="扩展阅读2"></a>扩展阅读2</h3><p>版权声明：本文为CSDN博主「念980」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_62343847/article/details/122604497">https://blog.csdn.net/weixin_62343847/article/details/122604497</a></p><p>腐蚀与膨胀</p><p>​        图像的腐蚀与膨胀互为逆向操作，通常用于处理二值图像（黑白图，以黑色为底面背景），因此需要先进行二值化处理，腐蚀和膨胀通俗的理解就是，在指定大小的卷积核内，如果该卷积核内全为黑色或全为白色，则该卷积核内像素值不变，但若是既有黑色又有白色，即在图像边缘处，那么膨胀操作则会将该卷积核内所有白色像素点都赋值变为黑色，以此将图像向内腐蚀掉一圈，而膨胀操作则相反，会将卷积核内的黑色像素点赋值成2白色，以此让图像膨胀一圈。</p><p>​        膨胀与腐蚀的函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>uint8<span class="token punctuation">)</span> <span class="token comment">#定义要处理的卷积核大小和卷积核的类型。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">erosion <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#对图像进行膨胀操作，img_test是要进行处理的图像，kernel是通过上一个函数定义好的卷积核，而iterations则是腐蚀操作的循环次数（可以将卷积核设置为（1，1），然后不断调整循环次数来实现精细化的腐蚀，以达到更好的腐蚀效果）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">dilate_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img_test<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#对图像进行膨胀操作，这里的参数跟上面的参数作用一样，只是改了函数名而已。（同样可以将卷积核设置为（1，1），不断改变循环次数，以达到更好的膨胀效果）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        应用：腐蚀操作一般用于消去图像中不需要的粘连部分，而膨胀操作则用于填充图像内的空白部分，同时也可以恢复图像由于进行腐蚀操作后缩小的面积，在下面的代码实例中会有体现。</p><p>代码实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment">#导入包</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span><span class="token comment">#读入图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定处理的内核</span>erosion <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#腐蚀操作</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"erosion"</span><span class="token punctuation">,</span>erosion<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>pie <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"pie.png"</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"pie"</span><span class="token punctuation">,</span>pie<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>erosion_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#循环腐蚀1次</span>erosion_2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#循环腐蚀2次</span>erosion_3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#循环腐蚀3次</span>All <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>erosion_1<span class="token punctuation">,</span>erosion_2<span class="token punctuation">,</span>erosion_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#拼接图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"All"</span><span class="token punctuation">,</span>All<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>img_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>erosion_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#腐蚀图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"erosion_test3"</span><span class="token punctuation">,</span>erosion_test3<span class="token punctuation">)</span><span class="token comment">#展示腐蚀后的图像</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>dilate_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>erosion_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#对腐蚀过的图像进行膨胀处理</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"dilate"</span><span class="token punctuation">,</span>dilate_test3<span class="token punctuation">)</span><span class="token comment">#展示膨胀后的图像</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>dilate_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#循环膨胀一次后的图像</span>dilate_2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#循环膨胀两次后的图像</span>dilate_3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#循环膨胀三次后的图像</span>All <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>dilate_1<span class="token punctuation">,</span>dilate_2<span class="token punctuation">,</span>dilate_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#拼接以上三幅图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"All"</span><span class="token punctuation">,</span>All<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        运行结果</p><p>​        这是原图，可以看到上面有一些多出来的粘连部分</p><p><img src="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-1OTgw,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>​        进行腐蚀操作后的图像，可以看到，我们用腐蚀操作成功去除了边缘的粘连部分，但同时字体笔画也由于受到了腐蚀而变细了</p><p><img src="qdwd.png" alt="img"></p><p>​        对上图进行膨胀操作，可以看到，我们恢复了被腐蚀前笔画的粗细，同时也去除掉了原图的粘连部分，这种操作称为开运算，能够在尽量不改变原图的情况下去除图像的粘连。（在下面会有详细的介绍）</p><p><img src="ss.png" alt="img"></p><pre><code>     以下是循环腐蚀1~3次之后的图像对比</code></pre><p><img src="wq.png" alt="img"></p><pre><code>     以下是循环膨胀1~3次之后的图像对比</code></pre><p><img src="das.png" alt="img"></p><p>​        通过上面两幅图可以看出，不管是腐蚀还是膨胀，都不是等比例的进行，它们最终都会趋近于矩形（因为卷积核就是矩形的），并且进行腐蚀再膨胀后的图像跟原图是存在细微差别的，比如中间的部分空洞可能已经消失了等等。</p><p>​        开运算和闭运算 </p><p>​        所谓开运算在上面的代码其实已经使用过了，只是opencv本身便带有可以进行腐蚀后再膨胀的函数，不需要我们自己写那么多代码。开运算在原图的基础上就是用于消除图像的一些粘连部分的一种方式。</p><p>​        而闭运算则相反，是先进行膨胀，再进行腐蚀的一种操作。它主要用于填充图像中的空洞部分，在opencv中同样有一个专门的函数进行闭运算。</p><p>​        函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">opening <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_OPEN<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#开运算，img_test3是要进行处理的图片，cv2.MORPH_OPEN表示要进行的是开运算（先腐蚀后膨胀），kernel则跟上面的函数一样，是定义好的卷积核。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"> closing <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#闭运算，这里的函数参数跟上一个函数作用一样，cv2.MORPH_OPEN表示要进行的是闭运算（先膨胀后腐蚀）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span><span class="token comment">#读入图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>opening <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_OPEN<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#开运算，先腐蚀后膨胀，能够去除图像中粘连的部分</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">,</span>opening<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的卷积核大小</span>closing <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#闭运算，先膨胀后腐蚀，能够填补图像中间的空隙</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"close"</span><span class="token punctuation">,</span>closing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><p>​        开运算:</p><p><img src="dqwdqew.png" alt="img"></p><p>​        闭运算：效果不明显，但是如果该图像中间有空洞存在，那么我们可以明显的看到空洞被填上了。</p><p> <img src="ceacergaefr.png" alt="img"></p><pre><code>     梯度运算</code></pre><p>​        原理：将图像分别进行膨胀和腐蚀，然后两者相减，则可以得到该图像的轮廓，而opencv中同样提供了进行梯度运算的函数。</p><p>​        函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">gradient <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_GRADIENT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#这里的pie是将要进行处理的二值图像，cv2.MORPH_GRADIENT表示进行梯度运算，kernel则是定义好的卷积核。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        代码示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltpie <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"pie.png"</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"pie"</span><span class="token punctuation">,</span>pie<span class="token punctuation">)</span><span class="token comment">#展示原图</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span class="token comment">#梯度运算，通过膨胀减去腐蚀得到轮廓</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定卷积核大小</span>gradient <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_GRADIENT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#梯度运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"gradient"</span><span class="token punctuation">,</span>gradient<span class="token punctuation">)</span><span class="token comment">#展示处理后的图像</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        运行结果</p><p>​        原图</p><p><img src="ewaVQERWEFWRVA.png" alt="img"></p><p>​        处理后得到的图像轮廓</p><p><img src="ce.PNG" alt="img"></p><pre><code>     礼帽与黑帽</code></pre><p>​        礼帽：将图像先进行开运算，再以原始图像减去开运算的结果，我们就可以得到图像被腐蚀掉的粘连部分，或者说原图中灰度较亮的区域，所以也称白顶帽变换。</p><p>​        黑帽：将图像先进行闭运算，再将闭运算的结果减去原始图像，作用我们就可以得到原图像中被填充的空洞部分，也就是图像中件较暗的空洞区域，所以又称黑底帽变换。</p><p>​        函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">tophat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#礼帽运算，cv2.MORPH_TOPHAT表示进行的是礼帽运算，即原图像-开运算。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">blackhat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_BLACKHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#黑帽运算，cv2.MORPH_BLACKHAT表示进行的是黑帽运算，即闭运算-原图像。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        代码示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span><span class="token comment">#读入图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span class="token comment">#礼帽，原始图像-开运算，得到的就是被腐蚀掉的粘连部分</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定卷积核大小</span>tophat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#礼帽运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"tophat"</span><span class="token punctuation">,</span>tophat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#黑帽运算，闭运算-原始图像，得到的是膨胀之前原始图像中比较暗的部分，即中间的空洞</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定卷积核大小</span>blackhat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_BLACKHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#黑帽运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"blackhat"</span><span class="token punctuation">,</span>blackhat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        运行结果</p><p>​        原图</p><p><img src="QWDQWD.png" alt="img"></p><p>​        礼帽，可以看到图像粘连部分被剔除出来了</p><p><img src="wdqqwdqw.png" alt="img"></p><p>​        黑帽，我们得到了迪哥中间微小的空洞部分</p><p><img src="sqwdw.png" alt="img"></p><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv_learning_CPP</title>
      <link href="/2023/06/06/Opencv-learning-CPP/"/>
      <url>/2023/06/06/Opencv-learning-CPP/</url>
      
        <content type="html"><![CDATA[<h1 id="Opencv-with-Visual-Studio-重置"><a href="#Opencv-with-Visual-Studio-重置" class="headerlink" title="Opencv with Visual Studio (重置)"></a>Opencv with Visual Studio (重置)</h1><h2 id="C-Version"><a href="#C-Version" class="headerlink" title="C++ Version"></a>C++ Version</h2><h2 id="1-环境配置问题"><a href="#1-环境配置问题" class="headerlink" title="1.环境配置问题"></a>1.环境配置问题</h2><p>​        我们首先下好 Opencv 4.5.1 的包，安装好 Cmake 之后开始使用！</p><p>​        下面为了配置好 Opencv 的开发环境：我们必须书写一个 CmakeLists来链接库：</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">cmake_minimum_required(VERSION 2.8)project(def) # 工程名称 set(SOURCES    default.cpp # 源文件) set(HEADERS    #main.hpp # 头文件) add_executable(Main #产生可执行区域    $&#123;SOURCES&#125;    $&#123;HEADERS&#125;) set(OpenCV_DIR &quot;D:&#x2F;Opencv4.5.1&#x2F;opencv&#x2F;build&#x2F;x64&#x2F;vc15&#x2F;lib&quot;) # 找到二进制的坤文件find_package(OpenCV REQUIRED)if(OpenCV_FOUND)    target_include_directories(Main PUBLIC $&#123;OpenCV_INCLUDE_DIRS&#125;)    target_link_libraries(Main $&#123;OpenCV_LIBS&#125;)    # 上面两行代码把 Opencv 库所需要的文件和程序链接 endif()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        随后，点击Cmake 把工作区和二进制生成文件的地址传进去</p><p><img src="image-20230305134917646.png" alt="image-20230305134917646"></p><p>​        平台选择 64 位，点击 Configure 随后点击 Generate :留意有没有报错！</p><p>​        如果一切没有问题，那么，回到你的工作文件夹，选择BUILD文件夹，打开，随后找到：def.sIn文件，单击启动项目，当然我们需要更改启动项</p><p><img src="image-20230305135524174.png" alt="image-20230305135524174"></p><p>​        选择Main启动项即可！</p><p>​        当然可以使用以下代码测试你的环境！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;Mat img &#x3D; imread(path);if (img.empty()) &#123;return -1;&#125;imshow(&quot;1&quot;, img);waitKey(0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="项目入门1："><a href="#项目入门1：" class="headerlink" title="项目入门1："></a>项目入门1：</h2><p>​        我们首先来了解什么是图像：这很简单！我们在计算机中用一个矩阵，向里面填入色块实现图像的显示，我们的图像越高清，就说明我们的矩阵划分的越密集，这样，表现出来的就越是清晰！</p><p>​        在黑白图中，我们使用 8 位图来刻画我们的黑白图！0代表黑色，255 则是白色。</p><p><img src="image-20230305140523343.png" alt="image-20230305140523343"></p><p>​        对于彩色图像，我们使用 BGR 三色图，以不同的比例的亮度来叠加在一起。</p><h3 id="显示一个图像"><a href="#显示一个图像" class="headerlink" title="显示一个图像"></a>显示一个图像</h3><p>​        下面我们来使用一个函数 imread 和 imshow!</p><p>​        先来引入头文件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         现在看一下，有没有报错，一般而言成功了的环境是不会报错的！正是如此！</p><p>​        如果你有幸浏览到了 opencv  的文档，你会注意到 imread 表示的是从程序外面读取一个图像，并且将对象返回给一个叫做 Mat 的类型！函数需要一个string，表示的是图像的地址</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++"># 这里找到一个图像的地址：string path &#x3D; &quot;path_DIR&quot;;# 然后传进去：Mat img &#x3D; imread(path);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个 Mat 就是一个矩阵，存储着图像的信息。显示图像也是简单的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">imshow(&quot;NameWindows&quot;,img);waitKey(0);&#x2F;&#x2F; 防止图像一闪而过<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Examples:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;Mat img &#x3D; imread(path);if (img.empty()) &#123;return -1;&#125;imshow(&quot;1&quot;, img);waitKey(0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230305141742942.png" alt="image-20230305141742942"></p><p>​        效果如上！</p><h3 id="显示一个视频"><a href="#显示一个视频" class="headerlink" title="显示一个视频"></a>显示一个视频</h3><p>​        视频的本质是一帧一帧图像的播放，基于此，我们可以导入，以及导出一个视频：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string path &#x3D; &quot;C:\\Users\\陈冠豪\\Videos\\2023-03-05 14-24-15.mp4&quot;;VideoCapture videocap(path);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        我们的 Opencv 里有一个专门搞视频的类型：</p><pre class="line-numbers language-none"><code class="language-none">VideoCapture <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        类型，支持这样的构造：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">VideoCapture videocap(path)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        随后声明一个矩阵，他将会存储我们的视频中一帧的图片：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat img;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们视频的读取是这样的：读取每一帧，然后显示，直到视频结束或者我们人为的退出：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(1)&#123;videocap.read(img);    imshow(&quot;Video&quot;,img);    waitKey(1); &#x2F;&#x2F; 我们在这里决定了延迟是如何的，这里实现倍速或者是慢速播放&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Videos\\2023-03-05 14-31-23.mp4&quot;;VideoCapture videocap(path);Mat img;while (1)&#123;videocap.read(img);imshow(&quot;1&quot;, img);waitKey(20);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你当然可以选择你的摄像头！电脑的默认头是0，这意味着：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;VideoCapture videocap(0);Mat img;while (1)&#123;videocap.read(img);imshow(&quot;1&quot;, img);waitKey(20);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        就可以看到你自己了！</p><p><img src="image-20230305144156399.png" alt="image-20230305144156399"></p><p>​        很好。</p><h2 id="项目入门2：图像处理"><a href="#项目入门2：图像处理" class="headerlink" title="项目入门2：图像处理"></a>项目入门2：图像处理</h2><p>​        下面，我们来一 一介绍函数的图像处理：</p><p>​        1）转化为灰度图：</p><p>来看这个函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cvtColor(imgSrc,imgDst,code);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个函数把源图像转化为目标图像，以及转化方式：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;Mat imgSrc, imgDst;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;imgSrc &#x3D; imread(path);cvtColor(imgSrc, imgDst, COLOR_BGR2GRAY);imshow(&quot;gray&quot;, imgDst);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230305145310719.png" alt="image-20230305145310719"></p><h2 id="图像模糊（高斯模糊）"><a href="#图像模糊（高斯模糊）" class="headerlink" title="图像模糊（高斯模糊）"></a>图像模糊（高斯模糊）</h2><p>​        使用函数 GaussainBlur 来实现！</p><p>​        小技巧，如果你不知道这个函数是干什么的，传什么样的参数：可以Ctrl+单击</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void GaussianBlur( InputArray src, OutputArray dst, Size ksize,                                double sigmaX, double sigmaY &#x3D; 0,                                int borderType &#x3D; BORDER_DEFAULT );&#x2F;** @brief Applies the bilateral filter to an image.The function applies bilateral filtering to the input image, as described inhttp:&#x2F;&#x2F;www.dai.ed.ac.uk&#x2F;CVonline&#x2F;LOCAL_COPIES&#x2F;MANDUCHI1&#x2F;Bilateral_Filtering.htmlbilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it isvery slow compared to most filters._Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\&lt;10), the filter will not have much effect, whereas if they are large (\&gt; 150), they will have a verystrong effect, making the image look &quot;cartoonish&quot;._Filter size_: Large filters (d \&gt; 5) are very slow, so it is recommended to use d&#x3D;5 for real-timeapplications, and perhaps d&#x3D;9 for offline applications that need heavy noise filtering.This filter does not work inplace.@param src Source 8-bit or floating-point, 1-channel or 3-channel image.@param dst Destination image of the same size and type as src .@param d Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,it is computed from sigmaSpace.@param sigmaColor Filter sigma in the color space. A larger value of the parameter means thatfarther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resultingin larger areas of semi-equal color.@param sigmaSpace Filter sigma in the coordinate space. A larger value of the parameter means thatfarther pixels will influence each other as long as their colors are close enough (see sigmaColor). When d\&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d isproportional to sigmaSpace.@param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到，这个函数需要源图像，目标图像和高斯核的大小，以及两个方差（其中有一个是必须的）</p><p><img src="image-20230305150011615.png" alt="image-20230305150011615"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;Mat imgSrc,imgBlur;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;imgSrc &#x3D; imread(path);GaussianBlur(imgSrc, imgBlur, Size(7, 7), 5, 0);imshow(&quot;1&quot;, imgBlur);imshow(&quot;org&quot;, imgSrc);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图像边缘检测"><a href="#图像边缘检测" class="headerlink" title="图像边缘检测"></a>图像边缘检测</h3><p>​        下面我们要使用函数Canny 来给我们的图像进行检测！</p><p>​        <strong>我们在使用 Canny 检测的时候，往往还会在之前使用模糊来更好的检测！！！</strong></p><p>​        通读一下函数需求：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void Canny( InputArray image, OutputArray edges,                         double threshold1, double threshold2,                         int apertureSize &#x3D; 3, bool L2gradient &#x3D; false );&#x2F;** \overloadFinds edges in an image using the Canny algorithm with custom image gradient.@param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).@param dy 16-bit y derivative of input image (same type as dx).@param edges output edge map; single channels 8-bit image, which has the same size as image .@param threshold1 first threshold for the hysteresis procedure.@param threshold2 second threshold for the hysteresis procedure.@param L2gradient a flag, indicating whether a more accurate \f$L_2\f$ norm\f$&#x3D;\sqrt&#123;(dI&#x2F;dx)^2 + (dI&#x2F;dy)^2&#125;\f$ should be used to calculate the image gradient magnitude (L2gradient&#x3D;true ), or whether the default \f$L_1\f$ norm \f$&#x3D;|dI&#x2F;dx|+|dI&#x2F;dy|\f$ is enough (L2gradient&#x3D;false ). *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到，我们需要源图像，目标图像，两个阈值</p><p><img src="image-20230305150945109.png" alt="image-20230305150945109"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;Mat imgSrc,imgBlur,imgCanny;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;imgSrc &#x3D; imread(path);GaussianBlur(imgSrc, imgBlur, Size(7, 7), 5, 0);Canny(imgBlur,imgCanny,50,150);imshow(&quot;org&quot;, imgSrc);imshow(&quot;canny&quot;, imgCanny);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们用这个来检测阈值，当然，阈值越低，对边界越敏感：</p><p><img src="image-20230305151111912.png" alt="image-20230305151111912"></p><p>​        下调阈值为 25,75后的结果！</p><h3 id="图像膨胀"><a href="#图像膨胀" class="headerlink" title="图像膨胀"></a>图像膨胀</h3><p>​        当我们的图像特征不明显的时候，我们可以放大特征来便于我们的检测：</p><p>​        使用的是函数 dilate:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">CV_EXPORTS_W void dilate( InputArray src,                          OutputArray dst,                          InputArray kernel,                          Point anchor &#x3D; Point(-1,-1),                          int iterations &#x3D; 1,                          int borderType &#x3D; BORDER_CONSTANT,                          const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue()                         );&#x2F;** @brief Performs advanced morphological transformations.The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation asbasic operations.Any of the operations can be done in-place. In case of multi-channel images, each channel isprocessed independently.@param src Source image. The number of channels can be arbitrary. The depth should be one ofCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.@param dst Destination image of the same size and type as source image.@param op Type of a morphological operation, see #MorphTypes@param kernel Structuring element. It can be created using #getStructuringElement.@param anchor Anchor position with the kernel. Negative values mean that the anchor is at thekernel center.@param iterations Number of times erosion and dilation are applied.@param borderType Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.@param borderValue Border value in case of a constant border. The default value has a specialmeaning.@sa  dilate, erode, getStructuringElement@note The number of iterations is the number of times erosion or dilatation operation will be applied.For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to applysuccessively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate). *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在我们使用完Canny之后：</p><p>​        我们的核怎么来呢？专门使用函数 getStructuringElement来完成我们的工作</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat kernel &#x3D; getStructuringElement(MORPH_RECT,Size(5,5));# 这个核越大膨胀越厉害<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230305151930037.png" alt="image-20230305151930037"></p><p>​        特征被明显的放大了！</p><h3 id="图像侵蚀"><a href="#图像侵蚀" class="headerlink" title="图像侵蚀"></a>图像侵蚀</h3><p>​        我们使用的函数是 Erode:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void erode( InputArray src, OutputArray dst, InputArray kernel,                         Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,                         int borderType &#x3D; BORDER_CONSTANT,                         const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue() );&#x2F;** @example samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Morphology_1.cppErosion and Dilation sample code![Sample Screenshot-Erosion](Morphology_1_Tutorial_Erosion_Result.jpg)![Sample Screenshot-Dilation](Morphology_1_Tutorial_Dilation_Result.jpg)Check @ref tutorial_erosion_dilatation &quot;the corresponding tutorial&quot; for more details*&#x2F;&#x2F;** @brief Dilates an image by using a specific structuring element.The function dilates the source image using the specified structuring element that determines theshape of a pixel neighborhood over which the maximum is taken:\f[\texttt&#123;dst&#125; (x,y) &#x3D;  \max _&#123;(x&#39;,y&#39;):  \, \texttt&#123;element&#125; (x&#39;,y&#39;) \ne0 &#125; \texttt&#123;src&#125; (x+x&#39;,y+y&#39;)\f]The function supports the in-place mode. Dilation can be applied several ( iterations ) times. Incase of multi-channel images, each channel is processed independently.@param src input image; the number of channels can be arbitrary, but the depth should be one ofCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.@param dst output image of the same size and type as src.@param kernel structuring element used for dilation; if elemenat&#x3D;Mat(), a 3 x 3 rectangularstructuring element is used. Kernel can be created using #getStructuringElement@param anchor position of the anchor within the element; default value (-1, -1) means that theanchor is at the element center.@param iterations number of times dilation is applied.@param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported.@param borderValue border value in case of a constant border@sa  erode, morphologyEx, getStructuringElement *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230305152314781.png" alt="image-20230305152314781"></p><p>代码一览：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;Mat imgSrc,imgBlur,imgCanny,imgDial,imgErode;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;imgSrc &#x3D; imread(path);GaussianBlur(imgSrc, imgBlur, Size(7, 7), 5, 0);Canny(imgBlur,imgCanny,50,150);Mat kernel &#x3D; getStructuringElement(MORPH_RECT, Size(5, 5));dilate(imgCanny, imgDial, kernel);erode(imgDial, imgErode, kernel);imshow(&quot;org&quot;, imgSrc);imshow(&quot;dilate&quot;, imgDial);imshow(&quot;erode&quot;, imgErode);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图像大小调整与变换"><a href="#图像大小调整与变换" class="headerlink" title="图像大小调整与变换"></a>图像大小调整与变换</h3><p>​        很容易猜到重新设定大小的函数就是Resize:</p><p>​        我们首先学习一下怎样查看图像的大小：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cout &lt;&lt; img.size()&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230305153228802.png" alt="image-20230305153228802"></p><p>​        现在我们可以调整大小了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">resize(img,imgResize,Size(640,480));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230305153352540.png" alt="image-20230305153352540"></p><p>​        如果希望是等比例的放缩，可以采用这样的方式：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">resize(img,imgResize,Size(),xRatio,yRatio);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​         我们也可以裁剪图像：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Rect roi(100,100,200,300); &#x2F;&#x2F; 这里产生一个区域矩形imgCrop &#x3D; img(roi);&#x2F;&#x2F;从图像中生成子图像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    <img src="image-20230305154148790.png" alt="image-20230305154148790"></p><h2 id="纯图像应用"><a href="#纯图像应用" class="headerlink" title="纯图像应用"></a>纯图像应用</h2><p>​        Opencv当然可以创建纯色的图片。只需要我们指定图像的种类和每一位的BGR值</p><pre class="line-numbers language-none"><code class="language-none">Mat img(height,width,imgType,bkColorScalar);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        今为了创建一个彩色图像，选择 CV_8UC3，表明是CV下的8bit unsigned char（就是0~255）下的3通道图.</p><p>​        太单调了，画个圆：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;&#x2F;&#x2F; create a blank img&#x2F;&#x2F; CV_8bits(2~255) Unsigned Char 3dims Mat img(512, 512, CV_8UC3, Scalar(255,0,0));&#x2F;&#x2F;create a circlecircle(img, Point(256, 256), 155,Scalar(0,255,0),10);imshow(&quot;blue one&quot;, img);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230322220017113.png" alt="image-20230322220017113"></p><p>​        当然可以玩其他东西：不过，也就是可以查看API自己搞定：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;&#x2F;&#x2F; create a blank img&#x2F;&#x2F; CV_8bits(2~255) Unsigned Char 3dims Mat img(512, 512, CV_8UC3, Scalar(255,0,0));&#x2F;&#x2F;create a circlecircle(img, Point(256, 256), 155,Scalar(0,255,0),10);&#x2F;&#x2F; rectangle createrectangle(img, Point(150, 150), Point(300, 300), Scalar(255, 255, 255), FILLED);&#x2F;&#x2F; lineline(img, Point(200, 400), Point(400, 400), Scalar(100, 100, 100), 20);&#x2F;&#x2F; putTextputText(img, &quot;hello,world&quot;, Point(100, 100), FONT_HERSHEY_DUPLEX, 2, Scalar(0, 0, 0));imshow(&quot;blue one&quot;, img);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230322221142413.png" alt="image-20230322221142413"></p><h2 id="Warp我们的图像：图像变换1"><a href="#Warp我们的图像：图像变换1" class="headerlink" title="Warp我们的图像：图像变换1"></a>Warp我们的图像：图像变换1</h2><p>​        下面我们继续！</p><p>​        <img src="1-16825202276533.png" alt="1"></p><p>​        现在，我们想要变换这中间的一个扑克牌使之正立！我们转向：先把目标放到一个Demo 上，就是King这张牌。现在，我们找出它的四个点！不必打开画图，我们使用 <code>setMouseCallBack</code>这个函数！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setMouseCallback(const String&amp; winname, MouseCallback onMouse, void* userdata &#x3D; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        winname就是目标窗口名称，那这个 MouseCallback是啥呢？进一步去看</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        再明显不过了，我们重写一个函数，其原型是如上的，我们编写一个！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void onMouse(int event, int x, int y, int flags, void*) &#123;if(event &#x3D;&#x3D; EVENT_LBUTTONDOWN)cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;string path &#x3D; &quot;C:\\Users\\usr\\Desktop\\My coding repositary\\learnopencv\\2\\source_file\\1.png&quot;;Mat warp &#x3D; imread(path);if (warp.empty()) &#123;return -1;&#125;imshow(&quot;1&quot;, warp);setMouseCallback(&quot;1&quot;, onMouse);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        啊哈！</p><p><img src="image-20230419220733947.png" alt="image-20230419220733947"></p><p>​        这几个点收下了！</p><p>​        然后，我们想要立正之后，图片的宽和高也应当要给出来！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">float w &#x3D; 250, h &#x3D; 350;Point2f points[4] &#x3D; &#123; &#123;575 ,195&#125;,&#123;440 ,465&#125;,&#123;733 ,528&#125;,&#123;833 ,247&#125; &#125;;Point2f after[4] &#x3D; &#123; &#123;0,0&#125;,&#123;w ,0&#125;,&#123;0 ,h&#125;,&#123;w ,h&#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后转向API的调用！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">mat &#x3D; getPerspectiveTransform(points, after);warpPerspective(warp,imgWarp, mat, Point(w, h));imshow(&quot;Warp&quot;, imgWarp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230419222906918.png" alt="image-20230419222906918"></p><p>​        看到这个图片了嘛，这个就是我们今天的任务！通过颜色来检测于识别小车！</p><h2 id="颜色检测"><a href="#颜色检测" class="headerlink" title="颜色检测"></a>颜色检测</h2><p>​        我们首先来转化一下这个图片，我们的图片都是采用BGR绘制的。但是还有另一套颜色系统，是用HSV来描述的：</p><pre class="line-numbers language-none"><code class="language-none">每一种颜色都是由色相（Hue，简H），饱和度（Saturation，简S）和色明度（Value，简V）所表示的。这个模型中颜色的参数分别是：色调（H），饱和度（S），亮度（V）。色调H参数表示色彩信息，即所处的光谱颜色的位置。该参数用一角度量来表示，取值范围为0°～360°。若从红色开始按逆时针方向计算，红色为0°，绿色为120°，蓝色为240°。它们的补色是：黄色为60°，青色为180°，紫色为300°；饱和度S：取值范围为0.0～1.0；亮度V：取值范围为0.0(黑色)～1.0(白色)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在Opencv中，转化的方式同将图片二值化是一致的，都是cvtColor(),其调用的参数我想很容易猜：COLOR_BGR2HSV.</p><p><img src="D:/Hexo-Blog/source/_posts/image-20230423222747297.png" alt=""></p><p>​        但是，我们若是想要筛选，就必须要采用滑条的方式来搞！</p><p>​        怎么搞呢？</p><p>​        首先，我们创建滑动条，就必须要使用Scalar来搞，我们的HSV有上下限制，这就意味着。两个vector是被需要的：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lower<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> upper<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int arr[6] &#x3D; &#123; 0,0,0,255,255,255 &#125;;for (int i &#x3D; 0; i &lt; 3; i++) &#123;lower.push_back(arr[i]);upper.push_back(arr[i + 3]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        随后，使用由inRange函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void inRange(InputArray src, InputArray lowerb,                          InputArray upperb, OutputArray dst);&#x2F;** @brief Performs the per-element comparison of two arrays or an array and scalar value.The function compares:*   Elements of two arrays when src1 and src2 have the same size:    \f[\texttt&#123;dst&#125; (I) &#x3D;  \texttt&#123;src1&#125; (I)  \,\texttt&#123;cmpop&#125;\, \texttt&#123;src2&#125; (I)\f]*   Elements of src1 with a scalar src2 when src2 is constructed from    Scalar or has a single element:    \f[\texttt&#123;dst&#125; (I) &#x3D;  \texttt&#123;src1&#125;(I) \,\texttt&#123;cmpop&#125;\,  \texttt&#123;src2&#125;\f]*   src1 with elements of src2 when src1 is constructed from Scalar or    has a single element:    \f[\texttt&#123;dst&#125; (I) &#x3D;  \texttt&#123;src1&#125;  \,\texttt&#123;cmpop&#125;\, \texttt&#123;src2&#125; (I)\f]When the comparison result is true, the corresponding element of outputarray is set to 255. The comparison operations can be replaced with theequivalent matrix expressions:@code&#123;.cpp&#125;    Mat dst1 &#x3D; src1 &gt;&#x3D; src2;    Mat dst2 &#x3D; src1 &lt; 8;    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        产生掩码：但是这里要求的时Scalar，我们先搞一下</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Scalar down(lower[0], lower[1], lower[2]);Scalar up(upper[0], upper[1], upper[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        现在可以了</p><pre class="line-numbers language-none"><code class="language-none">inRange(HSV, down, up, mask);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        但是，反复的调值太麻烦，我们使用滑动条调值！</p><p>​        先建立一个窗口，在基于这个窗口创立滑动条！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">namedWindow(&quot;TrackBars&quot;, (640, 480));createTrackbar(&quot;Hue Min&quot;, &quot;TrackBars&quot;, &amp;lower[0], 255);createTrackbar(&quot;Hue Max&quot;, &quot;TrackBars&quot;, &amp;upper[0], 255);createTrackbar(&quot;Sat Min&quot;, &quot;TrackBars&quot;, &amp;lower[1], 255);createTrackbar(&quot;Sat Max&quot;, &quot;TrackBars&quot;, &amp;upper[1], 255);createTrackbar(&quot;Val Min&quot;, &quot;TrackBars&quot;, &amp;lower[2], 255);createTrackbar(&quot;Val Max&quot;, &quot;TrackBars&quot;, &amp;upper[2], 255);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void namedWindow(const String&amp; winname, int flags &#x3D; WINDOW_AUTOSIZE);&#x2F;** @brief Destroys the specified window.The function destroyWindow destroys the window with the given name.@param winname Name of the window to be destroyed. *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS int createTrackbar(const String&amp; trackbarname, const String&amp; winname,                              int* value, int count,                              TrackbarCallback onChange &#x3D; 0,                              void* userdata &#x3D; 0);&#x2F;** @brief Returns the trackbar position.The function returns the current position of the specified trackbar.@note[__Qt Backend Only__] winname can be empty if the trackbar is attached to the controlpanel.@param trackbarname Name of the trackbar.@param winname Name of the window that is the parent of the trackbar. *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，使用一个死循环来完成我们的工作：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(1)&#123;Scalar down(lower[0], lower[1], lower[2]);Scalar up(upper[0], upper[1], upper[2]);inRange(HSV, down, up, mask);imshow(&quot;work&quot;, mask);waitKey(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样就好了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;using namespace cv;string path &#x3D; &quot;D:\\My coding repositary\\learnopencv\\5\\source_file\\1.png&quot;;vector&lt;int&gt; lower;vector&lt;int&gt; upper;void showVec(vector&lt;int&gt; pVec) &#123;for (auto i &#x3D; pVec.begin(); i !&#x3D; pVec.end(); i++) &#123;cout &lt;&lt; *i &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &#39;\n&#39;;&#125;Mat HSV , mask;int main()&#123;int arr[6] &#x3D; &#123; 0,0,0,255,255,255 &#125;;for (int i &#x3D; 0; i &lt; 3; i++) &#123;lower.push_back(arr[i]);upper.push_back(arr[i + 3]);&#125;showVec(lower);showVec(upper);Mat workPng &#x3D; imread(path);if (workPng.empty()) &#123;return -1;&#125;cvtColor(workPng, HSV, COLOR_BGR2HSV);namedWindow(&quot;TrackBars&quot;, (640, 480));createTrackbar(&quot;Hue Min&quot;, &quot;TrackBars&quot;, &amp;lower[0], 255);createTrackbar(&quot;Hue Max&quot;, &quot;TrackBars&quot;, &amp;upper[0], 255);createTrackbar(&quot;Sat Min&quot;, &quot;TrackBars&quot;, &amp;lower[1], 255);createTrackbar(&quot;Sat Max&quot;, &quot;TrackBars&quot;, &amp;upper[1], 255);createTrackbar(&quot;Val Min&quot;, &quot;TrackBars&quot;, &amp;lower[2], 255);createTrackbar(&quot;Val Max&quot;, &quot;TrackBars&quot;, &amp;upper[2], 255);while(1)&#123;Scalar down(lower[0], lower[1], lower[2]);Scalar up(upper[0], upper[1], upper[2]);inRange(HSV, down, up, mask);imshow(&quot;work&quot;, mask);waitKey(1);&#125;waitKey();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="D:/Hexo-Blog/source/_posts/image-20230426213925062.png" alt="image-20230426213925062"></p><p><img src="D:/Hexo-Blog/source/_posts/image-20230426214024473.png" alt="image-20230426214024473"></p><p><img src="D:/Hexo-Blog/source/_posts/image-20230426214208705.png" alt="image-20230426214208705"></p><p>​        这是一个简单的图像，我们尝试来用之检测形状！</p><h2 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h2><p>​        现在我们想要检测形状的轮廓，是需要对图片做出若干预处理的！我们必须保证我们的图片经过开闭运算：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Mat&amp; preWork(Mat&amp; pic)&#123;Mat grey, blur, canny, dil, erode;cvtColor(pic, grey, COLOR_BGR2GRAY);GaussianBlur(grey, blur, Size(3, 3), 3, 0);Canny(blur, canny, 25, 75);Mat kernel &#x3D; getStructuringElement(MORPH_RECT, Size(3, 3));dilate(canny, dil, kernel);imshow(&quot;grey&quot;, grey);imshow(&quot;blur&quot;, blur);imshow(&quot;canny&quot;, canny);imshow(&quot;dil&quot;, dil);&#x2F;&#x2F;imshow(&quot;erode&quot;, erode);waitKey(0);Mat* work &#x3D; new Mat(dil);return *work;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们返回的就是经过预处理的图片了！下面开始重点讲轮廓！</p><p>​        我们的轮廓是用点来描述的，轮廓有若干层数，这就需要我们使用 vector<vector< int >&gt;</p><p>​        还有层级，这里我们使用 vector&lt; Vec4i &gt;来定义类型！它表明当前的每一个类型有四个整数构成，就不需要我们自己手动指定原生的C++类型了</p><p>​        这里是找到轮廓的函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** @brief Finds contours in a binary image.The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contoursare a useful tool for shape analysis and object detection and recognition. See squares.cpp in theOpenCV sample directory.@note Since opencv 3.2 source image is not modified by this function.@param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1&#39;s. Zeropixels remain 0&#39;s, so the image is treated as binary . You can use #compare, #inRange, #threshold ,#adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one.If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).@param contours Detected contours. Each contour is stored as a vector of points (e.g.std::vector&lt;std::vector&lt;cv::Point&gt; &gt;).@param hierarchy Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It hasas many elements as the number of contours. For each i-th contour contours[i], the elementshierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indicesin contours of the next and previous contours at the same hierarchical level, the first childcontour and the parent contour, respectively. If for the contour i there are no next, previous,parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.@param mode Contour retrieval mode, see #RetrievalModes@param method Contour approximation method, see #ContourApproximationModes@param offset Optional offset by which every contour point is shifted. This is useful if thecontours are extracted from the image ROI and then they should be analyzed in the whole imagecontext. *&#x2F;CV_EXPORTS_W void findContours( InputArray image, OutputArrayOfArrays contours,                              OutputArray hierarchy, int mode,                              int method, Point offset &#x3D; Point());&#x2F;** @overload *&#x2F;CV_EXPORTS void findContours( InputArray image, OutputArrayOfArrays contours,                              int mode, int method, Point offset &#x3D; Point());&#x2F;** @example samples&#x2F;cpp&#x2F;squares.cppA program using pyramid scaling, Canny, contours and contour simplification to findsquares in a list of images (pic1-6.png). Returns sequence of squares detected on the image.*&#x2F;&#x2F;** @example samples&#x2F;tapi&#x2F;squares.cppA program using pyramid scaling, Canny, contours and contour simplification to findsquares in the input image.*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这里是一些参数的文档</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">enum RetrievalModes &#123;    &#x2F;** retrieves only the extreme outer contours. It sets &#96;hierarchy[i][2]&#x3D;hierarchy[i][3]&#x3D;-1&#96; for    all the contours. *&#x2F;    RETR_EXTERNAL  &#x3D; 0,    &#x2F;** retrieves all of the contours without establishing any hierarchical relationships. *&#x2F;    RETR_LIST      &#x3D; 1,    &#x2F;** retrieves all of the contours and organizes them into a two-level hierarchy. At the top    level, there are external boundaries of the components. At the second level, there are    boundaries of the holes. If there is another contour inside a hole of a connected component, it    is still put at the top level. *&#x2F;    RETR_CCOMP     &#x3D; 2,    &#x2F;** retrieves all of the contours and reconstructs a full hierarchy of nested contours.*&#x2F;    RETR_TREE      &#x3D; 3,    RETR_FLOODFILL &#x3D; 4 &#x2F;&#x2F;!&lt;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">enum ContourApproximationModes &#123;    &#x2F;** stores absolutely all the contour points. That is, any 2 subsequent points (x1,y1) and    (x2,y2) of the contour will be either horizontal, vertical or diagonal neighbors, that is,    max(abs(x1-x2),abs(y2-y1))&#x3D;&#x3D;1. *&#x2F;    CHAIN_APPROX_NONE      &#x3D; 1,    &#x2F;** compresses horizontal, vertical, and diagonal segments and leaves only their end points.    For example, an up-right rectangular contour is encoded with 4 points. *&#x2F;    CHAIN_APPROX_SIMPLE    &#x3D; 2,    &#x2F;** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 *&#x2F;    CHAIN_APPROX_TC89_L1   &#x3D; 3,    &#x2F;** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 *&#x2F;    CHAIN_APPROX_TC89_KCOS &#x3D; 4&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面是一些具体的参数说明！</p><p>​        我们的findCountours 取到轮廓之后呢，就向我们传入空的轮廓和层级输入数据。随后，我们在 原图像（很重要，不要画在二值化后的图里去了！！！）绘制轮廓，这样就好了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)&#123;vector&lt;vector&lt;Point&gt;&gt; countours;vector&lt;Vec4i&gt; hierarchy;findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);Mat* workMat &#x3D; new Mat(org);drawContours(*workMat, countours, -1, Scalar(255, 0, 0), 3);return *workMat;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="D:/Hexo-Blog/source/_posts/image-20230426221756602.png" alt="image-20230426221756602"></p><p>​        但是一些原因我们的图片可能是有多个绘制的，他们是由图片的噪点 造成的，我们现在使用面积筛选法筛选！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)&#123;vector&lt;vector&lt;Point&gt;&gt; countours;vector&lt;Vec4i&gt; hierarchy;findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);Mat* workMat &#x3D; new Mat(org);for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;auto area &#x3D; contourArea(countours[i]);cout &lt;&lt; area &lt;&lt; endl;if (area &gt; 1000) &#123;drawContours(*workMat, countours, i, Scalar(255, 0, 0), 3);&#125;&#x2F;&#x2F; 第I个轮廓满足！&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面呢，我们使用矩形将找到的形状括起来！这就需要我们：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** @brief Calculates a contour perimeter or a curve length.The function computes a curve length or a closed contour perimeter.@param curve Input vector of 2D points, stored in std::vector or Mat.@param closed Flag indicating whether the curve is closed or not. *&#x2F;CV_EXPORTS_W double arcLength( InputArray curve, bool closed );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">double peri &#x3D; arcLength(countours[i], true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以及我们之后可能需要通过多少个角点来判定他们是什么，就需要我们：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** @brief Approximates a polygonal curve(s) with the specified precision.The function cv::approxPolyDP approximates a curve or a polygon with another curve&#x2F;polygon with lessvertices so that the distance between them is less or equal to the specified precision. It uses theDouglas-Peucker algorithm &lt;http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ramer-Douglas-Peucker_algorithm&gt;@param curve Input vector of a 2D point stored in std::vector or Mat@param approxCurve Result of the approximation. The type should match the type of the input curve.@param epsilon Parameter specifying the approximation accuracy. This is the maximum distancebetween the original curve and its approximation.@param closed If true, the approximated curve is closed (its first and last vertices areconnected). Otherwise, it is not closed. *&#x2F;CV_EXPORTS_W void approxPolyDP( InputArray curve,                                OutputArray approxCurve,                                double epsilon, bool closed );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为此，我们需要一个跟轮廓一个数据结构的大小来接受结果，随后用之来绘制轮廓，那就是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)&#123;vector&lt;vector&lt;Point&gt;&gt; countours;vector&lt;Vec4i&gt; hierarchy;findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);Mat* workMat &#x3D; new Mat(org);vector&lt;vector&lt;Point&gt;&gt; conPoly(countours.size());for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;auto area &#x3D; contourArea(countours[i]);cout &lt;&lt; area &lt;&lt; endl;if (area &gt; 1000) &#123;double peri &#x3D; arcLength(countours[i], true);approxPolyDP(countours[i], conPoly[i], 0.02 * peri, true);drawContours(*workMat, conPoly, i, Scalar(255, 0, 0), 3);&#125;&#125;return *workMat;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="D:/Hexo-Blog/source/_posts/image-20230426223109977.png" alt="image-20230426223109977"></p><p>​        而框住矩形是由给出：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** @brief Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.The function calculates and returns the minimal up-right bounding rectangle for the specified point set ornon-zero pixels of gray-scale image.@param array Input gray-scale image or 2D point set, stored in std::vector or Mat. *&#x2F;CV_EXPORTS_W Rect boundingRect( InputArray array );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        函数每一次扫描ConPoly后返回最小矩形，我们用一个vector&lt; Rect &gt;接受就好了</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)&#123;vector&lt;vector&lt;Point&gt;&gt; countours;vector&lt;Vec4i&gt; hierarchy;findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);Mat* workMat &#x3D; new Mat(org);vector&lt;vector&lt;Point&gt;&gt; conPoly(countours.size());vector&lt;Rect&gt; boundRect(countours.size());for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;auto area &#x3D; contourArea(countours[i]);cout &lt;&lt; area &lt;&lt; endl;if (area &gt; 1000) &#123;double peri &#x3D; arcLength(countours[i], true);approxPolyDP(countours[i], conPoly[i], 0.02 * peri, true);boundRect[i]  &#x3D; boundingRect(conPoly[i]);drawContours(*workMat, conPoly, i, Scalar(255, 0, 0), 3);rectangle(*workMat, boundRect[i].tl(), boundRect[i].br(), Scalar(255, 0, 100),5);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="D:/Hexo-Blog/source/_posts/image-20230426223759367.png" alt="image-20230426223759367"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm_in_C(1)</title>
      <link href="/2023/06/06/Algorithm-in-C-1/"/>
      <url>/2023/06/06/Algorithm-in-C-1/</url>
      
        <content type="html"><![CDATA[<h1 id="基于C的算法深入学习"><a href="#基于C的算法深入学习" class="headerlink" title="基于C的算法深入学习"></a>基于C的算法深入学习</h1><h2 id="第一篇：小引"><a href="#第一篇：小引" class="headerlink" title="第一篇：小引"></a>第一篇：小引</h2><p>​        为了更好的学习算法，我们有必要采取一些简单的数学复习。</p><h3 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h3><script type="math/tex; mode=display">X^AX^B = X^{A+B}</script><script type="math/tex; mode=display">\frac{X^A}{X^B} = X^{A-B}</script><script type="math/tex; mode=display">(X^A)^B = X^{AB}</script><h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><p>​        在计算机科学中，我们有必要反复强调，所有的对数都是以二为底的。</p><p>​        而在数学上，我们如是定义对数：$X^A = B$，于是$\log_X^B=A$</p><script type="math/tex; mode=display">\log_A^B=\frac{\log_C^B}{\log_C^A}</script><script type="math/tex; mode=display">\log AB=\log A+ \log B</script><p>​        当然基于此，我们还有其他的公式：</p><p>1.$\log A/B = \log A-\log B$</p><p>2.$\log(A^B)=B\log A$</p><p>3.$\log X &lt; X$</p><h3 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h3><p>​        什么是级数呢？一些列数字的从1 至 i 的和记作$a_i$，于是下面是一个最简单的级数求和公式</p><script type="math/tex; mode=display">\sum_{i = 0}^N 2^i = 2^{N+1} -1</script><p>​        为了强调通用性，我们还给出这个公式：</p><script type="math/tex; mode=display">\sum_{i = 0}^N A^i = \frac{A^{N+1} -1}{A-1}</script><p>​        于是，当$0 &lt; A &lt; 1$下，就会得到该级数收敛的结果</p><script type="math/tex; mode=display">\sum_{i = 0}^N A^i \leq \frac{1}{1-A}</script><h3 id="定义模运算"><a href="#定义模运算" class="headerlink" title="定义模运算"></a>定义模运算</h3><p>​        如果我们说: 一个整数$N$整除$A-B$，也就记作有：$A\equiv B(\mod N)$</p><h3 id="简单的递归阐述"><a href="#简单的递归阐述" class="headerlink" title="简单的递归阐述"></a>简单的递归阐述</h3><p>​        递归在数据结构与算法中被大量的使用。我们来看一个小例子：$C = 5\times(F-32)/9$。我们书写一个函数来求之给定一个华氏度下的摄氏度求法。</p><p>​        任何一个C程序员可以马上给出：（为了从简我们使用<code>int</code> ）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int F(int x)&#123;    return 5*(F-32)&#x2F;9;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        那使用递归呢？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int F(int x)&#123;&#x2F;*给出退出条件*&#x2F;    if( X &#x3D;&#x3D; 0 )        return 0;    else        return 2*F(X-1) + X*X;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        什么意思？<strong>当我们没有办法给出一个直达结果的程序代码，而是只知道两者联系的时候，使用递归可以是很好的解决办法</strong></p><p>​        上面的代码，只考虑了第$I-1$摄氏度和第$I$摄氏度关系，一直调用函数直到函数的形参为0 时停止调用，将值一级一级返回至最初的调用点。</p><p>​        注意——书写函数的时候应当妥善的处理推出条件，估计到自己的递归能不能成功退出递归条件。比如说</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;*Unsuccessful recursion!*&#x2F;int someFunc(unsigned int N)&#123;    if(N &#x3D;&#x3D; 0)&#123;        return 0;    &#125;    else    &#123;        return someFunc(N&#x2F;3 + 1) + N - 1;     &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的结果，除了 0 之外，都无法算出结果，代价是程序的空间将会被占满直到计算机崩溃为止。</p><h2 id="Extensive-Reading"><a href="#Extensive-Reading" class="headerlink" title="Extensive Reading"></a>Extensive Reading</h2><p>原文链接：<a href="https://blog.csdn.net/weixin_44572229/article/details/119909728">https://blog.csdn.net/weixin_44572229/article/details/119909728</a></p><h3 id="1-什么是递归？"><a href="#1-什么是递归？" class="headerlink" title="1.什么是递归？"></a>1.什么是递归？</h3><p>​        什么是递归呢? 要理解递归，就得先了解什么是递归，实际上这句话就是一个递归。这么说可能不好理解，接下来我举个简单的例子来解释这段话的意义。</p><p>​        如果不了解递归，那就先了解什么是递归。嗯？那我再说一遍：如果不了解递归，那就先了解什么是递归。，好像死循环了！可能你会说这是个循环并不是递归，我们前面说到，递归是需要终止条件的，那么你明白递归是什么其实就是终止条件。整个过程，搜索引擎充当递归函数(只是形象的假设)。在你去依次查找递归/栈/内存/操作系统的过程为前行阶段，在你都了解完之后，反回去了解含义的过程为退回阶段。如果还是不太清楚，可以接着看下面的例子。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA5piv5LiA5Y-q5rS-5aSn6ZGr,size_9,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p> 实际上这张图就很形象地表达出了递归，这句吓得我抱起了抱着抱着抱着我的小鲤鱼的我的我的我如果从字面意义上看可能看不出是什么意思，那么我们可以通过代码来实现同样的效果:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void recursion(int n)&#123;std::cout&lt;&lt;&quot;抱着&quot;;if(!n)&#123;std::cout&lt;&lt;&quot;我的小鲤鱼&quot;;&#125;else&#123;recursion(n-1);&#125;  std::cout&lt;&lt;&quot;的我&quot;;return;&#125;int main()&#123;std::cout&lt;&lt;&quot;吓得我抱起了&quot;;recursion(2);return 0;&#x2F;&#x2F;完结撒花～&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA5piv5LiA5Y-q5rS-5aSn6ZGr,size_15,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><h3 id="2-递归的思想"><a href="#2-递归的思想" class="headerlink" title="2.递归的思想"></a>2.递归的思想</h3><p>​        递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。</p><p>​        递归有三大要素</p><h4 id="第一要素：明确你这个函数想要干什么"><a href="#第一要素：明确你这个函数想要干什么" class="headerlink" title="第一要素：明确你这个函数想要干什么"></a>第一要素：明确你这个函数想要干什么</h4><p>​        对于递归，我觉得很重要的一个事就是，这个函数的功能是什么，他要完成什么样的一件事，而这个，是完全由你自己来定义的。也就是说，我们先不管函数里面的代码什么，而是要先明白，你这个函数是要用来干什么。</p><p>​        例如，我定义了一个函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 算 n 的阶乘(假设n不为0)int f(int n)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个函数的功能是算 n 的阶乘。好了，我们已经定义了一个函数，并且定义了它的功能是什么，接下来我们看第二要素。</p><h4 id="第二要素：寻找递归结束条件"><a href="#第二要素：寻找递归结束条件" class="headerlink" title="第二要素：寻找递归结束条件"></a>第二要素：寻找递归结束条件</h4><p>​        所谓递归，就是会在函数内部代码中，调用这个函数本身，所以，我们必须要找出递归的结束条件，不然的话，会一直调用自己，进入无底洞。也就是说，我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。</p><p>​        例如，上面那个例子，当 n = 1 时，那你应该能够直接知道 f(n) 是啥吧？此时，f(1) = 1。完善我们函数内部的代码，把第二要素加进代码里面，如下</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 算 n 的阶乘(假设n不为0)int f(int n)&#123;    if(n &#x3D;&#x3D; 1)&#123;        return 1;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        有人可能会说，当 n = 2 时，那我们可以直接知道 f(n) 等于多少啊，那我可以把 n = 2 作为递归的结束条件吗？</p><p>​        当然可以，只要你觉得参数是什么时，你能够直接知道函数的结果，那么你就可以把这个参数作为结束的条件，所以下面这段代码也是可以的。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 算 n 的阶乘(假设n&gt;&#x3D;2)int f(int n)&#123;    if(n &#x3D;&#x3D; 2)&#123;        return 2;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意我代码里面写的注释，假设 n &gt;= 2，因为如果 n = 1时，会被漏掉，当 n &lt;= 2时，f(n) = n，所以为了更加严谨，我们可以写成这样：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 算 n 的阶乘(假设n不为0)int f(int n)&#123;    if(n &lt;&#x3D; 2)&#123;        return n;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第三要素：找出函数的等价关系式"><a href="#第三要素：找出函数的等价关系式" class="headerlink" title="第三要素：找出函数的等价关系式"></a>第三要素：找出函数的等价关系式</h4><p>​        第三要素就是，我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。</p><p>​        例如，f(n) 这个范围比较大，我们可以让 f(n) = n * f(n-1)。这样，范围就由 n 变成了 n-1 了，范围变小了，并且为了原函数f(n) 不变，我们需要让 f(n-1) 乘以 n。</p><p>​        说白了，就是要找到原函数的一个等价关系式，f(n) 的等价关系式为 $n\times f(n-1)$.</p><p>​        举个栗子，还是从阶乘来出发 </p><p>​        假设我们用递归来算阶乘 f(n)</p><pre class="line-numbers language-none"><code class="language-none">f &#x3D; n &#x3D;&gt;    n &#x3D;&#x3D;&#x3D; 1 ? 1            : n * f(n-1) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        f 里面用到了 f，怎么理解呢？</p><p>​        很简单，把式子展开即可：</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBA5piv5LiA5Y-q5rS-5aSn6ZGr,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><pre><code>     看到递归了吗？</code></pre><p>​        先递进，再回归——这就是「递归」。 </p><h4 id="3-递归的缺点"><a href="#3-递归的缺点" class="headerlink" title="3.递归的缺点"></a>3.递归的缺点</h4><p>​        递归的缺点，从上图我们可以看出</p><p>​        在程序执行中，递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 栈溢出 的后果。</p><p>​        显然有时候递归处理是高效的，比如归并排序；有时候是低效的，比如数孙悟空身上的毛，因为堆栈会消耗额外空间，而简单的递推不会消耗空间。</p><h4 id="4-递归的程序特性"><a href="#4-递归的程序特性" class="headerlink" title="4.递归的程序特性"></a>4.递归的程序特性</h4><p>优雅性</p><p>​        相比其他解法（比如迭代法），使用递归法，你会发现只需少量程序就可描述出解题过程，大大减少了程序的代码量，而且很好理解。递归的能力在于用有限的语句来定义对象的无限集合。</p><p>反向性</p><p>​        由于递归调用程序需要维护调用栈，而栈（我们在上文提过）具有后进先出的特征，因此递归程序适合满足取反类需求。我们在第五部分有一些编程实践，比如字符串取反，链表取反等相关有趣的算法问题。</p><p>递推关系</p><p>​        递归程序可以较明显的发现递推关系，反过来也可以这么说，具有递推关系的问题基本都可以通过递归求解（当然也许有性能更佳的解法，但递归绝对是一种选择）。递推关系常见问题有杨辉三角、阶乘计算</p><h4 id="5-什么时候用递归"><a href="#5-什么时候用递归" class="headerlink" title="5.什么时候用递归"></a>5.什么时候用递归</h4><p>​        说了那么多，那么我们什么时候可以用、应该用递归呢？</p><p>​        具有以下特征的问题可考虑递归求解：</p><p>​        当问题和子问题具有递推关系，比如杨辉三角、计算阶乘（后文讨论）。<br>​        具有递归性质的数据结构，比如链表、树、图。<br>​        反向性问题，比如取反。<br>​        总结下来，最根本的还是要抓住问题本身是否可以通过层层拆解到最小粒度来得解。</p><h3 id="6-递归总结"><a href="#6-递归总结" class="headerlink" title="6.递归总结"></a>6.递归总结</h3><p>​        现在，我们更加相信递归是一种强大的技术，它使我们能够以一种优雅而有效的方式解决许多问题。同时，它也不是解决任务问题的灵丹妙药。由于时间或空间的限制，并不是所有的问题都可以用递归来解决。递归本身可能会带来一些不希望看到的副作用，如栈溢出。</p><p>​        有时，在解决实际问题时乍一看，我们并不清楚是否可以应用递归算法来解决问题。然而，由于递归的递推性质与我们所熟悉的数学非常接近，用数学公式来推导某些关系总是有帮助的，也就是说写出递推关系和基本情况是使用递归算法的前置条件。</p><p>​        只要有可能，就应用记忆化。在起草递归算法时，可以从最简单的策略开始。有时，在递归过程中，可能会出现重复计算的情况，例如斐波纳契数（Fibonacci）。在这种情况下，你可以尝试应用 Memoization 技术，它将中间结果存储在缓存中供以后重用，它可以在空间复杂性上稍加折中，从而极大地提高时间复杂性，因为它可以避免代价较高的重复计算。</p><p>​        当堆栈溢出时，尾递归可能会有所帮助。</p><p>​        使用递归实现算法通常有几种方法。尾递归是我们可以实现的递归的一种特殊形式。与记忆化技术不同的是，尾递归通过消除递归带来的堆栈开销，优化了算法的空间复杂度。更重要的是，有了尾递归，就可以避免经常伴随一般递归而来的堆栈溢出问题，而尾递归的另一个优点是，与非尾递归相比，尾部递归更容易阅读和理解。这是由于尾递归不存在调用后依赖（即递归调用是函数中的最后一个动作），这一点不同于非尾递归，因此，只要有可能，就应该尽量运用尾递归。</p><h2 id="第二篇：简单的算法分析"><a href="#第二篇：简单的算法分析" class="headerlink" title="第二篇：简单的算法分析"></a>第二篇：简单的算法分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>​        我们分析算法，<strong>首先需要衡量的就是一个算法的时间复杂度</strong>，问题来了，啥是时间复杂度嘞？答案是：我跑完这个算法的时间相对于数量级的最高幂数。抽象！人话就是：对于同一套数据处理之，它快不快？</p><p>​        还是没大懂，究竟是什么？</p><p>​        先来思考一个问题：你怎么衡量一个算法的速度的？很简单，扔进一个程序性能分析器，看他跑完我这个模块的时间呗！基于此的，我再问你，你这个算法，和我这个算法，给出10个数据处理，和给1000000000000000000个数据处理，时间一样嘛？显然不一样！我的算法处理1000000000000000000个数据，和你的算法处理10个数据，显然往往后这快！但是，如果我们两个都去处理1000000000000000000个数据，这就不好说了。于是——</p><p>​        <code>时间复杂度</code>正是对于给定一套数量级的数据，该算法相对于这个数量级的数据的运算时间表现。</p><h4 id="O-f-N"><a href="#O-f-N" class="headerlink" title="$O(f(N))$"></a>$O(f(N))$</h4><p>​        但是，这一时间并不好精确的衡量，我们于是引入下面四个重要的定义式子：他们将分别衡量——算法运行的最大期望时间，最小的期望时间。</p><pre><code>   首先，这是我们在学习工作中描述算法时间复杂度用的最普遍的符号shi 。它是渐进上界，其作用是将我们得到的算法在最坏情况下（worst case）时间复杂度表达式简化成对应的多项式（比如n^2等）。所以在我们证明的过程中，目的是证明我们的式子要“小于等于”目标多项式。</code></pre><h4 id="Omega-f-N"><a href="#Omega-f-N" class="headerlink" title="$\Omega(f(N))$"></a>$\Omega(f(N))$</h4><pre><code>  这个符号我们一般用的比较少，一个是因为我们一般不会去考虑算法运行时间的下界，另一个是因为下界时间也不好证明。没错，他就是渐进下界，其作用是将我们得到的算法在最好情况下（best case）时间复杂度表达式简化成对应的多项式（也比如n^2等）。所以在我们证明的过程中，目的是证明我们的式子要“大于等于”目标多项式。</code></pre><h4 id="Theta-g-N"><a href="#Theta-g-N" class="headerlink" title="$\Theta(g(N))$"></a>$\Theta(g(N))$</h4><p>​      如果O和Ω可以用同一个多项式表示，那么这个多项式就是我们所要求的渐进紧的界了。其作用是将我们可以较准确地得到算法的时间复杂度表达式对应的多项式（也比如n^2等）。所以在我们证明的过程中，目的是证明我们的式子要“等于”目标多项式。</p><h3 id="各项算法的差异"><a href="#各项算法的差异" class="headerlink" title="各项算法的差异"></a>各项算法的差异</h3><p>​        常见的时间复杂度如下所示：</p><p>1.O(1) — 常数复杂度<br>2.O(log n) — 对数复杂度<br>3.O(n) — 线性复杂度<br>4.O(n log n) — 对数线性复杂度<br>5.O(nᵏ) — 多项式复杂度<br>6.O(kⁿ) — 指数复杂度<br>7.O(n!) — 阶乘复杂度<br>        下图描绘了各种复杂度的算法中，当输入规模增长时，操作数量（运行时间）的变化趋势。</p><p><img src="C:\Users\陈冠豪\Desktop\NowReading\Finish reading as well as noting\C Algorithm\基于C的算法深入学习1\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM4MzI3MDc=,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p><p>​        你可以看到，随着输入规模的增长，红色阴影区域中算法的运行时间急剧增长。另一方面，在黄色和绿色阴影区域中的算法，当输入规模增长时，运行时间在变化不是很大，因此它们更高效，处理大量数据时更游刃有余。</p><p>​        最后需要指明的一点，大 O 表示法通常用于描述当输入规模变得非常大时，算法呈现的「显著趋势」。因此，大的显著趋势会盖过一些小的细枝末节的趋势。例如，我们实际测算得到时间复杂度为 O(n²+ n) 的算法会简化为 O(n²)，原因是随着 n 变得非常大时， n² 这一项的显著性远远盖过了 n 这一项的显著性。</p><p>​        下面给出一些例子：</p><ol><li><h4 id="O-1-—-常数复杂度"><a href="#O-1-—-常数复杂度" class="headerlink" title="O(1) — 常数复杂度"></a>O(1) — 常数复杂度</h4><p>​        这种复杂度的算法的运行时间不会随着输入规模的增加而增加。这类操作的实际例子就是在数组中按索引查找值，或者在哈希表中按键查找值：</p></li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int i &#x3D; 0;i ++; &#x2F;&#x2F; 简单的操作int arr[100] &#x3D; &#123;0&#125;;i &#x3D; arr[99];&#x2F;&#x2F; pretend that we import the hashTabletable.search(i); &#x2F;&#x2F; 常数时间操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>    无论传递给这些函数的哈希表有多大，它们用同等的时间来完成（只有一步操作）。</code></pre><ol><li><h4 id="O-log-n-—-对数复杂度"><a href="#O-log-n-—-对数复杂度" class="headerlink" title="O(log n) — 对数复杂度"></a>O(log n) — 对数复杂度</h4><p>​        典型的对数复杂度算法是二分搜索算法。这是一种用于在有序数组中查找特定值的算法，它不断迭代读取当前范围的中间值，判断目标值是小于还是大于中间值，排除不包含目标的那一半内容。下面是它的一种实现：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef int Index;#define UNFIND -1;Index binSearch(int arr[],int arrSize,int target)&#123;    &#x2F;&#x2F; make some check here...    &#x2F;&#x2F; ...    &#x2F;&#x2F; end check    int left &#x3D; 0;    int right &#x3D; arrSize - 1;    while(left &lt;&#x3D; right)    &#123;        int middle &#x3D; left + (right - left) &gt;&gt; 1; &#x2F;&#x2F; actually make middle,but this way we could effectively prevent overflowing        if(middle &#x3D; target)        &#123;            return middle;        &#125;        else if(arr[middle] &lt; target)&#123;            left &#x3D; middle + 1;        &#125;        else        &#123;            right &#x3D; middle - 1;        &#125;    &#125;        &#x2F;&#x2F; the while break, means that we could not find the target, while loop break.        return UNFIND;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><pre><code>    由于每次迭代，待搜索的数组长度会减半。因此哪怕搜索的数组长度翻了一倍，也只需多迭代一次！因此，随着数组长度的增加，运行时间将呈对数增长。</code></pre><ol><li><h4 id="O-n-—-线性复杂度"><a href="#O-n-—-线性复杂度" class="headerlink" title="O(n) — 线性复杂度"></a>O(n) — 线性复杂度</h4><p>​        线性复杂度算法往往在连续迭代数据结构时涉及到。参考先前的对数搜索示例，在数组中搜索值可以用（效率较低）的线性时间来进行，这里还是采取链表的搜索吧！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef int Index;#define UNFIND -1;&#x2F;*pretend that we define a linklist contains integers*&#x2F;Index FindElem(LinkList list, int target)&#123;    LinkNodePtr cur;    Index inPos &#x3D; 0;    while(cur !&#x3D; NULL)&#123;        if(cur-&gt;data &#x3D;&#x3D; target)&#123;            return inPos;        &#125;        inPos++;        cur &#x3D; cur-&gt;next;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>   ​        显然，随着输入链表大小的增加，由于需要检查列表中的每个项目，最坏情况下找到目标所需的循环迭代次数的增长与输入列表的大小增长成正比。</p><ol><li><h4 id="O-n-log-n-—-对数线性复杂度"><a href="#O-n-log-n-—-对数线性复杂度" class="headerlink" title="O(n log n) — 对数线性复杂度"></a>O(n log n) — 对数线性复杂度</h4><p>​        列举对数线性复杂度算法的示例会比之前难一些。顾名思义，它们同时包含对数和线性部分。其中最常见的示例是排序算法。有一个算法叫「归并排序」，它用迭代手法将数组分成一小块一小块，对每小块进行拆分、排序，然后再按顺序重新将各个小块合并在一起。通过图像可以更容易看明白，因此我将<img src="C:\Users\陈冠豪\Desktop\NowReading\Finish reading as well as noting\C Algorithm\基于C的算法深入学习1\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM4MzI3MDc=,size_16,color_FFFFFF,t_70#pic_center-16860228106569.png" alt="在这里插入图片描述">省略代码的实现。</p></li></ol><ol><li><h4 id="O-nᵏ-—-多项式复杂度"><a href="#O-nᵏ-—-多项式复杂度" class="headerlink" title="O(nᵏ) — 多项式复杂度"></a>O(nᵏ) — 多项式复杂度</h4><p>​        在这里，我们开始着手研究时间复杂度较差的算法，通常应尽可能避免使用它（请参考上文的图表，我们正处于红色区域！）。但是，许多「暴力」算法都属于多项式复杂度，可以作为帮助我们解决问题的切入点。</p></li></ol><ol><li><h4 id="O-kⁿ-—-指数复杂度"><a href="#O-kⁿ-—-指数复杂度" class="headerlink" title="O(kⁿ) — 指数复杂度"></a>O(kⁿ) — 指数复杂度</h4><p>我们的倒数第二个常见时间复杂度是指数复杂度，即随着输入规模的增加，运行时间将按固定倍数来增长。一个典型的例子是直接计算斐波纳契数列中的第 n 项。</p></li></ol><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long long Feb(int pos)&#123;if(pos &lt;&#x3D; 2)&#123;        return 1;    &#125;        return Feb(pos -1) + Feb(pos - 2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>    在上面的示例中，每当输入 n 增加 1 时，执行的操作数量就会翻倍。这是因为我们没有缓存每个函数调用的结果，所以必须从最开始重新计算所有先前的值。因此，该算法的时间复杂度为 O(2ⁿ)。</code></pre><ol><li><h4 id="O-n-—-阶乘复杂度"><a href="#O-n-—-阶乘复杂度" class="headerlink" title="O(n!) — 阶乘复杂度"></a>O(n!) — 阶乘复杂度</h4><p>最后但同样重要（但肯定是效率最低）的类型是阶乘时间复杂度的算法。通常应避免这中复杂度，因为随着输入规模的增加，它们会很快变得难以运行。这种算法有一个示例，那就是旅行推销员问题的暴力解法。这个问题是希望找到一条最短路径，要求该路径必须访问坐标系中的所有点，并最终回到起点。暴力解法涉及相互比较所有可能的路线（读作：排列组合）并选择最短的。请注意，除非要访问的点数很少，否则这通常不是解决此问题的合理方法。</p><h3 id="简单的计算时间表达式"><a href="#简单的计算时间表达式" class="headerlink" title="简单的计算时间表达式"></a>简单的计算时间表达式</h3><p>​        时间复杂度可以由时间表达式给出。来看一个很简单的小例子：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int getSumCube(int N)&#123;int i, PartialSum;   PartialSum &#x3D; 0;    for(i &#x3D; 1; i &lt;&#x3D; N;i++)&#123;        PartialSum +&#x3D; i*i*i;    &#125;return PartialSum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们扫描了一遍大小为N的数组，于是可以给出这个式子的时间表达式是：</p><script type="math/tex; mode=display">f(N) = 6N + 4</script><p>​        计算时间的一般简单法则：</p><p>1.<code>for</code>循环</p><p>一次 <code>for</code> 循环的时间是for循环的次数乘上for 循环次数</p><p>2.嵌套的<code>for</code>循环</p><p>自内向外的做1 的分析，一般来讲是带有乘上几层for循环的。</p><p>3.顺序语句</p><p>直接求和即可</p><p>4.<code>if/else</code>语句</p><p>不会超过判断时间 + 较长者分支时间。</p></li></ol><h3 id="一些问题导览"><a href="#一些问题导览" class="headerlink" title="一些问题导览"></a>一些问题导览</h3><h4 id="最大的子序数列和问题"><a href="#最大的子序数列和问题" class="headerlink" title="最大的子序数列和问题"></a>最大的子序数列和问题</h4><p>​        问题是这样的：给定整数序列$\{A_i\}$我们需要求出：$\sum_{k = i}^j$作为这数列的一个子数列的和的最大值的问题。</p><p>​        最简单的，我们来回扫描嘛！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int MaxSequenceSum(const int A[],int N)&#123;    int thisSum,Maxsum,i,j,k;    for(i &#x3D; 0; i &lt; N; i++)&#123;        for(j &#x3D; 0; j &lt; N; j++)&#123;            thisSum &#x3D; 0;            for(k &#x3D; 1; k &lt;&#x3D; j; k++)&#123;                ThisSum +&#x3D; A[k];            &#125;                        if(ThisSum &gt; MaxSum)&#123;                MaxSum &#x3D; thisSum;            &#125;        &#125;    &#125;        return MaxSum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是，精确的来讲，我们需要花费的时间表达式是：</p><script type="math/tex; mode=display">\sum_{i = 0}^{N-1}\frac{(N-i-1)(N-i)}{2} = \frac{N^3+3N^2+2N}{6}</script><p>​        但是，这样的算法一旦数据量大起来，就会寄。</p><p>​        那就优化一下！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int MaxSequenceSum(const int A[],int N)&#123;    int thisSum,Maxsum,i,j;    MaxSum &#x3D; 0;    for(i &#x3D; 0; i &lt; N; i++)    &#123;        thisSum &#x3D; 0;        for(j &#x3D; i; j &lt; N; j++)        &#123;            ThisSum +&#x3D; j[k];             if(ThisSum &gt; MaxSum)            &#123;            MaxSum &#x3D; thisSum;            &#125;        &#125;    &#125;        return MaxSum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还有其他方法嘛？有的！</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>（1）原文链接：<a href="https://blog.csdn.net/weixin_44507219/article/details/128245726">https://blog.csdn.net/weixin_44507219/article/details/128245726</a></p><p>​        最大子序列求和是指给定一组序列，求所有连续子序列的和中的最大值，例如给定数列：</p><p>​        [5,-2,-5,6]最大子序列和是6；[1, 2, -3, 4, -5, 6, 7, 8, -9, 10]最大子序列和是22；</p><p>​        下面将利用几种不同的算法来解决此问题，重要的是理解不同算法中所代表的思想</p><p><strong>1、穷举法</strong></p><p>​        穷举法的思想比较简单，它是指列举所有的可能，来得到问题最终的解；</p><p>​        在此问题中，可以利用穷举法将所有的子序列的和计算出来，来得到最大子序列的和；</p><p>​        假设子序列的起点为i，那么i的范围在数组下标中可以是:[0,arrays.length-1]；</p><p>​        针对起点为i的子序列，由于子序列是连续的，那么它的终点的范围是[i,arrays.length-1]；</p><p>​        最后我们需要对[i,j]的子序列进行求和，并把结果每次与max比较，以此得到最大子序列和max；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//穷举法，时间复杂度为O(N^3)</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">method_1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrays<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//每个子序列的起点 = i</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrays<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//每个子序列的终点 = j</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arrays<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">//子序列求和</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                sum <span class="token operator">=</span> sum <span class="token operator">+</span> arrays<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">//当出现子序列和大于max，用sum替换掉max</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                max <span class="token operator">=</span> sum<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、穷举优化</p><p>​        显然，上面算法的时间复杂度O(N^3)并不能让人满意，不过我们可以简单优化一下：</p><p>​        列举所有的子序列[i,j]依然不变，但是针对子序列[i,j]求和，我们完全可以省略这一步，当固定起点i时，以i为起点的子序列的终点j的范围[i,arrays.length-1]是连续的，可以发现，j=i+1为子序列的终点时，它的和为：</p><pre><code>    SUM(i,j)=SUM(i,i+1)=SUM(i,i)+arrays[i+1]；</code></pre><p>​        同理，j=i+2时：</p><pre><code>    SUM(i,j)=SUM(i,i+2)=SUM(i,i+1)+arrays[i+2]</code></pre><p>……</p><p>​        也就是说，我们可以把上一次子序列的求和保存起来，留待下次j递增(j++)后使用，即不用针对每次子序列[i,j]，去重新计算它的和，在代码里，只需要把对sum的初始化int sum = 0 提到上一层循环里就可以了，并去掉重复计算的for循环就可以了，此方法的时间复杂度为O(N^2)</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;穷举优化:时间复杂度为O(N^2)public static int method_2(int[] arrays) &#123;    int max &#x3D; 0;    &#x2F;&#x2F;每个子序列的起点 &#x3D; i    for (int i &#x3D; 0; i &lt; arrays.length; i++) &#123;        int sum &#x3D; 0;        &#x2F;&#x2F;每个子序列的终点 &#x3D; j        for (int j &#x3D; i; j &lt; arrays.length; j++) &#123;            sum &#x3D; sum + arrays[j];            &#x2F;&#x2F;当出现子序列和大于max，用sum替换掉max            if (sum &gt; max) &#123;                max &#x3D; sum;            &#125;        &#125;    &#125;    return max;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这里稍微有点动态规划的思想，但并不完全，下面我们将介绍基于动态规划的思想的Kadane算法对此问题的解法思路</p><p>3、Kadane算法-动态规划</p><p>​        穷举法是针对具体的子序列[i,j]去求解，虽然做了优化减少了重复计算，但依然需要比较高的时间复杂度。</p><p>​    最大子序列和的最终答案是值，而不用去求具体的子序列，所以这里我们可以巧妙的运用动态规划的思想来解决，动态规划的核心思想是：拆分成若干子问题，记住过往，减少重复计算。</p><p>​    假设我们求长度为N的序列的最大子序列和，可以拆分成N个子问题来计算，假设此数组序列下标是i，那么这N个子问题分别是：i=[0]、i=[0,1]、i=[0,1,2]、……、i=[0,1,2,…,N-1]的子序列的最大子序列和，我们这里可以不用逆推，直接采用顺推的方式来实现。</p><p>​    我们可以根据i=[0]的子序列的结果，去推算i=[0,1]的结果，然后用i=[0,1]的子序列的结果去推算i=[0,1,2]的结果，以此类推，最终推算出i=[0,1,2,…,N-1]的结果；</p><p>​    然而值得我们注意的是，我们需要知道使用前一个子问题去推算后一个子问题，它们之间的连接关系：</p><pre><code>        当 i(k)=[0,1,2,3,...k] --&gt; i(k+1)=[0,1,2,3,...k,k+1],即用i(k)结果去推算i(k+1)的结果的时候：</code></pre><p>​    我们定义两个变量max，sum；max(k)代表i(k)的结果(即最大子序列和)，sum(k)代表</p><p>i(k)序列的累加，（max ≠ sum）；</p><p>​            sum(k+1) = sum(k) + arrays[k+1]</p><p>​            当sum(k+1) &gt; max(k) 时，则 max(k+1) = sum(k+1)</p><p>​            否则max(k+1)=max(k)；</p><p>​            要使上述成立我们必须所做的一个操作是，当sum &lt; 0时，需要把sum = 0（结合下面i = 4/5时更容易理解）</p><p>例如对于数组[1, 2, -3, 4, -5, 6, 7, 8, -9, 10]，</p><div class="table-container"><table><thead><tr><th>Arrays    1    2    -3    4    -5    6    7    8    -9    10</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>i(下标)    0    1      2    3    4    5    6     7      8    9</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>​        当遍历到：</p><pre><code>    i=0时：            sum=1  ----&gt; sum&gt;max ----&gt; max = 0 ： 序列[1]的最大子序列和为 1    i=1时：            sum = 3 ----&gt; sum&gt;max ----&gt; max = 3 ： 序列[1,2]的最大子序列和为3    i=2时：            sum=0 ----&gt; sum&lt;max ----&gt; max = 3 ： 序列[1,2,-3]的最大子序列和为3    i=3时：            sum=4 ----&gt; sum&gt;max ----&gt; max = 4 ： 代表序列[1,2,-3,4]的最大子序列和为4</code></pre><p>​        （注意：此时的和为最大的值的子序列有两个[1,2,-3,4]，[4]，但我们并不在意，我们需要在意的是状态(sum是否小于0)以及max(sum是否大于max),sum如果一直没有小于0,那么sum的值对于后面的累加都是有效的增大，而sum只要一小于0，我们需要把sum=0，它才不影响后面最大值的累加。强调一下：我们只关注当前所遍历过的这整个一块的最大子序列的和max以及sum值的状态）</p><pre><code>    i=4时：            sum=-1 ----&gt; sum&lt;max ----&gt; max = 4 ----&gt;sum=0：序列[1,2,-3,4,-5]的最大子序列和为4    i=5时：            sum=6 ----&gt; sum&gt;max ----&gt; max = 6 ： 序列[1,2,-3,4,-5,6]的最大子序列和为6    ......    i=8时：            sum=6+7+8-9 ----&gt; sum&lt;max(6+7+8) ----&gt; max=21 : 序列[1, 2, -3, 4, -5, 6, 7, 8, -9]的最大子序列和为21    i=9时：            sum=6+7+8-9+10=22 ----&gt; sum &gt; max ----&gt; max = 22 ：序列[1, 2, -3, 4, -5, 6, 7, 8, -9, 10]的最大子序列和为22。</code></pre><p>​        可以清晰的看到，我们只需要一次遍历，就可以得到最终的解，时间复杂度为O(N);</p><p>代码如下：               </p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;动态规划，时间复杂度O(N)public static int method_3(int[] arrays) &#123;    int max &#x3D; 0;    int sum &#x3D; 0;    for (int i &#x3D; 0; i &lt; arrays.length; i++) &#123;            sum &#x3D; sum + arrays[i];            if (sum &gt; max) &#123;                max &#x3D; sum;            &#125;else if(sum &lt; 0)&#123;                sum &#x3D; 0;            &#125;    &#125;    return max;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、分治策略</p><p>​        分治策略的核心思想为：分而治之。</p><p>​        它跟动态规划相同点：都是将问题分成若干个子问题。</p><p>​        不同点：动态规划的场景一般为：每个子问题与前后都是有联系的，以1推2，以2推3，依次推到最终结果；而分治策略的场景一般为：先独立的计算出每个子问题的结果，再合并结果得到最终结果。</p><p>左半部分                  起点                    右半部分<br>1    2    -3    4    -5    6    7    8    -9    10<br>        在此问题中，我们也同样可以使用分治策略来解决：我们很容易知道最大子序列和可能在三处出现，如：</p><p>​    A、左半部分：</p><p>​    B、右半部分：</p><p>​    C、中间部分（左右都占）：</p><p>​    AB两种情况我们可以通过递归求解；C情况我们可以算出以左半部分的起点向左依次遍历的最大和值，以右半部分的起点向右依次遍历得出的最大和值，两者相加；最终我们比较ABC三者的最大值，即可返回最终结果。</p><p>​    此种方法的时间复杂度为O(N*logN)，想比较动态规划而言，它有些地方重复计算了，但是如果将问题转换为求最大子序列的起点跟终点，动态规划或许不太适用了。</p><p>​                </p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;分治策略，时间复杂度为O(N*logN)public static int method_4(int[] arrays,int left,int right) &#123;    &#x2F;&#x2F;基准情况    if(left &#x3D;&#x3D; right)&#123;        if(arrays[left] &gt; 0)&#123;            return arrays[left];        &#125;else&#123;            return 0;        &#125;    &#125;     int center &#x3D; (left+right)&#x2F;2;    &#x2F;&#x2F;递归求左半部分(A情况)    int maxLeft &#x3D; method_4(arrays,left,center);    &#x2F;&#x2F;递归求右半部分(B情况)    int maxRight &#x3D; method_4(arrays,center+1,right);        &#x2F;&#x2F;求C情况的以左半部分起点向左遍历的最大值    int maxLeftBorder &#x3D; 0;    int sumLeftBorder &#x3D; 0;    for(int i &#x3D; center;i&gt;&#x3D;left;i--)&#123;        sumLeftBorder &#x3D; sumLeftBorder+arrays[i];        if(sumLeftBorder&gt;maxLeftBorder)&#123;            maxLeftBorder &#x3D; sumLeftBorder;        &#125;    &#125;        &#x2F;&#x2F;求C情况的以右半部分起点向右遍历的最大值    int maxRightBorder &#x3D; 0;    int sumRightBorder &#x3D; 0;    for(int i &#x3D; center+1;i&lt;&#x3D;right;i++)&#123;        sumRightBorder &#x3D; sumRightBorder+arrays[i];        if(sumRightBorder&gt;maxRightBorder)&#123;            maxRightBorder &#x3D; sumRightBorder;        &#125;    &#125;    &#x2F;&#x2F;返回 maxLeft 、maxRight、maxLeftBorder+maxRightBorder中的最大值    int temp &#x3D; Math.max(maxLeft, maxRight);    return Math.max(temp,maxLeftBorder+maxRightBorder);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt &amp;&amp; Opencv Config</title>
      <link href="/2023/06/01/Qt-Opencv-Config/"/>
      <url>/2023/06/01/Qt-Opencv-Config/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Qt-opencv各平台编译方法的水博客1（代价是搞了N久）"><a href="#关于Qt-opencv各平台编译方法的水博客1（代价是搞了N久）" class="headerlink" title="关于Qt + opencv各平台编译方法的水博客1（代价是搞了N久）"></a>关于Qt + opencv各平台编译方法的水博客1（代价是搞了N久）</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​        正确选择模块的版本是必要的                                        ——爹的 instruction</p><p>​        首先，如果你是一个构件库者，哥们建议你仔细看看这帮写博客的人他们构建配置的版本是多少！防止坑上加坑，导致人寄上加寄！</p><p>​        下面，我将介绍一下简单的 Windows11/Linux-Ubuntu20.04 Qt5.12.8/Qt6.6.0 + Opencv 4.6.0/Opencv 4.5.3， 如果你是想在自己的电脑上搭建上述系统，烦请按照我下面给出的若干的reference version, 否则在编译，安装，运行，到最后的打包出了问题。。。很正常就会，以及，以及</p><p><strong>注意到本博客尚未解决：基于Windows11下如此操作方法qt6.6.0 + mingw_64bits打包程序的可移植性的问题，具体表现为于纯净Win10下爆出 RunTimeError - Unknown Terminate 以及Windows11下程序双击无反应的问题</strong></p><p>​        成功解决的是下面的，全流程简单的概括为👇</p><h2 id="Windows11-Qt-5-12-8-Opencv4-5-3"><a href="#Windows11-Qt-5-12-8-Opencv4-5-3" class="headerlink" title="Windows11 + Qt 5.12.8 + Opencv4.5.3"></a>Windows11 + Qt 5.12.8 + Opencv4.5.3</h2><p>​        首先，我们需要的是获取上面我提到的资源。</p><p>​        如果打算配置的是6.6.0，Cmake可以不用下，qt有自己自带的Cmake-gui，但是低版本的不自带Cmake-gui，需要自己来下载。</p><p>​        Qt 5.12.8可以通过点击这里获取：<a href="https://download.qt.io/new_archive/qt/5.12/5.12.8/qt-opensource-windows-x86-5.12.8.exe">qt-opensource-windows-x86-5.12.8.exe</a></p><p>​        或者，你想要浏览其他的版本，看这里：<a href="https://download.qt.io/new_archive/qt/">Index of /new_archive/qt</a></p><p>​        至于 opencv，这里给出传送门：</p><p>​        opencv:<a href="https://opencv.org/releases/">Releases - OpenCV</a>，对了，有人有疑问：我是该安装Source版本的还是Windows版本的呢？都一样，前者直接得到压缩包，后者是一个解压程序。基本一致的！结合自身的需求来！</p><p>​        opencv_contrib :  这个用户贡献的contribution的子模块，是需要到 github那里去下载的！注意到这里给出的是 opencv_contrib 4.x 的教程。读者可以自行尝试opencv_contrib 5.x的联合编译。<a href="https://github.com/opencv/opencv_contrib/tree/4.x（不过，不建议编译这个，我自己尝试过在后续的编译中这个会爆炸（爆一大堆错误））">https://github.com/opencv/opencv_contrib/tree/4.x（不过，不建议编译这个，我自己尝试过在后续的编译中这个会爆炸（爆一大堆错误））</a></p><p>​        我们下载好了之后。得到的是若干的压缩包和一个QT安装的SDK。</p><h3 id="安装QT"><a href="#安装QT" class="headerlink" title="安装QT"></a>安装QT</h3><p>​        原则上讲，这个版本的QT不使用线上安装，意味之我们不需要配置Qt tempory repository.注意到如果你先前有一个qt账号，登陆即可，反之，注册一个！直接选择对应的编译包和SDK包就可以了。为了联合演示 mingw_32, mingw_64, MSVC2017_32,MSVC_64编译器下的编译行为，这里我就都下载了，以及，在Tools选择上也都选择了MSVC编译器和mingw编译器（tnnd,13.8G）。Qt作为桌面开发的经典工具，安装也是press几个按钮的事情。这里就不细说说明了。</p><h3 id="安装opencv"><a href="#安装opencv" class="headerlink" title="安装opencv"></a>安装opencv</h3><p>​        解压就完事了！</p><h3 id="开始联合编译Qt-opencv"><a href="#开始联合编译Qt-opencv" class="headerlink" title="开始联合编译Qt + opencv"></a>开始联合编译Qt + opencv</h3><p>​        我们将opencv得到的资源，分别置于一个空间比较大的地方。比如说我的D盘（）。</p><p>​        专门建立一个文件夹，叫：</p><pre class="line-numbers language-none"><code class="language-none">Qt5_12_Opencv453Compile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在底下，再建立三个文件夹！</p><p><img src="image-20230602103923847.png" alt="image-20230602103923847"></p><p><img src="image-20230602103930586.png" alt="image-20230602103930586"></p><p>​        如上图所示。也就是：</p><pre class="line-numbers language-none"><code class="language-none">opencv_buildopencv_contribopencv_source<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我想，你从名字就知道了——<code>opencv_source</code>装源码，把<code>Opencv4.5.3</code>的源码内容放到这里, <code>opencv_contrib</code> 装用户贡献模块，把contrib的所有内容放到这里，而<code>opencv_build</code>,任何一个熟知Cmake编译的人都知道装编译的结果的。</p><p>​        现在，打开你的Cmake-gui</p><p>​    <img src="image-20230602121940454.png" alt="image-20230602121940454"></p><p>​        你的<code>Where is the source code</code>和<code>where to build the binaries</code>，如果先前没有用过会是空的！source code自然在<code>opencv_source</code>下，build产生的文件放到<code>opencv_build</code>下，就像这样一样。</p><p>​        点击Advanced 和 Grouped,防止自己老花眼找半天的Cmake变量。点击Configure</p><p><img src="image-20230602122308408.png" alt="image-20230602122308408"></p><p>​        默认下，这里是没有编译器的，现在，选择Specify native Compliers（指定本地编译器），点击之</p><p><img src="image-20230602122412384.png" alt="image-20230602122412384"></p><p>​        下拉找到<code>Mingw Makefiles</code>，这就是我们想要的编译器了！</p><p>​        Config结束后，点击Next.</p><p>​        指定好自己C,C++语言的编译器位置，他们在自己QT安装的文件下的。</p><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\Tools\mingw730_64\bin\gcc.exe &#x2F;&#x2F; for C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\Tools\mingw730_64\bin\g++.exe &#x2F;&#x2F; for C++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230602122748504.png" alt="image-20230602122748504"></p><p>​        可以看到正在配置了。</p><p>​        同时，记得添加编译器到环境变量！</p><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\5.12.8\mingw73_64\bin;D:\QT\Qt5.12.12\Tools\mingw730_64;D:\QT\Qt5.12.8\Tools\mingw730_64\x86_64-w64-mingw32\bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        他们稍后是为了使系统可以找到Qt库来运行Qt的！</p><p>​        待到你添加完毕之后，现在，回到Cmake界面是满山红</p><p><img src="image-20230602123431972.png" alt="image-20230602123431972"></p><p>​        下面开始配置选项</p><p>​        1. 打开with_OpenGL 和 With_Qt,他们在WITH group下面</p><p>​        2. 配置好contrib模块，就是在Opencv Group下，找到这样的一个变量     OPENCV_EXTRA_MODOLES_PATH</p><p>​        给他写上：</p><pre class="line-numbers language-none"><code class="language-none">D:\QT5_12_Opencv453Compile\opencv_contrib\modules<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        呐！就是我们存放<code>contrib</code>模块下面的<code>modules</code>模块，注意。</p><p>​        再次重新配置：点击Configure</p><p>​        正常来讲，再次编译过后，是不会有红色出现的！但是我这里还是红色出现了！</p><p>​        是Qt5的库路径不知道。给我默认到自己的Anaconda的库里去了。自己手动修改一下，同时，留意一下正斜杠与反斜杠的区别（fuck Windows）</p><p><img src="image-20230602124437202.png" alt="image-20230602124437202"></p><p>​        _这里是为了测试mingw32编译才选择的32编译器_（WRANING!后续的编译中尝试过了！不建议选择这个，64位的系统就选择mingw64!）如果你不想打包库的话，可以选择64位编译器。</p><p>​        以及我看到有教程建议在Opencv的变量中只勾选opencv_world. 这是把若干的库编译成一个，显得笨重！这里就不这样做了！</p><p>​        点击Config</p><p><img src="image-20230602124653801.png" alt="image-20230602124653801"></p><p>​        (留心一下产生的清单里有没有都配置成为你想要的环境，确定了再点击！)</p><p>​        再点击Generate生成可以用的MakeFile.</p><h3 id="PowerShell启用mingw32编译源代码"><a href="#PowerShell启用mingw32编译源代码" class="headerlink" title="PowerShell启用mingw32编译源代码"></a>PowerShell启用mingw32编译源代码</h3><p><img src="image-20230602124918062.png" alt="image-20230602124918062"></p><pre class="line-numbers language-none"><code class="language-none">mingw32-make -j 8 &#x2F;&#x2F; 8 is then_recommend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        后来还是调成8了，因为有一定概率产生多线程编译错误导致编译中止！</p><p>​        CD到自己的Build文件下，敲这个指令！（哈哈，其实是让他所有的CPU资源来调动编译之，可不想等1个小时）</p><p><img src="image-20230602125026896.png" alt="image-20230602125026896"></p><p>​        一敲击回车，程序开始快速的编译。泡杯咖啡休息一下把。</p><p>​        中间可能存在跑错！注意！明确选择的编译器是64位！同时，注意反复确认引入的Cmake选项指向的环境是你想要的那个（错一点都不行！）</p><p>​        _不！要！mingw编译器 停止编译了还要继续继续在原文件夹下再输mingw32-make_了，否则可能会跳过一些库的生成！导致后面程序应用后异常崩溃！</p><pre class="line-numbers language-none"><code class="language-none">mingw32-make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        下载好刚刚那些库！</p><p><img src="image-20230602135455371.png" alt="image-20230602135455371"></p><p>​        现在，我们下载好的库，就在</p><p><img src="image-20230602135533374.png" alt="image-20230602135533374"></p><p>以及opencv可用的文件在：</p><p><img src="image-20230602135559565.png" alt="image-20230602135559565"></p><p>​        打开QT，整一个MainWindow工程。</p><p>​        现在开始检验你配置的是否成功了！（大喜）</p><p>​        在PRO工程文件下，添加</p><pre class="line-numbers language-none"><code class="language-none">INCLUDEPATH +&#x3D; D:\QT5_12_Opencv453Compile\opencv_build\install\includeLIBS +&#x3D; D:\QT5_12_Opencv453Compile\opencv_build\install\x64\mingw\bin\libopencv_*.dll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <strong>然！后！Ctrl+S重载一下工程，否则下面别让自己白忙活！</strong></p><p>​        尝试一下，在MainWindow.cpp下整点：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;opencv2&#x2F;opencv.hpp&gt; &#x2F;&#x2F; 关键时刻！#include&lt;QDebug&gt;using namespace cv;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    Mat img &#x3D; imread(&quot;D:\\QT projects\\5128opencv\\1.png&quot;);&#x2F;&#x2F;嘿！这个别照搬地址！哥们找自己的一张图片扔进来它的地址！    if(img.empty())&#123;       qDebug() &lt;&lt; &quot;Error in loading picture&quot;;    &#125;    namedWindow(&quot;Display window&quot;, WINDOW_AUTOSIZE );    imshow(&quot;Display window&quot;,img);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        好了，如果，我说如果，没有什么问题，那恭喜可以开摆了。。。</p><p>​        但是如果没有呢？</p><p>​        0. Can not find opencv2/opencv.hpp: 好好看看你有没有Ctrl + S你的工程</p><p>​        1.Unrecognize File Format</p><p>​        当你运行上面的代码在QConsole上扔出了这个错误的时候，注意选好你的编译器套餐！留意到你用了什么编译器编译的opencv+QT，就使用哪款编译器！</p><pre><code>    2. ​        程序异常结束</code></pre><p>​        哥们太倒霉了！程序不认识库！也就是说，他没办法按照你给的路径去寻找库，一个一点都不优雅的方法，就是把 自己编译产生的库，在install/x64/bin下的库，原封不动的扔到自己的debug或者是release文件夹下，让G++/GCC编译的时候直接在本地工作文件夹下找到库从而避免一场结束！（Windows的这个屏蔽了过多的细节，没办法）</p><p><img src="image-20230602141655611.png" alt="image-20230602141655611"></p><p>​        这是成功的界面！</p><h3 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h3><p>​        成功了！后面经过调试，成功将这一个环境的qt+ opencv程序应用到了各台电脑上！（不用下载几百MB的库力，喜）</p><p>​        首先，转到自己同名目录下的：</p><pre><code>     很抽象的一个：》</code></pre><pre class="line-numbers language-none"><code class="language-none">D:\QT projects\build-5128opencv-Desktop_Qt_5_12_8_MinGW_64_bit-Release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        将这个目录下的可执行文件拿出来，和这下面的一大堆库一起</p><p><img src="image-20230602143253394.png" alt="image-20230602143253394"></p><p>​        和</p><p><img src="image-20230602143320878.png" alt="image-20230602143320878"></p><p>​        把他们拎出来：</p><p>​        扔到一个建议是<strong>全程不带一点中文名的路径（for example:你的D盘）</strong>，把我说的那一大坨东西，扔到一个新建的文件夹下。</p><p>​        现在，<strong>在应用搜索处，搜索你构建的编译器</strong>，比如说根据这个名字：</p><pre class="line-numbers language-none"><code class="language-none">build-5128opencv-Desktop_Qt_5_12_8_MinGW_64_bit-Release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我应当选择</p><pre class="line-numbers language-none"><code class="language-none">Qt5.12.8 Mingw64bits<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后选择之运行：</p><p><img src="image-20230602144243995.png" alt="image-20230602144243995"></p><p>​        cd 到自己的构建文件夹下</p><pre class="line-numbers language-none"><code class="language-none">windeployqt yourFileName.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后就会给你配置一些库了！</p><p><img src="image-20230602144734439.png" alt="image-20230602144734439"></p><p>​        点击一下</p><p>​        Error 1： 少库了！</p><p>​        总而言之就是少库了！别慌别慌，补一下就好啦！</p><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\5.12.8\mingw73_64\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        找到自己安装QT下的这种文件夹，找到缺什么库就直接Copy即可。</p><p>​        Error 2: Terminate by unknown Error</p><p>​        反正就是扔给你这个未知的错误，本质上来讲就是少库（对可执行文件而言），可能是没有在全英文路径下打包造成。</p><p>​        Error 3：EXE文件在装死</p><p>​        嘛，说白了还是少库，有人急了（是我/(ㄒoㄒ)/~~）咋还少库啊，事实上是：库签名对不上，使用的mingw编译器下的windeployqt没有给你正确的打包！可能还是：没有在全英文路径下打包造成。实在不行库全删了，缺啥补啥！</p><p>​        Anyway，忙活了两天的(大致回忆了一下是块30多个小时处理之)配置这里说完了，下一篇博客我介绍一下<code>Linux + qt5.12.8 + opencv 4.5.3</code>的配置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>High Quality of C_Cpp programming in formats(1)</title>
      <link href="/2023/04/17/High-Quality-of-C-Cpp-programming-in-formats-1/"/>
      <url>/2023/04/17/High-Quality-of-C-Cpp-programming-in-formats-1/</url>
      
        <content type="html"><![CDATA[<h1 id="高质量的C-C-规程规范"><a href="#高质量的C-C-规程规范" class="headerlink" title="高质量的C/C++规程规范"></a>高质量的C/C++规程规范</h1><h2 id="笔记篇"><a href="#笔记篇" class="headerlink" title="笔记篇"></a>笔记篇</h2><p>​        每个C++/C 程序通常分为两个文件。一个文件用于保存程序的声明（declaration），这被称之为头文件，另一个文件用于保存程序的实现，这是被称之为定义文件。</p><p>​        为此，我们选择了使用后缀来作为文件的区分。在C/C++中，我们选择使用.h/.hpp来作为头文件，而.c文件是C语言源文件，.cpp是C++源文件.</p><p>​        下面是头文件的开门格式</p><h2 id="头文件的结构"><a href="#头文件的结构" class="headerlink" title="头文件的结构"></a>头文件的结构</h2><p>​        三个基本结构: 开头的的版权和版本声明</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;**Copyright (c) * All rights reserved. * * 文件名称：filename.h * 文件标识：见配置管理计划书 * 摘 要：简要描述本文件的内容 * * 当前版本：1.1 * 作 者：输入作者（或修改者）名字 * 完成日期：2001年7月20日 * * 取代版本：1.0 * 原作者 ：输入原作者（或修改者）名字 * 完成日期：2001年5月10日*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        预处理块。</p><pre class="line-numbers language-none"><code class="language-none">#define ...#ifdef ...#ifndef ...#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        函数和类结构声明等。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Some announcements hear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假设头文件名称为 graphics.h，头文件的结构参见示例 1-2。 </p><p><strong>【规则 1-2-1</strong>】为了防止头文件被重复引用，应当用ifndef/define/endif 结构产生预</p><p>处理块。</p><p><strong>【规则 1-2-2</strong>】用 #include <filename.h> 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。</p><p><strong>【规则 1-2-3</strong>】用 #include “filename.h” 格式来引用非标准库的头文件（编译器将</p><p>从用户的工作目录开始搜索）。</p><p><strong>【建议 1-2-1</strong>】头文件中只存放“声明”而不存放“定义”<br>        在 C++ 语法中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。这虽然会带来书写上的方便，但却造成了风格不一致，弊大于利。建议将成员函数的定义与声明分开，不论该函数体有多么小。<br><strong>【建议 1-2-2】</strong>不提倡使用全局变量，尽量不要在头文件中出现象 extern int value 这<br>类声明。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 版权和版本声明见示例 1-1，此处省略。</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">GRAPHICS_H </span><span class="token comment">// 防止 graphics.h 被重复引用 </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GRAPHICS_H</span> </span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span> <span class="token comment">// 引用标准库的头文件 </span></span>…<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token expression">“myheader<span class="token punctuation">.</span>h” </span><span class="token comment">// 引用非标准库的头文件 </span></span>… <span class="token keyword">void</span> <span class="token function">Function1</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 全局函数声明 </span>… <span class="token keyword">class</span> <span class="token class-name">Box</span> <span class="token comment">// 类结构声明 </span><span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        早期的编程语言如 Basic、Fortran 没有头文件的概念，C++/C 语言的初学者虽然会<br>用使用头文件，但常常不明其理。这里对头文件的作用略作解释：<br>​        （1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。<br>​        （2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担</p><p>​        在目录结构上:如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。<br>例如可将头文件保存于 include 目录，将定义文件保存于 source 目录（可以是多级<br>目录）。<br>​        如果某些头文件是私有的，它不会被用户的程序直接引用，则没有必要公开其“声<br>明”。为了加强信息隐藏，这些私有的头文件可以和定义文件存放于同一个目录</p><h2 id="尽可能良好的书写程序"><a href="#尽可能良好的书写程序" class="headerlink" title="尽可能良好的书写程序"></a>尽可能良好的书写程序</h2><p>​        空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。空行不会浪费内存，虽然打印含有空行的程序是会多消耗一些纸张，但是值得。所以不要舍不得用空行。</p><p><img src="image-20230417143154203.png" alt="image-20230417143154203"></p><p>​        于是可以看到,在程序的逻辑模块之间, 我们采用空格来表明逻辑的独立性</p><p>【规则 2-2-1】一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样<br>的代码容易阅读，并且方便于写注释。<br>【规则 2-2-2】if、for、while、do 等语句自占一行，执行语句不得紧跟其后。不论<br>执行语句有多少都要加{}。这样可以防止书写失误。</p><p>【建议 2-2-1】尽可能在定义变量的同时初始化该变量（就近原则）<br>如果变量的引用处和其定义处相隔比较远，变量的初始化很容易被忘记。如果引用<br>了未被初始化的变量，可能会导致程序错误。</p><p>2.3 代码行内的空格</p><p>【规则 2-3-1】关键字之后要留空格。象 const、virtual、inline、case 等关键字之<br>后至少要留一个空格，否则无法辨析关键字。象 if、for、while 等关键字之后应留<br>一个空格再跟左括号‘（’，以突出关键字。</p><p>【规则 2-3-2】函数名之后不要留空格，紧跟左括号‘（’，以与关键字区别。</p><p>【规则 2-3-3】‘（’向后紧跟，‘）’、‘，’、‘;’向前紧跟，紧跟处不留空格。</p><p>【规则 2-3-4】‘，’之后要留空格，如 Function(x, y, z)。如果‘;’不是一行的结束<br>符号，其后要留空格，如 for (initialization; condition; update)。</p><p>【规则 2-3-5】赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，<br>如“=”、“+=” “&gt;=”、“&lt;=”、“+”、“*”、“%”、“&amp;&amp;”、“||”、“&lt;&lt;”,“^”等二<br>元操作符的前后应当加空格。</p><p>【规则 2-3-6】一元操作符如“!”、“~”、“++”、“—”、“&amp;”（地址运算符）等前后不<br>加空格。</p><p>【规则 2-3-7】象“［］”、“.”、“-&gt;”这类操作符前后不加空格。</p><p>【建议 2-3-1】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去<br>掉一些空格，如 for (i=0; i&lt;10; i++)和 if ((a&lt;=b) &amp;&amp; (c&lt;=d))</p><p><img src="image-20230417144044784.png" alt="image-20230417144044784"></p><p>对齐</p><p>​        【规则 2-4-1】程序的分界符‘{’和‘}’应独占一行并且位于同一列，同时与引用<br>它们的语句左对齐。</p><p>​        【规则 2-4-2】{ }之内的代码块在‘{’右边数格处左对齐。</p><p>长行的拆分</p><p>​    【规则 2-5-1】代码行最大长度宜控制在 70 至 80 个字符以内。代码行不要过长，否则眼睛看不过来，也不便于打印。<br>​    【规则 2-5-2】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读</p><p><img src="image-20230417144342762.png" alt="image-20230417144342762"></p><p>​        修饰符 <em> 和 ＆ 应该靠近数据类型还是该靠近变量名，是个有争议的活题。<br>​        若将修饰符 </em> 靠近数据类型，例如：int<em> x; 从语义上讲此写法比较直观，即 x<br>是 int 类型的指针 ,上述写法的弊端是容易引起误解，例如：int</em> x, y; 此处 y 容易被误解为指针变量。虽然将 x 和 y 分行定义可以避免误解，但并不是人人都愿意这样做。<br>​    【规则 2-6-1】应当将修饰符 <em> 和 ＆ 紧靠变量名<br>​        例如：<br>​        char </em>name;<br>         int *x, y; // 此处 y 不会被误s解为指针！</p><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnLinuxBasicNote</title>
      <link href="/2023/04/16/LearnLinuxBasicNote/"/>
      <url>/2023/04/16/LearnLinuxBasicNote/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p>​        首先计算机由硬件和软件组成，这是大家都知道的。硬件，就是你看到到的实体。至于软件，就是用户和计算机硬件之间的接口和桥梁。我们这次的主题：操作系统，就是软件！他是用户和计算机硬件之间的桥梁，调度和管理计算机硬件进行工作。</p><p>​        当代计算机不能失去计算机，就像西方不能失去耶路撒冷一样（）</p><p><img src="image-20230411185638955.png" alt="image-20230411185638955"></p><p>​        操作系统可以：调度CPU和内存进行工作，使用硬盘来进行数据存储，来使用网卡进行网络通讯，调用音响发出声音，调用打印机打印东西等等。</p><p>​        这是一个操作系统调用网卡的过程：</p><p><img src="image-20230411190152332.png" alt="image-20230411190152332"></p><p>​        常见的操作系统有：Windows 11 ， Linux， macOS（PC操作系统）和android, IOS Harmony OS等等是移动端操作系统了。</p><h2 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h2><p>​        1991年，Linux从一个佬那里诞生，并且逐渐被世界所接受。</p><p>​        Linux由Linux系统内核和系统级应用程序组成。</p><p>​        内核提供系统最核心的功能：比如说：调度CPU，调度缓存，调度文件系统，调度网络通信，调度IO等。</p><p>​        系统应用：比如说图片查看等等</p><p>​        </p><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>​        Linux的目录结构是一个树形的结构，Linux不同于Windows，他只有一个根目录/，所有的文件都在它的下面</p><p><img src="image-20230411195709234.png" alt="image-20230411195709234"></p><p>​        首先，我们这个是在阐述文件路径的层级关系，打开你的Windows cmd (Win + R + Enter) ，发现这个：</p><p><img src="image-20230411195944592.png" alt="image-20230411195944592"></p><p>​        如果我们到Linux底下（不管是CentOS 还是 Ubuntu）都是 / 的</p><p><img src="image-20230411200155312.png" alt="image-20230411200155312"></p><p>​    （以Ubuntu 20.04作为示例）</p><p>​        于是，想要在文件中找到一个目标文件，在Windows中，我们已经很熟悉了：</p><pre class="line-numbers language-none"><code class="language-none">D:\data\work\hello.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在Linux下就是</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;usr&#x2F;local&#x2F;hello.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意到<strong>Linux中，/出现在开头：根目录，/出现在中间：层次关系</strong></p><h2 id="第一个Linux命令：ls"><a href="#第一个Linux命令：ls" class="headerlink" title="第一个Linux命令：ls"></a>第一个Linux命令：ls</h2><p>​        先停！搞清楚什么是命令很重要：他是Linux的 Terminal，下命令提示符页面我们单纯的使用’字符’来操作系统，也就是使用各种字符指令来对系统发出操作指令。</p><p>​        而命令，本质上还是一个程序，只是没有图形化的相关界面。其反馈又以字符串的形式返回来。</p><p><img src="image-20230414222522060.png" alt="image-20230414222522060"></p><p>​        比如说在CentOS下，我们敲入字符ls 发现返回了东西。就是说明 ls 是程序，而下面的结果就是字符形式的返回</p><p>​        在Linux,命令具有相同的通用格式！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token punctuation">[</span>-options<span class="token punctuation">]</span> <span class="token punctuation">[</span>parameters<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        command 即是命令本身，</p><p>​        （选填）而 -options 就是 控制行为的一些具体的设置细节</p><p>​        （选填）parameter 就是命令之下的参数</p><p>​        举个例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span> /home<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        ls 就是命令， -l 就是选项，表明如何执行这样的命令，/home表示参数。于是这条指令正是： 查看home文件夹下的内容，其显示方式使用列表</p><p><img src="image-20230414224112645.png" alt="image-20230414224112645"></p><p>​        现在主要看 ls ，他的格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token punctuation">[</span>-a <span class="token parameter variable">-l</span> -h<span class="token punctuation">]</span> <span class="token punctuation">[</span>/Linux/Path<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        直接使用ls 表明直接通过平铺的方式展示这一目录下的工作内容</p><p><img src="image-20230414224455558.png" alt="image-20230414224455558"></p><p><img src="image-20230414224618031.png" alt="image-20230414224618031"></p><p>​        还就是桌面上那个home文件夹的内容！于是 ls 就是等同于我们来看当前文件夹下的东西。</p><h2 id="什么是工作目录"><a href="#什么是工作目录" class="headerlink" title="什么是工作目录"></a>什么是工作目录</h2><p>​        当我们启动命令行时，默认我们的 home下的用户名为名称的目录正是工作目录：也就是我们准备执行若干操作的当下目录</p><p><img src="image-20230414225017894.png" alt="image-20230414225017894"></p><p><img src="image-20230414225600771.png" alt="image-20230414225600771"></p><h2 id="ls-参数详解"><a href="#ls-参数详解" class="headerlink" title="ls 参数详解"></a>ls 参数详解</h2><p>​        -a : all 的意思。于是。。。</p><p><img src="image-20230414231338693.png" alt="image-20230414231338693"></p><p>​        在 .Name 之类的就是Linux下的隐藏文件。总而言之，-a 就是展示所有的文件，包括那些被隐藏的文件</p><p>​        而在-l 下，就是以列表的方式展示我们的文件是怎样的。</p><p><img src="image-20230414232357814.png" alt="image-20230414232357814"></p><p>​        那如果我想： 既想展示所有的隐藏文件，又想用列表的方式展示，那就是可以有下面三种方式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token parameter variable">-a</span> <span class="token function">ls</span> <span class="token parameter variable">-la</span><span class="token function">ls</span> <span class="token parameter variable">-al</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230414232421335.png" alt="image-20230414232421335"></p><p><img src="image-20230414232443582.png" alt="image-20230414232443582"></p><p><img src="image-20230414232507927.png" alt="image-20230414232507927"></p><p>​        最后是 -h, 他表示我们以一种方便阅读的方式来列出文件的大小！注意必须和-l 一同使用，否则不会显示相关的效果！ </p><p><img src="image-20230414232733351.png" alt="image-20230414232733351"></p><p>​        可以看到我们更容易阅读文件的大小了</p><h2 id="cd-pwd指令"><a href="#cd-pwd指令" class="headerlink" title="cd  -  pwd指令"></a>cd  -  pwd指令</h2><p>​        使用 cd 命令来切换工作目录（Change Directory）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /Linux/Path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当我们不指定路径时，直接回到home目录</p><p><img src="image-20230415215546677.png" alt="image-20230415215546677"></p><p>​        ls并不是专门打印当下目录的正确指令，至少不恰当！事实上，还是pwd才合适，他就是 print work directory 的缩写</p><p><img src="image-20230415215936705.png" alt="image-20230415215936705"></p><p>​        只需要输入 pwd 就可以查看当下的目录了！·</p><h2 id="相对路径-绝对路径-特殊路径符"><a href="#相对路径-绝对路径-特殊路径符" class="headerlink" title="相对路径/绝对路径/特殊路径符"></a>相对路径/绝对路径/特殊路径符</h2><p>​        我们书写目录，一种是从根目录开始找： /usr/ Path，还有一种是从 当下的工作目录开始找： cd LinuxPath, 前者是就是从根目录找，称之为绝对路径，非常的绝对，代价即是很长。后者就是在当前目录去找！</p><p>​        下面是一些特殊的符号：</p><pre class="line-numbers language-none"><code class="language-none">. : 当前目录，常用的就是切换到当前目录下的文件夹，比如说：cd .&#x2F;Desktop&#x2F;SomeThing.. : 返回上一级目录 退两级：cd ..&#x2F;..~ : 直接回到home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> LinuxPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        mkdir正如缩写所义：make directory。创建一个在父目录之下的子目录。而参数 -p 是可选的，他让我们可以创建一个递归的目录，适用于直接创建多层的文件夹，实际看一下就是这个意思！</p><p><img src="image-20230415221252797.png" alt="image-20230415221252797"></p><p><img src="image-20230415221608598.png" alt="image-20230415221608598"></p><h2 id="torch-cat-more"><a href="#torch-cat-more" class="headerlink" title="torch cat more"></a>torch cat more</h2><p>​        使用torch命令来创建文件，格式是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> LinuxPath/Filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230415222041990.png" alt="image-20230415222041990"></p><p>​        随后，我们可以先给这个文件写点东西，会使用 vim 就用 vim：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; type in shell &gt;&gt;&gt;vim touch.txt&#x2F;&#x2F; press i to get into the insert mode&#x2F;&#x2F; write in file : Hello,welcome using cat to check the note off this file&#x2F;&#x2F; press ESC&#x2F;&#x2F; write :wq&#x2F;&#x2F; back to shell: &gt;&gt;&gt; cat touch.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230415222728934.png" alt="image-20230415222728934"></p><pre class="line-numbers language-none"><code class="language-none">cat Linux&#x2F;Path&#x2F;FileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        对于more命令，那表示的是如果文件内容过长，可以使用more命令来查看文档</p><p><img src="image-20230415223140319.png" alt="image-20230415223140319"></p><p>​        </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">more</span> Linux/Path/FileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        回车一行行查看，空格是一页一页看，退出是q</p><h2 id="cp-mv-rm"><a href="#cp-mv-rm" class="headerlink" title="cp mv rm"></a>cp mv rm</h2><p>​        cp是copy的缩写，就是复制文件的意思。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> <span class="token punctuation">[</span>-r<span class="token punctuation">]</span> LinuxPath_beCopied LinuxPath_toThePlace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        -r 递归复制文件</p><p>​        第一个Path表明被复制的对象，第二个表示的是复制到何处。</p><p><img src="image-20230415223633861.png" alt="image-20230415223633861"></p><p>​        而mv:即是 move 的缩写了！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> LinuxPath/FileName<span class="token punctuation">(</span>or dirName<span class="token punctuation">)</span> LinuxPathDir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当然目标不存在的话就会改名保证目标的存在</p><p><img src="image-20230415223930574.png" alt="image-20230415223930574"></p><p>​        <img src="image-20230415224110470.png" alt="image-20230415224110470"></p><p>​        看，1.txt就被改成3.txt了</p><p>​        rm命令就是remove，表明删除</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>-r -f<span class="token punctuation">]</span> file1 dir1 file2 dir2 <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        -r :递归删除，可以用来删除文件夹</p><p>​        -f: 强迫删除，不需要询问，都可以删！（force）</p><p>​        如此多的参数就是我们想要删除的内容，使用空格隔开</p><p><img src="image-20230415224446501.png" alt="image-20230415224446501"></p><p><img src="image-20230415224550942.png" alt="image-20230415224550942"></p><p>​        rm支持通配符*用来进行模糊搜索：如</p><p>​        test*表明以test开头的所有文件</p><p>​        *test表示以test结尾的所有文件</p><p>​        <em>test\</em>表所有包含了test这个子字符串的文件名</p><h2 id="which和find"><a href="#which和find" class="headerlink" title="which和find"></a>which和find</h2><p>​        我们知道，Linux下的大部分命令就是程序代码，which则会告诉我们这些程序的二进制代码在哪里</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> instName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230415225204867.png" alt="image-20230415225204867"></p><p>​        Find既是搜索指定的文件名查找</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> PathStart <span class="token parameter variable">-name</span> <span class="token string">"fileNameBeSearched"</span> // 文件名查找<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230415225404584.png" alt="image-20230415225404584"></p><p>​        (Permisson denied 表明权限不够，回开root的开root试试)</p><p><img src="image-20230415225529928.png" alt="image-20230415225529928"></p><p>​        这个也支持模糊查找！具体的不再演示</p><p>​        另一个find即是：按照大小查找：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> pathStart <span class="token parameter variable">-size</span> +<span class="token operator">|</span>- n<span class="token punctuation">[</span>KMG<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        +表大于 - 表小于，后面带上数字和单位表大小（k(小写！！)多少KB，MB，GB）</p><p><img src="image-20230415230150000.png" alt="image-20230415230150000"></p><h2 id="grep-与-wc"><a href="#grep-与-wc" class="headerlink" title="grep 与 wc"></a>grep 与 wc</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>-n<span class="token punctuation">]</span> 关键字 文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        &gt;这里有可选参数 -n 表明在结果之中显示匹配的行的行号。</p><p>​        关键字参数时，表明查询的关键字，如果含有特殊符号请使用“”括起来</p><p>​        文件路径 表文件路径，可以作为内容输入端口</p><p><img src="image-20230416103713665.png" alt="image-20230416103713665"></p><p>​        wc做字符统计</p><pre class="line-numbers language-none"><code class="language-none">wc [-c -m -l -w] 文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        -c  : 统计bytes数量</p><p>​        -m 统计字符数量</p><p>​        -l 统计行数</p><p>​        -w 统计单词数量</p><p>​        文件路径那自然指向的时被统计文件，可以作为输入端的端口</p><p><img src="image-20230416105615266.png" alt="image-20230416105615266"></p><p>​        单词是用空格划分的！这是我们需要注意的。</p><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h2><p>​        我们现在尝试管道符：他正是表示的是将左边命令的结果作为右边命令的输入。</p><p><img src="image-20230416110106424.png" alt="image-20230416110106424"></p><p><img src="image-20230416110206546.png" alt="image-20230416110206546"></p><p>​        这个表明的是将检索到的内容来统计行数</p><h2 id="echo命令输出内容"><a href="#echo命令输出内容" class="headerlink" title="echo命令输出内容"></a>echo命令输出内容</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> 输出的内容<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230416110707817.png" alt="image-20230416110707817"></p><p>​        当然有特殊符号请用 “ “来括起来。</p><p>​        想要让他作为命令输出，如输出pwd的内容，加上`</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">pwd</span><span class="token variable">`</span></span> // 没什么用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="重定向符号-gt-与-gt-gt"><a href="#重定向符号-gt-与-gt-gt" class="headerlink" title="重定向符号 &gt; 与&gt;&gt;"></a>重定向符号 &gt; 与&gt;&gt;</h2><p>​        &gt; :将左侧命令的结果覆盖到符号右侧的指定文件</p><p>​        &gt;&gt; : 将左侧命令的结果追加到符号右侧的指定文件</p><p><img src="image-20230416111428026.png" alt="image-20230416111428026"></p><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tail</span> <span class="token punctuation">[</span>-f -num<span class="token punctuation">]</span> LinuxPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数，Linux的路径，这表示的是被跟踪的文件路径</p><p>​        -f 表示持续跟踪</p><p>​        -num 表示查看多少行，不填就是10行</p><p><img src="image-20230416111911011.png" alt="image-20230416111911011"></p><p><img src="image-20230416111948298.png" alt="image-20230416111948298"></p><p><img src="image-20230416112026385.png" alt="image-20230416112026385"></p><p><img src="image-20230416112203086.png" alt="image-20230416112203086"></p><h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><p>​        这是最经典的文本编辑器</p><p>​        下面开始介绍：</p><p>​        Command mode命令模式：这里所有的输入编辑器都理解为命令，从而驱动执行不同的功能</p><p>​        Insert mode： 我们可以对文编编辑</p><p>​        Last Line mode : 用 : 作为起头，通常用在文件的保存和退出</p><p><img src="image-20230416112744542.png" alt="image-20230416112744542"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>// <span class="token function">vim</span> LinuxPath<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        如果文件不存在就会创建一个新的文件，要不就会打开已经存在的文件。</p><p>​        一般打开的时候，会默认在命令模式。想要编写文件，必须先敲入 i 进入插入模式。</p><p>编辑结束后 esc 即可</p><p><img src="image-20230416113105108.png" alt="image-20230416113105108"></p><p><img src="image-20230416113210159.png" alt="image-20230416113210159"></p><h2 id="Root权限"><a href="#Root权限" class="headerlink" title="Root权限"></a>Root权限</h2><p>​        拥有最大的权限就是root.我们几乎做任何事情都不会受到阻挠。进入的方式就是</p><pre class="line-numbers language-none"><code class="language-none">su root&gt;&gt;&gt; encode your password in the Linux[root@...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        su 就是账户切换的系统命令，switch user</p><pre class="line-numbers language-none"><code class="language-none">su [-] -usrName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个符号是可选的，是用来加载环境变量的，建议带上</p><p>​        可以用exit指令退回到上一个用户，快捷键是 ctrl + d</p><pre class="line-numbers language-none"><code class="language-none">sudo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用户临时使用root权限。</p><p><img src="image-20230416114249475.png" alt="image-20230416114249475"></p><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><p>​        我们可以配置多个用户和用户组。用户也可以加入多个用户组。在Linux下，权限管控分为针对用户的权限控制和针对用户组的权限控制。</p><h3 id="创建与删除用户组"><a href="#创建与删除用户组" class="headerlink" title="创建与删除用户组"></a>创建与删除用户组</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">groupadd</span> groupname <span class="token comment"># in root</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">groupdel groupname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="用户的操作"><a href="#用户的操作" class="headerlink" title="用户的操作"></a>用户的操作</h3><p>1）useradd [-g -d]用户名</p><p>-g 用于指定用户所在的组，不指定-g会创建同名的组并让其进入这个组，注意如果指定的了的话必须组是存在的</p><p>-d 用于指定home在哪里，不写就是: /home/usrname</p><p><img src="image-20230416115407673.png" alt="image-20230416115407673"></p><p>2)userdel [-r] usrname</p><p>​        -r就是同时删除其用户的home文件夹</p><p>3)id [usrname]</p><p>​        查看自己所在的用户组，带上可选参数usrname就是查看 usrname 的用户组</p><p>4）usermod -aG 将指定的用户加到指定的用户组</p><p>5）getend 查看当前系统有哪些用户。</p><h2 id="查看权限工作"><a href="#查看权限工作" class="headerlink" title="查看权限工作"></a>查看权限工作</h2><p>在root下，输入ls -l即可：</p><p><img src="image-20230416120246176.png" alt="image-20230416120246176"></p><p><img src="image-20230416120355916.png" alt="image-20230416120355916"></p><p>其中：r有读权限 w有写权限 x有执行权限</p><p>当然具体来说也可能会有写不同：</p><p><img src="image-20230416120458085.png" alt="image-20230416120458085"></p><h2 id="修改权限控制"><a href="#修改权限控制" class="headerlink" title="修改权限控制"></a>修改权限控制</h2><p>chmod</p><p><img src="image-20230416120610230.png" alt="image-20230416120610230"></p><p><img src="image-20230416120725024.png" alt="image-20230416120725024"></p><p>chown </p><p><img src="image-20230416120752474.png" alt="image-20230416120752474"></p><h2 id="一些快速操作快捷键"><a href="#一些快速操作快捷键" class="headerlink" title="一些快速操作快捷键"></a>一些快速操作快捷键</h2><p>Ctrl + c强制停止</p><p>Ctrl + d 退出账户</p><p>history: 查看历史执行的命令， !命令前缀，自动执行从后往前的找到第一个匹配前缀的指令</p><p><img src="image-20230416121054792.png" alt="image-20230416121054792"></p><p><img src="image-20230416121101651.png" alt="image-20230416121101651"></p><p><img src="image-20230416121123675.png" alt="image-20230416121123675"></p><p><img src="image-20230416121152194.png" alt="image-20230416121152194"></p><p><img src="image-20230416121219359.png" alt="image-20230416121219359"></p><p><img src="image-20230416121319303.png" alt="image-20230416121319303"></p><p><img src="image-20230416121350614.png" alt="image-20230416121350614"></p><p><img src="image-20230416121411677.png" alt="image-20230416121411677"></p><p><img src="image-20230416121432968.png" alt="image-20230416121432968"></p><p><img src="image-20230416121446642.png" alt="image-20230416121446642"></p><p><img src="image-20230416121528040.png" alt="image-20230416121528040"></p><p><img src="image-20230416121543781.png" alt="image-20230416121543781"></p><p><img src="image-20230416121622511.png" alt="image-20230416121622511"></p><p><img src="image-20230416121635041.png" alt="image-20230416121635041"></p><p><img src="image-20230416121702592.png" alt="image-20230416121702592"></p><p><img src="image-20230416121713490.png" alt="image-20230416121713490"></p><p><img src="image-20230416121736563.png" alt="image-20230416121736563"></p><p><img src="image-20230416121748284.png" alt="image-20230416121748284"></p><p><img src="image-20230416121823770.png" alt="image-20230416121823770"></p><p><img src="image-20230416121835516.png" alt="image-20230416121835516"></p><p><img src="image-20230416121849522.png" alt="image-20230416121849522"></p><p><img src="image-20230416121904518.png" alt="image-20230416121904518"></p><p><img src="image-20230416121932632.png" alt="image-20230416121932632"></p><p><img src="image-20230416121949219.png" alt="image-20230416121949219"></p><p><img src="image-20230416122008858.png" alt="image-20230416122008858"></p><p><img src="image-20230416122034234.png" alt="image-20230416122034234"></p><p>​        这个有点像Windows下的PATH</p><p><img src="image-20230416122057738.png" alt="image-20230416122057738"></p><p><img src="image-20230416122108863.png" alt="image-20230416122108863"></p><p><img src="image-20230416122125643.png" alt="image-20230416122125643"></p><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><p><img src="image-20230416122233062.png" alt="image-20230416122233062"></p><p><img src="image-20230416122248474.png" alt="image-20230416122248474"></p><p><img src="image-20230416122257252.png" alt="image-20230416122257252"></p><p><img src="image-20230416122319744.png" alt="image-20230416122319744"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas in Python</title>
      <link href="/2023/04/13/Pandas-in-Python/"/>
      <url>/2023/04/13/Pandas-in-Python/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 这里是我随手写的Pandas API 的一些笔记，为了省事直接拷贝于此！</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> pandas<span class="token triple-quoted-string string">'''this is a pandas demoto show basic API of pandasto install the lib ...pip:    pip install pandas IN terminal    or if conda is available in your operating system, using    conda install pandas == version_you_want_to_install    '''</span><span class="token triple-quoted-string string">'''Pandas 1 : using this sentence to show the version of pandas:>'''</span><span class="token keyword">print</span><span class="token punctuation">(</span>pandas<span class="token punctuation">.</span>__version__<span class="token punctuation">)</span><span class="token comment"># Sections1: Series</span><span class="token triple-quoted-string string">'''Series in pandas is considered as a data structure with indexAs D &amp; Alg has already pointed out, index can be string or just numbersin pandas, it's the same'''</span><span class="token triple-quoted-string string">'''---------------------------------------------------------------------------------    the creation of series---------------------------------------------------------------------------------'''</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is to create a series by using two ways'</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">''' to check, try to run it in terminal '''</span><span class="token comment"># this is a list</span>height_among_stu_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">131</span><span class="token punctuation">,</span> <span class="token number">141</span><span class="token punctuation">,</span> <span class="token number">182</span><span class="token punctuation">,</span> <span class="token number">109</span><span class="token punctuation">,</span> <span class="token number">178</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>height_among_stu_list<span class="token punctuation">)</span><span class="token comment"># this is a series</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Series is gonna printed:>\n"</span><span class="token punctuation">)</span>height_series <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>height_among_stu_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>height_series<span class="token punctuation">)</span><span class="token comment"># we can set a name of a series:></span>set_name <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'An Increasing subsequence'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>set_name<span class="token punctuation">)</span><span class="token comment"># Back to what I said before... series is a data structure with index... maybe hashSet or hash table?</span>val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>label <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span>set_with_label <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>val<span class="token punctuation">,</span> index<span class="token operator">=</span>label<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>set_with_label<span class="token punctuation">)</span><span class="token comment"># if you are serious about the index list, use series.index to gain a result:></span><span class="token keyword">print</span><span class="token punctuation">(</span>set_with_label<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token comment"># another quick way to create a series is to use a dictionary as input</span>dic <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token number">111</span><span class="token punctuation">,</span>    <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token number">222</span><span class="token punctuation">,</span>    <span class="token string">'C'</span><span class="token punctuation">:</span> <span class="token number">333</span><span class="token punctuation">,</span>    <span class="token string">'D'</span><span class="token punctuation">:</span> <span class="token number">444</span><span class="token punctuation">&#125;</span>ser_dic <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>dic<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ser_dic<span class="token punctuation">)</span><span class="token comment"># here comes an interesting questions:> what if we have 3 inputs but owns four labels? have a try...</span>dic <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token number">111</span><span class="token punctuation">,</span>    <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token number">222</span><span class="token punctuation">,</span>    <span class="token string">'C'</span><span class="token punctuation">:</span> <span class="token number">333</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>ser_dic_loss <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>dic<span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ser_dic_loss<span class="token punctuation">)</span><span class="token comment"># we get a nan as result! NAN in pandas means a loss of number. We are supposed to make a deal with it!</span><span class="token comment"># another creation , especially for vals, is to do in this way:>1</span>set_num <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>set_num<span class="token punctuation">)</span><span class="token comment"># we see the labels own the same value of 10...</span><span class="token triple-quoted-string string">'''-----------------------------------------------------------------------------------    the usage of index and its relative API-----------------------------------------------------------------------------------'''</span><span class="token comment"># usually, when we visit a hash set, we do visit elements by offering a label.</span><span class="token comment"># for example, we can get 'A' by inputting 1 in a hash set:></span><span class="token comment"># for series in pandas, things got the same...</span>dic_for_search <span class="token operator">=</span> dicsetSearch <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>dic_for_search<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Print the key by the visitor[]"</span><span class="token punctuation">)</span><span class="token comment"># this for loop is to visit elements in series</span>searchLabels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">[</span>searchLabels<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># but if the key is hard to get, while it's relatively easy to know the position,</span><span class="token comment"># this API is just for the case:> called 'iloc': i locations in other words...</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># differently, we can output the suitable value by just inputting the logical expression in []</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this key - val set is a set which the val is above 222"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">[</span>setSearch <span class="token operator">></span> <span class="token number">222</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># Also, if the val is supported to make basic calculations, we can operate all the elements by...</span>setSearch <span class="token operator">+=</span> <span class="token number">222</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># here comes a big difference comparing list in python and series in pandas</span>mylist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>mylist<span class="token punctuation">)</span>mylist <span class="token operator">+=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>mylist<span class="token punctuation">)</span><span class="token comment"># See , we actually directly append the elements backward to the mylist</span><span class="token comment"># while this one is...</span>setSearch <span class="token operator">+=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># add the elements to all the vals instead of appending</span><span class="token triple-quoted-string string">'''----------------------------------------------------------------------------------------------            index----------------------------------------------------------------------------------------------'''</span><span class="token comment"># index has variety of types</span><span class="token comment"># when we do not offer a coefficient of index in the initialization, pandas will</span><span class="token comment"># automatically use RangeIndex</span>val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>a <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>val<span class="token punctuation">)</span>b <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>val<span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">)</span>c <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'abcde'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token triple-quoted-string string">''' VAlS in pandas '''</span><span class="token comment"># 1 iloc and loc</span><span class="token comment"># loc is [ ] while iloc is [ )</span><span class="token comment"># no examples... as they have been used previously</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is the size:> "</span><span class="token punctuation">,</span> setSearch<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment"># is_unique:> if there is the same elem in the set, return false, else return true</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">.</span>is_unique<span class="token punctuation">)</span><span class="token comment"># we can modify the elements by offering the key name:></span>setSearch<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># also it can be multipy:></span>setSearch<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">:</span><span class="token string">'C'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20000</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># back to the way of appending the series: by just offering a new key with value:></span>setSearch<span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2000000</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># or using the api: append</span>appender <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10000000</span><span class="token punctuation">,</span><span class="token number">20000000</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'G'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>setSearch<span class="token punctuation">.</span>append<span class="token punctuation">(</span>appender<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''-----------------------------------------------------------------------------------------------------                                        del-----------------------------------------------------------------------------------------------------'''</span><span class="token comment"># use del directly to erase the elements</span><span class="token keyword">del</span> setSearch<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># or use tha api in pandas:></span>setSearch<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>index<span class="token operator">=</span><span class="token string">'B'</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># if we want to erase the duplicate elements, use:></span>duplicate <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'abcdef'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>duplicate<span class="token punctuation">)</span>duplicate <span class="token operator">=</span> duplicate<span class="token punctuation">.</span>drop_duplicates<span class="token punctuation">(</span>keep<span class="token operator">=</span><span class="token string">'first'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>duplicate<span class="token punctuation">)</span><span class="token comment"># duel and check the NAN</span>aNAN <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>NaN<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>NaN<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>NaN<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'abcdef'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>aNAN<span class="token punctuation">.</span>isna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># use dropna() can be a good choice to erase the invalid data</span>aNAN <span class="token operator">=</span> aNAN<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>aNAN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmake 简单笔记 （1）</title>
      <link href="/2023/02/16/Cmake-%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2023/02/16/Cmake-%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简单CMake教程"><a href="#简单CMake教程" class="headerlink" title="简单CMake教程"></a>简单CMake教程</h1><p>​        下面请在 Linux 系统下操作，建议虚拟机！</p><h2 id="干嘛的这个"><a href="#干嘛的这个" class="headerlink" title="干嘛的这个"></a>干嘛的这个</h2><p>​        我们构建程序非常需要这个玩意！使用它来构建比如说VS下的项目！</p><h2 id="怎么下载？"><a href="#怎么下载？" class="headerlink" title="怎么下载？"></a>怎么下载？</h2><p>​        先尝试一个指令：</p><pre class="line-numbers language-none"><code class="language-none">cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果出现了这个，那就说明你的Cmake已经装好了！</p><p><img src="image-20230216193703982.png" alt="image-20230216193703982"></p><p>​        如果不是，仔细阅读提示，大概是自己没有安装这个东西：</p><pre class="line-numbers language-none"><code class="language-none">sudo install cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        等一会儿就好了！</p><p>​        为了测试，也自行安装一下 g++ 编译器！</p><pre class="line-numbers language-none"><code class="language-none">sudo install g++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        方便我们后续的编译。</p><p>​        以及为了方便我们的书写，自然推介 vim 编辑器来干活：</p><pre class="line-numbers language-none"><code class="language-none">sudo install vim&#x2F;&#x2F; 先别急，一般你的linux已经安装好了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="先熟悉一下！"><a href="#先熟悉一下！" class="headerlink" title="先熟悉一下！"></a>先熟悉一下！</h2><p>​        先 cd 到一个工作文件夹吧！</p><p>​        先创建一个文件夹</p><pre class="line-numbers language-none"><code class="language-none">mkdir work<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        进入：</p><pre class="line-numbers language-none"><code class="language-none">cd work<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        直接整一个 main.cpp</p><pre class="line-numbers language-none"><code class="language-none">vim main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        按 i 来进入编辑模式, copy，请</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;int main()&#123;std::cout&lt;&lt;&quot;Hello Cpp&quot;&lt;&lt;std::endl&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后摁 esc 键，输入:wq退出</p><p>​        然后开始入门！</p><pre class="line-numbers language-none"><code class="language-none">vim CMakeLists.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        严格区分大小写！！！！</p><p>​        然后还是 copy ! 先不论这些都是什么东西</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">SET</span><span class="token punctuation">(</span>SRC_LIST main.cpp<span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"this is binary dir"</span> <span class="token punctuation">$&#123;</span><span class="token variable">HELLO_BINARY_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"this is SOURCE dir"</span> <span class="token punctuation">$&#123;</span><span class="token variable">HELLO_SOURCE_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello <span class="token punctuation">$&#123;</span>SRC_LIST<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        保存一下，还是一样的 esc :wq</p><p>​        然后编译一下，.的意思是在当前目录找CMakeList，在哪个目录下cmake产生的文件就在哪个目录下</p><pre class="line-numbers language-none"><code class="language-none">cmake .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后可以运行了：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span>   <span class="token comment"># 指定了工程的名字，并且支持所有语言—建议</span><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO CXX<span class="token punctuation">)</span>      <span class="token comment"># 指定了工程的名字，并且支持语言是C++</span><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO C CXX<span class="token punctuation">)</span>    <span class="token comment"># 指定了工程的名字，并且支持语言是C和C++</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        该指定隐式定义了两个CMAKE的变量</p><pre class="line-numbers language-none"><code class="language-none">&lt;projectname&gt;_BINARY_DIR，本例中是 HELLO_BINARY_DIR&lt;projectname&gt;_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录。</p><p>​        问题：如果改了工程名，这两个变量名也会改变</p><p>​        解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h2><p>​        用来显示的指定变量的</p><p>​        SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>​        也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h2><p>​        向终端输出用户自定义的信息</p><p>​        主要包含三种信息：    </p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h2 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a>ADD_EXECUTABLE关键字</h2><p>​        生成可执行文件</p><p>​        ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>​        也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>​        上述例子可以简化的写成</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h2 id="语法的基本原则"><a href="#语法的基本原则" class="headerlink" title="语法的基本原则"></a>语法的基本原则</h2><p>​        1. 变量使用 ${} 方式取值，但是在 IF 控制语句中是直接使用变量名</p><p>​        2.</p><ul><li>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，</li><li>如果存在另外一个 func.cpp 源文件，就要写成：</li><li><code>ADD_EXECUTABLE(hello main.cpp func.cpp)</code>或者<code>ADD_EXECUTABLE(hello main.cpp;func.cpp)</code></li><li>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</li><li>指令是大小写无关的，参数和变量是大小写相关的。</li></ul><h2 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h2 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h2><ul><li><p>我们刚刚讲的例子就是内部构建，他生产的临时文件特别多，不方便清理</p><p><img src="image-20230216202047986.png" alt="image-20230216202047986"></p><p>​        一大堆文件混在一起</p></li><li><p>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</p></li></ul><p>​        首先</p><pre class="line-numbers language-none"><code class="language-none">mkdir buildcd build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        然后</p><pre class="line-numbers language-none"><code class="language-none">cmake .. # 在上两级编译<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        现在干净了：（查看时cd ..）</p><p><img src="image-20230216202644656.png" alt="image-20230216202644656"></p><p>​        (记得再cd回去)</p><pre class="line-numbers language-none"><code class="language-none">make.&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        总结一下：</p><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>​        注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p><h2 id="让Hello-World看起来更像一个工程"><a href="#让Hello-World看起来更像一个工程" class="headerlink" title="让Hello World看起来更像一个工程"></a>让Hello World看起来更像一个工程</h2><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li></ul><p>每个目录下都要有一个CMakeLists.txt说明</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>外层CMakeLists.txt</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>src bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>src下的CMakeLists.txt</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        可执行文件在 bin 下面</p><h2 id="ADD-SUBDIRECTORY-指令"><a href="#ADD-SUBDIRECTORY-指令" class="headerlink" title="ADD_SUBDIRECTORY 指令"></a>ADD_SUBDIRECTORY 指令</h2><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p></li></ul><h2 id="更改二进制的保存路径"><a href="#更改二进制的保存路径" class="headerlink" title="更改二进制的保存路径"></a>更改二进制的保存路径</h2><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)<br>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h2 id="如何安装HelloWord"><a href="#如何安装HelloWord" class="headerlink" title="如何安装HelloWord"></a>如何安装HelloWord</h2><p>​        使用CMAKE一个新的指令：INSTALL</p><p>​        INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>​        使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><h2 id="安装文件COPYRIGHT和README"><a href="#安装文件COPYRIGHT和README" class="headerlink" title="安装文件COPYRIGHT和README"></a>安装文件COPYRIGHT和README</h2><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/<DESTINATION 定义的路径></p><p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p><p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h2 id="安装脚本runhello-sh"><a href="#安装脚本runhello-sh" class="headerlink" title="安装脚本runhello.sh"></a>安装脚本runhello.sh</h2><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><p>说明：实际安装到的是 /usr/bin</p><p>使用: make install 安装东西</p><pre class="line-numbers language-none"><code class="language-none">sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装-doc-中的-hello-txt"><a href="#安装-doc-中的-hello-txt" class="headerlink" title="安装 doc 中的 hello.txt"></a>安装 doc 中的 hello.txt</h2><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc/有很大的区别</p><p>目录名不以/结尾：这个目录将被安装为目标路径下的</p><p>目录名以/结尾：将这个目录中的内容安装到目标路径</p><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>cmake ..</p><p>make</p><p>make install</p><h2 id="静态库和动态库的构建"><a href="#静态库和动态库的构建" class="headerlink" title="静态库和动态库的构建"></a>静态库和动态库的构建</h2><p>静态库和动态库的区别</p><ul><li><p>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</p></li><li><p>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</p></li><li><p>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</p><h2 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a>构建实例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@localhost cmake2<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── lib    ├── CMakeLists<span class="token punctuation">.</span>txt    ├── hello<span class="token punctuation">.</span>cpp    └── hello<span class="token punctuation">.</span>h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.h中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HELLO_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Hello_H</span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.cpp中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hello.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>项目中的cmake内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>lib bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>lib中CMakeLists.txt中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3 id="同时构建静态和动态库"><a href="#同时构建静态和动态库" class="headerlink" title="同时构建静态和动态库"></a>同时构建静态和动态库</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello STATIC $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static STATIC $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static STATIC $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//对hello_static的重名为hello</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static PROPERTIES  OUTPUT_NAME <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello PROPERTIES  OUTPUT_NAME <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a>动态库的版本号</h2><p>一般动态库都有一个版本号的关联</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span>libhello<span class="token punctuation">.</span>so <span class="token operator">-></span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-></span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h2 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h2><p>我们将 hello 的共享库安装到<prefix>/lib目录，</p><p>将 hello.h 安装到<prefix>/include/hello 目录</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//文件放到该目录下</span><span class="token function">INSTALL</span><span class="token punctuation">(</span>FILES hello<span class="token punctuation">.</span>h DESTINATION include<span class="token operator">/</span>hello<span class="token punctuation">)</span><span class="token comment">//二进制，静态库，动态库安装都用TARGETS</span><span class="token comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span><span class="token function">INSTALL</span><span class="token punctuation">(</span>TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h2 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h2><p>准备工作，新建一个目录来使用外部共享库和头文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@MiWiFi<span class="token operator">-</span>R4CM<span class="token operator">-</span>srv cmake3<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;hello.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解决：make后头文件找不到的问题"><a href="#解决：make后头文件找不到的问题" class="headerlink" title="解决：make后头文件找不到的问题"></a>解决：make后头文件找不到的问题</h2><p>PS：include <hello/hello.h>  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><h2 id="解决：找到引用的函数问题"><a href="#解决：找到引用的函数问题" class="headerlink" title="解决：找到引用的函数问题"></a>解决：找到引用的函数问题</h2><p>报错信息：undefined reference to `HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@MiWiFi<span class="token operator">-</span>R4CM<span class="token operator">-</span>srv bin<span class="token punctuation">]</span># ldd main linux<span class="token operator">-</span>vdso<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span><span class="token number">0x00007ffedfda4000</span><span class="token punctuation">)</span>libhello<span class="token punctuation">.</span>so <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libhello<span class="token punctuation">.</span><span class="token function">so</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0d8f000</span><span class="token punctuation">)</span>libstdc<span class="token operator">++</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libstdc<span class="token operator">++</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0874000</span><span class="token punctuation">)</span>libm<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libm<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0572000</span><span class="token punctuation">)</span>libgcc_s<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libgcc_s<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c035c000</span><span class="token punctuation">)</span>libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41bff8e000</span><span class="token punctuation">)</span><span class="token operator">/</span>lib64<span class="token operator">/</span>ld<span class="token operator">-</span>linux<span class="token operator">-</span>x86<span class="token operator">-</span><span class="token number">64.</span>so<span class="token punctuation">.</span><span class="token number">2</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0b7c000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h2 id="特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH"><a href="#特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH" class="headerlink" title="特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH"></a>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h2><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE=debug</p><h2 id="For-Lessons"><a href="#For-Lessons" class="headerlink" title="For Lessons:"></a>For Lessons:</h2><p><a href="https://www.bilibili.com/video/BV1vR4y1u77h?p=4&amp;vd_source=7756b1d353ef340c2ab91e80642a8922">从零开始详细介绍CMake</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言常用函数（1）string.h系列</title>
      <link href="/2023/02/09/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89string-h%E7%B3%BB%E5%88%97/"/>
      <url>/2023/02/09/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89string-h%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="string-h常用API-一览"><a href="#string-h常用API-一览" class="headerlink" title="string.h常用API 一览"></a>string.h常用API 一览</h1><h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><p>​    </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;string.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个东西，我想学习过C语言的都不陌生。这里我们拿出来一些常见的，有用的函数来仔细讲讲，仔细学学！</p><h3 id="strcpy-amp-amp-strcat"><a href="#strcpy-amp-amp-strcat" class="headerlink" title="strcpy&amp;&amp;strcat"></a>strcpy&amp;&amp;strcat</h3><p>​        我们首先来看看strcpy: 他就是 string copy的简写 而strcat可以看作string concatenates的缩写：这里先放一下官方对这两个函数的解释（水字数（划））</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;****strcat.c - contains strcat() and strcpy()**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       Strcpy() copies one string onto another.&#x2F;&#x2F;拷贝字符串**       Strcat() concatenates (appends) a copy of the source string to the*       end of the destination string, returning the destination string.&#x2F;&#x2F;追加字符串********************************************************************************&#x2F;#include &lt;string.h&gt;&#x2F;&#x2F; 引入定义的头文件&#x2F;&#x2F;无需理睬这里#ifndef _MBSCAT    #pragma function(strcat, strcpy)#endif&#x2F;&#x2F;&#x2F;****char *strcat(dst, src) - concatenate (append) one string to another**Purpose:*       Concatenates src onto the end of dest.  Assumes enough*       space in dest.&#x2F;&#x2F;这个 Assumptions相当有趣，它忽视了字符串可能发生上溢的风险*&#x2F;&#x2F;转而交给专门检查这个并抛出相关错误的函数来干*Entry:*       char *dst - string to which &quot;src&quot; is to be appended*       const char *src - string to be appended to the end of &quot;dst&quot;**Exit:*       The address of &quot;dst&quot; &#x2F;&#x2F;返回被追加字符串的首地址，便于我们访问**Exceptions:********************************************************************************&#x2F;char * __cdecl strcat (        char * dst, &#x2F;&#x2F; 目标要被写入，就必须不加 const，否则会报错        const char * src &#x2F;&#x2F; 源头不能改，加 const        )&#123;    &#x2F;&#x2F; 先取到首地址，防止改动 dst 导致被追加字符串无法访问        char * cp &#x3D; dst;        while( *cp )                cp++;                   &#x2F;* find end of dst *&#x2F;        while((*cp++ &#x3D; *src++) !&#x3D; &#39;\0&#39;) ;       &#x2F;* Copy src to end of dst *&#x2F;        return( dst );                  &#x2F;* return dst *&#x2F;&#125;&#x2F;****char *strcpy(dst, src) - copy one string over another**Purpose:*       Copies the string src into the spot specified by*       dest; assumes enough room.**Entry:*       char * dst - string over which &quot;src&quot; is to be copied*       const char * src - string to be copied over &quot;dst&quot;**Exit:*       The address of &quot;dst&quot;**Exceptions:*******************************************************************************&#x2F;char * __cdecl strcpy(char * dst, const char * src)&#123;        char * cp &#x3D; dst;        while((*cp++ &#x3D; *src++) !&#x3D; &#39;\0&#39;)                ;               &#x2F;* Copy src over dst *&#x2F;        return( dst );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        水完了，但是仔细看看，却发现信息量很大！我们首先从 直接拷贝 说起：</p><h4 id="strcpy-直接拷贝"><a href="#strcpy-直接拷贝" class="headerlink" title="strcpy 直接拷贝"></a>strcpy 直接拷贝</h4><p>​        strcpy函数是一个直接从资源（拷贝）字符串中拿取信息扔到另一个字符串里，从实现上我们一眼看出了这个函数<strong>会覆盖目的地字符串的信息</strong>! </p><p>​        问题来了，我们怎样理解这段代码？或者说：当我们也要自己实现一个搬运信息的函数的时候，怎样实现一个跟库里一样简洁的函数呢？</p><p>​        首先，我们的思路就是：</p><p>​        1）确定函数的参数列表，返回类型！ <strong>参数根据问题来看：从哪里拷贝？拷贝到哪里？</strong> 返回类型？好像一眨眼看，不需要返回什么（因为我们可以拿起目的地字符串指针），于是：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void myStrCpy(char* dest , char* src)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        接下来，就是拷贝工作了！为了访问数据， 在C语言中 ，除了使用下标访问，我们还可以使用指针 ：定义两个指针出来，开始拷贝！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！char* p_Src &#x3D; src ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        然后呢？我们开始拷贝：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">*p_Dest &#x3D; *p_Src ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不对啊！拷贝完第一个，咱们还要拷贝下一个啊！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">p_Dest++;p_Src++ ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        然后重复工作！很明了了，我们使用while循环</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while( &#x2F;* Still Unknown *&#x2F;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针p_Src++ ; &#x2F;&#x2F;移动指针&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        怎么停下来？好说！ source拷完了停下来嘛！怎么看 source 拷没拷完？字符串终结的标志，是<code>\0</code> 那就简单了： Src指针走向 \0的时候，我就让 while 循环停下来嘛！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while (p_Src !&#x3D; &#39;\0&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230209163006541.png" alt="image-20230209163006541"></p><p>​        如上图所示，拷贝完，就移动指针到下一个！周而复始直到 lol拷贝完毕 p_Src 指向 ‘\0’结束拷贝！</p><p>​        就这样完事了？看看打印出来了什么东西？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void myStrCpy(char* dest , char* src)&#123;    char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！char* p_Src &#x3D; src ;    while( p_Src !&#x3D; &#39;\0&#39;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针p_Src++ ; &#x2F;&#x2F;移动指针&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209163254267.png" alt="image-20230209163254267"></p><p>​        挺符合逻辑，所以，敢这样就拍马屁走人了，那就很遗憾了：</p><p><img src="image-20230209163516376.png" alt="image-20230209163516376"></p><p>​        我们的函数，只要在这个环境下工作，马上就会出问题！你猜猜为什么呢？当然是没有’\0’啦！，因为我们的函数逻辑是遇到’\0’就停，‘\0’没有被拷贝就走了！自然我们的打印函数就要跑遍满内存去找你那\0!</p><p>​        我们手动放上一个斜杠0不就好了嘛？</p><p><img src="image-20230209163936912.png" alt="image-20230209163936912"></p><p>​        加上句话就好了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">p_Dest &#x3D; &#39;\0&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        但是好啰嗦啊，可以自己看看：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void myStrCpy(char* dest , char* src)&#123;    char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！char* p_Src &#x3D; src ;    while( p_Src !&#x3D; &#39;\0&#39;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针p_Src++ ; &#x2F;&#x2F;移动指针&#125;    p_Dest &#x3D; &#39;\0&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        开始化简，写高质量代码！</p><p>​        首先想一件事情： 我们有没有必要，整出来一个char<em> p_Src = src ？<strong>没有必要</strong>！因为我们在这里只是对他访问信息，<em>*不做改动</em></em>！马上，我们有两个点可以改动！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;1 原则1： 不改动的一律使用 const 修饰符提高程序安全&#x2F;&#x2F;2 原则2： 减少声明过多的累赘的变量！void myStrCpy(char* dest , const char* src) &#x2F;&#x2F; 1. Change 1&#123;     char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！    while( *src !&#x3D; &#39;\0&#39;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针&#125;    p_Dest &#x3D; &#39;\0&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        同时，我们希望可以让程序有更好的扩展性，我们可以修改返回类型，使之可以产生链式编程的效果（在C++中重载 + 等运算符尤为常见的思想），就是返回本身：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* myStrCpy(char* dest , const char* src) &#x2F;&#x2F; 1. Change 1&#123;     char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！    while( *src !&#x3D; &#39;\0&#39;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针&#125;    p_Dest &#x3D; &#39;\0&#39;;    return dest ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        到这里，作为一个良好的编程人已经可以高喊下班了，但是再看看 ，可不可以偷懒，让程序再简洁一些呢？当然可以！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">1.    while循环里使之终止的值为 零，包括：(int)0,&#39;\0&#39;,false , NULL((void*)0)2.表达式产出的结果可以直接放进while循环里做判断，基于此，我们可以化简程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* myStrCpy(char* dest , const char* src)&#123;        char* p_Dest &#x3D; dest;        while(        (            *src++ &#x3D; *p_Dest++ &#x2F;&#x2F;各自赋值，然后指针移动        )         !&#x3D; &#39;\0&#39; &#x2F;&#x2F; 产生的值，就是赋予的东西跟 \0 比较，如果是我们就暂停         )        ; &#x2F;&#x2F; just copy    return dest ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们的实现就跟库完全一致了！</p><h4 id="strcat-追加字符串"><a href="#strcat-追加字符串" class="headerlink" title="strcat 追加字符串"></a>strcat 追加字符串</h4><p>​        不同于直接拷贝，咱们这个是追加上去的，什么是追加？就是在屁股后面直接跟上字符串：比如说： str 追加一个 str——<code>&gt;</code> strstr 。我们已经讲过了最为基础的拷贝，具体有关拷贝和移动细节，不在过多的讲了。原型一样的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* myStrCat(char* dest ,const char* src)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        思路是简单的，追加分成 1）追 2）加 两个部分！</p><p>​        先追：到目标地点字符串的最后面：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* p_Dest &#x3D; dest ;while( *p_Dest ) &#x2F;&#x2F;while循环里使之终止的值为 零，包括：(int)0,&#39;\0&#39;,false , NULL    p_Dest ++ ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        再拷贝：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while((            *src++ &#x3D; *p_Dest++ &#x2F;&#x2F;各自赋值，然后指针移动        )         !&#x3D; &#39;\0&#39; &#x2F;&#x2F; 产生的值，就是赋予的东西跟 \0 比较，如果是我们就暂停      )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        再返回：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return dest;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        就是多了一个追加的过程！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* myStrCat(char* dest ,const char* src)&#123;    char* p_Dest &#x3D; dest ;    while( *p_Dest ) &#x2F;&#x2F;while循环里使之终止的值为 零，包括：(int)0,&#39;\0&#39;,false , NULL   p_Dest ++ ;        while((            *src++ &#x3D; *p_Dest++ &#x2F;&#x2F;各自赋值，然后指针移动         )          !&#x3D; &#39;\0&#39; &#x2F;&#x2F; 产生的值，就是赋予的东西跟 \0 比较，如果是我们就暂停      )      return dest;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="strcmp比较函数"><a href="#strcmp比较函数" class="headerlink" title="strcmp比较函数"></a>strcmp比较函数</h3><p>​        这个有意思，我们拿他来比较两个字符串 ， 在经典Windows ，Linux文件索引排序的时候，都是使用这样的strcmp决定谁先谁后，注意的是，我们比较的，是ASCII码值的大小，这跟char的特性密切相关（ASCII规定使用一字节二进制数表示一个字符）。Anyway , 看看C库开发者怎么说</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;****strcmp.c - routine to compare two strings (for equal, less, or greater)**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       Compares two string, determining their ordinal order.********************************************************************************&#x2F;#include &lt;string.h&gt;#pragma function(strcmp)&#x2F;****strcmp - compare two strings, returning less than, equal to, or greater than**Purpose:*       STRCMP compares two strings and returns an integer*       to indicate whether the first is less than the second, the two are*       equal, or whether the first is greater than the second.**       Comparison is done byte by byte on an UNSIGNED basis, which is to*       say that Null (0) is less than any other character (1-255).**Entry:*       const char * src - string for left-hand side of comparison*       const char * dst - string for right-hand side of comparison**Exit:*       returns -1 if src &lt;  dst*       returns  0 if src &#x3D;&#x3D; dst*       returns +1 if src &gt;  dst**Exceptions:********************************************************************************&#x2F;int __cdecl strcmp (        const char * src,        const char * dst        )&#123;        int ret &#x3D; 0 ;        while((ret &#x3D; *(unsigned char *)src - *(unsigned char *)dst) &#x3D;&#x3D; 0 &amp;&amp; *dst)                &#123;                ++src, ++dst;                &#125;&#x2F;&#x2F; what is fxxking this ???        return ((-ret) &lt; 0) - (ret &lt; 0); &#x2F;&#x2F; (if positive) - (if negative) generates branchless code&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我打赌你肯定看不懂了哈哈，没关系。我们先来理解原理！</p><p>​        上面我强调，我们比的，是一个字符一个字符的ASCII值。如果两个字符的ASCII值不一样，说明一个问题：这两个字符串不一样！那就好说了！如果两个字符串长度不一样，我们直接就认为两个字符串不相等（触犯了<em>str1 == </em>str2,因为‘\0’一定不等于另一个未完结字符串的内容）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while( *str1 &#x3D;&#x3D; *str2 &amp;&amp; &#x2F;* Must have other conditions...*&#x2F;)&#123;    str1++;    str2++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        当然。。。截至判断必须要有：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while( *str1 &#x3D;&#x3D; *str2 &amp;&amp; *str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39;)&#123;    str1++;    str2++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        返回什么？其实，标准库有两种返回！我们先来看第一种：</p><pre class="line-numbers language-none"><code class="language-none">ASCII小的返回-1 ， ASCII 完全一致的返回 0 ，大的返回 1！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        那简单！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if( *str1 &lt; *str2) return -1;else if( *str1 &#x3D;&#x3D; *str2 )     return 0;else      return 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不错，还有一种直接返回他们的差</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return *str1 - *str2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        能不能骚一点？咱们的 <code>if-else if - else</code>写的太捞了！让我们一行代码搞定？可以！</p><p>​        首先来看一件事！这个差是怎样的，可以跟 0 比较！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int ret &#x3D; *str1 - *str2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">ret &lt; 0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个式子返回1，反之如果不成立，就返回0！</p><p>​        现在，我们这样来看！ ret要不小于0，要不大于0 要不等于0  -ret更是如此：如果我们的表达式产出的布尔值，无非就是这样的：</p><div class="table-container"><table><thead><tr><th>ret</th><th>&gt;0</th><th>=0</th><th>&lt;0</th></tr></thead><tbody><tr><td>-ret&lt;0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>ret&lt;0</td><td>0</td><td>0</td><td>1</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><p>​        很好！现在我们来看，如果把这两行的值相减！不久达到了我们的目的吗！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">-</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        再把<code>int ret = *str1 - *str2</code>带入</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return (-(*str1 - *str2) &lt; 0)- ((*str1 - *str2) &lt; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        完事！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int myStrCmp(const char* str1, const char* str2) &#123;    while (*str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39;&amp;&amp;*str1&#x3D;&#x3D;*str2) &#123;        str1++;        str2++;    &#125;    return (-(*str1 - *str2) &lt; 0)- ((*str1 - *str2) &lt; 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="memory-h"><a href="#memory-h" class="headerlink" title="memory.h"></a>memory.h</h3><p>注意，在这里我不打算放出源码，作为C语言里几乎可以说是最底层的头文件，不打算让你去看大量的汇编代码，那没意思！但是，我们可以了解一些常用的API</p><h4 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h4><p>​        memory copy的简写！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* memcpy(void *dest, const void *src, size_t n) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数？作为直接操作内存块的函数，我们的接受类型必须是<code>void*</code>!同时，看const修饰的位置我们也知道，dest是写入内存的地方，另一个是资源区块!</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;this is a example shows that memcpy can copy things whatever it is!int main()&#123;    &#x2F;&#x2F;可以拷贝内置数据类型    int src1 &#x3D; 10;int* dest1 &#x3D; (int*)malloc(4);if (dest1 &#x3D;&#x3D; NULL) &#123;return;&#125;memcpy(dest1, &amp;src1, 4);printf(&quot;%d &quot;, *dest1);        &#x2F;&#x2F;可以拷贝自定义的内容typedef struct student_ &#123;int age;char* name;&#125;student;student s1;s1.age &#x3D; 18;s1.name &#x3D; &quot;charliechen&quot;;student* s_copy &#x3D; (student*)malloc(sizeof(student));memcpy(s_copy, &amp;s1, sizeof(student));printf(&quot;%d %s&quot;, s_copy-&gt;age, s_copy-&gt;name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209181211552.png" alt="image-20230209181211552"></p><h4 id="memmove"><a href="#memmove" class="headerlink" title="memmove"></a>memmove</h4><p>​        这个函数解决了资源与拷贝区重叠的问题：</p><p>​        对于memmove，即使内容有重叠，src的内容也可以正确地被拷贝到了dest指向的空间。</p><p><img src="1.png" alt="1"></p><p>​                                                                    内存重叠的拷贝</p><p>​        这种情况下，src的地址小于dest的地址，拷贝前3个字节没问题，但是拷贝第4，5个字节时，原有的内容已经被src拷贝过来的字符覆盖了，所以已经丢失原来src的内容，这很明显就是问题所在。所以，对于正常情况下，优先使用memmove防止出现未定义行为，其他的跟memcpy完全一致！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
