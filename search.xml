<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法（1）</title>
      <link href="/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h3 id="认识时间复杂度"><a href="#认识时间复杂度" class="headerlink" title="认识时间复杂度"></a>认识时间复杂度</h3><p>​        我们有一些操作是常数时间完成的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int a &#x3D;arr[i];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为我们直接计算偏移量直接取出的</p><p>​        但是这个不是</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int t&#x3D;list.get(i);&#x2F;&#x2F;链表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为链表必须遍历，才能找到元素</p><p>​        以及加减乘除的操作是常数操作。</p><p>​        总而言之：涉及到数据量的操作都是<strong>非常数操作</strong></p><p>​        举个例子，选择排序：这个排序是一种选择某一个数与前面已经排好的数组开始对比。怎么保证前面的已经有序了呢？我们把算法作用在第一个元素上，这个时候那他与第二个元素排序，成功后就是一个有序小数组，这样就满足了递归的条件：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Part I:C version without recurssion#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;&#x2F;&#x2F;using Choose sort to sort the array&#x2F;&#x2F;rand num getterint getRandNum(int maxRange)&#123;    srand((unsigned int)clock());    Sleep(10);    return rand()% maxRange;&#125;void printCurrentArray(int* array,int arraySize)&#123;    printf(&quot;Current array is shown:\n&quot;);    for(int i&#x3D;0; i&lt;arraySize; i++)    &#123;        printf(&quot;%d &quot;,array[i]);    &#125;    printf(&quot;\n&quot;);&#125;void swapInt(int* e1, int* e2)&#123;    int temp&#x3D;*e1;    *e1&#x3D;*e2;    *e2&#x3D;temp;&#125;int main()&#123;    &#x2F;&#x2F;get a rand array    int arr[10]&#x3D;&#123;0&#125;;    for(int i&#x3D;0; i&lt;10; i++)    &#123;        arr[i]&#x3D; getRandNum(100);    &#125;    &#x2F;&#x2F;Sort starts!    for(int i&#x3D;1; i&lt;10; i++)    &#123;        &#x2F;&#x2F;from the second one        &#x2F;&#x2F;Compared with the previous one and the front one        for(int j&#x3D;i;j&gt;0;j--)        &#123;            &#x2F;&#x2F;If inverted,invert them back            if(arr[j]&lt;arr[j-1])            &#123;                swapInt(&amp;arr[j], &amp;arr[j - 1]);            &#125;        &#125;        &#x2F;&#x2F;Target the Current Key and show:        printf(&quot;Current key is:%d\n&quot;,arr[i]);        printCurrentArray(arr,10);        printf(&quot;Enter the newline to go forward!&quot;);        getchar();    &#125;    printf(&quot;Eventually...\n&quot;);    printCurrentArray(arr,10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Or Recussion type#define _CRT_SECURE_NO_WARNINGS 1#include&lt;windows.h&gt;#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;&#x2F;&#x2F;using Choose sort to sort the array&#x2F;&#x2F;rand num getterint getRandNum(int maxRange)&#123;    srand((unsigned int)clock());    Sleep(10);    return rand() % maxRange;&#125;void printCurrentArray(int* array, int arraySize)&#123;    printf(&quot;Current array is shown:\n&quot;);    for (int i &#x3D; 0; i &lt; arraySize; i++)    &#123;        printf(&quot;%d &quot;, array[i]);    &#125;    printf(&quot;\n&quot;);&#125;void swapInt(int* e1, int* e2)&#123;    int temp &#x3D; *e1;    *e1 &#x3D; *e2;    *e2 &#x3D; temp;&#125;void insertSort(int* array, int arraySize, int cur_sort_place)&#123;    if (cur_sort_place &gt; arraySize-1)        return;    int j &#x3D; cur_sort_place;    while (j &gt; 0)    &#123;        if (array[j] &lt; array[j - 1])            swapInt(&amp;array[j], &amp;array[j - 1]);        j--;    &#125;    choiceSort(array, arraySize, cur_sort_place + 1);&#125;int main()&#123;    int arr[10] &#x3D; &#123; 0 &#125;;    for (int i &#x3D; 0; i &lt; 10; i++)    &#123;        arr[i] &#x3D; getRandNum(100);    &#125;    insertSort(arr, 10, 1);    printCurrentArray(arr, 10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个算法的时间复杂度就是O($N^2$)，这是因为操作表达式的最高阶是$N^2$.</p><p>​        注意到O(N)表达的是表达式的最高此项，是衡量巨大数量下算法的优良度</p><p><img src="image-20230126193633933.png" alt="image-20230126193633933"></p><p>​        当时间复杂度相同时，通过==比较常数项==作出判断是否可靠。更多的时候我们选择直接开跑看看怎么样：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void Process1()&#123;    int N&#x3D;1000;    int a&#x3D;1;    for(int i&#x3D;0 ; i&lt;N; i++)    &#123;        a*&#x3D;10;        a&#x3D;a+10;        a&#x3D;6127*9876;    &#125;&#125;public static void Process2()&#123;     int N&#x3D;1000;    int a&#x3D;1;    for(int i&#x3D;0 ; i&lt;N; i++)    &#123;        a&#x3D;10|1;        a^&#x3D;10;        a&#x3D;a&amp;9876;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对，就是这种。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>​        回顾上面的实例代码：我们使用Java写出另一个版本：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">seletionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minIndex<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            minIndex<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token operator">?</span>j<span class="token operator">:</span>minIndex<span class="token punctuation">;</span><span class="token comment">//直接找到最小的地方</span>        <span class="token punctuation">&#125;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Using in swap minindex with arr[i]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>​        我们也可以使用冒泡排序排数，就像大的泡泡向下沉，小的泡泡向上浮。就好了。值得注意的是，我们换完产生的最值区已经换好了，没有必要再参与排序。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>N<span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>conditions<span class="token punctuation">)</span>            swap data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="交换的离奇写法"><a href="#交换的离奇写法" class="headerlink" title="交换的离奇写法"></a>交换的离奇写法</h3><p>请看这个</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>异或：相同为0，不同为1：</p><p>例如：</p><p>A:1011110101001</p><p>B:1000101011001</p><p>  A^B: 0011011110000                        </p><p>也可以理解为无进位相加：</p><p>性质1：0^N=N,N^N=0</p><p>性质2：满足交换律和结合律</p><p>那这是怎么交换的？</p><p>a=a^b  1)</p><p>b=a^b</p><p>a=a^b</p><p>假设a= A,b=B;</p><p>1)a=A^B b=B</p><p>2)a=A^B,b=(A^B)^B =A^(B^B)=A</p><p>3)a=A^B^A=B b=A</p><p>交换完毕</p><p>但是注意：这样的方法不适用于同一块内存，否则会洗成0.</p><p>例题：1）现在有一个整型数组：里面有诺干出现了偶数次的数和一个出现奇数次的数，找出那个奇数次数的数：</p><p>EG：[2,1,3,1,3,1,3,2,1]——-&gt;3</p><p>Solutions：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int ero&#x3D;0;for(int i&#x3D;0;i&lt;arr.length;i++)&#123;ero^&#x3D;arr[i];&#125;printf(&quot;%d &quot;,ero);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是因为异或顺序无关，偶数次数的全消成了0.于是可以引用在奇偶相关次序无关的题目。</p><p>2）现在有一个整型数组：里面有诺干出现了偶数次的数和两个出现奇数次的数，找出那两个奇数次数的数：</p><p>Ok，当我们依旧沿袭上面的方法的时候，我们发现：eor=a^b,这是因为一切出现了偶数次的异或为0，a和b也最后削成一个a^b。下面怎么办？</p><p>注意到a$\neq$b，这样的话：因为最右边的1是a,b作为二进制的特征数（用它来区分a,b），我们就可以提取出来：int rightOne=eor&amp;(~eor+1)，也就是源码与上补码，提取eor上的第右边的1，随后只与这个位置上是1的数，就得到a或者是b了</p><p>​        <img src="image-20230127113335433.png" alt="image-20230127113335433"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printOddTimeNum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> eor<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        eor<span class="token operator">^</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> rightOne<span class="token operator">=</span>eor<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>eor<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找出来最右边的数</span>    <span class="token keyword">int</span> onlyOne<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//eor'</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token operator">:</span>arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cur<span class="token operator">&amp;</span>rightOne<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//别写1，因为出来的只能是0或者是rightOne，如果想要另一个就!=0;</span>            onlyOne<span class="token operator">^=</span>cur<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>onlyOne<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span><span class="token punctuation">(</span>ero<span class="token operator">^</span>onlyOne<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>​        这个就是最上面的代码，就是相当于插牌。这个算法的表现是波动较大的：O(N)~O($N^2$)。</p><p>​        但是算法的复杂度是看最差情况的，所以是O($N^2$).</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><p>​        注意，这个只使用于有序数组。这个数组使用二分查找是最快的。主要思想：找中间，比大小，挪边界，继续二分。这个算法的复杂度因此是$O(\log n)$.</p><h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h3><p>​        假设我们要进行测试方法A，我们使用随机样本产生器，我们随机的产生数据放到多个方法，他们结果要是不一样，那要不就是A错，要不就是B错，要不就是都错了。这个时候人工干预的方式修改方法。</p><h3 id="递归行为下时间复杂度的计算"><a href="#递归行为下时间复杂度的计算" class="headerlink" title="递归行为下时间复杂度的计算"></a>递归行为下时间复杂度的计算</h3><h4 id="求取中点的方法"><a href="#求取中点的方法" class="headerlink" title="求取中点的方法"></a>求取中点的方法</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int mid&#x3D;L+((R-L)&gt;&gt;1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    为什么这样书写：防止R+L溢出int上限、</p><h4 id="使用递归求解数组最大值："><a href="#使用递归求解数组最大值：" class="headerlink" title="使用递归求解数组最大值："></a>使用递归求解数组最大值：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">L</span><span class="token operator">==</span><span class="token class-name">R</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token class-name">L</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> leftMax<span class="token operator">=</span><span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token class-name">L</span><span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightMax<span class="token operator">=</span><span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">,</span>rightMax<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个写法我们是在二分类是常用的：先处理递归左边，再递归处理右边，最后从小到大的返回各层的最大值，最后得到整体的最大值。下面也有C++版本的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;Windows.h&gt;class Finder &#123;public:int getMax(std::vector&lt;int&gt; s) &#123;return Dofindmax(s, 0, s.size()-1);&#125;int Dofindmax(std::vector&lt;int&gt; s, int left, int right)&#123;if (left &#x3D;&#x3D; right)return s[left];int mid &#x3D; left + ((right - left) &gt;&gt; 1);int leftMax &#x3D; Dofindmax(s, left, mid);int rightMax &#x3D; Dofindmax(s, mid + 1, right);return leftMax &gt; rightMax ? leftMax : rightMax;&#125;&#125;;void PrintVector(std::vector&lt;int&gt; s)&#123;for (std::vector&lt;int&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;std::cout&lt;&lt;std::endl;&#125;int getRandNum()&#123;srand((unsigned int)clock());Sleep(10);return rand() % 100;&#125;int main()&#123;std::vector&lt;int&gt; s;for (int i &#x3D; 0; i &lt; 10; i++)s.push_back(getRandNum());PrintVector(s);Finder f;int t &#x3D; f.getMax(s);std::cout &lt;&lt; t;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，别太常用，因为容易把栈搞炸</p><p><img src="image-20230127160815732.png" alt="image-20230127160815732"></p><p>画个递归树</p><h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><script type="math/tex; mode=display">if:T(N)=a*T(\frac{N}{b})+O(N^d)</script><script type="math/tex; mode=display">then:1)\log_ba>d->T(N^{\log_ba})</script><script type="math/tex; mode=display">2)\log_ba=d->T(N^{d}log N)</script><script type="math/tex; mode=display">3)\log_ba<d->T(N^{d})</script><p>有人话版本吗？有的：就是说我们的一次递归可以拆分一个问题为b个子问题，当然右额外开销$N^d$,这样，我们就有分层级讨论：比较$\log_ba$与d的大小从而一步写出公式。</p><p>以上面为例：上面的问题把问题拆成两个子问题：b=2,并且在单个函数体内调用了两次：a=2,剩下的时间复杂度为O(1).这下，我们的公式就是：</p><script type="math/tex; mode=display">T(N)=2*T(N/2)+O(1)</script><p>这样就直接带入公式:T(N)=O(logn).</p><h3 id="补充Reading"><a href="#补充Reading" class="headerlink" title="补充Reading"></a>补充Reading</h3><p>​        平时设计或者阅读一个算法的时候，必然会提到算法的复杂度（包括时间复杂度和空间复杂度）。比如我们说一个二分查找算法的平均时间复杂度为 O(log n)，快速排序可能是 O(n log n)。那这里的 O 是什么意思？这样的表达是否准确呢？</p><p>​        今天来复习一下与算法复杂度相关的知识：函数渐进阶，记号 O、Ω、θ和 o；Master 定理。</p><p>​        先插一句，在算法复杂度分析中，log 通常表示以 2 为底的对数。</p><p>​        算法复杂度（算法复杂性）是用来衡量算法运行所需要的计算机资源（时间、空间）的量。通常我们利用渐进性态来描述算法的复杂度。</p><p>​        用 n 表示问题的规模，T(n) 表示某个给定算法的复杂度。所谓渐进性态就是令 n→∞ 时，T(n) 中增长最快的那部分。严格的定义是：如果存在 $T’(n)$，当 n→∞ 时，有:</p><script type="math/tex; mode=display">\frac{T(n)-T'(n)}{T(n)}\rightarrow 0</script><p>​        我们就说$T’(n)$是 T(n) 当 n→∞ 时的渐进性态。</p><p>​        比如 T(n) = 2 <em> n ^ 2 + n log n + 3，那么显然它的渐进性态是 2 </em> n ^ 2，因为当 n→∞ 时，后两项的增长速度要慢的多，可以忽略掉。引入渐进性态是为了简化算法复杂度的表达式，只考虑其中的主要因素。当比较两个算法复杂度的时候，如果他们的渐进复杂度的阶不相同，那只需要比较彼此的阶（忽略常数系数）就可以了。</p><p>​        总之，分析算法复杂度的时候，并不用严格演算出一个具体的公式，而是只需要分析当问题规模充分大的时候，复杂度在渐进意义下的阶。记号 O、Ω、θ和 o 可以帮助我们了解函数渐进阶的大小。</p><p>​        假设有两个函数 f(n) 和 g(n)，都是定义在正整数集上的正函数。上述四个记号的含义分别是：</p><ul><li>f(n) = O(g(n))：$∃c&gt;0,n_0∈N,∀n≥n_0,f(n)≤cg(n)$；f 的阶<strong>不高于</strong> g 的阶。</li><li>f(n) = Ω(g(n))：$∃c&gt;0,n_0∈N,∀n≥n_0,f(n)≥cg(n)$；f 的阶<strong>不低于</strong> g 的阶。</li><li>f(n) = θ(g(n))：⟺$f(n)=O(g(n))\&amp;\&amp;f(n)=Ω(g(n))$；f 的阶<strong>等于</strong> g 的阶。</li><li>f(n) = o(g(n))：$∀\varepsilon&gt;0,∃n_0∈N,∀n≥n_0,f(n)/g(n)&lt;\varepsilon$；f 的阶<strong>低于</strong> g 的阶。</li></ul><p>​        可见，记号 O 给出了函数 f(n) 在渐进意义下的上界（但不一定是最小的），相反，记号Ω给出的是下界（不一定是最大的）。如果上界与下界相同，表示 f(n) 和 g(n) 在渐进意义下是同阶的（θ），亦即复杂度一样。</p><p>​        列举一些常见的函数之间的渐进阶的关系：</p><p><img src="image-20230127163435272.png" alt="image-20230127163435272"></p><p>​        有些人可能会把这几个记号跟算法的最坏、最好、平均情况复杂度混淆，它们有区别，也有一定的联系。</p><p>​        即使问题的规模相同，随着输入数据本身属性的不同，算法的处理时间也可能会不同。于是就有了最坏情况、最好情况和平均情况下算法复杂度的区别。它们从不同的角度反映了算法的效率，各有用处，也各有局限。</p><p>​        有时候也可以利用最坏情况、最好情况下算法复杂度来粗略地估计算法的性能。比如某个算法在最坏情况下时间复杂度为θ(n ^ 2)，最好情况下为θ(n)，那这个算法的复杂度一定是 O(n ^ 2)、Ω(n) 的。也就是说 n ^ 2 是该算法复杂度的上界，n 是其下界。</p><p>​        接下来看看 Master 定理。</p><p>​        有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的：</p><p>​        设常数 a &gt;= 1，b &gt; 1，f(n) 为函数，T(n) 为非负整数，T(n) = a T(n / b) + f(n)，则有：</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230127163457999.png" alt="image-20230127163457999"></p><p>​        比如常见的二分查找算法，时间复杂度的递推方程为 T(n) = T(n / 2) + θ(1)，显然有 $n^{\log _b^a}⁡=n^0=Θ(1)$，满足 Master 定理第二条，可以得到其时间复杂度为 T(n) = θ(log n)。</p><p>​        再看一个例子，T(n) = 9 T(n / 3) + n，可知 $n^{\log_b^a}=n^2$，令ε取 1，显然满足 Master 定理第一条，可以得到 T(n) = θ(n ^ 2)。</p><p>​        来一个稍微复杂一点儿例子，T(n) = 3 T(n / 4) + n log n。$n^{\log_b^a}=O(n^{0.793})$，取ε = 0.2，显然当 c = 3 / 4 时，对于充分大的 n 可以满足 a <em> f(n / b) = 3 </em> (n / 4) <em> log(n / 4) &lt;= (3 / 4) </em> n <em> log n = c </em> f(n)，符合 Master 定理第三条，因此求得 T(n) = θ(n log n)。</p><p>​        运用 Master 定理的时候，有一点一定要<strong>特别注意</strong>，就是第一条和第三条中的ε必须<strong>大于零</strong>。如果无法找到大于零的ε，就不能使用这两条规则。</p><p>​        举个例子，T(n) = 2 T(n / 2) + n log n。可知 $n^{\log_b^a}=n$，而 f(n) = n log n，显然不满足 Master 定理第二条。但对于第一条和第三条，也无法找到大于零的ε使得 nlog⁡n=O$(n^{1−\varepsilon})$ 或者Ω$(n^{1−\varepsilon})$，因此不能用 Master 定理求解，只能寻求别的方式求解。比如可以利用递归树求出该算法的复杂度为 $T(n)=O(n\log^2n)$。简单的说一下计算过程：</p><p>​        递归树的建立过程，就像是模拟算法的递推过程。树根对应的是输入的规模为 n 的问题，在递归处理子问题之外，还需要 n log n 的处理时间。然后根据递推公式给根节点添加子节点，每个子节点对应一个子问题。这里需要两个子节点，每个节点处理规模为 n / 2 的问题，分别需要 (n / 2) <em> log(n / 2) 的时间。因此在第二层一共需要 n </em> (log n - 1) 的时间。第三层节点就是将第二层的两个节点继续分裂开，得到四个各需要 (n / 4) <em> log(n / 4) 时间的节点，总的时间消耗为 n </em> (log n - 2)。依此类推，第 k（设树根为 k = 0）层有 2 ^ k 的节点，总的时间为 n * (log n - k)。而且可以知道，这棵树总共有 log n 层（最后一层每个节点只处理规模为 1 的子问题，无须再分治）。最后将每一层消耗的时间累加起来，得到：</p><p><img src="image-20230127163854294.png" alt="image-20230127163854294"></p><h3 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h3><p>​        1）整体就很简单，就是一个简单的递归，左边排好序，右边排好序，然后整体就有序。</p><p>​        2）让其整体有序的方式用了排外序方法</p><p>​        3）继续使用master公式求解:$O(N\log N)$，空间复杂度O(N)</p><p>​        4）归并排序的实质</p><p>思路</p><p><img src="image-20230127164408704.png" alt="image-20230127164408704"></p><p>​        对于一块区域，我们使用指针访问：左右双指针法。开辟一块小空间，如果左边的大于右边的，左边指针拷贝同时指针后移一个，右边大于左边的同理。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Solution&#123;    public static void mergeSort(int[] arr)    &#123;        if(arr&#x3D;&#x3D;null||arr.length&lt;2)            return;        process(arr,0,arr.length-1);    &#125;    public static void process(int[] arr,int L, int R)    &#123;        if(L&#x3D;&#x3D;R)            return;      int mid &#x3D; left + ((right - left) &gt;&gt; 1);        process(arr,L,mid);        process(arr,mid+1,R);        merge(arr,L,mid,R);    &#125;    public static void merge(int[] arr,int L,int M,int R)&#123;        int[] helpSort&#x3D;new int[R-L+1];&#x2F;&#x2F;这是辅助空间        int i&#x3D;0;        int p1&#x3D;L;        int p2&#x3D;M+1;&#x2F;&#x2F;划分区域        while(p1&lt;&#x3D;M&amp;&amp;p2&lt;&#x3D;R)&#123;            helpSort[i++]&#x3D;arr[p1]&lt;&#x3D;arr[p2]?arr[p1++]:arr[p2++];            &#125;        while(p1&lt;&#x3D;M)&#123;           helpSort[i++]&#x3D;arr[p1++];        &#125;        while(p2&lt;&#x3D;R)&#123;            helpSort[i++]&#x3D;arr[p2++];        &#125;        for(i&#x3D;0;i&lt;helpSort.length;i++)&#123;            arr[L+i]&#x3D;helpSort[i];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std; void Merge(int arr[],int low,int mid,int high)&#123;    &#x2F;&#x2F;low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素    int i&#x3D;low,j&#x3D;mid+1,k&#x3D;0; &#x2F;&#x2F;mid+1为第2有序区第1个元素，j指向第1个元素    int *temp&#x3D;new(nothrow) int[high-low+1]; &#x2F;&#x2F;temp数组暂存合并的有序序列    if(!temp)&#123; &#x2F;&#x2F;内存分配失败        cout&lt;&lt;&quot;error&quot;;        return;    &#125;    while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;high)&#123;        if(arr[i]&lt;&#x3D;arr[j]) &#x2F;&#x2F;较小的先存入temp中            temp[k++]&#x3D;arr[i++];        else            temp[k++]&#x3D;arr[j++];    &#125;    while(i&lt;&#x3D;mid)&#x2F;&#x2F;若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中        temp[k++]&#x3D;arr[i++];    while(j&lt;&#x3D;high)&#x2F;&#x2F;同上        temp[k++]&#x3D;arr[j++];    for(i&#x3D;low,k&#x3D;0;i&lt;&#x3D;high;i++,k++)&#x2F;&#x2F;将排好序的存回arr中low到high这区间arr[i]&#x3D;temp[k];    delete []temp;&#x2F;&#x2F;删除指针，由于指向的是数组，必须用delete []&#125; &#x2F;&#x2F;用递归应用二路归并函数实现排序——分治法void MergeSort(int arr[],int low,int high)&#123;    if(low&lt;high)&#123;        int mid&#x3D;(low+high)&#x2F;2;        MergeSort(arr,low,mid);        MergeSort(arr,mid+1,high);        Merge(arr,low,mid,high);    &#125;&#125; int main()&#123;    int a[10]&#x3D;&#123;5,1,9,3,7,4,8,6,2,0&#125;;    MergeSort(a,0,9);    for(int i&#x3D;0;i&lt;10;i++)        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展我们的归并排序问题"><a href="#扩展我们的归并排序问题" class="headerlink" title="扩展我们的归并排序问题"></a>扩展我们的归并排序问题</h3><p>​        小和问题：对一个数组中，每个数左边比当前数小的数累加起来，叫做这个数的小和：请写一个程序：求解一个数组的小和。</p><p>Example:[1,3,4,2,5]产生的单个小和是[0,1,4,1,10],故数组的小和是16.</p><p>​        逆序问题：在一个数组中，左边的数如果比右边的数大，则这连哥哥数构成一个逆序对，请打印所有的逆序对。</p><p>​        （1）暴力解法是很简单的：对于位置i直接暴力遍历，但是$O(N^2)$</p><p>​        有没有更快的：有！</p><p>​        仔细思考一下：我们的小和可以这样产生！看一个数右边走，如果有别的数大于它就加一次这个数本身。如[1,3,4,2,5]：看1，右边四个数比他大，就加四次1，看3，右边两个数比他大，就加两个3，依次类推。。。</p><p>​        现在，我们对全数组进行二分。针对拆分后的数组一级一级使用我们新的求小和的过程，我们在比较的同时也排序：如：[1，3，4，2，5]下，拆分成2级[1,3,4]和[2,5]，然后又是:[1,3] [4]  和[2]  [5]最后是:[1] [3] [4] [2] [5]，现在返回去合并：[1,3]产生小和1，[1,3,4]产生1个1，1个3，（左侧小，左侧加小和，左侧移动指针到下一个，于是产生）[2,5]合并产生一个2，之后再次合并产生一个1，一个3，一个4，现在完事了：1+1+1+3+2+1+3+4=16</p><p>​        这个算法为什么是O(NlogN),就是因为排序的时候不需要在暴力遍历之后才知道有几个数比当前的数小。这才省略了新的遍历。</p><p>​        可能不一样的是：在这题里面，我们必须在左右数字相等的时候先拷贝右边的，再拷贝左边的.</p><p>​        （2）类似的，仍可以使用mergeSort，也就是说，只要产生小和操作就是说明产生了逆序。我们只要统计这个就好了</p><p>​        荷兰国旗问题：指定一个数，比他大的放右边，小的放左边，但是注意空间复杂度O(1)</p><p>​        思路：我们把使用两个指针。把小于num的放到左边，与小于区的下一个数字直接交换就好了。这样小于区右扩，否则指针直接右移。</p><p>​        荷兰国旗问题（2）：指定一个数，比他大的放右边，小的放左边，相等的放中间。但是注意空间复杂度O(1)</p><p>​        </p><p>​        还是类似，只不过有趣的是我们可以：</p><p>​        小于：[i]和小于区域的下一个交换，小于区东扩</p><p>​        相等：直接++</p><p>​        大于：[i]和大于区域的上一个交换，大于区西扩，但是i不动（我们还没排序那个交换过来的数嘞！）。</p><p>看看代码实现（看2就好了）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void swap(int* e1, int* e2)&#123;int temp &#x3D; *e1;*e1 &#x3D; *e2;*e2 &#x3D; temp;&#125;typedef struct Pair_ &#123;int pair1;int pair2;&#125;Pair;void arrangeArray(Pair* pair, int* arr, int arrsize,int sortnum)&#123;if (!pair &amp;&amp; !arr)return;if (arrsize &lt; 0)return;int* smaller &#x3D; &amp;arr[-1];int* bigger &#x3D; &amp;arr[10];int* check &#x3D; arr;while (check &lt; bigger)&#123;if (*check &lt; sortnum)&#123;swap(check, smaller + 1);check++;smaller++;&#125;else if (*check &#x3D;&#x3D; sortnum)&#123;check++;&#125;else&#123;swap(check, bigger - 1);bigger--;&#125;&#125;pair-&gt;pair1 &#x3D; smaller - arr;pair-&gt;pair2 &#x3D; bigger - arr;&#125;void PrintArr(int* arr, int arr_size)&#123;for (int i &#x3D; 0; i &lt; arr_size; i++)&#123;printf(&quot;%d &quot;, arr[i]);&#125;printf(&quot;\n&quot;);&#125;int main()&#123;int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;PrintArr(arr, 10);Pair* p&#x3D;(Pair*)malloc(sizeof(Pair));p-&gt;pair1 &#x3D; 0;p-&gt;pair2 &#x3D; 0;arrangeArray(p, arr, 10, 5);PrintArr(arr, 10);printf(&quot;%d\n&quot;, arr[p-&gt;pair1]);printf(&quot;%d\n&quot;, arr[p-&gt;pair2]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        C++:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;class Array &#123;public:void initVal(int* arr, int size) &#123;int* arrayData &#x3D; new int[size];for (int i &#x3D; 0; i &lt; size; i++)&#123;arrayData[i] &#x3D; arr[i];&#125;arraydata &#x3D; arrayData;arraysize &#x3D; size;&#125;void swapPartialData(int swap1,int swap2)&#123;int temp &#x3D; arraydata[swap1];arraydata[swap1] &#x3D; arraydata[swap2];arraydata[swap2] &#x3D; temp;&#125;void arrangeandSort(int sortnum)&#123;int smaller &#x3D; -1;int bigger &#x3D; arraysize;int check &#x3D; 0;while (check &lt; bigger)&#123;if (arraydata[check] &lt; sortnum)&#123;swapPartialData(check, smaller + 1);check++;smaller++;&#125;else if (arraydata[check] &#x3D;&#x3D; sortnum)&#123;check++;&#125;else&#123;swapPartialData(check, bigger - 1);bigger--;&#125;&#125;&#125;void PrintVal()&#123;for (int i &#x3D; 0; i &lt; arraysize; i++)&#123;std::cout &lt;&lt; arraydata[i] &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl;&#125;private:int* arraydata;int arraysize;&#125;;int main()&#123;int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;Array a;a.initVal(arr, 10);a.PrintVal();a.arrangeandSort(5);a.PrintVal();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>​        快速排序请先把上面的代码琢磨明白：快速排序使得我们以一个数区分好了左右，排除掉标杆数我们只要对左右再次区分直到一个尽头结束。这次我们直接拿最后一个数当作标杆进行快排，这样我们就使得整个数组有序了。</p><p>​        这个思想还可以进一步优化：直接把标杆数（最后一个）直接放到中间，左右再递归。</p><p>​        当然，这个时间复杂度很不稳定：当划分值再中间的时候：</p><script type="math/tex; mode=display">T(n)=2T(\frac{T}{2})+O(N)</script><p>​        但是如果划分值再最左边和最右边：则就是经典排序为O($N^2$)。</p><p>​        我们继续改进：如果我们在一个划分区域随机选一个数，是不是就更多的避免了总是遇到最差情况？是的，这就是随机快速排序。这下，我们就可以</p><p><img src="image-20230130193038830.png" alt="image-20230130193038830"></p><p>​        对所有的情况求时间期望:$O(N\log N)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Pycharm</title>
      <link href="/2023/01/29/Opencv-in-Pycharm/"/>
      <url>/2023/01/29/Opencv-in-Pycharm/</url>
      
        <content type="html"><![CDATA[<h1 id="Pycharm下的opencv使用1：基本图像操作导论"><a href="#Pycharm下的opencv使用1：基本图像操作导论" class="headerlink" title="Pycharm下的opencv使用1：基本图像操作导论"></a>Pycharm下的opencv使用1：基本图像操作导论</h1><h3 id="在Pycharm中导入opencv"><a href="#在Pycharm中导入opencv" class="headerlink" title="在Pycharm中导入opencv"></a>在Pycharm中导入opencv</h3><p>​        笔者被C++实现的opencv干到心态炸裂了，所以这里先整一篇基于python的opencv的博客。</p><p>​        在pycharm中导入opencv很容易：只需要在Project的setting里给解释器安装上opencv-python库就好了。使用这个程序跑一下看看可不可以读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#向工程文件下新建一个img文件夹,放好你的图片，我这里放的是test.png</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230129194508512.png" alt="image-20230129194508512"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2img_path<span class="token operator">=</span><span class="token string">"img/test.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Test img can be shown below!"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        跳出这个即为成功！开始你的opencv的欢乐时间！</p><p><img src="image-20230129194919800.png" alt="image-20230129194919800"></p><h3 id="计算机眼中的图片"><a href="#计算机眼中的图片" class="headerlink" title="计算机眼中的图片"></a>计算机眼中的图片</h3><p>​        在计算机眼中，图像由矩阵构成</p><p><img src="image-20230115212443109.png" alt="image-20230115212443109"></p><p>​        </p><p>​        数值的大小表明了图像的亮度，而通道表明了一个颜色：一个R通道上的255表明这是在Red上很亮</p><p>​        下面，我们来介绍一下我们应该怎么读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment">#不同于RGB，我们读取的格式是BGR</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#caution:the input should be the addr of the img</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取的结果是：一个nd array</p><p>好抽象：可不可以直接展示图片啊：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们试一下这个：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> showimg <span class="token keyword">as</span> simg<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'1.png'</span><span class="token punctuation">)</span>simg<span class="token punctuation">.</span>imgshow<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以封装一个函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cv_show</span><span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span>     cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以查看一个图片的大小：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>shape<span class="token comment">#(175, 286, 3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以设置读入的方式：比如说读入灰度图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span>，cv2<span class="token punctuation">.</span>IMREAD_GREYSCALE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存我们产出的图像</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">'savedfilename'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 可以计算像素点的个数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>​        视频由图像组成，也就是说，我们可以读取视频：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">vc<span class="token operator">=</span>cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">'videofilepath'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们是不是读取成功了？这个看如下的代码判断：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> vc<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">open</span><span class="token punctuation">.</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token builtin">open</span><span class="token operator">=</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们来运行的读取视频</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> <span class="token builtin">open</span><span class="token punctuation">:</span>ret<span class="token punctuation">,</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> frame <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">if</span> ret<span class="token operator">==</span><span class="token boolean">True</span><span class="token punctuation">:</span>        gray<span class="token operator">=</span>cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>frame<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">,</span>gray<span class="token punctuation">)</span>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token operator">==</span><span class="token number">27</span><span class="token punctuation">:</span><span class="token comment">#按下ESC退出或者视频播放完毕</span>            <span class="token keyword">break</span>vc<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="截取部分图片（ROI）"><a href="#截取部分图片（ROI）" class="headerlink" title="截取部分图片（ROI）"></a>截取部分图片（ROI）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imgread<span class="token punctuation">(</span><span class="token string">'Path'</span><span class="token punctuation">)</span>cat<span class="token operator">=</span>img<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">]</span>cv_show<span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span>cat<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样我们就利用切片截取了部分图片了.</p><h3 id="颜色通道提取"><a href="#颜色通道提取" class="headerlink" title="颜色通道提取"></a>颜色通道提取</h3><p>我们可以分离图片，通过不同的颜色通道提取：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token operator">=</span>cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是效果：1，2，3分别代表b,g,r</p><p><img src="2.png" alt="2"> </p><p>1:</p><p><img src="b.png" alt="b"></p><p>2:</p><p><img src="g.png" alt="g"></p><p>3:<img src="r.png" alt="r"></p><p>当然也可以合回去：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以单独保留，直接修改：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#只保留R</span>cur_img<span class="token operator">=</span>img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span>cur_img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><p>我们可以扩充图像，通过一些方式来对图像进行扩充：请看这里：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token comment">#定位点</span>replicate<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REPLICATE<span class="token punctuation">)</span>reflect<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT<span class="token punctuation">)</span>reflect101<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT_101<span class="token punctuation">)</span>wrap<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_WRAP<span class="token punctuation">)</span>constant<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span>value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们得到了五张图像，随后，我们使用imwrite输出图像，同时导入matplotlib的pyplot子库进行观察：</p><p>​        这是总的效果：</p><p><img src="matplot_version.png" alt="matplot_version"></p><p>​         仔细观察：</p><p><img src="replicate.png" alt="replicate"></p><p><img src="reflect.png" alt="reflect"></p><p><img src="reflect101.png" alt="reflect101"></p><p><img src="wrap.png" alt="wrap"></p><p><img src="constant.png" alt="constant"></p><p>​        第一张图是展示了</p><p>​        replicate：这个单词是复制的意思：直接复制最边缘的像素</p><p>​        reflect：对感兴趣的部分进行两边复制：fedcba|abcdef|fedcba</p><p>​        reflect101:但是是对最边缘的像素为对称轴进行复制:gfedcba|abcdefgh|gfedcba</p><p>​        wrap:外包装：cdefgh|abcdefgh|abcdefg</p><p>​        constant:对图像以默认黑值填充</p><h3 id="对图像进行数值操作"><a href="#对图像进行数值操作" class="headerlink" title="对图像进行数值操作"></a>对图像进行数值操作</h3><p>​        我们可以对numpy进广播操作。人话翻译成C++就是cv2库重载了运算符号，使之我们可以对矩阵进行广义的加法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'cat.jpg'</span><span class="token punctuation">)</span>img_cat_GeneralAdd<span class="token operator">=</span>img_cat<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>img_cat<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>img_cat2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        在控制台上输出就可以发现矩阵里每一个数值都加上了一个10。</p><p><img src="image-20230129191422226.png" alt="image-20230129191422226"></p><p>​        （懒得自己跑，截个图）</p><p>​        那可不可以狭义相加呢？当然可以，结合线性代数的常识，相加的矩阵必须满足大小完全一致。假设我们已经满足了这个前提，直接相加得到的结果是不是就是放到矩阵的值呢？</p><p>​        显然不是！因为RGB有界，不可以超过255.在重载的+中，矩阵的RGB值自动%256，就是除以2256取它的余数放到矩阵里。那还有别的加法吗？有：使用方法add，传入cv2.add(img_cat,img_cat2)就可以了，达到255之后就不会取模，只会停在255不动</p><h3 id="图像叠加"><a href="#图像叠加" class="headerlink" title="图像叠加"></a>图像叠加</h3><p>​        我们也可以对图像进行叠加。但是注意，我们首先要调整图像大小一致：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token punctuation">.</span>shapeimg_dog<span class="token operator">=</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token comment"># path是路径</span>img_dog<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_dog<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token operator">*</span>size required to resize<span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230129192417117.png" alt="image-20230129192417117"></p><p>​        同样的还有其他resize方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">required_pic<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_required_resize<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>fx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>fy<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是个什么玩意呢？指的是我们依照某个点把图像在X轴上拉长3倍数，Y轴不变。</p><p>​        现在，我们使用addWeighted来叠加图像，以混合图片特征。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res<span class="token operator">=</span>cv2<span class="token punctuation">.</span>addWeighted<span class="token punctuation">(</span>img_cat<span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">,</span>img_dog<span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#img_cat*0.4+img_dog*0.6+0//最后一项是亮度提升</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h3><p>​        我们可以使用一些参数，对图像进行有条件的处理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ret<span class="token punctuation">,</span>dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>src<span class="token punctuation">,</span>thresh<span class="token punctuation">,</span>maxval<span class="token punctuation">,</span><span class="token builtin">type</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>src:输入，只能输入单通道图像，通常是灰度图</p><p>dst：输出图</p><p>thresh:执行阈值</p><p>maxval:超过或小于阈值后所赋予的值</p><p>type:方法，如下：</p><p>1.cv2.THRESH_BINARY：超过阈值的取maxval,否则取0</p><p>2.cv2.THRESH_BINARY_INV反过来</p><p>3.THRESH_TRUNC大于阈值的设置成阈值</p><p>4.THRESH_TOZERO大于阈值的不变，否则设置成0</p><p>5.THRESH_TOZERO_INV反转</p><p>我们依旧使用matplotlib的pyplot库放送一下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'2.png'</span><span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY_INV<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh3<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TRUNC<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh4<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh5<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO_INV<span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original Image'</span><span class="token punctuation">,</span><span class="token string">'BINARY'</span><span class="token punctuation">,</span><span class="token string">'BINARY_INV'</span><span class="token punctuation">,</span><span class="token string">'THRESH_TRUNC'</span><span class="token punctuation">,</span><span class="token string">'TOZERO'</span><span class="token punctuation">,</span><span class="token string">'TOZERO_INV'</span><span class="token punctuation">]</span>images<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>thresh1<span class="token punctuation">,</span>thresh2<span class="token punctuation">,</span>thresh3<span class="token punctuation">,</span>thresh4<span class="token punctuation">,</span>thresh5<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看：</p><p><img src="Figure_1.png" alt="Figure_1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学随记(1)</title>
      <link href="/2023/01/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学教程笔记1"><a href="#高等数学教程笔记1" class="headerlink" title="高等数学教程笔记1"></a>高等数学教程笔记1</h1><h2 id="极限运算与函数分析基础"><a href="#极限运算与函数分析基础" class="headerlink" title="极限运算与函数分析基础"></a>极限运算与函数分析基础</h2><h4 id="函数与极限"><a href="#函数与极限" class="headerlink" title="函数与极限"></a>函数与极限</h4><p>函数部分主要是奠基于高中的一些基础，这里做一些简单的复习</p><p>1.映射与函数</p><p>首先来了解以下映射：4</p><p>​        先定义X，Y是两个非空集合。现在有一个法则f，使得X中的每个元素$x$（$X$={$x_0$,$x_1$,$x_2$,…}）,都有<strong>唯一</strong>的y($Y$={$y_0$,$y_1$,$y_2$,$y_3$,…})与之对应。那么，我们称f是一个<strong>映射</strong>。</p><p>​        也就是说，这个定义是围绕f的。他是一个这样的法则（或者说规则）让两个非空的集合建立起如定义所言的联系，仅此而已。</p><p>​        也不必太过担心，映射在这本笔记里大概不会再次出现了。</p><p>不过，我们把它引出来必有我们的目的：回过头来，我们实际上用一大长串定义干了这样一件事：</p><script type="math/tex; mode=display">{X}\xrightarrow{f}Y</script><p>现在，让我们开始取其名字：</p><p>X：是一个定义域，有写法D,或者写法更明确一些：$D_f$</p><p>实际上这是Domain的意思</p><p>Y：是一个值域，有写法R,或者同样更明确一些：$R_f$</p><p>实际上这是Range的意思。</p><p>至于：f，我们刚刚讲过了，这就是一个法则，表明一种对应关系。</p><p>依然有这样的更简单的写法：</p><script type="math/tex; mode=display">X\xrightarrow{f}R_f</script><p>重复一些以下的要点：</p><p>（1）上述定义阐述了三要素：X（定义域），f(法则)，Rf(对应值域)</p><p>（2）对于x属于X这回事，对应的y是唯一的。不可以又对应y1同时对应y2.</p><p>Q:可以多个x对应一个y吗？可以！事实上，用图片表示是这样的：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221226141035208.png" alt="image-20221226141035208"></p><p>（3）Rf属于Y，但不是Y！！！但特别的：当Rf=Y下，我们又称这样厉害的f叫满射。</p><p>（4）在众多的映射中，还有一种特殊的映射：单射。人话就是一一对应</p><p>（5）那么，又是单射又是满射如何？这又有名字：一一映射（一夫一妻）因为必须全部对应且一一对应。</p><p>正过来叫映射，倒过来又如何？</p><p>设 f有如下关系：</p><script type="math/tex; mode=display">X\longrightarrow{Y}</script><p>是一个单射，那么，我们可以倒过来：对于Y属于Rf而言都有唯一的一个$x$属于$X$.这又是一组对应关系，不过是倒过来的。记作如下：</p><script type="math/tex; mode=display">g:R_f\longrightarrow{X}</script><p>这样看不出什么联系，我们采用与 f 相关的表示：</p><script type="math/tex; mode=display">f^-1:D_{f^-1}\longrightarrow{D_f}</script><p>好吧，太复杂了，好好回味一下，我们继续折磨：</p><p>现在我们来看这样一个内容：</p><p>在学习完映射之后，我们来看这样的一个D(定义域),且</p><script type="math/tex; mode=display">D\subset{R}</script><p>换而言之，这个数集是R里的一部分，而f是一个使得：</p><script type="math/tex; mode=display">f:D\longrightarrow{R}</script><p>的映射。</p><p>那么，这样来看我们构造了一个映射使得一个实数集映射到了另一个实数集上。这样的映射有一个大家熟悉的名字：函数，简记作：</p><script type="math/tex; mode=display">y=f(x),x\in{D}</script><p>这下看懂了：</p><p>x是一个自变量，y是一个因变量 ，定义域为D，值域是R（不是实数集的R！！！）</p><p>构成一个函数的两要素，就可以从动态的角度来看了，这使得我们信息的表达可以更为浓缩：$D_f$ ,$ f$ 就可以了</p><p>函数的表达有三种：表格法，图形法，解析法。这个是大家高中就已经熟知的了</p><p>说完了定义和表示，我们来看一个函数最广泛的几个性质：</p><h4 id="1-有界性"><a href="#1-有界性" class="headerlink" title="1.有界性"></a>1.有界性</h4><p>听名字就知道：表明的是一些函数可能是有界限的。但这样的表达不规范。</p><p>仔细思考，函数的界限分为两种：不大于一个数和不小于一个数（当然，也可以说是小于一个数或者是大于一个数）</p><p>那么，我们说：对于总是一个小于一个数或者是不大于一个数的函数，我们说他有上界。表达是这样的：</p><script type="math/tex; mode=display">\exists{k_1},f(x)\leqslant{k_1}</script><p>这是什么东西呢？先别急，它还有另一个符号，也是在数学中相当常见的：$\exists$ , $\forall$</p><p>上面的两个符号，一个表示：存在；另一个表示任意。</p><p>那么，上界是唯一的吗？不是的。比如说：</p><script type="math/tex; mode=display">f(x)=x , x\in{(-\infty,1]}</script><p>这就有无穷个上界：可以是1，可以是2，可以是$\pi$…总而言之，并不唯一。</p><p>那么与之对应的，还会有一个下界：</p><script type="math/tex; mode=display">\exists{k_2} ,f(x)\geqslant{k_2}</script><p>我们说：对于总是一个大于一个数或者是不小于一个数的函数，我们说他有下界。</p><p>同样的，下界也不唯一。</p><p>这在我们后面证明极限的存在时是很有必要的！！！</p><p>统称起来，我们就可以说：函数是有界的：上下界都有！总而言之，这种情况称为有界的。反之，一个函数若是既没有上界有没有下界，或者是只有上界，或者是只有下界，则称这个函数无界。用数学符号定义有界是这样的：</p><script type="math/tex; mode=display">\exists M>0,|f(x)|\leqslant{M}</script><p>那么，无界的是这样定义的：</p><script type="math/tex; mode=display">\forall{M}>0,\exists x_1\in{x},|f(x)|>M</script><h4 id="2-单调性"><a href="#2-单调性" class="headerlink" title="2.单调性"></a>2.单调性</h4><p>这个性质是讨论函数的变化趋势的：是增加还是减少？我们用这个性质衡量：</p><p>当在一个区间里：</p><script type="math/tex; mode=display">x_1<x_2,f(x_1)<f(x_2)</script><p>这样的性质叫单调递增，</p><p>反之：</p><script type="math/tex; mode=display">x_1 < x_2,f( x_1 )>f( x_2 )</script><p>这样的性质叫单调递减，但是注意，这称之为严格单调，后面我们会讲述什么是严格单调什么是广义单调的。</p><h4 id="3-奇偶性"><a href="#3-奇偶性" class="headerlink" title="3.奇偶性"></a>3.奇偶性</h4><p>首先声明一点：我们的函数的定义域必须对称：也就是说：函数的$D_f$必须关于原点对称：</p><p>实数域$R$是对称的，$[-1,1]$是对称的，以此类推。当：$f(x)=f(-x)$时，我们称呼这样的函数是一个偶函数，反之：$f(-x)=-f(x)$或者$-f(-x)=f(x)$ 则称之为奇函数。</p><p>有趣的是：在图像法表达函数时：奇函数关于原点对称，偶函数关于$y$轴对称。</p><h4 id="4-周期性"><a href="#4-周期性" class="headerlink" title="4.周期性"></a>4.周期性</h4><p>有一些函数很有意思，伴随$x$的增大，我们甚至可以看到$f(x)$会有周期的重现。这时候，我们说这个函数具有周期性，用数学语言的表达是如下的：</p><script type="math/tex; mode=display">\exists l>0 , f(x+l)=f(x)</script><p>这个$l$就是周期，同时，我们讨论的周期常常是最小正周期。</p><p>比如说：</p><script type="math/tex; mode=display">y=\sin(x)</script><p>这个函数的（最小正）周期就是2$\pi$。</p><p>但是，不是所有的函数都有最小的正周期。如</p><script type="math/tex; mode=display">D(x)=\begin{cases}1 &  x\in{Q}\\ 0 & x\in{Q^C} \\\end{cases}</script><h4 id="5-反函数"><a href="#5-反函数" class="headerlink" title="5.反函数"></a>5.反函数</h4><p>有点像逆映射的感觉了：</p><p>设$f:D\rightarrow{f(D)}$是一个单射，且$f$单调 则有$f^-1:f(D)\rightarrow{D}$ ，且$f^-1$单调，单调性跟 $f$一致</p><p>那么称$x=f^-1(y)$ 是$y=f(x)$的反函数，且这两个函数的图像是关于$y=x$对称的</p><h4 id="6-复合函数"><a href="#6-复合函数" class="headerlink" title="6.复合函数"></a>6.复合函数</h4><p>引入两个函数：$y=f(t) , t=g(x)$ ,把$t$换成$g(x)$，我们就得到了一个复合函数$f(g(x))$。</p><p>值得注意的是：我们如此操作是把 $t =g(x)$视作了一个自变量， $t$的取值范围（f(x)的自变量范围）由我们的$g(x)$决定了，这就是$g(x)$的值域决定了$f(x)$的定义域， 于是，复合函数想要有定义，其$g(x)$的值域必须在$f(x)$的定义域内部才可以。</p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>下面引入两个函数：$f(x),g(x)$ 其中：其定义域以次为$D_f,D_g$ ，产生的新函数的定义域为$D=D_f\cap{D_g}$</p><p>函数的和差：</p><script type="math/tex; mode=display">(f\pm{g})(x)=f(x)\pm{g(x)}</script><p>函数的乘积：</p><script type="math/tex; mode=display">(f\cdot{g})(x)=f(x)\cdot{g(x)}</script><p>函数的相除：</p><script type="math/tex; mode=display">(\frac{f}{g})(x)=\frac{f(x)}{g(x)}, g(x)\neq0</script><h4 id="常见的初等函数"><a href="#常见的初等函数" class="headerlink" title="常见的初等函数"></a>常见的初等函数</h4><p>幂函数：$y=a^{\mu}$</p><p>指数函数:$y=a^x$</p><p>对数函数$y=log_a{x}$, 当$a=e$时，记作：$y=e^x$</p><p>特别的：当$a=e$时，又记成$y=\ln(x)$，当$a=10$时，又记成 $y=\lg(x)$.</p><p>三角函数：$\sin(x)$</p><p>反三角函数:$\arcsin(x)$</p><p>所有的这些函数经过有限次数的组合，运算得到的函数都是初等函数。</p><h2 id="极限定义与使用"><a href="#极限定义与使用" class="headerlink" title="极限定义与使用"></a>极限定义与使用</h2><h4 id="数列的极限的定义"><a href="#数列的极限的定义" class="headerlink" title="数列的极限的定义"></a>数列的极限的定义</h4><p>​            数列可以简单的理解为一列数：按照一定的规律排放：{$x_1,x_2,x_3,x_4,x_5…$}，我们简记作：$\{x_n\}$（注意到N是无穷大的）,比如说：</p><p>​                                                        $\{\frac{1}{2^n}\}$:$\{\frac{1}{2},\frac{1}{4},\frac{1}{8},\frac{1}{16}…\}$</p><p>其中，我们单取出来一项：这是数列的一个项。对于$\frac{1}{2^n}$这个东西，则我们叫做一般项：因为我们可以通过带入N的值来求得第N项的值来。</p><p>​        再来看一些数列：</p><p>​                                            $\{\frac{1}{n}\}$:{1,$\frac{1}{2},\frac{1}{3},\frac{1}{4},\frac{1}{5},\frac{1}{6},\frac{1}{7}$…}</p><p>​        这些数列似乎都随着N的增大逼近一个数，比如说，上面的这些数列都在$N\rightarrow\infty$下，{$x_n$}都在逼近一个数，比如和上面两个都在向0逼近。</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221227094255924.png" alt="image-20221227094255924"></p><p>​        这是$\{\frac{1}{n}\}$在数轴上的表示：当N越来越大下，数代表的点越来越靠近0代表的点。</p><p>我们称数列随着$N\rightarrow\infty$下，逼近的那一个数称之为这个数列的极限。</p><p>​        大概如此，所以我们来看看数学分析下定义的极限：</p><p>​        定义：$\{x_n\}$作为一个数列，$\forall \varepsilon&gt;0$，总$\exists{N},$当$n&gt;N$下，$|x_n-a|&lt;\varepsilon$</p><p>​        好吧，看一脸懵逼。那这个是什么意思呢？为什么引出这个抽象的定义？</p><p>​        注意到：$\forall \varepsilon&gt;0$ :这个是表明任意的一个$ \varepsilon$，只要它大于0都算，都要让上面的式子成立。</p><p>​        这就是说，我的$ \varepsilon$可以取得任意的小，多小都得行！，而$\exists{N},$表明了存在数列的一个项：使得在之后的项（这在$n&gt;N$已经说明白了）都与一个数a的差的绝对值（嘛，就是之后的项与这个数a的距离）为任意小。还不是相等，是一个动态的过程，因为如同</p><p>$\{\frac{1}{n}\}$中$n=10000000000000$一样，只是$x_n=\frac{1}{10000000000000}$罢了，但绝对不是0！但是，伴随这N取的越来越大，我们的{$x_n$}会越来越逼近0的。这描述的是一个动态的过程。</p><p>下面我们来引入一道经典例题：</p><p>​                                                            $2,\frac{1}{2},\frac{4}{3},\frac{3}{4}…\frac{n+(-1)^{n-1}}{n}$</p><p>​        这个数列的极限如何？</p><p>​        首先分析以下大通项：$\frac{n+(-1)^{n-1}}{n}$，它可以做出分离：$1+\frac{(-1)^{n-1}}{n}$ 注意到$(-1)^{n-1}$是一个震荡的数，在-1与1之间震荡，如果看作是一个函数的话，他是有界的，而$\frac{1}{n}$或者是$-\frac{1}{n}$无论如何都会随N增大而趋向于0.那么，这个数列的极限很明了了：</p><p>​    那我们使用数列的极限来证明：</p><p>​    $证明：$</p><p>​    $    因为 |x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}$</p><p>​    $于是\forall \varepsilon&gt;0,取{N=[\frac{1}{n}]+1}, 此时|x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}&lt;\varepsilon$</p><p>​    于是数列的极限是1.</p><p>​    我们再来看一个例题：</p><p>​    证明：$x_n=\frac{(-1)^n}{(n+1)^2}$的极限是0：</p><p>​    这是好说的：我们照猫画虎：</p><p>​    $证明：$</p><p>​    $    因为：|x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}$</p><p>​    $于是\forall \varepsilon&gt;0，取N=[\frac{1}{\sqrt{ \varepsilon}}]+1,此时有 |x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}&lt;\varepsilon$</p><p>​    于是数列的极限为0.</p><p>​    收敛数列的性质：</p><p>​    我们讨论一个收敛数列，是要关注他有什么特性的：</p><p>​    显然：</p><p>（1）收敛数列的极限唯一。</p><p>​    不太好证，所以我们来引入反证法：</p><p>​    证明：假设$x_n\rightarrow{a}同时x_n\rightarrow{b}$ ($a\neq{b}$),我们取$\varepsilon=\frac{b-a}{2}$（1）,</p><p>​    $于是：\exists{N_1},当n&gt;N_1下 |x_n-a|&lt;\frac{b-a}{2}$（2）</p><p>​    同时，又有$\exists{N_2},当n&gt;N_2下 |x_n-b|&lt;\frac{b-a}{2}$</p><p>​    这个时候，我们处理一下上面的式子：（展开我们的绝对值写成不等式）</p><p>​    此时由（1）得到的是：$x_n&lt;\frac{a+b}{2}$</p><p>​    由（2）得到的是：$x_n&gt;\frac{a+b}{2}$</p><p>​    毫无疑问这是矛盾的。所以，我们的极限不可以同时趋近于两个数。</p><p>​    （2）收敛数列一定有界。</p><p>​    证明：设$\lim\limits_{n\to+\infty}{x_n}=a$，此时此刻，我们可以随意的取一个$\varepsilon=1,\exists {N},当n&gt;N下，|x_n-a|&lt;1$</p><p>​    这个时候：</p><p>​    $    |x_n|=|x_n-a+a|\leqslant|x_n-a|+|a|&lt;1+|a|$</p><p>​        这显然符合有界的定义。但是呢？这是保证了$x&gt;N$的形况下，这个时候，我们只需要取出$M=max\{x_1,x_2,…x_N,1+|a|\}$（取出前N个里中最大的与1+$|a|$中还要大的那个，此时，M就是$\{x_n\}$下最大的一项了），这下子：$x_n\leqslant{M}$肯定有界了</p><p>（3）收敛数列具有保号性</p><p>​        这是什么意思呢？就是说：如果一个数列的极限为正（为负），那么，我们的数列在某一项之后肯定都是正的（负的）</p><p>​        数学的表达是这样的：</p><p>​        $\lim\limits_{n\to+\infty}{x_n}=a$,且$a&gt;0$，$\exists{N},$当$n&gt;N下,x_n&gt;0$</p><p>证明：</p><p>​        $a&gt;0$时，取$\varepsilon=\frac{a}{2}&gt;0,\exists{N},$当$n&gt;N$下,$|x_n-a|&lt;\frac{a}{2},$此后，我们的$0&lt;\frac{a}{2}&lt;x_n&lt;\frac{3a}{2}$</p><p>证毕。</p><p>​        反过来讲，如果数列从一项起都大于（小于）0，并且：$\lim\limits_{n\to+\infty}{x_n}=a$，那么：$a\geqslant0(\leqslant0)$</p><p>​    （4）收敛数列的任意子数列都收敛于同一极限</p><p>子数列：就是从原本的数列中抽取一些元素组成一个全新的数列。</p><p>$x_{n_k}$就是一种表示。</p><p>​        证明:</p><p>记：$\{x_{n_k}\}$是$\{x_{n}\}$的一个子数列，并且$\lim\limits_{n\to+\infty}{x_n}=a$</p><p>则$\forall \varepsilon&gt;0,\exists N&gt;0,n&gt;N下$</p><p>$|x_n-a|&lt;\varepsilon,这时，我们取K=N,k&gt;K时，n_k&gt;n_K=n_N\geqslant{N}$</p><p>${|x_{n_k}-a|}&lt;\varepsilon$</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145330449.png" alt=""></p><p>​        于是，我们又多了一种证明方式：如果一个数列中，存在两个子数列收敛于不同的极限，则我们说这个数列是发散。</p><p>补充：</p><p>​        反三角函数：三角函数的反函数时反三角函数。有如下的对应关系：</p><p>$sin(x)\rightarrow{arcsin(x)}$</p><p>$cos(x)\rightarrow{arccos(x)}$</p><p>$tan(x)\rightarrow{arctan(x)}$</p><p>​        实际上，就是$x=siny$的离谱写法我们看不惯，于是我们选择用一个全新的表达来表达一个全新的函数</p><p>​        图像上，回忆第一小节的笔记，图像关于$y=x$对称，做出来的图像就如下图所示：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145914221.png" alt="image-20221228145914221"></p><p>​        同时，为了保证是函数（还是第一小节的知识），截取我们的函数得到：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145933050.png" alt="image-20221228145933050"></p><p>​        于是：$x\in[-1,1],y\in[-\frac{\pi}{2},\frac{\pi}{2}]$</p><p>​        一些常见的函数值对应表：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228150223124.png" alt="image-20221228150223124"></p><p>其他的：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228150313511.png" alt="image-20221228150313511"></p><h5 id="（二）函数的极限"><a href="#（二）函数的极限" class="headerlink" title="（二）函数的极限"></a>（二）函数的极限</h5><p>​        1）$x\rightarrow{a}$下的函数极限</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.这一大长串，简记成如下：</p><p>法1）$\lim\limits_{x\rightarrow{x_0}}f(x)=A$</p><p>法2)$f(x)\rightarrow{A}(x\rightarrow{x_0})$</p><p>​        这定义还是很抽象：我们用人话讲：就是只要$x到{x_0}$是充分接近的，$f(x)$到$A$的距离可以为任意小。</p><p>​        但是，我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>下面我们就使用这个定义来证明一些命题：</p><p>$(1)\lim\limits_{x\rightarrow x_0}C=C$</p><p>证明：$\forall\varepsilon&gt;0,\exists\delta=N(N&gt;0)$</p><p>使得$0&lt;|x-x_0|&lt;\delta,|f(x)-A|=0,这明显小于\varepsilon$</p><p>证毕</p><p>$(2)\lim\limits_{x\rightarrow{1}}(2x-1)=1$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta=\frac{\varepsilon}{2}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=2|x-1|&lt;\varepsilon$</p><p>$(3)\lim\limits_{x\rightarrow{1}}\frac{x^2-1}{x-1}=2$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta={\varepsilon}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=|x-1|&lt;\varepsilon$</p><p>证毕</p><p>​        回到我刚刚讲到的：因为我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。为了方便描述，我们引入左，右极限的概念来描述从左侧右侧来逼近函数一点时产生的极限</p><p>左极限:$\lim\limits_{x\rightarrow{x_0^-}}f(x)=A$</p><p>右极限:$\lim\limits_{x\rightarrow{x_0^+}}f(x)=A$</p><p>那么，回到这个定义：</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.</p><p>​    其中$x$怎么趋近的方式是已经确定的，于是上面的$|x-x_0|$就可以拆成$x-x_0$或者是$x_0-x$了</p><p>那么，我们再次阐述：</p><p>​        我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>这个定理：$x\rightarrow{x_0}$,$f(x)$的极限存在$\Leftrightarrow$ 左右极限存在且相等</p><p>比如说</p><p>$\begin{equation}f(x)=\left\{\begin{array}{cl}x+1 &amp;  x &gt; 0 \\0  &amp;  x = 0 \\x-1 &amp;  x &lt; 0 \\\end{array} \right.\end{equation}$</p><p>$\lim\limits_{x\rightarrow{0^-}}f(x)=-1$</p><p>$\lim\limits_{x\rightarrow{0^+}}f(x)=1$</p><p>两者不相等，于是$f(x)$在0处的极限是不存在的。</p><p>​        2）$x\rightarrow{\infty}$下的函数极限</p><p>​        假设啊，我们的函数在无穷远处有定义的：这个时候，我们的$x$越远，我们的函数值越是接近某一个数。用数学语言表达是这样的：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X&gt;0,\mbox{使得}|x|&gt;X时，|f(x)-A|&lt;\varepsilon$</p><p>此时，我们简记作$\lim\limits_{x\rightarrow{\infty}}=A$</p><p>例题：</p><p>​        $(1)\lim\limits_{x\rightarrow{\infty}}{\frac{1}{x}=0}$</p><p>证明：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X=\frac{1}{\varepsilon},\mbox{使得}|x|&gt;X时，|\frac{1}{x}|&lt;\varepsilon$</p><p>证明完毕</p><p>​        </p><p>​        说完了，让我们谈谈性质</p><p>​        1)函数的极限唯一性</p><p>​        2)函数的局部有界限：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\exists{M&gt;0},\forall{\delta&gt;0},0&lt;|x-x_0|&lt;\delta时，|f(x)|\leqslant{M}$</p><p>​        3)局部保号性：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,A&gt;0,\exists{\delta&gt;0}则在0&lt;|x-x_0|&lt;\delta,f(x)&gt;0$</p><p>​        4）$Henn$定理：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\{x_n\}\rightarrow{x_0},\lim\limits_{n\rightarrow{\infty}}f(x_n)=\lim\limits_{x\rightarrow{x_0}}f(x)$</p><h6 id="无穷小和无穷大"><a href="#无穷小和无穷大" class="headerlink" title="无穷小和无穷大"></a>无穷小和无穷大</h6><p>​        无穷小：趋于0的一个量（动态的！），是正是负和0都叫无穷小。同时，无穷小除了0意外，无穷小都不确定。具体的定义是这样的：</p><p>​        定义：$x\rightarrow{x_0}(x\rightarrow{\infty})$时，$f(x)$ 的极限为0，称$f(x)$是当$x\rightarrow{x_0}(x\rightarrow{\infty})$下的无穷小</p><p>​        这么说来，无穷小并不唯一，有无穷多个无穷小</p><p>下面介绍以下无穷小的一些性质:</p><p>​        定义$a,b$是两个无穷小</p><p>​        $a+b$是一个无穷小；</p><p>​        $a-b$是一个无穷小;</p><p>​        $a\times b$是一个无穷小;</p><p>​        $c\times{a}$是一个无穷小;</p><p>​        注意！！！$a\div{b}$是未定式，在没有给定a,b的具体情况，我们是不知道这个值究竟是多少的！它本身可以是任何数！！！</p><p>​        无穷大：这个有特定的符号：$\infty$</p><p>​        他也是有定义的：$\lim\limits_{ {x\rightarrow{x_0} } }f(x)= \infty$或者$\lim\limits_{ {x\rightarrow{\infty} } }f(x)=\infty$</p><p>​        注意！！！注意！！！无穷大可以是正无穷大或者是负无穷大！！！于是</p><p>​        引入两个无穷大记作$a,b$</p><p>​        无论是$a+b还是a-b$都是未定义的</p><p>​        但是$a\times{b}$一定是无穷大，$c\times{ \infty }(c\neq{ 0 })$一定是无穷大</p><p>​        $a\div{ b }$结果未知</p><p>​        定理：$f(x)$如果是无穷大，那么$\frac{1}{f(x)}$是无穷小。</p><p>​        $f(x)$如果是无穷小，那么$\frac{1}{f(x)}$是无穷大。（$f(x)\neq{0}$）</p><p>​        极限运算法则</p><p>​        法则1：两个甚至是若干有限个的无穷小的和是无穷小的</p><p>​        <strong>法则2：有界函数与无穷小的乘积是无穷小</strong></p><p>​        推论：常数乘以无穷小还是无穷小</p><p>​                    有限个无穷小的乘积还是无穷小</p><p>​        定理：记：$\lim{f(x)}=A,\lim{g(x)}=B$</p><p>​        1)$\lim{f(x)\pm{g(x)}}=A\pm{B}$</p><p>​        2)$\lim{f(x)\times{g(x)}}=A\times{B}$</p><p>​        3)$\lim{\frac{f(x)}{g(x)}}=\frac{A}{B}(B\neq{0})$</p><p>​        4)$\lim{cf(x)}=c\lim{f(x)}$</p><p>​        5)$\lim{ {f(x)}^n}=[{\lim{f(x) } }]^n$</p><p>对于数列还是一样的</p><p>​        定理:$\psi(x)\geqslant\varphi(x)$,$\lim{\psi(x)}&gt;\lim{\varphi(x)}$</p><p>哎，这后面这么没有等号了呢?举个例子:$\frac{1}{x}$,$-\frac{1}{x}$</p><h5 id="极限存在准则，两个重要极限"><a href="#极限存在准则，两个重要极限" class="headerlink" title="极限存在准则，两个重要极限"></a>极限存在准则，两个重要极限</h5><p>准则I：对于数列$\{x_n\},\{y_n\}$,${z_n}$ (1)$\exists {n_0}\in{N},y_n\leqslant{x_n}\leqslant{z_n}$(2)$\lim{y_n}=lim{z_n}=a$那么：$\lim{x_n}=a$</p><p>准则I’ :对于函数f(x),g(x),h(x),且(1)$g(x)\leqslant{f(x)}\leqslant{h(x)}$(2)$\lim{g(x)}=\lim{h(x)}=A$那么：$lim{f(x)}=A$</p><p>两个重要极限：</p><h6 id="I-lim-limits-x-rightarrow-0-frac-sin-x-x-1"><a href="#I-lim-limits-x-rightarrow-0-frac-sin-x-x-1" class="headerlink" title="I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$"></a>I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$</h6><p>注意一定是$x\rightarrow{0}$！！！</p><p>同时！！！也可以有推广：</p><h6 id="I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1"><a href="#I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1" class="headerlink" title="I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$"></a>I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$</h6><p>其他派生的极限：</p><p>$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=1$</p><p>这是因为：$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=\lim\limits_{x\rightarrow{0}}(\frac{\sin{x}}{x})\times(\frac{1}{\cos{x}})$=1</p><p>例题：$\lim\limits_{x\rightarrow{0}}\frac{1-\cos{x}}{x^2}$</p><p>解：<img src="C:\Users\陈冠豪\Desktop\image-20221229164852173.png" alt="image-20221229164852173"></p><p>等价无穷小：（I派生）</p><p>$\sin{x}\backsim{x}$ , $\tan{x}\backsim{x}$, $\arcsin{x}\backsim{x}$</p><h4 id="准则II：单调有界数列必有极限！"><a href="#准则II：单调有界数列必有极限！" class="headerlink" title="准则II：单调有界数列必有极限！"></a>准则II：单调有界数列必有极限！</h4><p>性质：收敛必有界，而有界不一定收敛</p><p>为什么有界不一定收敛呢？举个反例：$\{(-1)^{N}\}$就可以了，这个数列显然有界：</p><p>II:$\lim\limits_{x\rightarrow{\infty}}(1+\frac{1}{x})^{x}=e$</p><p>注意$x$一定是趋于无穷！！！</p><p>派生的还有。。。</p><p>II’$\lim\limits_{\Box\rightarrow{\infty}}(1+\frac{1}{\Box})^{\Box}=e$</p><p>II’’$\lim\limits_{x\rightarrow{0}}(1+{x})^\frac{1}{x}=e$</p><p>补充：Cauchy极限审敛法：</p><p>$\{x_n\}收敛\Leftrightarrow \forall{\varepsilon&gt;0},\exists N,当m&gt;N时，|x_n-x_m|&lt;\varepsilon$</p><p>无穷小的比较：</p><p>​        不同无穷小趋于0的速度不一样，我们比较无穷小就是比较不同无穷小趋于0的速度：</p><p>方法是简单的，看他们的商的极限即可：</p><p>如：$\lim\limits_{x\rightarrow{0}}x=0,\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$,而$\lim\limits_{x\rightarrow{0}}\frac{x}{\sqrt{x}}=\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$</p><p>于是：我们发现这个极限为0，说明在趋近速度上$x&gt;\sqrt{x}$</p><p>这样，我们就比较出来了</p><p>定义：</p><p>$若\lim\frac{\beta}{\alpha}=0,则称\beta是\alpha的高阶无穷小，记作\beta=o(\alpha)$</p><p>$若\lim\frac{\beta}{\alpha}=\infty,则称\beta是\alpha的低阶无穷小$</p><p>$若\lim\frac{\beta}{\alpha}=c(c\neq{0}),则称\beta是\alpha的同阶无穷小,特别的，当c=1时，又称等价无穷小,记作{\beta}\backsim{\alpha}$</p><p>$若\lim\frac{\beta}{\alpha^k}=c(c\neq{0}),则称\beta是\alpha的k阶无穷小$</p><p>下面是一些常见的等价无穷小：</p><p>1)$x\rightarrow{0}时，\sqrt[n]{1+x}-1\backsim\frac{x}{n},\sin(x)\sim{x}$</p><p>定理：</p><p>1）$\beta于\alpha等价\Leftrightarrow \beta=\alpha+o(\alpha)$</p><p>2)$\alpha\sim\widetilde{\alpha},\beta\sim\widetilde{\beta},且\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}是存在的，则:\lim\frac {\alpha}{\beta}=\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}$</p><p>于是：</p><p>2)$\tan{x}\sim{x},\arcsin{x}\sim{x}$</p><p>上面的$x$都可以被替换成$\Box$</p><p>定理：</p><p>1）两个无穷小相比的极限时，分子分母可以用等价无穷小替换</p><p>2）如果分子或分母是若干因子的乘积，则我们可以对其中一个或者几个无穷小做替换，但是因子用加减法是不可以的！！！！！！！！！！！！！！！！</p><h4 id="函数的连续性"><a href="#函数的连续性" class="headerlink" title="函数的连续性"></a>函数的连续性</h4><p>对于函数增量的定义：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221229174949222.png" alt="image-20221229174949222"></p><p>则增量$\Delta f(x)=f(x+\Delta{x})-f(x)$</p><p>实际上，叫做改变量更切合实际，因为函数也可以递减</p><p>那么，连续的定义由此引出：</p><p>若$\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=\lim\limits_{\Delta{x}\rightarrow{0}}(f(x_0+\Delta{x})-f(x_0))=0$时，则函数在$x_0$处连续</p><p>或者</p><p>$\lim\limits_{x\rightarrow{x_0}}f(x)=f(x_0)$时，则函数在$x_0$处连续</p><p>总结而言，一个函数若是想在$x_0$ 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！</p><p>既然有左右极限，于是也使得函数也有左右连续。函数的左右极限就是由$x$以不同的方向逼近产生的。</p><p>左连续：$\lim\limits_{x\rightarrow{x_0^-}}f(x)=f(x_0)$</p><p>右连续：$\lim\limits_{x\rightarrow{x_0^+}}f(x)=f(x_0)$</p><p>类似的：函数的连续的充要条件是函数即左连续又右连续。</p><h4 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h4><p>回到连续需要满足的条件：</p><p>一个函数若是想在x_0 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！于是，间断点也就有三种产生原因：</p><p>1)在$x_0$无定义</p><p>2)$\lim\limits_{x\rightarrow{x_0}}f(x)$不存在</p><p>3）$\lim\limits_{x\rightarrow{x_0}}f(x)\neq{f(x_0)}$</p><p>举例子：</p><p>1)$y=\tan{x}在x=\frac{\pi}{2}$处无定义，所以在这一点上不连续这是可去间断点.</p><p>2)$y=\sin{\frac{1}{x}}$在x=0处极限不存在，所以在这一点上不连续.</p><p>3）</p><script type="math/tex; mode=display">\begin{equation}f(x)=\left\{\begin{array}{cl}\frac{x^2-1}{x-1} &  x \neq 0 \\0  & x = 0 \\\end{array} \right.\end{equation}</script><p>，这个函数在x=1处不连续。这个间断点叫跳跃间断点</p><p>间断点有两类：</p><p>第一类：左右极限都存在</p><p>有可去间断点，跳跃间断点</p><p>第二类：左右极限不都存在</p><p>有震荡间断点</p><p>连续函数的性质：</p><p>对于$[a,b]$上，且$f(a)f(b)&lt;0$时，则其中至少存在一个点$\xi \in[a,b]，$使得$f(\xi)=0$</p><p>推广：</p><p>定理：$f(x)在[a,b]$上连续,$f(a)=A,f(b)=B$,则$\exists C\in[A ,B]$,至少有一个$\xi \in [a,b]$使得，$f(\xi)=C$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随记(1)</title>
      <link href="/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简单C教程1"><a href="#简单C教程1" class="headerlink" title="简单C教程1"></a>简单C教程1</h1><p>​        首先打开你的VS，或者是已经配置好GCC和相关插件的Vscode,亦或者Dev C++这个东西，以及切换到英文输入法！！！！！！！！！！！！小心中文的分号给你小小的计算机震撼</p><p>​        我们首先明确：C语言是一个人和计算机交流的语言。语言既然有发展的历史，那么，计算机语言也有发展的过程</p><p>​        最开始的时候：我们使用0，1来代表正电负电，后来用助记符 ，而后有用更高级的语言表达一些固定的助记符。C语言由此诞生。</p><p>​        C语言也有标准：C89/C90是我们这个时候学习的主力。</p><h3 id="My-Fisrt-C-Project"><a href="#My-Fisrt-C-Project" class="headerlink" title="My Fisrt C Project"></a>My Fisrt C Project</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression"><span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h</span><span class="token comment">//1</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//2</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//3</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        //1:首先，我们首先引入头文件stdio.h，这个文件里包含了我们以后要使用的函数，我需要把他们包含进来才可以使用，否则编译器不认识他们。</p><p>​        //2:接着，main是主函数的意思，这是我们程序的入口：只能有一个main函数不可以有第二个，更不可以没有main函数，int是integer的缩写，表明的是整形。这个表达的是这个函数返回的是一个整形。这个函数负责完成任务</p><p>​        //3：返回0：这是因为函数需要返回东西，我们返回0表达的是成功完成任务</p><p>​        //4：printf:print formatly标准的打印，里面放进去的是一个字符串”hello world\n”,\n是一个换行符</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><div class="table-container"><table><thead><tr><th style="text-align:left">char</th><th>short</th><th>long</th><th>int</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">long long</td><td>float</td><td>double</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>​    数据类型有上面这几种，生活中无非就是小数，整数。上面就是引申出来的七种类型</p><p>1.char类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;char ch&#x3D;&#39;A&#39;;&#x2F;&#x2F;存放一个字符，我们起了一个名字ch，里面放了一个A    printf(&quot;%c&quot;,ch);&#x2F;&#x2F;使用%c来输出一个字符变量的内容，函数以这样的方式取出一个字符    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.int类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;int stdint&#x3D;114514;&#x2F;&#x2F;存储一个整形，我们起了一个名字叫stdint，里面放了一个114514printf(&quot;%d&quot;,stdint);&#x2F;&#x2F;使用%d来输出一个整形变量的内容，函数以这样的方式取出一个整形return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.long, long long（C99）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;long stdint&#x3D;114514;&#x2F;&#x2F;存储一个长整形，我们起了一个名字叫stdint，里面放了一个114514printf(&quot;%ld&quot;,stdint);&#x2F;&#x2F;使用%ld来输出一个长整形变量的内容，函数以这样的方式取出一个长整形return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.float，double</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;float stdflt&#x3D;114514.1919810;&#x2F;&#x2F;存储一个浮点型，我们起了一个名字叫stdflt，里面放了一个114514.1919810printf(&quot;%f&quot;,stdflt);&#x2F;&#x2F;使用%f来输出一个浮点型变量的内容，函数以这样的方式取出一个浮点型    double stddbl&#x3D;114514.1919810;&#x2F;&#x2F;存储一个双精度浮点型，我们起了一个名字叫stddbl，里面放了一个114514.1919810    printf(&quot;%lf&quot;,stddbl);&#x2F;&#x2F;使用%lf来输出一个双精度浮点型变量的内容，函数以这样的方式取出一个双精度浮点型return 0;&#125;&#x2F;&#x2F;打印还有其他方式访问：%p声明打印地址，%x以十六进制的方式打印，%o以八进制的方式打印<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        问题来了，为什么整这么多花里胡哨的东西呢？一个不香吗？</p><p>​        首先我们区分他们在计算机在内存中占用的内存。使用一个运算符叫做sizeof(),我们的括号里面放的就是类型。大伙看一看，有什么区别</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    printf(&quot;%d\n&quot;,sizeof(char));&#x2F;&#x2F;char申请内存的大小    printf(&quot;%d\n&quot;,sizeof(short));&#x2F;&#x2F;short申请内存的大小    printf(&quot;%d\n&quot;,sizeof(int));&#x2F;&#x2F;int申请内存的大小    printf(&quot;%d\n&quot;,sizeof(long));&#x2F;&#x2F;long申请内存的大小    printf(&quot;%d\n&quot;,sizeof(float));&#x2F;&#x2F;float申请内存的大小    printf(&quot;%d\n&quot;,sizeof(double));&#x2F;&#x2F;double申请内存的大小&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230129173130931.png" alt="image-20230129173130931"></p><p>​        等等，我们是得到了数，单位是什么呢？字节（byte）。下面插一个小科普：计算机的单位有以下几个层级：</p><p>​        bit                    byte            kb            mb            gb            tb            pb </p><p>​        计算机力最小的单位是怎么定义的呢？</p><p>​        计算机通电工作，这些硬件下通过的电流分为正电和负电，分别代表0和1。（高低电平）这就是2进制的来源，我们用一系列的0和1来表达数据或者物体的状态。1个比特位就可以存储一个0或者是1，8个比特位构成一个字节，随后k,m,g,t,p的进位关系是1024倍数的关系。就是说：一个char的大小是8个比特位，一个int由32个比特位构成。我们的这些类型就是为了更加方便和丰富的表达生活的类型，所以才产生的。</p><h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p>​        我们针对数据变不变来区分出来数据是常量还是变量。</p><p>​        比如说：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int age&#x3D;10;&#x2F;&#x2F;向内存申请4个字节存放一个20，而这个字节表达的含义是age<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个age是可以变动的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int age&#x3D;10;printf(&quot;%d\n&quot;,age);age&#x3D;20;printf(&quot;%d\n&quot;,age);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的代码打出来了10和20 。</p><p>​        定义变量的方法是这样的：</p><pre class="line-numbers language-none"><code class="language-none">类型 变量名 &#x3D; 值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        变量自身也有分类：局部变量和全局变量，区别又是什么呢？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int num1&#x3D;20;int main()&#123;    int num2&#x3D;10;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不难猜到：num1是全局变量，num2是局部变量。全局变量指的是定义在代码块{ }之外的变量。反之，在{ }内的是全局变量。问题来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int global &#x3D;2023;int main()&#123;    int local&#x3D;2022;    &#x2F;&#x2F;?So what about the next line?int global&#x3D;2022;    printf(&quot;global here is %d\n&quot;,global);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         当你在VS2022一敲出来，高亮颜色就告诉你，答案是2022：</p><p>​        <img src="image-20230129180112913.png" alt="image-20230129180112913"></p><p>​        能同时共存，而且：<strong>局部变量优先</strong> 这里给出建议：</p><p>​        <strong>打代码的时候不要使用同名的局部变量和全局变量，如果相同了，记住一件事情：局部变量优先！</strong></p><p>​        下面我们继续玩一个新的函数：scanf函数。</p><p>​        我说停停！！！先别函数玩的欢乐，这是因为在新标准下，C标准委员会嫌这东西不安全（为什么不安全这里先不扯，简单来讲就是这个函数读到什么东西就往里塞，实在读不进去就直接扔回一个-1摆烂，导致程序安全性很差）, 所以整了一个船新函数scanf_s ,这个函数我的评价是VS用用行，但是移植到别的编译器还要切换标准，怎么办呢？在VS编译器下面使用一个宏定义#define _CRT_SECURE_NO_WARNINGS 1 让编译器赶紧闭嘴通过就完事，这个宏（可以先不追究这是什么东西）扔到程序的最前面就可以了</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Example#define _CRT_SECURE_NO_WARNINGS 1&#x2F;&#x2F;Looking here#include&lt;stdio.h&gt;int global &#x3D; 2023;int main()&#123;    int local &#x3D; 2022;    &#x2F;&#x2F;?So what about the next line?    int global &#x3D; 2022;    printf(&quot;global here is %d\n&quot;, global);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个函数读取键盘的输入，使用方法如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;A basic program that reads two numbers then returns the sum of themint num1&#x3D;0;int num2&#x3D;0;scanf(&quot;%d%d&quot;,&amp;num1,&amp;num2);&#x2F;&#x2F;字符串里面不要塞上空格！不要塞上空格int sum&#x3D;num1+num2;printf(&quot;%d&quot;,sum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对了，这个&amp;是什么捏？取地址符号，后面我们提到指针的时候我们会天天见到他。人话就是这样讲：告诉这个函数，这两个变量在计算机的哪里。</p><p>​        认真的讲，计算机有巨大的内存，那么多数据，我们的计算机怎么哪里是哪里？使用地址，就像你们家的门牌号一样。</p><p>​        变量也有作用域：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int global&#x3D;10;int main()&#123;    int numlevel1&#x3D;10;    &#123;        int numlevel2&#x3D;20;    &#125;    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel1);    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你的编译器很快（也很不幸的）告诉你，我不到numlevel2是什么啊。那就对了，因为每个变量都有它的作用域：范围就是从他定义的位置到当前它在的大括号区域}结束处：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int global&#x3D;10;int main()&#123;printf(&quot;%d&quot;,numlevel1);&#x2F;&#x2F;NOOOO,变量还没被声明，不要用:(    int numlevel1&#x3D;10;&#x2F;&#x2F;----init numlevel1    &#123;       int numlevel2&#x3D;20;&#x2F;&#x2F;----init numlevel2    &#125;&#x2F;&#x2F;----destroy numlevel2 Sadly    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel1);   &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel2);&#125;&#x2F;&#x2F;----destroy numlevel1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的图就表示了程序变量的生命周期或者说作用域：创建完之后到被回收之前，变量才是被允许使用的。所以，当你的编译器不知道你想要使用的变量的时候，他会指出错误：未声明的标识符。这个时候回去看看你的代码哪里出现了问题⑧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
