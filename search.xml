<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于使用GDB调试远程下位机开发板的应用层程序办法 + VSCode更好的界面调试体验提升</title>
      <link href="/2024/12/13/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E8%BF%9C%E7%A8%8B%E4%B8%8B%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E7%A8%8B%E5%BA%8F%E5%8A%9E%E6%B3%95-VSCode%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%95%8C%E9%9D%A2%E8%B0%83%E8%AF%95%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87/"/>
      <url>/2024/12/13/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8GDB%E8%B0%83%E8%AF%95%E8%BF%9C%E7%A8%8B%E4%B8%8B%E4%BD%8D%E6%9C%BA%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E7%A8%8B%E5%BA%8F%E5%8A%9E%E6%B3%95-VSCode%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%95%8C%E9%9D%A2%E8%B0%83%E8%AF%95%E4%BD%93%E9%AA%8C%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式Linux应用层开发——调试专篇（关于使用GDB调试远程下位机开发板的应用层程序办法-VSCode更好的界面调试体验提升）"><a href="#嵌入式Linux应用层开发——调试专篇（关于使用GDB调试远程下位机开发板的应用层程序办法-VSCode更好的界面调试体验提升）" class="headerlink" title="嵌入式Linux应用层开发——调试专篇（关于使用GDB调试远程下位机开发板的应用层程序办法 + VSCode更好的界面调试体验提升）"></a>嵌入式Linux应用层开发——调试专篇（关于使用GDB调试远程下位机开发板的应用层程序办法 + VSCode更好的界面调试体验提升）</h1><h2 id="环境预备——调试"><a href="#环境预备——调试" class="headerlink" title="环境预备——调试"></a>环境预备——调试</h2><p>​    虽说有正点原子的代码带着，但是，如果我们只是打着printf这种方式进行手动的检查代码错误，还是不太方便的，笔者这里整理了两个上位机调试路线。</p><ol><li>路线1：使用GCC7.5，这个路线比较保守，适合对GCC, GDB等比较陌生的萌新使用，关于这个的安装，请参考笔者之前的博客进行学习安装。</li><li>路线2：使用GCC13.2，这个路线比较激进，目前笔者使用的板子上是不支持跑GCC13.2编译器编译的，笔者目前的解决方案是直接将板子上的libc.so.6拷贝下来放到我们的工程目录下，后面编译的时候使用。</li><li>路线3：直接把板子大刷新刷一个新系统用新的glibc，但是笔者认为那属于大炮打蚊子。</li></ol><h2 id="环境预备"><a href="#环境预备" class="headerlink" title="环境预备"></a>环境预备</h2><p>​    笔者注意到很多博客都在用arm-linux-noneabihf-gdb来进行调试，笔者认为其实没有必要。现代的跨平台gdb调试方案是gdb-multiarch</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install gdb-multiarch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    现在我们使用gdb-multiarch</p><pre class="line-numbers language-none"><code class="language-none">➜  gdb-multiarchGNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-gitCopyright (C) 2024 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type &quot;show copying&quot; and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;bugs&#x2F;&gt;.Find the GDB manual and other documentation resources online at:    &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;documentation&#x2F;&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.(gdb) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="如果坚持使用arm-linux-noneabihf-gdb"><a href="#如果坚持使用arm-linux-noneabihf-gdb" class="headerlink" title="如果坚持使用arm-linux-noneabihf-gdb"></a>如果坚持使用arm-linux-noneabihf-gdb</h3><p>​    以笔者的Ubuntu24.04为例子，我需要不幸的告诉你，Ubuntu24.04的apt源已经不提供python2.7了（太老了），但是如果你的gdb版本非常的低（比如说笔者的GCC7.5以下的版本），那么不幸的是，他必须依赖python2.7。</p><p>​    办法是自己动手丰衣足食，好在并不麻烦：</p><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;2.7.18&#x2F;Python-2.7.18.tgz # 下载Python-2.7tar -xvf Python-2.7.18.tgzcd Python-2.7.18# 我不认为看到这篇博客的朋友需要我解释上面的两句话# 我们的gdb需要依赖的是libpython2.7，所以采用的是共享库构建, 后面那个错误是为了补充解决UnicodeUCS4依赖缺失的问题# 默认下载到&#x2F;usr&#x2F;local下面去，如果想换地方，--prefix指定前置的目录 :).&#x2F;configure --enabled-shared --enable-unicode&#x3D;ucs4make -j16sudo make install # 下载到&#x2F;usr&#x2F;local，或者是自己--prefix指定的地方<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    gdb还会依赖，我可以告诉你不行，Ubuntu24.04已经不使用ncurse5了，改成了6了，所以一个办法就是</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F; -name libncurses*find &#x2F; -name libtinfo*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    然后软链接到/lib/x86_64-linux-gnu/下面去，新的链接名称依次为：</p><pre class="line-numbers language-none"><code class="language-none">libncurses.so.5libtinfo.so.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    ldd查看你的gdb有没有出现依赖丢失的问题，没有的话，你的gdb就能用了，如果你的环境缺失依赖，那可以自己把报错喂给搜索引擎。</p><blockquote><p>一个不太负责任的ref:</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install -y build-essential checkinstall libssl-dev libsqlite3-dev tk-dev libgdbm-dev libc6-dev libbz2-dev libffi-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个依赖笔者没有测试过，不确定是否为<strong>最小且的有效依赖！</strong>（原文还有libncursesw5-dev，为啥不行我说了）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">➜  .&#x2F;arm-linux-gnueabihf-gdbGNU gdb (Linaro_GDB-2019.12) 8.3.1.20191204-gitCopyright (C) 2019 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http:&#x2F;&#x2F;gnu.org&#x2F;licenses&#x2F;gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type &quot;show copying&quot; and &quot;show warranty&quot; for details.This GDB was configured as &quot;--host&#x3D;x86_64-unknown-linux-gnu --target&#x3D;arm-linux-gnueabihf&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;bugs&#x2F;&gt;.Find the GDB manual and other documentation resources online at:    &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gdb&#x2F;documentation&#x2F;&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.(gdb) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="番外：使用update-alternatives来管理多版本的工具链"><a href="#番外：使用update-alternatives来管理多版本的工具链" class="headerlink" title="番外：使用update-alternatives来管理多版本的工具链"></a>番外：使用update-alternatives来管理多版本的工具链</h2><p>​    笔者现在算下来，python有两个版本：3.12和2.7，arm-gcc有两个版本：gcc7.5和gcc13.2，这样的话我们就需要请出来我们的update-alternatives来帮助我们管理我们的多版本的工具链了。</p><p><a href="https://zhuanlan.zhihu.com/p/20797436">Linux命令之update-alternatives - 知乎 (zhihu.com)</a></p><p>上面是一篇update-alternatives的使用和原理说明，这里不再赘述。</p><h2 id="使用Filezilla来传递我们的文件"><a href="#使用Filezilla来传递我们的文件" class="headerlink" title="使用Filezilla来传递我们的文件"></a>使用Filezilla来传递我们的文件</h2><p>​    当然你可以使用scp传递，笔者这里偷懒方便，你可以</p><pre class="line-numbers language-none"><code class="language-none">sudo apt install filezilla<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    来下载我们的Filezilla</p><p>​    正点原子的板子上是有ssh服务的，所以，你需要做的是继续把网线一插，配置一下对应网卡的ipv4地址（ifconfig扫一眼，没有ipv4地址，也别学一些抽象的哥们跑去爆改/etc文件，没那个必要，直接做这个事情就好了</p><pre class="line-numbers language-none"><code class="language-none">ifconfig 网卡 自己的可以被上位机Ping通的IP地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后重启一下网卡即可）</p><p>​    现在看看ipconfig，应该就有ipv4地址了。笔者的是：</p><pre class="line-numbers language-none"><code class="language-none">ifconfig eth0 10.41.0.50 # 不要照着抄！看你自己的以太网网线分配的gateway，依照netmask来设置ipifconfig eth0 downifconfig eth0 up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    使用ifconfig确认好IP确实出现在这里了，下一步就是在上位机上测试有没有Ping通我们的板子</p><pre class="line-numbers language-none"><code class="language-none">➜  ping 10.41.0.50PING 10.41.0.50 (10.41.0.50) 56(84) bytes of data.64 bytes from 10.41.0.50: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.533 ms64 bytes from 10.41.0.50: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.412 ms64 bytes from 10.41.0.50: icmp_seq&#x3D;3 ttl&#x3D;64 time&#x3D;0.344 ms...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    OK完事。现在就可以使用filezilla来传递我们的文件，同时，我们也保证了后面的gdb调试是可以运行的！</p><h2 id="准备调试"><a href="#准备调试" class="headerlink" title="准备调试"></a>准备调试</h2><pre class="line-numbers language-none"><code class="language-none">➜  cat test.c#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;Hello!GDB!\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    现在我们首先使用比较保守的版本较低的arm-gcc进行编译。注意，我们调试是需要保留一部分调试符号的。所以需要添加-g参数</p><pre class="line-numbers language-none"><code class="language-none">arm-linux-gnueabihf-gcc test.c -o test -g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    file一下：</p><pre class="line-numbers language-none"><code class="language-none">➜  file testtest: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter &#x2F;lib&#x2F;ld-linux-armhf.so.3, for GNU&#x2F;Linux 3.2.0, BuildID[sha1]&#x3D;296f78e701a368fa147dedac2d781b8886aea9fa, with debug_info, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    如果是我们新的gcc，那么就需要使用Filezilla来下载开发板上的glibc动态库(<code>libc.so.6</code>，在哪里自己在开发板上find一下就完事了)然后在编译时：</p><pre class="line-numbers language-none"><code class="language-none">arm-linux-gnueabihf-gcc test.c -o test -g (libc的动态库的位置)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    以笔者的为例子，我的构建目录比较简单：</p><pre class="line-numbers language-none"><code class="language-none">➜  lslibc.so.6  test  test.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">arm-linux-gnueabihf-gcc test.c -o test -g .&#x2F;libc.so.6 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    嗯，不太好看。当然后续可以使用-L参数指定编译器链接库，这个就脱离了我们讨论的范畴了。可以将文件移动到开发板上试一下，不出意外是可以运行的！</p><p>​    确保你的可执行文件可以运行，以及板子是可以ping通的情况下</p><h2 id="使用gdbserver-gdb-multiarch来调试我们的板子"><a href="#使用gdbserver-gdb-multiarch来调试我们的板子" class="headerlink" title="使用gdbserver, gdb-multiarch来调试我们的板子"></a>使用gdbserver, gdb-multiarch来调试我们的板子</h2><p>​    把我们编译的test文件传递到板子上</p><pre class="line-numbers language-none"><code class="language-none">root@ATK-IMX6U:~&#x2F;debug_demo# lstest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    注意到，gdb调试是需要第三方运行权限的，所以，需要我们chmod一下：</p><pre class="line-numbers language-none"><code class="language-none">chmod 755 test # 第三方运行要可读可运行，故755<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    gdb调试是版本无关的。所以无论您是采用高版本还是低版本编译器编译的代码，都可以采用下面的流程进行调试：</p><p>​    正点原子的板子上已经有了可以直接运行的gdbserver，我们启动这个服务器</p><pre class="line-numbers language-none"><code class="language-none">root@ATK-IMX6U:~&#x2F;debug_demo# gdbserver 10.41.0.50:2001 testProcess test created; pid &#x3D; 1123Listening on port 2001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    现在服务器端就已经准备就绪了，下一步就是我们的客户端要连接上来。</p><pre class="line-numbers language-none"><code class="language-none">(gdb) target remote 10.41.0.50:2001Remote debugging using 10.41.0.50:2001Reading &#x2F;lib&#x2F;ld-linux-armhf.so.3 from remote target...warning: File transfers from remote targets can be slow. Use &quot;set sysroot&quot; to access files locally instead.Reading &#x2F;lib&#x2F;ld-linux-armhf.so.3 from remote target...Reading symbols from target:&#x2F;lib&#x2F;ld-linux-armhf.so.3...Reading &#x2F;lib&#x2F;ld-2.23.so from remote target...Reading &#x2F;lib&#x2F;.debug&#x2F;ld-2.23.so from remote target...Reading &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;&#x2F;lib&#x2F;ld-2.23.so from remote target...Reading &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;lib&#x2F;&#x2F;ld-2.23.so from remote target...(No debugging symbols found in target:&#x2F;lib&#x2F;ld-linux-armhf.so.3)Reading &#x2F;usr&#x2F;lib&#x2F;debug&#x2F;.build-id&#x2F;bc&#x2F;36f44173aa35217e54ad98751d4537bb36daa9.debug from remote target...This GDB supports auto-downloading debuginfo from the following URLs:  &lt;https:&#x2F;&#x2F;debuginfod.ubuntu.com&gt;# 这里询问你是否要进一步下载更多的调试符号，我们选择yEnable debuginfod for this session? (y or [n]) yDebuginfod has been enabled.To make this setting permanent, add &#39;set debuginfod enabled on&#39; to .gdbinit.Downloading separate debug info for system-supplied DSO at 0x76ffd0000x76fcfac0 in ?? () from target:&#x2F;lib&#x2F;ld-linux-armhf.so.3                                                 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这个时候我们看看开发板的终端，就会发现已经连上了：</p><pre class="line-numbers language-none"><code class="language-none">Remote debugging from host 10.41.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    为了调试方便，我们在上位机的gdb终端输入</p><pre class="line-numbers language-none"><code class="language-none">layout src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="./image-20241213111701612.png" alt="image-20241213111701612"></p><p>​    可以看到笔者在这里打了断点</p><pre class="line-numbers language-none"><code class="language-none">(gdb) b 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    现在我们c一下（c是continue的意思），这里就是运行起来我们的程序，让它停在我们的第一行上：</p><p><img src="./image-20241213111909639.png" alt="image-20241213111909639"></p><p>​    调试已经成功，我们继续运行</p><p><img src="./image-20241213111939705.png" alt="image-20241213111939705"></p><p>​    这里看到我们的程序运行结束了</p><p><img src="./image-20241213111958088.png" alt="image-20241213111958088"></p><p>​    我们的板子的终端也成功运行程序结束！调试的Demo完成了！</p><h2 id="更好的体验：在VSCode上调试我们的代码"><a href="#更好的体验：在VSCode上调试我们的代码" class="headerlink" title="更好的体验：在VSCode上调试我们的代码"></a>更好的体验：在VSCode上调试我们的代码</h2><p>​    一些朋友可能更喜欢在vscode上做调试，笔者整理了一份同构建无关的办法。那就是写launch.json文件。这里，我们需要在.vscode文件夹下（在你的工程目录下面，没有就自己创建一个，或者在调试的界面上创建launch.json。笔者这里提供了自己写的launch.json</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &#x2F;&#x2F; 使用 IntelliSense 了解相关属性。     &#x2F;&#x2F; 悬停以查看现有属性的描述。    &#x2F;&#x2F; 欲了解更多信息，请访问: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;test_vscode_gdb&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &#x2F;&#x2F; 下面的这个program就是你的可执行文件的名称            &quot;program&quot;: &quot;.&#x2F;test&quot;,            &#x2F;&#x2F; 如果你的可执行文件需要输入，在args下面依次添加参数即可            &quot;args&quot;: [],            &#x2F;&#x2F; 这个是询问要不要停在开头，如果想从头到尾的理解程序而不想自己手动打一个最初的断点，设置成true            &quot;stopAtEntry&quot;: false,            &#x2F;&#x2F; 这个是路径调整，笔者决定放在            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: false,            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;setupCommands&quot;: [                &#123;                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ],            &#x2F;&#x2F; 这个是指定我们的gdb调试路径，笔者的位置在这里，你需要自己指定一个路径            &quot;miDebuggerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gdb-multiarch&quot;,            &#x2F;&#x2F; 这个就是我们的调试的IP和地址，跟你设置target remote的IP端口一致            &quot;miDebuggerServerAddress&quot;: &quot;10.41.0.50:2001&quot;        &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="./show.png" alt="截图 2024-12-13 12-02-50"></p><p>​    现在我们运行，就发现成功的停在断点上了！Cheers!</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>解决undefined symbol: PyUnicodeUCS4_FromEncodedObject: <a href="https://stackoverflow.com/questions/8010384/pyunicodeucs4-fromencodedobject-error">python - PyUnicodeUCS4_FromEncodedObject Error - Stack Overflow</a></li><li><a href="https://zhuanlan.zhihu.com/p/20797436">Linux命令之update-alternatives - 知乎 (zhihu.com)</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2下使用miniconda+cuda+cudnn方案进行机器/深度学习环境配置方案</title>
      <link href="/2024/11/15/WSL2%E4%B8%8B%E4%BD%BF%E7%94%A8miniconda-cuda-cudnn%E6%96%B9%E6%A1%88%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/"/>
      <url>/2024/11/15/WSL2%E4%B8%8B%E4%BD%BF%E7%94%A8miniconda-cuda-cudnn%E6%96%B9%E6%A1%88%E8%BF%9B%E8%A1%8C%E6%9C%BA%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="WSL2下使用miniconda-cuda-cudnn方案进行机器-深度学习环境配置方案"><a href="#WSL2下使用miniconda-cuda-cudnn方案进行机器-深度学习环境配置方案" class="headerlink" title="WSL2下使用miniconda + cuda + cudnn方案进行机器/深度学习环境配置方案"></a>WSL2下使用miniconda + cuda + cudnn方案进行机器/深度学习环境配置方案</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    笔者这几天需要使用Google的mediapipe框架进行自定义的数据训练，值得注意到的是Google家的这个方便的自定义训练只支持在Linux下完成。具体原因可以参考到</p><blockquote><p><a href="https://docs.python.org/3/library/tty.html">tty — Terminal control functions — Python 3.13.0 documentation</a></p></blockquote><p>​    也即是google.colab库需要的环境就是Unix系的OS。。。所以没办法（耸肩），只好在WSL上完成mediapipe应用框架的搭建，刚好笔者准备尝鲜。</p><h2 id="方案简单前置"><a href="#方案简单前置" class="headerlink" title="方案简单前置"></a>方案简单前置</h2><ol><li><p>笔者认为您的电脑已经安装好了WSL2且使用的是默认的发行版（Ubuntu）</p><pre class="line-numbers language-none"><code class="language-none">➜  wsl --list适用于 Linux 的 Windows 子系统分发:Ubuntu-24.04 (默认)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>您可以参考任何一篇安装WSL2的教程，笔者认为官方的最为权威：</p><blockquote><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">https://learn.microsoft.com/zh-cn/windows/wsl/install</a></p></blockquote></li><li><p>笔者认为您的电脑上有可以使用的GPU用于深度学习模型的训练。</p><blockquote><p>笔者自己就在windows上有nvcc等工具链，因此直接梭哈，当然没有也没关系，我们后面安装的是WSL的驱动</p></blockquote><pre class="line-numbers language-none"><code class="language-none">➜  nvcc --versionnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2024 NVIDIA CorporationBuilt on Fri_Jun_14_16:44:19_Pacific_Daylight_Time_2024Cuda compilation tools, release 12.6, V12.6.20Build cuda_12.6.r12.6&#x2F;compiler.34431801_0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>笔者认为您的电脑已经安装好了vscode。且安装好了python插件用于辅助我们在VSCode上书写Python程序</p></li></ol><h2 id="方案配置说明"><a href="#方案配置说明" class="headerlink" title="方案配置说明"></a>方案配置说明</h2><p>​    最终，你的WSL2的目标发行版上将会有一个可以使用Host OS上正在使用的GPU训练深度模型的一个深度学习框架。</p><h2 id="Step-1-安装Miniconda"><a href="#Step-1-安装Miniconda" class="headerlink" title="Step 1: 安装Miniconda"></a>Step 1: 安装Miniconda</h2><blockquote><p><a href="https://docs.anaconda.com/miniconda/">Miniconda — Anaconda documentation</a></p></blockquote><p>​    这是Miniconda的官方网站，下载这个的原因十分简单：它简单轻量。</p><blockquote><p>有代理的朋友直接使用wget梭哈脚本就行了</p><p>没有代理的朋友使用清华源下载：</p><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;miniconda&#x2F;Miniconda3-latest-Linux-x86_64.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>特定版本的前往：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=N&amp;O=D">Index of /anaconda/miniconda/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a>慢慢搜索</p></blockquote><p>​    使用wget下好脚本之后，我们就可以梭哈了。</p><pre class="line-numbers language-none"><code class="language-none">bash Miniconda3-latest-Linux-x86_64.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    一路摁enter（默认的，我懒）</p><h2 id="STEP-2-创建一个环境"><a href="#STEP-2-创建一个环境" class="headerlink" title="STEP 2: 创建一个环境"></a>STEP 2: 创建一个环境</h2><p>​    但是你会发现：你没有办法使用conda，因为你的bash没有检索到它！</p><pre class="line-numbers language-none"><code class="language-none">export PATH&#x3D;$PATH:&#x2F;home&#x2F;charliechen&#x2F;miniconda3&#x2F;bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    笔者的偷懒办法是在自己的bashrc上添加一行这个，让我们的环境变量找到我们的conda可执行文件就OK！</p><pre class="line-numbers language-none"><code class="language-none">➜  conda --helpusage: conda [-h] [-v] [--no-plugins] [-V] COMMAND ...conda is a tool for managing and deploying applications, environments and packages....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    现在输出就是正确的了。</p><p>​    下面我们创建一个环境，使用conda创建环境很简单：</p><pre class="line-numbers language-none"><code class="language-none">conda -n env_name(不要照抄！自己设置一个有意义的名字) python&#x3D;python_version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    举个例子，笔者的创建是：</p><pre class="line-numbers language-none"><code class="language-none">conda -n Ican_Model_Train python&#x3D;3.8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    现在，使用</p><pre class="line-numbers language-none"><code class="language-none">conda activate Ican_Model_Train<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    激活我们刚刚创建的环境，这个时候你会发现你的shell多了（Ican_Model_Train），那就是成功了。</p><h2 id="STEP-3-VSCode链接WSL虚拟机"><a href="#STEP-3-VSCode链接WSL虚拟机" class="headerlink" title="STEP 3: VSCode链接WSL虚拟机"></a>STEP 3: VSCode链接WSL虚拟机</h2><p>​    这个事情参考WSL如何链接虚拟机：<a href="https://learn.microsoft.com/en-us/windows/wsl/tutorials/wsl-vscode">Get started using VS Code with WSL | Microsoft Learn</a></p><h2 id="STEP-4：安装WSL的nvidia-tool-kit"><a href="#STEP-4：安装WSL的nvidia-tool-kit" class="headerlink" title="STEP 4：安装WSL的nvidia tool kit"></a>STEP 4：安装WSL的nvidia tool kit</h2><p>​    欸！先别急着apt install，不是这样玩的：</p><blockquote><p><a href="https://docs.nvidia.com/cuda/wsl-user-guide/index.html#getting-started-with-cuda-on-wsl-2">CUDA on WSL (nvidia.com)</a></p></blockquote><p>​    参考官网的教程，人家叫你使用手动安装的方式，WSL现在可以直通GPU了。所以不要使用旧的方案！！！<strong>不要使用旧的方案！！！</strong></p><p>​    办法是：<a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-Ubuntu&amp;target_version=2.0">CUDA Toolkit 12.6 Update 2 Downloads | NVIDIA Developer</a></p><pre class="line-numbers language-none"><code class="language-none">wget https:&#x2F;&#x2F;developer.download.nvidia.com&#x2F;compute&#x2F;cuda&#x2F;repos&#x2F;wsl-ubuntu&#x2F;x86_64&#x2F;cuda-wsl-ubuntu.pinsudo mv cuda-wsl-ubuntu.pin &#x2F;etc&#x2F;apt&#x2F;preferences.d&#x2F;cuda-repository-pin-600wget https:&#x2F;&#x2F;developer.download.nvidia.com&#x2F;compute&#x2F;cuda&#x2F;12.6.2&#x2F;local_installers&#x2F;cuda-repo-wsl-ubuntu-12-6-local_12.6.2-1_amd64.debsudo dpkg -i cuda-repo-wsl-ubuntu-12-6-local_12.6.2-1_amd64.debsudo cp &#x2F;var&#x2F;cuda-repo-wsl-ubuntu-12-6-local&#x2F;cuda-*-keyring.gpg &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;sudo apt-get updatesudo apt-get -y install cuda-toolkit-12-6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    笔者列出来当时Nvidia官方给予我的方案。如上所示，照做即可。看官可以自行进入上述网址完成自己的方案配置。</p><p>​    检查我们的安装是否正常：</p><pre class="line-numbers language-none"><code class="language-none">➜  nvidia-smi # 这个是Windows上如果就有就会带，没有请安装Windows的nvidia-smi程序！在Windows上的！！！Thu Oct 10 23:16:41 2024+-----------------------------------------------------------------------------------------+| NVIDIA-SMI 560.28.03              Driver Version: 560.76         CUDA Version: 12.6     ||-----------------------------------------+------------------------+----------------------+| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC || Fan  Temp   Perf          Pwr:Usage&#x2F;Cap |           Memory-Usage | GPU-Util  Compute M. ||                                         |                        |               MIG M. ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;||   0  NVIDIA GeForce RTX 3060 ...    On  |   00000000:01:00.0  On |                  N&#x2F;A || N&#x2F;A   39C    P8             14W &#x2F;   95W |    1450MiB &#x2F;   6144MiB |      3%      Default ||                                         |                        |                  N&#x2F;A |+-----------------------------------------+------------------------+----------------------++-----------------------------------------------------------------------------------------+| Processes:                                                                              ||  GPU   GI   CI        PID   Type   Process name                              GPU Memory ||        ID   ID                                                               Usage      ||&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;||    0   N&#x2F;A  N&#x2F;A        25      G   &#x2F;Xwayland                                   N&#x2F;A      |+-----------------------------------------------------------------------------------------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">➜  nvcc --versionnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2024 NVIDIA CorporationBuilt on Thu_Sep_12_02:18:05_PDT_2024Cuda compilation tools, release 12.6, V12.6.77Build cuda_12.6.r12.6&#x2F;compiler.34841621_0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    如果你的nvcc —version找不到，不要气馁：</p><pre class="line-numbers language-none"><code class="language-none">export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;libexport PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;cuda&#x2F;bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    现在试试看！成功的话可以考虑写入bashrc文件！</p><h2 id="STEP-5：安装上层框架"><a href="#STEP-5：安装上层框架" class="headerlink" title="STEP 5：安装上层框架"></a>STEP 5：安装上层框架</h2><p>​    笔者玩的是Google MediaPipe，所以只需要一行话就可以把所有的上层框架装好就行！当然，如果是tensorflow，那就需要安装如下的python接口库：</p><pre class="line-numbers language-none"><code class="language-none">conda install -c conda-forge cudatoolkit&#x3D;11.8.0pip install nvidia-cudnn-cu11&#x3D;&#x3D;8.6.0.163<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    版本可以自行调整，建议如果常常使用GPU，将加载写入conda目标虚拟环境的加载脚本中</p><pre class="line-numbers language-none"><code class="language-none">mkdir -p $CONDA_PREFIX&#x2F;etc&#x2F;conda&#x2F;activate.d#如果跳过了第三节，则即使用sudo下面的命令也会报权限错误，需要在~&#x2F;miniconda3&#x2F;etc&#x2F;conda&#x2F;activate.d目录下新建env_vars.sh文件，将单引号中的内容复制到文件中echo &#39;CUDNN_PATH&#x3D;$(dirname $(python -c &quot;import nvidia.cudnn;print(nvidia.cudnn.__file__)&quot;))&#39; &gt;&gt; $CONDA_PREFIX&#x2F;etc&#x2F;conda&#x2F;activate.d&#x2F;env_vars.shecho &#39;export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:$CONDA_PREFIX&#x2F;lib&#x2F;:$CUDNN_PATH&#x2F;lib&#39; &gt;&gt; $CONDA_PREFIX&#x2F;etc&#x2F;conda&#x2F;activate.d&#x2F;env_vars.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    现在我们的动态依赖库安装好了</p><p>​    下面就是安装torch或者是tensorflow了</p><h3 id="Optional-if-target-is-torch-安装torch"><a href="#Optional-if-target-is-torch-安装torch" class="headerlink" title="[Optional if target is torch]安装torch"></a>[Optional if target is torch]安装torch</h3><p>​    查看<a href="https://pytorch.org/">PyTorch</a>的解决方案就行</p><h3 id="Optional-if-using-Tensorflow-安装tensourflow"><a href="#Optional-if-using-Tensorflow-安装tensourflow" class="headerlink" title="[Optional if using Tensorflow]安装tensourflow"></a>[Optional if using Tensorflow]安装tensourflow</h3><pre class="line-numbers language-none"><code class="language-none">pip install tensorflow<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="笔者玩的mediapipe"><a href="#笔者玩的mediapipe" class="headerlink" title="笔者玩的mediapipe"></a>笔者玩的mediapipe</h3><pre class="line-numbers language-none"><code class="language-none">pip install mediapipe-model-maker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="STEP-6：测试"><a href="#STEP-6：测试" class="headerlink" title="STEP 6：测试"></a>STEP 6：测试</h2><h3 id="Tensorflow系列"><a href="#Tensorflow系列" class="headerlink" title="Tensorflow系列"></a>Tensorflow系列</h3><p>​    mediapipe底下使用的是tensorflow，因此这里可以合并检测tensorflow的使用</p><pre class="line-numbers language-none"><code class="language-none">➜  head model_train.py -n 30# from google.colab import filesimport osimport tensorrt as trtimport tensorflow as tfassert tf.__version__.startswith(&#39;2&#39;)print(tf.__version__)from mediapipe_model_maker import gesture_recognizerimport tensorflow as tfprint(tf.test.is_gpu_available())# Trueprint(tf.config.list_physical_devices(&#39;GPU&#39;))# 你的GPU列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Torch系列"><a href="#Torch系列" class="headerlink" title="Torch系列"></a>Torch系列</h3><pre class="line-numbers language-none"><code class="language-none">torch.cuda.is_available()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>若返回为True，则使用的是GPU版本的torch，若为False，则为CPU版本</p></blockquote><pre class="line-numbers language-none"><code class="language-none">print(torch.cuda.get_device_name(0))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    返回的GPU型号为你使用的GPU型号</p><h2 id="STEP-7-开始愉悦炼丹！"><a href="#STEP-7-开始愉悦炼丹！" class="headerlink" title="STEP 7:开始愉悦炼丹！"></a>STEP 7:开始愉悦炼丹！</h2>]]></content>
      
      
      
        <tags>
            
            <tag> wsl </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32单片机之分析启动文件小论(II)</title>
      <link href="/2024/11/15/STM32%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8B%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%B0%8F%E8%AE%BA-II/"/>
      <url>/2024/11/15/STM32%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8B%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%B0%8F%E8%AE%BA-II/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​    请各位看官看本篇笔记的时候首先了解一下计算机体系架构，了解基本的arm汇编后再来阅读此教程。当然不必深入，了解即可。</p><p>​    对于一些弱符号含义，笔者已经放到Help当中，请酌情参考（笔者不是特别熟悉ARM汇编）！</p><h2 id="速通：做了什么："><a href="#速通：做了什么：" class="headerlink" title="速通：做了什么："></a>速通：做了什么：</h2><p>​    这个是ST公司在startup_stm32f103xe.s文件的开头所写。</p><ol><li>初始化堆栈指针 SP = _initial_sp </li><li>初始化程序计数器指针 PC = Reset_Handler </li><li>设置堆和栈的大小 </li><li>初始化中断向量表 </li><li>配置外部SRAM 作为数据存储器（可选） </li><li>配置系统时钟，通过调用SystemInit 函数（可选） </li><li>调用 C 库中的 _main 函数初始化用户堆栈，最终调用 main 函数 </li></ol><h2 id="分析I：分析2011年的startup文件所作"><a href="#分析I：分析2011年的startup文件所作" class="headerlink" title="分析I：分析2011年的startup文件所作"></a>分析I：分析2011年的startup文件所作</h2><p>​    老一部分的分析，笔者这里推介的是自己写的：</p><blockquote><p><a href="https://blog.csdn.net/charlie114514191/article/details/137664579?ops_request_misc=%7B%22request%5Fid%22%3A%22CFEE748F-1EDB-4DA5-B743-C3BD181EB61B%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=CFEE748F-1EDB-4DA5-B743-C3BD181EB61B&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-137664579-null-null.nonecase&amp;utm_term=STM &amp;spm=1018.2226.3001.4450">STM32启动流程简述_defined(stm32f103xe)-CSDN博客</a></p></blockquote><p>​    现在看看有点太随意了，重新阐述一下：</p><pre class="line-numbers language-none"><code class="language-none">; Amount of memory (in bytes) allocated for Stack; Tailor this value to your application needs; &lt;h&gt; Stack Configuration;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;; &lt;&#x2F;h&gt;Stack_Size      EQU     0x00000400                AREA    STACK, NOINIT, READWRITE, ALIGN&#x3D;3Stack_Mem       SPACE   Stack_Size__initial_sp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    先说栈多大！熟悉操作系统的人都知道必须要首先定义栈的大小！这样的话才方便分配空间，同时这个栈就是我们操作数据保存数据的一个重要的中转点！ </p><p>​    下一部分我们讨论的是对我们知道堆是程序运行中的一个重要的部分。（malloc在这里申请！）</p><pre class="line-numbers language-none"><code class="language-none">; &lt;h&gt; Heap Configuration;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;; &lt;&#x2F;h&gt;Heap_Size       EQU     0x00000200                AREA    HEAP, NOINIT, READWRITE, ALIGN&#x3D;3__heap_baseHeap_Mem        SPACE   Heap_Size__heap_limit                PRESERVE8                THUMB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    下面这里我们导出了一些符号，这些符号如果各位仔细看的话就是中断处理函数！也就是说STM32在发生中断时就会根据对应的中断类型跳转进入对应的中断处理子程序。 在这段程序的结尾定义了大小！</p><pre class="line-numbers language-none"><code class="language-none">; Vector Table Mapped to Address 0 at Reset                AREA    RESET, DATA, READONLY                EXPORT  __Vectors                EXPORT  __Vectors_End                EXPORT  __Vectors_Size__Vectors       DCD     __initial_sp               ; Top of Stack...__Vectors_End__Vectors_Size  EQU  __Vectors_End - __Vectors                AREA    |.text|, CODE, READONLY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    下面这个片段非常的重要因为它定义了我们STM32从上电到执行我们程序中最重要的几个部分：即首先执行了：SystemInit，然后跳转道__main函数，最终程序进入我们的main进行代码执行！</p><pre class="line-numbers language-none"><code class="language-none">; Reset handlerReset_Handler    PROC                 EXPORT  Reset_Handler             [WEAK]     IMPORT  __main     IMPORT  SystemInit                 LDR     R0, &#x3D;SystemInit                 BLX     R0                 LDR     R0, &#x3D;__main                 BX      R0                 END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    中间更大一部分定义了一些默认的中断处理子程序如果我们修改了这些子程序入口地址子，它也就会调用我们修改的而不是默认的！（当然不要直接汇编改，注册中断更为好！） </p><p>​    最后是：</p><pre class="line-numbers language-none"><code class="language-none">;*******************************************************************************; User Stack and Heap initialization;*******************************************************************************                 IF      :DEF:__MICROLIB                                            EXPORT  __initial_sp                 EXPORT  __heap_base                 EXPORT  __heap_limit                                 ELSE                                 IMPORT  __use_two_region_memory                 EXPORT  __user_initial_stackheap                 __user_initial_stackheap                 LDR     R0, &#x3D;  Heap_Mem                 LDR     R1, &#x3D;(Stack_Mem + Stack_Size)                 LDR     R2, &#x3D; (Heap_Mem +  Heap_Size)                 LDR     R3, &#x3D; Stack_Mem                 BX      LR                 ALIGN                 ENDIF                 END;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    最后这一段无非就是在问是否定义了MICROLIB宏。如果使用了MICROLIB，那么程序的启动就使用St公司提供的微库！如果不是就，使用用户提供的初始化函数。</p><p>​    对比2017年St公司提供的汇编启动文件，11年的启动文件就显得相对的简单。</p><h2 id="分析II：分析2017年的startup文件所作"><a href="#分析II：分析2017年的startup文件所作" class="headerlink" title="分析II：分析2017年的startup文件所作"></a>分析II：分析2017年的startup文件所作</h2><p>​    对比来看，2017年的汇编文件使用的arm汇编更为现代（至少nasm味道很冲）。在开头定义和初始化了一些程序启动必备的段： <code>.data</code> 和 BSS 段。<code>.data</code> 段用于存放已初始化的全局和静态变量，而 BSS 段用于存放未初始化的全局和静态变量。</p><p>​    下面就是经典的初始化Reset处理程序以及告知到哪里跳转到main函数：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;** * @brief  This is the code that gets called when the processor first *          starts execution following a reset event. Only the absolutely *          necessary set is performed, after which the application *          supplied main() routine is called. * @param  None * @retval : None*&#x2F;  .section .text.Reset_Handler  .weak Reset_Handler  .type Reset_Handler, %functionReset_Handler:&#x2F;* 给时钟做初始化 *&#x2F;&#x2F;* Call the clock system initialization function.*&#x2F;    bl  SystemInit&#x2F;* Copy the data segment initializers from flash to SRAM *&#x2F;  ldr r0, &#x3D;_sdata  ldr r1, &#x3D;_edata  ldr r2, &#x3D;_sidata  movs r3, #0  b LoopCopyDataInit&#x2F;* 设置寄存器，准备好源地址和目的地址 *&#x2F;CopyDataInit:  ldr r4, [r2, r3]  str r4, [r0, r3]  adds r3, r3, #4&#x2F;* 循环体！ *&#x2F;LoopCopyDataInit:  adds r4, r0, r3  cmp r4, r1  bcc CopyDataInit  &#x2F;* Zero fill the bss segment. *&#x2F;  ldr r2, &#x3D;_sbss  ldr r4, &#x3D;_ebss  movs r3, #0  b LoopFillZerobssFillZerobss:  str  r3, [r2]  adds r2, r2, #4LoopFillZerobss:  cmp r2, r4  bcc FillZerobss&#x2F;* Call static constructors *&#x2F;    bl __libc_init_array&#x2F;* Call the application&#39;s entry point.*&#x2F;  bl main  bx lr.size Reset_Handler, .-Reset_Handler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    在下面就比2011年的文件更加干净了，就是定义了tables和默认的处理子程序。而且没有废话。具体参考最下面我贴出来的文件。</p><h2 id="Helps"><a href="#Helps" class="headerlink" title="Helps"></a>Helps</h2><h3 id="2011"><a href="#2011" class="headerlink" title="2011"></a>2011</h3><div class="table-container"><table><thead><tr><th>指令</th><th>详细说明</th></tr></thead><tbody><tr><td>EQU</td><td><code>EQU</code> 指令用于为一个数字常量取一个符号名，相当于 C 语言中的 <code>#define</code>。通过这种方式，可以为常量提供一个易于识别的名称，从而提高代码的可读性和可维护性。例如，可以使用 <code>VALUE EQU 10</code> 来定义一个名为 <code>VALUE</code> 的常量，其值为 <code>10</code>。可以联想到nasm的equ，一个意思！</td></tr><tr><td>AREA</td><td><code>AREA</code> 指令用于定义一个新的代码段或数据段。它可以指定段的名称、类型（如代码段或数据段），以及其他属性。在汇编程序中，代码和数据通常被组织成不同的区域，以便于管理和访问。</td></tr><tr><td>ALIGN</td><td><code>ALIGN</code> 指令用于对齐数据或指令的存放地址。它通常需要跟一个立即数，表示对齐的字节数。默认情况下，缺省值为 4 字节对齐。<strong>对齐可以提高内存访问效率，确保数据在合适的地址边界上存放。</strong>（大部分架构要求严格的对齐！）</td></tr><tr><td>SPACE</td><td><code>SPACE</code> 指令用于分配指定数量的字节内存空间。这可以用于为数据结构、数组或其他需要在内存中分配空间的元素分配内存。分配的内存不会被初始化。</td></tr><tr><td>PRESERVE8</td><td><code>PRESERVE8</code> 指令用于指定当前文件的堆栈需要按照 8 字节对齐。这在处理某些数据结构（如 64 位数据类型）时很重要，因为不正确的对齐可能会导致性能下降或硬件故障。</td></tr><tr><td>THUMB</td><td><code>THUMB</code> 指令用于指示后续指令使用 THUMB 指令集，这是一种用于 ARM 处理器的指令集架构。Cortex-M 系列微控制器使用 THUMB-2 指令集，它支持 16 位和 32 位指令，旨在提高代码密度并减少内存占用。</td></tr><tr><td>EXPORT</td><td><code>EXPORT</code> 指令用于声明一个标号具有全局属性，这意味着该标号可以被其他外部文件访问。它用于模块化编程，使得不同模块之间可以共享函数或数据。</td></tr><tr><td>DCD</td><td><code>DCD</code> 指令用于以字节为单位分配内存，并要求内存按照 4 字节对齐，同时初始化这些内存。可以在指令后面跟随初始化值，通常用于定义常量数组或数据结构。</td></tr><tr><td>PROC</td><td><code>PROC</code> 指令用于定义一个子程序，与 <code>ENDP</code> 指令配对使用。它标志着一个子程序的开始和结束，允许代码的重用和结构化，提高程序的可读性和可维护性。</td></tr><tr><td>WEAK</td><td><code>WEAK</code> 指令用于声明一个弱定义的标号。如果外部文件中存在同名的标号，则优先使用外部文件定义的标号；如果没有定义，则使用当前文件中的定义。这在实现库时很有用，可以允许用户自定义某些功能，而不会导致链接错误。</td></tr><tr><td>IMPORT</td><td><code>IMPORT</code> 指令用于声明一个标号来自外部文件，类似于 C 语言中的 <code>extern</code> 关键字。这使得可以在当前汇编文件中引用其他模块或库中的标号。</td></tr><tr><td>LDR</td><td><code>LDR</code> 指令用于从存储器中加载一个字到指定的寄存器。它用于读取数据并将其存储在处理器的寄存器中，以便进行后续操作。这是 ARM 汇编语言中非常重要的一个指令，用于内存访问。</td></tr><tr><td>BLX</td><td><code>BLX</code> 指令用于跳转到由寄存器给出的地址，同时保存跳转前的下一条指令地址到链接寄存器（LR）。此指令还根据寄存器的最低有效位（LSE）确定处理器的状态，以支持 THUMB 指令集和 ARM 指令集之间的切换。</td></tr><tr><td>BX</td><td><code>BX</code> 指令用于跳转到由寄存器或标号给出的地址，并不保存返回地址。这在函数调用或中断处理时常用，以直接跳转到新的执行位置。</td></tr><tr><td>B</td><td><code>B</code> 指令用于无条件地跳转到一个标号，常用于控制程序的流程。这是实现循环和条件执行的基础。</td></tr><tr><td>IF, ELSE, ENDIF</td><td>这些指令用于实现汇编条件分支语句，类似于 C 语言中的 <code>if</code>、<code>else</code> 和 <code>endif</code> 结构。它们允许在汇编代码中根据条件选择执行不同的代码块。</td></tr><tr><td>END</td><td><code>END</code> 指令用于标记汇编文件的末尾，表示编译器可以停止处理该文件。这是每个汇编源文件的结束标志。</td></tr></tbody></table></div><h3 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h3><div class="table-container"><table><thead><tr><th>伪指令</th><th>含义</th></tr></thead><tbody><tr><td><code>.syntax unified</code></td><td>指定使用统一汇编语法，适用于 ARM 和 THUMB 模式。</td></tr><tr><td><code>.cpu cortex-m3</code></td><td>指定目标 CPU 为 Cortex-M3。</td></tr><tr><td><code>.fpu softvfp</code></td><td>指定使用软件浮点支持。</td></tr><tr><td><code>.thumb</code></td><td>指定后续代码使用 THUMB 指令集。</td></tr><tr><td><code>.global</code></td><td>声明全局符号，使得该符号在其他模块或文件中可被引用。</td></tr><tr><td><code>.word</code></td><td>定义一个或多个字（4 字节）数据，通常用于定义内存地址或数据常量。</td></tr><tr><td><code>.equ</code></td><td>定义常量，用于在代码中使用易读的符号名代替数值。</td></tr><tr><td><code>.section</code></td><td>指定代码或数据的段（section），以组织代码和数据。</td></tr><tr><td><code>.weak</code></td><td>声明弱符号，允许其他具有相同名称的符号覆盖该符号。</td></tr><tr><td><code>.type</code></td><td>指定符号的类型，如函数或对象。</td></tr><tr><td><code>.size</code></td><td>指定符号的大小，通常用于描述函数或数据段的长度。</td></tr><tr><td><code>.bss</code></td><td>表示未初始化的数据段，通常用于分配内存。</td></tr><tr><td><code>.text</code></td><td>指定代码段，用于放置程序的指令。</td></tr><tr><td><code>.data</code></td><td>指定已初始化的数据段，用于存放已初始化的变量。</td></tr><tr><td><code>.isr_vector</code></td><td>指定中断向量表段，通常用于定义中断处理程序的地址。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td><code>bl</code></td><td>分支到指定地址的函数，同时将返回地址存储到链接寄存器（LR），用于函数调用。</td></tr><tr><td><code>ldr</code></td><td>从内存中加载一个字（4 字节）到指定的寄存器中。</td></tr><tr><td><code>str</code></td><td>将寄存器中的值存储到内存中指定的地址。</td></tr><tr><td><code>movs</code></td><td>将一个立即数移动到寄存器中，并更新状态寄存器的条件标志。</td></tr><tr><td><code>adds</code></td><td>将两个寄存器的值相加，并将结果存储在第一个寄存器中，同时更新状态寄存器的条件标志。</td></tr><tr><td><code>cmp</code></td><td>比较两个寄存器的值，并更新状态寄存器，以便进行条件跳转。</td></tr><tr><td><code>bcc</code></td><td>如果前一次比较的结果小于，则进行条件跳转（无符号比较）。</td></tr><tr><td><code>b</code></td><td>无条件跳转到指定的标签或地址。</td></tr><tr><td><code>bx</code></td><td>跳转到寄存器中指定的地址，并返回到调用点。</td></tr></tbody></table></div><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><pre class="line-numbers language-none"><code class="language-none">;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************;* File Name          : startup_stm32f10x_md.s;* Author             : MCD Application Team;* Version            : V3.5.0;* Date               : 11-March-2011;* Description        : STM32F10x Medium Density Devices vector table for MDK-ARM ;*                      toolchain.  ;*                      This module performs:;*                      - Set the initial SP;*                      - Set the initial PC &#x3D;&#x3D; Reset_Handler;*                      - Set the vector table entries with the exceptions ISR address;*                      - Configure the clock system;*                      - Branches to __main in the C library (which eventually;*                        calls main()).;*                      After Reset the CortexM3 processor is in Thread mode,;*                      priority is Privileged, and the Stack is set to Main.;* &lt;&lt;&lt; Use Configuration Wizard in Context Menu &gt;&gt;&gt;   ;*******************************************************************************; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE; CONTENT OF SUCH FIRMWARE AND&#x2F;OR THE USE MADE BY CUSTOMERS OF THE CODING; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.;*******************************************************************************; Amount of memory (in bytes) allocated for Stack; Tailor this value to your application needs; &lt;h&gt; Stack Configuration;   &lt;o&gt; Stack Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;; &lt;&#x2F;h&gt;Stack_Size      EQU     0x00000400                AREA    STACK, NOINIT, READWRITE, ALIGN&#x3D;3Stack_Mem       SPACE   Stack_Size__initial_sp; &lt;h&gt; Heap Configuration;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;; &lt;&#x2F;h&gt;Heap_Size       EQU     0x00000200                AREA    HEAP, NOINIT, READWRITE, ALIGN&#x3D;3__heap_baseHeap_Mem        SPACE   Heap_Size__heap_limit                PRESERVE8                THUMB; Vector Table Mapped to Address 0 at Reset                AREA    RESET, DATA, READONLY                EXPORT  __Vectors                EXPORT  __Vectors_End                EXPORT  __Vectors_Size__Vectors       DCD     __initial_sp               ; Top of Stack                DCD     Reset_Handler              ; Reset Handler                DCD     NMI_Handler                ; NMI Handler                DCD     HardFault_Handler          ; Hard Fault Handler                DCD     MemManage_Handler          ; MPU Fault Handler                DCD     BusFault_Handler           ; Bus Fault Handler                DCD     UsageFault_Handler         ; Usage Fault Handler                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     0                          ; Reserved                DCD     SVC_Handler                ; SVCall Handler                DCD     DebugMon_Handler           ; Debug Monitor Handler                DCD     0                          ; Reserved                DCD     PendSV_Handler             ; PendSV Handler                DCD     SysTick_Handler            ; SysTick Handler                ; External Interrupts                DCD     WWDG_IRQHandler            ; Window Watchdog                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect                DCD     TAMPER_IRQHandler          ; Tamper                DCD     RTC_IRQHandler             ; RTC                DCD     FLASH_IRQHandler           ; Flash                DCD     RCC_IRQHandler             ; RCC                DCD     EXTI0_IRQHandler           ; EXTI Line 0                DCD     EXTI1_IRQHandler           ; EXTI Line 1                DCD     EXTI2_IRQHandler           ; EXTI Line 2                DCD     EXTI3_IRQHandler           ; EXTI Line 3                DCD     EXTI4_IRQHandler           ; EXTI Line 4                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7                DCD     ADC1_2_IRQHandler          ; ADC1_2                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break                DCD     TIM1_UP_IRQHandler         ; TIM1 Update                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare                DCD     TIM2_IRQHandler            ; TIM2                DCD     TIM3_IRQHandler            ; TIM3                DCD     TIM4_IRQHandler            ; TIM4                DCD     I2C1_EV_IRQHandler         ; I2C1 Event                DCD     I2C1_ER_IRQHandler         ; I2C1 Error                DCD     I2C2_EV_IRQHandler         ; I2C2 Event                DCD     I2C2_ER_IRQHandler         ; I2C2 Error                DCD     SPI1_IRQHandler            ; SPI1                DCD     SPI2_IRQHandler            ; SPI2                DCD     USART1_IRQHandler          ; USART1                DCD     USART2_IRQHandler          ; USART2                DCD     USART3_IRQHandler          ; USART3                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend__Vectors_End__Vectors_Size  EQU  __Vectors_End - __Vectors                AREA    |.text|, CODE, READONLY; Reset handlerReset_Handler    PROC                 EXPORT  Reset_Handler             [WEAK]     IMPORT  __main     IMPORT  SystemInit                 LDR     R0, &#x3D;SystemInit                 BLX     R0                 LDR     R0, &#x3D;__main                 BX      R0                 ENDP; Dummy Exception Handlers (infinite loops which can be modified)NMI_Handler     PROC                EXPORT  NMI_Handler                [WEAK]                B       .                ENDPHardFault_Handler\                PROC                EXPORT  HardFault_Handler          [WEAK]                B       .                ENDPMemManage_Handler\                PROC                EXPORT  MemManage_Handler          [WEAK]                B       .                ENDPBusFault_Handler\                PROC                EXPORT  BusFault_Handler           [WEAK]                B       .                ENDPUsageFault_Handler\                PROC                EXPORT  UsageFault_Handler         [WEAK]                B       .                ENDPSVC_Handler     PROC                EXPORT  SVC_Handler                [WEAK]                B       .                ENDPDebugMon_Handler\                PROC                EXPORT  DebugMon_Handler           [WEAK]                B       .                ENDPPendSV_Handler  PROC                EXPORT  PendSV_Handler             [WEAK]                B       .                ENDPSysTick_Handler PROC                EXPORT  SysTick_Handler            [WEAK]                B       .                ENDPDefault_Handler PROC                EXPORT  WWDG_IRQHandler            [WEAK]                EXPORT  PVD_IRQHandler             [WEAK]                EXPORT  TAMPER_IRQHandler          [WEAK]                EXPORT  RTC_IRQHandler             [WEAK]                EXPORT  FLASH_IRQHandler           [WEAK]                EXPORT  RCC_IRQHandler             [WEAK]                EXPORT  EXTI0_IRQHandler           [WEAK]                EXPORT  EXTI1_IRQHandler           [WEAK]                EXPORT  EXTI2_IRQHandler           [WEAK]                EXPORT  EXTI3_IRQHandler           [WEAK]                EXPORT  EXTI4_IRQHandler           [WEAK]                EXPORT  DMA1_Channel1_IRQHandler   [WEAK]                EXPORT  DMA1_Channel2_IRQHandler   [WEAK]                EXPORT  DMA1_Channel3_IRQHandler   [WEAK]                EXPORT  DMA1_Channel4_IRQHandler   [WEAK]                EXPORT  DMA1_Channel5_IRQHandler   [WEAK]                EXPORT  DMA1_Channel6_IRQHandler   [WEAK]                EXPORT  DMA1_Channel7_IRQHandler   [WEAK]                EXPORT  ADC1_2_IRQHandler          [WEAK]                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK]                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK]                EXPORT  CAN1_RX1_IRQHandler        [WEAK]                EXPORT  CAN1_SCE_IRQHandler        [WEAK]                EXPORT  EXTI9_5_IRQHandler         [WEAK]                EXPORT  TIM1_BRK_IRQHandler        [WEAK]                EXPORT  TIM1_UP_IRQHandler         [WEAK]                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK]                EXPORT  TIM1_CC_IRQHandler         [WEAK]                EXPORT  TIM2_IRQHandler            [WEAK]                EXPORT  TIM3_IRQHandler            [WEAK]                EXPORT  TIM4_IRQHandler            [WEAK]                EXPORT  I2C1_EV_IRQHandler         [WEAK]                EXPORT  I2C1_ER_IRQHandler         [WEAK]                EXPORT  I2C2_EV_IRQHandler         [WEAK]                EXPORT  I2C2_ER_IRQHandler         [WEAK]                EXPORT  SPI1_IRQHandler            [WEAK]                EXPORT  SPI2_IRQHandler            [WEAK]                EXPORT  USART1_IRQHandler          [WEAK]                EXPORT  USART2_IRQHandler          [WEAK]                EXPORT  USART3_IRQHandler          [WEAK]                EXPORT  EXTI15_10_IRQHandler       [WEAK]                EXPORT  RTCAlarm_IRQHandler        [WEAK]                EXPORT  USBWakeUp_IRQHandler       [WEAK]WWDG_IRQHandlerPVD_IRQHandlerTAMPER_IRQHandlerRTC_IRQHandlerFLASH_IRQHandlerRCC_IRQHandlerEXTI0_IRQHandlerEXTI1_IRQHandlerEXTI2_IRQHandlerEXTI3_IRQHandlerEXTI4_IRQHandlerDMA1_Channel1_IRQHandlerDMA1_Channel2_IRQHandlerDMA1_Channel3_IRQHandlerDMA1_Channel4_IRQHandlerDMA1_Channel5_IRQHandlerDMA1_Channel6_IRQHandlerDMA1_Channel7_IRQHandlerADC1_2_IRQHandlerUSB_HP_CAN1_TX_IRQHandlerUSB_LP_CAN1_RX0_IRQHandlerCAN1_RX1_IRQHandlerCAN1_SCE_IRQHandlerEXTI9_5_IRQHandlerTIM1_BRK_IRQHandlerTIM1_UP_IRQHandlerTIM1_TRG_COM_IRQHandlerTIM1_CC_IRQHandlerTIM2_IRQHandlerTIM3_IRQHandlerTIM4_IRQHandlerI2C1_EV_IRQHandlerI2C1_ER_IRQHandlerI2C2_EV_IRQHandlerI2C2_ER_IRQHandlerSPI1_IRQHandlerSPI2_IRQHandlerUSART1_IRQHandlerUSART2_IRQHandlerUSART3_IRQHandlerEXTI15_10_IRQHandlerRTCAlarm_IRQHandlerUSBWakeUp_IRQHandler                B       .                ENDP                ALIGN;*******************************************************************************; User Stack and Heap initialization;*******************************************************************************                 IF      :DEF:__MICROLIB                                            EXPORT  __initial_sp                 EXPORT  __heap_base                 EXPORT  __heap_limit                                 ELSE                                 IMPORT  __use_two_region_memory                 EXPORT  __user_initial_stackheap                 __user_initial_stackheap                 LDR     R0, &#x3D;  Heap_Mem                 LDR     R1, &#x3D;(Stack_Mem + Stack_Size)                 LDR     R2, &#x3D; (Heap_Mem +  Heap_Size)                 LDR     R3, &#x3D; Stack_Mem                 BX      LR                 ALIGN                 ENDIF                 END;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>startup_stm32f103xe.s（2017）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">&#x2F;**  *************** (C) COPYRIGHT 2017 STMicroelectronics ************************  * @file      startup_stm32f103xe.s  * @author    MCD Application Team  * @brief     STM32F103xE Devices vector table for Atollic toolchain.  *            This module performs:  *                - Set the initial SP  *                - Set the initial PC &#x3D;&#x3D; Reset_Handler,  *                - Set the vector table entries with the exceptions ISR address  *                - Configure the clock system     *                - Configure external SRAM mounted on STM3210E-EVAL board  *                  to be used as data memory (optional, to be enabled by user)  *                - Branches to main in the C library (which eventually  *                  calls main()).  *            After Reset the Cortex-M3 processor is in Thread mode,  *            priority is Privileged, and the Stack is set to Main.  ******************************************************************************  * @attention  *  * Copyright (c) 2017-2021 STMicroelectronics.  * All rights reserved.  *  * This software is licensed under terms that can be found in the LICENSE file  * in the root directory of this software component.  * If no LICENSE file comes with this software, it is provided AS-IS.  *  ******************************************************************************  *&#x2F;  .syntax unified  .cpu cortex-m3  .fpu softvfp  .thumb.global g_pfnVectors.global Default_Handler&#x2F;* start address for the initialization values of the .data section.defined in linker script *&#x2F;.word _sidata&#x2F;* start address for the .data section. defined in linker script *&#x2F;.word _sdata&#x2F;* end address for the .data section. defined in linker script *&#x2F;.word _edata&#x2F;* start address for the .bss section. defined in linker script *&#x2F;.word _sbss&#x2F;* end address for the .bss section. defined in linker script *&#x2F;.word _ebss.equ  BootRAM,        0xF1E0F85F&#x2F;** * @brief  This is the code that gets called when the processor first *          starts execution following a reset event. Only the absolutely *          necessary set is performed, after which the application *          supplied main() routine is called. * @param  None * @retval : None*&#x2F;  .section .text.Reset_Handler  .weak Reset_Handler  .type Reset_Handler, %functionReset_Handler:&#x2F;* Call the clock system initialization function.*&#x2F;    bl  SystemInit&#x2F;* Copy the data segment initializers from flash to SRAM *&#x2F;  ldr r0, &#x3D;_sdata  ldr r1, &#x3D;_edata  ldr r2, &#x3D;_sidata  movs r3, #0  b LoopCopyDataInitCopyDataInit:  ldr r4, [r2, r3]  str r4, [r0, r3]  adds r3, r3, #4LoopCopyDataInit:  adds r4, r0, r3  cmp r4, r1  bcc CopyDataInit  &#x2F;* Zero fill the bss segment. *&#x2F;  ldr r2, &#x3D;_sbss  ldr r4, &#x3D;_ebss  movs r3, #0  b LoopFillZerobssFillZerobss:  str  r3, [r2]  adds r2, r2, #4LoopFillZerobss:  cmp r2, r4  bcc FillZerobss&#x2F;* Call static constructors *&#x2F;    bl __libc_init_array&#x2F;* Call the application&#39;s entry point.*&#x2F;  bl main  bx lr.size Reset_Handler, .-Reset_Handler&#x2F;** * @brief  This is the code that gets called when the processor receives an *         unexpected interrupt.  This simply enters an infinite loop, preserving *         the system state for examination by a debugger. * * @param  None * @retval : None*&#x2F;    .section .text.Default_Handler,&quot;ax&quot;,%progbitsDefault_Handler:Infinite_Loop:  b Infinite_Loop  .size Default_Handler, .-Default_Handler&#x2F;******************************************************************************** The minimal vector table for a Cortex M3.  Note that the proper constructs* must be placed on this to ensure that it ends up at physical address* 0x0000.0000.*******************************************************************************&#x2F;  .section .isr_vector,&quot;a&quot;,%progbits  .type g_pfnVectors, %object  .size g_pfnVectors, .-g_pfnVectorsg_pfnVectors:  .word _estack  .word Reset_Handler  .word NMI_Handler  .word HardFault_Handler  .word MemManage_Handler  .word BusFault_Handler  .word UsageFault_Handler  .word 0  .word 0  .word 0  .word 0  .word SVC_Handler  .word DebugMon_Handler  .word 0  .word PendSV_Handler  .word SysTick_Handler  .word WWDG_IRQHandler  .word PVD_IRQHandler  .word TAMPER_IRQHandler  .word RTC_IRQHandler  .word FLASH_IRQHandler  .word RCC_IRQHandler  .word EXTI0_IRQHandler  .word EXTI1_IRQHandler  .word EXTI2_IRQHandler  .word EXTI3_IRQHandler  .word EXTI4_IRQHandler  .word DMA1_Channel1_IRQHandler  .word DMA1_Channel2_IRQHandler  .word DMA1_Channel3_IRQHandler  .word DMA1_Channel4_IRQHandler  .word DMA1_Channel5_IRQHandler  .word DMA1_Channel6_IRQHandler  .word DMA1_Channel7_IRQHandler  .word ADC1_2_IRQHandler  .word USB_HP_CAN1_TX_IRQHandler  .word USB_LP_CAN1_RX0_IRQHandler  .word CAN1_RX1_IRQHandler  .word CAN1_SCE_IRQHandler  .word EXTI9_5_IRQHandler  .word TIM1_BRK_IRQHandler  .word TIM1_UP_IRQHandler  .word TIM1_TRG_COM_IRQHandler  .word TIM1_CC_IRQHandler  .word TIM2_IRQHandler  .word TIM3_IRQHandler  .word TIM4_IRQHandler  .word I2C1_EV_IRQHandler  .word I2C1_ER_IRQHandler  .word I2C2_EV_IRQHandler  .word I2C2_ER_IRQHandler  .word SPI1_IRQHandler  .word SPI2_IRQHandler  .word USART1_IRQHandler  .word USART2_IRQHandler  .word USART3_IRQHandler  .word EXTI15_10_IRQHandler  .word RTC_Alarm_IRQHandler  .word USBWakeUp_IRQHandler  .word TIM8_BRK_IRQHandler  .word TIM8_UP_IRQHandler  .word TIM8_TRG_COM_IRQHandler  .word TIM8_CC_IRQHandler  .word ADC3_IRQHandler  .word FSMC_IRQHandler  .word SDIO_IRQHandler  .word TIM5_IRQHandler  .word SPI3_IRQHandler  .word UART4_IRQHandler  .word UART5_IRQHandler  .word TIM6_IRQHandler  .word TIM7_IRQHandler  .word DMA2_Channel1_IRQHandler  .word DMA2_Channel2_IRQHandler  .word DMA2_Channel3_IRQHandler  .word DMA2_Channel4_5_IRQHandler  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word 0  .word BootRAM       &#x2F;* @0x1E0. This is for boot in RAM mode for                         STM32F10x High Density devices. *&#x2F;&#x2F;********************************************************************************* Provide weak aliases for each Exception handler to the Default_Handler.* As they are weak aliases, any function with the same name will override* this definition.********************************************************************************&#x2F;  .weak NMI_Handler  .thumb_set NMI_Handler,Default_Handler  .weak HardFault_Handler  .thumb_set HardFault_Handler,Default_Handler  .weak MemManage_Handler  .thumb_set MemManage_Handler,Default_Handler  .weak BusFault_Handler  .thumb_set BusFault_Handler,Default_Handler  .weak UsageFault_Handler  .thumb_set UsageFault_Handler,Default_Handler  .weak SVC_Handler  .thumb_set SVC_Handler,Default_Handler  .weak DebugMon_Handler  .thumb_set DebugMon_Handler,Default_Handler  .weak PendSV_Handler  .thumb_set PendSV_Handler,Default_Handler  .weak SysTick_Handler  .thumb_set SysTick_Handler,Default_Handler  .weak WWDG_IRQHandler  .thumb_set WWDG_IRQHandler,Default_Handler  .weak PVD_IRQHandler  .thumb_set PVD_IRQHandler,Default_Handler  .weak TAMPER_IRQHandler  .thumb_set TAMPER_IRQHandler,Default_Handler  .weak RTC_IRQHandler  .thumb_set RTC_IRQHandler,Default_Handler  .weak FLASH_IRQHandler  .thumb_set FLASH_IRQHandler,Default_Handler  .weak RCC_IRQHandler  .thumb_set RCC_IRQHandler,Default_Handler  .weak EXTI0_IRQHandler  .thumb_set EXTI0_IRQHandler,Default_Handler  .weak EXTI1_IRQHandler  .thumb_set EXTI1_IRQHandler,Default_Handler  .weak EXTI2_IRQHandler  .thumb_set EXTI2_IRQHandler,Default_Handler  .weak EXTI3_IRQHandler  .thumb_set EXTI3_IRQHandler,Default_Handler  .weak EXTI4_IRQHandler  .thumb_set EXTI4_IRQHandler,Default_Handler  .weak DMA1_Channel1_IRQHandler  .thumb_set DMA1_Channel1_IRQHandler,Default_Handler  .weak DMA1_Channel2_IRQHandler  .thumb_set DMA1_Channel2_IRQHandler,Default_Handler  .weak DMA1_Channel3_IRQHandler  .thumb_set DMA1_Channel3_IRQHandler,Default_Handler  .weak DMA1_Channel4_IRQHandler  .thumb_set DMA1_Channel4_IRQHandler,Default_Handler  .weak DMA1_Channel5_IRQHandler  .thumb_set DMA1_Channel5_IRQHandler,Default_Handler  .weak DMA1_Channel6_IRQHandler  .thumb_set DMA1_Channel6_IRQHandler,Default_Handler  .weak DMA1_Channel7_IRQHandler  .thumb_set DMA1_Channel7_IRQHandler,Default_Handler  .weak ADC1_2_IRQHandler  .thumb_set ADC1_2_IRQHandler,Default_Handler  .weak USB_HP_CAN1_TX_IRQHandler  .thumb_set USB_HP_CAN1_TX_IRQHandler,Default_Handler  .weak USB_LP_CAN1_RX0_IRQHandler  .thumb_set USB_LP_CAN1_RX0_IRQHandler,Default_Handler  .weak CAN1_RX1_IRQHandler  .thumb_set CAN1_RX1_IRQHandler,Default_Handler  .weak CAN1_SCE_IRQHandler  .thumb_set CAN1_SCE_IRQHandler,Default_Handler  .weak EXTI9_5_IRQHandler  .thumb_set EXTI9_5_IRQHandler,Default_Handler  .weak TIM1_BRK_IRQHandler  .thumb_set TIM1_BRK_IRQHandler,Default_Handler  .weak TIM1_UP_IRQHandler  .thumb_set TIM1_UP_IRQHandler,Default_Handler  .weak TIM1_TRG_COM_IRQHandler  .thumb_set TIM1_TRG_COM_IRQHandler,Default_Handler  .weak TIM1_CC_IRQHandler  .thumb_set TIM1_CC_IRQHandler,Default_Handler  .weak TIM2_IRQHandler  .thumb_set TIM2_IRQHandler,Default_Handler  .weak TIM3_IRQHandler  .thumb_set TIM3_IRQHandler,Default_Handler  .weak TIM4_IRQHandler  .thumb_set TIM4_IRQHandler,Default_Handler  .weak I2C1_EV_IRQHandler  .thumb_set I2C1_EV_IRQHandler,Default_Handler  .weak I2C1_ER_IRQHandler  .thumb_set I2C1_ER_IRQHandler,Default_Handler  .weak I2C2_EV_IRQHandler  .thumb_set I2C2_EV_IRQHandler,Default_Handler  .weak I2C2_ER_IRQHandler  .thumb_set I2C2_ER_IRQHandler,Default_Handler  .weak SPI1_IRQHandler  .thumb_set SPI1_IRQHandler,Default_Handler  .weak SPI2_IRQHandler  .thumb_set SPI2_IRQHandler,Default_Handler  .weak USART1_IRQHandler  .thumb_set USART1_IRQHandler,Default_Handler  .weak USART2_IRQHandler  .thumb_set USART2_IRQHandler,Default_Handler  .weak USART3_IRQHandler  .thumb_set USART3_IRQHandler,Default_Handler  .weak EXTI15_10_IRQHandler  .thumb_set EXTI15_10_IRQHandler,Default_Handler  .weak RTC_Alarm_IRQHandler  .thumb_set RTC_Alarm_IRQHandler,Default_Handler  .weak USBWakeUp_IRQHandler  .thumb_set USBWakeUp_IRQHandler,Default_Handler  .weak TIM8_BRK_IRQHandler  .thumb_set TIM8_BRK_IRQHandler,Default_Handler  .weak TIM8_UP_IRQHandler  .thumb_set TIM8_UP_IRQHandler,Default_Handler  .weak TIM8_TRG_COM_IRQHandler  .thumb_set TIM8_TRG_COM_IRQHandler,Default_Handler  .weak TIM8_CC_IRQHandler  .thumb_set TIM8_CC_IRQHandler,Default_Handler  .weak ADC3_IRQHandler  .thumb_set ADC3_IRQHandler,Default_Handler  .weak FSMC_IRQHandler  .thumb_set FSMC_IRQHandler,Default_Handler  .weak SDIO_IRQHandler  .thumb_set SDIO_IRQHandler,Default_Handler  .weak TIM5_IRQHandler  .thumb_set TIM5_IRQHandler,Default_Handler  .weak SPI3_IRQHandler  .thumb_set SPI3_IRQHandler,Default_Handler  .weak UART4_IRQHandler  .thumb_set UART4_IRQHandler,Default_Handler  .weak UART5_IRQHandler  .thumb_set UART5_IRQHandler,Default_Handler  .weak TIM6_IRQHandler  .thumb_set TIM6_IRQHandler,Default_Handler  .weak TIM7_IRQHandler  .thumb_set TIM7_IRQHandler,Default_Handler  .weak DMA2_Channel1_IRQHandler  .thumb_set DMA2_Channel1_IRQHandler,Default_Handler  .weak DMA2_Channel2_IRQHandler  .thumb_set DMA2_Channel2_IRQHandler,Default_Handler  .weak DMA2_Channel3_IRQHandler  .thumb_set DMA2_Channel3_IRQHandler,Default_Handler  .weak DMA2_Channel4_5_IRQHandler  .thumb_set DMA2_Channel4_5_IRQHandler,Default_Handler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32单片机之分析启动文件小论(I)</title>
      <link href="/2024/11/15/STM32%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8B%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%B0%8F%E8%AE%BA-I/"/>
      <url>/2024/11/15/STM32%E5%8D%95%E7%89%87%E6%9C%BA%E4%B9%8B%E5%88%86%E6%9E%90%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%B0%8F%E8%AE%BA-I/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32单片机之分析启动文件小论-I"><a href="#STM32单片机之分析启动文件小论-I" class="headerlink" title="STM32单片机之分析启动文件小论(I)"></a>STM32单片机之分析启动文件小论(I)</h1><h3 id="上电时"><a href="#上电时" class="headerlink" title="上电时"></a>上电时</h3><p>我们的STM32一经上电，他会跟<a href="https://so.csdn.net/so/search?q=CPU&amp;spm=1001.2101.3001.7020">CPU</a>上电的行为一致，也就是跳转到一个固定的地址。我们的STM32也是一样，对于不同的boot选择，他会跳转到不同的地址。这就跟启动模式的三种方式很有关系：</p><div class="table-container"><table><thead><tr><th style="text-align:left">BOOT0</th><th style="text-align:left">BOOT1</th><th style="text-align:left">启动模式</th><th style="text-align:left">0x00000000的映射地址</th><th style="text-align:left">0x00000004的映射地址</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">x</td><td style="text-align:left">内部FLASH</td><td style="text-align:left">0x08000000</td><td style="text-align:left">0x08000004</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">内部SRAM</td><td style="text-align:left">0x20000000</td><td style="text-align:left">0x20000004</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">0</td><td style="text-align:left">系统存储器</td><td style="text-align:left">0x1FFFF000</td><td style="text-align:left">0x1FFFF004</td></tr></tbody></table></div><p>也就是说，选择不同的boot引脚本质上就是在选择不一样的跳转地址，无论如何，我们要做的，就是在选定我们的特定的跳转地址后，在这些地址上排列我们之后的指令。</p><h3 id="启动文件分析"><a href="#启动文件分析" class="headerlink" title="启动文件分析"></a>启动文件分析</h3><p>这一场串的文件很大，也是一份arm汇编文件，为此，为了理解这份文件，我们来看看一些简单的汇编标识符：</p><div class="table-container"><table><thead><tr><th style="text-align:left">指令名称</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">EQU</td><td style="text-align:left">相当于#define给常量取名称</td></tr><tr><td style="text-align:left">AREA</td><td style="text-align:left">汇编一段全新的段</td></tr><tr><td style="text-align:left">ALIGN</td><td style="text-align:left">编译器对指令或者数据的存放地址进行对齐。一般需要跟一个立即数，缺省表示四字节对齐。不过要注意的是：<strong>这个并不是arm汇编指令，而是编译器的内置指令</strong></td></tr><tr><td style="text-align:left">SPACE</td><td style="text-align:left">分配内存空间</td></tr><tr><td style="text-align:left">PRESERVE8</td><td style="text-align:left">当前文件堆栈需要按照八字节对齐</td></tr><tr><td style="text-align:left">THUMB</td><td style="text-align:left">表示向后兼容THUMB指令（详细可以查询ARM状态和THUMB状态）</td></tr><tr><td style="text-align:left">EXPORT</td><td style="text-align:left">声明导出这个符号给外边文件用</td></tr><tr><td style="text-align:left">IMPORT</td><td style="text-align:left">声明这个符号来源于外面</td></tr><tr><td style="text-align:left">DCD</td><td style="text-align:left">以字节为单位分配内存要求四字节对齐并且要求初始化这些内存</td></tr><tr><td style="text-align:left">PROC</td><td style="text-align:left">子程序的开始，要求以ENDP成对出现</td></tr><tr><td style="text-align:left">WEAK</td><td style="text-align:left">这表示若定义如果外部文件声明的一个符号，则优先使用外部文件定义的符号。如果外部文件没有定义这个符号也不会出错。<strong>要注意的是这也不是arm的汇编指令而是编译器的内置指令</strong></td></tr><tr><td style="text-align:left">LDR</td><td style="text-align:left">从存储器加载一个字</td></tr><tr><td style="text-align:left">BLX</td><td style="text-align:left">跳转到寄存器给出的地址，并且根据寄存器的LSE确定处理器的状态，还要把跳转前的下条指令地址保存到LR（实际上就是call）</td></tr><tr><td style="text-align:left">BX</td><td style="text-align:left">跳转到由寄存器或者标号给出的地址不用返回</td></tr><tr><td style="text-align:left">B</td><td style="text-align:left">跳转到一个标号</td></tr><tr><td style="text-align:left">IF ELSE ENDIF</td><td style="text-align:left">汇编条件分支语句跟C语言类似</td></tr><tr><td style="text-align:left">END</td><td style="text-align:left">文件结束</td></tr></tbody></table></div><p>那我们现在尝试着手分析这个文件</p><blockquote><p>文件名称：startup_stm32f103xe.s</p></blockquote><pre class="line-numbers language-none"><code class="language-none">Stack_Size      EQU     0x00000400                      # 声明一个栈大小的宏                AREA    STACK, NOINIT, READWRITE, ALIGN&#x3D;3 # STACK栈区域，不初始化，可读可写，对齐3字节Stack_Mem       SPACE   Stack_Size                      # 表达栈的大小是1024B，也就是1KB大小__initial_sp                                                                                              ; &lt;h&gt; Heap Configuration;   &lt;o&gt;  Heap Size (in Bytes) &lt;0x0-0xFFFFFFFF:8&gt;; &lt;&#x2F;h&gt;Heap_Size       EQU     0x00000200                      # 堆大小为512B                AREA    HEAP, NOINIT, READWRITE, ALIGN&#x3D;3  # HEAP堆区域，不初始化，可读可写，对齐3字节 __heap_base                                           # HEAP起始地址Heap_Mem        SPACE   Heap_Size                       # HEAP区域__heap_limit                                          # HEAP终止地址                PRESERVE8                               # 这两条看上面的说明：当前文件堆栈需要按照八字节对齐                THUMB                                   # THUMB指令; 上面的区域划分了区域，下面开始排布中断向量表，他在0地址处（数据段）; Vector Table Mapped to Address 0 at Reset                AREA    RESET, DATA, READONLY           # 中断向量表安排在0地址处                EXPORT  __Vectors                      # 下面的三个符号将会可见（被外面的使用）                EXPORT  __Vectors_End                EXPORT  __Vectors_Size# 具体含义如何不是这里的侧重点__Vectors       DCD     __initial_sp               ; Top of Stack                   DCD     Reset_Handler              ; Reset Handler  ;               ... 省略了大量的中断向量                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 &amp; Channel5__Vectors_End__Vectors_Size  EQU  __Vectors_End - __Vectors          # 推导出我们的向量表的大小                AREA    |.text|, CODE, READONLY         # 只读代码段，放在.text段上                ; Reset handler # 我们很关心这个Reset_Handler   PROC                EXPORT  Reset_Handler             [WEAK]                # __main函数，也是标准的C库函数，负责初始化堆栈（这里要求要连接到C库）                IMPORT  __main                # SystemInit()是一个库函数，在system_stm32f1xx.c中定义的                IMPORT  SystemInit  # SystemInit贴在了下面                # 先调用SystemInit                LDR     R0, &#x3D;SystemInit                BLX     R0                         # 再调用__main函数初始化                LDR     R0, &#x3D;__main                BX      R0                ENDP                ; 省略了大量的handlers的弱定义; ....; ....; 结束;*******************************************************************************; User Stack and Heap initialization;*******************************************************************************# 有没有定义__MICROLIB?我们默认人没有定义，这样的化就是使用C库函数___main帮助我们完成初始化，                 IF      :DEF:__MICROLIB                                 EXPORT  __initial_sp                 EXPORT  __heap_base                 EXPORT  __heap_limit                                 ELSE                 # 我们正常走这里                 IMPORT  __use_two_region_memory                 EXPORT  __user_initial_stackheap                 __user_initial_stackheap                 LDR     R0, &#x3D;  Heap_Mem                 LDR     R1, &#x3D;(Stack_Mem + Stack_Size)                 LDR     R2, &#x3D; (Heap_Mem +  Heap_Size)                 LDR     R3, &#x3D; Stack_Mem                 BX      LR                 ALIGN                 ENDIF                 END;************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE******* * @brief Setup the microcontroller system * Initialize the Embedded Flash Interface, the PLL and update the  * SystemCoreClock variable. * @note This function should be used only after reset. * @param None * @retval None *&#x2F; # 简单来讲就是初始化Flash接口和初始化系统的时钟void SystemInit (void)&#123; &#x2F;* Reset the RCC clock configuration to the default reset state(for debug purpose) *&#x2F; &#x2F;* Set HSION bit *&#x2F; RCC-&gt;CR |&#x3D; 0x00000001U;  &#x2F;* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits *&#x2F;#if !defined(STM32F105xC) &amp;&amp; !defined(STM32F107xC) RCC-&gt;CFGR &amp;&#x3D; 0xF8FF0000U;#else RCC-&gt;CFGR &amp;&#x3D; 0xF0FF0000U;#endif &#x2F;* STM32F105xC *&#x2F;   &#x2F;* Reset HSEON, CSSON and PLLON bits *&#x2F; RCC-&gt;CR &amp;&#x3D; 0xFEF6FFFFU;  &#x2F;* Reset HSEBYP bit *&#x2F; RCC-&gt;CR &amp;&#x3D; 0xFFFBFFFFU;  &#x2F;* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE&#x2F;OTGFSPRE bits *&#x2F; RCC-&gt;CFGR &amp;&#x3D; 0xFF80FFFFU; #if defined(STM32F105xC) || defined(STM32F107xC) &#x2F;* Reset PLL2ON and PLL3ON bits *&#x2F; RCC-&gt;CR &amp;&#x3D; 0xEBFFFFFFU;  &#x2F;* Disable all interrupts and clear pending bits *&#x2F; RCC-&gt;CIR &#x3D; 0x00FF0000U;  &#x2F;* Reset CFGR2 register *&#x2F; RCC-&gt;CFGR2 &#x3D; 0x00000000U;#elif defined(STM32F100xB) || defined(STM32F100xE) &#x2F;* Disable all interrupts and clear pending bits *&#x2F; RCC-&gt;CIR &#x3D; 0x009F0000U;  &#x2F;* Reset CFGR2 register *&#x2F; RCC-&gt;CFGR2 &#x3D; 0x00000000U; #else &#x2F;* Disable all interrupts and clear pending bits *&#x2F; RCC-&gt;CIR &#x3D; 0x009F0000U;#endif &#x2F;* STM32F105xC *&#x2F; #if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG) #ifdef DATA_IN_ExtSRAM SystemInit_ExtMemCtl();  #endif &#x2F;* DATA_IN_ExtSRAM *&#x2F;#endif  #ifdef VECT_TAB_SRAM SCB-&gt;VTOR &#x3D; SRAM_BASE | VECT_TAB_OFFSET; &#x2F;* Vector Table Relocation in Internal SRAM. *&#x2F;#else SCB-&gt;VTOR &#x3D; FLASH_BASE | VECT_TAB_OFFSET; &#x2F;* Vector Table Relocation in Internal FLASH. *&#x2F;#endif &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看完了：我们捋一下如何启动的：</p><h3 id="启动流程分析"><a href="#启动流程分析" class="headerlink" title="启动流程分析"></a>启动流程分析</h3><p><strong>上电：单片机根据选择的BOOT引脚跳转到相应的地址，开始取出堆栈指针的初始值（栈顶的初始值）和PC计数器的值（下一条指令在哪里）</strong></p><p><strong>这个PC值就是中断向量表的起始地址，也是复位程序的入口地址，接着跳转到复位程序入口处，初始向量表，然后设置时钟(SystemInit)，设置堆栈(__main函数)，最后跳转到C空间的main函数，即进入用户程序</strong></p><p><strong>实际上就是这样的简单。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈笔记：一个debug记录之错误的ld interpreter</title>
      <link href="/2024/10/18/%E6%9D%82%E8%B0%88%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%80%E4%B8%AAdebug%E8%AE%B0%E5%BD%95%E4%B9%8B%E9%94%99%E8%AF%AF%E7%9A%84ld-interpreter/"/>
      <url>/2024/10/18/%E6%9D%82%E8%B0%88%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%80%E4%B8%AAdebug%E8%AE%B0%E5%BD%95%E4%B9%8B%E9%94%99%E8%AF%AF%E7%9A%84ld-interpreter/</url>
      
        <content type="html"><![CDATA[<h1 id="杂谈笔记：一个debug记录之错误的ld-interpreter"><a href="#杂谈笔记：一个debug记录之错误的ld-interpreter" class="headerlink" title="杂谈笔记：一个debug记录之错误的ld interpreter"></a>杂谈笔记：一个debug记录之错误的ld interpreter</h1><h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>​    笔者前段时间帮忙测试一位同学的校园网驱动程序的时候出现了一个非常有趣的问题：那就是这个文件被进程加载的时候出现了：</p><pre class="line-numbers language-none"><code class="language-none">can not execuate the file, the request file is missing<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    的有趣错误。笔者检查了一下file命令的输出，大致格式如下：</p><pre class="line-numbers language-none"><code class="language-none">demo: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, BuildID[sha1]&#x3D;8233200d91ce5b352b50c14288246e5296c1749f, for GNU&#x2F;Linux 3.2.0, with debug_info, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    当然，这不是那份程序的输出。不过我们也是从这里的输出定位到了问题。常见的原因是ELF位数格式不匹配的问题。笔者这里的程序显得更加的刁钻：那就是程序是在NixOS下构建。任何熟悉NixOS的朋友会立刻认识到问题所在：那就是程序在其他人笔记本中构建的时候采用的interpreter信息是nix下被冠以hash code path指向的interpreter。这里的missing就会出现上面的问题！太简单了。这个可执行文件甚至被拦截在了成为进程之前了！因为他甚至没有找到这个可执行文件的解释器在何处！</p><h2 id="具体解释"><a href="#具体解释" class="headerlink" title="具体解释"></a>具体解释</h2><p>​    我们回到正题。那就是file的输出指代了什么信息呢？我们都知道file的一个功能就是查看文件的类型信息，和必要的加载信息。</p><pre class="line-numbers language-none"><code class="language-none">➜  file demodemo: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, BuildID[sha1]&#x3D;8233200d91ce5b352b50c14288246e5296c1749f, for GNU&#x2F;Linux 3.2.0, with debug_info, not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>ELF</strong>: 这是文件的格式，表示它是一个可执行和可链接的格式，ELF格式相信任何熟悉Linux的人都不陌生！</li><li><strong>64-bit</strong>: 表示这个 ELF 文件是为 64 位架构设计的，适用于 x86-64 处理器。（一些朋友就会发现在64位平台编译的可执行文件在32位上跑不了，这个可以提前查看file命令解决，当然，配合uname -a来一起鉴定）</li><li><strong>LSB</strong>: 表示这个文件是“小端”格式（Least Significant Byte first），这是数据存储的字节序。（另一个就是MSB大端了，常见的大端机器就是IBM了，当然ARM架构的可以自己设置位进行说明）</li><li><strong>pie</strong>: 表示这个可执行文件是“位置无关的”（Position Independent Executable），可以在内存的任何位置加载运行，通常用于提高安全性。（位置无关是重要的安全措施，另一方面说明这个程序对内存的未知不敏感，所有的Symbol都不是硬编码的）</li><li><strong>executable</strong>: 表示这个文件是一个可执行文件。</li><li><strong>x86-64</strong>: 指定了文件是为 x86-64 架构（即 AMD64 或 Intel 64）编译的。</li><li><strong>version 1 (SYSV)</strong>: 指的是 ELF 文件格式的版本和 ABI（应用二进制接口），这里是 System V 的版本 1。</li><li><strong>dynamically linked</strong>: 表示该可执行文件是动态链接的，意味着它依赖于共享库（如 .so 文件）在运行时加载，而不是将所有代码静态链接到可执行文件中。（这就意味着我们需要后面请出interpreter做铺垫了）</li><li><strong>interpreter /lib64/ld-linux-x86-64.so.2</strong>: 指定了运行时链接器的路径，这个链接器会在程序启动时加载所需的共享库。（笔者当时就是这个指向了朋友开发的系统的解释器！）</li><li><strong>BuildID[sha1]=8233200d91ce5b352b50c14288246e5296c1749f</strong>: 这是一个唯一的标识符，用于标识这个构建版本，通常用于调试和符号表查找。</li><li><strong>for GNU/Linux 3.2.0</strong>: 指明了这个文件的目标操作系统和版本，表明它是为 GNU/Linux 3.2.0 版本构建的。</li><li><strong>with debug_info</strong>: 表示这个可执行文件包含调试信息，这些信息可以用于调试程序，提供源代码行号等。（其内含有debug信息！）</li><li><strong>not stripped</strong>: 表示这个文件没有被“剥离”，即调试信息和符号表仍然保留在可执行文件中，便于调试。通常，剥离操作会去除调试信息，以减小文件大小和保护源代码（当然使用strip指令就可以进行剥离，代价就是——程序无法调试了！）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Linux上构建Raspberry Pi虚拟环境</title>
      <link href="/2024/07/29/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E4%B8%8A%E6%9E%84%E5%BB%BARaspberry-Pi%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/07/29/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E4%B8%8A%E6%9E%84%E5%BB%BARaspberry-Pi%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在Linux上构建Raspberry-Pi虚拟环境"><a href="#如何在Linux上构建Raspberry-Pi虚拟环境" class="headerlink" title="如何在Linux上构建Raspberry Pi虚拟环境"></a>如何在Linux上构建Raspberry Pi虚拟环境</h1><p>​    下面我们来讲讲如何使用QEMU来仿照树莓派环境。这里首先先分成两大类。第一类是跑比较老的，安全性较低的老树莓派，主要指代的是22年4月份发布之前的版本，这个版本当中，树莓派镜像自己内部就配置了一份默认的账户密码。对于之后的版本则不配备这种默认的账号密码。因此，我们需要区分出两种装载模式。</p><p>​    为了省力，我们使用人家已经配置好了的</p><blockquote><p>github仓库：<a href="https:*//github.com/dhruvvyas90/qemu-rpi-kernel.git*">qemu-rpi-kernel</a></p></blockquote><h2 id="前置环境需求"><a href="#前置环境需求" class="headerlink" title="前置环境需求"></a>前置环境需求</h2><pre class="line-numbers language-none"><code class="language-none">yay -S qemu-system-arm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Older-Version"><a href="#Older-Version" class="headerlink" title="Older Version"></a>Older Version</h2><p>​    考虑旧的树莓派镜像，安装的方式如下</p><ol><li><p>克隆仓库<a href="https:*//github.com/dhruvvyas90/qemu-rpi-kernel.git*">qemu-rpi-kernel</a>到一个位置，取出里头的：</p><pre class="line-numbers language-none"><code class="language-none">kernel-qemu-5.4.51-busterversatile-pb-buster-5.4.51.dtb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个文件到一个自己创建的目录文件夹下。我的是oldone</p></li><li><p>下载旧树莓派镜像</p><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;downloads.raspberrypi.org&#x2F;raspios_lite_armhf&#x2F;images&#x2F;raspios_lite_armhf-2020-05-28&#x2F;2020-05-27-raspios-buster-lite-armhf.zip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>wget还是扔浏览器自己点击，看自己兴趣。下载结束解压到上面创建的oldone文件夹下</p></li><li><p>写一个简单的脚本</p><pre class="line-numbers language-none"><code class="language-none">qemu-system-arm \  -M versatilepb \  -cpu arm1176 \  -m 256 \  -drive &quot;file&#x3D;2020-05-27-raspios-buster-lite-armhf.img,   if&#x3D;none,index&#x3D;0,media&#x3D;disk,format&#x3D;raw,id&#x3D;disk0&quot;   -device &quot;virtio-blk-pci,drive&#x3D;disk0,disable-modern&#x3D;on,disable-legacy&#x3D;off&quot; \  -net &quot;user,hostfwd&#x3D;tcp::5022-:22&quot; \  -dtb versatile-pb-buster-5.4.51.dtb \  -kernel kernel-qemu-5.4.51-buster \  -nographic \ # 提示，这个跟下面的console&#x3D;ttyAMA0搭配使用，想要图形化输出请自行删掉提到的两行  -append &#39;root&#x3D;&#x2F;dev&#x2F;vda2 panic&#x3D;1 console&#x3D;ttyAMA0&#39; \  -no-reboot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我先说说这些参数都是什么意思。</p><blockquote><p>-M versatilepb:QEMU支持的板子里有这个，这个是我们树莓派的体系平台，选这个运行我们的树莓派仿真环境</p><p>-cpu arm1176: CPU型号选择arm1176</p><p>-m 256 内存大小是256MB，我看有Issue说最大就这个，不能再大了，有bug会，笔者这里尚未考证，不予评价</p><p>下面这一个长一些：实际上就是指定我们的镜像文件和索引格式：</p><blockquote><p><code>file=2020-05-27-raspios-buster-lite-armhf.img</code>：指定要使用的镜像文件。</p><p><code>if=none</code>：指定该驱动器不自动分配到任何接口。</p><p><code>index=0</code>：设置驱动器的索引为0。</p><p><code>media=disk</code>：指定媒体类型为磁盘。</p><p><code>format=raw</code>：指定镜像文件的格式为raw（原始格式）。</p><p><code>id=disk0</code>：为该驱动器指定一个唯一的ID（disk0）。</p></blockquote><p>下面的这个是指定输入输出：</p><blockquote><p><code>virtio-blk-pci</code>：指定设备模型为VirtIO块设备（通过PCI总线连接的VirtIO块设备）。VirtIO设备通常用于提高虚拟化性能。</p><p><code>drive=disk0</code>：将这个设备与之前定义的ID为<code>disk0</code>的驱动器关联起来。</p><p><code>disable-modern=on</code>：禁用现代（modern）VirtIO设备特性。这些特性通常提供更高的性能，但可能与某些旧的系统不兼容。</p><p><code>disable-legacy=off</code>：启用传统（legacy）VirtIO设备特性。这些特性通常用于兼容旧的系统。</p></blockquote><p>-net配置网络：<code>user</code>：使用用户模式网络栈。这是QEMU的一种网络配置方式，适合不需要复杂网络配置的场景。<code>hostfwd=tcp::5022-:22</code>：设置端口转发规则，将主机的TCP端口5022转发到虚拟机的TCP端口22。</p><p>-dtb：指定设备树，这里用配好的</p><p>-kernel是使用到的内核：kernel-qemu-5.4.51-buster</p><p>-no-reboot：虚拟机关机或崩溃时，阻止它自动重启（关了我们怎么看日志呢hhh）</p><p>-nographic:不启用图形化，这个看心情指定，注意的是这个跟console=ttyAMA0一起用</p><p>下面的—append说的是追加内核启动参数：</p><blockquote><p><code>root=/dev/vda2</code>：指定根文件系统所在的设备。这里假设根文件系统位于虚拟磁盘的第二个分区。</p><p><code>panic=1</code>：在内核遇到致命错误时，指定在1秒后自动重启。</p><p><code>console=ttyAMA0</code>：指定内核控制台输出到<code>ttyAMA0</code>，通常用于ARM架构的串口控制台。</p></blockquote></blockquote></li></ol><p>​    下面就可以启动了，我想要提到的是，由于这玩意内存就给256M，可以说启动相当的缓慢，因此，有点耐心，好几次笔者以为是配置挂了反复检查，直到吃饭回来才发现跑通的本来</p><p>​    总结一下，如果看官希望采用的是非图形化的输出，需要写入的脚本是：</p><pre class="line-numbers language-none"><code class="language-none">qemu-system-arm \  -M versatilepb \  -cpu arm1176 \  -m 256 \  -drive &quot;file&#x3D;2020-05-27-raspios-buster-lite-armhf.img,   if&#x3D;none,index&#x3D;0,media&#x3D;disk,format&#x3D;raw,id&#x3D;disk0&quot;   -device &quot;virtio-blk-pci,drive&#x3D;disk0,disable-modern&#x3D;on,disable-legacy&#x3D;off&quot; \  -net &quot;user,hostfwd&#x3D;tcp::5022-:22&quot; \  -dtb versatile-pb-buster-5.4.51.dtb \  -kernel kernel-qemu-5.4.51-buster \  -nographic \  -append &#39;root&#x3D;&#x2F;dev&#x2F;vda2 panic&#x3D;1 console&#x3D;ttyAMA0&#39; \  -no-reboot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    下面只需要</p><pre class="line-numbers language-none"><code class="language-none">chmod 777 &lt;脚本名称&gt;.sh.&#x2F;&lt;脚本名称&gt;.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    很快就会刷屏</p><blockquote><p>笔者建议使用非图形化的方式启动，日志更加丰富，而且可以实时看看进度。图形化的方式则会缺斤少两，导致一些长时间的加载被误认为是kernel挂了（我自己）</p></blockquote><p><img src="image-20240729214054816.png" alt="image-20240729214054816"></p><p>​    这是结束时候的画面，默认的，旧版本下的账号密码是：登录用户名为pi，该账户默认密码是raspberry，之后想要改passwd更改就好。</p><p>​    如果想要以图形化的方式启动：</p><pre class="line-numbers language-none"><code class="language-none">qemu-system-arm \  -M versatilepb \  -cpu arm1176 \  -m 256 \  -drive &quot;file&#x3D;2020-05-27-raspios-buster-lite-armhf.img,   if&#x3D;none,index&#x3D;0,media&#x3D;disk,format&#x3D;raw,id&#x3D;disk0&quot;   -device &quot;virtio-blk-pci,drive&#x3D;disk0,disable-modern&#x3D;on,disable-legacy&#x3D;off&quot; \  -net &quot;user,hostfwd&#x3D;tcp::5022-:22&quot; \  -dtb versatile-pb-buster-5.4.51.dtb \  -kernel kernel-qemu-5.4.51-buster \  -append &#39;root&#x3D;&#x2F;dev&#x2F;vda2 panic&#x3D;1&#39; \  -no-reboot<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="pic1.png" alt="pic1"></p><p><img src="pic2.png" alt="pic2"></p><h2 id="新版本启动"><a href="#新版本启动" class="headerlink" title="新版本启动"></a>新版本启动</h2><p>​    我们这一次玩一个新的，这一次我们尝试跑最新版本的树莓派镜像，有了旧版本的经验，事情垂手可得，但是这次我们要注意的是，我们必须先用非图形化的方式跑一次（可以不用吗，可以，但是我懒得改文件）</p><p>​    这是因为我们需要被引导设置账号密码，新版本的树莓派OS不再提供默认的账号密码了！剩下的都一样！这里不再赘述</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Windows上编译可用的Tesseract OCR in C++ 并部署在Visual Studio与Qt6上</title>
      <link href="/2024/07/27/%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8A%E7%BC%96%E8%AF%91%E5%8F%AF%E7%94%A8%E7%9A%84Tesseract-OCR-in-C-%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8Visual-Studio%E4%B8%8EQt6%E4%B8%8A/"/>
      <url>/2024/07/27/%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8A%E7%BC%96%E8%AF%91%E5%8F%AF%E7%94%A8%E7%9A%84Tesseract-OCR-in-C-%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8Visual-Studio%E4%B8%8EQt6%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在Windows上编译可用的Tesseract-OCR-in-C-并部署在Visual-Studio与Qt6上"><a href="#如何在Windows上编译可用的Tesseract-OCR-in-C-并部署在Visual-Studio与Qt6上" class="headerlink" title="如何在Windows上编译可用的Tesseract OCR in C++ 并部署在Visual Studio与Qt6上"></a>如何在Windows上编译可用的Tesseract OCR in C++ 并部署在Visual Studio与Qt6上</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本教程是一个截止至2024年7月11日最新的，旨在编译可以运行在x86_64结构上的，其操作系统是Windows11的机器上的，谷歌著名的光学识别库Tessereact OCR。本篇教程将会编译产生：</p><ul><li>使用msys环境下的，使用mingw64编译器编译的Tessereact OCR动态库</li><li>使用基于vcpkg的，于msvc19编译器编译的Tessereact OCR动态库</li></ul><p>​    文章的最后将会放上Github仓库与自己写的极简的包装器（问就是手动释放折磨人，智能指针万岁！）</p><h3 id="阅前提示"><a href="#阅前提示" class="headerlink" title="阅前提示"></a>阅前提示</h3><p>​    出于一些大家都知道的原因，使用一台没有VPN代理软件的机器编译来自国外的优秀软件是一件相当折磨人的事情，所以如果您想要按照本篇教程进行编译，请先：</p><blockquote><ol><li>机器上有足够的内存，硬存条件</li><li>有一个可用的代理软件，或者，您的网络可以流畅的使用git下载软件，或者是在vcpkg运行时补齐相关的依赖</li></ol></blockquote><h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><blockquote><p>Tesseract 项目地址：<a href="https://github.com/tesseract-ocr/tesseract">tesseract-ocr/tesseract: Tesseract Open Source OCR Engine (main repository) (github.com)</a>，我们的项目地址，等会从这里开始折磨</p><p>Tesseract用户侧与开发侧手册：<a href="https://tesseract-ocr.github.io/tessdoc/Home.html">Tesseract User Manual | tessdoc (tesseract-ocr.github.io)</a>，我们的开发手册，开发的时候别听某些瞎写的博客乱逼逼，有的时候以这个为准</p></blockquote><p>​    下文是对简介的翻译：</p><p>​    Tesseract 是一个开源文本识别 (OCR) 引擎，遵循 Apache 2.0 许可。（人话：记得你自己用完了发布项目的时候带上这个许可） 主要版本 5 是当前稳定版本，于 2021 年 11 月 30 日发布 5.0.0 版。 GitHub 提供较新的次要版本和错误修复版本。 GitHub 上的主分支提供最新源代码。未解决的问题可以在问题跟踪器和计划文档中找到。 Tesseract 可以直接通过命令行使用，或者（对于程序员）通过使用 API 从图像中提取打印文本。它支持多种语言。Tesseract 没有内置 GUI，但第三方页面提供了几种。Tesseract 的外部工具、包装器和培训项目列在 AddOns 下。 </p><p>​    <strong>Tesseract 可以在您自己的项目中使用，但需遵守 Apache 许可 2.0 的条款。它具有功能齐全的 API，可以针对包括 Android 和 iPhone 在内的各种目标进行编译。</strong>请参阅 3rdParty 和 AddOns 页面，了解已完成的操作示例。</p><p>​    下面进入正题：开始编译！</p><h2 id="使用基于vcpkg的，于msvc19编译器编译的Tessereact-OCR动态库"><a href="#使用基于vcpkg的，于msvc19编译器编译的Tessereact-OCR动态库" class="headerlink" title="使用基于vcpkg的，于msvc19编译器编译的Tessereact OCR动态库"></a>使用基于vcpkg的，于msvc19编译器编译的Tessereact OCR动态库</h2><h3 id="使用vcpkg辅助我们的编译"><a href="#使用vcpkg辅助我们的编译" class="headerlink" title="使用vcpkg辅助我们的编译"></a>使用vcpkg辅助我们的编译</h3><p>​    我看很多博客并没有使用包管理器辅助我们构建软件的意识，这里我们将会使用vcpkg包管理器来辅助我们的编译，帮助我们在编译时补全相关的依赖。</p><blockquote><p>什么是vcpkg，就看看巨硬的文档吧！ <a href="https://learn.microsoft.com/zh-cn/vcpkg/get_started/overview">vcpkg 概述 | Microsoft Learn</a></p><p>安装时可以参考的流程：<a href="https://learn.microsoft.com/zh-cn/vcpkg/get_started/get-started-vs?pivots=shell-cmd">在 Visual Studio 中使用 CMake 安装和管理包 | Microsoft Learn</a></p></blockquote><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>​    下面，我们开始使用git安排vcpkg：</p><p>​    找一个硬存空间较大的地方，比如说我的D盘：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">➜  <span class="token function">dir</span><span class="token comment"># 我在D盘下</span>目录: D:\➜  <span class="token variable">$Env</span>:http_proxy=<span class="token string">"http://127.0.0.1:7890"</span><span class="token punctuation">;</span><span class="token variable">$Env</span>:https_proxy=<span class="token string">"http://127.0.0.1:7890"</span> <span class="token comment"># 设置自己的代理</span>➜  git clone https:<span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com/microsoft/vcpkg<span class="token punctuation">.</span>gitCloning into <span class="token string">'vcpkg'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>remote: Enumerating objects: 240417<span class="token punctuation">,</span> done<span class="token punctuation">.</span>remote: Counting objects: 100% <span class="token punctuation">(</span>23483/23483<span class="token punctuation">)</span><span class="token punctuation">,</span> done<span class="token punctuation">.</span>remote: Compressing objects: 100% <span class="token punctuation">(</span>944/944<span class="token punctuation">)</span><span class="token punctuation">,</span> done<span class="token punctuation">.</span>remote: Total 240417 <span class="token punctuation">(</span>delta 23000<span class="token punctuation">)</span><span class="token punctuation">,</span> reused 22547 <span class="token punctuation">(</span>delta 22539<span class="token punctuation">)</span><span class="token punctuation">,</span> pack-reused 216934Receiving objects: 100% <span class="token punctuation">(</span>240417/240417<span class="token punctuation">)</span><span class="token punctuation">,</span> 71<span class="token punctuation">.</span>03 MiB <span class="token punctuation">|</span> 2<span class="token punctuation">.</span>00 MiB/s<span class="token punctuation">,</span> done<span class="token punctuation">.</span>Resolving deltas: 100% <span class="token punctuation">(</span>160646/160646<span class="token punctuation">)</span><span class="token punctuation">,</span> done<span class="token punctuation">.</span>Updating files: 100% <span class="token punctuation">(</span>11502/11502<span class="token punctuation">)</span><span class="token punctuation">,</span> done<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果自己不会设代理。。。哈？去网上查查，懒得查来我这篇看：</p><p><a href="https://blog.csdn.net/charlie114514191/article/details/135922310">OpenCV4.9.0 + 扩展 + WITH_QT（Qt6）模块编译教程（Windows）_opencv4.9 qt-CSDN博客</a></p></blockquote><p>​    下一步，进入目录初始化他：</p><pre class="line-numbers language-none"><code class="language-none">➜  cd vcpkg➜  bootstrap-vcpkg.batDownloading https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;vcpkg-tool&#x2F;releases&#x2F;download&#x2F;2024-06-10&#x2F;vcpkg.exe -&gt; D:\vcpkg\vcpkg.exe (using proxy: http:&#x2F;&#x2F;127.0.0.1:7890)... done.Validating signature... done.vcpkg package management program version 2024-06-10-02590c430e4ed9215d27870138c2e579cc338772See LICENSE.txt for license information.Telemetry---------vcpkg collects usage data in order to help us improve your experience.The data collected by Microsoft is anonymous.You can opt-out of telemetry by re-running the bootstrap-vcpkg script with -disableMetrics,passing --disable-metrics to vcpkg on the command line,or by setting the VCPKG_DISABLE_METRICS environment variable.Read more about vcpkg telemetry at docs&#x2F;about&#x2F;privacy.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    现在可以用vcpkg来下载包了，注意使用他下载的时候挂代理，不然的话就会很慢。</p><blockquote><p>I. 只是想用一用，不想持久化的使用它管理（我）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">cd vcpkgvcpkg install tesseract<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>II. 想要到处使用：</p><p>很简单！自己把自己的vcpkg目录添加进入环境变量就行了</p><p>btw:现在的Windows不需要重启就可以读取环境变量，因为所有的主程序都会在载入内存的时候发起请求载入环境变量的动作，所以正确的做法是重启软件而不是重启操作系统！</p><pre class="line-numbers language-none"><code class="language-none">vcpkg install tesseract<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>​    嗯，第一次下载需要进行漫长的编译，我是经历了几个小时的折磨。</p><p>​    我们的所需品在：</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment"># vcpkg/installed/x64-windows/*</span>➜  tree <span class="token punctuation">.</span>Folder PATH listing <span class="token keyword">for</span> volume <span class="token keyword">Data</span>Volume serial number is 2A4D-419BD:\VCPKG\INSTALLED\X64-WINDOWS├───bin├───debug│   ├───bin│   └───lib│       └───pkgconfig├───include│   ├───curl│   ├───leptonica│   ├───libpng16│   ├───libxml│   ├───libxml2│   │   └───libxml│   ├───lzma│   ├───openjpeg-2<span class="token punctuation">.</span>5│   ├───openssl│   ├───tesseract│   │   ├───api│   │   ├───arch│   │   ├───ccmain│   │   ├───ccstruct│   │   ├───ccutil│   │   ├───classify│   │   ├───cutil│   │   ├───dict│   │   ├───lstm│   │   ├───textord│   │   ├───viewer│   │   └───wordrec│   └───webp│       └───sharpyuv├───lib│   └───pkgconfig├───share│   ├───bzip2│   ├───curl│   ├───doc│   │   └───xz│   │       └───examples│   ├───gif│   ├───giflib│   ├───iconv│   ├───jpeg│   ├───leptonica│   ├───libarchive│   ├───libiconv│   ├───libjpeg-turbo│   ├───liblzma│   ├───libpng│   ├───libwebp│   ├───libxml2│   ├───lz4│   ├───openjpeg│   ├───openssl│   ├───png│   ├───tessdata│   │   ├───configs│   │   └───tessconfigs│   ├───tesseract│   ├───tiff│   ├───vcpkg-cmake│   ├───vcpkg-cmake-config│   ├───vcpkg-cmake-<span class="token function">get-vars</span>│   │   └───cmake_get_vars│   ├───WebP│   ├───zlib│   └───zstd└───tools    ├───bzip2    ├───curl    │   ├───bin    │   └───debug    │       └───bin    ├───libiconv    │   ├───bin    │   └───debug    │       └───bin    └───tesseract<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>有朋友可能会出现vcpkg下包的Error: <a href="https://blog.csdn.net/weixin_74027669/article/details/139796202">2024最新版Vcpkg安装第三方库报错error: building XXXX failed with: BUILD_FAILED_vcpkg 卡在— building x64-linux-dbg-CSDN博客</a>\</p><p>这个CSDN博客解决了我的问题：记得保持vcpkg本地和上游的同步！<code>(git pull; vcpkg update)</code></p></blockquote><p>​    至此完成了编译。</p><h2 id="使用msys2环境下的，使用mingw64编译器编译的Tessereact-OCR动态库"><a href="#使用msys2环境下的，使用mingw64编译器编译的Tessereact-OCR动态库" class="headerlink" title="使用msys2环境下的，使用mingw64编译器编译的Tessereact OCR动态库"></a>使用msys2环境下的，使用mingw64编译器编译的Tessereact OCR动态库</h2><p>​    这个可就折磨人了，无论是官方还是民间给的可参考文献寥寥无几，只好自己摸索。但是没关系，既然这篇文章出现在这里，说明基本上的共同问题已经解决了，文章的大幅度也是描述这个的。</p><h3 id="什么是msys2"><a href="#什么是msys2" class="headerlink" title="什么是msys2"></a>什么是msys2</h3><blockquote><p>msys的官方简介：<a href="https://www.msys2.org/">MSYS2</a></p></blockquote><p>​    MSYS2 是一组工具和库，为您提供了一个易于使用的环境，用于构建、安装和运行原生 Windows 软件。 它由一个名为 mintty 的命令行终端、bash、git 和 subversion 等版本控制系统、tar 和 awk 等工具甚至 autotools 等构建系统组成，所有这些都基于 Cygwin 的修改版本。尽管其中一些核心部分基于 Cygwin，但 MSYS2 的主要重点是为原生 Windows 软件提供构建环境，并将 Cygwin 使用部分保持在最低限度。MSYS2 为 GCC、mingw-w64、CPython、CMake、Meson、OpenSSL、FFmpeg、Rust、Ruby 等提供最新的原生版本。 </p><p>​    为了提供软件包的轻松安装和保持更新的方法，<strong>它提供了一个名为 Pacman 的软件包管理系统，Arch Linux 用户应该很熟悉它</strong>（还真是，来自Arch Linux 用户的肯定）。它带来了许多强大的功能，例如依赖性解析和简单的完整系统升级，以及直接且可复制的软件包构建。我们的软件包存储库包含 3200 多个可立即安装的预构建软件包。</p><p>​    <strong>说了这么多，其实就是提供一个 Mingw 编译器都认的环境，不会出现跨编译器的包的链接导致大串的未定义符号问题，其次，提供一个补全依赖的包管理器辅助我们进行包管理</strong>，我们下面开始安装</p><blockquote><p>5月7日的release：<a href="https://github.com/msys2/msys2-installer/releases/download/2024-05-07/msys2-x86_64-20240507.exe">https://github.com/msys2/msys2-installer/releases/download/2024-05-07/msys2-x86_64-20240507.exe</a></p><p>最新的release去<a href="https://www.msys2.org/">MSYS2</a>上下载</p></blockquote><p>​    值得注意的是，安装中会卡在50%好一会儿，安装包此时正在注册可用的数据库，因此需要花费一些时间，不是安装出现的错误，只是安装所必需要的时间罢了。</p><p><img src="image-20240711090429141.png" alt="image-20240711090429141"></p><p><img src="image-20240711090515022.png" alt="image-20240711090515022"></p><h3 id="安装前，我们也许。。。"><a href="#安装前，我们也许。。。" class="headerlink" title="安装前，我们也许。。。"></a>安装前，我们也许。。。</h3><h4 id="Option-更改用户名"><a href="#Option-更改用户名" class="headerlink" title="[Option]更改用户名"></a>[Option]更改用户名</h4><p>​    至少，我的电脑的用户名是中文的，Msys会继承这一名称，他所惯用的字符集是utf8的，意味着会出现很不友好的字符乱码的行为，所以，改个用户名</p><p>​    在Windows搜索菜单找到Msys2,运行他</p><p><img src="image-20240711090853227.png" alt="image-20240711090853227"></p><p>​    在控制台下：</p><pre class="line-numbers language-none"><code class="language-none">$ &#x2F;usr&#x2F;bin&#x2F;mkpasswd.exe &gt; &#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    然后去自己的安装位置下，找到etc目录，用记事本编辑<code>/etc/passwd</code>，如果发现自己的最后一行出现了中文（那是你的用户名），改成英文，比如说我：</p><pre class="line-numbers language-none"><code class="language-none">Charliechen:*:197609:197121:U-Charliechen\Charliechen,S-1-5-21-611203946-4106071162-1991142053-1001:&#x2F;home&#x2F;Charliechen:&#x2F;usr&#x2F;bin&#x2F;bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    再次运行，同时看看自己的home目录下有没有多出自己刚编辑的用户名文件夹。</p><h4 id="Option-添加一下Path（更改了用户名的需要做）"><a href="#Option-添加一下Path（更改了用户名的需要做）" class="headerlink" title="[Option]添加一下Path（更改了用户名的需要做）"></a>[Option]添加一下Path（更改了用户名的需要做）</h4><blockquote><p>我们的msys随的是bash的规范，也就是说，我们的msys软件首先是读取的是用户的配置，在下面这个地方，我们可以预先写上我们想要在msys2加载的时候运行的shell指令</p><p><img src="image-20240711092554407.png" alt="image-20240711092554407"></p><p>这里标上Option是因为我自己后续安装包的时候发现它并没有识别到在mingw64文件夹下的包，我必须自己手动加入，如果后续下载包发现不添加这里的PATH也能正确的识别到自己下载的依赖软件的话，这一步可以不做！</p><p>在.bashrc文件下：添加</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/d/msys64/mingw64/bin:/d/msys64/mingw64/etc:/d/msys64/mingw64/include:/d/msys64/mingw64/lib:/d/msys64/mingw64/share <span class="token comment"># 添加目标编译器的路径,如果使用clang 64位编译器的话就添加clang64的，其他雷同</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Option-配置默认的代理（对自己网速没有任何信心的，请）"><a href="#Option-配置默认的代理（对自己网速没有任何信心的，请）" class="headerlink" title="[Option]配置默认的代理（对自己网速没有任何信心的，请）"></a>[Option]配置默认的代理（对自己网速没有任何信心的，请）</h4><p>​    还是一样，不过我们添加代理需要遵循的是bash的语法：</p><blockquote><p>在.bashrc文件下：添加</p></blockquote><pre class="line-numbers language-none"><code class="language-none">export http_proxy&#x3D;127.0.0.1:7890export https_proxy&#x3D;127.0.0.1:7890<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="正文1-：-使用全新的编译器编译Tesseract-OCR-C"><a href="#正文1-：-使用全新的编译器编译Tesseract-OCR-C" class="headerlink" title="正文1 ： 使用全新的编译器编译Tesseract OCR C++"></a>正文1 ： 使用全新的编译器编译Tesseract OCR C++</h3><h4 id="配齐基本工具链和依赖"><a href="#配齐基本工具链和依赖" class="headerlink" title="配齐基本工具链和依赖"></a>配齐基本工具链和依赖</h4><p>​    下面需要做的是根据自己的编译器来选择自己的依赖开发组件。在使用基于vcpkg的，于msvc19编译器编译的Tessereact OCR动态库的过程中，我们已经预见了可能使用到的依赖，这里，我们列出可能需要的依赖：</p><blockquote><p>我们假定我们在x86_64平台上的mingw编译器为代表列出可能需要下载的依赖。</p><p>base-devel msys2-devel mingw-w64-x86_64-toolchain: 基本的编译套装，值得注意的是：这里编译出的库最好是给由编译同一编译器编译出的软件使用！（为正文2埋下伏笔）</p><p>git: 你猜猜我们怎么下代码（不是）</p><p>mingw-w64-x86_64-asciidoc mingw-w64-x86_64-cairo mingw-w64-x86_64-curl mingw-w64-x86_64-icu mingw-w64-x86_64-leptonica mingw-w64-x86_64-libarchive mingw-w64-x86_64-pango mingw-w64-x86_64-zlib ：Tessereact 编译+运行时依赖</p><p>mingw-w64-x86_64-autotools ，mingw-w64-x86_64-cmake</p></blockquote><pre class="line-numbers language-none"><code class="language-none">pacman -S base-devel msys2-devel mingw-w64-x86_64-toolchain git mingw-w64-x86_64-asciidoc mingw-w64-x86_64-cairo mingw-w64-x86_64-curl mingw-w64-x86_64-icu mingw-w64-x86_64-leptonica mingw-w64-x86_64-libarchive mingw-w64-x86_64-pango mingw-w64-x86_64-zlib mingw-w64-x86_64-autotools mingw-w64-x86_64-cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>有人可能需要使用clang来编译，或者是urct等，可以自行pacman -Ss 查找包名，例子：</p><pre class="line-numbers language-none"><code class="language-none">$ pacman -Ss cmakeclangarm64&#x2F;mingw-w64-clang-aarch64-ccmake 3.29.2-2 A cross-platform open-source make system (mingw-w64) (curses GUI)clangarm64&#x2F;mingw-w64-clang-aarch64-cmake 3.29.2-2 A cross-platform open-source make system (mingw-w64)clangarm64&#x2F;mingw-w64-clang-aarch64-cmake-cmcldeps 3.29.2-2 CMake wrapper for cl to extract dependencies (mingw-w64)...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据自己的目标编译器下包！mingw编译器的就需要选择前缀是mingw-w64-x86_64-， clang编译器的：mingw-w64-clang-x86_64-… 看看自己的pacman -Ss输出就好！（<strong>注意编译套装和依赖要一平齐</strong>）</p></blockquote><p>​    上面的这些依赖大约1.5G，泡杯茶休息一下吧！</p><p>​    下载完毕后，测试一下：</p><pre class="line-numbers language-none"><code class="language-none">$ cmake -versioncmake version 3.29.2CMake suite maintained and supported by Kitware (kitware.com&#x2F;cmake).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    如果这里告诉你Unknown Command，就回到《安装前，我们也许。。。》的章节部分的《添加Path》部分，把这个事情做完重启msys就好了。</p><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p>​    跟随我的步伐~</p><pre class="line-numbers language-none"><code class="language-none">Charliechen@Charliechen MINGW64 ~$ echo $https_proxy# 查看自己的代理（我网菜）127.0.0.1:7890Charliechen@Charliechen MINGW64 ~$ git clone https:&#x2F;&#x2F;github.com&#x2F;tesseract-ocr&#x2F;tesseract tesseractCloning into &#39;tesseract&#39;...remote: Enumerating objects: 47934, done.remote: Counting objects: 100% (412&#x2F;412), done.remote: Compressing objects: 100% (252&#x2F;252), done.remote: Total 47934 (delta 199), reused 253 (delta 153), pack-reused 47522Receiving objects: 100% (47934&#x2F;47934), 52.30 MiB | 4.29 MiB&#x2F;s, done.Resolving deltas: 100% (37371&#x2F;37371), done.Updating files: 100% (729&#x2F;729), done.Charliechen@Charliechen MINGW64 ~$ cd tesseract&#x2F;Charliechen@Charliechen MINGW64 ~&#x2F;tesseract$ lsAUTHORS          INSTALL.GIT.md  autogen.sh          java      tesseract.pc.cmakeCITATIONS.bib    LICENSE         cmake               m4        tesseract.pc.inCMakeLists.txt   Makefile.am     configure.ac        snap      testCONTRIBUTING.md  README.md       doc                 src       unittestChangeLog        VERSION         docker-compose.yml  sw.cppINSTALL          appveyor.yml    include     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    我们下面开始构建源码。</p><h4 id="构建源码"><a href="#构建源码" class="headerlink" title="构建源码"></a>构建源码</h4><p>​    使用CMake的经典步骤！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Charliechen@Charliechen MINGW64 ~/tesseract$ <span class="token builtin class-name">pwd</span>/home/Charliechen/tesseractCharliechen@Charliechen MINGW64 ~/tesseract$ <span class="token function">mkdir</span> build <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> buildCharliechen@Charliechen MINGW64 ~/tesseract/build$ <span class="token builtin class-name">pwd</span>/home/Charliechen/tesseract/build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    我们使用的是默认的默认的编译器，而且，默认的CMakeLists是指定使用SW包管理管理依赖，事实证明，这个玩意我开代理都救不了的狗屎东西，所以，我们需要设置cmake的参数为：</p><blockquote><p>-DSW_BUILD=0 表示不用sw构建程序，Sw即Software Network也是一个开源安装器</p><p>-DCMAKE_INSTALL_PREFIX=/usr/local 表示将程序安装到/usr/local</p><p>其他的参数按照自己的需求加</p></blockquote><pre class="line-numbers language-none"><code class="language-none">Charliechen@Charliechen MINGW64 ~&#x2F;tesseract&#x2F;build$ pwd&#x2F;home&#x2F;Charliechen&#x2F;tesseract&#x2F;buildCharliechen@Charliechen MINGW64 ~&#x2F;tesseract&#x2F;build$ cmake .. -G&quot;MinGW Makefiles&quot; -DSW_BUILD&#x3D;0 -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local-- Setting policy CMP0091 to NEW-- The C compiler identification is GNU 13.2.0-- The CXX compiler identification is GNU 13.2.0-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Check for working C compiler: D:&#x2F;msys64&#x2F;mingw64&#x2F;bin&#x2F;cc.exe - skipped-- Detecting C compile features...-- Configuring done (23.6s)-- Generating done (0.7s)-- Build files have been written to: D:&#x2F;msys64&#x2F;home&#x2F;Charliechen&#x2F;tesseract&#x2F;build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    仔细看看控制台，有没有fatal error，如果我们上面的事情都做好了，一般不会出现问题，出现问题自行Github Issue之。少依赖了自行配置之！</p><p>​    完成后，马力全开</p><blockquote><p><code>--build .</code>: 在当前目录下展开构建</p><p><code>-j$(nproc)</code>：以最大可支持的线程数进行编译。</p><p><code>--config Release</code>：配置为发布版本（无调试信息）。</p><p><code>--target install</code>:对生成的目标进行install操作（等价于make install在这里）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$ cmake --build . -j$(nproc)  --config Release --target install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    好消息是：不用泡茶，构建相当迅速。整个流程甚至连一个Warning都没有。当然，仅限全新的默认工具链！（写完这句话编译完了）</p><pre class="line-numbers language-none"><code class="language-none">...-- Installing: D:&#x2F;msys64&#x2F;usr&#x2F;local&#x2F;bin&#x2F;unicharset_extractor.exe-- Installing: D:&#x2F;msys64&#x2F;usr&#x2F;local&#x2F;bin&#x2F;text2image.exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    现在我们看看</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">➜  tree <span class="token punctuation">.</span>Folder PATH listing <span class="token keyword">for</span> volume <span class="token keyword">Data</span>Volume serial number is 2A4D-419BD:\MSYS64\USR\LOCAL<span class="token comment"># /usr/local/ 在Window上的等价映射</span>├───bin├───etc├───include│   └───tesseract├───lib│   ├───cmake│   │   └───tesseract│   └───pkgconfig<span class="token comment"># 有pkgconfig，可以CMake下用PKG_CONGIG来找包引入了</span>└───share    └───tessdata        ├───configs        └───tessconfigs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    我们可以玩玩这个库了！按照一般的测试流程就行！这里不加以演示了。</p><h3 id="正文2：以Qt为例，部署到目标项目里集成使用"><a href="#正文2：以Qt为例，部署到目标项目里集成使用" class="headerlink" title="正文2：以Qt为例，部署到目标项目里集成使用"></a>正文2：以Qt为例，部署到目标项目里集成使用</h3><p>​    到这里，我们实际上可以使用Tesseract了，但是我自己在移植到其他平台上进行开发的时候发现了由于编译器的微妙差别和库依赖的问题，实际上仍然困难重重。。。代表性的有：</p><pre class="line-numbers language-none"><code class="language-none">undefined reference to &#96;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_replace_cold(char*, unsigned long long, char const*, unsigned long long, unsigned long long)&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    这是因为我目标开发平台上使用的主编译器和构建的库使用的编译器不一致导致的…所以，我们就需要回过头来，重新部署配置。</p><p>​    现在为了方便演示，我们使用cmake-gui来完成操作。</p><blockquote><p>我自己清空了build文件夹下的东西！</p><pre class="line-numbers language-none"><code class="language-none">Charliechen@Charliechen MINGW64 ~&#x2F;tesseract&#x2F;build$ pwd&#x2F;home&#x2F;Charliechen&#x2F;tesseract&#x2F;buildCharliechen@Charliechen MINGW64 ~&#x2F;tesseract&#x2F;build$ ls<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接阅过正文1的朋友，在开始之前仍然是在做经典的CMake构建步骤</p><pre class="line-numbers language-none"><code class="language-none">Charliechen@Charliechen MINGW64 ~&#x2F;tesseract$ pwd&#x2F;home&#x2F;Charliechen&#x2F;tesseractCharliechen@Charliechen MINGW64 ~&#x2F;tesseract$ mkdir build &amp;&amp; cd buildCharliechen@Charliechen MINGW64 ~&#x2F;tesseract&#x2F;build$ pwd&#x2F;home&#x2F;Charliechen&#x2F;tesseract&#x2F;build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>​    我们为了方便指定编译器和设置参数，还是使用cmake-gui干活方便</p><pre class="line-numbers language-none"><code class="language-none">Charliechen@Charliechen MINGW64 ~&#x2F;tesseract&#x2F;build$ pacman -Ss cmake-gui...mingw64&#x2F;mingw-w64-x86_64-cmake-gui 3.29.2-2    A cross-platform open-source make system (mingw-w64) (Qt GUI)...Charliechen@Charliechen MINGW64 ~&#x2F;tesseract&#x2F;build$ pacman -S mingw-w64-x86_64-cmake-gui...Charliechen@Charliechen MINGW64 ~&#x2F;tesseract&#x2F;build$ cmake-gui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果这里告诉你cmake-gui是Unknown Command，就回到《安装前，我们也许。。。》的章节部分的《添加Path》部分，把这个事情做完重启msys就好了。</p></blockquote><p>​    这是弹出的界面：</p><p><img src="image-20240711104109623.png" alt="image-20240711104109623"></p><p>​    在这里我们指定自己使用的本地编译器：</p><p><img src="image-20240711104146832.png" alt="image-20240711104146832"></p><p>​    记得勾选好后，准备执行第一次配置。</p><p>​    第一次配置会报错：</p><pre class="line-numbers language-none"><code class="language-none">Could not find a package configuration file provided by &quot;SW&quot; with any ofthe following names:  SWConfig.cmake  sw-config.cmakeAdd the installation prefix of &quot;SW&quot; to CMAKE_PREFIX_PATH or set &quot;SW_DIR&quot; toa directory containing one of the above files.  If &quot;SW&quot; provides a separatedevelopment package or SDK, be sure it has been installed.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    很正常，我们都没有SW包管理器，有的话自行按照上面说的自己指定就好，不然，就跟着我把这个选项去掉：</p><p>​    这里的<code>SW_BUILD</code>给点掉，让它不参与构建！</p><p><img src="image-20240711104403132.png" alt="image-20240711104403132"></p><p>​    再配置一次，现在不会报错了。</p><p>​    我们下面配置一下下载的位置，不然的话会下载到默认的位置</p><p><img src="image-20240711104545400.png" alt="image-20240711104545400"></p><p>​    改到自己的目标位置上</p><p><img src="image-20240711104612739.png" alt="image-20240711104612739"></p><blockquote><p>点击右侧的小…来选定位置！</p></blockquote><p>​    如果您有其他需求，继续进行配置就好。记得再配置一次。比如说我这里的项目要求C++17，那就再CXX_FLAGS那里添加<code>-std=c++17</code>，依次类推</p><p><img src="image-20240711104732230.png" alt="image-20240711104732230"></p><p>​    现在我们确信上方没有发红的项，控制台上也没有报错的信息，表明所有的依赖都被正确定位且组合！</p><p>​    点击Generate生成Mingw Makefile就好。</p><p>​    下一步就是关掉界面，执行构建：</p><pre class="line-numbers language-none"><code class="language-none">Charliechen@Charliechen MINGW64 ~&#x2F;tesseract&#x2F;build$ cmake --build . -j$(nproc) --target install...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    由于这里不再使用默认的配置，故爆警告甚至是错误（我没有遇到，可能情况并不算特殊）随自己的平台的编译器而定！</p><p>​    下载完了看看：</p><pre class="line-numbers language-none"><code class="language-none">➜  tree .Folder PATH listing for volume DataVolume serial number is 2A4D-419BD:\MINGW_TESSERACT_INSTALL# 按照自己的配置，如期出现在了 D:&#x2F;mingw_tesseract_install 上了├───bin├───include│   └───tesseract├───lib│   ├───cmake│   │   └───tesseract│   └───pkgconfig└───share    └───tessdata        ├───configs        └───tessconfigs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h4 id="添加识别依赖"><a href="#添加识别依赖" class="headerlink" title="添加识别依赖"></a>添加识别依赖</h4><p>​    开一个Console过程就直接干！</p><blockquote><p>回顾：我们的vcpkg - MSVC Tesseract下载到了 <code>vcpkg/installed/x64-windows/*</code> 下面，对此，我自己的路径是：</p><pre class="line-numbers language-none"><code class="language-none"># 下载路径前缀 Prefix: D:\vcpkg\installed\x64-windows\# 头文件包含路径 Include Path: D:\vcpkg\installed\x64-windows\include# 用于动态库运行加载信息的静态信息库 Static Library Path: D:\vcpkg\installed\x64-windows\lib# 动态运行依赖库 Dynamic Runtime Required Bins: # debug模式D:\vcpkg\installed\x64-windows\debug\bin# release模式D:\vcpkg\installed\x64-windows\bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>以我的路径为例子，我们要做的就是在</p><blockquote><p>属性 - VC++ - 包含路径中加入D:\vcpkg\installed\x64-windows\include</p><p>属性 - VC++ - 库路径加入D:\vcpkg\installed\x64-windows\lib</p><p>属性 - 链接器 - 附加依赖项添加leptonica-1.84.1d.lib和tesseract54d.lib</p><p>D:\vcpkg\installed\x64-windows\debug\lib\leptonica-1.84.1d.lib<br>D:\vcpkg\installed\x64-windows\debug\lib\tesseract54d.lib</p><p>在调试 - 工作目录下设置为：</p><p>Debug模式下：D:\vcpkg\installed\x64-windows\debug\bin，</p><p>Release模式下：D:\vcpkg\installed\x64-windows\bin</p><p>看官自行对照路径加入</p></blockquote><h4 id="下载数据集与设置TESSDATA-PREFIX"><a href="#下载数据集与设置TESSDATA-PREFIX" class="headerlink" title="下载数据集与设置TESSDATA_PREFIX"></a>下载数据集与设置TESSDATA_PREFIX</h4><p>​    我们要先下载数据集，不然我们的Tesseract没法运行起来！</p><blockquote><p>TessData数据集在：<a href="https://github.com/tesseract-ocr/tessdata">tesseract-ocr/tessdata: Trained models with fast variant of the “best” LSTM models + legacy models (github.com)</a>，使用vcpkg下包的朋友，把他放到<code>vcpkg\installed\x64-windows\share\tessdata</code>下，这个文件夹放置的是Tesseract用到的数据和配置。</p><p>一些常见语言的数据集：</p><p>中文数据集：<a href="https://github.com/tesseract-ocr/tessdata/blob/main/chi_sim.traineddata">tessdata/chi_sim.traineddata at main · tesseract-ocr/tessdata (github.com)</a></p><p>英文数据集：<a href="https://github.com/tesseract-ocr/tessdata/blob/main/eng.traineddata">tessdata/eng.traineddata at main · tesseract-ocr/tessdata (github.com)</a></p></blockquote><p>​    还没有完事，我们还需要设置TESSDATA_PREFIX环境变量的值，否则我们的程序不知道如何去哪里寻找配置！</p><p>​    有两个方法：</p><p>​    方法I：在环境变量中加入的TESSDATA_PREFIX值，指向的是tessdata文件夹，使用vcpkg下载的朋友可以在<code>vcpkg\installed\x64-windows\share\tessdata</code>下找到，将这个文件夹的路径先添加到环境变量当中，确认后可以尝试控制台输出一下，比如说我自己的是</p><pre class="line-numbers language-none"><code class="language-none">➜  $Env:TESSDATA_PREFIXD:\vcpkg\installed\x64-windows\share\tessdata<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    方法II：如果您是库开发者，可能并不希望用户感知道自己使用的OCR库的存在，需要在程序运行时动态的设定这个值。所以你可以使用非标准库的<code>_put_env_s</code>或者是根据所使用到的操作系统调用对应的API，这里不加以演示了！</p><h3 id="测试1：-在Visual-Studio上测试vcpkg产出的Tesseract-OCR"><a href="#测试1：-在Visual-Studio上测试vcpkg产出的Tesseract-OCR" class="headerlink" title="测试1： 在Visual Studio上测试vcpkg产出的Tesseract OCR"></a>测试1： 在Visual Studio上测试vcpkg产出的Tesseract OCR</h3><p>​    我们测试官方自己家的小例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;tesseract/baseapi.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;leptonica/allheaders.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream></span></span><span class="token comment">// 看官自行在github仓库上下好phototest.tif</span><span class="token keyword">static</span> constexpr <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> PATH <span class="token operator">=</span> <span class="token string">"D:\\My coding repositary\\windows\\libTesseract\\phototest.tif"</span><span class="token punctuation">;</span><span class="token comment">// 输出到的文件位置：</span><span class="token keyword">static</span> constexpr <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> writeTo <span class="token operator">=</span> <span class="token string">"D:\\My coding repositary\\windows\\libTesseract\\result.txt"</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span><span class="token operator">*</span> outText<span class="token punctuation">;</span>    tesseract<span class="token operator">::</span>TessBaseAPI<span class="token operator">*</span> api <span class="token operator">=</span> new tesseract<span class="token operator">::</span><span class="token function">TessBaseAPI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Initialize tesseract-ocr with English, without specifying tessdata path</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>api<span class="token operator">-></span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">"eng"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Could not initialize tesseract.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Open input image with leptonica library</span>    Pix<span class="token operator">*</span> image <span class="token operator">=</span> <span class="token function">pixRead</span><span class="token punctuation">(</span>PATH<span class="token punctuation">)</span><span class="token punctuation">;</span>    api<span class="token operator">-></span><span class="token function">SetImage</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Get OCR result</span>    outText <span class="token operator">=</span> api<span class="token operator">-></span><span class="token function">GetUTF8Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>fstream <span class="token function">to</span><span class="token punctuation">(</span>writeTo<span class="token punctuation">,</span> std<span class="token operator">::</span>ios_base<span class="token operator">::</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>to<span class="token punctuation">.</span><span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        to <span class="token operator">&lt;&lt;</span> outText<span class="token punctuation">;</span>        to<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error in writing files:> %s"</span><span class="token punctuation">,</span> writeTo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// Destroy used object and release memory</span>    api<span class="token operator">-></span><span class="token function">End</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    delete api<span class="token punctuation">;</span>    delete<span class="token punctuation">[</span><span class="token punctuation">]</span> outText<span class="token punctuation">;</span>    <span class="token function">pixDestroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    程序的执行结果令人满意：</p><pre class="line-numbers language-none"><code class="language-none">D:\My coding repositary\windows\libTesseract\x64\Debug\libTesseract.exe (进程 31484)已退出，代码为 0。按任意键关闭此窗口. . .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20240711114954828.png" alt="image-20240711114954828"></p><p>可能出现的错误：</p><ol><li><p>```<br>Error opening data file ./chi_sim.traineddata<br>Please make sure the TESSDATA_PREFIX environment variable is set to your “tessdata” directory.<br>Failed loading language ‘eng’<br>Tesseract couldn’t load any languages!<br>Could not initialize tesseract.</p><pre class="line-numbers language-none"><code class="language-none">   这个错误的原因非常简单，并没有设定相关的环境变量的值导致库并不知道去哪里读取训练数据。所以解决方案是：前往上一个小节的《设置TESSDATA》部分仔细阅读，根据自己的开发身份确定！2. &#96;&#96;&#96;   Error opening data file D:\vcpkg\installed\x64-windows\share\tessdata&#x2F;chi_sim.traineddata   Please make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory.   Failed loading language &#39;chi_sim&#39;   Tesseract couldn&#39;t load any languages!   Could not initialize tesseract.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个错误的原因也很简单，说明缺失相关的训练数据，需要我们去Github上下载对应的训练数据，并放到自己设定的TESSDATA_PREFIX文件夹下方！</p></li></ol><blockquote><p>TessData数据集在：<a href="https://github.com/tesseract-ocr/tessdata">tesseract-ocr/tessdata: Trained models with fast variant of the “best” LSTM models + legacy models (github.com)</a>，使用vcpkg下包的朋友，把他放到<code>vcpkg\installed\x64-windows\share\tessdata</code>下，这个文件夹放置的是Tesseract用到的数据和配置。</p><p>一些常见语言的数据集：</p><p>中文数据集：<a href="https://github.com/tesseract-ocr/tessdata/blob/main/chi_sim.traineddata">tessdata/chi_sim.traineddata at main · tesseract-ocr/tessdata (github.com)</a></p><p>英文数据集：<a href="https://github.com/tesseract-ocr/tessdata/blob/main/eng.traineddata">tessdata/eng.traineddata at main · tesseract-ocr/tessdata (github.com)</a></p></blockquote><h3 id="测试2：在-Qt-上使用Tesseract-OCR-C"><a href="#测试2：在-Qt-上使用Tesseract-OCR-C" class="headerlink" title="测试2：在 Qt 上使用Tesseract OCR C++"></a>测试2：在 Qt 上使用Tesseract OCR C++</h3><h4 id="测试程序："><a href="#测试程序：" class="headerlink" title="测试程序："></a>测试程序：</h4><pre class="line-numbers language-none"><code class="language-none">#include &lt;tesseract&#x2F;baseapi.h&gt;#include &lt;leptonica&#x2F;allheaders.h&gt;#include &lt;fstream&gt;&#x2F;&#x2F; 看官自行在github仓库上下好phototest.tifstatic constexpr const char* PATH &#x3D; &quot;D:\\My coding repositary\\windows\\libTesseract\\phototest.tif&quot;;&#x2F;&#x2F; 输出到的文件位置：static constexpr const char* writeTo &#x3D; &quot;D:\\My coding repositary\\windows\\libTesseract\\result.txt&quot;;int main()&#123;    char* outText;    tesseract::TessBaseAPI* api &#x3D; new tesseract::TessBaseAPI();    &#x2F;&#x2F; Initialize tesseract-ocr with English, without specifying tessdata path    if (api-&gt;Init(NULL, &quot;eng&quot;)) &#123;        fprintf(stderr, &quot;Could not initialize tesseract.\n&quot;);        exit(1);    &#125;    &#x2F;&#x2F; Open input image with leptonica library    Pix* image &#x3D; pixRead(PATH);    api-&gt;SetImage(image);    &#x2F;&#x2F; Get OCR result    outText &#x3D; api-&gt;GetUTF8Text();    std::fstream to(writeTo, std::ios_base::out);    if(to.is_open())    &#123;        to &lt;&lt; outText;        to.close(    &#125;    else &#123;        printf(&quot;Error in writing files:&gt; %s&quot;, writeTo);    &#125;    &#x2F;&#x2F; Destroy used object and release memory    api-&gt;End();    delete api;    delete[] outText;    pixDestroy(&amp;image);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="MSVC-Special"><a href="#MSVC-Special" class="headerlink" title="MSVC Special"></a>MSVC Special</h4><p>​    我们创建一个Demo实例，非Qt程序可以去掉QApplication依赖和QT += core的配置（QMake）。下面，我们将所需要的依赖拷贝到目标目录下：将vcpkg下的lib, bin, include目录拷贝到自己的项目文件夹下。</p><p><img src="image-20240711121340555.png" alt="image-20240711121340555"></p><p>​    对于Qt，类似的添加头文件，静态库：</p><pre class="line-numbers language-none"><code class="language-none">CONFIG +&#x3D; c++17 cmdline# You can make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.#DEFINES +&#x3D; QT_DISABLE_DEPRECATED_BEFORE&#x3D;0x060000    # disables all the APIs deprecated before Qt 6.0.0SOURCES +&#x3D; \        main.cpp# Default rules for deployment.qnx: target.path &#x3D; &#x2F;tmp&#x2F;$$&#123;TARGET&#125;&#x2F;binelse: unix:!android: target.path &#x3D; &#x2F;opt&#x2F;$$&#123;TARGET&#125;&#x2F;bin!isEmpty(target.path): INSTALLS +&#x3D; targetwin32:CONFIG(release, debug|release): LIBS +&#x3D; -L$$PWD&#x2F;lib&#x2F; -ltesseract54 -lleptonica-1.84.1else:win32:CONFIG(debug, debug|release): LIBS +&#x3D; -L$$PWD&#x2F;lib&#x2F; -ltesseract54d -lleptonica-1.84.1delse:unix: LIBS +&#x3D; -L$$PWD&#x2F;lib&#x2F; -ltesseract54INCLUDEPATH +&#x3D; $$PWD&#x2F;includeDEPENDPATH +&#x3D; $$PWD&#x2F;include<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    将bin文件下的dll文件全部拷贝到exe同级目录下方</p><p><img src="image-20240711121957196.png" alt="image-20240711121957196"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;tesseract&#x2F;baseapi.h&gt;#include &lt;leptonica&#x2F;allheaders.h&gt;#include &lt;fstream&gt;static constexpr const char* PATH &#x3D; &quot;D:\\My coding repositary\\windows\\libTesseract\\phototest.tif.&quot;;static constexpr const char* writeTo &#x3D; &quot;.&#x2F;result.txt&quot;;int main()&#123;    char* outText;    tesseract::TessBaseAPI* api &#x3D; new tesseract::TessBaseAPI();    &#x2F;&#x2F; Initialize tesseract-ocr with English, without specifying tessdata path    if (api-&gt;Init(NULL, &quot;eng&quot;)) &#123;        fprintf(stderr, &quot;Could not initialize tesseract.\n&quot;);        exit(1);    &#125;    &#x2F;&#x2F; Open input image with leptonica library    Pix* image &#x3D; pixRead(PATH);    api-&gt;SetImage(image);    &#x2F;&#x2F; Get OCR result    outText &#x3D; api-&gt;GetUTF8Text();    std::fstream to(writeTo, std::ios_base::out);    if(to.is_open())    &#123;        to &lt;&lt; outText;        to.close();    &#125;    else &#123;        printf(&quot;Error in writing files:&gt; %s&quot;, writeTo);    &#125;    &#x2F;&#x2F; Destroy used object and release memory    api-&gt;End();    delete api;    delete[] outText;    pixDestroy(&amp;image);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    现在运行即可得到结果，这里不再赘述。</p><blockquote><p>可能出现的错误：</p><ol><li><p>```<br>Error opening data file ./chi_sim.traineddata<br>Please make sure the TESSDATA_PREFIX environment variable is set to your “tessdata” directory.<br>Failed loading language ‘eng’<br>Tesseract couldn’t load any languages!<br>Could not initialize tesseract.</p><pre class="line-numbers language-none"><code class="language-none">   这个错误的原因非常简单，并没有设定相关的环境变量的值导致库并不知道去哪里读取训练数据。所以解决方案是：前往上一个小节的《设置TESSDATA》部分仔细阅读，根据自己的开发身份确定！2. &#96;&#96;&#96;   Error opening data file D:\vcpkg\installed\x64-windows\share\tessdata&#x2F;chi_sim.traineddata   Please make sure the TESSDATA_PREFIX environment variable is set to your &quot;tessdata&quot; directory.   Failed loading language &#39;chi_sim&#39;   Tesseract couldn&#39;t load any languages!   Could not initialize tesseract.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个错误的原因也很简单，说明缺失相关的训练数据，需要我们去Github上下载对应的训练数据，并放到自己设定的TESSDATA_PREFIX文件夹下方！</p></li></ol><blockquote><p>TessData数据集在：<a href="https://github.com/tesseract-ocr/tessdata">tesseract-ocr/tessdata: Trained models with fast variant of the “best” LSTM models + legacy models (github.com)</a>，使用vcpkg下包的朋友，把他放到<code>vcpkg\installed\x64-windows\share\tessdata</code>下，这个文件夹放置的是Tesseract用到的数据和配置。</p><p>一些常见语言的数据集：</p><p>中文数据集：<a href="https://github.com/tesseract-ocr/tessdata/blob/main/chi_sim.traineddata">tessdata/chi_sim.traineddata at main · tesseract-ocr/tessdata (github.com)</a></p><p>英文数据集：<a href="https://github.com/tesseract-ocr/tessdata/blob/main/eng.traineddata">tessdata/eng.traineddata at main · tesseract-ocr/tessdata (github.com)</a></p></blockquote><ol><li><p>QProcess::Crashed，也就是说控制台输出</p><pre class="line-numbers language-none"><code class="language-none">qtc.process_stub: Inferior error:  QProcess::Crashed &quot;Process crashed&quot;Process exited with code: -1073741515<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是缺乏了动态库，按照笔者所述的，要么指定动态库路径，要么自己放到跟exe文件同级目录下方。</p></li></ol></blockquote><h4 id="Mingw-版本"><a href="#Mingw-版本" class="headerlink" title="Mingw 版本"></a>Mingw 版本</h4><p>​    这个最难办，我们使用的Msys编译的库都是只打包到msys环境下才可用，导出到外部需要我们自己手动完成依赖配置。笔者搞了一个下午，查阅无数的.pc依赖文件和解决符号问题才将依赖配好，这里给出需要的东西：</p><blockquote><p>回顾我们的构建：我们把东西装在了<code>D:\mingw_tesseract_install</code>下，找到也是你自己的位置！</p><p>Include文件夹：<code>D:\mingw_tesseract_install</code>，我们发现只有tesseract的，我们需要另找Leptonica的：他在<code>msys64/mingw/include/leptonica</code>，把这个文件夹拷贝到include目录下，构成以下的视图：</p><pre class="line-numbers language-none"><code class="language-none">➜  tree .Folder PATH listing for volume DataVolume serial number is 2A4D-419BD:\QT PROJECTS\TESS_MINGW\INCLUDE├───leptonica # Leptonica└───tesseract # Tesseract<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lib文件夹：这个也需要自己组装，笔者组装的结果如下：</p><p>.a文件：libtesseract54.a（自行在<code>D:\mingw_tesseract_install\lib\</code>）下找到并放到这里</p><p>.dll文件：在<code>msys64/mingw/include/bin</code>下依次搜索然后拷贝扔到lib文件夹下。</p><pre class="line-numbers language-none"><code class="language-none">-a---           2024&#x2F;4&#x2F;29    13:52         769154 libarchive-13.dll-a---           2022&#x2F;2&#x2F;18    23:03          34372 libb2-1.dll-a---            2023&#x2F;9&#x2F;6    15:40         143397 libbrotlicommon.dll-a---            2023&#x2F;9&#x2F;6    15:40          60412 libbrotlidec.dll-a---           2023&#x2F;9&#x2F;27    14:57         100964 libbz2-1.dll-a---           2024&#x2F;4&#x2F;30     1:58        5094016 libcrypto-3-x64.dll-a---           2024&#x2F;3&#x2F;28     2:39         861289 libcurl-4.dll-a---           2024&#x2F;3&#x2F;27    23:05          91035 libdeflate.dll-a---           2024&#x2F;3&#x2F;14     5:04         188909 libexpat-1.dll-a---           2024&#x2F;2&#x2F;21    17:04          41367 libgif-7.dll-a---            2024&#x2F;2&#x2F;2    20:48        1118202 libiconv-2.dll-a---            2024&#x2F;2&#x2F;2    16:48         242965 libidn2-0.dll-a---           2024&#x2F;2&#x2F;23    15:41         188681 libintl-8.dll-a---           2023&#x2F;8&#x2F;18    17:47          62083 libjbig-0.dll-a---           2024&#x2F;1&#x2F;26    19:30         928587 libjpeg-8.dll-a---            2024&#x2F;1&#x2F;5     5:05        2721006 libleptonica-6.dll-a---           2022&#x2F;7&#x2F;29    16:34         761261 libLerc.dll-a---           2022&#x2F;8&#x2F;16    14:20         147105 liblz4.dll-a---           2024&#x2F;3&#x2F;30     4:01         184667 liblzma-5.dll-a---            2024&#x2F;4&#x2F;5     5:52         216502 libnghttp2-14.dll-a---           2024&#x2F;2&#x2F;29    14:07         462194 libopenjp2-7.dll-a---           2024&#x2F;2&#x2F;24     4:20         247380 libpng16-16.dll-a---            2024&#x2F;2&#x2F;2    21:09         103768 libpsl-5.dll-a---           2024&#x2F;4&#x2F;16    23:04          57852 libsharpyuv-0.dll-a---           2023&#x2F;9&#x2F;10    23:04         295582 libssh2-1.dll-a---           2024&#x2F;4&#x2F;30     1:58        1009819 libssl-3-x64.dll-a---           2023&#x2F;9&#x2F;13    20:24         576887 libtiff-6.dll-a---           2024&#x2F;3&#x2F;29    23:03        1999287 libunistring-5.dll-a---           2024&#x2F;4&#x2F;16    23:04         743580 libwebp-7.dll-a---           2024&#x2F;4&#x2F;16    23:04          78730 libwebpmux-3.dll-a---            2024&#x2F;4&#x2F;3     3:59        1179848 libzstd.dll-a---           2024&#x2F;1&#x2F;23    15:49         120814 zlib1.dll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>​    这要求我们的.pro文件不太好看：</p><pre class="line-numbers language-none"><code class="language-none">TEMPLATE &#x3D; appCONFIG +&#x3D; console c++17CONFIG -&#x3D; app_bundleCONFIG -&#x3D; qtSOURCES +&#x3D; \        main.cppwin32:CONFIG(release, debug|release): LIBS +&#x3D; -L$$PWD&#x2F;lib&#x2F; *.dll -L$$PWD&#x2F;lib&#x2F; -ltesseract54 -lws2_32else:win32:CONFIG(debug, debug|release): LIBS +&#x3D; $$PWD&#x2F;lib&#x2F;*.dll -L$$PWD&#x2F;lib&#x2F; -ltesseract54 -lws2_32else:unix: LIBS +&#x3D; -L$$PWD&#x2F;lib&#x2F; -ltesseract54 -lleptonicaINCLUDEPATH +&#x3D; $$PWD&#x2F;includeDEPENDPATH +&#x3D; $$PWD&#x2F;include<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    编译通过，由于我们的程序是直接连接构建的，故可用直接运行：</p><pre class="line-numbers language-none"><code class="language-none">Process exited with code: 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240711132145641.png" alt="image-20240711132145641"></p><p>​    这里可能出现的错误跟上面阐述的一致，故这里不再重述</p><h2 id="最后…"><a href="#最后…" class="headerlink" title="最后…"></a>最后…</h2><p>​    到这里，放Github地址：</p><blockquote><p><a href="https://github.com/Charliechen114514/TesseractBuild">Charliechen114514/TesseractBuild: A build in Windows11 x86_64 arch for Tesseract54 (github.com)</a>: 可直接使用的release版本</p><p><a href="https://github.com/Charliechen114514/TesseractWrapper">Charliechen114514/TesseractWrapper (github.com) </a>一个简单的包装器</p><p>考虑给个star?（划</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Compile </tag>
            
            <tag> Tesseract_OCR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32开发环境配置记录——关于PlatformIO + VSCode + CubeMX的集成环境配置</title>
      <link href="/2024/07/27/STM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8EPlatformIO-VSCode-CubeMX%E7%9A%84%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/07/27/STM32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8EPlatformIO-VSCode-CubeMX%E7%9A%84%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32开发环境配置记录——关于PlatformIO-VSCode-CubeMX的集成环境配置"><a href="#STM32开发环境配置记录——关于PlatformIO-VSCode-CubeMX的集成环境配置" class="headerlink" title="STM32开发环境配置记录——关于PlatformIO + VSCode + CubeMX的集成环境配置"></a>STM32开发环境配置记录——关于PlatformIO + VSCode + CubeMX的集成环境配置</h1><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    为什么配置这样的一个环境呢？鄙人受够了Keil5那个简陋的工作环境了，实在是用不下去，调试上很容易跟CubeMX的代码产生不协调导致调试——发布代码不一致造成的一系列问题。CubeIDE虽说不错，但是它的代码辅助功能和构建系统实在不敢恭维，经常出现Makefile未同步导致符号定义冲突，亦或者是埋下了潜在的程序bug。</p><p>​    也有人尝试使用Keil Assistance + VSCode + Keil分工写代码与烧录，这听起来不错，但是调试并不方便，常常要来回奔波，实在是有些麻烦。这里我们尝试新兴的PlatformIO来辅助我们进行嵌入式的开发。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="PlatformIO"><a href="#PlatformIO" class="headerlink" title="PlatformIO"></a>PlatformIO</h3><blockquote><p><a href="https://docs.platformio.org/en/latest/">Your Gateway to Embedded Software Development Excellence — PlatformIO latest documentation</a></p></blockquote><p>​    Platform是基于VScode文本编辑器，使用了vscode强大的扩展extension功能，使得开发者可以在vscode中直接调用gcc、jlink、gdb等进行开发、调试。PlatformIO只是一个集成开发环境，其本身几乎不包括任何实质性功能，但是其集成了很多了例如编译器、调试器等，主要包括以下：</p><ul><li>vscode</li><li>gcc编译器，版本：arm-none-eabi-gcc （针对arm内核嵌入式设备的专属c语言编译器）</li><li>arm-none-eabi-gdb调试器</li><li>jlink 驱动</li><li>Scons构建工具、</li></ul><p>​    也就是说，PlatformIO就是一个类似于Keil, STMCudeIDE那样的工作环境，它本身不负责进行编译，上传，调试测试等，但是它封装了我们常见的arm-noeabi-系列工具，省去我们学习纷繁复杂的配置语法，统一成PlatformIO的配置语言，这样我们就可以通过写PlatformIO的配置语言来辅助构建我们的嵌入式程序。</p><h3 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h3><blockquote><p><a href="https://www.st.com/en/development-tools/stm32cubemx.html">STM32CubeMX - STM32Cube initialization code generator - STMicroelectronics</a></p></blockquote><p>​    STM32CubeMX 是用于 32 位 ARM Cortex STM32 微控制器的图形工具。它允许对 STM32 微控制器和微处理器进行非常简单的配置，生成初始化 C 代码，还可以通过一步一步的操作为 Arm Cortex-M 内核或 Arm Cortex-A core 生成部分 Linux 设备树。它是 STMCube 生态系统的一部分，且可以作为独立应用程序或作为 Eclipse 插件集成在开发环境（STM32CubeIDE）中。<br>​    它能做到的事情很简单了：那就是将我们配置嵌入式设备的流程从代码配置走向GUI配置，点点摁扭，就可以生成一系列初始化的代码辅助我们完成繁琐的初始化任务</p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><blockquote><p><a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a></p></blockquote><p>Visual Studio Code 是一个轻量级功能强大的源代码编辑器，支持语法高亮、代码自动补全（又称 IntelliSense）、代码重构、查看定义功能，并且内置了命令行工具和 Git 版本控制系统。适用于 Windows、macOS 和 Linux。它内置了对 JavaScript、TypeScript 和 Node.js 的支持，并为其他语言和运行时（如 C++、C#、Java、Python、PHP、Go、.NET）提供了丰富的扩展生态系统。为了不影响读者的沉浸式阅读学习，如需使用目录请在左侧使用即可。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>​    我们下面来以STM32F103ZET6为目标单片机，实现一个简单的点灯任务！来看看我们如何进行工程配置。</p><h3 id="使用STM32CubeMX生成PlatformIO可以支持的Makefile文件"><a href="#使用STM32CubeMX生成PlatformIO可以支持的Makefile文件" class="headerlink" title="使用STM32CubeMX生成PlatformIO可以支持的Makefile文件"></a>使用STM32CubeMX生成PlatformIO可以支持的Makefile文件</h3><p>​    我们的初始化代码是由STM32CubeMX生成的，这里我们完成这些配置：</p><blockquote><p>关于如何下载安装STM32CubeMX不是本文的重点，请看官另行百度</p></blockquote><p>点击画圈的地方选择目标嵌入式设备</p><p><img src="image-20240726185025439.png" alt="image-20240726185025439"></p><p>锁定目标板子（↓）</p><blockquote><p>这里我收藏了常用的板子，所以可以很快找到，没有的看官搜索板子的型号就好</p></blockquote><p><img src="image-20240726184849982.png" alt="image-20240726184849982"></p><p>点击目标板子的栏目，就看到我们熟悉的界面了。</p><h4 id="1-选择目标引脚并配置"><a href="#1-选择目标引脚并配置" class="headerlink" title="1. 选择目标引脚并配置"></a>1. 选择目标引脚并配置</h4><p>​    我们需要选择目标引脚然后完成相关的配置，笔者这里选择了我这块开发板上的PE5引脚来驱动连接上的单片机，引脚的配置需要结合硬件电路进行选择</p><p><img src="image-20240726185424554.png" alt="image-20240726185424554"></p><p>​    在这里，本人设置了：上拉输出，高速模式</p><p><img src="image-20240726185506603.png" alt="image-20240726185506603"></p><h4 id="2-配置时钟树"><a href="#2-配置时钟树" class="headerlink" title="2. 配置时钟树"></a>2. 配置时钟树</h4><p>​    我选择了使用外部晶振时钟，配置为72MHz</p><p><img src="image-20240726185620548.png" alt="image-20240726185620548"></p><p><img src="image-20240726185627328.png" alt="image-20240726185627328"></p><h4 id="3-关键！调试则需要：-选择调试器类型"><a href="#3-关键！调试则需要：-选择调试器类型" class="headerlink" title="3. [关键！调试则需要：]选择调试器类型"></a>3. <strong>[关键！调试则需要：]</strong>选择调试器类型</h4><p><img src="image-20240726185734704.png" alt="image-20240726185734704"></p><p>​    Serial Wire是笔者选择的，我的手头只有STLink可以使用，如果看官有的是JLink调试器，请根据</p><blockquote><p><a href="https://blog.csdn.net/2304_77832287/article/details/136578853">STM32-HAL库CubeMX中的SYS配置选项_cubmx不配置sys debug-CSDN博客</a></p></blockquote><p>​    做出相关的选择！这一步相当关键！</p><h4 id="4-选择对应的目标IDE配置代码与文件"><a href="#4-选择对应的目标IDE配置代码与文件" class="headerlink" title="4. 选择对应的目标IDE配置代码与文件"></a>4. 选择对应的目标IDE配置代码与文件</h4><p><img src="image-20240726190057720.png" alt="image-20240726190057720"></p><p>​    看官自行<strong>设置好项目名称</strong>和<strong>项目存储的文件夹</strong>，两者将会在后面的PIO配置中使用到！请高度关注！</p><blockquote><p>TIPS: 如果看官不想拷贝所有的库文件，可以在Code Generator那一栏中选择相应的配置：</p><p><img src="image-20240726190321267.png" alt="image-20240726190321267"></p></blockquote><p>下面我们生成代码</p><p><img src="image-20240726190344929.png" alt="image-20240726190344929"></p><p><img src="image-20240726190356053.png" alt="image-20240726190356053"></p><p>​    可以看到所有的必要底层库文件都得到了拷贝，下面我们转战VSCode + PIO</p><h3 id="使用PlatformIO搭建我们的STM32开发环境"><a href="#使用PlatformIO搭建我们的STM32开发环境" class="headerlink" title="使用PlatformIO搭建我们的STM32开发环境"></a>使用PlatformIO搭建我们的STM32开发环境</h3><p>​    打开VSCode，PlatformIO在Plugin Market里下载。</p><p><img src="image-20240726190608682.png" alt="image-20240726190608682"></p><p>​    看官先点击下载之，泡上一杯咖啡吧，下载很慢的！（笔者这里下载过了）安装结束之后，你的左侧工具栏会出现这个</p><p><img src="image-20240726190806690.png" alt="image-20240726190806690"></p><p>​    点击一下：</p><p><img src="image-20240726190833744.png" alt="image-20240726190833744"></p><p>​    这就是PlatformIO!我们下面可以将我们的STM32生成的代码跟PIO对接。点击新建工程：</p><p><img src="image-20240726191057265.png" alt="image-20240726191057265"></p><p>里面需要填写的项目我一个个说：</p><blockquote><ol><li>工程名称：跟CubeMx你填写的项目名称要完全一致</li><li>目标板子：跟CubeMx型号一致</li><li>框架：这个是说的是如何进行读取行为，我们使用的是CubeMX的生成代码，所以目标框架我们采用的是STM32Cube</li><li>位置Location:先把Default Location给删掉，我们需要选择在刚刚在CubeMx下选择的文件夹，可以看到我们在刚刚笔者选择在了<code>D:\MDK5 Project\CubeMx Trainingg\demo_</code>下，所有的代码都继续生成在了<code>D:\MDK5 Project\CubeMx Trainingg\demo_\$&#123;ProjectName&#125;\</code>下方，<strong>我们在PIO下的目录就选择到<code>D:\MDK5 Project\CubeMx Trainingg\demo_</code>这个位置</strong>，这是因为他也会生成<code>$&#123;ProjectName&#125;\...</code>文件夹，我们这样做是为了让PIO生成的文件和CubeMx的文件生成在用以项目根目录下，方便我们的书写和文件读取</li></ol></blockquote><p><img src="image-20240726191745589.png" alt="image-20240726191745589"></p><p>​    点击Finish到这里之后，第一次下载的朋友将会下载相关的工具链，笔者当时下载了长达小半个小时，请各位看官稍有耐心，可以出去散散步！之后等到工具链配置结束之后，生成工程就是一刹那的事情。</p><p>​    现在生成结束了！</p><p><img src="image-20240726194034496.png" alt="image-20240726194034496"></p><p>​    我们下面来看看platformio.ini文件。</p><pre class="line-numbers language-none"><code class="language-none">; PlatformIO Project Configuration File;;   Build options: build flags, source filter;   Upload options: custom upload port, speed and extra flags;   Library options: dependencies, extra library storages;   Advanced options: extra scripting;; Please visit documentation for the other options and examples; https:&#x2F;&#x2F;docs.platformio.org&#x2F;page&#x2F;projectconf.html[env:genericSTM32F103ZE]platform &#x3D; ststm32board &#x3D; genericSTM32F103ZEframework &#x3D; stm32cube<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这是PlatformIO为我们默认生成好的模板，但是仅靠这个完全没有办法编译我们的项目，我们需要自行修改。</p><p>​    经过笔者的简单探索，笔者整合出了如下的配置：</p><blockquote><p>使用笔者的配置</p></blockquote><pre class="line-numbers language-none"><code class="language-none">; PlatformIO Project Configuration File;;   Build options: build flags, source filter;   Upload options: custom upload port, speed and extra flags;   Library options: dependencies, extra library storages;   Advanced options: extra scripting;; Please visit documentation for the other options and examples; https:&#x2F;&#x2F;docs.platformio.org&#x2F;page&#x2F;projectconf.html; src_dir就是告知我们的项目的大源文件地址在何处，它隶属于platformio模块的匹配; https:&#x2F;&#x2F;docs.platformio.org&#x2F;en&#x2F;latest&#x2F;projectconf&#x2F;sections&#x2F;platformio&#x2F;options&#x2F;directory&#x2F;src_dir.html[platformio]src_dir &#x3D; .&#x2F;Core&#x2F;;目标板子: STM32F103ZE[env:genericSTM32F103ZE]platform &#x3D; ststm32board &#x3D; genericSTM32F103ZEframework &#x3D; stm32cube; -Idir是include文件目录, 这里随了GCC的语法; build_flag本质上就是给arm-noeabi-gcc加上了编译参数，直接添加的，所以直接随的是GCC的语法build_flags &#x3D;         -ICore&#x2F;Inc    ;选择链接文件，我们的STM32上电后要执行一段启动脚本board_build.ldscript &#x3D; .&#x2F;STM32F103ZETx_FLASH.ld; 下面是上传工具的配置; PlatformIO默认使用的上传协议就是stlink,默认的调试协议还是stlink, 这是笔者并没有写出的原因; 如果看官手头有的调试器是JLink的话，则需要显示的指定: [看官自行注释]; upload_protocol&#x3D;jlink; debug_tool&#x3D;jlink; 手头只有USB &lt; - &gt; TTL的话, 则是; upload_protocol&#x3D;serial; 值得注意的是: 一些板子是不支持某一些协议的，这跟PlatformIO使用到的开源库有关系，请前往; https:&#x2F;&#x2F;docs.platformio.org&#x2F;en&#x2F;latest&#x2F;boards&#x2F;index.html#boards; 搜索自己使用的板子查看支持的上传，调试协议<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    还有另一份是广为传播的一种配置：</p><pre class="line-numbers language-none"><code class="language-none">; PlatformIO Project Configuration File;;   Build options: build flags, source filter;   Upload options: custom upload port, speed and extra flags;   Library options: dependencies, extra library storages;   Advanced options: extra scripting;; Please visit documentation for the other options and examples; https:&#x2F;&#x2F;docs.platformio.org&#x2F;page&#x2F;projectconf.html; 在配置文件中分号开头为注释[platformio]; 将源代码的编译目录移到项目目录下，否则默认src下src_dir &#x3D; .&#x2F;[env:genericSTM32F103ZE]platform &#x3D; ststm32board &#x3D; genericSTM32F103ZE; framework &#x3D; stm32cube（不用framework了）; 编译配置-D是宏定义，-Idir是include文件目录,读者可按自己项目结构更改; 这里笔者锐评一下: 这种方式就是会十分繁琐！必须依次指定所有的包含目录!; 在已经存在支持的框架下，请优先使用platformIO已经支持的框架！build_flags &#x3D;           -D STM32F103xE; 预定义宏, 看官可以理解为在一切源文件的开头加上了#define STM32F103xE  -ICore&#x2F;Inc; 包含了源文件的路径  -IDrivers&#x2F;CMSIS&#x2F;Include  -IDrivers&#x2F;CMSIS&#x2F;Device&#x2F;ST&#x2F;STM32F1xx&#x2F;Include  -IDrivers&#x2F;STM32F1xx_HAL_Driver&#x2F;Inc  -IDrivers&#x2F;STM32F1xx_HAL_Driver&#x2F;Inc&#x2F;Legacy;选择编译文件的所在路径，这里包含了源文件路径，启动文件，驱动库和rtos路径。如果+&lt;*&gt;便是路径下的所以文件，-&lt;.git&#x2F;&gt;便是忽略.git路径下的文件build_src_filter &#x3D; +&lt;Core&#x2F;Src&gt; +&lt;startup_stm32f103xe.s&gt; +&lt;Drivers&#x2F;&gt; +&lt;Middlewares&#x2F;&gt;;选择链接文件board_build.ldscript &#x3D; .&#x2F;STM32F103ZETx_FLASH.ld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    下面我们直接点灯就好，在Core/Src/main.c下：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 笔者选择的是上拉模式,亮灯要拉低GPIO电平HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    我们下面编译运行，<strong>您既可以Ctrl + Shift + P输入PlatformIO:Build</strong>开始构建，也可以的点击VSCode下方工具栏上的：</p><p><img src="image-20240726201942633.png" alt="image-20240726201942633"></p><blockquote><p>从小房子的图标开始，依次是：</p><ul><li>PlatformIO主页面</li><li>构建</li><li>上传</li><li>清理</li><li>测试（单元测试）</li><li>串口监视器</li><li>终端</li><li>项目</li><li>上传的端口设置（默认不动就好）</li></ul></blockquote><p>​    余下的是笔者写其他语言的插件，请不予理会。</p><p>​    笔者下面演示的是构建工程，点击<code>√</code>号</p><pre class="line-numbers language-none"><code class="language-none">Processing genericSTM32F103ZE (platform: ststm32; board: genericSTM32F103ZE; framework: stm32cube)----------------------------------------------------------------------------------------------------------------------------------------------------------------Verbose mode can be enabled via &#96;-v, --verbose&#96; optionCONFIGURATION: https:&#x2F;&#x2F;docs.platformio.org&#x2F;page&#x2F;boards&#x2F;ststm32&#x2F;genericSTM32F103ZE.htmlPLATFORM: ST STM32 (17.4.0) &gt; STM32F103ZE (64k RAM. 512k Flash)HARDWARE: STM32F103ZET6 72MHz, 64KB RAM, 512KB FlashDEBUG: Current (blackmagic) External (blackmagic, cmsis-dap, jlink, stlink)PACKAGES: - framework-stm32cubef1 @ 1.8.4 - tool-ldscripts-ststm32 @ 0.2.0 - toolchain-gccarmnoneeabi @ 1.70201.0 (7.2.1)LDF: Library Dependency Finder -&gt; https:&#x2F;&#x2F;bit.ly&#x2F;configure-pio-ldfLDF Modes: Finder ~ chain, Compatibility ~ softFound 29 compatible librariesScanning dependencies...No dependenciesBuilding in release modeCompiling .pio\build\genericSTM32F103ZE\FrameworkHALDriver\Src\stm32f1xx_hal.o... Compiling .pio\build\genericSTM32F103ZE\FrameworkCMSISDevice\gcc\startup_stm32f103xe.oCompiling .pio\build\genericSTM32F103ZE\FrameworkCMSISDevice\system_stm32f1xx.oArchiving .pio\build\genericSTM32F103ZE\libFrameworkCMSISDevice.aIndexing .pio\build\genericSTM32F103ZE\libFrameworkCMSISDevice.aLinking .pio\build\genericSTM32F103ZE\firmware.elfChecking size .pio\build\genericSTM32F103ZE\firmware.elfAdvanced Memory Usage is available via &quot;PlatformIO Home &gt; Project Inspect&quot;RAM:   [          ]   0.1% (used 44 bytes from 65536 bytes)Flash: [          ]   0.5% (used 2724 bytes from 524288 bytes)Building .pio\build\genericSTM32F103ZE\firmware.bin&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; [SUCCESS] Took 4.93 seconds &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    出现<code>[SUCCESS]</code>字样，说明我们的项目构建顺利，否则，请依次查看自己的项目配置问题。常见的是重定义，请保证自己不要重复包含源文件导致符号重定义！</p><p>​    下面我们点击<code>-&gt;</code>上传项目到板子上！</p><p>​    请在上传之前，确保您已经连接好调试器（我的是STLink），同时板子已经上好电了！</p><pre class="line-numbers language-none"><code class="language-none">Processing genericSTM32F103ZE (platform: ststm32; board: genericSTM32F103ZE; framework: stm32cube)----------------------------------------------------------------------------------------------------------------------------------------------------------------Verbose mode can be enabled via &#96;-v, --verbose&#96; optionCONFIGURATION: https:&#x2F;&#x2F;docs.platformio.org&#x2F;page&#x2F;boards&#x2F;ststm32&#x2F;genericSTM32F103ZE.htmlPLATFORM: ST STM32 (17.4.0) &gt; STM32F103ZE (64k RAM. 512k Flash)HARDWARE: STM32F103ZET6 72MHz, 64KB RAM, 512KB FlashDEBUG: Current (blackmagic) External (blackmagic, cmsis-dap, jlink, stlink)PACKAGES: - framework-stm32cubef1 @ 1.8.4 - tool-dfuutil @ 1.11.0 - tool-dfuutil-arduino @ 1.11.0 - tool-ldscripts-ststm32 @ 0.2.0 - tool-openocd @ 3.1200.0 (12.0) - tool-stm32duino @ 1.0.2 - toolchain-gccarmnoneeabi @ 1.70201.0 (7.2.1)LDF: Library Dependency Finder -&gt; https:&#x2F;&#x2F;bit.ly&#x2F;configure-pio-ldfLDF Modes: Finder ~ chain, Compatibility ~ softFound 29 compatible librariesScanning dependencies...No dependenciesBuilding in release modeChecking size .pio\build\genericSTM32F103ZE\firmware.elfAdvanced Memory Usage is available via &quot;PlatformIO Home &gt; Project Inspect&quot;RAM:   [          ]   0.1% (used 44 bytes from 65536 bytes)Flash: [          ]   0.5% (used 2724 bytes from 524288 bytes)Configuring upload protocol...AVAILABLE: blackmagic, cmsis-dap, dfu, jlink, serial, stlinkCURRENT: upload_protocol &#x3D; stlinkUploading .pio\build\genericSTM32F103ZE\firmware.elfxPack Open On-Chip Debugger 0.12.0-01004-g9ea7f3d64-dirty (2023-01-30-15:04)Licensed under GNU GPL v2For bug reports, read        http:&#x2F;&#x2F;openocd.org&#x2F;doc&#x2F;doxygen&#x2F;bugs.htmldebug_level: 1hla_swd[stm32f1x.cpu] halted due to debug-request, current mode: Thread xPSR: 0x01000000 pc: 0x08000bf8 msp: 0x20010000** Programming Started **Warn : Adding extra erase range, 0x08000c90 .. 0x08000fff** Programming Finished **** Verify Started **** Verified OK **** Resetting Target **shutdown command invoked&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; [SUCCESS] Took 2.75 seconds &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="82c98b7c910a177f4abf722b5e108ac.jpg" alt="82c98b7c910a177f4abf722b5e108ac"></p><p>​    如愿，小灯亮起，到这里，我们的教程结束！</p><h2 id="一些在上传中可能出现的问题"><a href="#一些在上传中可能出现的问题" class="headerlink" title="一些在上传中可能出现的问题"></a>一些在上传中可能出现的问题</h2><ol><li>板子没上电↓</li></ol><p><img src="image-20240726193353117.png" alt="image-20240726193353117"></p><ol><li>STLink没插好！或者STLink异常，导致OpenOCD无法初始化，请检查端口</li></ol><p><img src="image-20240726193217124.png" alt="image-20240726193217124"></p><ol><li>使用USB转TTL接口上传程序出现的问题</li></ol><p><img src="image-20240726204118021.png" alt="image-20240726204118021"></p><p>​    感谢SourceForge大佬的解答，我随后马上意识到自己犯了一件很蠢的事情，我忘记改板子为bootloader烧录模式了，导致板子根本不接受usb烧录。</p><blockquote><p><a href="https://sourceforge.net/p/stm32flash/tickets/134/">stm32flash / Tickets / #134 STM32L462 “Failed to init device” problem (sourceforge.net)</a></p></blockquote><p>​    请各位看官参考自己的手册关于BOOT引脚的配置！</p><p><img src="image-20240726204321081.png" alt="image-20240726204321081"></p><p>​    所以，我需要改BOOT0引脚接到3.3V上去，上载好程序后，恢复BOOT引脚全部接地运行程序，果然：</p><pre class="line-numbers language-none"><code class="language-none">Processing genericSTM32F103ZE (platform: ststm32; board: genericSTM32F103ZE; framework: stm32cube)----------------------------------------------------------------------------------------------------------------------------------------------------------------Verbose mode can be enabled via &#96;-v, --verbose&#96; optionCONFIGURATION: https:&#x2F;&#x2F;docs.platformio.org&#x2F;page&#x2F;boards&#x2F;ststm32&#x2F;genericSTM32F103ZE.htmlPLATFORM: ST STM32 (17.4.0) &gt; STM32F103ZE (64k RAM. 512k Flash)HARDWARE: STM32F103ZET6 72MHz, 64KB RAM, 512KB FlashDEBUG: Current (blackmagic) External (blackmagic, cmsis-dap, jlink, stlink)PACKAGES: - framework-stm32cubef1 @ 1.8.4 - tool-dfuutil @ 1.11.0 - tool-dfuutil-arduino @ 1.11.0 - tool-ldscripts-ststm32 @ 0.2.0 - tool-openocd @ 3.1200.0 (12.0) - tool-stm32duino @ 1.0.2 - toolchain-gccarmnoneeabi @ 1.70201.0 (7.2.1)LDF: Library Dependency Finder -&gt; https:&#x2F;&#x2F;bit.ly&#x2F;configure-pio-ldfLDF Modes: Finder ~ chain, Compatibility ~ softFound 29 compatible librariesScanning dependencies...No dependenciesBuilding in release modeChecking size .pio\build\genericSTM32F103ZE\firmware.elfAdvanced Memory Usage is available via &quot;PlatformIO Home &gt; Project Inspect&quot;RAM:   [          ]   0.1% (used 44 bytes from 65536 bytes)Flash: [          ]   0.5% (used 2716 bytes from 524288 bytes)Configuring upload protocol...AVAILABLE: blackmagic, cmsis-dap, dfu, jlink, serial, stlinkCURRENT: upload_protocol &#x3D; serialLooking for upload port...Auto-detected: COM8Uploading .pio\build\genericSTM32F103ZE\firmware.binstm32flash 0.4http:&#x2F;&#x2F;stm32flash.googlecode.com&#x2F;Using Parser : Raw BINARYInterface serial_w32: 115200 8E1Version      : 0x22Option 1     : 0x00Option 2     : 0x00Device ID    : 0x0414 (High-density)- RAM        : 64KiB  (512b reserved by bootloader)- Flash      : 512KiB (sector size: 2x2048)- Option RAM : 16b- System RAM : 2KiBWrite to memoryErasing memoryWrote address 0x08000100 (7.98%) Wrote address 0x08000200 (15.96%) ...Wrote address 0x08000b00 (87.78%) Wrote address 0x08000c00 (95.76%) Wrote address 0x08000c88 (100.00%) Done.Starting execution at address 0x08000000... done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>​    这里请只有串口烧录的朋友止步了。</p><p>​    调试极其容易，我们只需要按照经典的点击：</p><p><img src="image-20240726205600649.png" alt="image-20240726205600649"></p><p>​    确保自己的板子和调试器都上好电之后，就可以愉快调试了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
            <tag> PlatformIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QEMU + Vscode + Arm Arch‘s Linux调试小记</title>
      <link href="/2024/07/27/QEMU-Vscode-Arm-Arch%E2%80%98s-Linux%E8%B0%83%E8%AF%95%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/07/27/QEMU-Vscode-Arm-Arch%E2%80%98s-Linux%E8%B0%83%E8%AF%95%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="QEMU-Vscode-Arm-Arch‘s-Linux调试小记"><a href="#QEMU-Vscode-Arm-Arch‘s-Linux调试小记" class="headerlink" title="QEMU + Vscode + Arm Arch‘s Linux调试小记"></a>QEMU + Vscode + Arm Arch‘s Linux调试小记</h1><p>前几天看到了一篇讲授如何调试ARM <a href="https://so.csdn.net/so/search?q=Linux内核&amp;spm=1001.2101.3001.7020">Linux内核</a>的文章，这里现在记录一下调试ARM Linux内核的办法</p><h3 id="下载QEMU"><a href="#下载QEMU" class="headerlink" title="下载QEMU"></a>下载<a href="https://so.csdn.net/so/search?q=QEMU&amp;spm=1001.2101.3001.7020">QEMU</a></h3><p>对于Arch Linux用户而言，没有必要自己编译，直接上AUR源下载就行。我自己有打算研究和调试多个架构，所以我自己下载了：</p><pre class="line-numbers language-none"><code class="language-none">yay -S qemu-full<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于什么是QEMU：<a href="https://wiki.archlinux.org/title/QEMU">QEMU - ArchWiki</a></p><p>AUR源：<a href="https://archlinux.org/packages/extra/x86_64/qemu-full/">Arch Linux - qemu-full 9.0.1-1 (x86_64)</a></p><p>如果只是想要调试ARM64位linux，需要下载的是aarch版本的。</p><p>下载完成之后，可以看看自己是否可以正常启动：</p><pre class="line-numbers language-none"><code class="language-none">qemu-system-aarch64 --versionQEMU emulator version 9.0.1Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="下载aarch64-gcc"><a href="#下载aarch64-gcc" class="headerlink" title="下载aarch64-gcc"></a>下载aarch64-gcc</h3><pre class="line-numbers language-none"><code class="language-none">yay -S aarch64-linux-gnu-gcc aarch64-linux-gnu-gcc  -v Using built-in specs.COLLECT_GCC&#x3D;aarch64-linux-gnu-gccCOLLECT_LTO_WRAPPER&#x3D;&#x2F;usr&#x2F;lib&#x2F;gcc&#x2F;aarch64-linux-gnu&#x2F;14.1.0&#x2F;lto-wrapperTarget: aarch64-linux-gnuConfigured with: &#x2F;build&#x2F;aarch64-linux-gnu-gcc&#x2F;src&#x2F;gcc-14.1.0&#x2F;configure --prefix&#x3D;&#x2F;usr --program-prefix&#x3D;aarch64-linux-gnu- --with-local-prefix&#x3D;&#x2F;usr&#x2F;aarch64-linux-gnu --with-sysroot&#x3D;&#x2F;usr&#x2F;aarch64-linux-gnu --with-build-sysroot&#x3D;&#x2F;usr&#x2F;aarch64-linux-gnu --with-native-system-header-dir&#x3D;&#x2F;include --libdir&#x3D;&#x2F;usr&#x2F;lib --libexecdir&#x3D;&#x2F;usr&#x2F;lib --target&#x3D;aarch64-linux-gnu --host&#x3D;x86_64-pc-linux-gnu --build&#x3D;x86_64-pc-linux-gnu --disable-nls --enable-default-pie --enable-languages&#x3D;c,c++,fortran --enable-shared --enable-threads&#x3D;posix --with-system-zlib --with-isl --enable-__cxa_atexit --disable-libunwind-exceptions --enable-clocale&#x3D;gnu --disable-libstdcxx-pch --disable-libssp --enable-gnu-unique-object --enable-linker-build-id --enable-lto --enable-plugin --enable-install-libiberty --with-linker-hash-style&#x3D;gnu --enable-gnu-indirect-function --disable-multilib --disable-werror --enable-checking&#x3D;releaseThread model: posixSupported LTO compression algorithms: zlib zstdgcc version 14.1.0 (GCC) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下载BusyBox"><a href="#下载BusyBox" class="headerlink" title="下载BusyBox"></a>下载<a href="https://so.csdn.net/so/search?q=BusyBox&amp;spm=1001.2101.3001.7020">BusyBox</a></h3><p>这个比较遗憾，因为我们是调试ARM架构的，所以文件系统的架构基础必须是ARM，否则文件系统无法识别，为此我们不得不干脏活：手动编译ARM版本的BusyBox</p><blockquote><p>Downloads: <a href="https://www.busybox.net/downloads/">Index of /downloads</a></p><p>busybox-1.36.1.tar.bz2: <a href="https://www.busybox.net/downloads/busybox-1.36.1.tar.bz2">https://www.busybox.net/downloads/busybox-1.36.1.tar.bz2</a></p></blockquote><p>下一步就是配置，好玩的是：我们需要更改一下menuconfig的文件：</p><blockquote><p>你可以先尝试make menuconfig，不过马上就会给你抛错：说找不到libncurse5，其实不然，改一下shell脚本就行：</p><p><a href="https://aur.archlinux.org/cgit/aur.git/tree/esp8266-rtos-sdk-aur-ncurses-fix.patch?h=esp8266-rtos-sdk">esp8266-rtos-sdk-aur-ncurses-fix.patch - aur.git - AUR Package Repositories</a></p><p>也就是把main改成int main就好</p></blockquote><p>下一步就是：</p><pre class="line-numbers language-none"><code class="language-none">make menuconfigSettings ---&gt; [*] Build static binary (no shared libs) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>指定编译架构和参数</p><pre class="line-numbers language-none"><code class="language-none">export ARCH&#x3D;arm64export CROSS_COMPILE&#x3D;aarch64-linux-gnu-make &amp;&amp; make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们所有的文件就会出现在源代码根目录下的_install里，下面比较麻烦——为了制作操作系统的可用文件系统，必须多加点</p><pre class="line-numbers language-none"><code class="language-none">cd _installmkdir etc dev lib➜  lsbin&#x2F;  dev&#x2F;  etc&#x2F;  lib&#x2F;  linuxrc@  sbin&#x2F;  usr&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>下面依次创建文件：</p><p>在etc目录下：</p><blockquote><p>profile</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;shexport HOSTNAME&#x3D;Charliechenexport USER&#x3D;rootexport HOME&#x3D;&#x2F;homeexport PS1&#x3D;&quot;[$USER@$HOSTNAME \W]\# &quot;PATH&#x3D;&#x2F;bin:&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;sbinLD_LIBRARY_PATH&#x3D;&#x2F;lib:&#x2F;usr&#x2F;lib:$LD_LIBRARY_PATHexport PATH LD_LIBRARY_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>inittab</p></blockquote><pre class="line-numbers language-none"><code class="language-none">::sysinit:&#x2F;etc&#x2F;init.d&#x2F;rcS::respawn:-&#x2F;bin&#x2F;sh::askfirst:-&#x2F;bin&#x2F;sh::ctrlaltdel:&#x2F;bin&#x2F;umount -a -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>fstab</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#device  mount-point    type     options   dump   fsck orderproc &#x2F;proc proc defaults 0 0tmpfs &#x2F;tmp tmpfs defaults 0 0sysfs &#x2F;sys sysfs defaults 0 0tmpfs &#x2F;dev tmpfs defaults 0 0debugfs &#x2F;sys&#x2F;kernel&#x2F;debug debugfs defaults 0 0kmod_mount &#x2F;mnt 9p trans&#x3D;virtio 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建一个init.d文件夹：</p><p>里面放入文件</p><blockquote><p>rcS</p></blockquote><pre class="line-numbers language-none"><code class="language-none">mkdir -p &#x2F;sysmkdir -p &#x2F;tmpmkdir -p &#x2F;procmkdir -p &#x2F;mnt&#x2F;bin&#x2F;mount -amkdir -p &#x2F;dev&#x2F;ptsmount -t devpts devpts &#x2F;dev&#x2F;ptsecho &#x2F;sbin&#x2F;mdev &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;hotplugmdev -s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改一下权限：</p><pre class="line-numbers language-none"><code class="language-none">chmod 777 rcS<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>busybox 作为linuxrc启动后， 会读取/etc/profile, 这里面设置了一些环境变量和shell的属性</li><li>根据/etc/fstab提供的挂载信息， 进行文件系统的挂载</li><li>busybox 会从 /etc/inittab中读取sysinit并执行， 这里sysinit指向了/etc/init.d/rcS</li><li>/etc/init.d/rcS 中 ，mdev -s 这条命令很重要， 它会扫描/sys目录，查找字符设备和块设备，并在/dev下mknod</li></ol><p>我们继续：在dev目录下创建console文件</p><pre class="line-numbers language-none"><code class="language-none">cd _install&#x2F;devsudo mknod console c 5 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>拷贝aarch目录下的lib动态文件到lib目录，让动态运行文件可以执行：</p><pre class="line-numbers language-none"><code class="language-none">cd _install&#x2F;libcp &#x2F;usr&#x2F;aarch64-linux-gnu&#x2F;lib&#x2F;*.so*  -a .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="编译linux-6-9-5的内核"><a href="#编译linux-6-9-5的内核" class="headerlink" title="编译linux 6.9.5的内核"></a>编译linux 6.9.5的内核</h3><pre class="line-numbers language-none"><code class="language-none">make defconfig ARCH&#x3D;arm64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改.config的这些配置：</p><pre class="line-numbers language-none"><code class="language-none">CONFIG_DEBUG_INFO&#x3D;y # 更多的调试信息CONFIG_INITRAMFS_SOURCE&#x3D;&quot;.&#x2F;root&quot; # 文件系统在哪？CONFIG_INITRAMFS_ROOT_UID&#x3D;0CONFIG_INITRAMFS_ROOT_GID&#x3D;0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意，上面的信息务必是：存在则修改，不存在添加！</p><p>在Linux源码目录下添加一个root文件夹，其实这对应的是CONFIG_INITRAMFS_SOURCE的位置：</p><pre class="line-numbers language-none"><code class="language-none">mkdir rootsudo cp -r path&#x2F;to&#x2F;your&#x2F;busybox_source_code&#x2F;_install .&#x2F;rootmake ARCH&#x3D;arm64 Image -j8  CROSS_COMPILE&#x3D;aarch64-linux-gnu-<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>泡杯茶老铁！</p><h3 id="启动！"><a href="#启动！" class="headerlink" title="启动！"></a>启动！</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;usr&#x2F;local&#x2F;bin&#x2F;qemu-system-aarch64 -m 512M # 内存为512M-smp 4 # 4核-cpu cortex-a57 # cpu 为cortex-a57-machine virt -kernel arch&#x2F;arm64&#x2F;boot&#x2F;Image #  kernel镜像文件-append &quot;rdinit&#x3D;&#x2F;linuxrc nokaslr console&#x3D;ttyAMA0 loglevel&#x3D;8&quot; # 传给kernel 的cmdline参数。其中rdinit指定了init进程；nokaslr 禁止内核起始地址随机化，这个很重要， 否则GDB调试可能有问题；console&#x3D;ttyAMA0指定了串口，没有这一步就看不到linux的输出-nographic # 禁止图形输出-s # 监听gdb端口， gdb程序可以通过1234这个端口连上来。qemu-system-aarch64 -m 512M -smp 4 -cpu cortex-a57 -machine virt -kernel arch&#x2F;arm64&#x2F;boot&#x2F;Image -append &quot;rdinit&#x3D;&#x2F;linuxrc nokaslr console&#x3D;ttyAMA0 loglevel&#x3D;8&quot; -nographic -s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动起来！</p><p><img src="image-20240727170538077.png" alt="image-20240727170538077"></p><p>成功运行!</p><h3 id="链接到vscode进行远程调试"><a href="#链接到vscode进行远程调试" class="headerlink" title="链接到vscode进行远程调试"></a>链接到vscode进行远程调试</h3><p>我们在Linux源代码根目录下code .</p><p>非上位机架构需要使用gdb-multiarch来调试!</p><pre class="line-numbers language-none"><code class="language-none">yay -S gdb-multiarch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在.vscode文件处添加launch.json文件：</p><pre class="line-numbers language-none"><code class="language-none">➜  cat .vscode&#x2F;launch.json &#123;    &#x2F;&#x2F; 使用 IntelliSense 了解相关属性。     &#x2F;&#x2F; 悬停以查看现有属性的描述。    &#x2F;&#x2F; 欲了解更多信息，请访问: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;kernel debug&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;vmlinux&quot;,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;miDebuggerPath&quot;:&quot;&#x2F;usr&#x2F;bin&#x2F;gdb-multiarch&quot;,            &quot;miDebuggerServerAddress&quot;: &quot;localhost:1234&quot;        &#125;    ]&#125;⏎<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下一步可能出错的是——没有对应版本的py，这个自信寻找aur源，我当时缺少的是python311，所以在aur源搜索python+版本号就可以出来，举个例子少python3,7搜python37就OK！</p><p>之后我们就可以顺利的启动起来了：</p><p><img src="image-20240727170557053.png" alt="image-20240727170557053"></p><p>下一步就是——打个断点试试看：我打在了kernel/fork.c的copy_mm函数！相信大家熟悉linux内核开发的都知道这个是什么（喜）</p><p><img src="image-20240727170606739.png" alt="image-20240727170606739"></p><p>打好断点，输入ls并且回车，就可以看到断点生效！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Coding:小写一个debugfs</title>
      <link href="/2024/07/27/Linux-Coding-%E5%B0%8F%E5%86%99%E4%B8%80%E4%B8%AAdebugfs/"/>
      <url>/2024/07/27/Linux-Coding-%E5%B0%8F%E5%86%99%E4%B8%80%E4%B8%AAdebugfs/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Coding-小写一个debugfs"><a href="#Linux-Coding-小写一个debugfs" class="headerlink" title="Linux Coding:小写一个debugfs"></a>Linux Coding:小写一个debugfs</h1><p>上一次整活还是在上一个月，写了一个简单的module并且熟悉了module的<a href="https://so.csdn.net/so/search?q=挂载&amp;spm=1001.2101.3001.7020">挂载</a>查看和卸载。这一次我们自然玩一个大的，就是利用linux的debugfs API写一个调试文件系统。</p><p>事实上，底层的<a href="https://so.csdn.net/so/search?q=API&amp;spm=1001.2101.3001.7020">API</a>全写好了，我们就是简单的调调API就成的事情！</p><h3 id="事先检查"><a href="#事先检查" class="headerlink" title="事先检查"></a>事先检查</h3><p>第一步是检查我们当前的内核是否支持debugfs调试：</p><pre class="line-numbers language-none"><code class="language-none">zcat &#x2F;proc&#x2F;config.gz | grep DEBUG_FS# CONFIG_XEN_DEBUG_FS is not setCONFIG_BLK_DEBUG_FS&#x3D;yCONFIG_BLK_DEBUG_FS_ZONED&#x3D;y# CONFIG_SCSI_SNIC_DEBUG_FS is not set# CONFIG_SCSI_LPFC_DEBUG_FS is not set# CONFIG_USB_GADGET_DEBUG_FS is not set# CONFIG_OCFS2_DEBUG_FS is not setCONFIG_DEBUG_FS&#x3D;yCONFIG_DEBUG_FS_ALLOW_ALL&#x3D;y# CONFIG_DEBUG_FS_DISALLOW_MOUNT is not set# CONFIG_DEBUG_FS_ALLOW_NONE is not set<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我们是要查看的是：<code>CONFIG_DEBUG_FS=y</code>，在这件事情上，如果是n，说明当前内核是不支持调试文件系统的，这就要求我们另外编译内核（打开这个开关），安装并进入内核才行。这里不再赘述如何自定义内核了。</p><h3 id="开干"><a href="#开干" class="headerlink" title="开干"></a>开干</h3><p>我们的文件系统有自己的一套fops，这里，也不是意外的。和我们对文件系统自身的认知，我们知道文件系统实际上就是提供一种对目标设备一套被抽象出来的访问读写等若干操作的句柄。所以我们所需要做的就是自己实现这一套句柄。显然我们需要实现的有打开文件 ，读文件以及写文件，这是最基本的！</p><p>我们的文件系统将会以模块的方式动态的加载到内核。所以这就要求我们需要先掌握学习如何编写模块的知识，这个在我之前的博客里有所提到。<a href="https://blog.csdn.net/charlie114514191/article/details/139374482?spm=1001.2014.3001.5502">关于如何在Arch Linux上编写自己的第一个module_archlinux modules-CSDN博客</a></p><p>各位看官之前并没有了解到这方面的知识，可以阅读我上面所写的博客等掌握这个知识之后，再进行下一步的实践。</p><p>现在，我们沿用写模块的Makefile:</p><pre class="line-numbers language-none"><code class="language-none">obj-m:&#x3D; charlie.opwd:&#x3D; $(shell pwd)ker-ver:&#x3D; $(shell uname -r)KDIR:&#x3D; &#x2F;lib&#x2F;modules&#x2F;$(ker-ver)&#x2F;build# 下面这一行是用来调试的# ccflags-y +&#x3D; -DDEBUG -g -ggdb -gdwarf-4 -Og \                -Wall -fno-omit-frame-pointer -fvar-tracking-assignmentsall:    make -C $(KDIR) M&#x3D;$(pwd) modules # 先调整一下目录，用人家的Makefileclean:    rm -rf *.o .* .cmd *.ko *.mod.c .tmp_versions *.order *.symvers *.mod写代码！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="撸代码"><a href="#撸代码" class="headerlink" title="撸代码"></a>撸代码</h3><p>我们首先需要引入写模块和调试文件系统的基本头文件。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;linux&#x2F;debugfs.h&gt;#include &lt;linux&#x2F;module.h&gt;#include &lt;linux&#x2F;fs.h&gt;#include &lt;linux&#x2F;uaccess.h&gt;#include &lt;linux&#x2F;errno.h&gt;#include &lt;linux&#x2F;types.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后完成读写，打开等基本操作。</p><pre class="line-numbers language-none"><code class="language-none">static int charlie_fs_open(struct inode* inode, struct file* pfile)&#123;&#x2F;&#x2F; 函数是打开某一个文件，准备进行读或者写。    printk(&quot;Charlie_filesystem_open\n&quot;);    pfile-&gt;private_data &#x3D; inode-&gt;i_private;    return 0;&#125;static ssize_t charlie_fs_read(struct file* pFile, char __user *buf, size_t cnt, loff_t* offp)&#123;&#x2F;&#x2F; 函数完成的任务是对传入进来的内存块进行存入buf里。    int retval &#x3D; 0;    if((*offp + cnt) &gt; 512)        cnt &#x3D; 512 - *offp;&#x2F;&#x2F; printk函数主要是向控制台打印一些控制信息，这个信息需要通过这条指令进行查看: sudo dmesg    printk(&quot;Received read request! count:%ld, offset:%lld\n&quot;, cnt, *offp);    if(copy_to_user(buf, charlie_buf + *offp, cnt))&#123;        &#x2F;&#x2F; 警告！        pr_warn(&quot;Oh no, failed to copy to user! count is %ld\n&quot;, cnt);        retval &#x3D; -EFAULT;        goto out;    &#125;    *offp +&#x3D; cnt;    retval &#x3D; cnt;out:    return retval; &#125;static ssize_t charlie_fs_write(struct file* pFile, const char __user *buf, size_t cnt, loff_t* offp)&#123;&#x2F;&#x2F; 函数完成的任务是向文件块进行写入。    int retval;    pr_info(&quot;Write request is here: count: %ld, offset:%lld\n&quot;, cnt, *offp);    if(*offp &gt; 512)        return 0;    if((*offp + cnt) &gt; 512)        cnt &#x3D; 512 - *offp;    if(copy_from_user(charlie_buf + *offp, (const void*)buf, cnt))&#123;        pr_warn(&quot;Oh no, failed to copy from user! count is %ld\n&quot;, cnt);        retval &#x3D; -EFAULT;        goto out;    &#125;    *offp +&#x3D; cnt;    retval &#x3D; cnt;out:    return retval; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于这里的几个所用到的函数都是什么意思，各位看官可自行百度更加详细的说明！</p><p>我们的文件系统是通过模块进行载入和卸载的，这就意味着我们仍然需要写初始化函数和析构函数。我们所做的就是要在初始化的时候完成对文件系统处理函数的注册。即在卸载文件系统的时候，移除我们在初始化时进行注册的相关函数。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 句柄struct file_operations charlie_fs_fops &#x3D; &#123;    .owner &#x3D; THIS_MODULE,    .read &#x3D; charlie_fs_read,    .write &#x3D; charlie_fs_write,    .open &#x3D; charlie_fs_open&#125;;&#x2F;&#x2F; 模块的初始化static int __init charlie_debug_fs_init(void)&#123;    pr_info(&quot;The module is initing...&quot;);    charlie_dir &#x3D; debugfs_create_dir(&quot;Charliedir&quot;, NULL);    if(!charlie_dir)&#123;        pr_crit(&quot;Failing shit! can not create any dir at all!&quot;);        goto failed;    &#125;    static struct dentry* sub_charlie_dir;    sub_charlie_dir &#x3D;  debugfs_create_dir(&quot;CharlieSubDir&quot;, charlie_dir);        if(!sub_charlie_dir)&#123;        pr_crit(&quot;Failing shit! can not create any sub dir at all!&quot;);        goto failed;    &#125;    struct dentry* filent &#x3D; debugfs_create_file(&quot;Charlie&quot;, 0644, sub_charlie_dir, NULL, &amp;charlie_fs_fops);    if(!filent)&#123;        pr_err(&quot;Can not create file!&quot;);        goto failed;    &#125;    pr_info(&quot;Init finish!&quot;);    return 0;failed:    return -ENOENT;&#125;&#x2F;&#x2F; 模块的析构函数static void __exit charlie_debug_fs_exit(void)&#123;    pr_info(&quot;Safe quit! begin&quot;);    debugfs_remove_recursive(charlie_dir);    pr_info(&quot;Safe quit! end&quot;);&#125;module_init(charlie_debug_fs_init);module_exit(charlie_debug_fs_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Charliechen&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里我们保存，然后make一下</p><pre class="line-numbers language-none"><code class="language-none">make -C &#x2F;lib&#x2F;modules&#x2F;6.9.7-arch1-1&#x2F;build M&#x3D;&#x2F;home&#x2F;Charliechen&#x2F;Works&#x2F;opearte_system&#x2F;module&#x2F;test2 modulesmake[1]: Entering directory &#39;&#x2F;usr&#x2F;lib&#x2F;modules&#x2F;6.9.7-arch1-1&#x2F;build&#39;  CC [M]  &#x2F;home&#x2F;Charliechen&#x2F;Works&#x2F;opearte_system&#x2F;module&#x2F;test2&#x2F;charlie.o  MODPOST &#x2F;home&#x2F;Charliechen&#x2F;Works&#x2F;opearte_system&#x2F;module&#x2F;test2&#x2F;Module.symvers  CC [M]  &#x2F;home&#x2F;Charliechen&#x2F;Works&#x2F;opearte_system&#x2F;module&#x2F;test2&#x2F;charlie.mod.o  LD [M]  &#x2F;home&#x2F;Charliechen&#x2F;Works&#x2F;opearte_system&#x2F;module&#x2F;test2&#x2F;charlie.ko  BTF [M] &#x2F;home&#x2F;Charliechen&#x2F;Works&#x2F;opearte_system&#x2F;module&#x2F;test2&#x2F;charlie.komake[1]: Leaving directory &#39;&#x2F;usr&#x2F;lib&#x2F;modules&#x2F;6.9.7-arch1-1&#x2F;build&#39;➜  sudo insmod charlie.ko &amp;&amp; lsmod | grep charlie[sudo] password for Charliechen: charlie                16384  0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到我们的模块已经被正确的挂载！下一步，则是测试我们写的一系列功能。</p><pre class="line-numbers language-none"><code class="language-none">➜  sudo ls &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F; | grep CharliedirCharliedir➜  sudo ls &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;CharliedirCharlieSubDir➜  sudo ls &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;Charliedir&#x2F;CharlieSubDirCharlie➜  suPassword: [root@ArchLinux test2]# lscharlie.c  charlie.ko  charlie.mod  charlie.mod.c  charlie.mod.o  charlie.o  Makefile  modules.order  Module.symvers[root@ArchLinux test2]# sudo insmod charlie.ko &amp;&amp; lsmod | grep charliecharlie                16384  0[root@ArchLinux test2]# echo 114514 &gt; &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;Charliedir&#x2F;CharlieSubDir&#x2F;Charlie[root@ArchLinux test2]# dmesg | tail -4[18109.769088] The module is initing...[18109.769097] Init finish![18117.722104] Charlie_filesystem_open[18117.722177] Write request is here: count: 7, offset:0[root@ArchLinux test2]# cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;Charliedir&#x2F;CharlieSubDir&#x2F;Charlie 114514[root@ArchLinux test2]# dmesg | tail -7[18109.769088] The module is initing...[18109.769097] Init finish![18117.722104] Charlie_filesystem_open[18117.722177] Write request is here: count: 7, offset:0[18147.692623] Charlie_filesystem_open[18147.692645] Received read request! count:512, offset:0[18147.692666] Received read request! count:0, offset:512[root@ArchLinux test2]# rmmod charlie.ko[root@ArchLinux test2]# dmesg | tail -8[18109.769088] The module is initing...[18109.769097] Init finish![18117.722104] Charlie_filesystem_open[18117.722177] Write request is here: count: 7, offset:0[18147.692623] Charlie_filesystem_open[18147.692645] Received read request! count:512, offset:0[18147.692666] Received read request! count:0, offset:512[18165.395570] Safe quit! begin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于如何在Arch Linux上编写自己的第一个module</title>
      <link href="/2024/07/27/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%9C%A8Arch-Linux%E4%B8%8A%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAmodule/"/>
      <url>/2024/07/27/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%9C%A8Arch-Linux%E4%B8%8A%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAmodule/</url>
      
        <content type="html"><![CDATA[<h1 id="关于如何在Arch-Linux上编写自己的第一个module"><a href="#关于如何在Arch-Linux上编写自己的第一个module" class="headerlink" title="关于如何在Arch Linux上编写自己的第一个module"></a>关于如何在Arch Linux上编写自己的第一个module</h1><p>​    前一段时间一直想深入学习编写一个module插入到自己的内核当中，但是网上的资料基本上全都针对的<a href="https://so.csdn.net/so/search?q=Ubuntu&amp;spm=1001.2101.3001.7020">Ubuntu</a>和Debian等流行的Linux发行版，这里打算简单的记录一波博客。</p><h3 id="啥是Module-着急可不看"><a href="#啥是Module-着急可不看" class="headerlink" title="啥是Module?(着急可不看)"></a>啥是Module?(着急可不看)</h3><p>​    众所周知：现代宏内核架构的操作系统都会借鉴微内核当中比较有价值的设计思想，这里的modules正是“模块”的意思，模块模块，可载可拆。他的加载和卸载是动态的，我们并不需要重新编译内核，只需要使用insmod和rmmod指令，就可以加载或者卸载自己的module。</p><p>​    模块的文件后缀是.ko文件，也是我们编程到最后生成的目标文件，挂载与卸载的就是.ko文件。（熟悉Linux内核编程的同志可以一眼认出这是kernel object的缩写）</p><h3 id="正题：如何编写自己的kernel-module"><a href="#正题：如何编写自己的kernel-module" class="headerlink" title="正题：如何编写自己的kernel module"></a>正题：如何编写自己的kernel module</h3><p>​        模块的编写方式同一般的写法有些区别，作为对比，我们给出一个例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 我们编写基础的模块需要这三位兄第</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/moduleparam.h></span></span> <span class="token comment">// 模块谁写的？</span><span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"Charliechen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 模块的认证签名协议是？</span><span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 下面开始是程序的正文。有同志会好奇干嘛是static呢？原因很简单：</span><span class="token comment">// 模块的加载是独立的，作为下面即将使用的加载模块和卸载模块的函数，我们只会在</span><span class="token comment">// 自己的文件中使用，因此！加上static，告知gcc不需要跑去找声明</span><span class="token keyword">static</span> <span class="token keyword">int</span> prt_times <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">Charliechen_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prt_times<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"SUP, DUDE!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">Charliechen_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"GOODBYE_BOY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token function">module_init</span><span class="token punctuation">(</span>Charliechen_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">module_exit</span><span class="token punctuation">(</span>Charliechen_exit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    你会很懵，这个结构跟我们所熟悉的模块编程完全不一样！多了很多陌生的东西。如果你现在只是想快速的跳到结果，可以前往下一个小节了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">Charliechen_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prt_times<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"SUP, DUDE!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// ... omitted ...</span> <span class="token function">module_init</span><span class="token punctuation">(</span>Charliechen_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    首先是模块的初始化函数，当我们的模块加载程序运行的时候，他会调用我们被标注以：module_init包裹的函数，这个函数将会作为我们对模块的初始化的函数，借用一下面对对象编程的术语，那就是构造函数！</p><p>​    很简单这个函数做的事情：无非就是向内核打印”Sup, Dude”10次，很简单是吧。那么，这个<strong>init做什么事情呢？学过内核编程的都知道这是标记符号：在这里，gcc扫描到</strong>init这个东西，就会把这个函数放到特别安排的区域，同理，__exit也是！好了，我们最后使用module_init或者是module_exit函数（咱们是动态加载）声明我们的“构造”函数和“析构函数”就好。</p><h3 id="撸Makefile"><a href="#撸Makefile" class="headerlink" title="撸Makefile"></a>撸Makefile</h3><p>​    是的，我们生成模块要使用Makefile去写，先给出Makefile</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># 最后生成的模块名称的模块重定位文件</span><span class="token comment">#（实际上就是说自己.ko的前面是啥,这里需要跟源文件名称一致）</span>obj-m<span class="token operator">:=</span> charlie.o pwd<span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> pwd<span class="token punctuation">)</span> <span class="token comment"># 当前目录</span>KDIR<span class="token operator">:=</span> /lib/modules/<span class="token punctuation">(</span><span class="token variable">$shell</span> uname -r<span class="token punctuation">)</span>/build <span class="token comment"># 我们的Kernel modules依赖文件在哪里</span> <span class="token comment"># make执行的：</span><span class="token target symbol">all</span><span class="token punctuation">:</span>        make -C <span class="token variable">$</span><span class="token punctuation">(</span>KDIR<span class="token punctuation">)</span> M<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>pwd<span class="token punctuation">)</span> modules <span class="token comment"># make clean执行的</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>        rm -rf *.o .* .cmd *.ko *.mod.c .tmp_versions *.order *.symvers *.mod<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    有同志马上就会发现自己没有/lib/modules/(uname -r)/build这个文件夹，这个需要单独下载：yay -Ss linux-headers，确认包的名称跟自己的linux-header一致后，下载下来，你就会发现多了一个build文件夹，里面就是我们开发modules的SDK了！</p><p>​    我们下面make</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">➜  <span class="token function">make</span><span class="token function">make</span> <span class="token parameter variable">-C</span> /lib/modules/6.9.3-arch1-1//build <span class="token assign-left variable">M</span><span class="token operator">=</span>/home/Charliechen/Works/opearte_system/module modulesmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: 进入目录“/usr/lib/modules/6.9.3-arch1-1/build”  CC <span class="token punctuation">[</span>M<span class="token punctuation">]</span>  /home/Charliechen/Works/opearte_system/module/charlie.o  MODPOST /home/Charliechen/Works/opearte_system/module/Module.symvers  CC <span class="token punctuation">[</span>M<span class="token punctuation">]</span>  /home/Charliechen/Works/opearte_system/module/charlie.mod.o  LD <span class="token punctuation">[</span>M<span class="token punctuation">]</span>  /home/Charliechen/Works/opearte_system/module/charlie.ko  BTF <span class="token punctuation">[</span>M<span class="token punctuation">]</span> /home/Charliechen/Works/opearte_system/module/charlie.ko<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    好了，我们拿到了自己的module了，下面讲解如何挂载，查看信息，卸载。</p><h3 id="挂载我们的module"><a href="#挂载我们的module" class="headerlink" title="挂载我们的module"></a>挂载我们的module</h3><p>​    挂载模块很简单：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> insmod 模块名.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    我先前踩过这个坑：</p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol"><span class="token keyword">ERROR</span><span class="token punctuation">:</span> Can <span class="token operator">not</span> load xxx<span class="token punctuation">.</span>ko<span class="token punctuation">:</span> <span class="token keyword">Invalid</span> Format<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    排查一下，会告知你很具体的原因，办法是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">dmesg</span> <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    最常见的原因是模块的系统版本签名和自己将要挂载的系统的版本不对等，arch兄弟们可以reboot(大概率是自己update系统之后不reboot导致自己使用的SDK版本和系统不对等)，重启后保证自己的uname -r跟自己的模块系统版本签名一致就行</p><p>​    正常的现象是：啥也没有</p><p><img src="image-20240727165342067.png" alt="image-20240727165342067"></p><p>​    现在，我们来看看自己的模块挂没挂上</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>    <span class="token number">6.058570</span><span class="token punctuation">]</span> loop: module loaded<span class="token punctuation">[</span>  <span class="token number">156.245140</span><span class="token punctuation">]</span> charlie: loading out-of-tree module taints kernel.<span class="token punctuation">[</span>  <span class="token number">156.245148</span><span class="token punctuation">]</span> charlie: module verification failed: signature and/or required key missing - tainting kernel 不用害怕最后一行，这是我们没有验证模块，不影响什么<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    printk函数是内核打印函数，系统的日志就是依靠这个函数完成的，我们观察我们的模块现象：</p><pre class="line-numbers language-less" data-language="less"><code class="language-less">[  156.245140] <span class="token property">charlie</span><span class="token punctuation">:</span> loading out<span class="token operator">-</span>of<span class="token operator">-</span>tree module taints kernel.[  156.245148] <span class="token property">charlie</span><span class="token punctuation">:</span> module verification <span class="token property">failed</span><span class="token punctuation">:</span> signature and<span class="token operator">/</span>or required key missing <span class="token operator">-</span> tainting kernel[  156.245609] SUP<span class="token punctuation">,</span> DUDE![  156.245611] SUP<span class="token punctuation">,</span> DUDE![  156.245611] SUP<span class="token punctuation">,</span> DUDE![  156.245612] SUP<span class="token punctuation">,</span> DUDE![  156.245612] SUP<span class="token punctuation">,</span> DUDE![  156.245613] SUP<span class="token punctuation">,</span> DUDE![  156.245613] SUP<span class="token punctuation">,</span> DUDE![  156.245614] SUP<span class="token punctuation">,</span> DUDE![  156.245614] SUP<span class="token punctuation">,</span> DUDE!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    符合我们的预期：向内核打印！（吞了一个输出，无伤大雅）</p><h3 id="查看我们module信息"><a href="#查看我们module信息" class="headerlink" title="查看我们module信息"></a>查看我们module信息</h3><p>​    查看的办法是</p><pre class="line-numbers language-none"><code class="language-none">modinfo xxx.ko<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">➜  modinfo charlie.kofilename:       &#x2F;home&#x2F;Charliechen&#x2F;Works&#x2F;opearte_system&#x2F;module&#x2F;charlie.kolicense:        GPLauthor:         Charliechensrcversion:     D2FFFA830F5695951FAAC09depends:        retpoline:      Yname:           charlievermagic:       6.9.3-arch1-1 SMP preempt mod_unload <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="卸载我们的module"><a href="#卸载我们的module" class="headerlink" title="卸载我们的module"></a>卸载我们的module</h3><pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">sudo rmmod xxx.ko [  952.395595] GOODBYE_BOY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入研究Qt Meta - Object System</title>
      <link href="/2024/07/27/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Qt-Meta-Object-System/"/>
      <url>/2024/07/27/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6Qt-Meta-Object-System/</url>
      
        <content type="html"><![CDATA[<h1 id="深入研究Qt-Meta-Object-System"><a href="#深入研究Qt-Meta-Object-System" class="headerlink" title="深入研究Qt Meta - Object System"></a>深入研究Qt Meta - Object System</h1><p>这篇文章我打算研究一下QMetaObject System，也就是Qt自己构建起来的元对象系统。</p><h3 id="先说RTTI"><a href="#先说RTTI" class="headerlink" title="先说RTTI"></a>先说<a href="https://so.csdn.net/so/search?q=RTTI&amp;spm=1001.2101.3001.7020">RTTI</a></h3><p>啥是RTTI？这是C++编程里的一个常见术语，全称是：运行阶段类型识别（Runtime Type Identification），关于RTTI如何在原生C++中使用不是我们这里的重点，但是可以明确的一点是——跟编译器实现密切相关，意味着可移植性略差。很多类库已经为其类对象提供了实现这种功能的方式，但由于C++内部并不支持，因此各个厂商的机制通常互不兼容</p><p>即使编译器支持RTTI，就目前而言，原生的支持仍然十分的不足。我们没有办法完全知道例如类的名字、有哪些父类、有哪些成员变量、有哪些成员函数、哪些是public的、哪些是private的、哪些是protected的等等。</p><p>有时候一个工程项目可能包含成千上万个类，完整的保存这些信息将会消耗大量的内存资源。为了节省内存，C++标准约定<a href="https://so.csdn.net/so/search?q=typeid&amp;spm=1001.2101.3001.7020">typeid</a>只能返回类名。因此，仅靠dynamic_cast和typeid两个关键字提供的类型信息实在有限。更何况，他还会造成大量的系统开销，这也是为什么这个特性并没有被完整的纳入标准。</p><blockquote><p>关于RTTI，可以参看：<a href="https://zhuanlan.zhihu.com/p/509453699">【C++】RTTI有什么用？怎么用？ - 知乎 (zhihu.com)</a>以备快速的复习</p></blockquote><h3 id="再说QMeta-Object-System"><a href="#再说QMeta-Object-System" class="headerlink" title="再说QMeta Object System"></a>再说QMeta Object System</h3><p>下面我们聊聊，既然大家都各做各的，Qt框架作为C++早期时代就存在的框架，自然实现了自己的一套源系统机制。</p><p>这个元对象机制不光实现了类似于RTTI那样的动态查看类信息的作用，还扩展出了信号与槽的机制（这个就是大名鼎鼎的信号与槽）</p><blockquote><pre class="line-numbers language-none"><code class="language-none">Qt&#39;s meta-object system provides the signals and slots mechanism for inter-object communication, run-time type information, and the dynamic property system.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>这个对象说一千道一万，三个核心</p><blockquote><ol><li>The <a href="https://doc.qt.io/qt-6/qobject.html">QObject</a> class provides a base class for objects that can take advantage of the meta-object system.</li><li>The <a href="https://doc.qt.io/qt-6/qobject.html#Q_OBJECT">Q_OBJECT</a> macro inside the private section of the class declaration is used to enable meta-object features, such as dynamic properties, signals, and slots.</li><li>The <a href="https://doc.qt.io/qt-6/moc.html">Meta-Object Compiler</a> (<code>moc</code>) supplies each <a href="https://doc.qt.io/qt-6/qobject.html">QObject</a> subclass with the necessary code to implement meta-object features.</li></ol></blockquote><p>也就是说：</p><blockquote><ol><li>QObject这个类提供了整个元对象系统的一个根基</li><li><a href="https://so.csdn.net/so/search?q=Q_Object&amp;spm=1001.2101.3001.7020">Q_Object</a>宏这是让一个类可以使用RTTI，信号与槽机制（这就是为什么一些奇奇怪怪的Undefined Reference可以依赖这个解决，下一次发现使用信号与槽机制的时候编译炸了排查的时候考虑这个事情）</li><li>Moc则是更加进一步的提供了元对象系统的实现的保证（嘿！想一下你编译的时候是不是需要有moc文件，他就是Meta-object Compilers，元系统编译器产生的）</li></ol></blockquote><p>换而言之，Qt的元对象并不完全直接依赖于语言，而是借助了外来的Moc Tools预先扫描源文件，生成自己的元对象文件，在最后纳入编译阶段合并进来</p><p>当然，我们的元对象系统还可以做更多的事情：</p><blockquote><ol><li>QObject::metaObject作为一个静态方法返回关联的metaObject（也就是返回当前对象的元对象系统的那部分）</li><li>QMetaObject::className可以进一步返回运行时的对象名称，而这个是基于标准实现而不是编译器实现的，你知道的，一致性！</li><li>QObject::inherits则是检查一个类是不是位于Qt的继承树上</li><li>QObject::tr则是保证了我们的对象名称满足国际化</li><li>QObject::setProperty和QObject::property让我们的对象拥有了属性这个概念！</li><li>QMetaObject::newInstance()以一种工厂方法构造了这个类的一个新实例</li></ol></blockquote><p>我们知道dynamic_cast可以用来转化父类子类，而且转化成不成功全看是不是真的如此。这里我们入乡随俗，使用qobject_cast来检查Qt元对象的继承问题。</p><p>我随手写一个简单的demo:</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;QWidget&gt;#include &lt;QMainWindow&gt;#include &lt;QApplication&gt;class MyObject : public QWidget&#123;&#125;;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv); &#x2F;&#x2F; Import For QWidgets enable    QObject* obj &#x3D; new MyObject;    QWidget* widget &#x3D; qobject_cast&lt;QWidget*&gt;(obj);    if(widget)&#123;        qDebug() &lt;&lt; &quot;Is Widget&quot;;    &#125;    QMainWindow* window &#x3D; qobject_cast&lt;QMainWindow*&gt;(obj);    if(window)&#123;        qDebug() &lt;&lt; &quot;Is Window&quot;;    &#125;    delete obj;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是，如果我们希望纳入一个类进入QObject的继承对象树中，务！必！在私有区域声明一个Q_OBJECT。（当然要是想要直接暴露给外面的话放在public也不是不行）</p><p>手撸了一个例子</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;QWidget&gt;#include &lt;QMainWindow&gt;#include &lt;QApplication&gt;#define IS_USE_QOBJ_MACRO 0class MyObject : public QWidget&#123;#if IS_USE_QOBJ_MACRO    Q_OBJECT#endifpublic:    QString _ClassName()&#123;        return this-&gt;metaObject()-&gt;className();    &#125;&#125;;int main(int argc, char *argv[])&#123;    QApplication app(argc, argv);    QObject* obj &#x3D; new MyObject;    QWidget* widget &#x3D; qobject_cast&lt;QWidget*&gt;(obj);    if(widget)&#123;        qDebug() &lt;&lt; &quot;Is Widget&quot;;    &#125;    QMainWindow* window &#x3D; qobject_cast&lt;QMainWindow*&gt;(obj);    if(window)&#123;        qDebug() &lt;&lt; &quot;Is Window&quot;;    &#125;    qDebug() &lt;&lt; dynamic_cast&lt;MyObject*&gt;(obj)-&gt;_ClassName();    delete obj;&#125;#if IS_USE_QOBJ_MACRO#include &quot;main.moc&quot; &#x2F;&#x2F; 一个Demo，我们直接自己引入编译好的main.moc#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以留意到，添加了QOBJECT宏的类的行为表现的并不一致。</p><pre class="line-numbers language-none"><code class="language-none">#define IS_USE_QOBJ_MACRO 0Is Widget&quot;QWidget&quot;#define IS_USE_QOBJ_MACRO 1Is Widget&quot;MyObject&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由此，如果想要让元对象系统正确的工作，请务必使用Q_OBJECT</p><h3 id="关于Q-OBJECT"><a href="#关于Q-OBJECT" class="headerlink" title="关于Q_OBJECT"></a>关于Q_OBJECT</h3><pre class="line-numbers language-none"><code class="language-none">#define Q_OBJECT \public: \    QT_WARNING_PUSH \    Q_OBJECT_NO_OVERRIDE_WARNING \    static const QMetaObject staticMetaObject; \    virtual const QMetaObject *metaObject() const; \    virtual void *qt_metacast(const char *); \    virtual int qt_metacall(QMetaObject::Call, int, void **); \    QT_TR_FUNCTIONS \private: \    Q_OBJECT_NO_ATTRIBUTES_WARNING \    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \    QT_WARNING_POP \    struct QPrivateSignal &#123; explicit QPrivateSignal() &#x3D; default; &#125;; \    QT_ANNOTATE_CLASS(qt_qobject, &quot;&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这就是我们的源码。</p><p>可以看到他实际上就是向我们的类内嵌入了工作函数。这就是为什么需要添加一些类。</p><p>当然还有MOC编译器的使用，以及还有属性系统，挖个坑，有空讲。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How My Arch Linux StartUp</title>
      <link href="/2024/05/05/How-My-Arch-Linux-StartUp/"/>
      <url>/2024/05/05/How-My-Arch-Linux-StartUp/</url>
      
        <content type="html"><![CDATA[<h1 id="How-Linux-Works-I-How-Linux-Start-Up"><a href="#How-Linux-Works-I-How-Linux-Start-Up" class="headerlink" title="How Linux Works I - How Linux Start Up"></a>How Linux Works I - How Linux Start Up</h1><blockquote><p>写在前面：上一个专栏中我写完了内核源码层面看Linux，我们把抽象层拉高一点，看看Linux是如何工作的！</p></blockquote><h2 id="Linux如何启动？"><a href="#Linux如何启动？" class="headerlink" title="Linux如何启动？"></a>Linux如何启动？</h2><blockquote><ol><li>BIOS（Basic Input Output System）或者启动固件加载并运行引导装载程序（告知OS在哪里）</li><li>引导装载程序在磁盘上找到内核的位置，载入RAM中启动</li><li>初始化设备与驱动程序</li><li>挂载root文件系统</li><li>内核使用swapper进程（0号进程，PID = 1）来允许一个init进程，从这里开始，我们的程序将会被下放到用户态</li><li>init继续启动其他进程</li><li>最后的尾声就是启动一个登陆进程！是的，就是那个让你输入用户密码的那个界面就是登录进程完成的</li></ol></blockquote><p><img src=".\image-20240505183113071.png" alt="image-20240505183113071"></p><h2 id="启动信息"><a href="#启动信息" class="headerlink" title="启动信息"></a>启动信息</h2><p>​    Linux内核启动信息去这里看：</p><pre class="line-numbers language-none"><code class="language-none">sudo dmesg &gt; demo.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    这条指令可以将输出的信息发送到demo.txt文件当中，或者你想要在控制台上看</p><pre class="line-numbers language-none"><code class="language-none">sudo dmesg | less<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    将会调度less程序使得日志分页。一些启动日志将会保存在<code>/var/log/</code>下面，不同的发行版会有不同的调整，比如说我这里就没有什么一下就可以找到的开机日志文件（<code>Arch Linux</code>）</p><pre class="line-numbers language-none"><code class="language-none">[    0.000000] Linux version 6.8.8-arch1-1 (linux@archlinux) (gcc (GCC) 13.2.1 20240417, GNU ld (GNU Binutils) 2.42.0) #1 SMP PREEMPT_DYNAMIC Sun, 28 Apr 2024 15:59:47 +0000[    0.000000] Command line: BOOT_IMAGE&#x3D;&#x2F;@&#x2F;boot&#x2F;vmlinuz-linux root&#x3D;UUID&#x3D;c6ae9e8b-6dd3-4a7b-99bf-fcedbd6ab74c rw rootflags&#x3D;subvol&#x3D;@ loglevel&#x3D;3 quiet[    0.000000] [Firmware Bug]: TSC doesn&#39;t count with P0 frequency![    0.000000] BIOS-provided physical RAM map:[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x0000000000000fff] ACPI NVS[    0.000000] BIOS-e820: [mem 0x0000000000001000-0x000000000009ffff] usable...[   74.611975] systemd-journald[246]: &#x2F;var&#x2F;log&#x2F;journal&#x2F;deaaebab639c462183f85623319ae5fc&#x2F;user-1000.journal: Journal file uses a different sequence number ID, rotating.[  273.008400] systemd[1]: systemd 255.5-4-arch running in system mode (+PAM +AUDIT -SELINUX -APPARMOR -IMA +SMACK +SECCOMP +GCRYPT +GNUTLS +OPENSSL +ACL +BLKID +CURL +ELFUTILS +FIDO2 +IDN2 -IDN +IPTC +KMOD +LIBCRYPTSETUP +LIBFDISK +PCRE2 +PWQUALITY +P11KIT +QRENCODE +TPM2 +BZIP2 +LZ4 +XZ +ZLIB +ZSTD +BPF_FRAMEWORK +XKBCOMMON +UTMP -SYSVINIT default-hierarchy&#x3D;unified)[  273.008505] systemd[1]: Detected virtualization vmware.[  273.008596] systemd[1]: Detected architecture x86-64.[  273.424093] systemd[1]: bpf-lsm: LSM BPF program attached[  352.419139] perf: interrupt took too long (2590 &gt; 2500), lowering kernel.perf_event_max_sample_rate to 77100[  390.817032] perf: interrupt took too long (3500 &gt; 3237), lowering kernel.perf_event_max_sample_rate to 57000[  527.871009] perf: interrupt took too long (4415 &gt; 4375), lowering kernel.perf_event_max_sample_rate to 45300<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分析dmesg启动文件"><a href="#分析dmesg启动文件" class="headerlink" title="分析dmesg启动文件"></a>分析dmesg启动文件</h2><p>我们先简单看看基本的流程：</p><ol><li>检查CPU</li><li>检查内存</li><li>检查设备总线</li><li>检测设备</li><li>设置附加内核子系统</li><li>挂载 root 目录</li><li>启动用户空间</li></ol><p>​    这是我学习的这本书告知我的流程，我还是觉得没什么味道，这里写一个更加详细的，依照系统日志版本的</p><ol><li>第一步，查看Linux内核版本，确定内核的一些设置参数（这里你可以看到我的系统是使用了支持SMP多核架构编译选项了的内核 + 支持动态抢占（这点是自从2.6开始就有了的CFS调度的特性）选项编译的内核）</li></ol><pre class="line-numbers language-none"><code class="language-none">[    0.000000] Linux version 6.8.8-arch1-1 (linux@archlinux) (gcc (GCC) 13.2.1 20240417, GNU ld (GNU Binutils) 2.42.0) #1 SMP PREEMPT_DYNAMIC Sun, 28 Apr 2024 15:59:47 +0000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>第二步：找到内核位置</li></ol><pre class="line-numbers language-none"><code class="language-none">Command line: BOOT_IMAGE&#x3D;&#x2F;@&#x2F;boot&#x2F;vmlinuz-linux root&#x3D;UUID&#x3D;c6ae9e8b-6dd3-4a7b-99bf-fcedbd6ab74c rw rootflags&#x3D;subvol&#x3D;@ loglevel&#x3D;3 quiet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><strong>vmlinuz是可引导的、压缩的内核</strong>。“vm”代表“Virtual Memory”。Linux 支持虚拟内存，不像老的操作系统比如DOS有640KB内存的限制。Linux能够使用硬盘空间作为虚拟内存，因此得名“vm”。vmlinuz是可执行的Linux内核，它位于/boot/vmlinuz，它一般是一个软链接。</p></blockquote><ol><li>第三步：开始使用BIOS自举检查的信息：比如说，我们上面提到的——检查内存：</li></ol><pre class="line-numbers language-none"><code class="language-none">[    0.000000] BIOS-provided physical RAM map:# 是的，BIOS提供的物理RAM内存视图[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x0000000000000fff] ACPI NVS[    0.000000] BIOS-e820: [mem 0x0000000000001000-0x000000000009ffff] usable[    0.000000] BIOS-e820: [mem 0x00000000000c0000-0x00000000000fffff] reserved[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000000e655fff] usable[    0.000000] BIOS-e820: [mem 0x000000000e656000-0x000000000e672fff] ACPI data[    0.000000] BIOS-e820: [mem 0x000000000e673000-0x000000000efaafff] usable[    0.000000] BIOS-e820: [mem 0x000000000efab000-0x000000000efaefff] reserved[    0.000000] BIOS-e820: [mem 0x000000000efaf000-0x000000000efbcfff] usable[    0.000000] BIOS-e820: [mem 0x000000000efbd000-0x000000000efc1fff] reserved[    0.000000] BIOS-e820: [mem 0x000000000efc2000-0x000000000efc6fff] ACPI NVS[    0.000000] BIOS-e820: [mem 0x000000000efc7000-0x000000000fee5fff] usable[    0.000000] BIOS-e820: [mem 0x000000000fee6000-0x000000000ff55fff] reserved[    0.000000] BIOS-e820: [mem 0x000000000ff56000-0x000000000ff71fff] ACPI data[    0.000000] BIOS-e820: [mem 0x000000000ff72000-0x000000000ff75fff] ACPI NVS[    0.000000] BIOS-e820: [mem 0x000000000ff76000-0x00000000bfffffff] usable[    0.000000] BIOS-e820: [mem 0x00000000ffc00000-0x00000000ffc29fff] reserved[    0.000000] BIOS-e820: [mem 0x0000000100000000-0x000000023fffffff] usable #  4G起始空间 - 8G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>S在操作系统开始管理内存之前，首先要获取物理内存的信息，比如一共有多少物理地址是可用的，有哪些物理地址是被ACPI数据使用（关于PCI，ACPI我下面会简单的介绍，先不着急）</p></blockquote><p>可以查询到的一些字段说明：</p><ul><li>Usable：已经被映射到物理内存的物理地址。（也就是可用的）</li><li>Reserved：这些区间是没有被映射到任何地方，不能当作RAM来使用，但是kernel可以决定将这些区间映射到其他地方，<strong>比如PCI设备。通过检查/proc/iomem这个虚拟文件，就可以知道这些reserved的空间</strong>，是如何进一步分配给不同的设备来使用了。</li><li>ACPI data：映射到用来存放ACPI数据的RAM空间，操作系统应该将ACPI Table读入到这个区间内。</li><li>ACPI NVS：映射到用来存放ACPI数据的非易失性存储空间，操作系统不能使用。</li><li>Unusable：表示检测到发生错误的物理内存。这个在上面例子里没有，因为比较少见。</li></ul><p>我们的物理地址检查到了8G的大小，符合我们的设置吗？符合！说明BIOS探测没有问题，且所有的物理内存都可用（至少没有Unusable）</p><p><img src=".\image-20240505191234413.png" alt="image-20240505191234413"></p><p>确认开启NX保护机制，也就是说我们的内存页不可执行（CPU并不知道我们的来的流是数据是数据还是指令，把数据段当成指令段。。。嗯，你懂的）</p><blockquote><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p></blockquote><ol><li>第四步：静态初始化高级可编程中断控制器，也就是我们的APIC，管中断的！这里开始，定时器等跟中断相关的设备开始初始化</li></ol><pre class="line-numbers language-none"><code class="language-none">APIC: Static calls initialized<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面的e820是啥？嘿嘿，你知道的，任何一个手搓过Operating System的人都直到我们OS启动之后，还得进一步探测内存，方法？很简单，x86架构有一个简单的方式告知整个架构系统自己开始查RAM内存：也就是往RAX寄存器（如果是32位那就是往EAX，16位老古董？AX！）塞值：E820H，然后在我们向已经局部初始化的APIC发起一个中断：BIOS中断号15H</p><pre class="line-numbers language-none"><code class="language-none">mov eax, $e820Hint 15h; 15号中断<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    查得很快，我们的RAM局部图现在就会被排布成这样。</p><pre class="line-numbers language-none"><code class="language-none"> 0.000000] e820: update [mem 0x0c2c6018-0x0c2ce057] usable &#x3D;&#x3D;&gt; usable[    0.000000] e820: update [mem 0x0e60b018-0x0e60d057] usable &#x3D;&#x3D;&gt; usable[    0.000000] e820: update [mem 0x0e60b018-0x0e60d057] usable &#x3D;&#x3D;&gt; usable[    0.000000] e820: update [mem 0x0e609018-0x0e60a857] usable &#x3D;&#x3D;&gt; usable[    0.000000] e820: update [mem 0x0e609018-0x0e60a857] usable &#x3D;&#x3D;&gt; usable[    0.000000] extended physical RAM map:[    0.000000] reserve setup_data: [mem 0x0000000000000000-0x0000000000000fff] ACPI NVS[    0.000000] reserve setup_data: [mem 0x0000000000001000-0x000000000009ffff] usable[    0.000000] reserve setup_data: [mem 0x00000000000c0000-0x00000000000fffff] reserved[    0.000000] reserve setup_data: [mem 0x0000000000100000-0x000000000c2c6017] usable[    0.000000] reserve setup_data: [mem 0x000000000c2c6018-0x000000000c2ce057] usable[    0.000000] reserve setup_data: [mem 0x000000000c2ce058-0x000000000e609017] usable[    0.000000] reserve setup_data: [mem 0x000000000e609018-0x000000000e60a857] usable[    0.000000] reserve setup_data: [mem 0x000000000e60a858-0x000000000e60b017] usable[    0.000000] reserve setup_data: [mem 0x000000000e60b018-0x000000000e60d057] usable[    0.000000] reserve setup_data: [mem 0x000000000e60d058-0x000000000e655fff] usable[    0.000000] reserve setup_data: [mem 0x000000000e656000-0x000000000e672fff] ACPI data[    0.000000] reserve setup_data: [mem 0x000000000e673000-0x000000000efaafff] usable[    0.000000] reserve setup_data: [mem 0x000000000efab000-0x000000000efaefff] reserved[    0.000000] reserve setup_data: [mem 0x000000000efaf000-0x000000000efbcfff] usable[    0.000000] reserve setup_data: [mem 0x000000000efbd000-0x000000000efc1fff] reserved[    0.000000] reserve setup_data: [mem 0x000000000efc2000-0x000000000efc6fff] ACPI NVS[    0.000000] reserve setup_data: [mem 0x000000000efc7000-0x000000000fee5fff] usable[    0.000000] reserve setup_data: [mem 0x000000000fee6000-0x000000000ff55fff] reserved[    0.000000] reserve setup_data: [mem 0x000000000ff56000-0x000000000ff71fff] ACPI data[    0.000000] reserve setup_data: [mem 0x000000000ff72000-0x000000000ff75fff] ACPI NVS[    0.000000] reserve setup_data: [mem 0x000000000ff76000-0x00000000bfffffff] usable[    0.000000] reserve setup_data: [mem 0x00000000ffc00000-0x00000000ffc29fff] reserved[    0.000000] reserve setup_data: [mem 0x0000000100000000-0x000000023fffffff] usable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>下面就是EFI接手进一步启动工作EFI，是Extensible Firmware Interface的词头缩写，直译过来就是可扩展固件接口，它是用模块化、高级语言（主要是C语言）构建的一个小型化系统，它和BIOS一样，主要在启动过程中完成硬件初始化，但它是直接利用加载EFI驱动的方式，识别系统硬件并完成硬件初始化，彻底摒弃读各种中断执行。</p></li><li><p>不过这里，会确定下来我们的系统允许的平台和信息，使用的是SMBIOS（<em>System Management BIOS</em>），从而确认我们的主板信息等</p></li></ol><pre class="line-numbers language-none"><code class="language-none">efi: SMBIOS&#x3D;0xefc2000 # ACPI数据的非易失性存储空间，操作系统不能使用，这里就是给SMBIOS用了ACPI 2.0&#x3D;0xe656000 # 看到上面的RAM配置图了吗，果然ACPI被安排到这里了MEMATTR&#x3D;0xfcc3798 # 这里存放着内存的属性表，是后续工作用来确定这块内存干啥的# 对这部分源码有兴趣：&#x2F;efi&#x2F;memattr.c看看INITRD&#x3D;0xe608e98 # boot loader iniTIalized RAM disk，就是由 boot loader 初始化的内存盘,这是为了给初始化真正的文件系统之前，系统使用的文件系统，这里排布了他的位置！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查出来我的主板信息了：哈哈，是虚拟机！</p><pre class="line-numbers language-none"><code class="language-none">DMI: VMware, Inc. VMware7,1&#x2F;440BX Desktop Reference Platform, BIOS VMW71.00V.18452719.B64.2108091906 08&#x2F;09&#x2F;2021<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    所以，他会初始化虚拟机作用下的系统调用转发等工作（你知道的，虚拟机本身就是寄宿在客机上的，中间的一些步骤没啥好看的）</p><pre class="line-numbers language-none"><code class="language-none">[    0.000000] vmware: hypercall mode: 0x01[    0.000000] Hypervisor detected: VMware[    0.000000] vmware: TSC freq read from hypervisor : 3193.892 MHz[    0.000000] vmware: Host bus clock speed read from hypervisor : 66000000 Hz[    0.000000] vmware: using clock offset of 4464998876 ns # 没啥好看的，查出来是vmware，，做一些工作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>下一步，确定主板架构之后，读取CPU相关的信息，更新我们的RAM mapping：</li></ol><pre class="line-numbers language-none"><code class="language-none">[    0.000013] tsc: Detected 3193.892 MHz processor # 时间戳计数器（TSC，Time Stamp Counter）[    0.320730] e820: update [mem 0x00000000-0x00000fff] usable &#x3D;&#x3D;&gt; reserved[    0.320737] e820: remove [mem 0x000a0000-0x000fffff] usable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    TSC可以到我讲定时测量的部分看看，与之相关的还有HPET！</p><ol><li>准备为查好的内存建立页表，划分空间的3GB-4GB部分为内核使用！</li></ol><pre class="line-numbers language-none"><code class="language-none">[    0.320879] x86&#x2F;PAT: Configuration [0-7]: WB  WC  UC- UC  WB  WP  UC- WT  # 令人激动的一步！再这里开始，我们的后3GB - 4GB内存划分给了内核[    0.320935] e820: update [mem 0xc0000000-0xffffffff] usable &#x3D;&#x3D;&gt; reserved[    0.320938] last_pfn &#x3D; 0xc0000 max_arch_pfn &#x3D; 0x400000000[    0.323887] Using GB pages for direct mapping[    0.324326] Secure boot disabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说一下：</p><ul><li>Strong Uncacheable （UC）:这种cache类型的memory，任何读写操作都不经过cache。一般是memory-map的IO地址可以使用这种类型。一般的ram强烈推荐不使用这种cache，否则效率会非常低。</li><li>Write Back！（WB）最常见的 cacheable write</li><li>Uncacheable （UC-）:特性与UC(Strong uncacheable)相同，唯一不同的是，这种类型的memory，可以通过修改MTRR来把它改变成WC</li><li>Write Combining （WC）:这种类型的cache，特性与UC相似，不同的地方是它可以被speculative read（预先随机读取，这个小机制我们在看文件系统的时候还会看到！）每次write都可能被delay，write的内容会buffer到一个叫“write combining buffer”的地方。可以通过 对MTRR编程来设置WC，也可以通过设置PAT来设置WC(pat是什么？)</li><li>Write – through （WT）:这个很好理解，每次write，都要write到memory，同时write到对应的cache（if write hits）。WT方式保证了cache与memory是一致的。这种类型的memory，read和write，都跟一般的cache一样。只是write的时候，当写到了cache中，不会立即write到memory里（这个就跟WT不一样了）。CPU会等到适当的时候再write到memory里—比如当cache满了。 这种类型是效率最高的类型，</li><li>Write-protected （WP）:Read跟wb一样，但每次write，都会引起cache invalidate</li></ul><p>​    同时，针对AMD（这里透过虚拟机查到了我的电脑是AMD64，可以支持AMD的大TLB缓存）（Using GB pages for direct mapping）</p><p>​    下面初始化就是存放APIC中的一些数据结构的一些结构说明</p><ul><li>FADT (Fixed ACPI Description Table) ，主要放了一些硬件信息和DSDT的地址。</li><li>MADT(Multiple APIC Description Table )，描述了中断硬件相关的信息。</li><li>PPTT(Processor Properties Topology Table), 描述了CPU相关的信息。</li><li>MCFG(PCI Express memory mapped configuration space base address Description Table) PCIE内存空间先关的地址。</li><li>GTDT(Generic Timer Description Table), 描述了timer相关的信息。</li><li>SPCR(Serial Port Console Redirection Table), 描述了串口相关的信息。</li><li>DBG2(Debug Port Table)， 描述了Debug口相关信息。</li><li>IORT(I/O Remapping Table), 描述了IO Remap相关信息。</li></ul><p>看完了：</p><pre class="line-numbers language-none"><code class="language-none">[    0.324369] ACPI: Reserving SRAT table memory at [mem 0xe6560c0-0xe65698f][    0.324370] ACPI: Reserving FACP table memory at [mem 0xe671bf8-0xe671ceb][    0.324370] ACPI: Reserving DSDT table memory at [mem 0xe656990-0xe671bf7][    0.324371] ACPI: Reserving FACS table memory at [mem 0xff75000-0xff7503f][    0.324371] ACPI: Reserving FACS table memory at [mem 0xff75000-0xff7503f][    0.324372] ACPI: Reserving APIC table memory at [mem 0xe672000-0xe672741][    0.324372] ACPI: Reserving MCFG table memory at [mem 0xe672742-0xe67277d][    0.324373] ACPI: Reserving HPET table memory at [mem 0xe67277e-0xe6727b5][    0.324373] ACPI: Reserving WAET table memory at [mem 0xe6727b6-0xe6727dd][    0.324374] ACPI: Reserving WSMT table memory at [mem 0xe6727de-0xe672805][    0.324410] system APIC only can use physical flat[    0.324415] APIC: Switched APIC routing to: physical flat # 物理平坦模型！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在下面就是初始化各个表，这里不再枚举！</p><pre class="line-numbers language-none"><code class="language-none">[    0.324445] SRAT: PXM 0 -&gt; APIC 0x00 -&gt; Node 0[    0.324447] SRAT: PXM 0 -&gt; APIC 0x01 -&gt; Node 0[    0.324447] SRAT: PXM 0 -&gt; APIC 0x02 -&gt; Node 0[    0.324447] SRAT: PXM 0 -&gt; APIC 0x03 -&gt; Node 0...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>开始初始化一些子系统：比如说</li></ol><pre class="line-numbers language-none"><code class="language-none">PM: hibernation: Registered nosave memory: [mem 0x00000000-0x00000fff][    0.543907] PM: hibernation: Registered nosave memory: [mem 0x000a0000-0x000bffff][    0.543907] PM: hibernation: Registered nosave memory: [mem 0x000c0000-0x000fffff][    0.543908] PM: hibernation: Registered nosave memory: [mem 0x0c2c6000-0x0c2c6fff][    0.543909] PM: hibernation: Registered nosave memory: [mem 0x0c2ce000-0x0c2cefff][    0.543910] PM: hibernation: Registered nosave memory: [mem 0x0e609000-0x0e609fff][    0.543910] PM: hibernation: Registered nosave memory: [mem 0x0e60a000-0x0e60afff][    0.543910] PM: hibernation: Registered nosave memory: [mem 0x0e60b000-0x0e60bfff][    0.543911] PM: hibernation: Registered nosave memory: [mem 0x0e60d000-0x0e60dfff][    0.543912] PM: hibernation: Registered nosave memory: [mem 0x0e656000-0x0e672fff][    0.543912] PM: hibernation: Registered nosave memory: [mem 0x0efab000-0x0efaefff][    0.543913] PM: hibernation: Registered nosave memory: [mem 0x0efbd000-0x0efc1fff][    0.543914] PM: hibernation: Registered nosave memory: [mem 0x0efc2000-0x0efc6fff][    0.543914] PM: hibernation: Registered nosave memory: [mem 0x0fee6000-0x0ff55fff][    0.543915] PM: hibernation: Registered nosave memory: [mem 0x0ff56000-0x0ff71fff][    0.543915] PM: hibernation: Registered nosave memory: [mem 0x0ff72000-0x0ff75fff][    0.543916] PM: hibernation: Registered nosave memory: [mem 0xc0000000-0xffbfffff][    0.543916] PM: hibernation: Registered nosave memory: [mem 0xffc00000-0xffc29fff][    0.543917] PM: hibernation: Registered nosave memory: [mem 0xffc2a000-0xffffffff]# 这里就是电源管理系统，他开始注册监察内存，信息是从先前的排查中获取的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这里开始初始化我们内核要使用的per-cpu变量了，从这里开始我们慢慢熟悉起来了：</p><pre class="line-numbers language-none"><code class="language-none">[    0.602809] pcpu-alloc: s225280 r8192 d28672 u262144 alloc&#x3D;1*2097152[    0.602812] pcpu-alloc: [0] 000 001 002 003 004 005 006 007 [    0.602815] pcpu-alloc: [0] 008 009 010 011 012 013 014 015 [    0.602818] pcpu-alloc: [0] 016 017 018 019 020 021 022 023 [    0.602820] pcpu-alloc: [0] 024 025 026 027 028 029 030 031 [    0.602823] pcpu-alloc: [0] 032 033 034 035 036 037 038 039 [    0.602825] pcpu-alloc: [0] 040 041 042 043 044 045 046 047 [    0.602828] pcpu-alloc: [0] 048 049 050 051 052 053 054 055 [    0.602830] pcpu-alloc: [0] 056 057 058 059 060 061 062 063 [    0.602833] pcpu-alloc: [0] 064 065 066 067 068 069 070 071 [    0.602835] pcpu-alloc: [0] 072 073 074 075 076 077 078 079 [    0.602838] pcpu-alloc: [0] 080 081 082 083 084 085 086 087 [    0.602840] pcpu-alloc: [0] 088 089 090 091 092 093 094 095 [    0.602843] pcpu-alloc: [0] 096 097 098 099 100 101 102 103 [    0.602845] pcpu-alloc: [0] 104 105 106 107 108 109 110 111 [    0.602848] pcpu-alloc: [0] 112 113 114 115 116 117 118 119 [    0.602850] pcpu-alloc: [0] 120 121 122 123 124 125 126 127 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    基础的中断硬件支持激活，内存排查，页表等建立已经结束，我们开始真正的引导内核进入，下面是它打印先前设备接管的信息：</p><pre class="line-numbers language-none"><code class="language-none"># 内核[    0.602882] Kernel command line: BOOT_IMAGE&#x3D;&#x2F;@&#x2F;boot&#x2F;vmlinuz-linux root&#x3D;UUID&#x3D;c6ae9e8b-6dd3-4a7b-99bf-fcedbd6ab74c rw rootflags&#x3D;subvol&#x3D;@ loglevel&#x3D;3 quiet[    0.602926] Unknown kernel command line parameters &quot;BOOT_IMAGE&#x3D;&#x2F;@&#x2F;boot&#x2F;vmlinuz-linux&quot;, will be passed to user space.[    0.602947] random: crng init done[    0.602948] printk: log_buf_len individual max cpu contribution: 4096 bytes[    0.602948] printk: log_buf_len total cpu_extra contributions: 520192 bytes[    0.602949] printk: log_buf_len min size: 131072 bytes[    0.610763] printk: log_buf_len: 1048576 bytes[    0.610765] printk: early log buf free: 103752(79%)[    0.624062] Dentry cache hash table entries: 1048576 (order: 11, 8388608 bytes, linear)[    0.630705] Inode-cache hash table entries: 524288 (order: 10, 4194304 bytes, linear)[    0.633598] Fallback order for Node 0: 0 [    0.633618] Built 1 zonelists, mobility grouping on.  Total pages: 2063943[    0.633620] Policy zone: Normal[    0.638437] mem auto-init: stack:all(zero), heap alloc:on, heap free:off[    0.638444] software IO TLB: area num 128.[    0.736554] Memory: 8058148K&#x2F;8387472K available (16384K kernel code, 2121K rwdata, 12976K rodata, 3448K init, 3776K bss, 329064K reserved, 0K cma-reserved)[    0.737128] SLUB: HWalign&#x3D;64, Order&#x3D;0-3, MinObjects&#x3D;0, CPUs&#x3D;128, Nodes&#x3D;1 # 啊哈！slub缓存器[    0.737308] ftrace: allocating 49155 entries in 193 pages[    0.748068] ftrace: allocated 193 pages with 3 groups<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>初始化为了高性能运转的RCU机制：</li></ol><blockquote><p>RCU全称Read-Copy-Update，是linux内核中实现的一种可扩展的高性能同步机制，其功能是希望<strong>读线程</strong>没有同步开销，或者让同步开销变得很小，不需要使用原子操作指令和内存屏障，即可访问；而把需要同步的任务交给<strong>写线程</strong>，写线程等待所有读线程完成后才会把旧数据销毁。<strong>RCU原理可概括为：RCU记录了所有指向共享数据的指针的使用者，当要修改共享数据时，首先会创建一个副本，在副本中修改，当所有读访问线程都离开读临界区之后，指针将指向新修改后副本的指针，并且删除旧的数据。</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">[    0.750281] rcu: Preemptible hierarchical RCU implementation.[    0.750283] rcu: RCU restricting CPUs from NR_CPUS&#x3D;320 to nr_cpu_ids&#x3D;128.[    0.750284] rcu: RCU priority boosting: priority 1 delay 500 ms.[    0.750285] Trampoline variant of Tasks RCU enabled.[    0.750286] Rude variant of Tasks RCU enabled.[    0.750286] Tracing variant of Tasks RCU enabled.[    0.750287] rcu: RCU calculated value of scheduler-enlistment delay is 30 jiffies.[    0.750288] rcu: Adjusting geometry for rcu_fanout_leaf&#x3D;16, nr_cpu_ids&#x3D;128[    0.754050] NR_IRQS: 20736, nr_irqs: 1448, preallocated irqs: 16[    0.754473] rcu: srcu_init: Setting srcu_struct sizes to big.[    0.754851] kfence: initialized - using 2097152 bytes for 255 objects at 0x(____ptrval____)-0x(____ptrval____)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>TTY0中断初始化</li></ol><pre class="line-numbers language-none"><code class="language-none">[    0.755117] Console: colour dummy device 80x25[    0.755120] printk: legacy console [tty0] enabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>初始化fpu等系统组件</li></ol><pre class="line-numbers language-none"><code class="language-none">[    0.755263] ACPI: Core revision 20230628[    0.755845] clocksource: hpet: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 133484882848 ns[    0.755959] APIC: Switch to symmetric I&#x2F;O mode setup[    0.756295] x2apic enabled[    0.756623] APIC: Switched APIC routing to: physical x2apic[    0.758386] ..TIMER: vector&#x3D;0x30 apic1&#x3D;0 pin1&#x3D;2 apic2&#x3D;-1 pin2&#x3D;-1[    0.758433] clocksource: tsc-early: mask: 0xffffffffffffffff max_cycles: 0x2e09c06b889, max_idle_ns: 440795314250 ns[    0.758438] Calibrating delay loop (skipped) preset value.. 6390.94 BogoMIPS (lpj&#x3D;10646307)[    0.758943] x86&#x2F;cpu: User Mode Instruction Prevention (UMIP) activated[    0.759031] unchecked MSR access error: RDMSR from 0x852 at rIP: 0xffffffff89691387 (native_read_msr+0x7&#x2F;0x40)[    0.759037] Call Trace:[    0.759039]  &lt;TASK&gt;[    0.759041]  ? ex_handler_msr+0x121&#x2F;0x130[    0.759044]  ? fixup_exception+0x234&#x2F;0x310[    0.759045]  ? gp_try_fixup_and_notify+0x1e&#x2F;0xc0[    0.759048]  ? exc_general_protection+0x162&#x2F;0x450[    0.759052]  ? asm_exc_general_protection+0x26&#x2F;0x30[    0.759056]  ? native_read_msr+0x7&#x2F;0x40[    0.759058]  native_apic_msr_read+0x20&#x2F;0x30[    0.759061]  setup_APIC_eilvt+0x47&#x2F;0x170[    0.759065]  mce_amd_feature_init+0x47f&#x2F;0x4f0[    0.759068]  mcheck_cpu_init+0x19e&#x2F;0x4a0[    0.759071]  identify_cpu+0x3aa&#x2F;0x600[    0.759074]  arch_cpu_finalize_init+0x10&#x2F;0x110[    0.759078]  start_kernel+0x68f&#x2F;0xaa0[    0.759082]  x86_64_start_reservations+0x18&#x2F;0x30[    0.759085]  x86_64_start_kernel+0x96&#x2F;0xa0[    0.759087]  secondary_startup_64_no_verify+0x184&#x2F;0x18b[    0.759091]  &lt;&#x2F;TASK&gt;[    0.759093] LVT offset 2 assigned for vector 0xf4[    0.759094] [Firmware Bug]: cpu 0, try to use APIC520 (LVT offset 2) for vector 0xf4, but the register is already in use for vector 0x0 on this cpu[    0.759112] Last level iTLB entries: 4KB 512, 2MB 512, 4MB 256[    0.759114] Last level dTLB entries: 4KB 2048, 2MB 2048, 4MB 1024, 1GB 0[    0.759117] Spectre V1 : Mitigation: usercopy&#x2F;swapgs barriers and __user pointer sanitization[    0.759119] Spectre V2 : Mitigation: Retpolines[    0.759120] Spectre V2 : Spectre v2 &#x2F; SpectreRSB mitigation: Filling RSB on context switch[    0.759120] Spectre V2 : Spectre v2 &#x2F; SpectreRSB : Filling RSB on VMEXIT[    0.759122] Spectre V2 : mitigation: Enabling conditional Indirect Branch Prediction Barrier[    0.759123] Speculative Store Bypass: Vulnerable[    0.759124] Speculative Return Stack Overflow: IBPB-extending microcode not applied![    0.759125] Speculative Return Stack Overflow: WARNING: See https:&#x2F;&#x2F;kernel.org&#x2F;doc&#x2F;html&#x2F;latest&#x2F;admin-guide&#x2F;hw-vuln&#x2F;srso.html for mitigation options.[    0.759126] Speculative Return Stack Overflow: Vulnerable: Safe RET, no microcode[    0.759175] x86&#x2F;fpu: Supporting XSAVE feature 0x001: &#39;x87 floating point registers&#39;[    0.759176] x86&#x2F;fpu: Supporting XSAVE feature 0x002: &#39;SSE registers&#39;[    0.759177] x86&#x2F;fpu: Supporting XSAVE feature 0x004: &#39;AVX registers&#39;[    0.759178] x86&#x2F;fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256[    0.759179] x86&#x2F;fpu: Enabled xstate features 0x7, context size is 832 bytes, using &#39;compacted&#39; format.[    0.786020] Freeing SMP alternatives memory: 40K[    0.786025] pid_max: default: 131072 minimum: 1024[    0.787375] ------------[ cut here ]------------[    0.787377] CPA detected W^X violation: 8000000000000063 -&gt; 0000000000000063 range: 0x000000000ff06000 - 0x000000000ff06fff PFN ff06[    0.787424] WARNING: CPU: 0 PID: 0 at arch&#x2F;x86&#x2F;mm&#x2F;pat&#x2F;set_memory.c:645 __change_page_attr_set_clr+0xef8&#x2F;0x1030[    0.787431] Modules linked in:[    0.787434] CPU: 0 PID: 0 Comm: swapper&#x2F;0 Not tainted 6.8.8-arch1-1 #1 6e5d9eb17edb3e2ef7f1d13e0aec4b6c1833b648[    0.787437] Hardware name: VMware, Inc. VMware7,1&#x2F;440BX Desktop Reference Platform, BIOS VMW71.00V.18452719.B64.2108091906 08&#x2F;09&#x2F;2021[    0.787439] RIP: 0010:__change_page_attr_set_clr+0xef8&#x2F;0x1030[    0.787442] Code: 89 f9 48 89 c2 48 89 44 24 08 48 c7 c7 a8 85 c3 8a c6 05 85 49 f2 01 01 4c 8d 86 ff 0f 00 00 48 89 f1 4c 89 d6 e8 68 66 01 00 &lt;0f&gt; 0b 48 8b 44 24 08 e9 52 fc ff ff 4d 89 f3 48 8b 15 fa a1 63 01[    0.787444] RSP: 0000:ffffffff8b403c68 EFLAGS: 00010282[    0.787447] RAX: 0000000000000000 RBX: 000000000ff06063 RCX: ffff9a9dbfeee8a8[    0.787449] RDX: 0000000000000000 RSI: 00000000ffff7fff RDI: 0000000000000001[    0.787450] RBP: 800000000ff06063 R08: 0000000000000000 R09: ffffffff8b403af8[    0.787452] R10: ffffffff8b403af0 R11: 0000000000000003 R12: ffffffff8bb55930[    0.787454] R13: 0000000000000050 R14: 0000000000000001 R15: 000000000000ff06[    0.787455] FS:  0000000000000000(0000) GS:ffff9a9db5e00000(0000) knlGS:0000000000000000[    0.787457] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033[    0.787459] CR2: ffff9a9cafc03000 CR3: 000000012ee20000 CR4: 0000000000350ef0[    0.787462] Call Trace:[    0.787465]  &lt;TASK&gt;[    0.787466]  ? __change_page_attr_set_clr+0xef8&#x2F;0x1030[    0.787469]  ? __warn+0x81&#x2F;0x130[    0.787474]  ? __change_page_attr_set_clr+0xef8&#x2F;0x1030[    0.787477]  ? report_bug+0x171&#x2F;0x1a0[    0.787481]  ? prb_read_valid+0x1b&#x2F;0x30[    0.787485]  ? srso_alias_return_thunk+0x5&#x2F;0xfbef5[    0.787489]  ? handle_bug+0x3c&#x2F;0x80[    0.787492]  ? exc_invalid_op+0x17&#x2F;0x70[    0.787495]  ? asm_exc_invalid_op+0x1a&#x2F;0x20[    0.787499]  ? __pfx_efi_update_mem_attr+0x10&#x2F;0x10[    0.787505]  ? __change_page_attr_set_clr+0xef8&#x2F;0x1030[    0.787508]  ? __change_page_attr_set_clr+0xef8&#x2F;0x1030[    0.787514]  ? __pfx_efi_update_mem_attr+0x10&#x2F;0x10[    0.787517]  kernel_map_pages_in_pgd+0xa7&#x2F;0x110[    0.787523]  efi_update_mappings+0x36&#x2F;0xa0[    0.787527]  ? __pfx_efi_update_mem_attr+0x10&#x2F;0x10[    0.787530]  efi_memattr_apply_permissions+0x20e&#x2F;0x370[    0.787537]  efi_enter_virtual_mode+0x212&#x2F;0x4e0[    0.787541]  start_kernel+0x973&#x2F;0xaa0[    0.787546]  x86_64_start_reservations+0x18&#x2F;0x30[    0.787556]  x86_64_start_kernel+0x96&#x2F;0xa0[    0.787559]  secondary_startup_64_no_verify+0x184&#x2F;0x18b[    0.787566]  &lt;&#x2F;TASK&gt;[    0.787567] ---[ end trace 0000000000000000 ]---[    0.787815] LSM: initializing lsm&#x3D;capability,landlock,lockdown,yama,bpf,integrity[    0.787853] landlock: Up and running.[    0.787854] Yama: becoming mindful.[    0.787860] LSM support for eBPF active[    0.788205] Mount-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)[    0.788436] Mountpoint-cache hash table entries: 16384 (order: 5, 131072 bytes, linear)[    0.789697] smpboot: CPU0: AMD Ryzen 7 5800H with Radeon Graphics (family: 0x19, model: 0x50, stepping: 0x0)[    0.790536] RCU Tasks: Setting shift to 7 and lim to 1 rcu_task_cb_adjust&#x3D;1.[    0.790593] RCU Tasks Rude: Setting shift to 7 and lim to 1 rcu_task_cb_adjust&#x3D;1.[    0.790723] RCU Tasks Trace: Setting shift to 7 and lim to 1 rcu_task_cb_adjust&#x3D;1.[    0.790843] Performance Events: AMD PMU driver.[    0.790906] ... version:                0[    0.790907] ... bit width:              48[    0.790908] ... generic registers:      4[    0.790909] ... value mask:             0000ffffffffffff[    0.790911] ... max period:             00007fffffffffff[    0.790912] ... fixed-purpose events:   0[    0.790913] ... event mask:             000000000000000f[    0.791102] signal: max sigframe size: 1776[    0.791185] rcu: Hierarchical SRCU implementation.[    0.791187] rcu: Max phase no-delay instances is 1000.[    0.793187] NMI watchdog: Enabled. Permanently consumes one hw-PMU counter. <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>SMP机制初始化</li></ol><pre class="line-numbers language-none"><code class="language-none">[    0.800248] smp: Bringing up secondary CPUs ...[    0.800841] smpboot: x86: Booting SMP configuration:[    0.800843] .... node  #0, CPUs:          #1   #2   #3。。。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>DMA（也就是内存外存直通车机制）初始化</li></ol><pre class="line-numbers language-none"><code class="language-none">[    0.820223] DMA: preallocated 1024 KiB GFP_KERNEL pool for atomic allocations[    0.821769] DMA: preallocated 1024 KiB GFP_KERNEL|GFP_DMA pool for atomic allocations[    0.823306] DMA: preallocated 1024 KiB GFP_KERNEL|GFP_DMA32 pool for atomic allocations[    0.823317] audit: initializing netlink subsys (disabled)# 这里安排了为DMA提供多大内存映射！1MB大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>接入外设，初始化PCI总线上的一大堆设备：</li></ol><pre class="line-numbers language-none"><code class="language-none">[    0.835739] ACPI: Added _OSI(Module Device)[    0.835741] ACPI: Added _OSI(Processor Device)[    0.835742] ACPI: Added _OSI(3.0 _SCP Extensions)[    0.835744] ACPI: Added _OSI(Processor Aggregator Device)[    0.868436] ACPI: 1 ACPI AML tables successfully acquired and loaded[    0.872132] ACPI: [Firmware Bug]: BIOS _OSI(Linux) query ignored[    0.872143] ACPI: BIOS _OSI(Darwin) query ignored[    0.875392] ACPI: _OSC evaluation for CPUs failed, trying _PDC[    0.907570] ACPI: Interpreter enabled[    0.907586] ACPI: PM: (supports S0 S1 S4 S5)[    0.907588] ACPI: Using IOAPIC for interrupt routing[    0.908436] PCI: ECAM [mem 0xe0000000-0xe7ffffff] (base 0xe0000000) for domain 0000 [bus 00-7f][    0.909374] PCI: ECAM [mem 0xe0000000-0xe7ffffff] reserved as ACPI motherboard resource[    0.909386] PCI: Using host bridge windows from ACPI; if necessary, use &quot;pci&#x3D;nocrs&quot; and report a bug[    0.909387] PCI: Using E820 reservations for host bridge windows[    0.911491] ACPI: Enabled 4 GPEs in block 00 to 0F[    1.192489] ACPI: PCI Root Bridge [PCI0] (domain 0000 [bus 00-7f])[    1.192498] acpi PNP0A03:00: _OSC: OS supports [ExtendedConfig ASPM ClockPM Segments MSI EDR HPX-Type3][    1.192627] acpi PNP0A03:00: _OSC: platform does not support [AER LTR DPC][    1.192968] acpi PNP0A03:00: _OSC: OS now controls [PCIeHotplug SHPCHotplug PME PCIeCapability][    1.194177] PCI host bridge to bus 0000:00[    1.194180] pci_bus 0000:00: root bus resource [io  0x0d00-0xffff window][    1.194182] pci_bus 0000:00: root bus resource [io  0x0000-0x0cf7 window][    1.194184] pci_bus 0000:00: root bus resource [mem 0xfef00000-0xffdfffff window]...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>再一次排查内存，APIC和PIC总线设备映射了一些内存到RAM上，这就要求我们务必再一次排查内存</li></ol><pre class="line-numbers language-none"><code class="language-none">[    1.659318] e820: reserve RAM buffer [mem 0x0c2c6018-0x0fffffff][    1.659336] e820: reserve RAM buffer [mem 0x0e609018-0x0fffffff][    1.659338] e820: reserve RAM buffer [mem 0x0e60b018-0x0fffffff][    1.659339] e820: reserve RAM buffer [mem 0x0e656000-0x0fffffff][    1.659341] e820: reserve RAM buffer [mem 0x0efab000-0x0fffffff][    1.659342] e820: reserve RAM buffer [mem 0x0efbd000-0x0fffffff][    1.659343] e820: reserve RAM buffer [mem 0x0fee6000-0x0fffffff]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>开始注册IRQ，你熟悉的</li></ol><pre class="line-numbers language-none"><code class="language-none">[    1.422344] ACPI: PCI: Interrupt link LNKA configured for IRQ 0[    1.422346] ACPI: PCI: Interrupt link LNKA disabled # 顺手disable了！这个时候内核还在初始化[    1.422428] ACPI: PCI: Interrupt link LNKB configured for IRQ 0[    1.422430] ACPI: PCI: Interrupt link LNKB disabled[    1.422508] ACPI: PCI: Interrupt link LNKC configured for IRQ 0[    1.422510] ACPI: PCI: Interrupt link LNKC disabled[    1.422591] ACPI: PCI: Interrupt link LNKD configured for IRQ 0[    1.422594] ACPI: PCI: Interrupt link LNKD disabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>并行的，初始化网络子系统</li></ol><pre class="line-numbers language-none"><code class="language-none">[    1.720347] NET: Registered PF_INET protocol family[    1.722277] IP idents hash table entries: 131072 (order: 8, 1048576 bytes, linear)[    1.737287] tcp_listen_portaddr_hash hash table entries: 4096 (order: 4, 65536 bytes, linear)[    1.737307] Table-perturb hash table entries: 65536 (order: 6, 262144 bytes, linear)[    1.737335] TCP established hash table entries: 65536 (order: 7, 524288 bytes, linear)[    1.741297] TCP bind hash table entries: 65536 (order: 9, 2097152 bytes, linear)[    1.741392] TCP: Hash tables configured (established 65536 bind 65536)[    1.742373] MPTCP token hash table entries: 8192 (order: 5, 196608 bytes, linear)[    1.742400] UDP hash table entries: 4096 (order: 5, 131072 bytes, linear)[    1.742617] UDP-Lite hash table entries: 4096 (order: 5, 131072 bytes, linear)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    很多常见的协议这里就开始初始化工作了！这里初始化的是哈希表，干嘛的？之后网络服务分配端口用的！端口从这些hash table中取出来！</p><ol><li>初始化挂载文件系统：感谢我的一位大爹推介，我给root挂的是Brtfs，不是Ext4文件系统（），这里可以看到它把文件系统挂载在了sda3硬盘分区上，而且校验机制是32为CRC循环校验码</li></ol><pre class="line-numbers language-none"><code class="language-none">[    3.278244] Btrfs loaded, zoned&#x3D;yes, fsverity&#x3D;yes[    3.321572] BTRFS: device label ArchLinux devid 1 transid 3897 &#x2F;dev&#x2F;sda3 scanned by mount (191)[    3.322361] BTRFS info (device sda3): first mount of filesystem c6ae9e8b-6dd3-4a7b-99bf-fcedbd6ab74c[    3.322370] BTRFS info (device sda3): using crc32c (crc32c-intel) checksum algorithm [    3.322374] BTRFS info (device sda3): using free-space-tree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Systemd开始工作：</li></ol><pre class="line-numbers language-none"><code class="language-none">[    3.485381] systemd[1]: systemd 255.5-3-arch running in system mode (+PAM +AUDIT -SELINUX -APPARMOR -IMA +SMACK +SECCOMP +GCRYPT +GNUTLS +OPENSSL +ACL +BLKID +CURL +ELFUTILS +FIDO2 +IDN2 -IDN +IPTC +KMOD +LIBCRYPTSETUP +LIBFDISK +PCRE2 +PWQUALITY +P11KIT +QRENCODE +TPM2 +BZIP2 +LZ4 +XZ +ZLIB +ZSTD +BPF_FRAMEWORK +XKBCOMMON +UTMP -SYSVINIT default-hierarchy&#x3D;unified)[    3.485385] systemd[1]: Detected virtualization vmware.[    3.485444] systemd[1]: Detected architecture x86-64.[    3.487031] systemd[1]: Hostname set to &lt;ArchLinux&gt;.[    3.920722] systemd[1]: bpf-lsm: LSM BPF program attached[    4.211409] systemd[1]: Queued start job for default target Graphical Interface.[    4.258091] systemd[1]: Created slice Slice &#x2F;system&#x2F;dirmngr.[    4.258751] systemd[1]: Created slice Slice &#x2F;system&#x2F;getty.[    4.259320] systemd[1]: Created slice Slice &#x2F;system&#x2F;gpg-agent.[    4.259910] systemd[1]: Created slice Slice &#x2F;system&#x2F;gpg-agent-browser.[    4.260527] systemd[1]: Created slice Slice &#x2F;system&#x2F;gpg-agent-extra.[    4.261419] systemd[1]: Created slice Slice &#x2F;system&#x2F;gpg-agent-ssh.[    4.262026] systemd[1]: Created slice Slice &#x2F;system&#x2F;keyboxd.[    4.262596] systemd[1]: Created slice Slice &#x2F;system&#x2F;modprobe.[    4.263159] systemd[1]: Created slice User and Session Slice.[    4.263275] systemd[1]: Started Forward Password Requests to Wall Directory Watch.[    4.263462] systemd[1]: Set up automount Arbitrary Executable File Formats File System Automount Point.[    4.263503] systemd[1]: Expecting device &#x2F;dev&#x2F;disk&#x2F;by-...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    这里开始就是启动守护进程来观察剩下的子系统的建立：比如说文件系统的彻底初始化，网络子系统的彻底初始化</p><pre class="line-numbers language-none"><code class="language-none">[    4.263527] systemd[1]: Reached target Login Prompts.# 登录脚本获取[    4.263537] systemd[1]: Reached target Local Integrity Protected Volumes.[    4.263553] systemd[1]: Reached target Remote File Systems.[    4.263559] systemd[1]: Reached target Slice Units.[    4.263575] systemd[1]: Reached target Local Verity Protected Volumes.[    4.263645] systemd[1]: Listening on Device-mapper event daemon FIFOs.[    4.266006] systemd[1]: Listening on Process Core Dump Socket.[    4.266159] systemd[1]: Listening on Journal Socket (&#x2F;dev&#x2F;log).[    4.266275] systemd[1]: Listening on Journal Socket.[    4.266305] systemd[1]: TPM2 PCR Extension (Varlink) was skipped because of an unmet condition check (ConditionSecurity&#x3D;measured-uki).[    4.267123] systemd[1]: Listening on udev Control Socket. # udev程序开始工作：udev管理设备接入的[    4.267225] systemd[1]: Listening on udev Kernel Socket.[    4.267324] systemd[1]: Listening on User Database Manager Socket.[    4.269352] systemd[1]: Mounting Huge Pages File System...[    4.271193] systemd[1]: Mounting POSIX Message Queue File System...[    4.272566] systemd[1]: Mounting Kernel Debug File System...[    4.275675] systemd[1]: Mounting Kernel Trace File System...[    4.277280] systemd[1]: Starting Create List of Static Device Nodes...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>内核模块挂载功能的初始化，已经注册的模块的初始化</li></ol><pre class="line-numbers language-none"><code class="language-none">[    4.278792] systemd[1]: Starting Load Kernel Module configfs... # 开始初始化内核模块挂载初始化[    4.282344] systemd[1]: Starting Load Kernel Module dm_mod...[    4.287784] systemd[1]: Starting Load Kernel Module drm...[    4.291169] systemd[1]: Starting Load Kernel Module fuse...[    4.295357] systemd[1]: Starting Load Kernel Module loop...[    4.300246] systemd[1]: Starting Journal Service...[    4.303957] systemd[1]: Starting Load Kernel Modules...[    4.303970] systemd[1]: TPM2 PCR Machine ID Measurement was skipped because of an unmet condition check (ConditionSecurity&#x3D;measured-uki).[    4.311843] device-mapper: uevent: version 1.0.3[    4.311964] loop: module loaded[    4.312243] systemd[1]: Starting Remount Root and Kernel File Systems...[    4.312276] systemd[1]: TPM2 SRK Setup (Early) was skipped because of an unmet condition check (ConditionSecurity&#x3D;measured-uki).[    4.312986] device-mapper: ioctl: 4.48.0-ioctl (2023-03-01) initialised: dm-devel@redhat.com[    4.314481] systemd[1]: Starting Coldplug All udev Devices...[    4.317552] systemd[1]: Starting Virtual Console Setup...[    4.319302] systemd[1]: Mounted Huge Pages File System.[    4.319416] systemd[1]: Mounted POSIX Message Queue File System.[    4.319518] systemd[1]: Mounted Kernel Debug File System.[    4.319620] systemd[1]: Mounted Kernel Trace File System.[    4.319938] systemd[1]: Finished Create List of Static Device Nodes.[    4.320293] systemd[1]: modprobe@configfs.service: Deactivated successfully.[    4.320449] systemd[1]: Finished Load Kernel Module configfs.[    4.320851] systemd[1]: modprobe@dm_mod.service: Deactivated successfully.[    4.321003] systemd[1]: Finished Load Kernel Module dm_mod.[    4.321329] systemd[1]: modprobe@drm.service: Deactivated successfully.[    4.321523] systemd[1]: Finished Load Kernel Module drm.[    4.321818] systemd[1]: modprobe@fuse.service: Deactivated successfully.[    4.321968] systemd[1]: Finished Load Kernel Module fuse.[    4.322270] systemd[1]: modprobe@loop.service: Deactivated successfully.[    4.322431] systemd[1]: Finished Load Kernel Module loop.[    4.322464] systemd-journald[246]: Collecting audit messages is disabled.[    4.327584] systemd[1]: Mounting FUSE Control File System...[    4.331144] systemd[1]: Mounting Kernel Configuration File System...[    4.331197] systemd[1]: Repartition Root Disk was skipped because no trigger condition checks were met.[    4.333564] BTRFS info (device sda3: state M): use zstd compression, level 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>最后的最后，我们使用已经初始化完成的设备管理子系统接入诸如声卡，网卡，蓝牙等设备</li></ol><pre class="line-numbers language-none"><code class="language-none">[    5.160970] e1000: Intel(R) PRO&#x2F;1000 Network Driver[    5.160973] e1000: Copyright (c) 1999-2006 Intel Corporation.[    5.161298] e1000 0000:02:01.0: enabling device (0110 -&gt; 0113)[    5.166576] Guest personality initialized and is active[    5.166621] VMCI host device registered (name&#x3D;vmci, major&#x3D;10, minor&#x3D;123)[    5.166623] Initialized host personality# 声卡[    5.199128] input: PC Speaker as &#x2F;devices&#x2F;platform&#x2F;pcspkr&#x2F;input&#x2F;input4[    5.252008] input: VirtualPS&#x2F;2 VMware VMMouse as &#x2F;devices&#x2F;platform&#x2F;i8042&#x2F;serio1&#x2F;input&#x2F;input6[    5.252656] input: VirtualPS&#x2F;2 VMware VMMouse as &#x2F;devices&#x2F;platform&#x2F;i8042&#x2F;serio1&#x2F;input&#x2F;input5[    5.327777] cryptd: max_cpu_qlen set to 1000[    5.370835] Bluetooth: Core ver 2.22[    5.370927] NET: Registered PF_BLUETOOTH protocol family# 蓝牙[    5.370929] Bluetooth: HCI device and connection manager initialized[    5.370933] Bluetooth: HCI socket layer initialized[    5.370935] Bluetooth: L2CAP socket layer initialized[    5.370939] Bluetooth: SCO socket layer initialized[    5.375620] AVX2 version of gcm_enc&#x2F;dec engaged.[    5.376048] AES CTR mode by8 optimization enabled[    5.424872] snd_ens1371 0000:02:02.0: enabling device (0000 -&gt; 0001)[    5.430767] usbcore: registered new interface driver btusb[    5.478456] Bluetooth: hci0: unexpected cc 0x0c12 length: 2 &lt; 3[    5.478467] Bluetooth: hci0: Opcode 0x0c12 failed: -38# 抓到的网卡配置，可以ifconfig查看[    5.613099] e1000 0000:02:01.0 eth0: (PCI:66MHz:32-bit) 00:0c:29:dc:f5:a8[    5.613109] e1000 0000:02:01.0 eth0: Intel(R) PRO&#x2F;1000 Network Connection[    5.623326] e1000 0000:02:01.0 ens33: renamed from eth0[    5.654147] e1000: ens33 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: None[    6.446371] bridge: filtering via arp&#x2F;ip&#x2F;ip6tables is no longer available by default. Update your scripts to load br_netfilter if you need this.[    6.451480] Bridge firewalling registered[    6.555526] Initializing XFRM netlink socket[   74.611975] systemd-journald[246]: &#x2F;var&#x2F;log&#x2F;journal&#x2F;deaaebab639c462183f85623319ae5fc&#x2F;user-1000.journal: Journal file uses a different sequence number ID, rotating.[  273.008400] systemd[1]: systemd 255.5-4-arch running in system mode (+PAM +AUDIT -SELINUX -APPARMOR -IMA +SMACK +SECCOMP +GCRYPT +GNUTLS +OPENSSL +ACL +BLKID +CURL +ELFUTILS +FIDO2 +IDN2 -IDN +IPTC +KMOD +LIBCRYPTSETUP +LIBFDISK +PCRE2 +PWQUALITY +P11KIT +QRENCODE +TPM2 +BZIP2 +LZ4 +XZ +ZLIB +ZSTD +BPF_FRAMEWORK +XKBCOMMON +UTMP -SYSVINIT default-hierarchy&#x3D;unified)[  273.008505] systemd[1]: Detected virtualization vmware.[  273.008596] systemd[1]: Detected architecture x86-64.[  273.424093] systemd[1]: bpf-lsm: LSM BPF program attached[  352.419139] perf: interrupt took too long (2590 &gt; 2500), lowering kernel.perf_event_max_sample_rate to 77100[  390.817032] perf: interrupt took too long (3500 &gt; 3237), lowering kernel.perf_event_max_sample_rate to 57000[  527.871009] perf: interrupt took too long (4415 &gt; 4375), lowering kernel.perf_event_max_sample_rate to 45300<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到此位置，整个系统初始化完成，可以登录了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机Arch Linux With KDE6(x11)安装小记</title>
      <link href="/2024/03/20/ArchLinux%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
      <url>/2024/03/20/ArchLinux%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机Arch-Linux-With-KDE6-x11-安装小记"><a href="#虚拟机Arch-Linux-With-KDE6-x11-安装小记" class="headerlink" title="虚拟机Arch Linux With KDE6(x11)安装小记"></a>虚拟机Arch Linux With KDE6(x11)安装小记</h1><h2 id="写在前言"><a href="#写在前言" class="headerlink" title="写在前言"></a>写在前言</h2><p>​    此篇博客记载了笔者安装ArchLinux的基础步骤和安装教程，供各位看官参考和评判。</p><p>​    环境：Windows11下的VMWare虚拟机安装2024年3月初发行的Linux 6.8.1Kernel，安装的固件类型是<strong>UEFI安装</strong>而不是BIOS安装</p><p>​    配置导向：</p><blockquote><p>分区简单：UEFI分区（300M） + Swap(4G) + FileSystem(Btrfs)(75.6G)</p></blockquote><h2 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h2><h3 id="I-开始"><a href="#I-开始" class="headerlink" title="I. 开始"></a>I. 开始</h3><p>​    在安装结束VMWare虚拟机之后，诸位如果想要下载Arch Linux ISO，可以前往：</p><blockquote><p><a href="https://archlinux.org/download/"><code>Arch Linux - Downloads</code></a></p><p>下的中国源：</p><ul><li><a href="https://mirrors.aliyun.com/archlinux/iso/2024.03.01/"><code>aliyun.com</code></a></li><li>…</li></ul><p>进行下载</p></blockquote><p>​    下载结束之后，记住自己存放的ISO的位置，随后打开VMWare WorkStation，走过一次典型的虚拟机安装教程。这里给出笔者的配置：</p><p><img src="image-20240319194216766.png" alt="image-20240319194216766"></p><p>​    值得注意的是，请务必保证自己的内存不要小于1GB，否则Arch Linux Installer将会无法装进内存导致无法安装！</p><p>​    <strong>请设置我们的开机方式为UEFI而不是BIOS!当然想要查询BIOS方式也有专门的博客进行介绍</strong></p><p>​    我们的第一步就是禁用refleactor服务（它会自己更新 <code>mirrorlist</code>（软件包管理器 <code>pacman</code> 的软件源）），因为一些原因，他可能会误删我们手动配置好的国内源！（但是笔者的三次安装中两次我没有禁，事实上没有什么太大的影响，不过，如果发现下载速度过慢了还是禁掉！然后手动配置国内源）</p><pre class="line-numbers language-none"><code class="language-none">systemctl stop reflector.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    Systemd是一个系统管理守护进程、工具和库的集合，可以简单的认为：他就是我们系统守护进程的管理器。</p><p><img src="bg2016030703.png" alt="img"></p><pre class="line-numbers language-none"><code class="language-none"># 立即启动一个服务$ sudo systemctl start apache.service# 立即停止一个服务$ sudo systemctl stop apache.service# 设置服务开机自启动$ sudo systemctl enable some.service# 重启一个服务$ sudo systemctl restart apache.service# 杀死一个服务的所有子进程$ sudo systemctl kill apache.service# 重新加载一个服务的配置文件$ sudo systemctl reload apache.service# 重载所有修改过的配置文件$ sudo systemctl daemon-reload# 显示某个 Unit 的所有底层参数$ systemctl show httpd.service# 显示某个 Unit 的指定属性的值$ systemctl show -p CPUShares httpd.service# 设置某个 Unit 的指定属性$ sudo systemctl set-property httpd.service CPUShares&#x3D;500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    如你所见，这些指令在我们的配置路途上将会常常遇到。我们这里就是设置reflector服务程序暂停。</p><p>​    良好的习惯是：看我们的服务有没有真正暂停，确保我们这一步正确</p><pre class="line-numbers language-none"><code class="language-none">systemctl status reflector.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    预期的讲：status应该是failed的！</p><h3 id="II-网络"><a href="#II-网络" class="headerlink" title="II. 网络"></a>II. 网络</h3><p>​    下一步，我们再三的确认我们的启动方式是UEFI方式，很简单：</p><pre class="line-numbers language-none"><code class="language-none">ls &#x2F;sys&#x2F;firmware&#x2F;efi&#x2F;efivars<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    在这里，如果你的shell可以自动补全上述的路径，实际上就是说明我们的确是UEFI方式启动。输出一下</p><p><img src="image-20240319122704119.png" alt="image-20240319122704119"></p><p>​    下一步，就是连接网络，对于虚拟机，我们无需关心，只需要确认我们的桥接或者是NAT方式的连接使得虚拟机可以利用主机的网络配置向外交互就行：</p><pre class="line-numbers language-none"><code class="language-none">ping baidu.com # PING一下看看<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <img src="image-20240319123856904.png" alt="image-20240319123856904"></p><p>​    ping不同，可以首先尝试重启虚拟机，或者检查一下在主机上的VMWare网络服务是否开启，没有开启开一下（这里不再赘述如何打开服务了，抛hostname无法解析可能是DNS配置出现问题）</p><h3 id="III-开启NTP时钟校验"><a href="#III-开启NTP时钟校验" class="headerlink" title="III.开启NTP时钟校验"></a>III.开启NTP时钟校验</h3><p>​    大部分软件可能对事件敏感，这里启动一下ntp时钟校验</p><pre class="line-numbers language-none"><code class="language-none">timedatectl set-ntp true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>timedatectl也是systemd的一个子集指令集</p></blockquote><pre class="line-numbers language-none"><code class="language-none">timedatectl status <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240319124014490.png" alt="image-20240319124014490"></p><h3 id="IV-设置国内源"><a href="#IV-设置国内源" class="headerlink" title="IV. 设置国内源"></a>IV. 设置国内源</h3><p>​    使用 <code>vim</code> 编辑器修改 <code>/etc/pacman.d/mirrorlist</code> 文件。将 <code>pacman</code> 软件仓库源更换为国内软件仓库镜像源：</p><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    一些常见的国内源</p><pre class="line-numbers language-none"><code class="language-none">Server &#x3D; https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch # 中国科学技术大学开源镜像站Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch # 清华大学开源软件镜像站<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20240319124141856.png" alt="image-20240319124141856"></p><blockquote><p>使用Vim：摁一下 <code>i</code> 进入输入模式，输入结束之后ESC键摁一下回到命令行模式，输入 <code>:wq</code> 表示<code>write and quit</code></p></blockquote><h3 id="V-配置分区与文件系统"><a href="#V-配置分区与文件系统" class="headerlink" title="V. 配置分区与文件系统"></a>V. 配置分区与文件系统</h3><p>​    下一步就是查看一下文件块的信息如何了：</p><p><img src="image-20240319124204765.png" alt="image-20240319124204765"></p><p>​    可以看到我们的sda0就是我们的目标硬盘，对他分区！</p><pre class="line-numbers language-none"><code class="language-none">cfdisk &#x2F;dev&#x2F;sda<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    对了，一些博主喜欢使用fdisk干分区，我的评价是：喜欢命令行就那样做，担心出错就这个。</p><blockquote></blockquote><p>​    选择gpt分区后，开始分区。</p><blockquote><p>选择Free Space之后，光标会提示你输入大小：只需要数字 + 单位即可，然后分完之后光标切到type处选择对应的type就行</p></blockquote><p>具体如何分，笔者的配置是如下的：</p><blockquote><p>sda1 : EFI System    300M</p><p>sda2：Linux Swap    4G</p><p>sda3：Linux filesystem 75.7G</p></blockquote><p><img src="image-20240319124300888.png" alt="image-20240319124300888"></p><p>​    分完长上面那样，然后光标选中write后提示你输入yes表示确认，随后quit处出cfdisk</p><p>​    我们使用fdisk确认我们的分区：</p><p><img src="image-20240319124423859.png" alt="image-20240319124423859"></p><p>​    很好！</p><p>​    下一步就是格式化各个文件块：</p><blockquote><p>使用FAT32格式格式化EFI引导</p><pre class="line-numbers language-none"><code class="language-none">mkfs.fat -F32 &#x2F;dev&#x2F;sda1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用swap格式格式化swap分区</p><pre class="line-numbers language-none"><code class="language-none">mkswap &#x2F;dev&#x2F;sda2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们这次选用的是较新的btrfs文件系统格式化剩下的硬盘</p><pre class="line-numbers language-none"><code class="language-none">mkfs.btrfs -L ArchLinux &#x2F;dev&#x2F;sda3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-L</code> 选项后指定该分区的 <code>LABLE</code>，这里以 <code>ArchLinux</code> 为例，也可以自定义，但不能使用特殊字符以及空格，且最好有意义</li></ul></blockquote><p><img src="image-20240319124557960.png" alt="image-20240319124557960"></p><pre class="line-numbers language-none"><code class="language-none">btrfs的特性：首先是扩展性 (scalability) 相关的特性，btrfs 最重要的设计目标是应对大型机器对文件系统的扩展性要求。 Extent，B-Tree 和动态 inode 创建等特性保证了 btrfs 在大型机器上仍有卓越的表现，其整体性能而不会随着系统容量的增加而降低。其次是数据一致性 (data integrity) 相关的特性。系统面临不可预料的硬件故障，Btrfs 采用 COW 事务技术来保证文件系统的一致性。 btrfs 还支持 checksum，避免了 silent corrupt 的出现。而传统文件系统则无法做到这一点。第三是和多设备管理相关的特性。 Btrfs 支持创建快照 (snapshot)，和克隆 (clone) 。 btrfs 还能够方便的管理多个物理设备，使得传统的卷管理软件变得多余。最后是其他难以归类的特性。这些特性都是比较先进的技术，能够显著提高文件系统的时间 &#x2F; 空间性能，包括延迟分配，小文件的存储优化，目录索引等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>一些ref:</p><p><a href="https://zhuanlan.zhihu.com/p/61407714">Linux 文件系统的未来 btrfs - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/taoxicun/article/details/122878090">Btrfs 与 Ext4 - 功能、优势和劣势_btrfs和ext4-CSDN博客</a></p></blockquote><p>​    下一步就是创建子卷：创建之前，我们需要挂载一下分区：</p><pre class="line-numbers language-none"><code class="language-none">mount -t btrfs -o compress&#x3D;zstd &#x2F;dev&#x2F;sda3 &#x2F;mnt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240319124700796.png" alt="image-20240319124700796"></p><blockquote><p>mount作为挂载指令：你可以认为挂载是将设备等视作文件往里刻录东西之前的准备操作，就像你插入优盘Windows来对他进行操作的预备工作那样理解</p></blockquote><p>​    我们使用的是btrfs来操作，所以后面的参数就是指定我们如何压缩存储到磁盘上面的：</p><blockquote><ul><li>zstd</li><li>lzo</li><li>zlib</li></ul></blockquote><p>​    这些算法是可以被选择的，你可以查看后选择你希望的算法进行压缩</p><pre class="line-numbers language-none"><code class="language-none">btrfs subvolume create &#x2F;mnt&#x2F;@ # 创建 &#x2F; 目录子卷btrfs subvolume create &#x2F;mnt&#x2F;@home # 创建 &#x2F;home 目录子卷btrfs subvolume list -p &#x2F;mnt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20240319124804747.png" alt="image-20240319124804747"></p><p>​    在挂载时，挂载是有顺序的，需要从根目录开始挂载。使用如下命令挂载子卷：</p><pre class="line-numbers language-none"><code class="language-none">mount -t btrfs -o subvol&#x3D;&#x2F;@,compress&#x3D;zstd &#x2F;dev&#x2F;sda3 &#x2F;mnt # 挂载 &#x2F; 目录mkdir &#x2F;mnt&#x2F;home # 创建 &#x2F;home 目录mount -t btrfs -o subvol&#x3D;&#x2F;@home,compress&#x3D;zstd &#x2F;dev&#x2F;sda3 &#x2F;mnt&#x2F;home # 挂载 &#x2F;home 目录mkdir -p &#x2F;mnt&#x2F;boot&#x2F;efi # 创建 &#x2F;boot&#x2F;efi 目录mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;boot&#x2F;efi # 挂载 &#x2F;boot&#x2F;efi 目录swapon &#x2F;dev&#x2F;sda2 # 挂载交换分区df -h # 查看挂载情况free -h # 查看交换是否开启<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20240319125104714.png" alt="image-20240319125104714"></p><p><img src="image-20240319125121138.png" alt="image-20240319125121138">    </p><h3 id="VI-安装系统"><a href="#VI-安装系统" class="headerlink" title="VI. 安装系统"></a>VI. 安装系统</h3><p>​    开始安装系统！</p><pre class="line-numbers language-none"><code class="language-none">pacstrap &#x2F;mnt base base-devel linux linux-firmware btrfs-progs# 如果使用btrfs文件系统，额外安装一个btrfs-progs包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>base-devel</code> —— <code>base-devel</code> 在 <code>AUR</code> 包的安装过程中是必须用到的</li><li><code>linux</code> —— 内核软件包，这里建议先不要替换为其它内核</li></ul><p><img src="image-20240319125232674.png" alt="image-20240319125232674"></p><p>​    以及请务必安装下面的东西，这是为了稍后操作方便</p><pre class="line-numbers language-none"><code class="language-none">pacstrap &#x2F;mnt networkmanager vim sudo <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    至于：</p><pre class="line-numbers language-none"><code class="language-none">pacstrap &#x2F;mnt zsh zsh-completions<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    中是喜欢bash还是zsh还是fish啥的，看自己需求来。个人当时这里看到missing class的zsh很帅就安装了zsh(划去</p><h3 id="VII-生成-fstab-文件"><a href="#VII-生成-fstab-文件" class="headerlink" title="VII.生成 fstab 文件"></a>VII.生成 fstab 文件</h3><p>​    <code>fstab</code> 用来定义磁盘分区。它是 Linux 系统中重要的文件之一。使用 <code>genfstab</code> 自动根据当前挂载情况生成并写入 <code>fstab</code> 文件：</p><pre class="line-numbers language-none"><code class="language-none">genfstab -U &#x2F;mnt &gt; &#x2F;mnt&#x2F;etc&#x2F;fstab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    复查一下 <code>/mnt/etc/fstab</code> 确保没有错误：</p><pre class="line-numbers language-none"><code class="language-none">cat &#x2F;mnt&#x2F;etc&#x2F;fstab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240319125705793.png" alt="image-20240319125705793"></p><h3 id="VIII-切换root与配置新root"><a href="#VIII-切换root与配置新root" class="headerlink" title="VIII. 切换root与配置新root"></a>VIII. 切换root与配置新root</h3><p>​    很快了！</p><pre class="line-numbers language-none"><code class="language-none">arch-chroot &#x2F;mnt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240319125729743.png" alt="image-20240319125729743"></p><p>​    首先在 <code>/etc/hostname</code> 设置主机名：</p><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;hostname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这个看自己喜欢啥名字都行！这是我的：</p><pre class="line-numbers language-none"><code class="language-none">ArchLinux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><ol><li>接下来在 <code>/etc/hosts</code> 设置与其匹配的条目：</li></ol><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加入如下内容：</p><p><img src="image-20240319125917955.png" alt="image-20240319125917955"></p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1   localhost::1         localhost127.0.1.1   ArchLinux.localdomain ArchLinux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>某些情况下如不设置主机名，在 KDE 下可能会存在网络情况变更时无法启动 GUI 应用的问题，在终端中出现形如 <code>No protocol specified qt.qpa.xcb: could not connect to display</code> 的错误。这种情况极为少见。</p></blockquote><p>​    设置时区，在 <code>/etc/localtime</code> 下用 <code>/usr</code> 中合适的时区创建符号链接：</p><pre class="line-numbers language-none"><code class="language-none">ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    以及同步一下硬件时钟</p><pre class="line-numbers language-none"><code class="language-none">hwclock --systohc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240319130026863.png" alt="image-20240319130026863"></p><h3 id="IX-设置-locale"><a href="#IX-设置-locale" class="headerlink" title="IX. 设置 locale"></a>IX. 设置 locale</h3><p>​    <code>Locale</code> 决定了软件使用的语言、书写习惯和字符集。编辑 <code>/etc/locale.gen</code>，去掉 <code>en_US.UTF-8 UTF-8</code> 以及 <code>zh_CN.UTF-8 UTF-8</code> 行前的注释符号（<code>#</code>）：</p><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;locale.gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在命令行模式下输入/ + 查询前缀可以快速定位！摁Enter表示接受查询让光标不再跟着走！</p></blockquote><p>​    然后生成locale文件：</p><pre class="line-numbers language-none"><code class="language-none">locale-gen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240319130143841.png" alt="image-20240319130143841"></p><p>​    为防止奇怪的乱码出现：</p><pre class="line-numbers language-none"><code class="language-none">echo &#39;LANG&#x3D;en_US.UTF-8&#39;  &gt; &#x2F;etc&#x2F;locale.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="X-为-root-用户设置密码"><a href="#X-为-root-用户设置密码" class="headerlink" title="X.为 root 用户设置密码"></a>X.为 root 用户设置密码</h3><pre class="line-numbers language-none"><code class="language-none">passwd root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="XI-安装微码与引导（容易出错）"><a href="#XI-安装微码与引导（容易出错）" class="headerlink" title="XI.安装微码与引导（容易出错）"></a>XI.<strong>安装微码与引导（容易出错）</strong></h3><p>​    安装对应芯片制造商的微码（自行查询自己的cpu是base what的）</p><pre class="line-numbers language-none"><code class="language-none">pacman -S intel-ucode # Intelpacman -S amd-ucode # AMD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    安装引导包</p><pre class="line-numbers language-none"><code class="language-none">pacman -S grub efibootmgr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-S</code> 选项后指定要通过 <code>pacman</code> 包管理器安装的包：</p><ul><li><code>grub</code> —— 启动引导器</li><li><code>efibootmgr</code> —— <code>efibootmgr</code> 被 <code>grub</code> 脚本用来将启动项写入 NVRAM</li></ul><p>​    安装 <code>GRUB</code> 到 <code>EFI</code> 分区：</p><pre class="line-numbers language-none"><code class="language-none">grub-install --target&#x3D;x86_64-efi --efi-directory&#x3D;&#x2F;boot&#x2F;efi --bootloader-id&#x3D;ARCH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>--efi-directory=/boot</code>/efi —— <strong>将 <code>grubx64.efi</code> 安装到之前的指定位置（EFI 分区）</strong></li><li><code>--bootloader-id=ARCH</code> —— 取名为 <code>ARCH</code></li></ul><p><img src="image-20240319130516016.png" alt="image-20240319130516016"></p><p>​    如果出来似乎不是efi分区的错误，要么看自己的efi挂载在哪里了，要么看看自己有没有分efi出来（乐）</p><p>​    最后生成 <code>GRUB</code> 所需的配置文件：</p><pre class="line-numbers language-none"><code class="language-none">grub-mkconfig -o &#x2F;boot&#x2F;grub&#x2F;grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240319192613536.png" alt="image-20240319192613536"></p><p>​    完事：</p><pre class="line-numbers language-none"><code class="language-none">exit # 退回安装环境umount -R &#x2F;mnt # 卸载新分区reboot # 重启<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    重启后使用 root 账户登录系统：</p><p><img src="image-20240319192703265.png" alt="image-20240319192703265"></p><p><img src="image-20240319192725987.png" alt="image-20240319192725987"></p><p>​    设置开机自启并立即启动 networkmanager 服务，即可连接网络：</p><pre class="line-numbers language-none"><code class="language-none">systemctl enable --now NetworkManager # 设置开机自启并立即启动 NetworkManager 服务<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    ping一下网络？</p><p><img src="image-20240319192803637.png" alt="image-20240319192803637"></p><h3 id="Fin-整个花活"><a href="#Fin-整个花活" class="headerlink" title="Fin.整个花活"></a>Fin.整个花活</h3><pre class="line-numbers language-none"><code class="language-none">pacman -S neofetch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240319192825175.png" alt="image-20240319192825175"></p><p>​    完事咯！</p><h2 id="KDE6-安装配置"><a href="#KDE6-安装配置" class="headerlink" title="KDE6 安装配置"></a>KDE6 安装配置</h2><p>​    哈？不稀罕命令行？来整KDE6!</p><p><img src="image-20240319192953511.png" alt="image-20240319192953511"></p><p>​    先更新一下包管理！</p><p>​    注意，我们的KDE进入需要一个User用户，在Linux下添加一个用户的方式是：</p><pre class="line-numbers language-none"><code class="language-none">useradd -m edit_UserName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    比如说：</p><p><img src="image-20240319193142194.png" alt="image-20240319193142194"></p><p>​    下面为他设置密码：</p><pre class="line-numbers language-none"><code class="language-none">passwd edit_UserName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    给我们新建的用户一个可以使用sudo的机会</p><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    在这个配置文件中写入：用户名称 <code>ALL=(ALL)ALL</code></p><p><img src="image-20240319193241453.png" alt="image-20240319193241453"></p><p>​    下面就是安装大的：</p><pre class="line-numbers language-none"><code class="language-none">pacman -S xorg plasma kde-applications<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240319193401104.png" alt="image-20240319193401104"></p><blockquote><p>PS:一些老教程要求你也安装plasma-wayland-session，但是现在已经转正进入plasma了，不要安装了：</p><p>参考博客<code>:&gt;</code></p><p><a href="https://bbs.archlinux.org/viewtopic.php?pid=2156234">install archlinux kde error target not found plasma-wayland-session / Arch Linux Guided Installer / Arch Linux Forums</a></p></blockquote><p>​    好了喝口茶吧，得个几分钟。</p><pre class="line-numbers language-none"><code class="language-none">systemctl enable sddm.service # 启用显示管理器systemctl status NetworkManager.service # 检查网络管理器服务，确认他已经开启开机自启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    重启：</p><pre class="line-numbers language-none"><code class="language-none">reboot<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    好了！使用你刚刚创建的用户登录它！结束KDE的基础配置！</p><h2 id="KDE进阶配置"><a href="#KDE进阶配置" class="headerlink" title="KDE进阶配置"></a>KDE进阶配置</h2><p>​    到这里，如果你还想继续配置可以继续跟随我的步伐：</p><h3 id="I-设置屏幕分辨率"><a href="#I-设置屏幕分辨率" class="headerlink" title="I. 设置屏幕分辨率"></a>I. 设置屏幕分辨率</h3><p>打开<code>System Setting（桌面底下从左向右数第二个） -&gt; Display and Monitor -&gt; Display Configuration</code></p><h3 id="II-archlinuxcn源"><a href="#II-archlinuxcn源" class="headerlink" title="II. archlinuxcn源"></a>II. archlinuxcn源</h3><p>​    该仓库是由archlinux中文社区驱动的一个非官方的软件仓库。编辑<code>/etc/pacman.conf：</code></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">sudo vim /etc/pacman.conf-------------------------------------------# 在最后添加[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    <img src="image-20240319195728856.png" alt="image-20240319195728856"></p><p>​    顺嘴一提：如果你只是一个普通用户，不需要强验证ringKey的话，考虑将SigLevel设置为Never（虚拟机不怕（乐））</p><p><img src="image-20240319195626822.png" alt="image-20240319195626822"></p><p>​    否则等会下包的时候会频繁的要求你添加信任的开发者。</p><h3 id="III-安装中文字体-fcitx5输入法"><a href="#III-安装中文字体-fcitx5输入法" class="headerlink" title="III. 安装中文字体 + fcitx5输入法"></a>III. 安装中文字体 + fcitx5输入法</h3><p>​    下一步就是安装中文字体和fcitx5输入法了。请注意的是，这里有两套诸位可以选择的配置：</p><blockquote><p>fcitx + sogoupinyin</p></blockquote><pre class="line-numbers language-none"><code class="language-none">yay -S fcitx fcitx-im fcitx-configtool fcitx-sogoupinyin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>fcitx5（笔者的配置是这个）</p></blockquote><pre class="line-numbers language-none"><code class="language-none">yay -S fcitx5-im fcitx5-chinese-addons<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    注意到fcitx5-im里就包含了：</p><blockquote><ul><li>fcitx5</li><li>fcitx5-configtool</li><li>fcitx5-gtk</li><li>fcitx5-qt</li></ul></blockquote><p>​    然后，我们还要让fcitx在xwindows加载的时候就启用，所以，一个快捷的方式就是直接在用户目录下写一个.xprofile文件：</p><pre class="line-numbers language-none"><code class="language-none">vim ~&#x2F;.xprofile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    写下这些东西：</p><pre class="line-numbers language-none"><code class="language-none">GTK_IM_MODULE&#x3D;fcitx5QT_IM_MODULE&#x3D;fcitx5XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx5&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​    关于xprofile文件的性质：可以参考archWiki:<a href="https://wiki.archlinux.org/title/Xprofile">xprofile - ArchWiki (archlinux.org)</a></p><p>​    这里检查的方式就是直接<code>reboot</code>让环境重新加载读取配置文件</p><p>​    这里，可能还会发现存在一些乱码（比如说region and language设置切换语言的时候简体中文的简这个字是方框），我们需要下载开源的好用字体：</p><blockquote><p>下载一个中文字体：</p><ul><li><code>wqy-microhei</code>(笔者选择了这个)</li><li><code>wqy-microhei-lite</code></li><li><code>wqy-bitmapfont</code></li><li><code>wqy-zenhei</code></li><li><code>ttf-arphic-ukai</code></li><li><code>ttf-arphic-uming</code></li><li><code>adobe-source-han-sans-cn-fonts</code></li><li><code>adobe-source-han-serif-cn-fonts</code></li><li><code>noto-fonts-cjk</code></li></ul></blockquote><p>​    下载一个nerd-fonts字体：</p><p><img src="image-20240320121517131.png" alt="image-20240320121517131"></p><p>​    笔者这里选择的是40（jb家的hhh）</p><p>​    下载的方式就是</p><pre class="line-numbers language-none"><code class="language-none">yay -S wqy-microhei<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">yay -S nerd-fonts #然后询问下载哪个的时候选择40（内存土豪全下我没意见）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    nerd-fonts会在后面我们配置<code>fish + oh-my-posh</code>的时候会用到。</p><h3 id="IV-firefox-配置代理"><a href="#IV-firefox-配置代理" class="headerlink" title="IV. firefox + 配置代理"></a>IV. firefox + 配置代理</h3><p>​    我们来配置代理：当然，笔者出于简单的考虑选择的是<code>clash-verge</code></p><pre class="line-numbers language-none"><code class="language-none">yay -S clash-verge firefox # firefox是浏览器，我喜欢这个（<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    下好了之后启动它直接GUI操作：</p><blockquote><p>这里塞订阅</p></blockquote><p><img src="image-20240320121944803.png" alt="image-20240320121944803"></p><blockquote><p>在这里启动</p></blockquote><p><img src="image-20240320122008635.png" alt="image-20240320122008635"></p><p>​    选择打开系统代理之后，就可以直接google了（在刚刚下载好的浏览器里直接正常操作）：</p><p><img src="image-20240320122142376.png" alt="image-20240320122142376"></p><p>​    但是我们的代理没法在终端使用，这个问题我们放在下一个section讲：</p><h3 id="V-fish-oh-my-posh"><a href="#V-fish-oh-my-posh" class="headerlink" title="V. fish + oh-my-posh"></a>V. <code>fish + oh-my-posh</code></h3><p>​    来了来了，我们首先先下载fish</p><pre class="line-numbers language-none"><code class="language-none">yay -S fish unzip wget # unzip是后面我们为oh-my-posh服务的，wget是后面我们下载zip包服务的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    下一步，就是更改我们的Konsole启动的默认配置（笔者这里的shell已经是fish了）</p><p><img src="image-20240320122501233.png" alt="image-20240320122501233"></p><p>​    在设置那里选择配置Konsole,切换到配置方案页面。咱们新建一个配置方案：</p><p><img src="image-20240320122615093.png" alt="image-20240320122615093"></p><p>​    在外观上，设置字体（选择你自己下的Nerd Font即可）：</p><p><img src="image-20240320123941804.png" alt="image-20240320123941804"></p><p>​    现在新建一个标签页：很好，就长这样</p><p><img src="image-20240319220024290.png" alt="image-20240319220024290"></p><p>​    下一步就是拉取oh-my-posh</p><pre class="line-numbers language-none"><code class="language-none">curl -s https:&#x2F;&#x2F;ohmyposh.dev&#x2F;install.sh | sudo bash -s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    接着我们下载主题：</p><pre class="line-numbers language-none"><code class="language-none"># 创建主题存放文件夹，读者可以根据需要自定义存放位置，# 如果自定义修改位置，那么后续的命令也需要做出相应更改mkdir ~&#x2F;.poshthemes# 获取主题zip文件并存放至对应主题文件夹（如果使用该命令下载zip较慢，# 可以通过复制该URL使用“github文件加速下载下载”文件wget https:&#x2F;&#x2F;github.com&#x2F;JanDeDobbeleer&#x2F;oh-my-posh&#x2F;releases&#x2F;latest&#x2F;download&#x2F;themes.zip -O ~&#x2F;.poshthemes&#x2F;themes.zip# 解压主题压缩包文件unzip ~&#x2F;.poshthemes&#x2F;themes.zip -d ~&#x2F;.poshthemes# 将所有主题文件设置可读权限chmod u+rw ~&#x2F;.poshthemes&#x2F;*.omp.*# 删除主题压缩包rm ~&#x2F;.poshthemes&#x2F;themes.zip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 注意“~/.poshthemes/jandedobbeleer.omp.json”，根据实际安装情况选择读者自己设置的 oh-my-posh 主题位置而定，在此仅作为参考。</span><span class="token comment"># 下面是一个例子</span>oh-my-posh init fish <span class="token parameter variable">--config</span> ~/.poshthemes/jandedobbeleer.omp.json <span class="token operator">|</span> <span class="token builtin class-name">source</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>注意</p><p>主题可以在<a href="https://ohmyposh.dev/docs/themes">官网</a>查看，当读者看到适合自己的主题时，可以暂时通过命令“oh-my-posh init fish —config ~/.poshthemes/看到的主题名.omp.json | source”查看使用效果，如果合适则直接将该命令添加到fish的配置文件中即可。</p></blockquote><p>​    笔者这里选择的是blueish主题</p><pre class="line-numbers language-none"><code class="language-none">oh-my-posh init fish --config ~&#x2F;.poshthemes&#x2F;blueish.omp.json | source<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    然后把上面的命令写入：</p><pre class="line-numbers language-none"><code class="language-none">~&#x2F;.config&#x2F;fish&#x2F;config.fish<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240320123810913.png" alt="image-20240320123810913"></p><p>​    然后开一个终端就行，如果没问题，就会是这样的</p><p><img src="image-20240320123910399.png" alt="image-20240320123910399"></p><h3 id="VI-配置终端代理"><a href="#VI-配置终端代理" class="headerlink" title="VI. 配置终端代理"></a>VI. 配置终端代理</h3><p>​    这一步请确保IV步骤已经完成！</p><p>​    实质上就是向终端启动文件写入两个alias就行：</p><p><img src="image-20240319221426461.png" alt="image-20240319221426461"></p><p>​    注意后面的http_proxy和https_proxy的端口号请看自己的代理软件的端口号。</p><p>​    在我们没有开启代理之前，我们测试一下：</p><pre class="line-numbers language-none"><code class="language-none">curl google.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240320124330709.png" alt="image-20240320124330709"></p><p>​    现在打开代理，确保自己的alias已经配置好并被终端读取</p><p><img src="image-20240320124414719.png" alt="image-20240320124414719"></p><p>​    完事！</p><h3 id="VII-配置lunar-vim"><a href="#VII-配置lunar-vim" class="headerlink" title="VII. 配置lunar vim"></a>VII. 配置lunar vim</h3><p>​    首先先下载neovim</p><pre class="line-numbers language-none"><code class="language-none">yay -S neovim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <img src="image-20240320130206684.png" alt="image-20240320130206684"></p><p>​    之后下载脚本开始配置</p><pre class="line-numbers language-none"><code class="language-none">curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;LunarVim&#x2F;LunarVim&#x2F;release-1.3&#x2F;neovim-0.9&#x2F;utils&#x2F;installer&#x2F;install.sh &gt; install.shchmod 777 .&#x2F;install.sh &amp;&amp; .&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    配置结束，按照脚本的提示，我们为了不污染环境，在config.fish文件下再alias一个指令</p><p><img src="image-20240320130635235.png" alt="image-20240320130635235"></p><pre class="line-numbers language-none"><code class="language-none">alias lvim&#x3D;&#x2F;path&#x2F;to&#x2F;your&#x2F;vim&#x2F;according&#x2F;2&#x2F;your&#x2F;shellscript<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    新开一个</p><pre class="line-numbers language-none"><code class="language-none">lvim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240320130750175.png" alt="image-20240320130750175"></p><h2 id="WHOLE-REFERENCE"><a href="#WHOLE-REFERENCE" class="headerlink" title="WHOLE_REFERENCE"></a>WHOLE_REFERENCE</h2><blockquote><p><strong>Base:</strong><a href="https://arch.icekylin.online/guide/rookie/basic-install.html">archlinux 基础安装 | archlinux 简明指南 (icekylin.online)</a></p><p><strong>KDE_Base</strong><a href="https://zhuanlan.zhihu.com/p/144122288">如何在 Arch Linux 上正确安装和设置 KDE Plasma？ | Linux 中国 - 知乎 (zhihu.com)</a></p><p><strong>输入法：</strong></p><ol><li><a href="https://www.cnblogs.com/klelee/p/archlinux-fcitx5.html">Archlinux安装和配置fcitx5 - 可乐klelee - 博客园 (cnblogs.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/558354279">Arch Linux + KDE 配置&amp;美化（持续更新~） - 知乎 (zhihu.com)</a></li></ol><p><strong>字体</strong></p><p><a href="https://blog.csdn.net/qingtian805/article/details/123187337">Arch（KDE Plasma）中文化_arch 中文字体-CSDN博客</a></p><p><strong>Fish Shell + Oh My Posh</strong></p><ol><li><a href="https://zhuanlan.zhihu.com/p/59439573">如何在 Linux 中安装、配置和使用 Fish Shell？ - 知乎 (zhihu.com)</a></li><li><a href="https://fishshell.com/">fish shell</a></li><li><a href="https://ohmyposh.dev/">Home | Oh My Posh</a></li><li><a href="https://www.cnblogs.com/aaroncoding/p/17118251.html">Linux终端下使用Fish shell并美化 - 木木亚伦 - 博客园 (cnblogs.com)</a></li></ol><p><strong>lunar vim</strong></p><p><a href="https://www.lunarvim.org/docs/installation">Installation | LunarVim</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv490+MSVC_Mingw+WITHQT+OpencvContrib4_x编译教程</title>
      <link href="/2024/01/29/Opencv490-MSVC-Mingw-WITHQT-OpencvContrib4-x%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/"/>
      <url>/2024/01/29/Opencv490-MSVC-Mingw-WITHQT-OpencvContrib4-x%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="OpenCV4-9-0-扩展-WITH-QT（Qt6）模块编译教程（Windows）"><a href="#OpenCV4-9-0-扩展-WITH-QT（Qt6）模块编译教程（Windows）" class="headerlink" title="OpenCV4.9.0 + 扩展 + WITH_QT（Qt6）模块编译教程（Windows）"></a>OpenCV4.9.0 + 扩展 + WITH_QT（Qt6）模块编译教程（Windows）</h1><p>​    本篇教程是Opencv4.9.0 和 扩展Opencv Contrib4.x以及带上了WITH_QT选项的CMake编译环境配置和编译教程。注意到环境是Window11（10应该仍可以使用）。本篇教程将会导出Mingw版本的，和MSVC19版本的Debug和Release四套Opencv库的编译教程。各位读者可以根据自己的需求进行编译，或者是在本文最后的部分前往本人开设的Github仓库处下载已经编译好的资源和库直接进行使用。</p><h2 id="前置的能力要求与说明"><a href="#前置的能力要求与说明" class="headerlink" title="前置的能力要求与说明"></a>前置的能力要求与说明</h2><ol><li>本教程要求自己至少会翻墙，不会翻墙的话就不建议费心自己编译了，文章的最后有仓库直接嫖，当然如果是的确需要存在自己的编译需求的话，可以查询如何瞒过CMake的下载步骤（也就是贴MD5码瞒天过海），替换自己的下载的资源从而使得CMake正确的生成MakeFile。</li><li>以及本教程需要提示您：本教程不生成opencvWorld这个巨无霸，因为他跟Contrib库的cvv可视化相互冲突，会存在依赖错配的问题导致大量的undefined reference，后续的配置种不需要cvv者可以不配置然后选择build_opencv_world，如果需要的话就只好忍耐生成大量的散装库了</li><li>教程的配置顺序优先是Release，这点务必注意。</li></ol><h2 id="需要下载的资源"><a href="#需要下载的资源" class="headerlink" title="需要下载的资源"></a>需要下载的资源</h2><ol><li>Opencv4.9.0 <code>:&gt;</code> <a href="https://github.com/opencv/opencv/tree/4.9.0">opencv/opencv at 4.9.0 (github.com)</a></li></ol><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>Opencv_Contrib4.x <code>:&gt;</code> <a href="https://github.com/opencv/opencv_contrib">opencv/opencv_contrib: Repository for OpenCV’s extra modules (github.com)</a></p><pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;opencv&#x2F;opencv_contrib.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Qt:<a href="https://www.qt.io/zh-cn/download">Try Qt | 开发应用程序和嵌入式系统 | Qt</a>直接下就行，但是先不要急着下啥组件，我后面会说。</p></li></ol><p>​    在网页Web和Windows Command命令行<code>(我喜欢用Powershell，这个因人而异)</code>中分别完成上述三个资源的下载。</p><blockquote><p>TIPS:如果你发现git被墙的厉害，可以使用代理工具配置IP和端口转发流量。这个需要查看你使用的代理软件（不会使用代理软件的话自行百度买节点，这里就不赘述怎么搞了），我的代理软件生成的Powershell的代理设置指令是：（<code>注！意！改！成！自！己！的！转！发！IP！和！端！口！</code>）</p><pre class="line-numbers language-none"><code class="language-none">$Env:http_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:7890&quot;;$Env:https_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:7890&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    惯用CMD用户可以根据自己的需求更改IP和端口</p><pre class="line-numbers language-none"><code class="language-none">set http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890 &amp; set https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:7890<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240129182906224.png" alt="image-20240129182906224"></p></blockquote><p>​    下载的时候记得泡杯茶喝喝。最近的话本人这里的网不太好，常常会丢包，多来几次就可以下载完整。两个包都比较大（Contrib包200多MB，Opencv本身的包达到了700多MB）</p><p>​    下载结束，开始配置。</p><p><img src="image-20240129183645488.png" alt="image-20240129183645488"></p><h2 id="配置编译器（WITH-QT用户看这个）"><a href="#配置编译器（WITH-QT用户看这个）" class="headerlink" title="配置编译器（WITH_QT用户看这个）"></a>配置编译器（WITH_QT用户看这个）</h2><p>​    下一步就是配置了，我们首先搞Qt的，我们特别需要注意的是，这篇教程的这个部分更加针对Qt6，Opencv的CMakeLists在这个版本中支持了Qt6，当然，选择Qt5也是可行的，事情更少。</p><p>​    <strong>Qt6用户在使用安装程序的时候需！要！注！意！请务必保证自己的安装中包含了下面的这些包：</strong></p><p><img src="image-20240129184036707.png" alt="image-20240129184036707"></p><p>​    编译器包，这里根据自己希望的平台二选一，或者都选！</p><p>​    另一方面，这里是Qt6用户务必保证的：</p><p><img src="image-20240129184225886.png" alt="image-20240129184225886"></p><p>​    这个是需要的，兼容Qt5的库包是一定要下载的！否则会在后续的配置中出现这个错误，类比的，他报了少啥关于Qt的，就在这里下啥！一定一定要补全！否则编译不通过！</p><p><code>error: Qt6::Core5Compat but the target was not found.</code></p><p>​    Qt5用户不需要管这个。</p><p>​    下一步就是添加路径：</p><p><img src="image-20240129184532997.png" alt="image-20240129184532997"></p><p>​    重点是lib库的路径，我们CMakeLists搜包需要这个文件下面的cmakeConfigFile。这也就提醒你：</p><blockquote><p>如！果！你！是！两！种！库！都！编！译！请确保对应编译器的Lib路径是要被优先搜索到的！换而言之，保证你的lib库路径在Path里的头部！</p><p>赶时间不看，我说原因：这是因为我们的后面的编译种会涉及到库的连接，如果我们在配置Mingw的库却使用了MSVC下的lib的库，两种库的导出符号的命名规则完全不一致，将会出现大名鼎鼎的Undifined Reference错误，而其是刷屏级别的。</p></blockquote><p>​    按照这个架势，我们就是先处理Mingw的库了。</p><h2 id="为CMakeLists设置代理"><a href="#为CMakeLists设置代理" class="headerlink" title="为CMakeLists设置代理"></a>为CMakeLists设置代理</h2><p>​    Opencv在Config的流程种会出现下载库的情况，对于原生的Opencv会下载FFMPEG等库，为此，如果你手头有代理软件，请为CMake设置代理，在CMakeLists的首部添加：</p><pre class="line-numbers language-none"><code class="language-none">set(ENV&#123;http_proxy&#125; &quot;http:&#x2F;&#x2F;127.0.0.1:7890&quot;)set(ENV&#123;https_proxy&#125; &quot;http:&#x2F;&#x2F;127.0.0.1:7890&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    别直接复制啊，看自己的IP和端口号</p><p><img src="image-20240129185327227.png" alt="image-20240129185327227"></p><p>​    保存，打开CMake-Gui，开始配置。</p><h2 id="CMake-3-24配置-Mingw-Release"><a href="#CMake-3-24配置-Mingw-Release" class="headerlink" title="CMake 3.24配置(Mingw Release)"></a>CMake 3.24配置(Mingw Release)</h2><p>​    推介使用CMake3.24而不是3.25,我先前使用会出现一个资源死活识别不出来然后发现是牛马的CMake的问题（Github Issue可以围观一手）</p><p>​    我们添上对应的路径，看自己的：（然后建议像我这样勾上Advanced和Grouped方便等会找问题）</p><p><img src="image-20240129185610044.png" alt="image-20240129185610044"></p><p>​    开始Configure，我们既然使用Mingw编译器，自然要的是Mingw-MakeFile，下一步就是使用指定的gcc和g++编译器。</p><p><img src="image-20240129185755487.png" alt="image-20240129185755487"></p><p><img src="image-20240129185804731.png" alt="image-20240129185804731"></p><p>​    可以参考位置看看自己的gcc和g++在哪里。</p><p><img src="image-20240129185828981.png" alt="image-20240129185828981"></p><p>​    确认，CMake开始扫描，检查编译条件。这个过程将会持续的很久，也会出现大量的有趣的错误。请随时留意自己的输出控制台有没有出现红色的东西。<strong>而不是不负责任的一直点Configure让错误失踪</strong></p><p><img src="image-20240129190037032.png" alt="image-20240129190037032"></p><p>​    这里就是让很多新手绊倒的地方，当我们完成CMake的代理配置后，可以发现这里不会报错，而是顺利的通过配置</p><p>​    第一次配置结束，可以看到满山红。</p><p><img src="image-20240129190135182.png" alt="image-20240129190135182"></p><blockquote><ol><li>检查自己的Install to，是你希望的路径吗？</li><li>回看自己的 Configure过程出现过爆红吗，有的话可以点对点的找问题解决，笔者这里尚未出现，常见的可能的就是不设置代理导致必须存在的库没有被下载，这个网上已经存在大量的教程教你，这里不再演示！</li></ol></blockquote><h2 id="配置自己的需求然后生成MakeFile"><a href="#配置自己的需求然后生成MakeFile" class="headerlink" title="配置自己的需求然后生成MakeFile"></a>配置自己的需求然后生成MakeFile</h2><h3 id="配置Contrib"><a href="#配置Contrib" class="headerlink" title="配置Contrib"></a>配置Contrib</h3><p>​    回忆我们的需求，我们要的是<code>opencv_contrib + WITH_QT</code>。所以第一步就是设置Opencv的Contrib路径</p><p><img src="image-20240129190457712.png" alt="image-20240129190457712"></p><p><img src="image-20240129190516432.png" alt="image-20240129190516432"></p><p>​    输入自己的<code>conrtib/module</code>路径。</p><h3 id="配置Qt（很重要，极易出现问题）"><a href="#配置Qt（很重要，极易出现问题）" class="headerlink" title="配置Qt（很重要，极易出现问题）"></a>配置Qt（很重要，极易出现问题）</h3><p>​    勾选WITH_QT选项。</p><p><img src="image-20240129191233670.png" alt="image-20240129191233670"></p><h3 id="再次Config观察输出台"><a href="#再次Config观察输出台" class="headerlink" title="再次Config观察输出台"></a>再次Config观察输出台</h3><p>​    由于多出了Contrib库，还会下载不少的文件</p><p><img src="image-20240129191337336.png" alt="image-20240129191337336"></p><p>​    文件也都比较大，考验流量。所以容易失败。</p><p>​    配置结束，控制台没有出现红色的部分。检查上面的栏目，对于我们当前的配置需求我们只检查qt的就行。</p><p><img src="image-20240129191555836.png" alt="image-20240129191555836"></p><p>​    OK，都是我们指定的路径，没问题。</p><p>​    再次Config消红</p><p><img src="image-20240129191731747.png" alt="image-20240129191731747"></p><p>​    很干净，没问题了。</p><p>​    生成MakeFile。结束CMake的配置部分。</p><p><img src="image-20240129191830681.png" alt="image-20240129191830681"></p><p>​    现在可以看到Opencv的build目录下文件丰富多彩，所以打开你的命令控制台，但走一个</p><h3 id="mingw32-make-exe-j14"><a href="#mingw32-make-exe-j14" class="headerlink" title="mingw32-make.exe -j14"></a>mingw32-make.exe -j14</h3><p>​    启动我们的编译。（注意：-j几看自己的机器，不然会出现部分线程超前编译的错误，导致出现未定义的错误。）</p><p><img src="image-20240129192024449.png" alt="image-20240129192024449"></p><p>​    路上会出现很多的编译信息。</p><blockquote><p>如果发生了错误，自行百度emmm，我第一编译出现了字符编码转化的问题，当然这个自己修修也就OK了。当然我们</p></blockquote><p><img src="image-20240129193447380.png" alt="image-20240129193447380"></p><p>​    单刷成功。</p><h3 id="下载库"><a href="#下载库" class="headerlink" title="下载库:"></a>下载库:</h3><pre class="line-numbers language-none"><code class="language-none">mingw32-make.exe install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20240129193655531.png" alt="image-20240129193655531"></p><p>​    整理文件，实际上我们用到的就是这些：</p><pre class="line-numbers language-none"><code class="language-none">.\build\install\x64\mingw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    下的bin和lib路径下的动态库和静态库和</p><pre class="line-numbers language-none"><code class="language-none">.\build\install\include\opencv2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    带着opencv2一块走记得。</p><h2 id="Mingw-Debug版本"><a href="#Mingw-Debug版本" class="headerlink" title="Mingw Debug版本"></a>Mingw Debug版本</h2><p>​    MingW debug版本有一个需要注意的：就是在上面配置的基础上修改buildType和buildFlag。如你所见：</p><p><img src="image-20240129195602018.png" alt="image-20240129195602018"></p><p>​    首先：<code>CMAKE_BUILD_TYPE:</code>改成<code>DEBUG</code>的类型。其次：</p><p><img src="image-20240129195703354.png" alt="image-20240129195703354"></p><p>​    <code>CMAKE_CXX_FLAGS_DEBUG</code>的falgs那里改成<code>-g O1</code>，这是因为我们的编译的过程会产生大量的比较大的目标文件，一部分的目标文件体积过大导致无法被连接，我们不得不妥协一部分编译信息来保证我们的Debug库会被正确编译。</p><p>​    没了，继续单走<code>mingw32-make.exe -j14</code>和<code>mingw32-make.exe install</code></p><p>​    老地方取库和头文件，这里不赘述了。</p><h2 id="MSVC-Version"><a href="#MSVC-Version" class="headerlink" title="MSVC Version"></a>MSVC Version</h2><p>​    在开始我们的MSVC版本的配置之前，请务必保证：</p><blockquote><p>自己的Qt路径下是MSVC优先</p></blockquote><p>​    我们的第一个与Mingw的分歧点在于，我们需要更改为指定MSVC编译器进行编译，为此就需要使用Visual Studio的MSVC生成编译工程</p><p><img src="image-20240129202538684.png" alt="image-20240129202538684"></p><p>​    请诸位读者自行选择自己的主机上存在的VS版本。然后配置即可：</p><p><img src="image-20240129202711235.png" alt="image-20240129202711235"></p><p>​    笔者这里采用的是MSVC17<code>(Visual Studio 2022版本)</code>进行编译的。对于中间的下载文件的配置要求跟Mingw的完全一致，这里还是一样：注意开好自己的代理，仍然存在不同于Mingw的文件需要下载。</p><blockquote><ol><li>检查自己的Install to，是你希望的路径吗？</li><li>回看自己的 Configure过程出现过爆红吗，有的话可以点对点的找问题解决，笔者这里尚未出现，常见的可能的就是不设置代理导致必须存在的库没有被下载，这个网上已经存在大量的教程教你，这里不再演示！</li></ol></blockquote><h2 id="配置自己的需求然后生成sln文件"><a href="#配置自己的需求然后生成sln文件" class="headerlink" title="配置自己的需求然后生成sln文件"></a>配置自己的需求然后生成sln文件</h2><h3 id="配置Contrib-1"><a href="#配置Contrib-1" class="headerlink" title="配置Contrib"></a>配置Contrib</h3><p>​    回忆我们的需求，我们要的是<code>opencv_contrib + WITH_QT</code>。所以第一步就是设置Opencv的Contrib路径</p><p><img src="image-20240129190457712.png" alt="image-20240129190457712"></p><p><img src="image-20240129190516432.png" alt="image-20240129190516432"></p><p>​    输入自己的<code>conrtib/module</code>路径。</p><h3 id="配置Qt（很重要，极易出现问题）-1"><a href="#配置Qt（很重要，极易出现问题）-1" class="headerlink" title="配置Qt（很重要，极易出现问题）"></a>配置Qt（很重要，极易出现问题）</h3><p>​    勾选WITH_QT选项。</p><p><img src="image-20240129191233670.png" alt="image-20240129191233670"></p><h3 id="再次Config观察输出台-1"><a href="#再次Config观察输出台-1" class="headerlink" title="再次Config观察输出台"></a>再次Config观察输出台</h3><p>​    由于多出了Contrib库，还会下载不少的文件</p><p><img src="image-20240129191337336.png" alt="image-20240129191337336"></p><p>​    文件也都比较大，考验流量。所以容易失败。</p><p>​    配置结束，控制台没有出现红色的部分。检查上面的栏目，对于我们当前的配置需求我们只检查qt的就行。</p><p><img src="image-20240129203345257.png" alt="image-20240129203345257"></p><p>​    OK，都是我们指定的路径，没问题。</p><p>​    再次Config消红</p><p><img src="image-20240129191731747.png" alt="image-20240129191731747"></p><p>​    很干净，没问题了。然后Generate Done。</p><p>​    回到build目录：</p><p><img src="image-20240129203509657.png" alt="image-20240129203509657"></p><p>​    抓到这个目录，点击打开工程</p><p><img src="image-20240129203614573.png" alt="image-20240129203614573"></p><p>​    第一件事情：确保是Release，第二件事情，点击生成<code>-&gt;</code>生成解决方案。</p><p><img src="image-20240129203755228-1706532201669-2.png" alt="image-20240129203755228"></p><p>​    很好，没毛病。</p><p><img src="image-20240129205837105.png" alt="image-20240129205837105"></p><p>​    下一步就是下载：找到这个地方，对着Install目录项右键生成配置方案</p><p><img src="image-20240129204352307.png" alt="image-20240129204352307"></p><h2 id="MSVC-Debug"><a href="#MSVC-Debug" class="headerlink" title="MSVC Debug"></a>MSVC Debug</h2><p>​    我们类比的把CMakeLists的build type改成了DEBUG，然后注意在生成的时候需要选择DEBUG模式的生成，否则会产生生成和配置不符合的问题。当然后面就是雷同了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio编译静，动态链接库指南备忘</title>
      <link href="/2023/12/18/Visual-Studio%E7%BC%96%E8%AF%91%E9%9D%99%EF%BC%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%8C%87%E5%8D%97%E5%A4%87%E5%BF%98/"/>
      <url>/2023/12/18/Visual-Studio%E7%BC%96%E8%AF%91%E9%9D%99%EF%BC%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%8C%87%E5%8D%97%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Visual-Studio编译与使用静，动态链接库指南备忘"><a href="#Visual-Studio编译与使用静，动态链接库指南备忘" class="headerlink" title="Visual Studio编译与使用静，动态链接库指南备忘"></a>Visual Studio编译与使用静，动态链接库指南备忘</h1><p>​        跟Microsoft的Visual Studio接触了这么久，第一次打算写点备忘在这里，这篇博客是记录在VS下如何编译与使用静，动态链接库的指南。</p><p>​        最近，我封装了基于Opencv的基础图像操作，打算让Tesseract提高准确识别从而对Opencv进行简单的套壳封装。方便起见，我打算采用低耦合的动态链接库的方式处理。</p><p>​        首先，这是我的工程文件下的含有目录：</p><p><img src="image-20231218212558692.png" alt="image-20231218212558692"></p><p>​        我的目标是</p><blockquote><p>只使得<code>ImgProcessor</code>这个类在动态库中是可见的，其他的符号并不可见（换而言之，无法直接使用，只可通过本人设计的Impl隔离层访问），我应该怎么做呢？</p></blockquote><h2 id="首先，给欲导出符号上buff-dllexport"><a href="#首先，给欲导出符号上buff-dllexport" class="headerlink" title="首先，给欲导出符号上buff: __dllexport"></a>首先，给欲导出符号上buff: __dllexport</h2><p>​        这招只适合在MSVC编译器底下玩，为了通用性，还需要判定这是否为MSVC编译器</p><pre class="line-numbers language-none"><code class="language-none">#ifdef _MSV_VER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        是一个微软预定义的宏，如果追求极强的通用性，用它来操作！这里我只是在玩自己的toys，没有必要给自己上难度（跑。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define CCSTD_EXPORT __declspec(dllexport)#ifdef __cplusplus &#x2F;&#x2F; C++环境宏#define CCSTD_FUNC_EXPORT extern &quot;C&quot; __declspec(dllexport)#else#define CCSTD_FUNC_EXPORT __declspec(dllexport)#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>extern &quot;C&quot;</code>是一个令人哭笑不得的选择，因为C++目前的ABI兼容貌似不太行，对于部分Modern C++特性，希望用在更加广泛的二进制平台有的时候会抽风，从而不得不投靠C的ABI接口，这个<code>extern &quot;C&quot;</code>就是在告诫编译器生成C Style的二进制接口（乐）</p></blockquote><p>​        然后，给自己的类加上符号</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class CCSTD_EXPORT ImageProcessor&#123;public:&#x2F;&#x2F; ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们就想要导出这个类，那就直接给这个函数加上修饰符即可，如果想要单独的给函数加上导出符号，请务必使用</p><pre class="line-numbers language-none"><code class="language-none">CCSTD_FUNC_EXPORT<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        C++环境下，它会被展开成：</p><pre class="line-numbers language-none"><code class="language-none">extern &quot;C&quot; __declspec(dllexport)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也就是C式的兼容性强的接口。（比如模板等高级特性）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;void CCSTD_FUNC_EXPORT someFunc(T* t);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="转向调整项目生成类型"><a href="#转向调整项目生成类型" class="headerlink" title="转向调整项目生成类型"></a>转向调整项目生成类型</h2><p><img src="image-20231218213725439.png" alt="image-20231218213725439"></p><p>​        注意自己的配置：<code>Debug or Release? x86 or x64?</code></p><p>​        然后选择自己的配置类型，比如说我打算生成debug模式下的静态库和动态库，就依次调整生成之（点生成<code>-&gt;</code>生成解决方案，如果希望清理，那就点击重新生成解决方案 ）。</p><p><img src="image-20231218213850854.png" alt="image-20231218213850854"></p><p>​        现在到自己的生成文件路径下面</p><p><img src="image-20231218214002280.png" alt="image-20231218214002280"></p><p>​        （这个opencv_world480d.dll是我自己提前编译得到的，exe文件是我自己测试的时候生成的，实质上我们需要的就是lib文件和dll文件）</p><p>​        好，把这两个文件拉到测试环境里去</p><h2 id="使用lib和dll"><a href="#使用lib和dll" class="headerlink" title="使用lib和dll"></a>使用lib和dll</h2><p>​        新开一个空工程，然后开始配置</p><p><img src="image-20231218214302697.png" alt="image-20231218214302697"></p><p>​        如果你的dll或者lib文件需要包含头文件但是你觉得一个一个加入工程多多少少有点抽象和烦人，那么就在这里配置你的包含文件的文件夹位置，如果你配置过opencv了，轻车熟路。</p><p>​        下面就是配置静态库：</p><p><img src="image-20231218214436157.png" alt="image-20231218214436157"></p><p>​        这个库目录指代静态库，我们需要填写这些静态库集中（没集中我建议手动集中一下，方便应用管理）</p><p>​        然后，我们在这里：</p><p><img src="image-20231218214553137.png" alt="image-20231218214553137"></p><p>​        <strong>添上所有的依赖库的符号</strong>，当然，可以自己脑子跑一遍看看填写多少库自己的代码都可以在连接时消除undefined而进行选择，这里是因为本人编译自己的库时并不打算把自己的依托东西同另一个巨无霸粘在一起，且没有极其严苛的保密需求，所以就需要告知原本的底层库的位置</p><p>​        下一步就是调整工作环境，我看很多垃圾教程都嚷嚷着把自己的dll扔到Windows32或者是环境变量，我的评价是乐，完全不需要污染自己的电脑，而是在这里：</p><p><img src="image-20231218215010350.png" alt="image-20231218215010350"></p><p>​        可以在这里设置工作目录，目录是自己的动态库的集中位置文件夹，填写完毕后，可以尝试启动一下了：</p><p><img src="image-20231218215120054.png" alt="image-20231218215120054"></p><p>​        运行正常，所有的模块都被打包进来了（比如说我自己手搓的ProgramLogger模块）</p><p><img src="image-20231218215230377.png" alt="image-20231218215230377"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统还原真相（超长记录版）</title>
      <link href="/2023/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%98%E5%8E%9F%E7%9C%9F%E7%9B%B8%EF%BC%88%E8%B6%85%E9%95%BF%E8%AE%B0%E5%BD%95%E7%89%88%EF%BC%89/"/>
      <url>/2023/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%98%E5%8E%9F%E7%9C%9F%E7%9B%B8%EF%BC%88%E8%B6%85%E9%95%BF%E8%AE%B0%E5%BD%95%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统学习记录"><a href="#操作系统学习记录" class="headerlink" title="操作系统学习记录"></a>操作系统学习记录</h1><h1 id="1-导论"><a href="#1-导论" class="headerlink" title="1. 导论"></a>1. 导论</h1><h4 id="硬件输入输出"><a href="#硬件输入输出" class="headerlink" title="硬件输入输出"></a>硬件输入输出</h4><p>​        <strong>分为两类，串行和并行，所以，我们相应的接口就是串行接口和并行接口。串行接口跟CPU通信，反过来，CPU通过串行接口跟串行设备进行数据传输。并行接口工作原理如法炮制。</strong></p><p>​        访问外部硬件的方式有两种：</p><blockquote><ol><li>把外设的内存映射到一定的地址内存中去，比如说显卡</li><li>通过IO接口访问</li></ol></blockquote><h4 id="啥是应用程序"><a href="#啥是应用程序" class="headerlink" title="啥是应用程序"></a>啥是应用程序</h4><p>​        我们把应用软件和操作系统解构，本质上就是一串命令和数据。我们使用编译器来讲代码翻译成机器语言。加上操作系统的一些现成的配合。程序才可以很快的运行。</p><h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><blockquote><p>内核态（Kernel Mode）：运行操作系统程序，操作硬件</p><p>用户态（User Mode）：运行用户程序</p></blockquote><p>一般而言，用户态需要陷入到内核态发生在下面三种情形：</p><p><img src="image-20231007073152106.png" alt="image-20231007073152106"></p><ul><li>请求系统调用</li></ul><p>​        <strong>这是用户态进程主动要求切换到内核态的一种方式</strong>，<strong>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。</strong>比如前例中fork()实际上就是执行了一个创建新进程的系统调用。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p><p>​        用户程序通常调用库函数，由库函数再调用系统调用，因此有的库函数会使用户程序进入内核态（只要库函数中某处调用了系统调用），有的则不会。</p><ul><li>异常</li></ul><p>​        当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p><ul><li>外围设备的中断</li></ul><p>​        <strong>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号</strong>，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p><p>​        值得注意的是：<strong>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</strong></p><h4 id="为何给内存分段"><a href="#为何给内存分段" class="headerlink" title="为何给内存分段"></a>为何给内存分段</h4><p>​        事实上，内存是随机读写设备，我们只需要给出一个地址告诉地址总线就好了。内存分段是一个历史遗留问题。我们发现，最开始要是直接给出绝对物理地址，会导致程序之间还需要判断这个地址上是否有其他程序运行，很是麻烦。不如我们加上一层抽象，即：<strong>采用分段，让程序使用虚拟地址，CPU在处理的时候，采用“段基址+段内地址偏移”的计算方式</strong>。这样，每一个程序好像都在独立的采用从0开始的编号地址，<strong>但实际映射的时候，分发到的是不同的绝对物理地址。这样程序就不需要关系底层的事情了。</strong>(PS:啊哈，后面到了页表，虚拟内存等就知道怎么回事了！)</p><p>​        上述的行为我们叫重定位。重定位行为需要专门的段基址寄存器存储段基址的值，如cs, ds, es等。这下，只要修改段基址就可以让程序在内存海洋里自由的翱翔了</p><p>​        CPU将外部存储器划分成一个个64k的逻辑段，通过这种方式加上段内地址偏移即可通过16位寄存器实现1MB地址空间的寻址。举个例子：</p><ul><li>用户输入一个操作指令，该指令通过总线传递到CPU内部，<strong>cpu通过段寄存器（cs）找到相应的逻辑段，接着根据段内指针找到相应的存储单元</strong>，将存储单元中的指令通过程序计数器读入指令寄存器，然后执行后续操作。</li><li>对于堆栈操作：<strong>cpu通过段寄存器（ss）找到相应的逻辑段，然后根据堆栈指针（sp）找到相应的存储单元</strong>，接着执行命令的后续流程。</li></ul><hr><p>​        当然了最后的运行结果要经过地址产生与总线控制逻辑运算得到一个20位地址（简单的讲就是将段基址左移４位，这样就可以表示20位了），然后交给相应的接口电路，继而交给程序进行数据的处理。</p><h4 id="代码分段"><a href="#代码分段" class="headerlink" title="代码分段"></a>代码分段</h4><p>​        事实上，代码不分段，也是可以跑的。毕竟CPU不晓得命令和数据的区别，告诉他执行什么机器码他就会执行什么机器码。分段只是方便我们的代码书写和代码调试。</p><p>​        值得注意的是：CPU要求指令是逻辑连续的，不需要物理连续。也就是说，只要源源不断的告诉他指令是什么。当然，实际上，指令还是连续的，当指令送到CPU哪里的时候，指令已经被紧密的排列好（操作码）只需要“当前指令地址 + 当前指令长度 = 下一个指令的地址”，就可以一直正确的执行下去了</p><p>​        分段的好处有三点：</p><ul><li>第一，<strong>可以为它们赋予不同的属性。</strong></li></ul><p>​        例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行啦。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性</p><ul><li>第二，<strong>为了提高CPU内部缓存的命中率。</strong></li></ul><p>​        缓存起作用的原因是程序的局部性原理。在CPU内部也有缓存机制，将程序中的指令和数据分离，这有利于增强程序的局部性。CPU内部有针对数据和针对指令的两种缓存机制，因此，将数据和代码分开存储将使程序运行得更快。</p><ul><li>第三，<strong>节省内存。</strong></li></ul><p>​        程序中存在一些只读的部分，比如代码，当一个程序的多个副本同时运行时（比如同时执行多个ls命令时），没必要在内存中同时存在多个相同的代码段，这将浪费有限的物理内存资源，只要把这一个代码段共享就可以了。</p><p>​        那么问题来了：如何给那一堆东西添加属性呢？是谁做了这个事情？答案是CPU和操作系统配合着干：</p><p>​        在保护模式下，有这样一个数据结构，它叫全局描述符表（Global Descriptor Table，GDT），这个表中的每一项称为段描述符。那什么是描述符？描述符就是描述某种数据的数据结构，是元信息，属于数据的数据。就像人们的身份证，上面有写性别、出生日期、地址等描述个人情况的信息。在段描述符中有段的属性位其实是有2个，一个是S字段，占1bit大小，另外一个是占4bit大小的TYPE字段，这两个字段配合在一起使用就能组合出各种属性，如只读、向下扩展、只执行等。</p><p>​        这个表是操作系统填，操作系统在让CPU进入保护模式之前，首先要准备好GDT，也就是要设置好GDT的相关项，填写好段描述符。段描述符填写成什么样，段具备什么样的属性，这完全取决于操作系统了，在这里大家只要知道，段描述符中的S字段和TYPE字段负责该段的属性，也就是该属性与安全相关。</p><p>（1）编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如，划分出了只读属性的代码段和可写属性的数据段。再补充一下，编译器并没有让段具备某种属性，对于代码段，编译器所做的只是将代码归类到一起而已，也就是将程序中的有关代码的多个section合并成一个大的segment（这就是我们所说的代码段），它并没有为代码段添加额外的信息。</p><p>（2）操作系统通过设置GDT全局描述符表来构建段描述符，在段描述符中指定段的位置、大小及属性（包括S字段和TYPE字段）。也就是说，操作系统认为代码应该是只读的，所以给用来指向代码段的那个段描述符设置了只读的属性，这才是真正给段添加属性的地方。</p><p>（3）CPU中的段寄存器提前被操作系统赋予相应的选择子（后面章节会讲什么是选择子，暂时将其理解为相当于段基址），从而确定了指向的段。在执行指令时，会根据该段的属性来判断指令的行为，若有返回则发出异常。</p><p>​        总之，编译器、操作系统、CPU三个配合在一起才能对程序保护，检测出指令中的违规行为。如果GDT中的代码段描述符具备可写的属性，那编译器再怎么划分代码段都没有用，有判断权利的只有CPU。</p><p>​        编译器编译出来的代码段是指一片连续的内存区域。这个段有自己的起始地址，也有自己的大小范围。用户进程中的段，只是为了便于管理，而编译器或程序员在“美学方面”做出的规划，本质上它并不是CPU用于内存访问的段，但它们都是描述了一段内存，而且程序中的段，其起始地址和大小可以理解为CPU访问内存分段策略中的“段基址：段内偏移地址”，这么说来，至少它们很接近了，让我们更近一步：程序是可以被人为划分成段的，并且可以将划分出来的段地址加载到段寄存器中。看一个《操作系统还原真相》给出的例子</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">section my_code vstart&#x3D;0   ;通过远跳转的方式给代码段寄存器CS赋值0x90     jmp 0x90:start     start:       ;标号start只是为了jmp跳到下一条指令   ;初始化数据段寄存器DS     mov ax,section.my_data.start     add ax,0x900   ;加0x900是因为本程序会被mbr加载到内存0x900处     shr ax,4     ;提前右移4位,因为段基址会被CPU段部件左移4位     mov ds,ax   ;初始化栈段寄存器SS     mov ax,section.my_stack.start     add ax,0x900  ;加0x900是因为本程序会被mbr加载到内存0x900处     shr ax,4    ;提前右移4位,因为段基址会被CPU段部件左移4位     mov ss,ax     mov sp,stack_top   ;初始化栈指针   ;此时CS､DS､SS段寄存器已经初始化完成,下面开始正式工作     push word [var2]   ;变量名var2编译后变成0x4     jmp $   ;自定义的数据段 section my_data align&#x3D;16 vstart&#x3D;0     var1 dd 0x1     var2 dd 0x6   ;自定义的栈段 section my_stack align&#x3D;16 vstart&#x3D;0     times 128 db 0 stack_top:  ;此处用于栈顶,标号作用域是当前section,                 ;以当前section的vstart为基数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是一个在<strong>实模式下运行的程序</strong>，其中自定义了三个段，为了和标准的段名（.code、.data等）有所区别，这里代码段取名为my_code，数据段取名为my_data，栈段取名为my_stack。这段代码是由MBR加载到物理内存地址0x900后，mbr通过“jmp 0x900”跳过来的，我们的想法是让各段寄存器左移4位后的段基址与程序中各分段实际内存位置相同，所以对于代码段，希望其基址是0x900，故代码段CS的值为0x90（在实模式下，由CPU的段部件将其左移4位后变成0x900，所以要初始化成左移4位前的值）。但没有办法直接为CS寄存器赋值，所以在代码0-1开头，用“jmp 0x90：0”初始化了程序计数器CS和IP。这样段寄存器CS就是程序中咱们自己划分的代码段了。</p><p>​        在此提醒一下，各section中的定义都有align=16和vstart=0，这是用来指定各section按16位对齐的，各section的起始地址是16的整数倍，即用十六进制表示的话，最后一位是0。所以右移操作如第9行的shr ax，4，结果才是正确的，只是把0移出去了。否则不加align=16的话，<strong>section的地址不能保证是16的整数倍，右移4位可能会丢数据。vstart=0是指定各section内数据或指令的地址以0为起始编号，这样做为段内偏移地址时更方便。</strong></p><p>​        第6～10行是初始化数据段寄存器DS，是用程序中自已划分的段my_data的地址来初始化的。由于代码0-1本身是脱离操作系统的程序，是MBR将其加载到0x900后通过跳转指令“jmp 0x900”跳入执行的，所以要将my_data在文件内的地址section.my_data.start加上0x900才是最终在内存中的真实地址。右移4位的原因同代码段相同，都是CPU的段部件会自动将段基址左移4位，故提前右移4位。此地址作为段基址赋值给DS，这样段寄存器DS中的值是程序中咱们自己划分的数据段了。</p><p>​        第12～17行是初始化栈段寄存器，原理和数据段差不多，唯一区别是栈段初始化多了个针指针SP，为它初始化的值stack_top是最后一行，因为栈指针在使用过程中指向的地址越来越低，所以初始化时一定得是栈段的最高地址。</p><p>​        经过代码段、数据段、栈段的初始化，CPU中的段寄存器CS、DS、SS都是指向程序中咱们自己划分的段地址，之后CPU的内存分段机制“段基址：段内偏移地址”，段基址就是程序中咱们自己划分的段，段内偏移地址都是各自定义段内的指令和数据地址，由于在section中有vstart=0限制，地址都是从0开始编号的。所以，程序中的分段和CPU内存访问的分段又是一回事。</p><p>​        让我们对此感到疑惑的原因，可能是我们一般都是用高级语言开发程序，在高级语言中，程序分段这种工作不由我们控制，是由编译器在编译阶段完成的。而且现代操作系统都是在平坦模型（整个4GB空间为1个段）下工作，编译器也是按照平坦模型为程序布局，程序中的代码和数据都在同一个段中整齐排列。</p><ul><li>Section Headers：列出了程序中所有的section，这些section是gcc编译器帮忙划分的。</li><li>Program Headers：列出了程序中的段，即segment，这是程序中section合并后的结果。</li><li>Section to Segment mapping：列出了一个segment中包含了哪些section。</li></ul><p>​        在Section Headers和Program Headers中您会发现，这些分段都是按照地址由低到高在4GB空间中连续整洁地分布的，在平坦模型下和谐融洽。</p><p>​        显然，不用程序员手工分段，并且采用平坦模型，这种操作上的“隔离”固然让我们更加方便，但也让我们更加感到进程空间布局的神秘。如果程序分段像代码0-1那样地直白、亲民，大家肯定不会感到迷惑了。其实我想说的是无论是否为平坦模型，程序中的分段和CPU中的内存分段机制，它们属于物品与容器的关系。</p><p>​        举个例子，程序中划分的段相当于各种水果，比如代码段相当于香蕉，数据段相当于葡萄，栈段相当于西瓜。CPU内存分段策略中的段寄存器相当于盛水果的盘子。可以用一个大盘子将各种水果都放进来，但依然是分门别类地摆放，不能失去美感混成一锅粥，这就是段大小为4GB的平坦模型。</p><p>​        总结一下，程序中的段只是逻辑上的划分，用于不同数据的归类，但是可以用CPU中的段寄存器直接指向它们，然后用内存分段机制去访问程序中的段，在这一点上看，它们很像相片和相框的关系：程序中的段是内存中的内容，相当于相片，属于被展示的内容，而内存分段机制则是访问内存的手段，相当于相框，有了相框，照片才能有地摆放。</p><p>​        我想大家应该已经搞清楚了内存分段和程序分段的关系，其实就是一回事，内存分段指的是处理器为访问内存而采用的机制，<strong>称之为内存分段机制，程序分段是软件中人为逻辑划分的内存区域，它本身也是内存，所以处理器在访问该区域时，也会采用内存分段机制，用段寄存器指向该区域的起始地址。</strong></p><h4 id="物理地址，逻辑地址，有效地址，线性地址，虚拟地址的区别"><a href="#物理地址，逻辑地址，有效地址，线性地址，虚拟地址的区别" class="headerlink" title="物理地址，逻辑地址，有效地址，线性地址，虚拟地址的区别"></a>物理地址，逻辑地址，有效地址，线性地址，虚拟地址的区别</h4><p>​        物理地址：物理地址就是内存单元的绝对地址，不管CPU内部怎么处理地址，最终访问的都是物理地址。在CPU实模式下“段基址+段内偏移地址”就是物理地址，CPU可以使用此地址直接访问内存。</p><p>​        线性地址、虚拟地址：C<strong>PU在保护模式下，“段基址+段内偏移地址”叫做线性地址，注意，保护模式下段基址寄存器中存储的不是真正的段基值（和实模式的含义不一样），而是被称为“段选择子”的东西，通过段选择子在GDT（全局描述表）中找到真正的段基值。</strong>另外，如果CPU在保护模式下没有开启分页功能，则线性地址就被当做最终的物理地址来用，若开启了分页功能，则线性地址就叫虚拟地址（在没开启分页功能的情况下线性地址和虚拟地址就是一回事）。但是，如果开启分页功能，虚拟地址（或线性地址）还要通过页部件电路转换成最终的物理地址。</p><p>​        逻辑地址、有效地址：无论CPU在什么模式下，段内偏移地址又称为有效地址或者逻辑地址（只是叫法不一样罢了），例如实模式下 “mov ax, [0x7c00]”，0x7c00就是逻辑地址（或有效地址），但这条指令最终操作的物理地址是DS*16+0x7c00</p><h4 id="大端字节序和小端字节序"><a href="#大端字节序和小端字节序" class="headerlink" title="大端字节序和小端字节序"></a>大端字节序和小端字节序</h4><h5 id="大端字节序-Big-Endian"><a href="#大端字节序-Big-Endian" class="headerlink" title="大端字节序(Big Endian)"></a>大端字节序(Big Endian)</h5><p>高位字节数据存放在内存低地址处，低位字节数据存放在内存高地址处。</p><h5 id="小端字节序-Little-Endian"><a href="#小端字节序-Little-Endian" class="headerlink" title="小端字节序(Little Endian)"></a>小端字节序(Little Endian)</h5><p>高位字节数据存放在内存高地址处，低位数据存放在内存低地址处。</p><h4 id="BIOS中断-DOS中断-Linux中断的区别"><a href="#BIOS中断-DOS中断-Linux中断的区别" class="headerlink" title="BIOS中断 DOS中断 Linux中断的区别"></a>BIOS中断 DOS中断 Linux中断的区别</h4><p>​        BIOS和DOS都是存在于实模式下的程序，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的。它们都是通过软中断指令int 中断号来调用的。</p><p>​        中断向量表中的每个中断向量大小是4字节。这4字节描述了一个中断处理例程（程序）的段基址和段内偏移地址。因为中断向量表的长度为1024字节，故该表最多容纳256个中断向量处理程序。计算机启动之初，中断向量表中的中断例程是由BIOS建立的，它从物理内存地址0x0000处初始化并在中断向量表中添加各种处理例程。</p><p>​        BIOS中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。这句话是否也表明了不通过BIOS调用也是可以访问硬件的？必须是的，否则BIOS中断处理程序又是如何操作硬件呢？操作硬件无非是通过in/out指令来读写外设的端口，BIOS中断程序处理是用来操作硬件的，故该处理程序中一定到处都是in/out指令。</p><p>​        BIOS为什么添加中断处理例程呢？</p><p>（1）给自己用，因为BIOS也是一段程序，是程序就很可能要重复性地执行某段代码，它直接将其写成中断函数，直接调用多省心。</p><p>（2）给后来的程序用，如加载器或boot loader。它们在调用硬件资源时就不需要自己重写代码了。</p><p>BIOS是如何设置中断处理程序的呢？</p><p>BIOS也要调用别人的函数例程。每个外设，包括显卡、键盘、各种控制器等，都有自己的内存（主板也有自己的内存，BIOS就存放在里面），不过这种内存都是只读存储器ROM。硬件自己的功能调用例程及初始化代码就存放在这ROM中。根据规范，第1个内存单元的内容是0x55，第2个存储单元是0xAA，第3个存储单位是该rom中以512字节为单位的代码长度。从第4个存储单元起就是实际代码了，直到第3个存储单元所示的长度为止。</p><p>有问题了，CPU如何访问到外设的ROM呢？</p><p>访问外设有两种方式。</p><p>（1）内存映射：通过地址总线将外设自己的内存映射到某个内存区域（并不是映射到主板上插的内存条中）。</p><p>（2）端口操作：外设都有自己的控制器，控制器上有寄存器，这些寄存器就是所谓的端口，通过in/out指令读写端口来访问硬件的内存。</p><p>​        控制显卡用的便是内存映射+端口操作的方式，这个以后说。</p><p>​        从内存的物理地址0xA0000开始到0xFFFFF这部分内存中，一部分是专门用来做映射的，如果硬件存在，硬件自己的ROM会被映射到这片内存中的某处，至于如何映射过去的，咱们暂时先不要深入了，这是硬件完成的工作。</p><p>​        如图0-11所示，BIOS在运行期间会扫描0xC0000到0xE0000之间的内存，若在某个区域发现前两个字节是0x55和0xAA时，这意味着该区域对应的rom中有代码存在，再对该区域做累加和检查，若结果与第3个字节的值相符，说明代码无误，就从第4个字节进入。这时开始执行了硬件自带的例程以初始化硬件自身，最后，BIOS填写中断向量表中相关项，使它们指向硬件自带的例程。</p><p><img src="f9f81f9e35e20bca9eb49f0705a0031a9f0b56e8 (2" alt="f9f81f9e35e20bca9eb49f0705a0031a9f0b56e8 (2)">.png)</p><p>中断向量表中第0H～1FH项是BIOS中断。</p><p>​        另外，上面说的是BIOS在填写中断向量表，那该表是谁创建的呢？答案就是CPU原生支持的，不用谁负责创建。之前我曾说过，软件是靠硬件来运行的，软件能实现什么功能，很大程度上取决于硬件提供了哪些支持。软件中只要执行int 中断向量号，CPU便会把向量号当作下标，去中断向量表中定位中断处理程序并执行。<br>DOS是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和BIOS的不能冲突。</p><p>0x20～0x27是DOS中断。因为DOS在实模式下运行，故其可以调用BIOS中断。</p><p>​        DOS中断只占用0x21这个中断号，也就是DOS只有这一个中断例程。</p><p>​        DOS中断调用中那么多功能是如何实现的？是通过先往ah寄存器中写好子功能号，再执行int 0x21。这时在中断向量表中第0x21个表项，即物理地址0x21*4处中的中断处理程序开始根据寄存器ah中的值来调用相应的子功能。</p><p>​        而Linux内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）。该表与中断向量表的区别会在讲解中断时详细介绍。所以在Linux下执行的中断调用，访问的中断例程是在中断描述符表中，已不在中断向量表里了。</p><p>​        Linux的系统调用和DOS中断调用类似，不过Linux是通过int 0x80指令进入一个中断程序后再根据eax寄存器的值来调用不同的子功能函数的。再补充一句：如果在实模式下执行int指令，会自动去访问中断向量表。如果在保护模式下执行int指令，则会自动访问中断描述符表。</p><h4 id="section和segment的区别"><a href="#section和segment的区别" class="headerlink" title="section和segment的区别"></a>section和segment的区别</h4><p>​        C程序大体上分为<strong>预处理、编译、汇编和链接</strong>4个阶段。</p><ol><li>预处理阶段是预处理器将<strong>高级语言中的宏展开，去掉代码注释，为调试器添加行号等。</strong></li><li>编译阶段是将预处理后的高级语言进行<strong>词法分析、语法分析、语义分析、优化，最后生成汇编代码。</strong></li><li>汇编阶段是将汇编代码编译成目标文件，也就是转换成了目标机器平台上的机器指令。</li><li>链接阶段是将目标文件连接成可执行文件。这里我们只关注汇编和链接这两个阶段。</li></ol><p>​        在汇编源码中，通常用语法关键字section或segment来表示一段区域，它们是编译器提供的伪指令，作用是相同的，都是在程序中“逻辑地”规划一段区域，此区域便是节。注意，此时所说的section或segment都是汇编语法中的关键字，它们在语法中都表示“节”，不是段，<strong>只是不同编译器的关键字不同而已</strong>，关键字segment在语法中也被认为与section意义相同。首先汇编器根据语法规则，会将汇编源码中表示“节”的语法关键字section或segment在目标文件中编译成“节”，此“节”便是我们要讨论的section。经过汇编生成目标文件之后，由这些section或segment修饰的程序区域便成为了“节”（section）。但操作系统加载程序时并不关心节的数量和大小，操作系统只关心节的属性，因为程序必然是要加载到内存中才能运行的，而内存的访问会涉及到全局描述符表中段描述符的访问权限等属性，<strong>保护模式下对任何内存的访问都要经过段描述符才行</strong>。比如程序代码所在的段描述符权限属性必须是只读，数据所在的段描述符的权限属性必然是可读写，程序中那些只读的节（比如代码区域）必然不能指向可读写的段描述符，同样，程序中的数据也不能用只读权限的段描述符去访问。</p><p>​        操作系统在加载程序时，不需要对逐个节进行加载，只要给出相同权限的节的集合就行了，例如把所有只读可执行的节（如代码节.text和初始化代码节.init）归并到一块，所有可读写的节（如数据节.data和未初始化节.bss）归并到一块，这样操作系统就能为它们分配不同的段选择子，从而指向不同段描述符，实现不同的访问权限了。为了程序能在操作系统上运行，操作系统和编译器需要相互配合，此时汇编器只生成了目标文件，尚未链接，因此这个将“节”合并的工作是由链接器来完成的，链接器将目标文件中属性相同的节合并成一个大的section集合，此集合便称为segment，也就是段，此段便是我们平时所说的可执行程序内存空间中的代码段和数据段。</p><p>​        section称为节，是指在汇编源码中经由关键字section或segment修饰、逻辑划分的指令或数据区域，汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中。</p><p>​        segment称为段，是链接器根据目标文件中属性相同的多个section合并后的section集合，这个集合称为segment，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中。我们平时所说的可执行程序内存空间中的代码段和数据段就是指的segment。</p><p>​        现在通过实验结果来展示出这两者的不同。其实用一个测试样例就能得出结果，不过为了消除大家的疑虑，测试得更彻底一点，在这里给大家准备了两个小汇编文件，将它们编译链接后，我们通过readelf命令查看其信息来得出结论</p><p><img src="fd227d1e6089d0920858a19ea87162dc332ef4e9.png" alt="fd227d1e6089d0920858a19ea87162dc332ef4e9"></p><p>​        这个汇编文件是在本地中声明了字符串，并调用外部的打印函数print</p><p><img src="8a6fe865f3f15d722e7a0cf45db77b43a5f843c2.png" alt="8a6fe865f3f15d722e7a0cf45db77b43a5f843c2"></p><p>​        在文件2中声明了函数print。下面将这两个文件分别编译成elf格式，这样方便我们通过readelf来查看其编译结果。开始编译，链接成可执行文件12。</p><pre class="line-numbers language-none"><code class="language-none">nasm -f elf 1.asm -o 1.onasm -f elf 2.asm -o 2.old 1.o 2.o -o 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>没问题，再执行一下。</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;12Hello，world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打印出了Hello，world!，结果正确。让我们用readelf查看下文件12的头信息，如图0-12所示。</p><p><img src="14951c16764c8084afdf153312d35de6e2d081f3.png" alt="14951c16764c8084afdf153312d35de6e2d081f3"></p><p><img src="8922afffe318c1a622047fcbccc7f1e1087e9350.png" alt="8922afffe318c1a622047fcbccc7f1e1087e9350"></p><p>​        要注意section headers的部分，此部分显示可执行文件中所有的section，也包括我们在两个汇编文件中用关键字section定义的部分。从第2个section到第5个section，是1.asm中的自定义数据section: file1data，自定义代码section: file1text和2.asm中的自定义数据section: file2data和自定义代码section: file2text。</p><p>​        再往下看Program Headers部分，此处一共有两个段，第一个段是我们的代码段，通过其Flg值为RE便可推断，只读（Readonly）可执行（Execute），其MemSiz为0x000c3。此段对应Section to Segment mapping部分中的第00个Segment，此segment中包括section: .text file1data file1text file2data file2text。</p><p><img src="8787da914b117506b98534bf26c5e8df590b1483.png" alt="8787da914b117506b98534bf26c5e8df590b1483"></p><p>​        第二个段便是我们的数据段，但此数据段中只包含.bss节（section），它用于存储全局未初始化数据，故其Flg必然可读写，其属性为RW。此段MemSiz大小为0x40，即十进制的64，可见，这和1.asm中定义的bss大小一致，而在2.asm中未定义.bbs section，所以此bss指的就是1.asm中的定义。此段对应Section to Segment mapping部分中的第01 个Segment，而此segment只包括.bss节，独立成一个段了。</p><p>​        自定义的section名，会在elf的section header 中显示出来。下面是几个标准的section（节）名，不是segment（段）名，segment没有名称。</p><pre class="line-numbers language-none"><code class="language-none">节名     说明.data   用于存入数据，可读可写.text   用于存入代码，只读可执行.bss    全局未初始化区域<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        在汇编代码中，若以标准节名定义section，如我们定义的.bss便是标准节名。编译器会按照以上说明中的要求使用section内的数据。</p><p>​        不管定义了多少节名，最终要把属性相同的section，或者编译认为可以放到一块的，合并到一个大的segment中，也就是elf中说的 program header 中的项。由此可见，某个节（section）属于某个段（segment），段是由节组成的。另外多说一句，最终给加载器用的也是program header中显示的段，这才是进程的资源，这部分内容将在加载内核时展开。</p><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><p>​        指令集就是指令的集合，为一串特定的比特序列命名成一个我们人可以一下子读懂的序列。比如说add。</p><p>​        最早的指令级是CISC，而后才是RISC。他们的区别这里不展开，简单的讲就是从复杂走向简练的过程。</p><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><p>​        用户程序不具备独立打印字符的功能，它必须借助操作系统的力量才可以，如何借助呢？操作系统提供了一套系统调用接口，用户进程直接调用这些接口就行啦。简单来说，接口就是某个功能模块的入口，通过接口给该模块一个输入，它就返回一个输出，模块内部实现的过程就像个黑盒子一样，咱们看不到，也无需关心。我们能够打印字符的原因就是调用了系统调用，但是大家确实没有亲手写下调用系统调用的代码（后面章节会说），这就是库函数的功劳，它帮你写下了这些。</p><p>​        但我们并没有看到库函数的实现，我们只是包含了所需要的库函数所在的头文件，该头文件中有这样一句函数的声明。比如printf函数所在的头文件是stdio.h，该文件位于磁盘/usr/include/目录下，其中第361行是对printf的声明。</p><pre class="line-numbers language-none"><code class="language-none">extern int printf (__const char *__restrict __format,...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        头文件被包含进来后，其内容也是原样被展开到include所在的位置，就是把整个头文件中的内容挪了过来，所以在头文件中的内容是什么都可以，未必一定要是函数声明</p><p>​        如果在头文件中定义的是printf函数的实现，也许就容易理解头文件帮我们做了什么，可是事实不是这样的，头文件中一般仅仅有函数声明，这个声明告诉编译器至少两件事。</p><p><strong>（1）函数返回值类型、参数类型及个数，用来确定分配的栈空间。</strong></p><p><strong>（2）该函数是外部函数，定义在其他文件，现在无法为其分配地址，需要在链接阶段将该函数体所在的目标文件一同链接时再安排地址。</strong></p><p>这第二件事是我们所说的重点。</p><p>​        如果预处理后，主调函数所在的文件中找不到所调用函数的函数体，一定要在链接阶段把该函数体所在的目标文件链接进来，否则程序在道理上都讲不通，怎么能通过编译呢。</p><p>​        您看到了，main.c中我把func_inc.d包含进来，include后面并不是尖括号而是双引号“？”，这用的是自定义文件的包含，并不是包含标准文件（也就是平时我们所说的标准库头文件）。如果用了尖括号，系统就会到默认路径下去搜索该头文件。搜索到头文件后，找到其中被调函数的声明，再到另一默认文件中找该函数体的实现。</p><p>​        另一默认文件，按理来说应该是目标文件。它到底在哪里呢？</p><p>​        gcc编译时加-v参数会将编译、链接两个过程详细地打印出来，如图0-16所示。</p><p><img src="2087593a46fed4958ce74a8d59b0c804ac05f32c.png" alt="2087593a46fed4958ce74a8d59b0c804ac05f32c"></p><p>gcc内部也要将C代码经过编译、汇编、链接三个阶段。</p><p>（1）编译阶段是将C代码翻译成汇编代码，由最上面的框框中的C语言编译器cc1来完成，它将C代码文件main.c翻译成汇编文件ccymR62K.s。</p><p>（2）汇编阶段是将汇编代码编译成目标文件，用第二个框框中的汇编语言编译器as完成，as将汇编文件ccymR62K.s编译成目标文件cc0yJGmy.o。</p><p>（3）链接阶段是将所有使用的目标文件链接成可执行文件，这是用左边最下面框框中的链接器collect2来完成的，它只是链接命令ld的封装，最终还是由ld来完成，在这一堆.o文件中，有咱们上面的目标文件cc0yJGmy.o。</p><p>以上我们想展开说的是第3点：链接阶段。</p><p>​        大家看到了，实际参与链接的有多个.o文件，这些都是目标文件，也就是函数体所在的文件。printf的函数体就在这里面其中某个.o文件中，而且，printf中也要调用其他函数，这些被调用的函数也分布在这些.o文件之中。</p><p>​        在图-16中的链接阶段，链接器collect2的参数除了有咱们的main.c生成的目标文件cc0yJGmy.o以外，还有以下这几个以crt开头的目标文件：crt1.o，crti.o，crtbegin.o，crtend.o，crtn.o。</p><p>crt是什么？CRT，即C Run-Time library，是C运行时库。运行时库是程序在运行时所需要的库，该库是由众多可复用的函数文件组成的，由编译器提供。所以，C运行时库，就是C程序运行时所需要的库文件，在我们的环境中，它由gcc提供。</p><p>​        在程序中简单地一句include &lt;标准头文件&gt;之所以有效，是因为编译器提供的C运行库中已经为我们准备好了这些标准函数的函数体所在的目标文件，在链接时默默帮我们链接上了。这些目标文件都是待重定位文件，重定位文件意思是文件中的函数是没有地址的，用file命令查看它们时会显示relocatable，它们中的地址是在与用户程序的目标文件链接成一个可执行文件时由链接器统一分配的。所以C运行时库中同样的函数与不同的用户程序链接时，其生成的可执行文件中分配给库函数的地址都可能是不同的。每一个用户程序都需要与它们链接合并成一个可执行文件，所以每一个可执行文件中都有这些库文件的副本，这些库文件相当于被复制到每个用户程序中。所以您清楚了，即使咱们的代码只有十几个字符，最终生成的文件也要几KB，就是这个道理。</p><p>​        总结一下：</p><p>（1）<strong>操作系统有自己支持、加载用户进程的规则，而C运行时库是针对此操作系统的规则，为了让用户程序开发更加容易，用来支持用户进程的代码库。</strong>大家要明白，之所以我们写个程序又链接这又链接那的，完全是因为操作系统规定这样做。</p><p>（2）用户进程要与C运行时库的诸多目标文件链接后合并成一个可执行文件，也就是说我们的用户进程被加进了大量的运行库中的代码。</p><p>（3）C运行时库作用如其名，是提供程序运行时所需要的库文件，而且还做了程序运行前的初始化工作，所以即使不包含标准库文件，链接阶段也要用到c运行时库。</p><p>（4）用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用，它是用户进程和操作系统之间的“钩子”，用户进程顶多算是个半成品，只有通过钩子挂上了操作系统，加了上所需要的操作系统的那部分代码，用户程序才能做完一件事，这才算完整，后面章节会有详解。</p><p>（5）尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效。</p><p>这里补充点内容：</p><p>​        库函数其实就是一个函数定义，比如常见read()、write()等函数说明了如何获得一个给定的服务，但是<strong>系统调用是通过软中断向内核发出一个明确的请求，再者系统调用是在内核完成的，而用户态的函数是在函数库完成的</strong>。</p><p>​        系统调用发生在内核空间，因此如果在用户空间的一般应用程序中使用系统调用来进行文件操作，<strong>会有用户空间到内核空间切换的开销</strong>。事实上，即使在用户空间使用库函数来对文件进行操作，因为文件总是存在于存储介质上，因此不管是读写操作，都是<strong>对硬件（存储器）的操作，都必然会引起系统调用</strong>。也就是说，库函数对文件的操作实际上是通过系统调用来实现的。例如C库函数fwrite()就是通过write()系统调用来实现的。</p><p>​        这样的话，使用库函数也有系统调用的开销，为什么不直接使用系统调用呢？这是因为可以提升效率，减少频繁的状态切换，读写文件通常是大量的数据（这种大量是相对于底层驱动的系统调用所实现的数据操作单位而言），这时，使用库函数就可以大大减少系统调用的次数。这一结果又缘于缓冲区技术。在用户空间和内核空间，对文件操作都使用了缓冲区，例如用fwrite写文件，都是先将内容写到用户空间缓冲区，当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓冲区，同样的道理，当内核缓冲区满或写结束时才将内核缓冲区内容写到文件对应的硬件媒介。</p><p>​        系统调用与系统命令：系统命令相对API更高一层，每个系统命令都是一个可执行程序，比如常用的系统命令ls、hostname等，比如strace ls就会发现他们调用了<br>诸如open(),brk(),fstat(),ioctl()等系统调用。</p><p>​        <strong>系统调用是用户进程进入内核的接口层，它本身并非内核函数，但他是由内核函数实现的，进入系统内核后，不同的系统调用会找到各自对应的内核函数，这些内核函数被称为系统调用的“服务例程”。也可以说系统调用是服务例程的封装例程。</strong></p><p>（参考博客<a href="https://www.cnblogs.com/friedCoder/articles/12390236.html">系统调用、库函数和内核函数关系与区别 - friedCoder - 博客园 (cnblogs.com)</a>）</p><h4 id="MBR-EBR-DBR-OBR"><a href="#MBR-EBR-DBR-OBR" class="headerlink" title="MBR EBR DBR OBR"></a>MBR EBR DBR OBR</h4><p>​        这几个概念主要是围绕计算机系统的控制权交接展开的，整个交接过程就是个接力赛，咱们从头梳理。</p><p>​        计算机在接电之后运行的是基本输入输出系统BIOS，BIOS是位于主板上的一个小程序，其所在的空间有限，代码量较少，功能受限，因此它不可能一人扛下所有的任务需求，也就是肯定不能充当操作系统的角色（比如说让BIOS运行QQ是不可能的），必须采取控制权接力的方式，一步步地让处理器执行更为复杂强大的指令，最终把处理器的使用权交给操作系统</p><p>​        采用接力式控制权交接，BIOS只完成一些简单的检测或初始化工作，然后找机会把处理器使用权交出去。交给谁呢？下一个接力棒的选手是MBR，为了方便BIOS找到MBR，MBR必须在固定的位置等待，因此MBR位于整个硬盘最开始的扇区。</p><p>​        MBR是主引导记录，Master或Main Boot Record，它存在于整个硬盘最开始的那个扇区，即0盘0道1扇区，这个扇区便称为MBR引导扇区。注意这里用CHS方式表示MBR引导扇区的地址，因此扇区地址以1开始，顺便说一句，LBA方式是以0为起始为扇区编址的，有关CHS和LBA的内容会在后面章节介绍。一般情况下扇区大小是512字节，但大伙儿不要把这个当真理，有的硬盘扇区并不是512字节。在MBR引导扇区中的内容是：</p><p>（1）446字节的引导程序及参数；</p><p>（2）64字节的分区表；</p><p>（3）2字节结束标记0x55和0xaa。</p><p>​        在MBR引导扇区中存储引导程序，为的是从BIOS手中接过系统的控制权，也就是处理器的使用权。任何一棒的接力都是由上一棒跳到下一棒，也就是上一棒得知道下一棒在哪里才能跳过去，否则权利还是交不出去。BIOS知道MBR在0盘0道1扇区，这是约定好的，因此它会将0盘0道1扇区中的MBR引导程序加载到物理地址0x7c00，然后跳过去执行，这样BIOS就把处理器使用权移交给MBR了。</p><p>​        既然MBR称为“主”引导程序，有“主”就得有“次”， MBR的作用相当于下一棒的引导程序总入口，BIOS把控制权交给MBR就行了，由MBR从众多可能的接力选手中挑出合适的人选并交出系统控制权，这个过程就是由“主引导程序”去找“次引导程序”，这么说的意思是“次引导程序”不止一个。也许您会问，为什么BIOS不直接把控制权交给“次引导程序”？原因是BIOS受限于其主板上的存储空间，代码量有限，本身的工作还做不过来呢，因此心有余而力不足。好啦，下面开始下一轮的系统控制权接力。不要忘了，MBR引导扇区中除了引导程序外，还有64字节大小的分区表，里面是分区信息。分区表中每个分区表项占16字节，因此MBR分区表中可容纳4个分区，这4个分区就是“次引导程序”的候选人群，MBR引导程序开始遍历这4个分区，想找到合适的人选并把系统控制权交给他。</p><p>​        通常情况下这个“次引导程序”就是操作系统提供的加载器，因此MBR引导程序的任务就是把控制权交给操作系统加载器，由该加载器完成操作系统的自举，最终使控制权交付给操作系统内核。但是各分区都有可能存在操作系统，MBR也不知道操作系统在哪里，它甚至不知道分区上的二进制01串是指令，还是普通数据</p><p>​        为了让MBR知道哪里有操作系统，我们在分区时，如果想在某个分区中安装操作系统，就用分区工具将该分区设置为活动分区，设置活动分区的本质就是把分区表中该分区对应的分区表项中的活动标记为0x80。MBR知道“活动分区”意味着该分区中存在操作系统，这也是约定好的。活动分区标记位于分区表项中最开始的1字节，<strong>其值要么为0x80，要么为0，其他值都是非法的。</strong>0x80表示此分区上有引导程序，0表示没引导程序，该分区不可引导。MBR在分析分区表时通过辨识“活动分区”的标记0x80开始找活动分区，如果找到了，就将CPU使用权交给此分区上的引导程序，此引导程序通常是内核加载器，下面就直接以它为例。</p><p>​        “控制权交接”是处理器从“上一棒选手”跳到“下一棒选手”来完成的，内核加载器的入口地址是这里所说的“下一棒选手”，但是内核加载器在哪里呢？为了MBR方便找到活动分区上的内核加载器，内核加载器的入口地址也必须在固定的位置，这个位置就是各分区最开始的扇区，这也是约定好的。这个“各分区起始的扇区”中存放的是操作系统引导程序——内核加载器，因此该扇区称为<strong>操作系统引导扇区</strong>，其中的引导程序（内核加载器）称为操作系统引导记录OBR，即OS Boot Record，此扇区也称为OBR引导扇区。在OBR扇区的前3个字节存放了跳转指令，这同样是约定，因此MBR找到活动分区后，就大胆主动跳到活动分区OBR引导扇区的起始处，该起始处的跳转指令马上将处理器带入操作系统引导程序，从此MBR完成了交接工作</p><p>​        不过OBR中开头的跳转指令跳往的目标地址并不固定，这是由所创建的文件系统决定的，对于FAT32文件系统来说，此跳转指令会跳转到本扇区偏移0x5A字节的操作系统引导程序处。不管跳转目标地址是多少，总之那里通常是操作系统的内核加载器。OBR是从DBR遗留下来的，要想了解OBR，还是先从了解DBR开始。DBR是DOS Boot Record，也就是DOS操作系统的引导记录（程序），DBR中的内容大概是：</p><p>（1）跳转指令，使MBR跳转到引导代码；</p><p>（2）厂商信息、DOS版本信息；</p><p>（3）BIOS参数块BPB，即BIOS Parameter Block；</p><p>（4）操作系统引导程序；</p><p>（5）结束标记0x55和0xaa。</p><p>​        在DOS时代只有4个分区，不存在扩展分区，这4个分区都相当于主分区，所以各主分区最开始的扇区称为DBR引导扇区。后来有了扩展分区之后，无论分区是主分区，还是逻辑分区，为了兼容，分区最开始的扇区都作为DOS引导扇区<strong>。但是其他操作系统如UNIX，Linux等为了兼容MBR也传承了这个习俗，都将各分区最开始的扇区作为自己的引导扇区，在里面存放自己操作系统的引导程序。由于现在这个“分区最开始的扇区”引导的操作系统类型太多了，而且DOS还退出历史舞台了，所以DBR也称为OBR。</strong></p><p>​        这里提到了扩展分区就不得不提到EBR。当初为了解决分区数量限制的问题才有了扩展分区，EBR是扩展分区中为了兼容MBR才提出的概念，主要是兼容MBR中的分区表。分区是用分区表来描述的，MBR中有分区表，扩展分区中的是一个个的逻辑分区，因此扩展分区中也要有分区表，为扩展分区存储分区表的扇区称为EBR，即Expand Boot Record，从名字上看就知道它是为了“兼容”而“扩展”出来的结构，兼容的内容是分区表，因此它与MBR结构相同，只是位置不同，EBR位于各子扩展分区中最开始的扇区（注意，各主分区和各逻辑分区中最开始的扇区是操作系统引导扇区），理论上MBR只有1个，EBR有无数个。有关扩展分区的内容还是要参见后面有关分区的章节，那里介绍得更细致。</p><p>​        EBR与MBR结构相同，但位置和数量都不同，整个硬盘只有1个MBR，其位于整个硬盘最开始的扇区——0道0道1扇区。而EBR可有无数个，具体位置取决于扩展分区的分配情况，总之是位于各子扩展分区最开始的扇区，如果此处不明白子扩展分区是什么，到了以后跟踪分区的章节中大伙儿就会明白。OBR其实就是DBR，指的都是操作系统引导程序，位于各分区（主分区或逻辑分区）最开始的扇区，访扇区称为操作系统引导扇区，即OBR引导扇区。OBR的数量与分区数有关，等于主分区数加逻辑分区数之和，友情提示：一个子扩展分区中只包含1 个逻辑分区。</p><p>​        MBR和EBR是分区工具创建维护的，不属于操作系统管理的范围，因此操作系统不可以往里面写东西，注意这里所说的是“不可以”，其实操作系统是有能力读写任何地址的，只是如果这样做的话会破坏“系统控制权接力赛”所使用的数据，下次开机后就无法启动了。OBR是各分区（主分区或逻辑分区）最开始的扇区，因此属于操作系统管理。</p><p>​        DBR、OBR、MBR、EBR都包含引导程序，因此它们都称为引导扇区，只要该扇区中存在可执行的程序，该扇区就是可引导扇区。若该扇区位于整个硬盘最开始的扇区，并且以0x55和0xaa结束，BIOS就认为该扇区中存在MBR，该扇区就是MBR引导扇区。若该扇区位于各分区最开始的扇区，并且以0x55和0xaa结束，MBR就认为该扇区中有操作系统引导程序OBR，该扇区就是OBR引导扇区。</p><p>​        DBR、OBR、MBR、EBR结构中都有引导代码和结束标记0x55和0xaa，因此很多同学都容易把它们搞混。不过它们最大的区别是分区表只在MBR和EBR中存在，DBR或OBR中绝对没有分区表。MBR、EBR、OBR的位置关系如图0-21所示。</p><p><img src="6eb973bc6bb56bddf8a1576fa4698494c94ecab0.png" alt="6eb973bc6bb56bddf8a1576fa4698494c94ecab0"></p><h1 id="MBR主引导记录"><a href="#MBR主引导记录" class="headerlink" title="MBR主引导记录"></a>MBR主引导记录</h1><h2 id="细说电脑开机过程"><a href="#细说电脑开机过程" class="headerlink" title="细说电脑开机过程"></a>细说电脑开机过程</h2><p>​        我们的计算机摁下开机键后，我们运行的第一个软件就是BIOS，全程就是<code>Basic Input Output System</code>，我们现在就有问题</p><ul><li>谁加载？</li><li>加载到哪里</li><li>他的CS:IP谁来改</li></ul><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h2><p>​        Intel 8086有二十根地址线，可以访问1MB内存大小，也就是说可以访问$2^{20}$B的大小，也就是1MB大小的内存。地址用一个五字节的数描述：0x00000 ~ 0xFFFFF</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phZGVzaHU=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>​        让我们看看：现在从低地往上看，也就是看看从0到0x9FFFF地址处就是DRAM，这个指的是动态的RAM（随机存储器），这里若是我们知道硬件的知识就会知道这说明构成RAM的电容是充放电迅速的，数据易失的。</p><p>​        我们看到F0000到FFFEF这个位置，存放的就是BIOS的代码。这里，BIOS会建立中断向量表（Interrupt Vector Table），我们就是这样建立起<code>&quot;int&quot;</code>中断号来实现相关的硬件调用。当然，这里只是完成最基础的一些工作。</p><p>​        我们知道，为什么BIOS分明在主板上却在实模式上访问不到1MB以外的内存呢？答案是——地址总线的宽度太小，我们的硬件需要经过地址分配映射到地址总线可以访问到的编号大小才可以。所以，在实模式下只好访问1MB了。</p><h2 id="BIOS的启动过程"><a href="#BIOS的启动过程" class="headerlink" title="BIOS的启动过程"></a>BIOS的启动过程</h2><p>​        啥？BIOS也启动？事实上，BIOS的代码是厂家已经烧录进ROM（只读存储器）的，这个ROM的内存被映射到了低端1MB的上端（这个映射是实际操作硬件完成的）</p><p>​        BIOS既然是一个程序，就需要执行代码，但是只有16B，只能执行一条：不难猜到就是跳转指令！</p><pre class="line-numbers language-none"><code class="language-none">[0x0000fffffff0] f000:fff0 (unk. ctxt): jmpf 0xf000:e05b          ; ea5be000f0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这就是我在启动BIOS的时候抓取到的代码，可以看到，跳转到的地方，也就是0xfe05b这个地方继续执行。</p><h2 id="0x7c00"><a href="#0x7c00" class="headerlink" title="0x7c00"></a>0x7c00</h2><p>​        这里是MBR的地址，但是我们先按顺序继续说。BIOS的最后一项工作就是检查位于0盘0道1扇区的内容。这个扇区有这样的规定</p><blockquote><p><strong>若这块内存的结尾是0x55和0xaa，BIOS将会认为这个扇区存在一个神秘的引导程序，也就是MBR其实。</strong></p></blockquote><p>​        无论是怎样的介质——软盘，硬盘还是什么，只要看到这两个数，就认为这是MBR。</p><p>​        那么为什么是0x7C00呢？答案是这样的，早期只有16位机和32位机，我们的研发工程师就默认32KB了，会在最后（为什么是最后呢？答案是MBR主要就是引导其他机器码进来（<strong>jmp xxx），随后就没用了，可以被覆盖从而实现内存的复用，为了使得MBR保险起见不被过早覆盖，就放到后面了）的地址内存空间。也就是0x8000 - 0x0400 = 0x7C00</strong>这就是这个数字的来历：DOS1.0要求最小的空间32KB 减去MBR自己的大小。这下就对了。</p><h2 id="实验：尝试写一个简单的mbr-s"><a href="#实验：尝试写一个简单的mbr-s" class="headerlink" title="实验：尝试写一个简单的mbr.s"></a>实验：尝试写一个简单的mbr.s</h2><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">;Main Guide Program;-------------------------------------------------SECTION MBR vstart&#x3D;0x7c00mov ax, csmov ds, axmov es, axmov ss, axmov fs, axmov sp, 0x7c00 ; 指引调用栈指针指向BIOS加载;-------------------------------------------------; INT 0x10功能号是:0x06，也就是上卷窗口;-------------------------------------------------;输入;AH &#x3D; 0x06;AL &#x3D; 上卷行数（0表示全部上卷）;BH &#x3D; 上卷行属性;(CL, CH) &#x3D; 窗口左上角的位置;(DL, DH) &#x3D; 窗口的右下角位置; no returnmov ax, 0x600mov bx, 0x700mov cx, 0;左上角mov dx, 0x184f;右下角，VGA文本模式下全屏大小是80个字符呈上25行，下标从0开始，那就是0x 18 4fint 0x10;触发0x10号中断;---------获取光标位置------------------;.cursor获取当前位置且在光标处打印字符mov ah, 3mov bh, 0int 0x10;-------------------------------------;-----------打印字符串-----------------mov ax, messagemov bp, ax; es:bp是串的首地址，es跟cs此时一致mov cx, 12;串的长度mov ax, 0x1301;ah al两个8位寄存器被合并赋值，此时这样赋值时ah -&gt; 0x13, al -&gt; 0x01:显示字符串且光标跟随移动mov bx, 0x2;bh存储的是显示的页号，此时显示的是0， bl则是说明字符属性，这里是黑底绿字int 0x10;;-------------------------------------jmp $ ;反复跳转到这一行message db &quot;Hello,World&quot;times 510 - ($ - $$) db 0 ;将剩下的字节处全部赋值为0,留下两个字节给魔数提示db 0x55, 0xaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20231011195507423.png" alt="image-20231011195507423"></p><p>​        这就是效果。</p><h1 id="完善MBR"><a href="#完善MBR" class="headerlink" title="完善MBR"></a>完善MBR</h1><h2 id="啥是地址"><a href="#啥是地址" class="headerlink" title="啥是地址"></a>啥是地址</h2><p>​        地址只是数字，描述各种符号在地址中的位置。是源代码文件中符号偏移文件开头的距离。编译器所作的工作就是将符号转化为机器语言，给符号排位置。现在，我们来把符号当成有血有肉的物体，有的大有点小。你看</p><p><img src="image-20231013230749270.png" alt="image-20231013230749270"></p><p>​        我们这里只是简单的把符号堆砌在这里，现在我们知道，符号的描述需要一定大小（信息论，只有足够的比特数才可以描述一定量的信息）。所以：</p><p><img src="image-20231013230930405.png" alt="image-20231013230930405"></p><p>​        可以看到，想要找到某一个元素，只需要将将当前元素的首地址加上元素的大小，就可以了。</p><p>​        我们来看一段源代码：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov ax, $$mov ds, axmov ax, [var]label: mov ax, $jmp labelvar dw 0x99<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们对之进行汇编，在进行反汇编：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">00000000  B80000            mov ax,0x000000003  8ED8              mov ds,ax00000005  A10D00            mov ax,[0xd]00000008  B80800            mov ax,0x80000000B  EBFB              jmp short 0x80000000D  99                cwd0000000E  00                db 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        第一个指的是当前指令的虚拟首地址，第二个就是我们ndisasm工具分割二进制流得到的：</p><pre class="line-numbers language-none"><code class="language-none">0000000 00b8 8e00 a1d8 000d 08b8 eb00 99fb 0000 &#x2F;&#x2F; 可以看到这儿是小端序<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        可以看到，同样是mov指令，但是编译出来的机器码天差地别，这是因为寻址方式不同，机器码自然不同的基本原理。对了，你会发现一个奇怪的一行</p><pre class="line-numbers language-none"><code class="language-none">0000000D  99                cwd0000000E  00                db 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        我们这里分明指出的是存储一个数0x99，却被反编译成cwd（扩展至双字节）</p><h2 id="啥是section"><a href="#啥是section" class="headerlink" title="啥是section"></a>啥是section</h2><p>​        什么是section?答案是，将程序被划分出来的若干个块，每个块就是一个section。我们这样就可以区分代码段和数据段，从而更好的维护我们的代码。（CPU不懂的，这些信息完全面向程序员）。</p><p>​        比如说，我们下面就来改造一下我们上面的程序，逻辑会更加清晰：</p><pre class="line-numbers language-none"><code class="language-none">section codemov ax, $$mov ax, section.data.startmov ax, [var1]mov ax, [var2]label: jmp labelsection datavar1 dd 0x4var2 dd 0x99<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        反汇编一下：</p><pre class="line-numbers language-none"><code class="language-none">00000000  B80000            mov ax,0x000000003  B81000            mov ax,0x1000000006  A11000            mov ax,[0x10]00000009  A11400            mov ax,[0x14]0000000C  EBFE              jmp short 0xc0000000E  0000              add [bx+si],al00000010  0400              add al,0x000000012  0000              add [bx+si],al00000014  99                cwd00000015  0000              add [bx+si],al00000017  00                db 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你看，没啥区别。</p><h2 id="啥是vstart"><a href="#啥是vstart" class="headerlink" title="啥是vstart"></a>啥是vstart</h2><p>​        我们来看看什么是vstart，他是指的：赋予一个虚拟起首地址。当然，这里先设一个重要的认识：跟x86开启分页后虚拟地址是两码事情。</p><p>​        我们汇编上面所有的符号相对地址都是针对vstart而言的——诸如看看下面</p><pre class="line-numbers language-none"><code class="language-none">section code vstart&#x3D;0x7c00mov ax, $$mov ax, section.code.startmov ax, section.data.startmov ax, $mov ax, [var1]mov ax, [var2]jmp $section data vstart&#x3D;0x900var1 dd 0x4var2 dw 0x99 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">00000000  B8007C            mov ax,0x7c0000000003  B80000            mov ax,0x000000006  B81400            mov ax,0x1400000009  B8097C            mov ax,0x7c090000000C  A10009            mov ax,[0x900]0000000F  A10409            mov ax,[0x904]00000012  EBFE              jmp short 0x1200000014  0400              add al,0x000000016  0000              add [bx+si],al00000018  99                cwd00000019  00                db 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到，第一列的地址才是真实地址。可以看到，当我们使用$$时，解析出来的是 vstart的虚拟地址，但是实际上当我们使用section.code.start的时候，使用的是真正的地址。这样，我们实际上实现了一个重定位技术</p><p>​        地址访问策略就是根据程序给出的地址访问东西。这个地址需要提前准备好东西。这是因为，他最后的最后是需要访问实际的物理地址的。</p><p>​        .vstart和org作用是一样的，只是告诉编译器我一定会被加载器加载到内存的某个固定的位置。所以就让编译器给这个程序的起始地址为这个固定的位置。</p><p>​        因为mbr一定会被加载到0x7c00，所以指定vstart为0x7c00，接下来的所有指令地址都是以这个地址为基址，然后偏移。</p><p>​        总而言之，vstart就是告知后续数据相对于起始的偏移时的基址是多少，不会改变他的真实位置（后面才会编排）</p><h2 id="CPU实模式"><a href="#CPU实模式" class="headerlink" title="CPU实模式"></a>CPU实模式</h2><p>​        <strong>实模式是8086CPU的寻址方式，寄存器大小，指令用法等的一个抽象概括。下面为了更好的解释这个概念，我们来看看CPU到底是怎么工作的。</strong></p><p>​        CPU自己可以划分为三个基本部分——控制单元，运算单元和存储单元</p><p>​        控制单元是CPU的控制中心，他操控CPU怎么干活。它是由IR（指令寄存器），ID（指令译码器）和OC（操作控制器）组成。程序被加载到内存时，我们的指令实际上也就在那里，CPU的指针指令寄存器（IP）依次指向指令后将之送到IR上准备执行。但是对于CPU来讲那只是一串01，不知道是这么具体工作的。这个时候，就需要ID来解析之。一般的指令格式如下：</p><pre class="line-numbers language-none"><code class="language-none">前缀 + 操作码 + 寻址方式，操作数类型 + 立即数 +偏移量<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意到：前缀是辅助CPU工作的东西，比如说rep，段超越前缀等。操作码就是大家常见的mov，jmp等。数据呢，他们在存储单元。这里的存储单元指的是CPU内部的L1，L2缓存以及寄存器。待处理的数据就存放在这些存储单元。我们为什么需要在CPU设立L1，L2缓存呢？答案是缓存基本上都是由的是SRAM，性能比DRAM好，缺点是体积大，所以，我们将之设计为层级的方式。缓解CPU和内存的矛盾。</p><p>​        寄存器分为两类</p><ul><li>一类是程序员可见的寄存器，比如说通用寄存器，段寄存器等。</li><li>程序不可见寄存器指的是那些程序员不仅而已直接使用也不可以直接访问的寄存器。</li></ul><p><img src="dkzqfrmwhklqo_f83f882584c94fecbbd5aa63b8667ec5.png" alt="e84197f771294a1da0331e35dc00a0eb.png"></p><p>​        下面谈谈实模式下的寄存器，他是一个物理存储原件。可以存储数据。</p><p>​        寄存器分为两种：内部使用的寄存器：GDTR(全局描述符寄存器)，IDTR（中断描述符表寄存器），LDTR（局部描述符表寄存器），TR（任务寄存器）CR0-3（控制寄存器），IP（指令指针寄存器），flags（标志寄存器），DR0-7调试寄存器。另一种那就是可见的，这里不赘述了</p><p>​        其中全局描述符表寄存器 GDTR, 通过 Igdt 指令为其指定全局描述符表的地址及偏移量。<strong>中断描述符表寄存器 IDTR通过 1idt指令为其指定中断描述符表的地址</strong>。局部描述符表寄存器 LDTR用gdt指令为其指定局部描述符表ldt任务寄存器TR，用 ltr 指令为其指定一个任务状态段tss。flags 寄存器,系统提供了 pushf和popf指令， 分别用于将 flags 寄存器的内容压入栈， 将栈中内容弹到 flags 寄存器ldt和tss 都位于 gdt中。</p><p><img src="dkzqfrmwhklqo_05c1410c00764cc3a52fb67b662b3f01.png" alt="17122401bc9b47fc99d04f9e34501c19.png"></p><p>​        在CPU内部寄存器都是十六位的，但是如何才能表示20位地址呢？通过将16位段基址左移4位变成20位（形成段地址），后4位由段内偏移得到。超出范围就进行回卷操作（跟循环队列相似）。<strong>段寄存器：</strong></p><p>​        段寄存器的作用就是指定一片内存的起始地址，故也称为段基址寄存器，尽管段基址在实模式下要乘以 16 ，在保护模式下只是个选择子(保护模式中会讲)，但其作用就是指定一片内存的起始地址，而段内偏移地址，顾名思义，就是仅仅相对于此起始地址的偏移量，</p><p>​        由于要指定的是内存中的一段区域的起始地址，所以称之为段基址寄存器，也称段寄存器，无论是在实模式下，还是保护模式下，它们都是 16 位宽。（这是为了更好地兼容嘛？）</p><p><img src="23909ce3752943488f080d91dfac2d06.png" alt="img"></p><p><strong>代码段：</strong>简而言之就是把所有指令都连续排放在一起，形成了一个全部都是指令的区域，里面存储的是指令的操作码及寻址方式等。该区域可以在硬盘上的文件中，也可以是被加载后的内存中，总之是一段指令区域。它们内部都是紧凑挨着的，内容形式完全一样，只是存放的介质不一样而己。代码段寄存器 CS 就是用来指向内存中这段指令区域的起始地址。</p><p><strong>数据段：</strong>和代码段类似，只是这段区域中的内容不是指令，而是纯粹的数据，也就是说里面存储的是程序运行所需要的数据，属于指令的操作数。数据段寄存器 DS 便是用来指向此数据区域的起始地址。</p><p><strong>栈段：</strong>其概念只在内存中，硬盘文件中可真没有。一般的栈段是由操作系统分配指定的，所以是属于被加载到内存后才有的。栈段寄存器 SS 就是用来指向此区域的起始地址。</p><p>另外三个附加段寄存器是为了方便大家，在 16 位 CPU 中，只有一个附加段寄存器——ES。而 FS，GS 附加段寄存器是在 32 位 CPU 中增加的。我们使用的是 32 位 CPU，并不是说 32 位 CPU 在实模式下的 16 位环境中就不能用 FS，GS 寄存器，32 位的 CPU 兼容 16 位 CPU 的特性。（兼容就是除了有自己额外新增的特性，还包括所有前辈的特性，只强不弱）</p><p>IP 寄存器是不可见寄存器，CS 寄存器是可见寄存器。（也就是说，程序员可以操作 CS 寄存器，而不能操作 IP 寄存器，因此程序员无法直接改变程序计数器 PC 来直接改变 CPU 的执行地址，只能通过像 jmp 这样的指令来跳转。）</p><blockquote><p>复习🍊：</p><p>x86体系的CPU中：程序计数器 PC 并不是单一的某种寄存器，它是一种寄存器组合，指的段寄存器 cs 和指令寄存器 ip；有专门改变执行流的指令，如 jmp、call、int、ret ，这些指令可以同时修 cs 和 ip，它们在硬件级别上实现了原子操作。</p><p>ARM体系的CPU中：程序计数器有个专门的寄存器，名字就叫 PC，想要改变程序流程，直接对该寄存器赋值便可，可以用 mov 指令来修改程序流。（这个 PC 不知道是怎么实现的）</p></blockquote><p>​        指令在内存中，访问内存就要用 “段：段内偏移” 的形式，所以 CS 寄存器用来存代码段段基址，IP 寄存器用来存储代码段段内偏移地址，同 CS 寄存器一样都是 16 位宽。并不是这两个寄存器真的决定了 CPU 的航向，只是 CPU 的航向被存入了这两个寄存器之中。（在 x86 体系架构中，是内存就应该用 “段基址：段内偏移地址” 的机制来访问，是地址就该有地方存放）</p><p>​        在执行当前指令的同时，在不跨段的情况下，CPU 以“ 当前 IP 寄存器中的值＋当前执行指令的机器码长度” 的和作为新的代码段内偏移地址，将其存入 IP 寄存器，再到该新地址处读取指令井执行。 如果下一条指令需要跨段访问，还要加载新的段基址到 CS 寄存器。</p><p><img src="35722d7409ff4cb7bc4468f95d9268a3.png" alt="img"></p><p>flags 寄存器是计算机的窗口，展示了 CPU 内部各项设置、指标，任何一个指令的执行，其执行过程的细节，对计算机造成了哪些影响，都在 flags 寄存器中通过一些标志位反映出来。</p><p><strong>通用寄存器：</strong></p><p>无论是实模式，还是保护模式，通用寄存器都是有 8 个，分别是 AX BX CX DX SI DI BP SP。</p><p><img src="3129ef40cb34473399413884719e0ad2.png" alt="img"></p><p>拿 AX 寄存器举例，根据图 3-6 可知, AX 寄存器是由 AH 寄存器和 AL 寄存器组成的，它们都是 8 位寄存器。由于某种原因，16 位 AX 寄存器不够用了，将其扩展 (Extend) 为 32 位，在 AX 原有的基础上，增加 16 位作为高 16 位便是扩展的 AX，即 EAX。所以 EAX 归根结底也是由 AL，AH 组成的，AL，AH 值变了会直接影响 EAX。</p><p><strong>通用是说每个寄存器的功能不单一，可以有多种用途，不像段寄存器 SS 那样只能用来放栈段基址，通用寄存器可以用来保存任何数据。</strong>虽说通用，但还是约定了它们的惯用法，除了通用的用途外每个寄存器肩负特定的功用。</p><p>​        cx 寄存器用作循环的次数控制，bx 寄存器用于存储起始地址。这样，在为一些通用的函数传递参数时会方便很多；另外，一些指令已经固定用一些特定的寄存器作为参数了。</p><p>各通用寄存器特定的功能描述如下：</p><p><img src="5a267b0971ab4880ae0e170cdec26978.png" alt="img"></p><p>CPU 中本来是没有实模式这一称呼的，是因为有了保护模式后，为了与老的模式区别开来，所以称老的模式为实模式。实模式的 “实” 体现在：程序中用到的地址都是真实的物理地址，＂段基址：段内偏移 “ 产生的逻辑地址就是物理地址，也就是程序员看到的完全是真实的内存。8086 之前的 CPU 对内存的访问比 8086 还要“实诚”，它们没有段的概念，程序中要访问内存，需要把地址写死，也就是所谓的 “硬编码”。由于 “硬编码” 的各种缺点，Intel 早期的工程师发明了“段”，即 CPU 访问内存用 “段＋偏移” 的形式。它就是首次在 8086 上出现的，自那之后的 CPU 都是用这类思想访问内存，只是在形式上有小改动。为了支持段机制，CPU 中新增了段寄存器，如 cs 、ds、es 等。</p><blockquote><p>查了一下为什么叫 8086🍊</p><p>这个起源可以从8085说起，这个名字的字面意思是：80年代生产的8位5伏电压处理器。后来，对这个进行升级，就简单的在个位上加1，变成了8086，也就出现了那个非常著名的x86鼻祖，于是就延用下来了。其实，后来的32位和64位系统，全名叫做x86-32 和 x86-64。但是，为了方便区分，就变成了x86和x64。</p><p>总结一下：8085是8位，8086是16位，x86-32是32位，x86-64是64位。其中，x86就是x86-32的简称，x64就是x86-64的简称。</p></blockquote><p>​        8086 的地址总线是 20 位宽，也就是其寻址范围是 2^20 次方＝ IMB 。但其内部寄存器都是 16 位的，若用单一寄存器来寻址的话，只能访问到 2^16 次方等于 64KB 的空间。（地址线位宽和寄存器位宽是没有必然联系）</p><p>​        为了让 16 位的寄存器寻址能够访问 20 位的地址空间 (注意，这里说的是通过寄存器寻址，因为只有通过 16 位的寄存器去寻址才会受到 16 位的限制，立即数寻址不会受到限制)，通过先把 16 位的段基址左移 4 位后变成 20 位，再加段内偏移地址，这样便形成了 20 位地址。</p><p>​        段基址为 0xFFFF0，偏移地址应该小于等于 F 就对啦，而这个偏移地址却是 0xFFFF，超出了 0xFFF0 的空间，也就是多出来 64K-16 字节，这部分内存就是传说中的高端内存区( High Memory Area, HMA )。这部分内存是不存在的，也不用处理，8086 只能接收 20 位长的地址（A0~A19 地址线），所以由于超过了 20 位而产生的进位，就会给丢掉，其作用相当于把地址对 IMB 取模了。这是地址回卷的效果，即超过最大范围后，从 0 重新开始计数。</p><h3 id="实模式下-CPU-内存寻址方式"><a href="#实模式下-CPU-内存寻址方式" class="headerlink" title="实模式下 CPU 内存寻址方式"></a>实模式下 CPU 内存寻址方式</h3><p>​        为了 CPU 设计更容易，CPU 访问数据的形式也需要提前“约定”好，这就是所谓的寻址方式。8086 的寻址方式，从大方向来看可以分为三大类：寄存器寻址、立即数寻址、内存寻址。在内存寻址中又分为：直接寻址、基址寻址、变址寻址、基址变址寻址。</p><p>​        从名字上看，寻址就是寻找地址，寻找谁的地址？CPU 眼里只有二进制数，所以这是 CPU 在寻找“数” 的地址。这个“数”可以源操作数，也可以是目的操作数 (顺便提一句，Intel 汇编语言语法是“指令目的操作数，源操作数”。简而言之，寻址就是找到“数”的所在地，从哪来，往哪去。</p><p><strong>寄存器寻址：</strong>最直接的寻址方式就是寄存器寻址，它是指“数”在寄存器中，直接从寄存器中拿数据就行了。只要牵扯到寄存器的操作，无论其是源操作数，还是目的操作数，都是寄存器寻址。若指令中有源操作数是立即数，也属于立即数寻址。</p><p><strong>立即数寻址：</strong>立即数就是常数。操作数 “直接” 存在指令中，直接拿过来，立即就能用了，为了突显“立即就能用”的高效率，此数便称为立即数，CPU 免去了找数的过程。</p><p><strong>内存寻址：</strong>操作数在内存中的寻址方式称为内存寻址。由于访问内存是用 “段基址：偏内偏移地址” 的形式，特别强调一下，此形式只用在内存访问中。默认情况下数据段寄存器是 DS，即段基址已经有了，只要再给出段内偏移地址就可以访问内存了，最终起决定作用的、有效的是段内偏移地址，所以段内偏移地址称为有效地址。</p><p><strong>直接寻址</strong>：直接寻址，就是将直接在操作数中给出的数字作为内存地址，通过中括号的形式告诉 CPU，取此地址中的值作为操作数。这里给出的数字是段内偏移地址，默认的段地址是 DS，若使用了段跨越前缀，那么段基址就在该前缀的段寄存器中。（书中有例子，更容易理解）</p><blockquote><p>注⚠️：立即数寻址中的数字是直接拿来就用作操作数了，直接寻址中的数字是用来进一步寻址的。</p></blockquote><p><strong>基址寻址</strong>：就是在操作数中用 bx 寄存器或 bp 寄存器作为地址的起始，地址的变化以它为基础。在实模式下，限制了只能用 bx，bp 作为基址寄存器，bx 寄存器的默认段寄存器是 DS，而 bp 寄存器的默认段寄存器是 SS。（bp、sp 都是栈的有效地址，有效地址就是指偏移地址）。</p><blockquote><p>实模式下，CPU 字长是 16（字长反映 CPU 一次运算的数字位数，而实模式下都是 16 位的数字），而栈的操作是以字长为单位的，因此实模式下的 push 指令默认情况下是压入 2 字节的数据，pop 指令默认是弹出 2 字节的数据。</p><p>其工作原理都可分为两步：(栈是向低地址方向发展的)</p><p>假如执行 push ax：</p><p>1 sub sp, 2          先将 sp 中的值减去2</p><p>2 mov [sp], ax       再将 ax 中的值 mov 到新的 ss:sp 指向的内存</p><p>假如执行 pop ax：</p><p>1 mov ax, [sp]       先将 ss:sp 指向的值 mov 到 ax</p><p>2 add sp, 2         再将 sp 的指针 +2</p></blockquote><p>​        访问栈有两种方式，一种是把栈当成“栈”来使用，也就是用 push，pop 指令操作栈，但这样我们只能访问到栈顶，即 sp 指向的地址，没有办法直接访问到栈底和栈顶之间的数据。</p><p>​        很多时候，我们需要读写栈中的数据，即需要把栈当成普通数据段那样访问。处理器为了让开发人员方便控制栈中数据，提供了这种把栈当成数据段来访问的方式，可以用寄存器 bp 来给出栈中偏 移量，所以 bp 默认的段寄存器就是 SS，这样就可通过 SS: bp 的方式把栈当成普通的数据段来访问了。</p><p><strong>变址寻址</strong>：变址寻址其实和基址寻址类似，只是寄存器由 bx，bp 换成了 si，di。si 是指源索引寄存器 (source index)，di 是指目的索引寄存器 (destination index)，两个寄存器的默认段寄存器也是 ds。变址寻址主要是用于字符搬运方面的指令，这两个寄存器在很多指令中都要成对使用。（配合基址寻址，用来实现基址变址寻址）</p><p><strong>基址变址寻址</strong>：从名字上看，这是基址寻址和变址寻址的结合，即基址寄存器 bx 或 bp 加一个变址寄存器 si 或 di。</p><blockquote><p>一种寻址方式对应一种电路实现，增加一种寻址方式，会增加硬件电路的复杂性，所以寻址方式是有限的。</p><p>🍊上层形式万千的变化，归根结底就是这么几类硬件电路，而它是有限的。</p></blockquote><h3 id="硬件是如何实现栈的？"><a href="#硬件是如何实现栈的？" class="headerlink" title="硬件是如何实现栈的？"></a>硬件是如何实现栈的？</h3><p>​        栈在我们计算机系统的工作十分重要。这里，我们假定数据结构大家已经学过，我们来看看硬件层面上栈是如何做到的。</p><p>​        栈使用一片内存空间 + SP指针维护的。我们的访问方法就是“段基址SS的值*16 + 栈指针SP（段内偏移地址）”访问，由于是硬件实现的栈，硬件提供了push和pop，SP就是栈的出口和入口，元素的进入和出去都是使用SP指针维护的。push指令就是SP-字长，目的是为了防止栈顶的元素被覆盖，所得到的差存入SP，这样我们就看到栈就向下移动一个元素大小位置。这样就可以去写入数据了，pop则是直接上移栈指针。（为什么是入栈下移出栈上移，答案是栈是向下生长的）</p><h3 id="实模式下的ret和call"><a href="#实模式下的ret和call" class="headerlink" title="实模式下的ret和call"></a>实模式下的ret和call</h3><p>​        复习一下，CS：IP寄存器存储的是地址，其中CS存段基址，IP存偏移量。但是，我们一般不能直接去改变这两个寄存器的值，而是通过CPU提供的跳转指令来完成这些工作。我们下面将会提到ret和call两个指令。</p><p>​        call值得是跳转执行新代码，跳转后他会留下一个返回地址，这个返回地址就是给ret指令准备的。注意，retf和callf对应，ret和call对应，原因是他们弹出和压入的地址字节长度不一样，f表达的就是far，代表跳转的地址字节长度是4个字节。反之则是2个字节。</p><p>​        这点跟jmp不一样，jmp指的是直接跳转去新代码而不会回头。</p><p>​        call调用有四种方式</p><ul><li>16位（2字节）实模式相对近调用</li></ul><p>​        强调两点，一是近，二是相对。为什么是近？因为两个字节，near，总是取出两个字节用来call和ret。注意，最后转化出来的操作数并不是实际物理地址，而是目标和现在所处的差：</p><pre class="line-numbers language-none"><code class="language-none">call near proc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        举个例子，proc被解析出来是0x1234，则实际上的操作数是0x1234 - call所处的地址 - call自身长度3.</p><pre class="line-numbers language-none"><code class="language-none">call near procjmp $addr dd 4near:mov ax, 0x1234ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们使用xdd指令来看看解析的结果</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Usage:       xxd [options] [infile [outfile]]    or       xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]Options:    -a          toggle autoskip: A single '*' replaces nul-lines. Default off.    -b          binary digit dump (incompatible with -ps,-i,-r). Default hex.    -C          capitalize variable names in C include file style (-i).    -c cols     format &lt;cols> octets per line. Default 16 (-i: 12, -ps: 30).    -E          show characters in EBCDIC. Default ASCII.    -e          little-endian dump (incompatible with -ps,-i,-r).    -g bytes    number of octets per group in normal output. Default 2 (-e: 4).    -h          print this summary.    -i          output in C include file style.    -l len      stop after &lt;len> octets.    -o off      add &lt;off> to the displayed file position.    -ps         output in postscript plain hexdump style.    -r          reverse operation: convert (or patch) hexdump into binary.    -r -s off   revert with &lt;off> added to file positions found in hexdump.    -d          show offset in decimal instead of hex.    -s [+][-]seek  start at &lt;seek> bytes abs. (or +: rel.) infile offset.    -u          use upper case hex letters.    -v          show version: "xxd 2021-10-22 by Juergen Weigert et al.".<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">e806 00eb fe04 0000 00b8 3412 c3         ..........4..<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>16位实模式间接绝对近调用</li></ul><p>​        间接指的是我们并没有直接给出地址而是通过去寄存器或者是内存中去找值。绝对则是指的是绝对地址。</p><p>​        数据类型伪指令分为byte, word, dword, qward可以认为是强制类型转换：</p><pre class="line-numbers language-none"><code class="language-none">section call_test vstart&#x3D;0x900mov word [addr], near_proccall [addr]mov ax, near_proccall axjmp $addr dd 4near_proc:mov ax, 0x1234ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>16位实模式直接绝对远调用</li></ul><p>​        直接指的是操作数直接给出，也就是立即数，远就意味着要跨段了</p><p>​        指令就是call far指令</p><pre class="line-numbers language-none"><code class="language-none">call far 段基址（立即数）：段内偏移地址（立即数）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">section call_test vstart &#x3D; 0x900call 0:far_procjmp $far_proc:mov ax, 0x1234    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>形式： call far 段基址（立即数）：段偏移（立即数）</p><p><img src="v2-0217fa387df2ce047bf7e359d66a3630_1440w.webp" alt="img"></p><p><img src="v2-738cdadc21743334c3a49113f5e3a00b_1440w.webp" alt="img"></p><p>这个图片中是程序执行顺序</p><ol><li>16位实模式间接绝对远调用</li></ol><p>和3的区别：段基址和段偏移地址存放在内存中</p><p>形式： call far [bx] || call far [0x1234] (ds为段基址)</p><p>call是去内存中找要跳转的位置，内存前（低）两个字节谁段偏移地址，后（高)两个字节是段基址。比如call far [0x1234] ，由于没有段跨越前缀，则默认的段基址*16后再与0x1234相加，得到的和为物理地址，以该物理地址为起始地址的前2字节是段偏移地址，以（该物理地址+2）为起始的地址为段基址。（因为cs和ip都是新的，所以就的cs和ip都要压入栈中）</p><p><img src="v2-f4fff590adabea904551b482e77b182a_1440w.webp" alt="img"></p><p>addr dw far_proc,0 addr是变量名称，dw是数据类型，far_proc，0两个都是dw类型，addr其实是一个数组，里面存放了两个dw类型的变量，前面的far_proc 是段偏移地址，0是段基址。call的化去addr里面访问，那么访问到的就是这两个数据。</p><p><img src="v2-da224c50c29255e4c0139e86eb54bc42_1440w.webp" alt="img"></p><h3 id="实模式下的jmp"><a href="#实模式下的jmp" class="headerlink" title="实模式下的jmp"></a>实模式下的jmp</h3><ul><li>16位实模式相对短转移</li></ul><p>短：因为使用short修饰，转移的操作数只有1个字节，所以叫短转移</p><p>相对：地址是相对位置，和上面的call 相对短转移是一样的。就拿上面那张图看，不是有jmp -2 么，这个就是相对的地址。（同时表明操作数是有符号的，所以才有-2）</p><p>jmp只有两个字节，操作码一个字节，操作数一个字节。操作数代表的位置转移可以是-127——128</p><p>​        注意，CPU是不认这个地址差的，CPU只认绝对的地址。所以这个jmp 0x1234这个0x1234被编译器编译成了地址差，还要被转换到绝对地址，才能传送到CPU中。</p><p><img src="v2-add39159ac2bebc24c9a26d868a1530c_1440w.webp" alt="img"></p><p>这里第3行定义了127个字节的数据。这个就是jmp短转移的操作数。因为第4行地址-第2行地址-2，就是127字节</p><p><img src="v2-7545687eedb45c03fb9f23b4884443b5_1440w.webp" alt="img"></p><p>​        第一行，在地址0x900处的指令是jmp +127操作数是127，其转移的真实地址是0x981，前面说过，操作数是不能给CPU直接用的，CPU要将其转换成绝对地址，所以此地址是这样得到的：0x900+2+127=0x981</p><p>因为jmp短转移的操作数范围是-127——-128，如果操作数不在这个范围内，那么会在编译阶段报错。</p><p>解决的方法就是将操作数的范围增大，突破1字节的有符号数表示范围就行了。</p><p>1）将第2行jmp后面的short去掉，改成near</p><p>2）第2行jmp后面什么都不写，让nasm编译器自己判断</p><ul><li>16位实模式相对近转移</li></ul><p>近转移：用near修饰，操作数有两个字节，所以转移的长度可以增加。</p><p>操作码占一个字节，是0xe9，操作数占两个字节，所以这个指令占3字节。</p><ul><li>16位实模式间接绝对近转移</li></ul><p>间接：使用寄存器或者内存，里面存放的是要转移的地址</p><p>绝对：给出绝对地址</p><p>近转移：near</p><p>形式：jmp near ax, jmp near [addr]</p><p><img src="v2-0c5cb6a58eac9006f6711880e260c375_1440w.webp" alt="img"></p><p><img src="v2-0ee4c0503f14724451704fab1c7371c3_1440w.webp" alt="img"></p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">section call_test vstart&#x3D;0x900mov word [addr], startjmp near [addr]times 128 db 0addr dw 0start:mov ax, 0x1234jmp $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="v2-0d833f7cfc029d8d00ad32f1822cc4fa_1440w.webp" alt="img"></p><ul><li>16位实模式直接绝对远转移</li></ul><p>直接：给出物理地址，即段基址和偏移地址，CPU可以直接用</p><p>绝对：提供绝对地址</p><p>远：跨段需求</p><p>形式：jmp 立即数形式的段基址：立即数形式的偏移地址，例如：jmp 0：0x1234</p><ul><li>16位实模式间接绝对远转移</li></ul><p>因为操作数有两个：段基址，段偏移，所以肯定是不能放寄存器里面了，所以要放在内存中。</p><p>形式：jmp far 内存地址</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">section call_test vstart&#x3D;0x900jmp far [addr]times 128 db 0addr dw start, 0start:mov ax, 0x1234jmp $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="v2-b903e637fc1b0ed35f5bf0218e633c58_1440w.webp" alt="img"></p><hr><h3 id="有条件转移"><a href="#有条件转移" class="headerlink" title="有条件转移"></a><strong>有条件转移</strong></h3><p>flags寄存器是16位宽，保护模式下扩展成32位的eflags寄存器。</p><p>0 cf：符号位，进位，借位为1，可以判断无符号加减的溢出，有符号不能判断。</p><p>2 pf：奇偶位，低8位1个数为偶，pf=1，否则为0</p><p>1,3,5,15没有专门标志位</p><p>有条件转移是一个指令簇，格式为jxx，条件满足跳转。但是jxx 目标地址只能是段内偏移地址。实模式下，编译器自动分辨是短转移还是近转移。保护模式下，32位偏移地址可以访问4GB内存，不分转移方式。</p><p><strong>所谓条件转移，条件就是判断上一条指令的结果是否满足某方面或某些方面，能够影响标志位的指令才能条件指令作为条件。</strong></p><h4 id="Eflag寄存器标志位"><a href="#Eflag寄存器标志位" class="headerlink" title="Eflag寄存器标志位"></a>Eflag寄存器标志位</h4><p><img src="webp.webp" alt="img"></p><p>Eflag标志位.png</p><ul><li><code>CF Carray Flag</code>:,CF为1，表示进位或借位</li><li><code>PF Parity Flag</code>：奇偶位，用来标记低八位中1的个数</li><li><code>AF Auxiliary carry Flag</code>：辅助进位标志，用来记录运算结果低四位的进借位情况。</li><li><code>ZF Zero Flag</code>：零标志位。若计算结果位0，此标志为1</li><li><code>SF Sign Flag</code>：符号标志位。运算结果为负，则SF位为1</li><li><code>TF Trap Flag</code>：陷阱标志位。TF为1，CPU进入单步运行模式。debug单步调试时，原理是让TF置一</li><li><code>IF Interrupt Flag</code>：中断标志位。IF为1，表示中断开启，CPU可以响应外部可屏蔽中断。</li><li><code>DF Direction Flag</code>：方向标志位。用于字符串操作指令中，当DF为1时，指令中的操作数地址会自动减少一个单位，当DF为0时，指令中的操作数地址会自动增加一个单位。其中提到的这个单位的大小，取决于用什么指令。</li><li><code>OF Overflow Flag</code>：溢出标志位。表示计算结果是否超过了数据类型可表示的大小。</li><li><code>IOPL Input Output Privilege Level</code>：用于特权级概念的CPU。占用两位表示4中特权级</li><li><code>NT Nest Task</code>：任务嵌套标志。8088支持多任务，一个任务就是一个进程。一个任务中又嵌套调用了另一个任务时，此NT为1</li><li><code>RF Resume Flag</code>：恢复标志位。该标志位用于程序调试，指示是否接受调试故障，它需要和调试寄存器一起使用</li><li><code>VM Virtual 8086 Model</code>：虚拟8086模式，这是实模式向保护模式过渡时的产物。此位为1，可以在保护模式下运行实模式的程序。在保护模式下运行实模式程序，都要为其虚拟一个实模式环境，故称为虚拟模式。</li><li><code>AC Alignment Check</code>：对齐检查。程序中的数据或指令其内存地址是否是偶数，是否是16，32的整数倍，没有余数。</li><li><code>VIF Virtual Interrupt Flag</code>：虚拟中断标志位，虚拟模式下的中断标志。</li><li><code>VIP Virtual Interrupt Pending</code>：虚拟中断挂起标志位。在多任务的情况下，为操作系统提供虚拟中断挂起信息。</li><li><code>ID Identification</code>：识别标志位。系统经常需要判断CPU型号，若ID为1，表示支持CPU id 指令</li></ul><h2 id="直接干显卡去"><a href="#直接干显卡去" class="headerlink" title="直接干显卡去"></a>直接干显卡去</h2><h3 id="CPU通过IO接口跟外界通信"><a href="#CPU通过IO接口跟外界通信" class="headerlink" title="CPU通过IO接口跟外界通信"></a>CPU通过IO接口跟外界通信</h3><p>​        在现在，硬件设备大爆发的今天，让CPU很难直接和外界设备进行通信。所以，加层，一个抽象层。一个IO接口设备。他来协调外界设备和CPU之间的通信。方法是：</p><ol><li>设定数据缓存，解决CPU于与外设之间的速度不匹配问题</li></ol><p>​        CPU和外设速度上的差异可以使用缓冲区来解决。</p><ol><li>设置信号电平转换电路</li></ol><p>​        CPU和外设信号的差异可以使用转换电路完成</p><ol><li>设置数据格式转换</li></ol><p>​        可以使用数模转换器转化到外设上进行驱动等等</p><ol><li>设置时序控制电路来同步CPU和外部设备</li></ol><p>​        硬件的工作也按照某一个时序，他们像计算机一样也有自己的晶振时序一样。我们的CPU和设备需要协调信号来进行通信！</p><ol><li>提供地址编码</li></ol><p>CPU同多个硬件打交道，每个硬件反馈的信息很多，所以一个IO接口需要包含多个端口。</p><p>​        CPU通过总线来跟IO接口交互。我们的数据就在这总线上高速飞驰。当多个IO设备想要和CPU进行通信的时候，会有一个芯片负责与之仲裁：那就是南桥芯片（输入输出控制中心 Input / Output Control Hub -&gt; ICH）用于处理低俗设备和CPU的通信。北桥芯片则是处理高速IO设备，一些板子已经集成在了CPU当中。</p><p>​        微观上，我们就是通过寄存器的方式，让外部设备同CPU进行通信，端口，也就是告知如何访问外设的寄存器，也就要以操纵寄存器的方式进行。有两个专门的指令in out来处理：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">in al, dx ;al,ax存储端口数据，dx则是存储端口号in ax, dx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        固定用法！只要使用in指令，就必须用dx代表源操作数，也就是端口，而使用al还是ax则是决定了我们的寄存器的宽度是8位的还是16位的。</p><p>​        相反的,我们还有out指令：</p><pre class="line-numbers language-none"><code class="language-none">out dx, alout dx, axout Imm, al,out Imm, ax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到位置反过来了，并且，我们可以使用立即操作数来表示端口，而不必须使用dx，这与in不同！</p><h3 id="显存，显卡，显式器"><a href="#显存，显卡，显式器" class="headerlink" title="显存，显卡，显式器"></a>显存，显卡，显式器</h3><p>​        显存是显卡内存的意思，显卡有两种常见的工作模式——图像模式和字符模式。显卡是通过我们一个约定的协议来得知我们需求。也就是说：我们使用一个编码来告诉显卡应该显示什么。举个例子，把0x41写进显卡内存，他知道他要打印A了。为了统一，我们就是用ASCII编码，来统一编码的格式：</p><div class="table-container"><table><thead><tr><th><strong>十进制代码</strong></th><th><strong>十六进制代码</strong></th><th><strong>MCS 字符或缩写</strong></th><th><strong>DEC 多国字符名</strong></th></tr></thead><tbody><tr><td><strong>ASCII 控制字符 1</strong></td><td></td><td></td><td></td></tr><tr><td>0</td><td>0</td><td>NUL</td><td>空字符</td></tr><tr><td>1</td><td>1</td><td>SOH</td><td>标题起始 (Ctrl/A)</td></tr><tr><td>2</td><td>2</td><td>STX</td><td>文本起始 (Ctrl/B)</td></tr><tr><td>3</td><td>3</td><td>ETX</td><td>文本结束 (Ctrl/C)</td></tr><tr><td>4</td><td>4</td><td>EOT</td><td>传输结束 (Ctrl/D)</td></tr><tr><td>5</td><td>5</td><td>ENQ</td><td>询问 (Ctrl/E)</td></tr><tr><td>6</td><td>6</td><td>ACK</td><td>认可 (Ctrl/F)</td></tr><tr><td>7</td><td>7</td><td>BEL</td><td>铃 (Ctrl/G)</td></tr><tr><td>8</td><td>8</td><td>BS</td><td>退格 (Ctrl/H)</td></tr><tr><td>9</td><td>9</td><td>HT</td><td>水平制表栏 (Ctrl/I)</td></tr><tr><td>10</td><td>0A</td><td>LF</td><td>换行 (Ctrl/J)</td></tr><tr><td>11</td><td>0B</td><td>VT</td><td>垂直制表栏 (Ctrl/K)</td></tr><tr><td>12</td><td>0C</td><td>FF</td><td>换页 (Ctrl/L)</td></tr><tr><td>13</td><td>0D</td><td>CR</td><td>回车 (Ctrl/M)</td></tr><tr><td>14</td><td>0E</td><td>SO</td><td>移出 (Ctrl/N)</td></tr><tr><td>15</td><td>0F</td><td>SI</td><td>移入 (Ctrl/O)</td></tr><tr><td>16</td><td>10</td><td>DLE</td><td>数据链接丢失 (Ctrl/P)</td></tr><tr><td>17</td><td>11</td><td>DC1</td><td>设备控制 1 (Ctrl/Q)</td></tr><tr><td>18</td><td>12</td><td>DC2</td><td>设备控制 2 (Ctrl/R)</td></tr><tr><td>19</td><td>13</td><td>DC3</td><td>设备控制 3 (Ctrl/S)</td></tr><tr><td>20</td><td>14</td><td>DC4</td><td>设备控制 4 (Ctrl/T)</td></tr><tr><td>21</td><td>15</td><td>NAK</td><td>否定接受 (Ctrl/U)</td></tr><tr><td>22</td><td>16</td><td>SYN</td><td>同步闲置符 (Ctrl/V)</td></tr><tr><td>23</td><td>17</td><td>ETB</td><td>传输块结束 (Ctrl/W)</td></tr><tr><td>24</td><td>18</td><td>CAN</td><td>取消 (Ctrl/X)</td></tr><tr><td>25</td><td>19</td><td>EM</td><td>媒体结束 (Ctrl/Y)</td></tr><tr><td>26</td><td>1A</td><td>SUB</td><td>替换 (Ctrl/Z)</td></tr><tr><td>27</td><td>1B</td><td>ESC</td><td>换码符</td></tr><tr><td>28</td><td>1C</td><td>FS</td><td>文件分隔符</td></tr><tr><td>29</td><td>1D</td><td>GS</td><td>组分隔符</td></tr><tr><td>30</td><td>1E</td><td>RS</td><td>记录分隔符</td></tr><tr><td>31</td><td>1F</td><td>US</td><td>单位分隔符</td></tr><tr><td><strong>ASCII 特殊和数字字符</strong></td><td></td><td></td><td></td></tr><tr><td>32</td><td>20</td><td>SP</td><td>空格</td></tr><tr><td>33</td><td>21</td><td>!</td><td>感叹号</td></tr><tr><td>34</td><td>22</td><td>“</td><td>引号 (双引号)</td></tr><tr><td>35</td><td>23</td><td>#</td><td>数字符号</td></tr><tr><td>36</td><td>24</td><td>$</td><td>美元符</td></tr><tr><td>37</td><td>25</td><td>%</td><td>百分号</td></tr><tr><td>38</td><td>26</td><td>&amp;</td><td>和号</td></tr><tr><td>39</td><td>27</td><td>‘</td><td>省略号 (单引号)</td></tr><tr><td>40</td><td>28</td><td>(</td><td>左圆括号</td></tr><tr><td>41</td><td>29</td><td>)</td><td>右圆括号</td></tr><tr><td>42</td><td>2A</td><td>*</td><td>星号</td></tr><tr><td>43</td><td>2B</td><td>+</td><td>加号</td></tr><tr><td>44</td><td>2C</td><td>,</td><td>逗号</td></tr><tr><td>45</td><td>2D</td><td>—</td><td>连字号或减号</td></tr><tr><td>46</td><td>2E</td><td>.</td><td>句点或小数点</td></tr><tr><td>47</td><td>2F</td><td>/</td><td>斜杠</td></tr><tr><td>48</td><td>30</td><td>0</td><td>零</td></tr><tr><td>49</td><td>31</td><td>1</td><td>1</td></tr><tr><td>50</td><td>32</td><td>2</td><td>2</td></tr><tr><td>51</td><td>33</td><td>3</td><td>3</td></tr><tr><td>52</td><td>34</td><td>4</td><td>4</td></tr><tr><td>53</td><td>35</td><td>5</td><td>5</td></tr><tr><td>54</td><td>36</td><td>6</td><td>6</td></tr><tr><td>55</td><td>37</td><td>7</td><td>7</td></tr><tr><td>56</td><td>38</td><td>8</td><td>8</td></tr><tr><td>57</td><td>39</td><td>9</td><td>9</td></tr><tr><td>58</td><td>3A</td><td>:</td><td>冒号</td></tr><tr><td>59</td><td>3B</td><td>;</td><td>分号</td></tr><tr><td>60</td><td>3C</td><td>&lt;</td><td>小于</td></tr><tr><td>61</td><td>3D</td><td>=</td><td>等于</td></tr><tr><td>62</td><td>3E</td><td>&gt;</td><td>大于</td></tr><tr><td>63</td><td>3F</td><td>?</td><td>问号</td></tr><tr><td><strong>ASCII 字母字符</strong></td><td></td><td></td><td></td></tr><tr><td>64</td><td>40</td><td>@</td><td>商业 at 符号</td></tr><tr><td>65</td><td>41</td><td>A</td><td>大写字母 A</td></tr><tr><td>66</td><td>42</td><td>B</td><td>大写字母 B</td></tr><tr><td>67</td><td>43</td><td>C</td><td>大写字母 C</td></tr><tr><td>68</td><td>44</td><td>D</td><td>大写字母 D</td></tr><tr><td>69</td><td>45</td><td>E</td><td>大写字母 E</td></tr><tr><td>70</td><td>46</td><td>F</td><td>大写字母 F</td></tr><tr><td>71</td><td>47</td><td>G</td><td>大写字母 G</td></tr><tr><td>72</td><td>48</td><td>H</td><td>大写字母 H</td></tr><tr><td>73</td><td>49</td><td>I</td><td>大写字母 I</td></tr><tr><td>74</td><td>4A</td><td>J</td><td>大写字母 J</td></tr><tr><td>75</td><td>4B</td><td>K</td><td>大写字母 K</td></tr><tr><td>76</td><td>4C</td><td>L</td><td>大写字母 L</td></tr><tr><td>77</td><td>4D</td><td>M</td><td>大写字母 M</td></tr><tr><td>78</td><td>4E</td><td>N</td><td>大写字母 N</td></tr><tr><td>79</td><td>4F</td><td>O</td><td>大写字母 O</td></tr><tr><td>80</td><td>50</td><td>P</td><td>大写字母 P</td></tr><tr><td>81</td><td>51</td><td>Q</td><td>大写字母 Q</td></tr><tr><td>82</td><td>52</td><td>R</td><td>大写字母 R</td></tr><tr><td>83</td><td>53</td><td>S</td><td>大写字母 S</td></tr><tr><td>84</td><td>54</td><td>T</td><td>大写字母 T</td></tr><tr><td>85</td><td>55</td><td>U</td><td>大写字母 U</td></tr><tr><td>86</td><td>56</td><td>V</td><td>大写字母 V</td></tr><tr><td>87</td><td>57</td><td>W</td><td>大写字母 W</td></tr><tr><td>88</td><td>58</td><td>X</td><td>大写字母 X</td></tr><tr><td>89</td><td>59</td><td>Y</td><td>大写字母 Y</td></tr><tr><td>90</td><td>5A</td><td>Z</td><td>大写字母 Z</td></tr><tr><td>91</td><td>5B</td><td>[</td><td>左中括号</td></tr><tr><td>92</td><td>5C</td><td>\</td><td>反斜杠</td></tr><tr><td>93</td><td>5D</td><td>]</td><td>右中括号</td></tr><tr><td>94</td><td>5E</td><td>^</td><td>音调符号</td></tr><tr><td>95</td><td>5F</td><td>_</td><td>下划线</td></tr><tr><td>96</td><td>60</td><td>`</td><td>重音符</td></tr><tr><td>97</td><td>61</td><td>a</td><td>小写字母 a</td></tr><tr><td>98</td><td>62</td><td>b</td><td>小写字母 b</td></tr><tr><td>99</td><td>63</td><td>c</td><td>小写字母 c</td></tr><tr><td>100</td><td>64</td><td>d</td><td>小写字母 d</td></tr><tr><td>101</td><td>65</td><td>e</td><td>小写字母 e</td></tr><tr><td>102</td><td>66</td><td>f</td><td>小写字母 f</td></tr><tr><td>103</td><td>67</td><td>g</td><td>小写字母 g</td></tr><tr><td>104</td><td>68</td><td>h</td><td>小写字母 h</td></tr><tr><td>105</td><td>69</td><td>i</td><td>小写字母 i</td></tr><tr><td>106</td><td>6A</td><td>j</td><td>小写字母 j</td></tr><tr><td>107</td><td>6B</td><td>k</td><td>小写字母 k</td></tr><tr><td>108</td><td>6C</td><td>l</td><td>小写字母 l</td></tr><tr><td>109</td><td>6D</td><td>m</td><td>小写字母 m</td></tr><tr><td>110</td><td>6E</td><td>n</td><td>小写字母 n</td></tr><tr><td>111</td><td>6F</td><td>o</td><td>小写字母 o</td></tr><tr><td>112</td><td>70</td><td>p</td><td>小写字母 p</td></tr><tr><td>113</td><td>71</td><td>q</td><td>小写字母 q</td></tr><tr><td>114</td><td>72</td><td>r</td><td>小写字母 r</td></tr><tr><td>115</td><td>73</td><td>s</td><td>小写字母 s</td></tr><tr><td>116</td><td>74</td><td>t</td><td>小写字母 t</td></tr><tr><td>117</td><td>75</td><td>u</td><td>小写字母 u</td></tr><tr><td>118</td><td>76</td><td>v</td><td>小写字母 v</td></tr><tr><td>119</td><td>77</td><td>w</td><td>小写字母 w</td></tr><tr><td>120</td><td>78</td><td>x</td><td>小写字母 x</td></tr><tr><td>121</td><td>79</td><td>y</td><td>小写字母 y</td></tr><tr><td>122</td><td>7A</td><td>z</td><td>小写字母 z</td></tr><tr><td>123</td><td>7B</td><td>{</td><td>左大括号</td></tr><tr><td>124</td><td>7C</td><td>\</td><td></td><td>垂直线</td></tr><tr><td>125</td><td>7D</td><td>}</td><td>右大括号 (ALTMODE)</td></tr><tr><td>126</td><td>7E</td><td>~</td><td>代字号 (ALTMODE)</td></tr><tr><td>127</td><td>7F</td><td>DEL</td><td>擦掉 (DELETE)</td></tr><tr><td><strong>控制字符</strong></td><td></td><td></td><td></td></tr><tr><td>128</td><td>80</td><td></td><td>[保留]</td></tr><tr><td>129</td><td>81</td><td></td><td>[保留]</td></tr><tr><td>130</td><td>82</td><td></td><td>[保留]</td></tr><tr><td>131</td><td>83</td><td></td><td>[保留]</td></tr><tr><td>132</td><td>84</td><td>IND</td><td>索引</td></tr><tr><td>133</td><td>85</td><td>NEL</td><td>下一行</td></tr><tr><td>134</td><td>86</td><td>SSA</td><td>被选区域起始</td></tr><tr><td>135</td><td>87</td><td>ESA</td><td>被选区域结束</td></tr><tr><td>136</td><td>88</td><td>HTS</td><td>水平制表符集</td></tr><tr><td>137</td><td>89</td><td>HTJ</td><td>对齐的水平制表符集</td></tr><tr><td>138</td><td>8A</td><td>VTS</td><td>垂直制表符集</td></tr><tr><td>139</td><td>8B</td><td>PLD</td><td>部分行向下</td></tr><tr><td>140</td><td>8C</td><td>PLU</td><td>部分行向上</td></tr><tr><td>141</td><td>8D</td><td>RI</td><td>反向索引</td></tr><tr><td>142</td><td>8E</td><td>SS2</td><td>单移 2</td></tr><tr><td>143</td><td>8F</td><td>SS3</td><td>单移 3</td></tr><tr><td>144</td><td>90</td><td>DCS</td><td>设备控制字符串</td></tr><tr><td>145</td><td>91</td><td>PU1</td><td>专用 1</td></tr><tr><td>146</td><td>92</td><td>PU2</td><td>专用 2</td></tr><tr><td>147</td><td>93</td><td>STS</td><td>设置传输状态</td></tr><tr><td>148</td><td>94</td><td>CCH</td><td>取消字符</td></tr><tr><td>149</td><td>95</td><td>MW</td><td>消息等待</td></tr><tr><td>150</td><td>96</td><td>SPA</td><td>保护区起始</td></tr><tr><td>151</td><td>97</td><td>EPA</td><td>保护区结束</td></tr><tr><td>152</td><td>98</td><td></td><td>[保留]</td></tr><tr><td>153</td><td>99</td><td></td><td>[保留]</td></tr><tr><td>154</td><td>9A</td><td></td><td>[保留]</td></tr><tr><td>155</td><td>9B</td><td>CSI</td><td>控制序列引导符</td></tr><tr><td>156</td><td>9C</td><td>ST</td><td>字符串终止符</td></tr><tr><td>157</td><td>9D</td><td>OSC</td><td>操作系统命令</td></tr><tr><td>158</td><td>9E</td><td>PM</td><td>秘密消息</td></tr><tr><td>159</td><td>9F</td><td>APC</td><td>应用程序</td></tr><tr><td><strong>其他字符</strong></td><td></td><td></td><td></td></tr><tr><td>160</td><td>A0</td><td></td><td>[保留] 2</td></tr><tr><td>161</td><td>A1</td><td>¡</td><td>反向感叹号</td></tr><tr><td>162</td><td>A2</td><td>¢</td><td>分币符</td></tr><tr><td>163</td><td>A3</td><td>£</td><td>英磅符</td></tr><tr><td>164</td><td>A4</td><td></td><td>[保留] 2</td></tr><tr><td>165</td><td>A5</td><td>¥</td><td>人民币符</td></tr><tr><td>166</td><td>A6</td><td></td><td>[保留] 2</td></tr><tr><td>167</td><td>A7</td><td>§</td><td>章节符</td></tr><tr><td>168</td><td>A8</td><td>¤</td><td>通用货币符号 2</td></tr><tr><td>169</td><td>A9</td><td>©</td><td>版权符号</td></tr><tr><td>170</td><td>AA</td><td>ª</td><td>阴性顺序指示符</td></tr><tr><td>171</td><td>AB</td><td>«</td><td>左角引号</td></tr><tr><td>172</td><td>AC</td><td></td><td>[保留] 2</td></tr><tr><td>173</td><td>AD</td><td></td><td>[保留] 2</td></tr><tr><td>174</td><td>AE</td><td></td><td>[保留] 2</td></tr><tr><td>175</td><td>AF</td><td></td><td>[保留] 2</td></tr><tr><td>176</td><td>B0</td><td>°</td><td>温度符</td></tr><tr><td>177</td><td>B1</td><td>±</td><td>加/减号</td></tr><tr><td>178</td><td>B2</td><td>²</td><td>上标 2</td></tr><tr><td>179</td><td>B3</td><td>³</td><td>上标 3</td></tr><tr><td>180</td><td>B4</td><td></td><td>[保留] 2</td></tr><tr><td>181</td><td>B5</td><td>µ</td><td>微符</td></tr><tr><td>182</td><td>B6</td><td>¶</td><td>段落符，pilcrow</td></tr><tr><td>183</td><td>B7</td><td>·</td><td>中点</td></tr><tr><td>184</td><td>B8</td><td></td><td>[保留] 2</td></tr><tr><td>185</td><td>B9</td><td>¹</td><td>上标 1</td></tr><tr><td>186</td><td>BA</td><td>º</td><td>阳性顺序指示符</td></tr><tr><td>187</td><td>BB</td><td>»</td><td>右角引号</td></tr><tr><td>188</td><td>BC</td><td>¼</td><td>分数四分之一</td></tr><tr><td>189</td><td>BD</td><td>½</td><td>分数二分之一</td></tr><tr><td>190</td><td>BE</td><td></td><td>[保留] 2</td></tr><tr><td>191</td><td>BF</td><td>¿</td><td>反向问号</td></tr><tr><td>192</td><td>C0</td><td>À</td><td>带重音符的大写字母 A</td></tr><tr><td>193</td><td>C1</td><td>Á</td><td>带尖锐重音的大写字母 A</td></tr><tr><td>194</td><td>C2</td><td>Â</td><td>带音调符号的大写字母 A</td></tr><tr><td>195</td><td>C3</td><td>Ã</td><td>带代字号的大写字母 A</td></tr><tr><td>196</td><td>C4</td><td>Ä</td><td>带元音变音 (分音符号) 的大写字母 A</td></tr><tr><td>197</td><td>C5</td><td>Å</td><td>带铃声的大写字母 A</td></tr><tr><td>198</td><td>C6</td><td>Æ</td><td>大写字母 AE 双重元音</td></tr><tr><td>199</td><td>C7</td><td>Ç</td><td>带变音符号的大写字母 C</td></tr><tr><td>200</td><td>C8</td><td>È</td><td>带重音符的大写字母 E</td></tr><tr><td>201</td><td>C9</td><td>É</td><td>带尖锐重音的大写字母 E</td></tr><tr><td>202</td><td>CA</td><td>Ê</td><td>带音调符号的大写字母 E</td></tr><tr><td>203</td><td>CB</td><td>Ë</td><td>带元音变音 (分音符号) 的大写字母 E</td></tr><tr><td>204</td><td>CC</td><td>Ì</td><td>带重音符的大写字母 I</td></tr><tr><td>205</td><td>CD</td><td>Í</td><td>带尖锐重音的大写字母 I</td></tr><tr><td>206</td><td>CE</td><td>Î</td><td>带音调符号的大写字母 I</td></tr><tr><td>207</td><td>CF</td><td>Ï</td><td>带元音变音 (分音符号) 的大写字母 I</td></tr><tr><td>208</td><td>D0</td><td></td><td>[保留] 2</td></tr><tr><td>209</td><td>D1</td><td>Ñ</td><td>带代字号的大写字母 N</td></tr><tr><td>210</td><td>D2</td><td>Ò</td><td>带重音符的大写字母 O</td></tr><tr><td>211</td><td>D3</td><td>Ó</td><td>带尖锐重音的大写字母 O</td></tr><tr><td>212</td><td>D4</td><td>Ô</td><td>带音调符号的大写字母 O</td></tr><tr><td>213</td><td>D5</td><td>Õ</td><td>带代字号的大写字母 O</td></tr><tr><td>214</td><td>D6</td><td>Ö</td><td>带元音变音 (分音符号) 的大写字母 O</td></tr><tr><td>215</td><td>D7</td><td>OE</td><td>大写字母 OE 连字 2</td></tr><tr><td>216</td><td>D8</td><td>Ø</td><td>带斜杠的大写字母 O</td></tr><tr><td>217</td><td>D9</td><td>Ù</td><td>带重音符的大写字母 U</td></tr><tr><td>218</td><td>DA</td><td>Ú</td><td>带尖锐重音的大写字母 U</td></tr><tr><td>219</td><td>DB</td><td>Û</td><td>带音调符号的大写字母 U</td></tr><tr><td>220</td><td>DC</td><td>Ü</td><td>带元音变音 (分音符号) 的大写字母 U</td></tr><tr><td>221</td><td>DD</td><td>Y</td><td>带元音变音 (分音符号) 的大写字母 Y</td></tr><tr><td>222</td><td>DE</td><td></td><td>[保留] 2</td></tr><tr><td>223</td><td>DF</td><td>ß</td><td>德语高调小写字母 s</td></tr><tr><td>224</td><td>E0</td><td>à</td><td>带重音符的小写字母 a</td></tr><tr><td>225</td><td>E1</td><td>á</td><td>带尖锐重音的小写字母 a</td></tr><tr><td>226</td><td>E2</td><td>â</td><td>带音调符号的小写字母 a</td></tr><tr><td>227</td><td>E3</td><td>ã</td><td>带代字号的小写字母 a</td></tr><tr><td>228</td><td>E4</td><td>ä</td><td>带元音变音 (分音符号) 的小写字母 a</td></tr><tr><td>229</td><td>E5</td><td>å</td><td>带铃声的小写字母 a</td></tr><tr><td>230</td><td>E6</td><td>æ</td><td>小写字母 ae 双重元音</td></tr><tr><td>231</td><td>E7</td><td>ç</td><td>带变音符号的小写字母 c</td></tr><tr><td>232</td><td>E8</td><td>è</td><td>带重音符的小写字母 e</td></tr><tr><td>233</td><td>E9</td><td>é</td><td>带尖锐重音的小写字母 e</td></tr><tr><td>234</td><td>EA</td><td>ê</td><td>带音调符号的小写字母 e</td></tr><tr><td>235</td><td>EB</td><td>ë</td><td>带元音变音 (分音符号) 的小写字母 e</td></tr><tr><td>236</td><td>EC</td><td>ì</td><td>带重音符的小写字母 i</td></tr><tr><td>237</td><td>ED</td><td>í</td><td>带尖锐重音的小写字母 i</td></tr><tr><td>238</td><td>EE</td><td>î</td><td>带音调符号的小写字母 i</td></tr><tr><td>239</td><td>EF</td><td>ï</td><td>带元音变音 (分音符号) 的小写字母 i</td></tr><tr><td>240</td><td>F0</td><td></td><td>[保留] 2</td></tr><tr><td>241</td><td>F1</td><td>ñ</td><td>带代字号的小写字母 n</td></tr><tr><td>242</td><td>F2</td><td>ò</td><td>带重音符的小写字母 o</td></tr><tr><td>243</td><td>F3</td><td>ó</td><td>带尖锐重音的小写字母 o</td></tr><tr><td>244</td><td>F4</td><td>ô</td><td>带音调符号的小写字母 o</td></tr><tr><td>245</td><td>F5</td><td>õ</td><td>带代字号的小写字母 o</td></tr><tr><td>246</td><td>F6</td><td>ö</td><td>带元音变音 (分音符号) 的小写字母 o</td></tr><tr><td>247</td><td>F7</td><td>oe</td><td>小写字母 oe 连字 2</td></tr><tr><td>248</td><td>F8</td><td>ø</td><td>带斜杠的小写字母 o</td></tr><tr><td>249</td><td>F9</td><td>ù</td><td>带重音符的小写字母 u</td></tr><tr><td>250</td><td>FA</td><td>ú</td><td>带尖锐重音的小写字母 u</td></tr><tr><td>251</td><td>FB</td><td>û</td><td>带音调符号的小写字母 u</td></tr><tr><td>252</td><td>FC</td><td>ü</td><td>带元音变音 (分音符号) 的小写字母 u</td></tr><tr><td>253</td><td>FD</td><td>ÿ</td><td>带元音变音 (分音符号) 的小写字母 y 2</td></tr><tr><td>254</td><td>FE</td><td></td><td>[保留] 2</td></tr><tr><td>255</td><td>FF</td><td></td><td>[保留] 2</td></tr></tbody></table></div><p>​        我们下面来看看，我们要往哪里写去：</p><div class="table-container"><table><thead><tr><th style="text-align:center">起始</th><th style="text-align:center">结束</th><th style="text-align:center">大小</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">C0000</td><td style="text-align:center">C7FFF</td><td style="text-align:center">32KB</td><td style="text-align:center">显示适配器BIOS</td></tr><tr><td style="text-align:center">B8000</td><td style="text-align:center">BFFFF</td><td style="text-align:center">32KB</td><td style="text-align:center">用于文本模式显示适配器</td></tr><tr><td style="text-align:center">B0000</td><td style="text-align:center">B7FFF</td><td style="text-align:center">32KB</td><td style="text-align:center">用于黑白显示适配器</td></tr><tr><td style="text-align:center">A0000</td><td style="text-align:center">AFFFF</td><td style="text-align:center">64KB</td><td style="text-align:center">用于彩色显示适配器</td></tr></tbody></table></div><p>​        我们先来看看文本模式：注意，我们可以决定文本上可以显示字符的个数，比如说80x25, 40x25等。我们一般默认80x25，2000个字符，然后，一位存放字符，另一位存放的是属性，那就占4000B</p><p>​        属性字节则是说明其颜色的：</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0luc2lzdDAyMjQ=,size_16,color_FFFFFF,t_70.png" alt="- [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-L0P98Sts-1577965421759)(E:\workspace\TyporaProjects\C笔记\汇编\images\第三章 控制显卡\字符属性取值表.png)]"></p><p>​        显卡怎么玩：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">SECTION MBR vstart&#x3D;0x7c00 ;起始地质编译在0x7c00    mov ax,cs    mov ds,ax    mov es,ax    mov ss,ax    mov fs,ax    mov sp,0x7c00    mov ax,0xb800 ; ax为文本信号起始区    mov gs,ax     ; gs &#x3D; ax 充当段基址的作用    ;ah &#x3D; 0x06 al &#x3D; 0x00 想要调用int 0x06的BIOS提供的中断对应的函数 即向上移动即完成清屏功能    ;cx dx 分别存储左上角与右下角的左边 详情看int 0x06函数调用    mov ax,0600h     mov bx,0700h    mov cx,0    mov dx,184fh        ;调用BIOS中断    int 0x10     ;新增功能 直接操作显存部分    ;预设输出LOVE6 OS        mov byte [gs:0x00],&#39;L&#39; ;低位字节储存ascii字符 小端储存内存顺序相反    mov byte [gs:0x01],0xA4    ;背景储存在第二个字节 含字符与背景属性        mov byte [gs:0x02],&#39;O&#39;     mov byte [gs:0x03],0xA4        mov byte [gs:0x04],&#39;V&#39;     mov byte [gs:0x05],0xA4        mov byte [gs:0x06],&#39;E&#39;     mov byte [gs:0x07],0xA4        mov byte [gs:0x08],&#39;6&#39;     mov byte [gs:0x09],0xA4        mov byte [gs:0x0A],&#39; &#39;     mov byte [gs:0x0B],0xA4        mov byte [gs:0x0C],&#39;O&#39;     mov byte [gs:0x0D],0xA4        mov byte [gs:0x0E],&#39;S&#39;     mov byte [gs:0x0F],0xA4        jmp $ ;于此处死循环        times 510 - ($ - $$) db 0     db 0x55,0xaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bochs调试指令速查"><a href="#bochs调试指令速查" class="headerlink" title="bochs调试指令速查"></a>bochs调试指令速查</h3><h4 id="Debugger-control-类"><a href="#Debugger-control-类" class="headerlink" title="Debugger control 类"></a>Debugger control 类</h4><ul><li>q|quit|exit，这三个命令任意一个都能退出调试状态，关闭虚拟机，一般用q最简单</li><li>set是指令族，通常用set设置寄存器的值</li><li>1） 例如set reg = val 。可以设置的寄存器包括通用寄存器和段寄存器。<br>2）也可以设置每次停止执行时，是否反汇编指令：set u on|off</li><li>show是指令族，有很多子功能，常用就下面3个<br>1）show mod<br>    每次cpu变换模式时就提示，模式是指保护模式、实模式，<br>2）show int<br>   每次有中断时就提示，同时显示三种中断类型，“softint”、“extint”和“iret”，可以单独显示某类中断,如执行<strong>show softint</strong>只显示软件主动触发的中断<strong>show extint</strong>则只显示来自外部设备的中断，<strong>show iret</strong>只显示iretd 指令有关的信息<br>3）show call<br>   每次有函数调用发生时就会提示</li><li>traceon|off 如果此项设为on，每次执行一条指令，bochs都会将反汇编代码打印到控制台，这样在单步调试时免得看源码了。</li><li>u | disasm  [/num]   [start]   [end]<br>将物理地址start到end之间的代码反汇编，如果不指定地址，则反汇编EIP指向的内存，num指定反汇编的指令数。</li><li>setsize = 16|32|64 在使用反汇编命令时，用来告诉调试器段的大小。</li><li>ctrl+c 中断执行，回到bochs控制台</li></ul><h4 id="Execution-control-类"><a href="#Execution-control-类" class="headerlink" title="Execution control 类"></a>Execution control 类</h4><ul><li>c|cont|continue，这三个命令都意为向下持续执行，若没有断点则一直运行下去</li><li>s|step [count] 执行count条指令，若不指定默认count=1，若遇到函数调用，则会进入函数去执行</li><li>p|n|next 执行1条指令，若待执行的指令是函数调用，不管函数内有多少指令，把整个函数当作一个整体来执行</li></ul><h4 id="Breakpoint-management-类"><a href="#Breakpoint-management-类" class="headerlink" title="Breakpoint management 类"></a>Breakpoint management 类</h4><p>以地址打断点：</p><ul><li>vb|vbreak [seg:off] 以虚拟地址添加断点，程序执行到此虚拟地址停下来，注意虚拟地址是“段：段内偏移”的形式。vb比较常用</li><li>lb|lbreak [addr] 以线性地址添加断点，程序执行到此线性地址停下来。lb比较常用</li><li>pb|pbreak|b|break [addr] 以物理地址添加断点，程序执行到此物理地址停下来。b比较常用</li></ul><p>以指令数打断点：</p><ul><li>sb [delta]  delta表示增量，意味再执行delta条指令程序就中断</li><li>sba [time] CPU从运行开始，执行第time条指令时中断，从0开始的指令数</li></ul><p>以读写IO打断点：</p><ul><li>wath r|read [phy_addr]   设置读断点，如果物理地址phy_addr有读操作则停止运行</li><li>wath w|write [phy_addr]   设置写断点，如果物理地址phy_addr有写操作则停止运行</li><li>watch 显示所有读写断点</li><li>unwatch 清除所有断点</li><li>unwatch [phy_addr] 清除在此地址上的读写断点</li><li>bpd|bpe [n] 禁用断点(break point disable) / 启用断点(break point enable)，n是断点号，可以用blist命令先检查出来</li><li>d|del|delete [n] 删除某断点，n是断点号，可以用blist命令先查出来</li></ul><h4 id="CPU-and-memory-contents-类"><a href="#CPU-and-memory-contents-类" class="headerlink" title="CPU and memory contents 类"></a>CPU and memory contents 类</h4><ul><li><p>x/nuf [line_addr] 显示线性地址的内容。n、u、f是三个参数，都是可选的，如果没有指定，则默认n=1，u=4，f=x</p><p>n：显示的单元数<br>u：每个显示单元的大小<br>    b 1字节<br>    h 2字节<br>    w 4字节<br>    g 8字节<br>f：显示格式<br>x 十六进制显示<br>d 十进制显示<br>u 无符号十进制显示<br>o 按照八进制显示<br>t 按照二进制显示<br>c 按照字符显示<br>s 按照ASCLLz显示<br>i 按照instr显示</p></li><li><p>xp /nuf [phy_addr] 显示物理地址 phy_addr 处的内容，注意和 x 的区别，x 是线性地址。</p></li><li><p>setpmem [phy_addr] [size] [val] 设置以物理内存 phy_addr 为起始，连续 size 个字节的内容为 val。在某些情况下不易调试时，可以在程序中通过某个地址的值来判断分支，需要用 setpmem 来配合。size 最多只能设置 4 个字节宽度的数据</p></li><li><p>r|reg|regs|registers 任意四个命令之一便可以显示 8 个通用寄存器的值+eflags 寄存器+eip 寄存器。</p></li><li><p>ptime 显示 Bochs 自启动之后，总执行指令数。</p></li><li><p>print-stack [num] 显示堆栈，num 默认为 16，表示打印的栈条目数。输出的栈内容是栈顶在上，低地址在上，高地址在下。这和栈的实际扩展方向相反，这一点请注意。</p></li><li><p>?|calc 内置的计算器。</p></li><li><p>info 是个指令族，执行 help info 时可查看其所有支持的子命令，如下：<br>1）info pb|pbreak|b|break 查看断点信息，等同于 blist。<br>2）info CPU 显示 CPU 所有寄存器的值，包括不可见寄存器。<br>3）info fpu 显示 FPU 状态。<br>4）info idt 显示中断向量表 IDT。<br>5）info gdt [num]显示全局描述符表 GDT，如果加了 num，只显示 gdt中第 num 项描述符。<br>6）info ldt 显示局部描述符表 LDT。<br>7）info tss 显示任务状态段 TSS。<br>8）info ivt [num]显示中断向量表 IVT。和 gdt 一样，如果指定了 num，则只会显示第 num 项的中断向量。如果想知道 BIOS 在中断向量表中建立了哪些中断，执行此命令就可以看</p></li><li><p>info flags|eflags 显示状态寄存器，其实在用 r 命令显示寄存器值时也会输出 eflags 的状态，还会输出通用寄存器的值，我通常会用 r 来看。<br>sreg 显示所有段寄存器的值。<br>dreg 显示所有调试寄存器的值。<br>creg 显示所有控制寄存器的值。<br>info tab 显示页表中线性地址到物理地址的映射。<br>page line_addr 显示线性地址到物理地址间的映射。</p></li></ul><h3 id="硬盘介绍"><a href="#硬盘介绍" class="headerlink" title="硬盘介绍"></a>硬盘介绍</h3><p>将磁盘整个盘面划分为多个同心环，以圆心画扇型，扇型与每个同心环相交的弧状区域作为最基本的数据存储单元。这个同心环就称为磁道，而同心环上的弧状区域是扇型的一部分，称为扇区。不同盘面的磁道组成的管状区域就称为柱面。</p><p>扇区的编号从1开始。盘面和磁道的编号从0开始。扇区有自己的“头部”，包含扇区自身的信息：磁头号、磁道号和扇区号。</p><p>针对硬盘的 IO 接口时硬盘控制器。</p><h4 id="3-5-3-硬盘控制器端口"><a href="#3-5-3-硬盘控制器端口" class="headerlink" title="3.5.3 硬盘控制器端口"></a>3.5.3 硬盘控制器端口</h4><p><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录3\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pod2VueDM=,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p><p>端口分为两组：</p><ul><li>Command Block registers。用于向硬盘驱动器写入命令字或者从硬盘控制器获得硬盘状态</li><li>Control Block registers。用于控制硬盘工作状态</li></ul><p>端口时按照通道给出的，要想操作某通道上的某块硬盘，需要单独指定。</p><p>data 寄存器的作用是读取或写入数据，宽度是16位（其它硬盘控制器寄存器都是8位）。在读硬盘时，硬盘准备好数据后，硬盘控制器将其放在内部的缓冲区中，不断读此寄存器便是读出缓冲区中的全部数据。在写硬盘时，把数据输送到此端口，数据便被存入缓冲区里，硬盘控制器发现这个缓冲区中有数据了，便将此处的数据写入相应的扇区中。</p><p>Error 和 Feature 寄存器都是 8 位宽度。</p><p>Sector count 寄存器用来指定待读取或待写入的扇区数。硬盘每完成一个扇区，就会将此寄存器的值减1，所以如果中间失败了，此寄存器中的值便是尚未完成的扇区。最大值是255，若指定为0，表示要操作256个扇区。</p><p>逻辑块地址（Logical Block Address），扇区从 0 开始依次递增编号，不用考虑扇区所在的物理结构。</p><p>LBA 有两种：</p><ul><li>LBA28。用 28 位比特来描述一个扇区的地址，最大支持128GB</li><li>LBA48。用 48 位比特来描述一个扇区的地址，最大支持128PB</li></ul><p>LBA 寄存器有 LBA low、LBA mid、LBA high 三个。LBA low 寄存器用来存储 28 位地址的第 0 ~ 7 位，LBA mid 寄存器用来存储第 8 ~ 15 位，LBA high 寄存器存储第 16 ~ 23 位。</p><p>device 寄存器的低 4 位用来存储 LBA 地址的第 24 ~ 27 位。第 4 位用来指定通道上的主盘或从盘，0 代表主盘，1 代表从盘。第 6 位用来设置是否启用 LBA 方式，1 代表启用 LBA 模式，0 代表启用 CHS 模式。第 5 和第 7 位固定为 1，称为 MBS 位。</p><p>在读硬盘时，Status 寄存器给出硬盘的状态信息。第 0 位是 ERR 位，如果此位为 1，表示命令出错。第 3 位是 data request 位，如果此位为 1，表示硬盘已经把数据准备好了，主机可以把数据读出来。第 6 位是 DRDY，表示硬盘就绪，可以执行一些命令。第 7 位是 BSY 位，表示硬盘是否繁忙，如果为 1 表示硬盘正忙，此寄存器中其他位都无效。在写硬盘时，Command 寄存器用来存储让硬盘执行的命令，只要把命令写进此寄存器，硬盘就开始工作了。</p><p>将要使用的命令：</p><ul><li>identify：0xEC，硬盘识别</li><li>read sector：0x20，读扇区</li><li>write sector：0x30，写扇区</li></ul><p><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录3\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pod2VueDM=,size_16,color_FFFFFF,t_70#pic_center-1698331851849-3.png" alt="在这里插入图片描述"></p><h4 id="3-5-4-常用的硬盘操作方法"><a href="#3-5-4-常用的硬盘操作方法" class="headerlink" title="3.5.4 常用的硬盘操作方法"></a>3.5.4 常用的硬盘操作方法</h4><p>command 寄存器最后写，一旦 command 寄存器被写入，硬盘就开始干活。</p><p>建议操作步骤：</p><ul><li>先选择通道，往该通道的 sector count 寄存器写入待操作的扇区数</li><li>往该通道上的三个 LBA 寄存器写入扇区起始地址的低 24 位</li><li>往 device 寄存器中写入 LBA 地址的 24 ~ 27 位，并置第 6 位 1，使其为 LBA 模式，设置第 4 位，选择操作的硬盘（主盘或从盘）</li><li>往该通道上的 command 寄存器写入操作命令</li><li>读取该通道上的 status 寄存器，判断硬盘工作是否完成</li><li>如果以上步骤是读硬盘，进入下一个步骤。否则完工</li><li>将硬盘数据读出</li></ul><p>常用的数据传送方式：</p><ul><li>无条件传送。数据源设备随时准备好数据，CPU随时拿</li><li>查询传送。传输前需要先去检测设备的状态</li><li>中断传送。数据源准备好后，发中断通知 CPU 来拿数据</li><li>直接存储器存取方式（DMA）。需要 DMA 控制器</li><li>I/O 处理机传送方式。一种专用于处理 I/O 的处理器</li></ul><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; 主引导程序; --------------------------------------------------%include &quot;boot.inc&quot;SECTION MBR vstart&#x3D;0x7c00 ; 把起始地址编译为 0x7c00    mov ax, cs     ; cs 代码段寄存器    mov ds, ax     ; dx 数据段寄存器    mov es, ax     ; es 附加段寄存器    mov ss, ax     ; ss 堆栈段寄存器    mov fs, ax     ; fs 80386 后添加的寄存器，无全称    mov sp, 0x7c00 ; sp 堆栈指针寄存器    mov ax, 0xb800    mov gs, ax     ; gs 80386 后添加的寄存器，无全称                   ; 往 gs 中存入显存段基址                   ; 文本模式显存的起始地址是 0xb8000; 清屏; --------------------------------------------------; INT 0x10    功能号: 0x06    功能描述：上卷窗口; --------------------------------------------------; 输入：; AH 功能号 &#x3D; 0x06; AL &#x3D; 上卷的行数(如果为0，表示全部); BH &#x3D; 上卷行属性; (CL, CH) &#x3D; 窗口左上角的 (X, Y) 位置; (DL, DH) &#x3D; 窗口右下角的 (X, Y) 位置; 无返回值:    mov ax, 0x600    mov bx, 0x700    mov cx, 0    mov dx, 0x184f ; 右下角: (80, 25)                   ; VGA 文本模式种，一行只能容纳 80 个字符，共 25 行                   ; 下标从 0 开始，所以 0x18&#x3D;24, 0x4f&#x3D;79            int 0x10       ; int 0x10    mov eax, LOADER_START_SECTOR ; loader 的起始扇区 LBA 地址    mov bx, LOADER_BASE_ADDR     ; 写入的地址    mov cx, 4                    ; 待读入的扇区数    call rd_disk_m_16            ; 以下读取程序的起始部分（一个扇区）    jmp LOADER_BASE_ADDR + 0x300; 读取硬盘 n 个扇区rd_disk_m_16:                                 ; eax &#x3D; LBA 扇区号                                 ; bx &#x3D; 将数据写入的内存地址                                 ; cx &#x3D; 读入的扇区数    mov esi, eax    ; 备份 eax    mov di, cx      ; 备份 cx    ; 1. 设置要读取的扇区数    mov dx, 0x1f2    mov al, cl    out dx, al      ; 读取的扇区数    mov eax, esi    ; 恢复 ax    ; 2. 将 LBA 地址存入 0x1f3 ~ 0x1f6        ; LBA 地址 7 ~ 0 位写入端口 0x1f3    mov dx, 0x1f3    out dx, al    ; LBA 地址 15 ~ 8 位写入端口 0x1f4    mov cl, 8    shr eax, cl    mov dx, 0x1f4    out dx, al    ; LBA 地址 23 ~ 16 位写入端口 0x1f5    shr eax, cl    mov dx, 0x1f5    out dx, al    shr eax, cl    and al, 0x0f ; LBA 地址的第 24 ~ 17 位    or al, 0xe0  ; 设置 7 ~ 4 位为 1110，表示 LBA 模式    mov dx, 0x1f6    out dx, al    ; 3. 向 0x1f7 端口写入读命令，0x20    mov dx, 0x1f7    mov al, 0x20    out dx, al    ; 4. 检测硬盘状态    .not_ready:        ; 从 Status 寄存器读硬盘状态        nop        in al, dx        and al, 0x88   ; 第 3 位为 1 表示硬盘控制器已准备好数据传输                       ; 第 7 位为 1 表示硬盘忙        cmp al, 0x08        jnz .not_ready ; 若硬盘未准备好，继续等        ; 5. 从 0x1f0 端口读数据    mov ax, di     ; di &#x3D; 要读入的扇区数    mov dx, 256    ; 一个扇区有 512 个字节，ax 寄存器宽度是 2 字节                   ; 一共需要读 di * 512 &#x2F; 2 &#x3D; di * 256 次    mul dx         ; ax &#x3D; ax * dx    mov cx, ax     ; cx &#x3D; 读硬盘次数    mov dx, 0x1f0    .go_on_read:        in ax, dx        mov [bx], ax     ; bx&#x3D;loader将被写到的内存地址        add bx, 2        ; ax 的宽度是两字节，内存地址需要往后移两个字节        loop .go_on_read         rettimes 510-($-$$) db 0db 0x55, 0xaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; boot.inc; loader 和 kernelLOADER_BASE_ADDR     equ 0x900      ; loader 被 MBR 写到的内存地址LOADER_START_SECTOR  equ 0x2        ; loader 所在硬盘 LBA 扇区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="保护模式入门"><a href="#保护模式入门" class="headerlink" title="保护模式入门"></a>保护模式入门</h1><p>​        我们结束阐述实模式，开始玩玩保护模式！首先我们引出一个问题：为什么需要保护模式呢？</p><ul><li>操作系统和用户程序同等级别</li><li>直接操纵的就是真实的物理地址，换而言之，我们的逻辑地址就是物理地址</li><li>用户可以随意修改段基址，从而任意的访问所有内存</li></ul><p>​        这是安全问题，下面讲讲效率：</p><ul><li>每当访问超过64KB的内存就要切换段基址</li><li>单批处理。也就是一次只可以运行一个程序</li><li>只有20地址线，最大可用内存不过1M。</li></ul><h2 id="扩展的寄存器"><a href="#扩展的寄存器" class="headerlink" title="扩展的寄存器"></a>扩展的寄存器</h2><p>​        现在，我们将开启32位时代，首先做的就是扩展我们的寄存器。之前，为了访问32位的数据，我们将之扩展为32位的寄存器，每一个寄存器的名称上我们都加上了一个前缀e:</p><p><img src="7e576fbe14e54be4a33156309b49a34e.png" alt="在这里插入图片描述"></p><p>​        这样设计是为了兼容先前的8086，偏移地址还是跟实模式一致，但是多加了信息检查，这就需要我们存储大量的检查标准和信息，我们就使用了一个数据结构：叫做GDT（全局描述表），来存放这些信息，每一个表项都是64个字节（64B），他在内存中，所以整一个GDTR指向他就好了。</p><h2 id="寻址扩展"><a href="#寻址扩展" class="headerlink" title="寻址扩展"></a>寻址扩展</h2><p>​        在16位下，我们只可以使用bx, bp作为基址寄存器，si, di作为变址寄存器。他们都是有固定使命的。而且，立即操作数（偏移寻址时的立即数）值可以是4个字节大小。这很不方便。所以现在，我们可以更加灵活的编址了：也就是使用扩展了的寄存器，并且允许对变址寄存器乘上一个比例因子（左移1， 2 ，3位）</p><pre class="line-numbers language-none"><code class="language-none">mov eax, [eax + edx*8 + 0x12345678]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当然，esp不可以用作变址寄存器。但是可以作为基址寄存器。</p><h2 id="运行模式反转"><a href="#运行模式反转" class="headerlink" title="运行模式反转"></a>运行模式反转</h2><p>​        我们在编写代码的时候，CPU并不知道我们的代码视在16位实模式下运行还是32位保护模式下运行，我们需要手动指定。很简单</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 16] ; 16位[bits 32] ; 32位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        我们来实际看看，两个环境下的代码是如何切换的：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 32]00000000  B8 78563412        mov eax,0x1234567800000005  BA 78563412        mov edx,0x12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        如果我们交叉写呢？</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">00000000  B83412            mov ax,0x123400000003  66B834120000      mov eax,0x123400000009  66BA3412BA34      mov edx,0x34ba12340000000F  1200              adc al,[bx+si]00000011  00                db 0x00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到，我们的反汇编器可以识别之，<strong>并且会给机器码上标识66，标识的是执行当前的代码需要反转一次状态</strong>：可以是16位切换到32位模式下，<strong>前面添加了前缀码66.反之亦然。对于寻址模式的反转，我们会在机器码上添加前缀0x67。</strong></p><h2 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h2><p>​        <strong>全局描述符号表是一个在保护模式下内存段登记表。为了更好的回忆，我们首先来看看段描述符。一个描述符是64位大小的，我买让我们依次来看看：</strong><br>​        首先，是段基址，由于保护模式下地址总线有32根，段基址就需要有32位。段界限字如其名，表示的是段边界的扩展最值，扩展方向可以向上，也可以向下。这对于数据段和代码段，向上扩展，对于栈则是向下扩展。段界限使用20位描述，它是一个数，最终折算成具体界限还是需要看粒度是1字节（1MB）还是4KB（4GB）。这里，段描述符存储了一个位G来说明粒度，1表示4KB，0表示1字节。</p><p>​        下面，还有type字段（S表示的是是否为系统段，0则为系统段，1则是数据段），A表示的是是否可以使用，C表示的是一致性代码，R表示的是是否可读，W表示是否可写，X表示的是代码是否可以执行，E指明扩展方向（1表示向下扩展），DPL字段（描述的当前描述符的特权级），2位可以表示4个字节。P表示的是段是否存在于内存，这是一个标记位。AVL表示的是可用，不过这里是保留的，操作系统可以使用之。DB位则是说明操作数大小的。举个例子：对于代码段，这里用D，D为1则是说明地址是32位的，否则是16位的。对于栈则是B，说明操作数的大小</p><h3 id="GDT，LDT和选择子"><a href="#GDT，LDT和选择子" class="headerlink" title="GDT，LDT和选择子"></a>GDT，LDT和选择子</h3><p>​        GDT的位置用一个GDTR寄存器来保存位置，这个寄存器48位大小，前32位存储位置，后16位描述GDT界限，也就是说，他可以指向65536/8=8192个段和门。当我们打开GDT后，段基址寄存器失去意义，段基址被存在表里了，现在他存储的是选择子，低2位放RPL（请求特权级），TI存放的是这个选择子在GDT还是LDT，高十三位就是索引值部分。刚好8192个，对上GDT了。<br>现在，我们就可以直接使用选择子指向的段描述符，现在就可以直接取地址并接起来就是我们要的地址了。<br>​        A20地址线门是为了兼容上个世纪的使用地址回环的技巧的程序方便使用的，这里不阐述了。<br>​        下面，我们来看看CR0寄存器，我们聚焦于第一位，也就是PE位，这一位打开了，我们就会进入保护模式了。<br>​        我们如何体现保护的呢，答案是使用多出来的一些判断位。向段寄存器加载的时候，需要看高十三位是不是在GDT或者是LDT的数目之内，有点像查看有没有越界访问。先看TI，决定去哪里拿，在看拿到的是啥，也就是看描述符里这片内存的属性。<br>CS加载代码段，它必须要求数据具有可执行性。<br>​        其他四个段寄存器则必须要求代码至少是可读或者是可写的。对于SS寄存器则必须要求可写，余下三个必须要求可读（不然怎么读取）<br>​        对于数据段，代码段的访问保护，则是查看代码段和数据段访问处尾端有没有越过段界限下<br>​        对于栈段，则是查看有没有低于最大用户栈空间和有没有有没有高于段界限，是就没事，不是则会抛出异常</p><p>​        我们下面来实践一段代码：那就是让我们的操作系统成功的进入保护模式并且整点活出来！</p><p>​        为了操作方便，我们先定义一串宏</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%include &quot;boot.inc&quot;section loader vstart&#x3D;LOADER_BASE_ADDRLOADER_STACK_TOP equ LOADER_BASE_ADDRjmp loader_start; gdt createGDT_BASE:               dd 0x0000_0000                        dd 0x0000_0000CODE_DESCRIPTOR         dd 0x0000_FFFF                        dd DESCRIBTOR_CODE_HIGH4DATA_STACK_DESCRIPTOR:  dd 0x0000_FFFF                        dd DESCRIBTOR_DATA_HIGH4VIDEO_DESCRIPTOR:       dd 0x8000_0007; limit &#x3D; 0xbffff - 0xb8000&#x2F;4K &#x3D; 7; text_mode specific                        dd DESCRIBTOR_VIDEO_HIGH4GDT_SIZE                equ $ - GDT_BASE;到这里了GDT多长GDT_LIMIT               equ GDT_SIZE - 1times 60 dq 0; 60 decriptors; 填充4字节的; 预备一些选择子SELECTOR_CODE           equ (0x0001 &lt;&lt; 3) + TI_GDT + RPL0; [(CODE_DESC - GDT_BASE) &#x2F;8 ]&lt;&lt;3+ TI_GDT + RPL0 SELECTOR_DATA           equ (0x0002 &lt;&lt; 3) + TI_GDT + RPL0SELECTOR_VIDEO          equ (0x0003 &lt;&lt; 3) + TI_GDT + RPL0; gdt pointerGDT_PTR                 dw GDT_LIMIT                        dd GDT_BASEloader_msg              db &#39;2 loader in real mode!&#39;loader_start:;--------------------------------------------------------------------------;INT 10; | 0x13 functional | print string!;--------------------------------------------------------------------------; AH &#x3D; 13H; BH &#x3D; page code; BL &#x3D;  attribute; CX &#x3D; string length;(DH, DL):POS; ES:BP string addr; AL: ways of outputmov sp, LOADER_BASE_ADDRmov bp, loader_msgmov cx, 22mov ax, 0x1301mov bx, 0x001fmov dx, 0x1800int 0x10; ----------------LOAD_TO_PRESERVED_MODE--------------------------------; Open A20; Load GDT; CR0 set first bet Page Enable 1; ----------------LOAD_TO_PRESERVED_MODE--------------------------------in al, 0x92or al, 0000_0010Bout 0x92, allgdt [GDT_PTR]mov eax, cr0or  eax, 0x0000_00001mov cr0, eaxjmp dword   SELECTOR_CODE:p_mode_start;刷新流水线[bits 32]p_mode_start:    mov ax, SELECTOR_DATA    mov ds, ax    mov es, ax    mov ss, ax    mov esp, LOADER_STACK_TOP    mov ax, SELECTOR_VIDEO    mov gs, ax    mov byte [gs:0xB0], &#39;P&#39; ; 放上一个P足矣！    jmp $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        引用的boot.inc是</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; --------------------LOADER and KERNEL---------------LOADER_BASE_ADDR            equ 0x900LOADER_START_SECTOR         equ 0x2;---------------------Global Describtor Table---------; 4k set 1 as per sector multiply 4KDESCRIBTOR_G_4K            equ 1000_0000_0000_0000_0000_0000b; set 1 as to indicate the operator is 32bits instead of 16 bitsDESCRIBTOR_D_32            equ  100_0000_0000_0000_0000_0000b; No, not 64 bits but 32!DESCRIBTOR_L               equ   00_0000_0000_0000_0000_0000b; Currently we don&#39;t use the AVL bits, as we don&#39;t have to make it meaningful!DESCRIBTOR_AVL             equ    0_0000_0000_0000_0000_0000b ; the second segments limitations in high 32 bitsDESCRIBTOR_LIMIT_CODE_2    equ      1111_0000_0000_0000_0000b; else for the data if the descriptor indicates the data segDESCRIBTOR_LIMIT_DATA_2    equ      DESCRIBTOR_LIMIT_CODE_2; for Video(显存) one:DESCRIBTOR_LIMIT_VIDEO_2   equ       000_0000_0000_0000_0000b; P for the present, of course it must be present :)DESCRIBTOR_P               equ           1000_0000_0000_0000b; Following macro sets the Privilage Level of the kernelDESCRIBTOR_DPL_0           equ            000_0000_0000_0000bDESCRIBTOR_DPL_1           equ            010_0000_0000_0000bDESCRIBTOR_DPL_2           equ            100_0000_0000_0000bDESCRIBTOR_DPL_3           equ            110_0000_0000_0000b; S stands for the basic type of the descriptor; 1 for the user des, 0 for the system des DESCRIBTOR_S_CODE          equ              1_0000_0000_0000bDESCRIBTOR_S_DATA          equ              DESCRIBTOR_S_CODEDESCRIBTOR_S_SYS           equ              0_0000_0000_0000b; set the type now! remember it is the X C R A for CODE X E W A for data; for code it is executable, not the consistence, unable to read , a is for \; having read, we haven&#39;t read it yet, set 0DESCRIBTOR_TYPE_CODE       equ                1000_0000_0000b; for the data. not executable, extended upper and writableDESCRIBTOR_TYPE_DATA       equ                0010_0000_0000b; make a sum and get the HIGH32bits; 代码段高位DESCRIBTOR_CODE_HIGH4      equ                (0x00 &lt;&lt; 24) + DESCRIBTOR_G_4K + \                                              DESCRIBTOR_D_32 + DESCRIBTOR_L + \                                              DESCRIBTOR_AVL + DESCRIBTOR_LIMIT_CODE_2 + \                                              DESCRIBTOR_P + DESCRIBTOR_DPL_0 + DESCRIBTOR_S_CODE +   DESCRIBTOR_TYPE_CODE + 0x00;数据段高位DESCRIBTOR_DATA_HIGH4      equ                (0x00 &lt;&lt; 24) + DESCRIBTOR_G_4K + \                                              DESCRIBTOR_D_32 + DESCRIBTOR_L + \                                              DESCRIBTOR_AVL + DESCRIBTOR_LIMIT_DATA_2 + \                                              DESCRIBTOR_P + DESCRIBTOR_DPL_0 + DESCRIBTOR_S_CODE +   DESCRIBTOR_TYPE_DATA + 0x00; 显卡高位DESCRIBTOR_VIDEO_HIGH4     equ                (0x00 &lt;&lt; 24) + DESCRIBTOR_G_4K + \                                              DESCRIBTOR_D_32 + DESCRIBTOR_L + \                                              DESCRIBTOR_AVL + DESCRIBTOR_LIMIT_VIDEO_2 + \                                              DESCRIBTOR_P + DESCRIBTOR_DPL_0 + DESCRIBTOR_S_CODE +   DESCRIBTOR_TYPE_DATA + 0x0B  ; --------------------------Sector-------------------------; Request Privilage Level from 0 to 3RPL0                       equ                00bRPL1                       equ                01bRPL2                       equ                10bRPL3                       equ                11b; What kind of the Table? Global One or Local OneTI_GDT                     equ                000bTI_LDT                     equ                100b                                                                               <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这里则是存储了大量的比特位操作。可以注释理解</p><p>​        配合上mbr.S</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; Main Guide%include &quot;boot.inc&quot;SECTION MBR vstart&#x3D;0x7c00    mov ax, cs    mov ds, ax    mov es, ax    mov ss, ax    mov fs, ax    mov sp, 0x7c00    mov ax, 0xb800    mov gs, ax; --------CLEAR SCREEN-----------------; INT 10, functional 0x06 ; -------------------------------------mov ax, 0600mov bx, 0700mov cx, 0mov dx, 184fint 10h; outPutBytesmov byte [gs:0x00], &#39;W&#39;mov byte [gs:0x01], 0xA4mov byte [gs:0x02], &#39;e&#39;mov byte [gs:0x03], 0xA4mov byte [gs:0x04], &#39;l&#39;mov byte [gs:0x05], 0xA4mov byte [gs:0x06], &#39;c&#39;mov byte [gs:0x07], 0xA4mov byte [gs:0x08], &#39;o&#39;mov byte [gs:0x09], 0xA4mov byte [gs:0x0a], &#39;m&#39;mov byte [gs:0x0b], 0xA4mov byte [gs:0x0c], &#39;e&#39;mov byte [gs:0x0d], 0xA4mov byte [gs:0x0e], &#39; &#39;mov byte [gs:0x0f], 0xA4mov byte [gs:0x10], &#39;P&#39;mov byte [gs:0x11], 0xA4mov byte [gs:0x12], &#39;r&#39;mov byte [gs:0x13], 0xA4mov byte [gs:0x14], &#39;e&#39;mov byte [gs:0x15], 0xA4mov byte [gs:0x16], &#39;s&#39;mov byte [gs:0x17], 0xA4mov byte [gs:0x18], &#39;e&#39;mov byte [gs:0x19], 0xA4mov byte [gs:0x1a], &#39;r&#39;mov byte [gs:0x1b], 0xA4mov byte [gs:0x1c], &#39;v&#39;mov byte [gs:0x1d], 0xA4mov byte [gs:0x1e], &#39;e&#39;mov byte [gs:0x1f], 0xA4mov byte [gs:0x20], &#39;d&#39;mov byte [gs:0x21], 0xA4mov byte [gs:0x22], &#39; &#39;mov byte [gs:0x23], 0xA4mov byte [gs:0x24], &#39;M&#39;mov byte [gs:0x25], 0xA4mov byte [gs:0x26], &#39;o&#39;mov byte [gs:0x27], 0xA4mov byte [gs:0x28], &#39;d&#39;mov byte [gs:0x29], 0xA4mov byte [gs:0x2a], &#39;u&#39;mov byte [gs:0x2b], 0xA4mov byte [gs:0x2c], &#39;l&#39;mov byte [gs:0x2d], 0xA4mov byte [gs:0x2e], &#39;e&#39;mov byte [gs:0x2f], 0xA4mov byte [gs:0x30], &#39;!&#39;mov byte [gs:0x31], 0xA4mov eax, LOADER_START_SECTOR;起始扇区地址mov bx, LOADER_BASE_ADDR; 写入的地址mov cx, 4;待读入的扇区个数call rd_disk_m_16jmp LOADER_BASE_ADDR;---------------------------;LOAD DISK;---------------------------rd_disk_m_16:;eax LBA ADDR； BX where shall we write into CX : amounts of disks    mov esi, eax    mov di, cx; Save the important index    ; First:set the read amount    mov dx, 0x1f2    mov al, cl    out dx, al    mov eax, esi    ;LBA 0-7 bits to 0x1f3    mov dx, 0x1f3    out dx, al    ; LBA 8-15 to 0x1f4    mov cl, 8    shr eax, cl ; shr means shift right cl bits    mov dx, 0x1f4    out dx, al    ; LBA 16-23    shr eax, cl    mov dx, 0x1f5    out dx, al    shr eax, cl    and al, 0x0f    or  al, 0xe0; 1110    mov dx, 0x1f6    out dx, al    mov dx, 0x1f7    mov al, 0x20;输入写指令    out dx, al    ;check the state.not_ready:    nop    in al, dx    and al, 0x88; 1000 1000检查第三位是不是1,是1表示准备结束    cmp al, 0x08    jnz .not_ready    ; ready to ready from 0x1f0    mov ax, di    mov dx, 256    mul dx    mov cx, ax    mov dx, 0x1f0.go_on_read:    in ax, dx    mov [bx], ax    add bx, 2    loop .go_on_read    rettimes 510 - ($ - $$) db 0db 0x55, 0xaa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后，先将MBR写到第一个扇区，再将Loader写道后面的扇区：</p><pre class="line-numbers language-none"><code class="language-none">dd if&#x3D;mbr.bin of&#x3D;a.img count&#x3D;1 bs&#x3D;512 seek&#x3D;0 conv&#x3D;notruncdd if&#x3D;loader.bin of&#x3D;a.img count&#x3D;2 bs&#x3D;512 seek&#x3D;2 conv&#x3D;notruncbochs -f bashsrc.ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        这样就可以了：</p><p><img src="image-20231106135326949.png" alt="image-20231106135326949"></p><p><img src="image-20231106135337555.png" alt="image-20231106135337555"></p><h1 id="保护模式进阶"><a href="#保护模式进阶" class="headerlink" title="保护模式进阶"></a>保护模式进阶</h1><h2 id="获取物理内存的容量"><a href="#获取物理内存的容量" class="headerlink" title="获取物理内存的容量"></a>获取物理内存的容量</h2><p>​        本质上调用BIOS的0x15实现</p><pre class="line-numbers language-none"><code class="language-none">EAX&#x3D;0xE820; 遍历主机全部内存AX &#x3D; 0xE801; 检测低15MB和16至4GB的内存AH&#x3D;0x88<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        这一方法在实模式下才可以使用，Linux自己也是在进入保护模式之前完成对内存容量的检查了，然后写近内存方便之后的工作拿取</p><h3 id="0x15下的0xE820"><a href="#0x15下的0xE820" class="headerlink" title="0x15下的0xE820"></a>0x15下的0xE820</h3><p>​        这一方法是迭代的查询每一个种类的内存分配，直到所有的类型都检查完毕。所以返回的信息更加丰富。需要一个格式结构来组织这些数据——那就是ARDS</p><div class="table-container"><table><thead><tr><th>字节偏移量</th><th>属性名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>BaseAddrLow</td><td>基地址的低32位</td></tr><tr><td>4</td><td>BaseAddrHigh</td><td>基地址的高32位</td></tr><tr><td>8</td><td>LengthLow</td><td>内存长度的低32位，单位是字节</td></tr><tr><td>12</td><td>LengthHigh</td><td>内存长度的高32位，单位是字节</td></tr><tr><td>16</td><td>Type</td><td>种类</td></tr></tbody></table></div><p>Type的值分为可以被操作系统直接使用和保留。我们来仔细看看如何使用之， 下面是寄存器的输入输出起到的作用：</p><div class="table-container"><table><thead><tr><th style="text-align:left">寄存器</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">eax</td><td style="text-align:left">功能码，当输入e820h时能够探测内存</td></tr><tr><td style="text-align:left">ebx</td><td style="text-align:left">主要用于指向内存区域，第一次调用时ebx=0,被称为continuation value</td></tr><tr><td style="text-align:left">es:di</td><td style="text-align:left">用于指令执行后，在指向的内存写入描述内存区域的数据结构ARDS(Address Range Descriptor Structure)</td></tr><tr><td style="text-align:left">ecx</td><td style="text-align:left">用于限制指令填充的ARDS的大小，实际上大多数情况这个是无效的，无论ecx设置为多少，BIOS始终会填充20字节的ARDS</td></tr><tr><td style="text-align:left">edx</td><td style="text-align:left">0534D4150h(‘SMAP’),输入时在edx，输出时将会在eax中</td></tr></tbody></table></div><p>下面是输出时各个寄存器(标志)的结果:</p><div class="table-container"><table><thead><tr><th style="text-align:left">寄存器</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left">CF</td><td style="text-align:left">当没有发生错误时,CF=0,否则CF=1</td></tr><tr><td style="text-align:left">eax</td><td style="text-align:left">0534D4150h(‘SMAP’)</td></tr><tr><td style="text-align:left">ebx</td><td style="text-align:left">指向下一个内存区域，而不是调用之前的内存区域，当ebx=0且CF=0时，表示当前是最后一个内存区域。</td></tr><tr><td style="text-align:left">es:di</td><td style="text-align:left">和调用之前一样，如果要保存多个ARDS，需要手动修改es:di</td></tr><tr><td style="text-align:left">ecx</td><td style="text-align:left">返回写入的ARDS的大小</td></tr></tbody></table></div><p>​        所以，简单的讲就是需要我们这样做：</p><p>1）填写好“调用前输入所列出的寄存器”</p><p>2）执行中断int 0x15</p><p>3）在CF位是0下，输出对应的寄存器就会有我们想要的结果</p><h3 id="0xE801"><a href="#0xE801" class="headerlink" title="0xE801"></a>0xE801</h3><p>向ax写入输入号后发其调用即可</p><p>输出：</p><div class="table-container"><table><thead><tr><th>寄存器</th><th>描述</th></tr></thead><tbody><tr><td>cf</td><td>0为出错，1出错了</td></tr><tr><td>ax</td><td>KB为单位，只显示15MB一下的内存，最大就是0x3c00</td></tr><tr><td>bx</td><td>64KB为单位，内存空间16MB-4GB连续的单位数量</td></tr><tr><td>cx</td><td>跟ax一样</td></tr><tr><td>dx</td><td>跟bx一样</td></tr></tbody></table></div><p>​        这个的功能就会较为简单，我们只需要向AX寄存器写入0xE801后执行中断，在判断CF位是0后取数即可。但是这种方法需要注意，他总是返回少1MB的内存。</p><blockquote><p> 80286是拥有24位地址线，其寻址空间是16MB。当时有一些ISA设备要用到地址15MB以上的内存做为缓冲区，也就是此缓冲区为1MB大小，所以硬件系统就把这部分内存保留下来，操作系统不可以用此段内存空间。保留的这部分内存区域就像不可以访问的黑洞，这就成了内存空洞memory hole。现在虽然很少很少能碰到这些老ISA设备了，但为了兼容，这部分空间还是保留下来，只不过是通过bios选项的方式由用户自己选择是否开启。bios厂商不同，一般的菜单选项名称也不相同，不过大概意思都差不多。比如咱们开机进入bios界面后，会有类似这样的选项：</p><p><strong>memory hole at address 15m-16m</strong></p><p>将此选项设为enable或disable便开启或关闭对这类扩展ISA设备的支持。话说，起初定义这个0xe801子功能，就是为了支持扩展ISA服务。现在来回答这个问题。如果检测到的内存容量大于等于16MB，bios 0x15中断返回的结果中，AX*1024必然是小于等于15MB，而BX*64*1024肯定大于0。所以，内存容量分成两部分展示，只要符合这两个结果，就能检查出内存空洞。当然如果物理内存在16MB以下，此方法就不灵了，但检测到的内存依然会小于实际内存1MB。所以实际的物理内存大小，在检测结果的基础上一定要加上1MB。</p></blockquote><h3 id="0x88"><a href="#0x88" class="headerlink" title="0x88"></a>0x88</h3><p>这是最后一个，也是最简单的一个，</p><p><img src="c0b65d3720a54014910fc7dc4372d5b7.png" alt="img"></p><p>​        方法一样，上班写代码，我们依次来看看如何调用：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">%include &quot;boot.inc&quot;section loader vstart&#x3D;LOADER_BASE_ADDRLOADER_STACK_TOP equ LOADER_BASE_ADDRjmp loader_start; gdt createGDT_BASE:               dd 0x0000_0000                        dd 0x0000_0000CODE_DESCRIPTOR         dd 0x0000_FFFF                        dd DESCRIBTOR_CODE_HIGH4DATA_STACK_DESCRIPTOR:  dd 0x0000_FFFF                        dd DESCRIBTOR_DATA_HIGH4VIDEO_DESCRIPTOR:       dd 0x8000_0007; limit &#x3D; 0xbffff - 0xb8000&#x2F;4K &#x3D; 7; text_mode specific                        dd DESCRIBTOR_VIDEO_HIGH4GDT_SIZE                equ $ - GDT_BASEGDT_LIMIT               equ GDT_SIZE - 1times 59 dq 0; 60 decriptors ;DQ 定义的变量为4字型（8字节）Define Quadra Wordtimes 5 db 0total_mem_bytes dd 0 ;保存内存中的总量大小，而我们默认bin vstart &#x3D; 0x900 + 0x200 &#x3D; 0xb00; why 0x200 &#x3D; 512? 60 x 8(discriptor) + 32btye(Current GDT Size: 0 for ununsable, code, video and data)GDT_PTR                 dw GDT_LIMIT; GDT_Reg 48 bits &#x3D;&#x3D; 1 w + 1 dw                        dd GDT_BASE                        ; tol_mem_bytes 4 + gdt_ptr 6 + buf 244 + ards_nr 2 &#x3D; 256ards_buf times 244      db 0 ; Auto Filled the bytesards_nr                 dw 0 ; record the number of ARDSSELECTOR_CODE           equ (0x0001 &lt;&lt; 3) + TI_GDT + RPL0SELECTOR_DATA           equ (0x0002 &lt;&lt; 3) + TI_GDT + RPL0SELECTOR_VIDEO          equ (0x0003 &lt;&lt; 3) + TI_GDT + RPL0; gdt pointerloader_start:; int 15h eax &#x3D; 0000_E820, edx &#x3D; 534D4150h &quot;SMAP&quot; as the signature to checkxor ebx, ebxmov edx, 0x534D4150mov di, ards_buf.e820_mem_get_loop:    mov eax, 0x0000_E820; caller    mov ecx, 20 ;ARDS is 20 bytes    int 0x15 ; call    jc .e820_mem_failed_try_e801 ; cf is 1 to signal the error, jmp to the second method    add di, cx    inc word [ards_nr] ; ards_nr++    cmp ebx, 0 ; is 0 means finish all and ready return    jnz .e820_mem_get_loop    ; find max     mov cx, [ards_nr]    mov ebx, ards_buf    xor edx, edx; clear edx to store the largest.find_max_mem_area:    mov eax, [ebx];base add low    add eax, [ebx + 8];length_low    add ebx, 20; next    cmp edx, eax; we always store largest in edx    jge .next_ards    mov edx, eax.next_ards:    loop .find_max_mem_area    jmp .mem_get_ok; --- E801H --------.e820_mem_failed_try_e801:    mov eax, 0xe801    int 0x15    jc .e801_failed_try_88    mov cx, 0x400    mul cx    shl edx, 16    and eax, 0x0000FFFF    or edx, eax    add edx, 0x10_0000; ax &#x3D; 15MB    mov esi, edx; store    ; 16MB+    xor eax, eax    mov ax, bx    mov ecx, 0x10000 ; 64KB    mul ecx     ; High in edx, low in eax    add esi, eax    mov edx, esi    jmp .mem_get_ok; ----0x88---.e801_failed_try_88:    mov ah, 0x88    int 0x15    jc .error_hlt    and eax, 0x0000_FFFF    mov cx, 0x400; change it to byte     mul cx    shl edx, 16; dx left move to higher place    or edx, eax; then we get dx | ax as 32bits    add edx, 0x100000; add the bonus 1MB.mem_get_ok:    mov [total_mem_bytes], edx; ----------------LOAD_TO_PRESERVED_MODE--------------------------------; Open A20; Load GDT; CR0 set first bet Page Enable 1; ----------------LOAD_TO_PRESERVED_MODE--------------------------------in al, 0x92or al, 0000_0010Bout 0x92, allgdt [GDT_PTR]mov eax, cr0or  eax, 0x0000_00001mov cr0, eaxjmp dword   SELECTOR_CODE:p_mode_start.error_hlt:hlt[bits 32]p_mode_start:    mov ax, SELECTOR_DATA    mov ds, ax    mov es, ax    mov ss, ax    mov esp, LOADER_STACK_TOP    mov ax, SELECTOR_VIDEO    mov gs, ax    mov byte [gs:0xB0], &#39;P&#39;    jmp $<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们查看一下，在0xb00位置处：</p><pre class="line-numbers language-none"><code class="language-none">xp 0xb00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20231113140535303.png" alt="image-20231113140535303"></p><p>​        10进制下就是32MB，成功！</p><h2 id="开启分页机制"><a href="#开启分页机制" class="headerlink" title="开启分页机制"></a>开启分页机制</h2><p>​        我们下面就要开启分页机制了，打开分页后，我们的CPU就不会将简单的线性地址直接认为是物理地址了。现在，我们将连续的线性地址与任意的物理内存相互关联（就是说，我们需要将线性地址经过转化才可以是物理地址）</p><p>​        分页机制就干两件事情：</p><ol><li>将线性地址通过映射得到物理地址</li><li>将大小相等的页替换大小不等的段</li></ol><p>​        现在，这个线性地址有了新的名称：虚拟地址。那么，我们又会是怎样的映射呢？答案是，以4KB作为粒度，这样分出来1M个页，用20个位表示即可，而剩下的12位恰好描述了4KB（2的12次方）。然而，一级页表还是大小可观，所以我们采用的是二级页表，每一个页表的物理地址都用页目录项的方式存储（Page Directory Entry）。采用了二级页表，我们就需要给虚拟地址这样分：前10位寻一级页表，中间10位给二级页表，最后12位是Offset。</p><p>​        页表也有属性，下面一一介绍：</p><div class="table-container"><table><thead><tr><th>位</th><th>说明</th></tr></thead><tbody><tr><td>P</td><td>Present表示的是在不在物理内存</td></tr><tr><td>RW</td><td>Read Write权限</td></tr><tr><td>US</td><td>User还是Supervisor，权限大小</td></tr><tr><td>PWT</td><td>页级通写位，1表示的是在高速缓存</td></tr><tr><td>PCD</td><td>页级高速缓存禁止位</td></tr><tr><td>A</td><td>访问位（可以用来记录内存的访问频率）</td></tr><tr><td>D</td><td>是否有效</td></tr><tr><td>PAT</td><td>页属性位表</td></tr><tr><td>Global</td><td>在不在TLB中，在的话可以直接的从TLB中取出地址直接转换，是用来加速的</td></tr></tbody></table></div><p>开启分页做好三件事情：</p><blockquote><ol><li>准备好页目录表和页表</li><li>将页表地址写入cr3寄存器</li><li>cr0的PG置1</li></ol></blockquote><p>​        我们先给boot.inc添加点新代码：这是一些关于页表的设置问题</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; -----------------------Page Table ---------------PAGE_DIR_TABLE_POS         equ                0x1000000; -----------------------Page Table Related AttributePG_P                       equ                1bPG_RW_R                    equ                00bPG_RW_W                    equ                01bPG_US_S                    equ                000bPG_US_U                    equ                100b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面，我们继续补充代码：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">%include &quot;boot.inc&quot;section loader vstart&#x3D;LOADER_BASE_ADDRLOADER_STACK_TOP equ LOADER_BASE_ADDRjmp loader_start; gdt createGDT_BASE:               dd 0x0000_0000                        dd 0x0000_0000CODE_DESCRIPTOR         dd 0x0000_FFFF                        dd DESCRIBTOR_CODE_HIGH4DATA_STACK_DESCRIPTOR:  dd 0x0000_FFFF                        dd DESCRIBTOR_DATA_HIGH4VIDEO_DESCRIPTOR:       dd 0x8000_0007; limit &#x3D; 0xbffff - 0xb8000&#x2F;4K &#x3D; 7; text_mode specific                        dd DESCRIBTOR_VIDEO_HIGH4GDT_SIZE                equ $ - GDT_BASEGDT_LIMIT               equ GDT_SIZE - 1times 60 dq 0; 60 decriptors ;DQ 定义的变量为4字型（8字节）Define Quadra Wordtotal_mem_bytes dd 0 ;保存内存中的总量大小，而我们默认bin vstart &#x3D; 0x900 + 0x200 &#x3D; 0xb00; why 0x200 &#x3D; 512? 60 x 8(discriptor) + 32btye(Current GDT Size: 0 for ununsable, code, video and data)GDT_PTR                 dw GDT_LIMIT; GDT_Reg 48 bits &#x3D;&#x3D; 1 w + 1 dw                        dd GDT_BASE                        ; tol_mem_bytes 4 + gdt_ptr 6 + buf 244 + ards_nr 2 &#x3D; 256ards_buf times 244      db 0 ; Auto Filled the bytesards_nr                 dw 0 ; record the number of ARDSSELECTOR_CODE           equ (0x0001 &lt;&lt; 3) + TI_GDT + RPL0SELECTOR_DATA           equ (0x0002 &lt;&lt; 3) + TI_GDT + RPL0SELECTOR_VIDEO          equ (0x0003 &lt;&lt; 3) + TI_GDT + RPL0; gdt pointerloader_start:; int 15h eax &#x3D; 0000_E820, edx &#x3D; 534D4150h &quot;SMAP&quot; as the signature to checkxor ebx, ebxmov edx, 0x534D4150mov di, ards_buf.e820_mem_get_loop:    mov eax, 0x0000_E820; caller    mov ecx, 20 ;ARDS is 20 bytes    int 0x15 ; call    jc .e820_mem_failed_try_e801 ; cf is 1 to signal the error, jmp to the second method    add di, cx    inc word [ards_nr] ; ards_nr++    cmp ebx, 0 ; is 0 means finish all and ready return    jnz .e820_mem_get_loop    ; find max     mov cx, [ards_nr]    mov ebx, ards_buf    xor edx, edx; clear edx to store the largest.find_max_mem_area:    mov eax, [ebx];base add low    add eax, [ebx + 8];length_low    add ebx, 20; next    cmp edx, eax; we always store largest in edx    jge .next_ards    mov edx, eax.next_ards:    loop .find_max_mem_area    jmp .mem_get_ok; --- E801H --------.e820_mem_failed_try_e801:    mov eax, 0xe801    int 0x15    jc .e801_failed_try_88    mov cx, 0x400    mul cx    shl edx, 16    and eax, 0x0000FFFF    or edx, eax    add edx, 0x10_0000; ax &#x3D; 15MB    mov esi, edx; store    ; 16MB+    xor eax, eax    mov ax, bx    mov ecx, 0x10000 ; 64KB    mul ecx     ; High in edx, low in eax    add esi, eax    mov edx, esi    jmp .mem_get_ok; ----0x88---.e801_failed_try_88:    mov ah, 0x88    int 0x15    jc .error_hlt    and eax, 0x0000_FFFF    mov cx, 0x400; change it to byte     mul cx    shl edx, 16; dx left move to higher place    or edx, eax; then we get dx | ax as 32bits    add edx, 0x100000; add the bonus 1MB.mem_get_ok:    mov [total_mem_bytes], edx; ----------------LOAD_TO_PRESERVED_MODE--------------------------------; Open A20; Load GDT; CR0 set first bet Page Enable 1; ----------------LOAD_TO_PRESERVED_MODE--------------------------------in al, 0x92or al, 0000_0010Bout 0x92, allgdt [GDT_PTR]mov eax, cr0or  eax, 0x0000_00001mov cr0, eaxjmp dword   SELECTOR_CODE:p_mode_start.error_hlt:hlt[bits 32]p_mode_start:; 初始化GDT    mov ax, SELECTOR_DATA    mov ds, ax    mov es, ax    mov ss, ax    mov esp, LOADER_STACK_TOP    mov ax, SELECTOR_VIDEO    mov gs, ax    call setup_page    sgdt [GDT_PTR]    mov ebx, [GDT_PTR + 2]    or dword [ebx + 0x18 + 4], 0xc000_0000    add dword [GDT_PTR + 2], 0xc000_0000    add esp, 0xc0000000    mov eax, PAGE_DIR_TABLE_POS    mov cr3, eax        mov eax, cr0    or eax, 0x8000_0000    mov cr0, eax        lgdt [GDT_PTR]    mov byte [gs:160], &#39;V&#39;    jmp $; -------------------setup page table ---------setup_page:    mov ecx, 4096    mov esi, 0.clear_page_dir: ; 先把页表空间清0    mov byte [PAGE_DIR_TABLE_POS + esi], 0    inc esi    loop .clear_page_dir;PDE.create_pde: ; Create Page Directory Entry    mov eax, PAGE_DIR_TABLE_POS    add eax, 0x1000;First PDE&#39;s attr    mov ebx, eax    ; ready for PTE    ; kernel one and usr one    or eax, PG_US_U | PG_RW_W | PG_P    ; init the basic attr    mov [PAGE_DIR_TABLE_POS + 0x0], eax    mov [PAGE_DIR_TABLE_POS + 0xc00], eax ; kernel    sub eax, 0x1000    mov [PAGE_DIR_TABLE_POS + 4092], eax; final one points to itself; create PTE    mov ecx, 256    mov esi, 0    mov edx, PG_US_U | PG_RW_W | PG_P.create_pte:    mov [ebx + esi*4], edx    add edx, 4096    inc esi    loop .create_pte; kernel pte    mov eax, PAGE_DIR_TABLE_POS    mov eax, 0x2000    or eax, PG_US_U | PG_RW_W | PG_P    mov ebx, PAGE_DIR_TABLE_POS    mov ecx, 254    mov esi, 769.create_kernel_pde:    mov [ebx + esi*4], eax    inc esi    add eax, 0x1000    loop .create_kernel_pde    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        放鞭炮！</p><p><img src="image-20231113150718261.png" alt="image-20231113150718261"></p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>​        TLB是translation lookaside buffer的简称。首先，我们知道MMU的作用是把虚拟地址转换成物理地址。虚拟地址和物理地址的映射关系存储在页表中，而现在页表又是分级的。64位系统一般都是3~5级。常见的配置是4级页表，就以4级页表为例说明。分别是PGD、PUD、PMD、PTE四级页表。在硬件上会有一个叫做页表基地址寄存器，它存储PGD页表的首地址。MMU就是根据页表基地址寄存器从PGD页表一路查到PTE，最终找到物理地址(PTE页表中存储物理地址)。这就像在地图上显示你的家在哪一样，我为了找到你家的地址，先确定你是中国，再确定你是某个省，继续往下某个市，最后找到你家是一样的原理。一级一级找下去。这个过程你也看到了，非常繁琐。如果第一次查到你家的具体位置，我如果记下来你的姓名和你家的地址。下次查找时，是不是只需要跟我说你的姓名是什么，我就直接能够告诉你地址，而不需要一级一级查找。四级页表查找过程需要四次内存访问。延时可想而知，非常影响性能。</p><h2 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h2><p>​        芜湖！终于可以C语言写代码了！下面，我们单刀直入，直接看看我们的main.c：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main(void)&#123;while(1);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        让我们查看一下：</p><pre class="line-numbers language-none"><code class="language-none">gcc -c -o main.c main.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">file main.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是可重定位文件，这是大家都熟悉的（relocatable）</p><p>​        我们使用nm指令查看符号定位情况，幸好，他足够简单</p><pre class="line-numbers language-none"><code class="language-none">0000000000000000 T main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        没有被重定位，那么地址自然是0！我们编译完成，就需要链接：</p><pre class="line-numbers language-none"><code class="language-none">ld main.o -Ttext 0xc0001500 -e main -o kernel.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        -e手动指定了我们的程序入口在哪个地方。假使我们不加-e main</p><pre class="line-numbers language-none"><code class="language-none">ld main.o -Ttext 0xc0001500 -o kernel.binld: 警告: 无法找到项目符号 _start; 缺省为 00000000c0001500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        嘶，我们这样呢？</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">_start</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        重新编译链接，没问题了！</p><p>​        回忆一下，在此之前，我们是怎么调用程序的，BIOS初始化之后，将第0扇区的MBR加载到0x7c00并且跳到那里执行，mbr再去调用loader，loader的地址是0x900。可以看到这些程序的地址都是固定的，并且调用方和被调用方需要约定好地址，存储在哪。这种方式是很不灵活的，我们可以提供一种较为灵活地方式来加载各种可执行程序吗？有，这种方式就是文件头+文件体。</p><p>　　文件头和文件体的运用还是不少的，比如我们学习计算机网络时，从应用层到链路层每一层都会添加一个头部用来描述这一层用的是什么协议，大小是多少等等。头部像是书上的目录，而文件体就像书的每一章内容，通过书上目录显示的每一章的页码，我们就能找到对应章的位置。</p><p>　　个人理解，文件头+文件体的方式并不是说不需要指定入口地址，它只不过是将入口地址等信息放到一个统一的模块去存储，从某种意义上说，其实和加载MBR和Loader没啥区别，都是需要得到入口地址，而这个入口地址无非是一个放在了一个常数变量里（宏定义），一个放在了一个类似表的东西（文件头），只不过我们约定好了一种文件格式，我们都总能根据格式规范找到入口地址，不再需要自己去额外定义常数，这会更加统一和灵活一些，就像C语言定义了一个结构体，结构体里定义好了有哪些成员，我们预先知道了这个结构体有什么成员，在哪个位置，到这个位置取出变量即可，文件头就和结构体类似，假设文件头告诉你它包含文件体大小和入口地址两个成员，而入口地址在文件体的第二个成员的位置，你去那里找就好了，这样的话任何可执行文件都可以按这种方式找到这个入口地址，不再需要定义变量这种不灵活的方式了。另外值得注意的一点是，程序头部是编译器生成的，那么入口地址自然也是编译器去赋值的 ，当然赋值多少要看编译器怎么实现，我们可以让编译器生成目标文件时<strong>指定入口地址</strong>，也可以让编译器自己去决定入口地址。</p><p>　　那么对于程序来说，程序头和程序体需要包含什么呢？程序头最基本需要包含程序体的大小和程序的入口地址，程序体大小限制了程序体的边界，程序入口地址方便让我们跳到指定的地址执行代码；程序体自然包括程序代码和其他程序数据了。如下图：</p><p><img src="824400-20200118160802810-68720977.png" alt="img"></p><p>　　基本的思想就是这样，但具体到实际的话，会有很多细节上的东西，比如如何识别这是个可执行文件，一个程序包含许多节（链接后会划分成段），如何在头部指定这些节或段的具体位置等等。</p><p>　　那么操作系统显然是预先知道这个约定的，但具体怎么规划或实现在各个操作系统都不太一样，我们可以说每个操作系统都有自己的<strong>文件格式</strong>，即自己文件头和文件体的规划。如Window下可执行文件格式为PE，Linux下采用的可执行文件格式是ELF，Mac系统下的可执行文件格式为Mach-O。说个题外话，一开始我还想再Mac系统下做接下来的实验的，不过一路坐下来发现mac系统和linux系统下文件格式有很大的不同，学习成本有点高，不过有兴趣的同学可以试试，接下来说的还是以Linux的文件格式来加载我们的程序。</p><p>　　Linux下的可执行文件格式为ELF，即Executable and Linkable Format，可执行链接格式。与ELF相关的文件类型有三种，是我们需要区分一下的，如下图：</p><p><img src="824400-20200118162412502-1404953017.png" alt="img"></p><p>　　我们将待重定位文件即没有编址好的文件称为<strong>目标文件</strong>，将动态链接库称为<strong>共享目标文件</strong>，将编译链接后的文件称为<strong>可执行文件</strong>。但以ELF规范的命名方式，这三种文件都称之为ELF<strong>目标文件</strong>。为了避免混淆，之后我们说目标文件是这三种类型的文件，不单单指待重定位的文件。</p><h2 id="段和节"><a href="#段和节" class="headerlink" title="段和节"></a>段和节</h2><p>　　之前我们有涉及过段和节的概念，节，之前有说过，就是人为将代码划分成几个模块，便于程序员理解模块的功能，节的声明并不会影响地址的编排。段不是内存的段，而是文件概念上的段，内存里真正运行的是段而不是节，所以ELF有个专门的字段叫程序头表，它描述段的存储信息，以“程序”头表称呼代表<strong>段才是程序真正执行的部分</strong>。节和段又是什么关系呢，在链接器将重定位文件合并为可执行文件时，<strong>多个节最终会合并成段</strong>，虽然节的声明并不会改变地址编排，但节到段的过程可能会改变节中指令的地址，毕竟节不是程序真正执行的部分，下面会结合例子讲讲这个过程。</p><p>　　本书对目标文件的节和段的描述不算太具体，以下结合《深入理解计算机系统》的链接章节进行补充。</p><h3 id="可重定位目标文件"><a href="#可重定位目标文件" class="headerlink" title="可重定位目标文件"></a>可重定位目标文件</h3><p>　　在可重定位目标文件中只有节，没有段，一个典型的ELF可重定位目标文件的结构如下图：</p><p> <img src="824400-20200204001630592-786633630.png" alt="img"></p><p>　　把《深入理解计算机系统》对每个节的描述复制过来 ，让大家看看：</p><blockquote><ul><li>.text：已编译程序的机器代码。</li><li>.rodata：只读数据，比如printf语句中的格式串和开关（switch）语句的跳转表。</li><li>.data：已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss节中。</li><li>.bss：未初始化的全局C变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分初始化和未初始化变量是为了空间效率在：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。</li><li>.symtab：一个符号表（symbol table），它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在.symtab中都有一张符号表。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的表目。</li><li>.rel.text：当链接噐把这个目标文件和其他文件结合时，.text节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。</li><li>.rel.data：被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。</li><li>.debug：一个调试符号表，其有些表目是程序中定义的局部变量和类型定义，有些表目是程序中定义和引用的全局变量，有些是原始的C源文件。只有以-g选项调用编译驱动程序时，才会得到这张表。</li><li>.line：原始C源程序中的行号和.text节中机器指令之间的映射。只有以-g选项调用编译驱动程序时，才会得到这张表。</li><li>.strtab：一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。</li></ul></blockquote><p>　　上面我们不是生成了main.o待重定位目标文件吗，通过readelf工具看看里面有什么节：</p><pre class="line-numbers language-none"><code class="language-none">readelf -S main.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　输出结果如下：</p><p><img src="824400-20200203205517144-440523082.png" alt="img"></p><h3 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h3><p>　　一个典型的ELF可执行文件结构如下图：</p><p><img src="824400-20200204002037999-1168857935.png" alt="img"></p><p> 　此时的可执行文件已经将各个节合并成段了，我们也用readelf工具查看一下kernel.bin段和节的情况。</p><pre class="line-numbers language-none"><code class="language-none">readelf -a kernel.bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　通过上面的命令得到ELF目标文件的全部信息。</p><p><img src="824400-20200204002801921-197427378.png" alt="img"></p><p> 　    通过上图，我们可以发现可执行目标文件只剩下几个section，重定位目标文件里的一些section不见了，分别是.data,.rel.eh_frame,.note.GNU-stack,.bss节。.rel.eh_frame好理解，毕竟只用作重定位，帮助被引用的符号找到正确的地址，而.data,.bss,.note.GNU-stack，个人觉得是因为它们的大小为0，到可执行文件就没必要存在了。</p><p>　　最终可执行文件将节合并为两个段，将.text,.eh_frame合并为一个段LOAD，可以称之为代码段，因为包含.text可执行的代码，还有一个段GNU_STACK不知道是什么用途，而且它大小为0就不管了。还有一些节并没有合并成段，原因是它们并不是程序执行的部分，没必要加载到内存里面，所以看不到有段包含它们。</p><p>　　我们再把注意力放到节和段的编址上，着重看.text和.eh_frame，因为它们最终组成了代码段，我们发现.text和.eh_frame的地址变了，它们的相对距离也变了；在可重定位文件中，.text和.eh_frame是分开的，而在可执行文件中，.text和.eh_frame是紧挨着的，所以合并成段后，段所包含的节地址是连续的。</p><h3 id="相同名称的节也会合并在一起"><a href="#相同名称的节也会合并在一起" class="headerlink" title="相同名称的节也会合并在一起"></a>相同名称的节也会合并在一起</h3><p>　　<strong>具有相同名字的节最终会合并在一起</strong>。</p><p>　　为了帮助理解节最终合并成段的过程，我下面编写一段小代码test.S：</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">section .datadb 0x1,0x2section .textadd esp,4section .datadb 0x3,0x4section .textadd esp,5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　编译该文件：</p><pre class="line-numbers language-none"><code class="language-none">nasm test.S<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　再反汇编生成的文件：</p><pre class="line-numbers language-none"><code class="language-none">ndisasm test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>　　输出如下：</p><p><img src="824400-20200204005503929-678951980.png" alt="img"></p><p> 　由于是直接利用nasm工具将汇编代码转化成可执行代码的，我们并不知道哪些节合并成什么段，但我们可以通过地址去猜测哪些节合并在一起了。</p><p>　　根据上面的输出，所有.data的节合并在一起了，所有.text的节合并在一起了，而且地址是连续的。还有就是.text和.data同时存在时，会把.text优先放到前面，因为按约定俗成的叫法，.text是可执行的部分，汇编器nasm优先把.text放在前面。如果把.text和.data改成.text1和.data1，这样就是用户自己定义的节，结果是.data1会放在前面，所以如果不存在.text和.data这类约定的节，相同名称的节合并成段时会按照这些节之中第一个的位置来编排地址。</p><p>　　至此我们对段和节，以及它们直接的关系都有比较直观的理解了。</p><h2 id="ELF布局"><a href="#ELF布局" class="headerlink" title="ELF布局"></a>ELF布局</h2><p><img src="824400-20200203170935644-1634770123.png" alt="img"></p><p>　　理解完节和段之后，我们再从ELF整个布局理解一下，操作系统是怎么将ELF文件加载到内存里面的。</p><p>　　ELF的布局如上图所示，ELF的布局在链接阶段和运行阶段并不太一样，主要是因为节最终会合并成段，不过我们发现ELF头是共同存在的。</p><h3 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h3><p>　　ELF头部结构如下图，可以去linux系统下/usr/include/elf.h找到这个定义：</p><p><img src="824400-20200204205823729-417070160.png" alt="img"></p><p>　　ELF头的每个成员含义可以在注释里面看到，由于我们需要获取程序段的代码，我们需要把注意力放在和Program header相关的成员上，在后面代码编写上我们主要用到e_phentsize、e_phoff、e_phnum，分别代表程序头表的大小、距离文件开头的偏移、个数。</p><p>　　<img src="824400-20200204210528749-767973833.png" alt="img"> </p><p> 　每个成员的字节大小可以根据上图得到，这有什么作用呢？由于我们获取文件段还是要用汇编代码编写的，所以我们需要知道这些成员距离文件开头的偏移位置，e_phentsize、e_phoff、e_phnum距离文件开头的位置分别为42，28，44。</p><h3 id="程序头表"><a href="#程序头表" class="headerlink" title="程序头表"></a>程序头表</h3><p>　　虽然说了节和段是什么东西，但还没讲程序头表是什么，程序头表是程序头的数组，程序头表的程序头地址是连续的，不是离散的。程序头是什么，程序头是描述段的数据结构。</p><p>　　下面看一下程序头的结构是怎样的。</p><p><img src="824400-20200204211936085-493288989.png" alt="img"></p><p>　　每个成员的含义可以在注释看到，后面我们主要用到p_type、p_filesz、p_offset、p_vaddr，分别代表段的类型、文件内的大小、距离文件开头的偏移、在内存中的地址。</p><p>　　p_type取值与含义如下:</p><p><img src="824400-20200204212415203-1637907878.png" alt="img"></p><h2 id="加载段到内存"><a href="#加载段到内存" class="headerlink" title="加载段到内存"></a>加载段到内存</h2><p>　　综合上面一节，我们可以得出加载段到内存的流程：</p><p>　　①得到程序头的大小</p><p>　　②得到第一个程序头的偏移量</p><p>　　③得到程序头的个数</p><p>　　开始复制段：</p><p>　　④判断段类型是否是忽略，是的话不复制，跳到⑦，否则继续</p><p>　　⑤得到段在文件的偏移量、段的大小、在内存的地址</p><p>　　⑥将段复制到内存里</p><p>　　⑦判断是否全部段都复制好了，不是的话，跳到下一个程序头，跳到④，否则复制完成</p><h2 id="TIPS："><a href="#TIPS：" class="headerlink" title="TIPS："></a>TIPS：</h2><p>​        这里需要注意的是：之后我们的C语言代码需要 使用gcc 4.4进行编译，需要我们去下载gcc 4.4，方法如下：</p><ol><li><p>添加deb源：</p><pre class="line-numbers language-none"><code class="language-none">deb http:&#x2F;&#x2F;dk.archive.ubuntu.com&#x2F;ubuntu&#x2F; trusty main universedeb http:&#x2F;&#x2F;dk.archive.ubuntu.com&#x2F;ubuntu&#x2F; trusty-updates main universe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>先update</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install g++-4.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会出现公匙问题，这里对应的添加即可</p></li></ol><p><img src="image-20231113154953605.png" alt="image-20231113154953605"></p><pre class="line-numbers language-none"><code class="language-none">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3B4FE6ACC0B21F32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        再次更新，一切照常！</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install g++-4.4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        安装结束后，我们需要使用</p><pre class="line-numbers language-none"><code class="language-none">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-11 60 sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-4.4 40 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        来添加gcc切换组</p><p>​        现在，我们只需要：</p><pre class="line-numbers language-none"><code class="language-none">sudo update-alternatives --config gcc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20231113155136331.png" alt="image-20231113155136331"></p><p>​        输入编号就可以自动切换链接了！</p><p><img src="image-20231113155200779.png" alt="image-20231113155200779"></p><p>​        下面我们给上代码，这里，我们的操作系统开始真正的拥有雏形。现在，我们分分区：</p><p>​        将我们先前打磨的boot.inc，loader.S放到位置boot下：</p><p><img src="image-20231113163141761.png" alt="image-20231113163141761"></p><p>​        将我们的main.c放到kernel下：</p><p><img src="image-20231113163215179.png" alt="image-20231113163215179"></p><p>修改一下我们的编译脚本和加载脚本：</p><p>Compile.sh</p><pre class="line-numbers language-none"><code class="language-none">nasm -I boot&#x2F;include&#x2F; boot&#x2F;loader.S -o boot&#x2F;loader.bingcc -m32 -c -o kernel&#x2F;main.o kernel&#x2F;main.cld -m elf_i386 kernel&#x2F;main.o -Ttext 0xc0001500 -e main -o kernel&#x2F;kernel.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Load.sh</p><pre class="line-numbers language-none"><code class="language-none">dd if&#x3D;.&#x2F;boot&#x2F;mbr.bin of&#x3D;a.img count&#x3D;1 bs&#x3D;512 seek&#x3D;0 conv&#x3D;notruncdd if&#x3D;.&#x2F;boot&#x2F;loader.bin of&#x3D;a.img count&#x3D;4 bs&#x3D;512 seek&#x3D;2 conv&#x3D;notruncdd if&#x3D;.&#x2F;kernel&#x2F;kernel.bin of&#x3D;a.img count&#x3D;200 bs&#x3D;512 seek&#x3D;9 conv&#x3D;notruncbochs -f bashsrc.ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们最后看一眼boot.inc</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; --------------------LOADER and KERNEL---------------LOADER_BASE_ADDR            equ 0x900LOADER_START_SECTOR         equ 0x2;---------------------Global Describtor Table---------; 4k set 1 as per sector multiply 4KDESCRIBTOR_G_4K            equ 1000_0000_0000_0000_0000_0000b; set 1 as to indicate the operator is 32bits instead of 16 bitsDESCRIBTOR_D_32            equ  100_0000_0000_0000_0000_0000b; No, not 64 bits but 32!DESCRIBTOR_L               equ   00_0000_0000_0000_0000_0000b; Currently we don&#39;t use the AVL bits, as we don&#39;t have to make it meaningful!DESCRIBTOR_AVL             equ    0_0000_0000_0000_0000_0000b ; the second segments limitations in high 32 bitsDESCRIBTOR_LIMIT_CODE_2    equ      1111_0000_0000_0000_0000b; else for the data if the descriptor indicates the data segDESCRIBTOR_LIMIT_DATA_2    equ      DESCRIBTOR_LIMIT_CODE_2; for Video(显存) one:DESCRIBTOR_LIMIT_VIDEO_2   equ       000_0000_0000_0000_0000b; P for the present, of course it must be present :)DESCRIBTOR_P               equ           1000_0000_0000_0000b; Following macro sets the Privilage Level of the kernelDESCRIBTOR_DPL_0           equ            000_0000_0000_0000bDESCRIBTOR_DPL_1           equ            010_0000_0000_0000bDESCRIBTOR_DPL_2           equ            100_0000_0000_0000bDESCRIBTOR_DPL_3           equ            110_0000_0000_0000b; S stands for the basic type of the descriptor; 1 for the user des, 0 for the system des DESCRIBTOR_S_CODE          equ              1_0000_0000_0000bDESCRIBTOR_S_DATA          equ              DESCRIBTOR_S_CODEDESCRIBTOR_S_SYS           equ              0_0000_0000_0000b; set the type now! remember it is the X C R A for CODE X E W A for data; for code it is executable, not the consistence, unable to read , a is for \; having read, we haven&#39;t read it yet, set 0DESCRIBTOR_TYPE_CODE       equ                1000_0000_0000b; for the data. not executable, extended upper and writableDESCRIBTOR_TYPE_DATA       equ                0010_0000_0000b; make a sum and get the HIGH32bitsDESCRIBTOR_CODE_HIGH4      equ                (0x00 &lt;&lt; 24) + DESCRIBTOR_G_4K + \                                              DESCRIBTOR_D_32 + DESCRIBTOR_L + \                                              DESCRIBTOR_AVL + DESCRIBTOR_LIMIT_CODE_2 + \                                              DESCRIBTOR_P + DESCRIBTOR_DPL_0 + DESCRIBTOR_S_CODE + \                                              DESCRIBTOR_TYPE_CODE + 0x00DESCRIBTOR_DATA_HIGH4      equ                (0x00 &lt;&lt; 24) + DESCRIBTOR_G_4K + \                                              DESCRIBTOR_D_32 + DESCRIBTOR_L + \                                              DESCRIBTOR_AVL + DESCRIBTOR_LIMIT_DATA_2 + \                                              DESCRIBTOR_P + DESCRIBTOR_DPL_0 + DESCRIBTOR_S_CODE + \                                              DESCRIBTOR_TYPE_DATA + 0x00DESCRIBTOR_VIDEO_HIGH4     equ                (0x00 &lt;&lt; 24) + DESCRIBTOR_G_4K + \                                              DESCRIBTOR_D_32 + DESCRIBTOR_L + \                                              DESCRIBTOR_AVL + DESCRIBTOR_LIMIT_VIDEO_2 + \                                              DESCRIBTOR_P + DESCRIBTOR_DPL_0 + DESCRIBTOR_S_CODE + \                                              DESCRIBTOR_TYPE_DATA + 0x0B  ; --------------------------Sector-------------------------RPL0                       equ                00bRPL1                       equ                01bRPL2                       equ                10bRPL3                       equ                11bTI_GDT                     equ                000bTI_LDT                     equ                100b    ; -----------------------Page Table ---------------PAGE_DIR_TABLE_POS         equ                0x1000000; -----------------------Page Table Related AttributePG_P                       equ                1bPG_RW_R                    equ                00bPG_RW_W                    equ                01bPG_US_S                    equ                000bPG_US_U                    equ                100b; -------------------Kernel Related -----------------KERNEL_BIN_SECTOR          equ                0x9KERNEL_BIN_BASE_ADDR       equ                0x70000KERNEL_ENTRY_ADDR          equ                0xc000_1500PT_NULL                    equ                0x0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>(新加的就在最后五行上)</code></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%include &quot;boot.inc&quot;section loader vstart&#x3D;LOADER_BASE_ADDRLOADER_STACK_TOP equ LOADER_BASE_ADDRjmp loader_start; gdt createGDT_BASE:               dd 0x0000_0000                        dd 0x0000_0000CODE_DESCRIPTOR         dd 0x0000_FFFF                        dd DESCRIBTOR_CODE_HIGH4DATA_STACK_DESCRIPTOR:  dd 0x0000_FFFF                        dd DESCRIBTOR_DATA_HIGH4VIDEO_DESCRIPTOR:       dd 0x8000_0007; limit &#x3D; 0xbffff - 0xb8000&#x2F;4K &#x3D; 7; text_mode specific                        dd DESCRIBTOR_VIDEO_HIGH4GDT_SIZE                equ $ - GDT_BASEGDT_LIMIT               equ GDT_SIZE - 1times 60 dq 0; 60 decriptors ;DQ 定义的变量为4字型（8字节）Define Quadra Wordtotal_mem_bytes dd 0 ;保存内存中的总量大小，而我们默认bin vstart &#x3D; 0x900 + 0x200 &#x3D; 0xb00; why 0x200 &#x3D; 512? 60 x 8(discriptor) + 32btye(Current GDT Size: 0 for ununsable, code, video and data)GDT_PTR                 dw GDT_LIMIT; GDT_Reg 48 bits &#x3D;&#x3D; 1 w + 1 dw                        dd GDT_BASE                        ; tol_mem_bytes 4 + gdt_ptr 6 + buf 244 + ards_nr 2 &#x3D; 256ards_buf times 244      db 0 ; Auto Filled the bytesards_nr                 dw 0 ; record the number of ARDSSELECTOR_CODE           equ (0x0001 &lt;&lt; 3) + TI_GDT + RPL0SELECTOR_DATA           equ (0x0002 &lt;&lt; 3) + TI_GDT + RPL0SELECTOR_VIDEO          equ (0x0003 &lt;&lt; 3) + TI_GDT + RPL0; gdt pointerloader_start:; int 15h eax &#x3D; 0000_E820, edx &#x3D; 534D4150h &quot;SMAP&quot; as the signature to checkxor ebx, ebxmov edx, 0x534D4150mov di, ards_buf.e820_mem_get_loop:    mov eax, 0x0000_E820; caller    mov ecx, 20 ;ARDS is 20 bytes    int 0x15 ; call    jc .e820_mem_failed_try_e801 ; cf is 1 to signal the error, jmp to the second method    add di, cx    inc word [ards_nr] ; ards_nr++    cmp ebx, 0 ; is 0 means finish all and ready return    jnz .e820_mem_get_loop    ; find max     mov cx, [ards_nr]    mov ebx, ards_buf    xor edx, edx; clear edx to store the largest.find_max_mem_area:    mov eax, [ebx];base add low    add eax, [ebx + 8];length_low    add ebx, 20; next    cmp edx, eax; we always store largest in edx    jge .next_ards    mov edx, eax.next_ards:    loop .find_max_mem_area    jmp .mem_get_ok; --- E801H --------.e820_mem_failed_try_e801:    mov eax, 0xe801    int 0x15    jc .e801_failed_try_88    mov cx, 0x400    mul cx    shl edx, 16    and eax, 0x0000FFFF    or edx, eax    add edx, 0x10_0000; ax &#x3D; 15MB    mov esi, edx; store    ; 16MB+    xor eax, eax    mov ax, bx    mov ecx, 0x10000 ; 64KB    mul ecx     ; High in edx, low in eax    add esi, eax    mov edx, esi    jmp .mem_get_ok; ----0x88---.e801_failed_try_88:    mov ah, 0x88    int 0x15    jc .error_hlt    and eax, 0x0000_FFFF    mov cx, 0x400; change it to byte     mul cx    shl edx, 16; dx left move to higher place    or edx, eax; then we get dx | ax as 32bits    add edx, 0x100000; add the bonus 1MB.mem_get_ok:    mov [total_mem_bytes], edx; ----------------LOAD_TO_PRESERVED_MODE--------------------------------; Open A20; Load GDT; CR0 set first bet Page Enable 1; ----------------LOAD_TO_PRESERVED_MODE--------------------------------in al, 0x92or al, 0000_0010Bout 0x92, allgdt [GDT_PTR]mov eax, cr0or  eax, 0x0000_00001mov cr0, eaxjmp dword   SELECTOR_CODE:p_mode_start.error_hlt:hlt[bits 32]p_mode_start:    mov ax, SELECTOR_DATA    mov ds, ax    mov es, ax    mov ss, ax    mov esp, LOADER_STACK_TOP    mov eax, KERNEL_BIN_SECTOR    mov ebx, KERNEL_BIN_BASE_ADDR        mov ecx,200    call rd_disk_m_32; -----------PAGE--------------    call setup_page    sgdt [GDT_PTR]    mov ebx, [GDT_PTR + 2]    or dword [ebx + 0x18 + 4], 0xc000_0000    add dword [GDT_PTR + 2], 0xc000_0000    add esp, 0xc0000000    mov eax, PAGE_DIR_TABLE_POS    mov cr3, eax        mov eax, cr0    or eax, 0x8000_0000    mov cr0, eax    mov eax, SELECTOR_VIDEO    mov gs, ax    lgdt [GDT_PTR]    mov byte [gs:160], &#39;V&#39;    jmp SELECTOR_CODE:enter_kernel; ----------------Enter kernelenter_kernel:    call kernel_init    mov esp, 0xc009_f000    jmp KERNEL_ENTRY_ADDR; -------------------setup page table ---------setup_page:    mov ecx, 4096    mov esi, 0.clear_page_dir: ; 先把页表空间清0    mov byte [PAGE_DIR_TABLE_POS + esi], 0    inc esi    loop .clear_page_dir;PDE.create_pde: ; Create Page Directory Entry    mov eax, PAGE_DIR_TABLE_POS    add eax, 0x1000;First PDE&#39;s attr    mov ebx, eax    ; ready for PTE    ; kernel one and usr one    or eax, PG_US_U | PG_RW_W | PG_P    ; init the basic attr    mov [PAGE_DIR_TABLE_POS + 0x0], eax    mov [PAGE_DIR_TABLE_POS + 0xc00], eax ; kernel    sub eax, 0x1000    mov [PAGE_DIR_TABLE_POS + 4092], eax; final one points to itself; create PTE    mov ecx, 256    mov esi, 0    mov edx, PG_US_U | PG_RW_W | PG_P.create_pte:    mov [ebx + esi*4], edx    add edx, 4096    inc esi    loop .create_pte; kernel pte    mov eax, PAGE_DIR_TABLE_POS    mov eax, 0x2000    or eax, PG_US_U | PG_RW_W | PG_P    mov ebx, PAGE_DIR_TABLE_POS    mov ecx, 254    mov esi, 769.create_kernel_pde:    mov [ebx + esi*4], eax    inc esi    add eax, 0x1000    loop .create_kernel_pde    retkernel_init:    xor eax, eax    xor ebx, ebx    xor ecx, ecx    xor edx, edx    mov ebx,[KERNEL_BIN_BASE_ADDR+28]    add ebx,KERNEL_BIN_BASE_ADDR                               ;ebx当前位置为程序段表    mov dx,[KERNEL_BIN_BASE_ADDR+42]         ;获取程序段表每个条目描述符字节大小    mov cx,[KERNEL_BIN_BASE_ADDR+44]                         ;一共有几个段          .get_each_segment:    cmp dword [ebx+0],PT_NULL    je .PTNULL                                                 ;空即跳转即可 不进行mem_cpy        mov eax,[ebx+8]    cmp eax,0xc0001500    jb .PTNULL                push dword [ebx+16]                                        ;ebx+16在存储的数是filesz  可以翻到Loader刚开始                                                                   mov eax,[ebx+4]                                                add eax,KERNEL_BIN_BASE_ADDR    push eax                                                   ;p_offset 在文件中的偏移位置    源位置             push dword [ebx+8]                                         ;目标位置         call mem_cpy    add esp,12                                                 ;把三个参数把栈扔出去 等于恢复栈指针     .PTNULL:    add  ebx,edx                                               ;edx是一个描述符字节大小    loop .get_each_segment                                     ;继续进行外层循环        ret                                        mem_cpy:    cld                                                        ;向高地址自动加数字 cld std 向低地址自动移动    push ebp                                                   ;保存ebp 因为访问的时候通过ebp 良好的编程习惯保存相关寄存器    mov  ebp,esp     push ecx                                                   ;外层循环还要用 必须保存 外层eax存储着还有几个段                                                                   ;分析一下为什么是 8 因为进入的时候又重新push了ebp 所以相对应的都需要+4                                                               ;并且进入函数时 还Push了函数返回地址 所以就那么多了    mov edi,[ebp+8]                                            ;目的指针 edi存储的是目的位置 4+4    mov esi,[ebp+12]                                           ;源指针   源位置             8+4    mov ecx,[ebp+16]                                           ;与Movsb好兄弟 互相搭配      12+4            rep movsb                                                  ;一个一个字节复制           pop ecx     pop ebp    ret;------------------------ rd_disk_m_32 rd_disk_m_32:;1 写入待操作磁盘数;2 写入LBA 低24位寄存器 确认扇区;3 device 寄存器 第4位主次盘 第6位LBA模式 改为1;4 command 写指令;5 读取status状态寄存器 判断是否完成工作;6 完成工作 取出数据  ;;;;;;;;;;;;;;;;;;;;; ;1 写入待操作磁盘数 ;;;;;;;;;;;;;;;;;;;;;    mov esi,eax   ; !!! 备份eax    mov di,cx     ; !!! 备份cx        mov dx,0x1F2  ; 0x1F2为Sector Count 端口号 送到dx寄存器中    mov al,cl     ; !!! 忘了只能由ax al传递数据    out dx,al     ; !!! 这里修改了 原out dx,cl        mov eax,esi   ; !!!袄无! 原来备份是这个用 前面需要ax来传递数据 麻了    ;;;;;;;;;;;;;;;;;;;;;;2 写入LBA 24位寄存器 确认扇区;;;;;;;;;;;;;;;;;;;;;    mov cl,0x8    ; shr 右移8位 把24位给送到 LBA low mid high 寄存器中    mov dx,0x1F3  ; LBA low    out dx,al         mov dx,0x1F4  ; LBA mid    shr eax,cl    ; eax为32位 ax为16位 eax的低位字节 右移8位即8~15    out dx,al        mov dx,0x1F5    shr eax,cl    out dx,al    ;;;;;;;;;;;;;;;;;;;;;;3 device 寄存器 第4位主次盘 第6位LBA模式 改为1;;;;;;;;;;;;;;;;;;;;;           ; 24 25 26 27位 尽管我们知道ax只有2 但还是需要按规矩办事       ; 把除了最后四位的其他位置设置成0    shr eax,cl        and al,0x0f     or al,0xe0   ;!!! 把第四-七位设置成0111 转换为LBA模式    mov dx,0x1F6 ; 参照硬盘控制器端口表 Device     out dx,al;;;;;;;;;;;;;;;;;;;;;;4 向Command写操作 Status和Command一个寄存器;;;;;;;;;;;;;;;;;;;;;    mov dx,0x1F7 ; Status寄存器端口号    mov ax,0x20  ; 0x20是读命令    out dx,al    ;;;;;;;;;;;;;;;;;;;;;;5 向Status查看是否准备好惹 ;;;;;;;;;;;;;;;;;;;;;       ;设置不断读取重复 如果不为1则一直循环  .not_ready:         nop           ; !!! 空跳转指令 在循环中达到延时目的    in al,dx      ; 把寄存器中的信息返还出来    and al,0x88   ; !!! 0100 0100 0x88    cmp al,0x08    jne .not_ready ; !!! jump not equal &#x3D;&#x3D; 0        ;;;;;;;;;;;;;;;;;;;;;;6 读取数据;;;;;;;;;;;;;;;;;;;;;    mov ax,di      ;把 di 储存的cx 取出来    mov dx,256    mul dx        ;与di 与 ax 做乘法 计算一共需要读多少次 方便作循环 低16位放ax 高16位放dx    mov cx,ax      ;loop 与 cx相匹配 cx-- 当cx &#x3D;&#x3D; 0即跳出循环    mov dx,0x1F0 .go_read_loop:    in ax,dx      ;两字节dx 一次读两字    mov [ebx],ax    add ebx,2    loop .go_read_loop    ret ;与call 配对返回原来的位置 跳转到call下一条指令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这里是loader.S,我们上机一跑，没有挂，就是成功了！完事！</p><h1 id="特权"><a href="#特权" class="headerlink" title="特权"></a>特权</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>　　什么是特权？顾名思义，如果特权级别高的，就能拥有更强大的能力，能访问低特权不能访问的数据。操作系统将特权分为四层，分别为0、1、2、3，0是最高特权级别，3是最低特权级别。特权级别为0一般时由操作系统占有，特权级别1、2是由驱动程序和虚拟机占有，而用户程序一般都在特权级别3的级别下，也就是最低特权级别，能拥有的能力是最低的。</p><h2 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h2><p>　　<strong>TSS是一种描述任务状态的数据结构，每一个任务都会有这样的一个结构。为什么要说这个结构，是因为在特权级别转移的时候会用到这个结构，</strong>但TSS不仅仅用于特权级别转移，既然它是描述任务状态的，那它必然也包含任务的其它信息。</p><p>　　那什么是任务呢？在没有操作系统内核的情况下，任务就是进程，一段独立的程序运行起来就是一个任务；但在有操作系统的情况下，任务就不仅仅包括用户的进程了，它还包含内核程序，用户进程处于特权级别3，内核程序处于特权级别0，即一个任务是有可能从特权级别3的用户程序跳到特权级别0的内核程序的，反之亦然，这时候是需要借助TSS完成这个过程的。</p><p>　　先来看看TSS的整体结构：</p><p><img src="824400-20200118194913264-1924072149.png" alt="img"></p><p>　　<strong>我们关注一下TSS结构偏移4到偏移27的三个栈指针，包括ss和esp。一个任务最多有4个栈，每个特权级别会用到一个独立的栈，但并不是每个任务都会有4个栈，因为不是每个特权级别都会用到。为什么每个特权级别的栈是独立的，而不是共用一个栈呢？这是因为如果共用一个栈，容易导致交叉引用引起混乱，并且一个栈也比较容易导致溢出。</strong></p><p>　　那既然至多有4个栈，那为啥TSS只有三个栈指针信息呢？esp0和ss0、esp1和ss1、esp2和ss2分别代表特权级别0、1、2的栈指针信息，唯独没有特权级别3的栈指针。</p><p>　　要理解这个问题，我们首先得知道为什么要用到TSS的这三个栈指针信息。</p><p>　　分两种情况，一种是从低特权级别转移到高特权级别，一种是由高特权级别转移到低特权级别。</p><p>　　①低特权级别转移到高特权级别时，栈也要由低转到高（省略的是特权级别这几个字，下面也是），所以处理器就会在TSS结构里面找到高特权级别的栈信息，并转移到高特权级别的栈上。这种情况下，只需要知道高特权级别的栈信息，所以作为最低特权级别的3的栈信息是不需要在TSS记录的。</p><p>　　②高特权级别转移到低特权级别时，高转低之前一般都有低转高的过程。这种情况下是不会用到TSS的，这是因为低转高时已经将低的栈指针压进高的栈里面了，所以只需要从高的栈里面获取低的栈指针即可返回到低的栈上。</p><p>　　另一个值得注意的点是，低转高时，由于高特权级别下执行指令时不免会对高特权级别的栈进行操作，此时高的esp就会变更，但是TSS里面的esp并不会跟着变更，如果要变更，也只有操作系统直接对TSS操作才会变更。</p><h2 id="当前特权级别"><a href="#当前特权级别" class="headerlink" title="当前特权级别"></a>当前特权级别</h2><p>　　首先，需要明确一点，当前处于什么<strong>特权是相对于处理器而言</strong>的，例如，我们可以说如果处理器在执行内核代码，处理器就处于特权级别0。</p><p>　　其次，需要知道特权下的访问者是谁，<strong>访问者是指令</strong>，对于处理器来说，只有指令是被执行的。</p><p>　　接着，再想想，我们怎样才知道<strong>当前的特权级别等级</strong>（CPL)是什么，在哪里查看，或者说是多少。既然处理器无时无刻不在执行指令，而且指令为访问者，我们用当前执行的指令的特权等级作为当前特权级别等级，但一条指令并不会指定它自己的特权级别，指令肯定是在某个代码段里面，而代码段是有自己的特权级别等级的，所以CPU用<strong>当前执行的代码段</strong>的<strong>特权级别</strong>作为当前特权级别等级。</p><p>　　还记不记得段描述符的结构，不记得的话，看一下下面这图：</p><p><img src="824400-20200118215643800-1777679949.png" alt="img"></p><p>　　段描述符的DPL就是描述某个段的特权级别，每个段都有自己的特权级别。结合上面所说的，当前执行代码段的DPL=CPL。</p><p>　　那么CPL需要有个地方保存，这样子处理器才能知道自己是处在什么特权级别。而这个地方就是选择子，准确来说的选择子中的RPL部分。</p><p>　　选择子在哪里存储的？段寄存器。代码段寄存器是CS，所以CS中的RPL=CPL，我们写作CS.RPL=CPL，综上，<strong>当前代码段DPL=CPL=CS.RPL</strong>。</p><h2 id="一般原则"><a href="#一般原则" class="headerlink" title="一般原则"></a>一般原则</h2><p>　　一般而言，<strong>低特权级别是不能访问高特权级别的资源</strong>，但高特权级别能访问低特权级别的资源。现在看来只有段描述符是有特权级别的，当然后面也有像门结构描述符也有DPL，下面只谈论“段”。</p><p>　　所以我们分别讨论一下代码段和数据段（这里除代码段以外都称为数据段）：</p><p>　　这里以三个例子来讨论一般规则。</p><p>　　①如果受访者是数据段，且特权级别为2，处于哪些特权等级的访问者可以访问？</p><p>　　遵循一般原则，只有高于或等于受访者的特权等级才能访问。所以只有处于特权级别0、1、2的访问才能对数据段进行访问。即<strong>数值上访问者的特权级别小于等于受访者的特权级别</strong>。</p><p>　　②如果受访者是非一致性代码段，且特权级别为2，处于哪些特权级别的访问者可以访问？</p><p>　　首先比受访者特权级别低的访问者肯定是不能直接访问了，这得遵循一般原则。所以我们不能通过jmp或call等指令跳到或调用特权等级较高的代码。</p><p>　　然后比受访者特权级别高的访问者可不可以访问呢？就是访问者能访问比自己特权级别低的代码段吗?不能，书上的解释是：低特权等级能做的事，高特权等级也能做，所以高特权等级没有必要跳到低特权等级里执行，访问者没有必要自降等级去做它本来能做的事情。凡是都有例外，唯一一种从高特权等级跳到低特权等级的情况是：从中断服务程序返回到用户态。</p><p>　　综上只有<strong>平级的访问者才能访问非一致性代码段</strong>，即特权级别为2才能访问。</p><p>　　③如果受访者是一致性代码段，且特权级别为2，处于哪些特权级别的访问者可以访问？</p><p>　　<strong>一致性代码段能让比自己特权级别低的访问者访问</strong>，所以特权级别3，2的访问者可以访问。注意访问者转移到一致性代码段后，转移后的特权级别还是和转移前一样，这是一致性代码段得到特点，一致性代码段不以自己的特权级别等级为主。</p><p>　　特权级别检查发生在访问受访者的一瞬间，之后访问这个受访者段里的内容都不需要再检查了。</p><h2 id="门结构"><a href="#门结构" class="headerlink" title="门结构"></a>门结构</h2><p>　　上面说到低特权级别不能访问高特权级别，但总有一些情况是需要访问到比自己高的特权级别等级，比如需要请求操作系统内核从外设里获取数据。处理器提供了一种”门结构”的机制，<strong>只有通过门结构才能让处理器转移到高特权级别等级</strong>。门结构是在内存里面存储的，所以也是由操作系统设置的，之所以说是处理器的机制，是因为处理器就是这样设计的，操作系统需要遵循处理器的这种机制，来实现门结构的效果，说白了，对于处理器来说，操作系统只是它的应用。</p><p>　　门结构在操作系统有四种：任务门、调用门、中断门、陷阱门。它们像描述段的段描述符那样，门结构都有自己的描述符。那么它们存储在那里呢？任务门描述符存储在GDT,LDT,IDT，IDT是中断描述符表，之后会说。GDT,LDT是全局描述符表和局部描述符表。调用门描述符存储在GDT,LDT。中断门描述符和陷阱们描述符都存储在IDT里面。任务门可以通过call和jmp指令调用，用任务门选择子作为参数。调用门可以通过call和jmp指令调用，用调用门选择子作为参数。中断门通过int指令发出中断。陷阱门通过int3指令发出中断，一般是在编译器调试时用，不做过多关注。</p><p>　　为了下面更好的讲述RPL，这里讲一下调用门，调用门是指定一段程序入口地址的门结构，调用门的结构如下图所示：</p><p>　　<img src="824400-20200208014421667-141989935.png" alt="img"></p><p>　　调用门的结构和段描述符的结构类似，都有P、DPL、S、TYPE，因为调用门需要描述一段程序，所以需要用到调用例程的选择子和偏移量，还有参数个数。</p><h3 id="调用门的执行流程"><a href="#调用门的执行流程" class="headerlink" title="调用门的执行流程"></a>调用门的执行流程</h3><p>　　我们说到调用门是描述一段例程的结构，可以让低特权级别转移到高特权级别等级，那么具体的<strong>使用流程</strong>是怎么样的呢？</p><p>　　具体流程如下：</p><blockquote><p> ①通过call 调用门选择子开始调用。</p><p>②根据选择子的索引在GDT或者LDT里面找到调用门描述符，从调用门描述符里得到了例程所在的段描述符选择子和段内偏移地址。</p><p>③再根据段描述符选择子在GDT或LDT找到该段的基址。</p><p>④将段基址和段内偏移地址相加得到最终的例程 入口地址。</p><p>⑤跳到该入口地址执行。</p></blockquote><p>　　</p><h3 id="调用门的栈的变化"><a href="#调用门的栈的变化" class="headerlink" title="调用门的栈的变化"></a>调用门的栈的变化</h3><p>　　从低特权级别等级转移到高特权级别等级，还涉及栈的转移，上面说了，每个特权级别都有独立的栈，所以<strong>栈也要跟着转移</strong>，那么这个过程是怎样的呢？</p><p>　　流程:</p><p>　　①call调用门选择子之前先压入参数。</p><p>　　②判断例程所在的段的DPL是否和CPL相同，不同则发生特权级别转移。</p><p>　　③若发生特权级别转移，在TSS查找转移后的特权级别的栈指针（包括ss和esp）。处理器临时找个地方保存当前特权级别的栈指针，再转移到新的特权级别的栈。</p><p>　　④在新栈中压入旧的栈指针（③所保存的），再根据调用门中的参数个数，复制低特权级别栈中的参数到新栈。</p><p>　　⑤再压入cs和eip。</p><p>　　若不发生特权级别转移，直接由②跳到⑤。</p><p><img src="824400-20200208022545361-379813095.png" alt="img"></p><p>　　那么执行完之后，如何返回到低特权级别时的状态呢？通过retf指令将ss、esp、cs、ip弹到寄存器里面，从而恢复现场。另外retf的用法是 retf+参数个数，这样子retf指令才知道中间应该跳过多少个参数。</p><h3 id="调用门的特权检查"><a href="#调用门的特权检查" class="headerlink" title="调用门的特权检查"></a>调用门的特权检查</h3><p>　　这里结合使用调用门的流程来讲讲其中的特权级别检查：</p><p>　　①通过call 调用门选择子开始调用。</p><p>　　②根据选择子的索引在GDT或者LDT里面找到调用门描述符，判断CPL数值上是否小于等于调用门描述符的DPL,设为DPL_GATE，即数值上<strong>CPL&lt;=DPL_GATE</strong>。可以看出调用门描述符的DPL是第一道门槛，起码访问者特权级别要高于受访者“门描述符”的特权级别，才能通过特权级别检查，这遵循一般原则。</p><p>　　③从调用门描述符里得到了例程所在的段描述符选择子和段内偏移地址。</p><p>　　④再根据段描述符选择子在GDT或LDT找到该段描述符，通过这个段描述符得到该段的特权级别等级DPL_CODE，<strong>由于门结构的特点</strong>，第二个约束就是数值上<strong>CPL&gt;=DPL_CODE</strong>,就是说转移后的特权等级要高于转移前的特权等级。</p><p>　　④将段描述符的段基址和调用门的段内偏移地址相加得到最终的例程 入口地址。</p><p>　　⑤跳到该入口地址执行。</p><p>　　综上数值上<strong>DPL_CODE&lt;=CPL&lt;=DPL_GATE。</strong></p><h2 id="RPL"><a href="#RPL" class="headerlink" title="RPL"></a>RPL</h2><p>　　根据上面谈及的一般原则，当访问者访问受访者时，访问者的特权级别数值上要小于等于受访者的特权级别DPL，所以CPL&lt;=DPL。</p><p>　　这里将访问者看作当前执行的指令，所以访问者的特权级别等级时CPL。</p><p>　　如果我们单纯靠CPL和DPL来进行特权级别检查的话会有什么问题呢？</p><p>　　考虑这样一种情况，用户程序想获取外设里的数据，比如通过网卡获取的网络数据，用户程序不能直接对外设进行访问，所以只能通过操作系统内核来获取。寻求内核的帮助需要用到门结构，因为涉及到特权级别的转移，这里假设用户是通过调用门转移到内核。用户程序向内核提交了一个缓冲区的选择子，缓冲区的段内偏移地址，写入数据大小三个参数。</p><p>　　用户提交参数后，并且通过了DPL_CODE&lt;=CPL&lt;=DPL_GATE的校验，转移到内核去执行调用门指向的例程，这时候CPL为0，处理器拥有最高的权限，可以对内存里的任何地方进行读写，用户提交缓冲区的选择子指向用户态下的数据段，此数据段DPL为3，由于CPL&lt;=DPL，所以处理器能够通过特权校验并对缓冲区写入。</p><p>　　那么再想想，如果用户通过某种途径知道了内核环境下的数据段，并且提交了一个指向内核缓冲区的选择子，试图破坏内核环境，结果会怎么样？</p><p>　　由于此时处理器处于最高特权级CPL=0，内核缓冲区的DPL=0，即CPL&lt;=DPL校验通过，所以处理器也是能对内核缓冲区进行读写操作，所以可能造成了破环内核环境的后果，这就很可怕了。</p><p>　　<img src="824400-20200209010950513-1768645648.png" alt="img"></p><p> 　出现这问题的原因是显然易见的。内核并不知道请求资源者的真正的能力是多少，当通过调用门转移到内核的时候，特权级别已经是最高了，内核成为了请求资源者的代理，能够对任何缓冲区进行读写，对于缓冲区来说，它认为访问者是内核，特权检查必定能通过，所以缓冲区肯定会放任内核去对自己进行操作。但实际上缓冲区的真正请求者是用户程序而不是内核。所以我们有必要让受访者知道真正请求资源的是谁。</p><p>　　RPL出现了。由于需要通过选择子去索引段描述符，RPL放在选择子再合适不过。</p><p>　　RPL代表选择子请求资源的能力，还记得选择子的结构吗，RPL就是在这里用到的。</p><p><img src="824400-20200209020303710-1519809110.png" alt="img"></p><h3 id="一般原则补充"><a href="#一般原则补充" class="headerlink" title="一般原则补充"></a>一般原则补充</h3><p>　　其实特权级别校验不单单有DPL和CPL的参与，还有RPL的参与，这里对上面说到的一般原则进行补充。</p><p>　　①如果受访者是数据段，特权级别需要满足：数值上数据段的DPL大于等于CPL和数据段选择子的RPL，即CPL&lt;=DPL且RPL&lt;=DPL。</p><p>　　②如果受访者是非一致性代码段，特权级别需要满足：数值上代码段的DPL等于CPL等于代码段选择子的RPL，即CPL=DPL=RPL。</p><p>　　③如果受访者是一致性代码段你，特权级别需要满足：数值上代码段的DPL小于等于CPL和RPL，即CPL&gt;=DPL且RPL&gt;=DPL。</p><h3 id="调用门特权检查补充"><a href="#调用门特权检查补充" class="headerlink" title="调用门特权检查补充"></a>调用门特权检查补充</h3><p>　　RPL同样需要在使用调用门时参与校验。</p><p>　　在访问调用门描述符时，需要指定调用门选择子，选择子的RPL要数值上小于等于门描述符的DPL_GATE，即RPL&lt;=DPL_GATE，同样需要CPL&lt;=DPL_GATE，之前讨论的。</p><p>　　在调用调用门指向的例程之前，门描述符选择子的RPL不需要参与校验，因为它只是用来索引门描述符，所以只需CPL&gt;=DPL_CODE。</p><h3 id="RPL防止越权读写资源"><a href="#RPL防止越权读写资源" class="headerlink" title="RPL防止越权读写资源"></a>RPL防止越权读写资源</h3><p>　　再回到刚才那个问题，操作系统是怎么利用RPL防止用户破坏内核环境的或者偷偷获取到内核数据的。<strong>用户通过调用门转移到内核服务程序执行，内核服务程序会将用户提交的选择子里的RPL变更为用户进程的CPL</strong>，这就防止了这个问题的出现。</p><p>　　假设用户伪造了一个RPL为0的选择子，并且这个选择子指向的时内核数据段。在执行内核服务程序时，这个选择子RPL被改成了3，此时CPL=0，RPL指向的数据段DPL=0，通过上面的讨论，得出虽然CPL&lt;=DPL，但是RPL&lt;=DPL并不满足，所以特权校验并不通过，自然就不会写进内核缓冲区了。</p><h3 id="几种情况"><a href="#几种情况" class="headerlink" title="几种情况"></a>几种情况</h3><p>　　在这里再讨论三种情况。</p><p>　　①不通过调用门，描述一下处于特权级别为3的用户程序向当前特权级别的缓冲区里写数据时，DPL、RPL、CPL的校验过程：</p><p>　　用户程序执行时CPL=3，缓冲区选择子RPL=3，缓冲区数据段DPL=3，CPL=RPL=DPL，校验通过。</p><p>　　②不通过调用门，描述一下处于特权级别3的用户程序尝试写入特权级别0的缓冲区中，DPL、RPL、CPL的校验过程：</p><p>　　用户程序执行时CPL=3，缓冲去选择子RPL=3，缓冲区数据段DPL=0，CPL&gt;DPL、RPL&gt;DPL，都不通过校验，特权检查失败。</p><p>　　③通过调用门，用户程序想获取外设里的数据，用户程序向内核提交了缓冲区的选择子，缓冲区的段内偏移地址，写入数据大小三个参数，DPL、RPL、CPL的校验过程：</p><p>　　这情况是对上面讨论的总结。</p><p>　　首先用户程序当前CPL=3，提交的缓冲区选择子RPL=3，指向的缓冲区所在数据段的DPL=3。</p><p>　　用户程序指定了一个调用门选择子，其RPL=3，调用门描述符的DPL_GATE=3（如果这里为2或2以下就通过不了校验了，所以一定为3），RPL&lt;=DPL_GATE且CPL&lt;=DPL_GATE，通过调用门描述符的特权检查。</p><p>　　再检查是否能转移到内核服务程序中，内核服务程序的DPL=0，所以CPL=3&gt;=DPL，通过校验，跳到内核服务程序执行。</p><p>　　内核服务程序获取外设数据后需要对缓冲区进行写入，此时CPL=0，缓冲区选择子RPL=3,缓冲区所在数据段DPL=3，所以CPL&lt;=DPL且RPL&lt;=DPL，通过校验，能对缓冲区进行写入。</p><p>　　如果用户伪造了一个缓冲区选择子RPL=0且指向的缓冲区所在的数据段DPL=0，会怎么样。</p><p>　　内核服务程序会将这个选择子的RPL改为3，虽然CPL&lt;=DPL但RPL&gt;DPL，所以校验不通过，不能对缓冲区进行写入，入侵失败。</p><h2 id="访问外设"><a href="#访问外设" class="headerlink" title="访问外设"></a>访问外设</h2><p>　　以下为补充内容，体现特权在IO和指令的限制。</p><h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>　　特权级不仅仅体现在对数据和代码的访问，而且体现在对指令的限制。</p><p>　　有一些指令只能在特权级别为0时才能执行，这类指令叫特权指令，如lgdt、lidt、ltr、popf等，这些指令涉及到对内存的管理、中断等等，不应该由用户程序操作，处理器也只信任操作系统，所以放在特权级别为0下运行也十分合理。</p><p>　　还有一些指令是需要受到IOPL限制，这些指令是IO读写指令，如in、out、cli、sti，也被称为IO敏感指令。只有在当前特权级别大于等于IOPL才能执行IO指令。</p><h3 id="IOPL"><a href="#IOPL" class="headerlink" title="IOPL"></a>IOPL</h3><p>　　还记得eflags的结构吗：</p><p><img src="824400-20200210014103158-2117903684.png" alt="img"></p><p> 　IOPL是IO特权级，是用来限制访问IO指令的最低特权级别。每个任务都有eflags寄存器，所以每个任务都会有自己的IOPL。</p><p>　　除此之外IOPL还可以用来决定任务是否能够访问所有外设端口。当数值上CPL&lt;=IOPL时，任务能够访问所有外设端口，那么当CPL&gt;IOPL时是不是就不能访问外设端口呢？不是，处理器允许部分IO端口被任务访问，哪些端口允许访问是IO位图决定的。所以IOPL有点像防火墙，首先禁止所有访问，再打开想开放的端口。</p><p>　　像处于特权级别0的操作系统和处于特权级别1的驱动程序就能对所有端口进行访问。驱动程序就是通过in、out对硬件直接访问的程序。</p><p>　　那么像任务处于特权级别2和3的话，虽然操作系统不允许开放所有端口，但还是允许部分端口对任务开放，只要通过IO位图做好限制即可。</p><p>　　为什么处理器允许特权级别1、2、3能够对IO进行直接操作呢，原因是如果所有IO操作都通过内核的话，上下文切换的开销会有点大，这样做主要是为了提速。</p><h3 id="IO位图"><a href="#IO位图" class="headerlink" title="IO位图"></a>IO位图</h3><p>　　什么是位图，位图就是用位映射到某些资源上，IO位图就是由一个位映射到一个端口，如果这个位是1，则端口关闭，如果是0，代表端口打开。</p><p>　　IO位图存储在TSS里面：</p><p><img src="824400-20200210024600729-1509475103.png" alt="img"></p><p>　　TSS的前104个字节的结构是固定的，不固定的是IO位图的起始位置。怎么找到IO位图的起始位置呢？TSS中偏移102字节的地方就是保存着IO位图在TSS的偏移地址，占2个字节。IO位图的偏移地址取值范围是104~TSS段界限limit之间，如果偏移地址不再这个范围，即大于等于TSS段界限limit，则代表没有IO位图。IO位图起始一个位代表第0个端口，以此类推。Intel处理器最大支持65536个端口，所以位图大小65536/8=8192个字节。IO位图如果存在且映射所有端口，TSS的大小为IO位图偏移地址+8192+1，1代表TSS最后的0xff，下面会解释，如果IO位图不存在，TSS大小为104。</p><p>　　那么为什么最后有个0xFF呢？</p><p>　　每个端口只能读写一个字节的数据，但IO指令是可以都多个端口进行读写，如果对一个端口进行连续读写，那相当于以该端口号为起始的多个端口一并读写进来，如in ax, 0x234，in可以读取16位端口数据，即两个字节，假设0x234是16位端口，in ax,0x234就相当于in al,0x234和in ah, 0x235两个指令。</p><p>　　所以一个指令是有可能会读取多个端口的，处理器会在IO位图检查这些端口是否都打开了，连续的bit会有可能跨字节，比如0x234端口在一个字节的最后一位，0x235端口在一个字节的首位，处理器需要将两个字节都都进来。大部分情况跨字节检查不会有问题，但是如果这发生在IO位图的最后一个字节的话，读取两个字节，第二个字节就会越界。</p><p>　　因此0xff会有两个作用：</p><p>　　①处理器允许IO位图不映射所有端口，但要保证最后一个字节位0xff。假设映射到0-23的端口，我读取23端口，且读取两个字节的数据，即会读取两个端口23、24,那么0xff就表明24端口关闭，这样既不会越界，也不会不合理，因为没有映射到的端口就是关闭了；0xff即代表24-31号端口关闭，也防止越界，当然防止越界才是真正的目的，前者只是合理化的结果。</p><p>　　②如果IO位图映射所有端口，那么0xff就不代表任何端口，它就是作为位图的边界标记，防止越界。</p><h1 id="函数调用与操作显卡"><a href="#函数调用与操作显卡" class="headerlink" title="函数调用与操作显卡"></a>函数调用与操作显卡</h1><h2 id="函数的调用约定"><a href="#函数的调用约定" class="headerlink" title="函数的调用约定"></a>函数的调用约定</h2><p>​        我们下面看看函数的调用约定问题。我们现在知道，函数调用在汇编层面就是先设置好寄存器的参数值之后压栈后调用函数，那么，压栈的过程中是怎么压栈的，需要我们思考。方法很多，这就延申出来下表了：</p><h4 id="①：cdecl"><a href="#①：cdecl" class="headerlink" title="①：cdecl"></a>①：cdecl</h4><p>参数从右往左依次压入栈中，由调用方负责弹出栈上的参数。这个约定与C语言的原型声明相一致，并且多用于可变参数函数的定义，比如 printf 函数。</p><h4 id="②：stdcall"><a href="#②：stdcall" class="headerlink" title="②：stdcall"></a>②：stdcall</h4><p>参数从右往左依次压入栈中，由被调用函数负责清理栈上的参数。这个约定多用于 Windows 操作系统中的 WinAPI 函数定义和调用。stdcall 可以减少程序的大小并且使得代码更容易优化。</p><h4 id="③：fastcall"><a href="#③：fastcall" class="headerlink" title="③：fastcall"></a>③：fastcall</h4><p>该约定可以支持寄存器传递参数来加快调用速度，通常前两个参数会被放置到寄存器 ecx 和 edx 中，其他参数依然按顺序入栈。由于寄存器有限，fastcall 只适用于参数少于三个的函数。</p><p>​        C语言遵循的是cdecl。</p><h2 id="C与汇编混合编程"><a href="#C与汇编混合编程" class="headerlink" title="C与汇编混合编程"></a>C与汇编混合编程</h2><p>​        我们先看库函数和系统调用，都知道库函数是对系统调用的一个封装。实际上，我们是预先指定好系统中断需要的值，放在寄存器中，然后发起中断（0x80）。需要的值就有需要请求的系统调用的中断号，比如说可以看看我们write函数的系统调用</p><p><img src="image-20231117133338746.png" alt="image-20231117133338746"></p><p>​        当然这是64位的，我们书写32位程序使用的是：</p><p><img src="image-20231117133515703.png" alt="image-20231117133515703"></p><p>​        我们这样就可以看看如何实现汇编使用系统调用了：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">section .dataSTR_C_LIB: db &quot;c lib says: hello world!&quot;, 0xaSTR_C_LIB_LEN equ $ - STR_C_LIBSTR_SYSCALL: db &quot;syscall says: hello world!&quot;, 0xaSTR_SYSCALL_LEN equ $ - STR_SYSCALLsection .textglobal _start_start:; ------- C Like Caller -------------    push STR_C_LIB_LEN    push STR_C_LIB    push 1    call simu_write    add esp, 12; use syscall directly    mov eax, 4 ; write&#39;s syscall num is 4    mov ebx, 1    mov ecx, STR_SYSCALL    mov edx, STR_SYSCALL_LEN    int 0x80;;;-----Exit then    mov eax, 1; 0x80 of 1 is exit    int 0x80simu_write:    push ebp    mov ebp, esp    mov eax, 4    mov ebx, [ebp + 8]    mov ecx, [ebp + 12]    mov edx, [ebp + 16]    int 0x80    pop ebp    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        两种方式，第一种就是C-like的参数压栈后调用，第二种就是直接干系统调用。</p><pre class="line-numbers language-none"><code class="language-none">nasm -f elf system_call.S -o system_call.old -m elf_i386 -o system_call.bin system_call.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20231117133737798.png" alt="image-20231117133737798"></p><h4 id="显卡的端口控制"><a href="#显卡的端口控制" class="headerlink" title="显卡的端口控制"></a>显卡的端口控制</h4><p>显卡寄存器：</p><p><img src="cb819dcc51a54f17ab5a70b68048de3a.png" alt="在这里插入图片描述"></p><p>显卡端口非常多，但是<a href="https://so.csdn.net/so/search?q=计算机系统&amp;spm=1001.2101.3001.7020">计算机系统</a>提供的寄存器寻址范围很少，只有0~65535个</p><p>所以显卡硬件也使用数据结构的方式来提供寄存器的访问，如图，上面4个寄存器被分为了2组，Address 寄存器和 Data 寄存器，前者存储寄存器组的索引，后者是该索引对应的寄存器</p><p>这里主要用到的寄存器组是<a href="https://so.csdn.net/so/search?q=CRT&amp;spm=1001.2101.3001.7020">CRT</a> Controller Register，这里的端口地址取决于 Miscellaneous Output Register 寄存器中的 Input/Output Address Select 字段。</p><p><img src="49f1dc33fc6244bea880989b37347c4c.png" alt="在这里插入图片描述"></p><p>默认情况下， Miscellaneous Output Register寄存器的值为0x67, 其他字段不管， 咱们只关注这最重要的I/OAS位， 其值为1。 也就是说：</p><ul><li>CRT controller寄存器组的Address Register的端口地址为0x3D4，Data Register的端口地址0x3D5。</li><li>Input Status # l Register寄存器的端口地址被设置为0x3DA。</li><li>Feature Control register寄存器的写端口是0x3DA。</li></ul><p>由于这里涉及到的显卡操作只用到了CRT Controller Registers分组中的寄存器，其他的就不管了:</p><p><img src="7e4ab05e900a486e80b79f4e21ddf6bf.png" alt="在这里插入图片描述"></p><p>这里的 <code>0x0e</code>和<code>0x0f</code>存储的是光标位置的高、低8位。</p><p>​        我们熟知自己要干啥之后，就可以开始写代码：</p><h3 id="实现打印函数"><a href="#实现打印函数" class="headerlink" title="实现打印函数"></a>实现打印函数</h3><p>​        首先定义标准类型：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; IN .&#x2F;lib&#x2F;stdint.h#ifndef __LIB_STDINT_H#define __LIB_STDINT_Htypedef signed char             int8_ttypedef signed short int        int16_ttypedef signed int              int32_ttypedef signed long long        int64_ttypedef unsigned char           uint8_ttypedef unsigned short int      uint16_ttypedef unsigned int            uint32_ttypedef unsigned long long      uint64_t#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">TI_GDT          equ         0RPL0            equ         0SELECTOR_VIDEO  equ         (0x0003 &lt;&lt; 3) + TI_GDT + RPL0section .dataput_int_buffer dq 0[bits 32]section .text;--------------------put_char------------------;   put char into the screen; --------------------------------------------global put_charput_char:    pushad    mov ax, SELECTOR_VIDEO    mov gs, ax; --- get cur cursor pos LOW--    mov dx, 0x03d4 # 端口在    mov al, 0x0e # 看CRT表得到    out dx, al    mov dx, 0x03d5    in al, dx    mov ah, al; --- get cur cursor pos HIGH--    mov dx, 0x03d4    mov al, 0x0f    out dx, al    mov dx, 0x03d5    in al, dx    mov bx, ax    mov ecx, [esp + 36]; pushad add 32 bits and then the ret addr is 36    cmp cl, 0xd    jz .is_carriage_return    cmp cl, 0xa    jz .is_line_feed    cmp cl, 0x8    jz .is_backspace    jmp .put_other.is_backspace:    dec bx  ; 回退一位    shl bx, 1; *2 ;    mov byte [gs:bx], 0x20 ;space    inc bx    mov byte [gs:bx], 0x07 ;space    shr bx, 1; &#x2F;2    jmp .set_cursor.put_other:    shl bx, 1    mov [gs:bx], cl;写进字符本身    inc bx    mov byte [gs:bx], 0x07 ;设置属性    shr bx, 1; &#x2F;2    inc bx    cmp bx, 2000 ; check if we need to set the cursor    jl  .set_cursor.is_line_feed:.is_carriage_return:    xor dx, dx    mov ax, bx    mov si, 80    div si    sub bx, dx.is_carriage_return_end:    add bx, 80    cmp bx, 2000 ;比较是否换行.is_line_feed_end:    jl .set_cursor.roll_screen:    cld    mov ecx, 960    mov esi, 0xc00b80a0    mov edi, 0xc00b8000    rep movsd    mov ebx, 3840    mov ecx, 80.cls:    mov word [gs:ebx], 0x0720    add ebx, 2    loop .cls    mov ebx, 1920.set_cursor:; HIGH 8    mov dx, 0x03d4    mov al, 0x0e    out dx, al    mov dx, 0x03d5    mov al, bh    out dx, al; LOW 8    mov dx, 0x03d4    mov al, 0x0f    out dx, al    mov dx, 0x03d5    mov al, bl    out dx, al.put_char_done:    popad    ret    ; ------------------------------; Put String into the screen; ------------------------------global put_strput_str:push ebxpush ecxxor ecx, ecxmov ebx, [esp + 12].goon:mov cl, [ebx]cmp cl, 0jz .str_overpush ecxcall put_charadd esp, 4inc ebxjmp .goon.str_over:pop ecxpop ebxretglobal put_int; ------------------------------; Put uint8 into the screen; ------------------------------put_int:pushadmov ebp, espmov eax, [ebp + 4*9]mov edx, eaxmov edi, 7mov ecx, 8mov ebx, put_int_buffer.16based_4bits:and edx, 0x0000_000Fcmp edx, 9jg .is_A2Fadd edx, &#39;0&#39;jmp .store.is_A2F:sub edx, 10add edx, &#39;A&#39;.store:mov [ebx, edi], dldec edishr eax, 4mov edx, eaxloop .16based_4bits.ready_to_print:inc edi.skip_prefix_0:cmp edi, 8je .full0.go_on_skip:mov cl, [put_int_buffer + edi]inc edicmp cl, &#39;0&#39;je .skip_prefix_0dec edijmp .put_each_num.full0:mov cl, &#39;0&#39;.put_each_num:push ecxcall put_charadd esp, 4inc edimov cl, [put_int_buffer + edi]cmp edi, 8jl .put_each_numpopadret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        建一个头文件：</p><pre class="line-numbers language-none"><code class="language-none">#ifndef __LIB_KERNEL_PRINT_H#define __LIB_KERNEL_PRINT_H#include&quot;stdint.h&quot;void put_char(uint8_t char_asci);void put_str(char* message);void put_int(uint32_t num);#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们在main函数下写道：</p><pre class="line-numbers language-none"><code class="language-none">#include&quot;print.h&quot;int main(void)&#123;put_str(&quot;\n\n\n\n\n\n\n&quot;);put_char(&#39;k&#39;);put_char(&#39;e&#39;);put_char(&#39;r&#39;);put_char(&#39;n&#39;);put_char(&#39;e&#39;);put_char(&#39;l&#39;);put_char(&#39;\n&#39;);put_char(&#39;1&#39;);put_char(&#39;2&#39;);put_char(&#39;\b&#39;);put_char(&#39;3&#39;);put_char(&#39;\n&#39;);put_str(&quot;Hello from CCSTDC_Kernel!\n&quot;);put_int(0x12345678);put_char(&#39;\n&#39;);while(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">├── a.img├── AutoRun.sh├── bashsrc.ab├── boot│   ├── include│   │   └── boot.inc│   ├── loader.bin│   ├── loader.S│   └── mbr.bin├── Compile.sh├── kernel│   ├── kernel.bin│   ├── main.c│   └── main.o├── lib│   ├── kernel│   │   ├── myprint.S│   │   ├── print.h│   │   └── print.o│   └── stdint.h└── Load.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是我们现在的结构图</p><p>​        编译：</p><pre class="line-numbers language-none"><code class="language-none">nasm -f elf .&#x2F;lib&#x2F;kernel&#x2F;myprint.S -o .&#x2F;lib&#x2F;kernel&#x2F;print.ogcc -m32 -I .&#x2F;lib&#x2F;kernel&#x2F; -c -o .&#x2F;kernel&#x2F;main.o .&#x2F;kernel&#x2F;main.cld -m elf_i386 .&#x2F;kernel&#x2F;main.o .&#x2F;lib&#x2F;kernel&#x2F;print.o  -Ttext 0xc0001500 -e main -o .&#x2F;kernel&#x2F;kernel.bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        加载：</p><pre class="line-numbers language-none"><code class="language-none">dd if&#x3D;.&#x2F;boot&#x2F;mbr.bin of&#x3D;a.img count&#x3D;1 bs&#x3D;512 seek&#x3D;0 conv&#x3D;notruncdd if&#x3D;.&#x2F;boot&#x2F;loader.bin of&#x3D;a.img count&#x3D;4 bs&#x3D;512 seek&#x3D;2 conv&#x3D;notruncdd if&#x3D;.&#x2F;kernel&#x2F;kernel.bin of&#x3D;a.img count&#x3D;200 bs&#x3D;512 seek&#x3D;9 conv&#x3D;notruncbochs -f bashsrc.ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20231117135419238.png" alt="image-20231117135419238"></p><p>​        执行结果就是这样。</p><h2 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h2><p>1.基本内联汇编的格式</p><pre class="line-numbers language-none"><code class="language-none">asm [volatile](&quot; code&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>采用；作为代码的<a href="https://so.csdn.net/so/search?q=分隔符&amp;spm=1001.2101.3001.7020">分隔符</a>，如果·一行写不下采用\继续下一行。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hJVF96aGFubXVzaQ==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>2.扩展内联汇编<br><img src="20200118120206131.png" alt="在这里插入图片描述"><br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hJVF96aGFubXVzaQ==,size_16,color_FFFFFF,t_70-1700200561533-7.png" alt="在这里插入图片描述"></p><p>例子：扩展内联汇编</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> add_1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>add_2<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> answer<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">"addl  %%ebx,%%eax"</span><span class="token operator">:</span><span class="token string">"=a"</span><span class="token punctuation">(</span>answer<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"a"</span><span class="token punctuation">(</span>add_1<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">(</span>add_2<span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>answer<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span>  <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到对于寄存器采用了两个%%来表示。此外扩展内联汇编还提供了占位符来方便表示。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hJVF96aGFubXVzaQ==,size_16,color_FFFFFF,t_70-1700200561533-8.png" alt="在这里插入图片描述"><br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hJVF96aGFubXVzaQ==,size_16,color_FFFFFF,t_70-1700200561533-9.png" alt="在这里插入图片描述"></p><h1 id="中断IDT"><a href="#中断IDT" class="headerlink" title="中断IDT"></a>中断IDT</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>​        我们这从来看看怎么玩中断表。可以理解为：</p><blockquote><p>操作系统完成初始化工作之后就开始hold住，靠中断来为上层服务。</p></blockquote><h2 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h2><p>​        分为外部中断和内部中断。</p><h3 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h3><p>​        从外面来的中断，一般是一个硬件给出的中断，比如说我们将要使用的8259A，他会给CPU一个信号——有中断了，处理一下。这个中断发出的引脚是INTR，表示的是非致命的中断，而从NMI引脚出来的信号表示的是致命错误，这些中断往往不可屏蔽，因为它表明系统要挂了。</p><h3 id="内部中断"><a href="#内部中断" class="headerlink" title="内部中断"></a>内部中断</h3><p>​        也就是我们系统软件发起的中断，int 0x啥的就是内部终端，我们就是让系统先保护现场，然后处理中断，然后恢复现场。就是这样的简单。</p><p><img src="72f97511543007fbd58c7fa2c12ee486.png" alt="img"></p><p>​        可以看到，有些中断还是会压入错误码，这就需要我们后续的处理中需要整一下活。</p><h2 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h2><h3 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h3><p><strong>什么是中断描述符表？</strong></p><p>中断描述符表是保护模式下用于存储中断处理程序的数据结构。CPU在接收到中断时，会根据中断向量在中断描述符表中检索对应的描述符。</p><p><strong>中断描述符表中的描述符有哪些类型？</strong></p><p>中断描述表中的主要包含以下类型：</p><ul><li>任务门描述符</li><li>中断门描述符</li><li>陷阱门描述符</li><li>调用门描述符</li></ul><p>任务门描述符结构如下：</p><p><img src="v2-f46a29f9c121c759ef92ad6f9a7e6c08_1440w.webp" alt="img"></p><p>任务门需要和任务状态段（TSS）配合使用，这是Intel处理器在硬件一级提供的任务切换机制。任务门可以存在于全局描述符GDT、局部描述符表LDT以及中断描述符表IDT中。</p><p>中断门描述符结构如下：</p><p><img src="v2-89adf50dea83e693455f17924b3d79d6_1440w.webp" alt="img"></p><p>中断门包含中断处理程序所在的段选择子和段内偏移地址，当通过此方式进入中断后，标志寄存器eflags中的IF位自动置0，表示把中断关闭，避免中断嵌套。中断们只存在于中断描述符表IDT。</p><p>陷阱门描述符结构如下：</p><p><img src="v2-48110ae5584bcfebfa6074689775f31b_1440w.webp" alt="img"></p><p>通过陷阱门进入中断，标志寄存器eflags的IF位不会自动置0，陷阱门只允许存在于IDT中。</p><p>调用门描述符结构如下：</p><p><img src="v2-2d1870b91b85a80b44b78949a9f9c030_1440w.webp" alt="img"></p><p>调用门是用户进程用来进入0特权级的方式，其DPL为3。调用门可以在GDT和IDT中存在的，只能使用call和jmp指令调用。</p><p><strong>中断描述符表存储的位置不固定。</strong></p><h3 id="中断描述符寄存器"><a href="#中断描述符寄存器" class="headerlink" title="中断描述符寄存器"></a>中断描述符寄存器</h3><p><strong>如何找到中断描述符表？</strong></p><p>CPU内部有个中断描述符寄存器IDTR，该寄存器的结构图如下图：</p><p><img src="v2-5935f6a7b2c03a6c2f8fe8332eff0ced_1440w.webp" alt="img"></p><p>第0~15位是表界限，即IDT减1，可容纳8192个中段描述符；第16~47位时IDT的基地址。</p><p>通过<strong>lidt 48位内存数据</strong>指令便可将中断描述符表的信息加载到IDTR寄存器中。</p><h3 id="中断细节"><a href="#中断细节" class="headerlink" title="中断细节"></a>中断细节</h3><p><strong>中断处理过程包含哪两部分？</strong></p><p>CPU外部：外部设备的中断由中断代理芯片接收，处理后将该中断的中断向量号发送给CPU</p><p>CPU内部：CPU执行该中断向量号的中断处理程序</p><p><strong>如何在中断描述表中定位中断描述符？</strong></p><p>每个中断描述符号占用8字节，所以使用中断向量号与8相乘，相当于得到偏移地址，然后从IDTR寄存器中取出中断描述符表的基址，将两个地址相加，便能定位到中断描述符的地址。</p><p><strong>中断门处理器如何进行特权级检查？</strong></p><p>对于内部中断来说，要求检查当前特权级CPL和中断门描述符DPL及门描述符对应的的代码段的DPL，在数值上满足以下关系：</p><p>目标代码段DPL &lt; 当前特权级CPL &lt; 门描述符DPL</p><p>对于外部中断，检查当前特权级CPL和目标代码段的DPL，在数值上满足以下关系：</p><p>目标代码段DPL &lt; 当前特权级CPL</p><p><strong>如何执行中断处理程序？</strong></p><p>将门描述符中的目标代码段描述符选择子加载到代码段寄存器CS中，把门描述中中断处理程序的偏移地址加载到EIP，便开始执行中断程序。</p><p><strong>如何确定使用新栈还是旧栈？</strong></p><p>程序的运行需要栈，由于不同的特权级需要使用不同的栈，因此当涉及到特权级变化后，便需要开启新栈。</p><p><strong>使用新栈时需要压入哪些信息？</strong></p><ul><li>旧栈环境下SS和ESP的值</li><li>标志寄存器EFLAGS的值</li><li>备份CS和EIP的值</li><li>ERROR_CODE中断错误码</li></ul><p>特权级不发生变化时，不需要压入旧栈环境下SS和ESP的值。</p><p>中断处理程序执行完成以后执行返回指令时，CPU会将上述值从栈中弹出，但是ERROR_CODE需要我们手动弹出。</p><p><strong>为什么要保存CS和EIP的值？</strong></p><p>当我们中断处理程序在返回时，检查备份的CS选择子，根据其RPL和DPL做特权级检查，如果通过，则需要更新寄存器CS和EIP，这样才可以恢复到中断之前的代码段。</p><p>该特权级检查的结果还决定了是否需要恢复SS和ESP的值，如果特权级没有发生变化，不需要恢复，因为中断处理程序和我们的应用程序是同一个栈，否则便需要恢复栈。</p><h3 id="中断错误码"><a href="#中断错误码" class="headerlink" title="中断错误码"></a>中断错误码</h3><p>中断错误码只是用来指明中断发生在哪个段上，结构如下图：</p><p>EXT用来指明中断源来自处理器内部还是外部，1代表中断源是不可屏蔽中断或外部设备。</p><p>IDT表示选择子是否指向中断描述表，1表示执行IDT，否则指向GDT或LDT。</p><p>当IDT为1：TI为0表示从GDT中检索描述符，为1表示从LDT检索描述符。</p><p>选择子高13位就是用来索引描述符用的下标。</p><h2 id="8259A详解"><a href="#8259A详解" class="headerlink" title="8259A详解"></a>8259A详解</h2><h3 id="8259A的外部引线"><a href="#8259A的外部引线" class="headerlink" title="8259A的外部引线"></a>8259A的外部引线</h3><p><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center.jpeg" alt="8259A"><br>采用28脚双列直插式封装。</p><ol><li>D0~D7:双向数据线，与系统的数据总线相连。编程时控制字，命令字由此写入；中断响应时，中断向量码由此送给CPU。</li><li>/WR,/RD为读写控制信号，与系统总线的/IOW,/IOR相连接。</li><li>/CS为片选信号，当/CS为低电平时，8259A被选中，CPU才能对它进行读写操作。此引脚连到系统的I/O译码器输出，由此确定8259A在系统I/O地址空间的基地址。</li><li>A0是8259A内部寄存器的选择信号，它与/CS,/WR,/RD信号相配合，对不同的内部寄存器进行读写。使用中，通常接地址总线的某一位，例如A1，A0等。</li><li>INT为8259A的中断请求输出信号，可以直接接到CPU的INTR输入端。</li><li>/INTA为中断响应输入信号，在中断响应过程中CPU的中断信号由此端进入8259A。</li><li>CAS0~CAS2为级联控制线。当多片8259A级联工作时，其中一片为主控芯片，其它均为从属芯片。对于主片的8259A，其CAS0到CAS2为输出，对于各从属芯片的CAS0到CAS2为输入。主片的CAS0到CAS2与从片相同引脚对应相连。当从片提出中断请求时，主片通过CAS0到CAS2送出相应的编码给从片，使得从片的中断被允许。</li><li>/SP/EN为双功能引线，工作在缓冲模式时，为输出，控制缓冲器的传送方向。CPU–&gt;8259A为高电平，数据从8259A–&gt;CPU为低电平。工作在非缓冲方式时，为输入，指定8259A是否为主片从片。/SP=1为主片，/SP=0为从片。系统中只有一片8259A时，接高电平。</li><li>IR0~IR7为中断请求输入信号，与外设中断请求线相连，上升沿或高电（可编程设定）时表示有中断请求到达。</li></ol><h3 id="8259A的内部结构"><a href="#8259A的内部结构" class="headerlink" title="8259A的内部结构"></a>8259A的内部结构</h3><p>8259A的内部结构如图所示：</p><p><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255916-33.jpeg" alt="在这里插入图片描述"><br>由中断请求寄存器IRR,中断服务寄存器ISR。中断屏蔽寄存器IMR,中断判优电路，数据总线缓冲器，读/写电路，控制逻辑和<a href="https://so.csdn.net/so/search?q=级联&amp;spm=1001.2101.3001.7020">级联</a>缓冲/比较器组成。</p><ol><li>中断请求寄存器IRR：<br>保存从IR0-IR7来的中断请求信号。某一位为1表示相应引脚上有中断请求信号。该中断请求信号至少应保持到该请求被响应为止。中断响应后，该IR输入线上的请求信号应撤销,否则，在中断处理完结后，该IR线上的高电平可能会引起又一次中断服务。</li><li>中断服务寄存器ISR:<br>ISR用于保存所有正在服务的中断源。是8位的寄存器（IS0-IS7分别对应IR0-IR7）。在中断响应时，判优电路。把发出中断请求的中断源中优先级最高的中断源所对应的位置1，表示该中断请求正在处理中，ISR的某一位ISi置1可阻止与它同级及更低优先级的请求被响应，但不阻止比它优先级更高的中断请求被响应，即允许中断嵌套，所以，ISR中可能不只有一位被置1，当8259A收到中断结束（EOI）命令时，ISR相应位会被清除。对自动EOI操作，ISR寄存器中刚被置1的位在中断相应结束时自动复位。</li><li>中断屏蔽寄存器IMR：<br>IMR用于存放中断屏蔽字，它的每一位分别与IR7~IR0相对应。其中为1的位所对应的中断请求输入将被屏蔽，为0的位所对应的中断请求输入不受影响。</li><li>中断判优电路<br>中断判优电路监测从IRR,ISR,和IMR来的输入，并确定是否应向CPU发出中断请求。在中断响应时，它要确定ISR寄存器哪一位应置1，并将相应的中断类型码送给CPU。在EOI命令时，它要决定ISR寄存器哪一位应复位。</li></ol><h3 id="8259A的工作过程"><a href="#8259A的工作过程" class="headerlink" title="8259A的工作过程"></a>8259A的工作过程</h3><p>当系统通电后，首先应对8259A初始化，也就是由CPU执行一段程序，向8259A写入若干控制字，指定它的工作方式。初始化完成后，8259A就准备好了，随时可以接受外设的中断请求信号，当外设发出请求后，8259A对外部中断请求的处理过程如下：<br>\5. 哪条IR线上的数据有效，IRR相应位置就置1。<br>\6. 至少有一条中断没有被屏蔽，都屏蔽了中断输入无意义，8259A由INT引脚向CPU发INTR信号。<br>\7. 恰好CPU处于开中断状态，完成当前指令后，用/INTR信号响应，告诉8259A收到了中断请求。<br>\8. 8259A接收到CPU发出的第一个/INTA脉冲后，把最高优先权的ISR置1，并使相应的IRR复位。<br>\9. 第二个中断响应周期中，CPU再输出一个/INTA脉冲，这时8259A就把刚才选定的中断源所对应的8位中断类型码放到数据总线上，CPU读取该中断类型码并乘以4，就是中断服务子程序在中断向量表中的入口地址。找到执行。<br>\10. 若8259A工作在自动中断结束AEOI方式，在第二个/INTA脉冲结束时，把中断源所对应的ISR中相应位复位。对于非自动中断结束方式，则由CPU在中断服务子程序结束时向8259A写入EOI命令，才能使ISR中的相应位复位。</p><h3 id="8259A的工作方式"><a href="#8259A的工作方式" class="headerlink" title="8259A的工作方式"></a>8259A的工作方式</h3><ol><li>中断优先方式与中断嵌套</li></ol><p><strong>中断优先方式</strong>：<br><em>固定优先级</em>：各中断请求中断优先级固定不变，8259A加电后就处于这种方式，默认IR0优先级最高，IR7优先级最低，可改变默认值。</p><p><em>循环优先级</em>： 实际应用中，许多中断源的优先级别是一样的，如果固定优先级，低级别的中断源可能总得不到服务。使这些中断源轮流处于最高优先级。一个中断源得到中断服务后，优先级自动降到最低，原来它的下一级中断源变为最高级，依次排列。</p><p><strong>中断嵌套</strong>：<br>允许更高优先级的中断打断当前的中断处理过程。</p><p><em>普通全嵌套方式：</em> 8259A最常用的工作方式，CPU响应中断时，8259A把优先权最高的中断源在ISR中置1，把它的中断类型码送到数据总线，在此中断服务子程序结束之前，比它低的或同级的被屏蔽，只有优先权高的才被允许。</p><p><em>特殊全嵌套方式</em>：与普通全嵌套的区别是：同级的中断请求8259A也会响应。从而实现中断处理过程能被同级别中断请求打断。一般用在8259A级联的系统中。在这种情况下，只有主片8259A允许编程为特殊全嵌套模式。这时，来自某一从片的中断请求正在处理时，主片除了对本片上优先级较高的引脚上的中断请求处理开放，同时对于从片较高优先级的请求也会开放。 这种模式下，中断结束时，通过软件检查是否为从片唯一中断，向从片发一正常结束命令EOI，然后读ISR内容。如果为0表示只有一个中断服务，这时再向主片发一个EOI命令，结束所有中断；否则，说明从片上有两个以上的中断，则不应再向主片发EOI命令，等待该从片中断服务全部结束后，再发EOI给主片。</p><p>2.中断结束处理方式<br>不管用哪种优先权方式工作，当一个中断请求IRi得到响应时，8259A都会将ISR中相应ISi置1.中断服务结束时清零。否则会引起总线竞争（我认为）。这个复位动作就是中断结束处理。<strong>这里的中断结束是指8259A结束中断的处理，而不是CPU结束执行中断服务子程序。</strong></p><p><em>自动中断结束方式（AEOI)</em>： 第二个中断响应周期/INTA信号的后沿，8259A自动把ISR中的对应位消除，CPU在执行中断服务，ISR中没有保留正在执行中断服务的状态。只能用于没有中断嵌套的情况。</p><p><em>正常中断结束方式（EOI)</em>：配合全嵌套优先权方式使用，CPU向8259A发出EOI命令，8259A就会把ISR中置1的最高位复位。因为在全嵌套方式中ISR中置1的位对应的是最后一次被响应和处理的中断。复位操作相当于结束了当前正在处理的中断。</p><p><em>特殊中断结束方式（SEOI）：</em> 在程序中发一条特殊的中断结束命令，这个命令指出了要擦除ISR中的哪一位。</p><p><strong>不管是EOI还是SEOI，在一个中断服务子程序结束时，对于级联使用的8259A都必须发两次中断结束命令，一次给主片，一次给从片。</strong></p><p>3.屏蔽中断源的方式：<br>8259A的8个中断请求都可根据需要单独屏蔽，（IMR置0或1）</p><p><strong>普通屏蔽方式：</strong> 很简单，IMR置1，对应IRi被屏蔽，中断请求不能从8259A送到CPU，置0，反之。</p><p><strong>特殊屏蔽方式：</strong> （SMM）为了动态改变系统优先权结构，在IRi的处理过程中，希望除了IRi以外的所有中断请求均可被响应，首先设置特殊屏蔽方式，再编程将IRi屏蔽掉，使得这一位复位。提供了允许较低优先级中断源得到响应的特殊手段。但是打乱了原来正常的嵌套结构，被处理的程序不一定是最高优先级的事件。所以不能用正常的EOI命令来使ISR复位。但是退出SMM方式之后，仍可以用正常的EOI结束中断。<br>ps:这个我感觉有点像有关系走后门，可以为所欲为，但是破坏了原来的秩序。你对他还没有办法:)</p><p>4.中断触发方式：</p><p><strong>边沿触发方式：</strong> 8259A的引脚IRi上出现上升沿表示有中断请求，高电平并不表示有中断请求。</p><p><strong>电平触发方式：</strong> 8259A的引脚IRi上出现高电平表示有中断请求。在这种方式下，应该及时撤除高电平，否则可能引起不应该有的第二次中断。</p><p>无论是边沿触发还是电平触发，中断请求信号IR都应维持足够的宽度，就是在第一个中断响应信号/INTA结束之前IR都必须保持高电平。如果IR信号提前变为低电平，8259A就会自动假设这个中断请求来自引脚IR7.这样能有效防止由IR输入端上的严重噪声尖峰而产生的中断，如果IR7被使用，仍可通过读ISR状态来识别非正常的IR7中断。（正常的IR7中断会使ISR的IS7置位，而非正常的IR7中断不会）</p><p>5.级联工作方式：</p><p>中断源超过8个，无法用一片8259A来进行管理，这时候使用级联工作方式。指定一片为主片，其余为从片。主片的INT接到CPU上，其余的从片INT输出分别接到主控芯片的IR输入端。一片有八个中断输入端，所以最多有64个中断输入。</p><p>在级联系统中，每一片8259A,不管是主片还是从片，都有各自独立的初始化程序，以便设置各自的工作状态。中断结束要发两次EOI命令，分别使主片和从片完成中断结束操作。</p><p>中断响应过程中，若中断请求来自从片的IR，中断响应时，主片8259A会通过级联控制线CAS0~CAS2来通知相应从片的8259A，从片即可把中断向量码放到数据总线上。</p><p>级联方式下，可以采用前面说的特殊全嵌套方式，允许从片上优先级更高的IR产生中断。主片初始化为特殊全嵌套方式后，从片结束中断时，要用软件来检查ISR的内容，看看本片上有没有其它中断请求未被处理，如果没有，连发两个EOI，使主片，从片结束中断，如果还有其它中断，只发一个EOI命令。<br>（这个前面说过）</p><h3 id="8259A的初始化编程"><a href="#8259A的初始化编程" class="headerlink" title="8259A的初始化编程"></a>8259A的初始化编程</h3><p>初始化编程不必多说，就是写入控制命令字，为我所用。<br>控制命令字分为：<strong>初始化命令字ICW</strong>， <strong>操作命令字OCW</strong><br>写入8259A后保存在内部的ICW和OCW寄存器中。<br>初始化编程：由CPU向 8259A送2~4个字节的初始化命令字ICW。<strong>在 8259A工作之前，必须写入初始化命令字</strong><br>操作方式编程：由CPU向 8259A送3个字节的操作命令字OCW。以规定8259A的操作方式，可在初始化后的任何状态写入。</p><p>1.8259A内部寄存器寻址方法<br>靠/CS,A0,/RD,/WR和数据线D4,D3配合寻址。<br><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255916-34.png" alt="在这里插入图片描述"></p><p>2.8259A初始化顺序<br>对8259A进行写时，若I/O地址是奇数（A0=1），则写的对象包括四个寄存器（ICW2,ICW3,ICW4,ICW1）即一个I/O地址对应了4个寄存器。按照下图顺序写入。<br><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255916-35.png" alt="在这里插入图片描述"><br>3.8259A内部控制字<br><strong>初始化命令字ICW</strong><br>ICW1–初始化字，写入条件上上图，这时写入的数据被当成ICW1，意味着重新初始化8259A，同时：<br>清除ISR,IMR<br>中断优先级设置为初始状态，IR0最高，IR7最低<br>设定为普通屏蔽方式<br>采用非自动EOI中断结束方式<br>状态读出电路设置为读IRR</p><p>ICW1各功能如图所示</p><p><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255916-36.jpeg" alt="在这里插入图片描述"><br>ICW2–中断向量码<br>ICW2为中断向量码寄存器，CPU响应中断时，放到数据总线。<br><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255917-37.jpeg" alt="在这里插入图片描述"><br>初始化只需要确定T6~T3，低三位可以任意，8259A中断响应时自动填入。</p><p>ICW3–级联控制字<br>仅在多片级联时需要写入，主片与从片格式不同<br><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255917-38.jpeg" alt="在这里插入图片描述"><br>主片标识码图上写的很明白，从片标识码与连接主片的IR序列号一致。</p><p>ICW4–中断结束方式字<br>紧跟ICW3写入同一I/O地址中<br><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255917-39.jpeg" alt="在这里插入图片描述"><br>缓冲方式用于在级联工作时增大数据驱动能力，/SP/EN端作为输出端，输出一个允许信号。用来控制缓冲器的工作此时主片从片由D2位区分，主片=0，从片=1；非缓冲方式/SP/EN端为输入端，用以区分主片（高电平），从片（低电平）</p><p><strong>操作命令字OCW</strong><br>用来改变8259A 的中断控制方式，屏蔽中断源，以及读出8259A的工作状态（IRR,ISR,IMR）,初始化完成后任意状态皆可写入，顺序也没有严格要求，但是对端口地址有规定：OCW1奇地址端口（A0=1），OCW2,OCW3必须为偶地址端口。</p><p>OCW1–中断屏蔽字<br>是否屏蔽中断，<br><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255917-40.jpeg" alt="在这里插入图片描述"><br>OCW2–中断结束和优先级循环<br>对8259A发中断结束命令EOI，还可以控制中断优先级循环，与OCW3共用一个端口地址，有特征位D4D3=00，写入要求为偶地址。<img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255917-41.jpeg" alt="在这里插入图片描述"><br>R:优先级循环控制位：0固定优先级，IR7最低，IR0最高。1循环优先级。前面说了循环优先级<br>SL：特殊循环控制。SL=1，L2~L0对应的中断为最低优先级，SL=0时，对应的中断编码无效<br>EOI：中断结束命令，为1复位ISR相应位，，在ICW4的AEOI=0时，需要用OCW2来复位</p><p>OCW3–屏蔽方式和状态读出控制字</p><p><img src="D:\My notebook project\Final Notes\Operating System\操作系统学习记录7\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTQ2MzI4,size_16,color_FFFFFF,t_70#pic_center-1700446255917-42.jpeg" alt="在这里插入图片描述"><br>查询中断请求，CPU禁止中断或不想让8259A申请中断，CPU先写一个P=1的OCW3到8259A，再对同一地址读入。<br>I=1:表示本片8259A有中断请求，最高优先级的IR线由后三位编码组合给出<br>I=0；无中断请求<br>查询状态可重复进行，为了响应同时发生的中断。</p><p>读8259A状态<br>使用OCW3命令控制读出IRR,ISR,IMR的内容。<br>CPU先写RR RIS=10,再对同一地址读，为IRR内容<br>ISR同理<br>A0=1时读8259A，为IMR（不依赖OCW3）</p><h2 id="编写程序，开干"><a href="#编写程序，开干" class="headerlink" title="编写程序，开干"></a>编写程序，开干</h2><p>​        我们梳理一下，就是首先需要写两个函数：pic_init函数和idt_init函数，我们首先使用汇编完成对中断处理的注册。</p><p>​        先介绍一下汇编概念下的宏：那就是</p><pre class="line-numbers language-none"><code class="language-none">%macro 宏名称 参数个数...%endmacro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        下面就是代码：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">[bits 32]%define ERROR_CODE nop      ;若在相关异常中CPU已经自动压入了错误码，为保持栈中格式统一，这里不做操作%define ZERO push 0        ;CPU没有压入错误码，为了统一栈中格式，手工压入0extern put_str              ;声明外部打印函数，上一章实现的section .dataintr_str db &quot;interrupt occur!&quot;, 0xa, 0global intr_entry_tableintr_entry_table:%macro VECTOR 2section .textintr%1entry:                ;每个中断处理程序都要压入中断向量号                            ;所以一个终端类型一个中断处理程序                            ;自己知道自己的中断向量号是多少    %2    push intr_str    call put_str    add esp, 4               ;跳过参数    ;如果是  从片 上进入的中断，除了往 从片发生EOI外，还要往主片发EOI    mov al, 0x20             ;中断结束命令 EOI    out 0xa0, al             ;向 从片发生    out 0x20, al             ;向 主片发送    add esp,4                   ;跨国error_code    iret                        ;从中断返回，32位下等同指令iretdsection .data           ;这个 section .data 的作用就是让数组里全都是地址，编译器会将属性相同的 Section 合成一个大的 Segmengt，所以这里就是紧凑排列的数组了        dd intr%1entry  ;存储各个中断入口程序的地址，形成 intr_entry_table 数组%endmacroVECTOR 0x00, ZEROVECTOR 0x01, ZEROVECTOR 0x02, ZEROVECTOR 0x03, ZEROVECTOR 0x04, ZEROVECTOR 0x05, ZEROVECTOR 0x06, ZEROVECTOR 0x07, ZEROVECTOR 0x08, ZEROVECTOR 0x09, ZEROVECTOR 0x0a, ZEROVECTOR 0x0b, ZEROVECTOR 0x0c, ZEROVECTOR 0x0d, ZEROVECTOR 0x0e, ZEROVECTOR 0x0f, ZEROVECTOR 0x10, ZEROVECTOR 0x11, ZEROVECTOR 0x12, ZEROVECTOR 0x13, ZEROVECTOR 0x14, ZEROVECTOR 0x15, ZEROVECTOR 0x16, ZEROVECTOR 0x17, ZEROVECTOR 0x18, ZEROVECTOR 0x19, ZEROVECTOR 0x1a, ZEROVECTOR 0x1b, ZEROVECTOR 0x1c, ZEROVECTOR 0x1d, ERROR_CODEVECTOR 0x1f, ZEROVECTOR 0x20, ZEROVECTOR 0x21, ZERO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        就是这样我们构成了一个中断向量描述表。</p><p>​        之后就是写C代码</p><blockquote><p> interrupt.c</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __KERNEL_INTERRUPT_H#define __KERNEL_INTERRUPT_H#include &quot;stdint.h&quot;typedef void* intr_handler;void idt_init(void);#endif#include &quot;interrupt.h&quot;#include &quot;global.h&quot;#include &quot;stdint.h&quot;#include &quot;io.h&quot;#include &quot;print.h&quot;#define PIC_M_CTRL 0x20     &#x2F;&#x2F;主片#define PIC_M_DATA 0x21#define PIC_S_CTRL 0xA0     &#x2F;&#x2F;从片#define PIC_S_DATA 0xA1#define IDT_DESC_CNT 0x21                   &#x2F;&#x2F;目前总共支持的中断数&#x2F;&#x2F;中断门描述符结构体struct gate_desc&#123;    uint16_t func_offset_low_word;          &#x2F;&#x2F;中断处理程序偏移量低16位    uint16_t selector;                      &#x2F;&#x2F;中断处理程序目标段选择子    uint8_t dcount;                         &#x2F;&#x2F;此项位双字计数字段，是门描述符第4字节，固定值    uint8_t attribute;                      &#x2F;&#x2F;type属性 + S + DPL + P    uint16_t func_offset_high_word;         &#x2F;&#x2F;中断处理程序偏移量高16位&#125;;&#x2F;&#x2F;静态函数声明，非必须&#x2F;&#x2F;intr_handler 实际上是void* ,将后两个参数写入第一个参数所指向的中断门描述符static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function);static struct gate_desc idt[IDT_DESC_CNT];  &#x2F;&#x2F;idt本质上就是个中断门描述符数组extern intr_handler intr_entry_table[IDT_DESC_CNT]; &#x2F;&#x2F;声明引用kernel.S里的中断处理函数入口数组&#x2F;* 初始化 可编程中断控制器 8259A *&#x2F;static void pic_init(void) &#123;    &#x2F;&#x2F;初始化主片    outb(PIC_M_CTRL, 0x11);         &#x2F;&#x2F;ICW1: 0001 0001, 边沿触发，级联8259，需要ICW4    outb(PIC_M_DATA, 0x20);         &#x2F;&#x2F;ICW2: 0010 0000, 其实中断向量号为0x20(0x20-0x27)    outb(PIC_M_DATA, 0x04);         &#x2F;&#x2F;ICW3: 0000 0100, IR2接从片    outb(PIC_M_DATA, 0x01);         &#x2F;&#x2F;ICW4: 0000 0001, 8086模式，正常EOI    &#x2F;&#x2F;初始化从片    outb(PIC_S_CTRL, 0x11);         &#x2F;&#x2F;ICW1: 0001 0001,边沿触发， 级联8259， 需要ICW4    outb(PIC_S_DATA, 0x28);         &#x2F;&#x2F;ICW2：0010 1000，起始中断向量号为0x28(0x28-0x2f)    outb(PIC_S_DATA, 0x02);         &#x2F;&#x2F;ICW3: 0000 0010，设置连接到主片的IR2引脚    outb(PIC_S_DATA, 0x01);         &#x2F;&#x2F;ICW4, 0000 0001, 8086模式， 正常EOI    &#x2F;&#x2F;打开主片上的IR0， 也就是目前只接受时钟产生的中断    &#x2F;&#x2F;eflags 里的IF位 堆所有外部中断有效，但不能屏蔽某个外设的中断了    outb(PIC_M_DATA, 0xfe);    outb(PIC_S_DATA, 0xff);    put_str(&quot;    pic init done\n&quot;);&#125;&#x2F;&#x2F;创建中断门描述符&#x2F;&#x2F;参数：中断描述符，属性，中断处理函数&#x2F;&#x2F;功能：向中断描述符填充属性和地址static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) &#123;    p_gdesc-&gt;func_offset_low_word &#x3D; (uint32_t)function &amp; 0x0000FFFF; &#x2F;&#x2F;0000FFFF&#x3D;1111 1111 1111 1111    p_gdesc-&gt;selector &#x3D; SELECTOR_K_CODE;    p_gdesc-&gt;dcount &#x3D; 0;    p_gdesc-&gt;attribute &#x3D; attr;    p_gdesc-&gt;func_offset_high_word &#x3D; ((uint32_t) function &amp; 0xFFFF0000) &gt;&gt; 16;&#125;&#x2F;&#x2F;初始化中断描述符表static void idt_desc_init(void) &#123;    int i;    for (i &#x3D; 0; i &lt; IDT_DESC_CNT; i++) &#123;        make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]);    &#x2F;&#x2F;IDT_DESC_DPL0在global.h定义的    &#125;    put_str(&quot;    idt_desc_init done\n&quot;);&#125;&#x2F;&#x2F;完成有关中断的所有初始化工作void idt_init() &#123;    put_str(&quot;idt_init_start\n&quot;);    idt_desc_init();            &#x2F;&#x2F;初始化中断描述符表    pic_init();                 &#x2F;&#x2F;初始化8259A    &#x2F;&#x2F;加载idt, idt&#x3D;32位表基址+16位表界限    &#x2F;&#x2F;通过lidt命令加载IDT，开启中断机制    uint64_t idt_operand &#x3D; ((sizeof(idt) - 1) | ((uint64_t) ((uint32_t)idt &lt;&lt; 16)));    asm volatile(&quot;lidt %0&quot; : : &quot;m&quot;(idt_operand));    put_str(&quot;idt_init_done\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>global.h</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef _KERNEL_GLOBAL_H#define _KERNEL_GLOBAL_H#include &quot;stdint.h&quot;#define RPL0 0#define RPL1 1#define RPL2 2#define RPL3 3#define TI_GDT 0#define TI_LDT 1#define SELECTOR_K_CODE      ((1 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)#define SELECTOR_K_DATA      ((2 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0) #define SELECTOR_K_STACK     SELECTOR_K_DATA#define SELECTOR_K_GS        ((3 &lt;&lt; 3) + (TI_GDT &lt;&lt; 2) + RPL0)&#x2F;*-------------------IDT描述符-----------------*&#x2F;#define IDT_DESC_P        1#define IDT_DESC_DPL0     0#define IDT_DESC_DPL3     3#define IDT_DESC_32_TYPE  0xE   &#x2F;&#x2F;32位的门#define IDT_DESC_16_TYPE  0x6    &#x2F;&#x2F;16位的门，用不到#define IDT_DESC_ATTR_DPL0  ((IDT_DESC_P &lt;&lt; 7) + (IDT_DESC_DPL0 &lt;&lt; 5) + IDT_DESC_32_TYPE)#define IDT_DESC_ATTR_DPL3  ((IDT_DESC_P &lt;&lt; 7) + (IDT_DESC_DPL3 &lt;&lt; 5) + IDT_DESC_32_TYPE)#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>init.c 和 init.h</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __KERNEL_INIT_H#define __kERNEL_INIT_Hvoid init_all(void);#endif&#x2F;&#x2F;#include &quot;init.h&quot;#include &quot;print.h&quot;#include &quot;interrupt.h&quot;&#x2F;*负责初始化所有模块*&#x2F;void init_all() &#123;    put_str(&quot;init_all\n&quot;);    idt_init();         &#x2F;&#x2F;初始化中断&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>io.h</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;************** 机器模式   *************** b -- 输出寄存器QImode名称,即寄存器中的最低8位:[a-d]l。 w -- 输出寄存器HImode名称,即寄存器中2个字节的部分,如[a-d]x。 HImode     “Half-Integer”模式，表示一个两字节的整数。  QImode     “Quarter-Integer”模式，表示一个一字节的整数。 *******************************************&#x2F; #ifndef __LIB_IO_H#define __LIB_IO_H#include &quot;stdint.h&quot;&#x2F;*向端口port写入一个字节*&#x2F;static inline void outb(uint16_t port, uint8_t data) &#123;    &#x2F;*********************************************************        对端口指定 N 表示0-255, d表示用dx存储端口号，        %b0表示对应al，%w1表示对应dx *&#x2F;    asm volatile (&quot;outb %b0, %w1&quot; : : &quot;a&quot;(data), &quot;Nd&quot;(port));    &#x2F;******************************************************&#x2F;        &#x2F;&#x2F; 这里是 AT&amp;T 语法的汇编语言，相当于： mov al. data        &#x2F;&#x2F;                                   mov dx, port        &#x2F;&#x2F;                                   out dx, al&#125;&#x2F;*将addr处其实的word_cnt 个字写入端口port *&#x2F;static inline void outsw(uint16_t port, const void* addr, uint32_t word_cnt) &#123;       &#x2F;*********************************************************        + 表示此限制既做输入，又做输出,        outsw 是把 ds:esi 处的 16 位的内容写入 port 端口,        我们在设置段描述符时，已经将ds,es,ss段的选择子都设置为相同的值了， 此时不用担心数据错乱 *&#x2F;    asm volatile (&quot;cld; rep outsw&quot; : &quot;+S&quot;(addr), &quot;+c&quot;(word_cnt) : &quot;d&quot;(port));    &#x2F;*********************************************************&#x2F;    &#x2F;&#x2F; 这里是 AT&amp;T 语法的汇编语言，相当于： cld    &#x2F;&#x2F;                                   mov esi, addr    &#x2F;&#x2F;                                   mov ecx, word_cnt    &#x2F;&#x2F;                                   mov edx, port&#125;&#x2F;* 将从端口port 读入一个字节返回*&#x2F;static inline uint8_t inb(uint16_t port) &#123;    uint8_t data;    asm volatile(&quot;inb %w1, %b0&quot; : &quot;&#x3D;a&quot;(data) : &quot;Nd&quot;(port));    return data;&#125;&#x2F;* 将从端口port 读入的word_cnt 个字写入addr *&#x2F;static inline void insw(uint16_t port, void* addr, uint32_t word_cnt)&#123;    &#x2F;&#x2F;insw是将端口port处读入的16位内容写入es:edi 指向的内存    asm volatile(&quot;cld; rep insw&quot; : &quot;+D&quot;(addr), &quot;+c&quot;(word_cnt) : &quot;d&quot;(port): &quot;memory&quot;);&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        而后装入bochs即可。</p><p>​        我们下面做出一些改进：也就是把汇编的注册接口挪到C来，这样的话方便我们的操作</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;interrupt.h&quot;#include &quot;global.h&quot;#include &quot;stdint.h&quot;#include &quot;io.h&quot;#include &quot;print.h&quot;#define PIC_M_CTRL 0x20     &#x2F;&#x2F;主片#define PIC_M_DATA 0x21#define PIC_S_CTRL 0xA0     &#x2F;&#x2F;从片#define PIC_S_DATA 0xA1#define IDT_DESC_CNT 0x21                   &#x2F;&#x2F;目前总共支持的中断数&#x2F;&#x2F;中断门描述符结构体struct gate_desc&#123;    uint16_t func_offset_low_word;          &#x2F;&#x2F;中断处理程序偏移量低16位    uint16_t selector;                      &#x2F;&#x2F;中断处理程序目标段选择子    uint8_t dcount;                         &#x2F;&#x2F;此项位双字计数字段，是门描述符第4字节，固定值    uint8_t attribute;                      &#x2F;&#x2F;type属性 + S + DPL + P    uint16_t func_offset_high_word;         &#x2F;&#x2F;中断处理程序偏移量高16位&#125;;&#x2F;&#x2F;静态函数声明，非必须&#x2F;&#x2F;intr_handler 实际上是void* ,将后两个参数写入第一个参数所指向的中断门描述符static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function);static struct gate_desc idt[IDT_DESC_CNT];  &#x2F;&#x2F;idt本质上就是个中断门描述符数组extern intr_handler intr_entry_table[IDT_DESC_CNT]; &#x2F;&#x2F;声明引用kernel.S里的中断处理函数入口数组char* intr_name[IDT_DESC_CNT];                  &#x2F;&#x2F;用于保存异常的名字intr_handler idt_table[IDT_DESC_CNT];           &#x2F;&#x2F;用于保存处理程序地址&#x2F;&#x2F;定义中断处理程序数组，在kernel.S中定义的intrXXentry&#x2F;&#x2F;只是中断处理程序入口，最终调用的是ide_table中的处理程序;;;&#x2F;* 初始化 可编程中断控制器 8259A *&#x2F;static void pic_init(void) &#123;    &#x2F;&#x2F;初始化主片    outb(PIC_M_CTRL, 0x11);         &#x2F;&#x2F;ICW1: 0001 0001, 边沿触发，级联8259，需要ICW4    outb(PIC_M_DATA, 0x20);         &#x2F;&#x2F;ICW2: 0010 0000, 其实中断向量号为0x20(0x20-0x27)    outb(PIC_M_DATA, 0x04);         &#x2F;&#x2F;ICW3: 0000 0100, IR2接从片    outb(PIC_M_DATA, 0x01);         &#x2F;&#x2F;ICW4: 0000 0001, 8086模式，正常EOI    &#x2F;&#x2F;初始化从片    outb(PIC_S_CTRL, 0x11);         &#x2F;&#x2F;ICW1: 0001 0001,边沿触发， 级联8259， 需要ICW4    outb(PIC_S_DATA, 0x28);         &#x2F;&#x2F;ICW2：0010 1000，起始中断向量号为0x28(0x28-0x2f)    outb(PIC_S_DATA, 0x02);         &#x2F;&#x2F;ICW3: 0000 0010，设置连接到主片的IR2引脚    outb(PIC_S_DATA, 0x01);         &#x2F;&#x2F;ICW4, 0000 0001, 8086模式， 正常EOI    &#x2F;&#x2F;打开主片上的IR0， 也就是目前只接受时钟产生的中断    &#x2F;&#x2F;eflags 里的IF位 堆所有外部中断有效，但不能屏蔽某个外设的中断了    outb(PIC_M_DATA, 0xfe);    outb(PIC_S_DATA, 0xff);    put_str(&quot;    pic init done\n&quot;);&#125;&#x2F;&#x2F;创建中断门描述符&#x2F;&#x2F;参数：中断描述符，属性，中断处理函数&#x2F;&#x2F;功能：向中断描述符填充属性和地址static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) &#123;    p_gdesc-&gt;func_offset_low_word &#x3D; (uint32_t)function &amp; 0x0000FFFF; &#x2F;&#x2F;0000FFFF&#x3D;1111 1111 1111 1111    p_gdesc-&gt;selector &#x3D; SELECTOR_K_CODE;    p_gdesc-&gt;dcount &#x3D; 0;    p_gdesc-&gt;attribute &#x3D; attr;    p_gdesc-&gt;func_offset_high_word &#x3D; ((uint32_t) function &amp; 0xFFFF0000) &gt;&gt; 16;&#125;&#x2F;&#x2F;初始化中断描述符表static void idt_desc_init(void) &#123;    int i;    for (i &#x3D; 0; i &lt; IDT_DESC_CNT; i++) &#123;        make_idt_desc(&amp;idt[i], IDT_DESC_ATTR_DPL0, intr_entry_table[i]);    &#x2F;&#x2F;IDT_DESC_DPL0在global.h定义的    &#125;    put_str(&quot;    idt_desc_init done\n&quot;);&#125;&#x2F;*通用的中断处理函数，一般用在异常出现时的处理*&#x2F;static void general_intr_handler(uint8_t vec_nr)&#123;    if (vec_nr &#x3D;&#x3D; 0x27 || vec_nr &#x3D;&#x3D; 0x2f) &#123;        &#x2F;&#x2F;IRQ7 IRQ15会产生伪中断，此处无需处理        &#x2F;&#x2F;0x2f 是从片8259A上的最后一个IR0引脚，保留项        return;    &#125;    put_str(&quot;int vector: 0x&quot;);    put_int(vec_nr);    put_char(&#39;\n&#39;);&#125;&#x2F;*完成一般中断处理函数注册及异常名称注册*&#x2F;static void exception_init(void)&#123;    int i;    for(i &#x3D; 0; i &lt; IDT_DESC_CNT; i++) &#123;        &#x2F;&#x2F;idt_table 数组中的函数是在进入中断后根据中断向量号调用的        &#x2F;&#x2F;见kernel.S的call[idt_table + %1 * 4]        idt_table[i] &#x3D; general_intr_handler;    &#x2F;&#x2F;默认为这个，后面会用register_handler 来注册具体处理函数        intr_name[i] &#x3D; &quot;unknown&quot;;    &#125;    intr_name[0] &#x3D; &quot;#DE Divide Error&quot;;    intr_name[1] &#x3D; &quot;#DB Debug Exception&quot;;    intr_name[2] &#x3D; &quot;NMI Interrupt&quot;;    intr_name[3] &#x3D; &quot;#BP Breakpoint Exception&quot;;    intr_name[4] &#x3D; &quot;#OF Overflow Exception&quot;;    intr_name[5] &#x3D; &quot;#BR BOUND Range Exceeded Exception&quot;;     intr_name[6] &#x3D; &quot;#UD Invalid Opcode Exception&quot;;     intr_name[7] &#x3D; &quot;#NM Device No七 Available Exception&quot;;     intr_name[8] &#x3D; &quot;JIDF Double Fault Exception&quot;;    intr_name[9] &#x3D; &quot;Coprocessor Segment Overrun&quot;;    intr_name[10] &#x3D; &quot;#TS Invalid TSS Exception&quot;;     intr_name[11] &#x3D; &quot;#NP Segment Not Present&quot;;    intr_name[12] &#x3D; &quot;#SS Stack Fault Exception&quot;;    intr_name[13] &#x3D; &quot;#GP General Protection Exception&quot;;     intr_name[14] &#x3D; &quot;#PF Page-Fault Exception&quot;;    &#x2F;&#x2F; intr_name[l5]第15项是intel保留项，未使用    intr_name[16] &#x3D; &quot;#MF x87 FPU F&#39;loating-Point Error&quot;;     intr_name[17] &#x3D; &quot;#AC Alignment Check Exception&quot;;     intr_name[18] &#x3D; &quot;#MC Machine-Check Exception&quot;;     intr_name[19] &#x3D; &quot;#XF SIMD Floating-Point Exception&quot;;&#125;&#x2F;&#x2F;完成有关中断的所有初始化工作void idt_init() &#123;    put_str(&quot;idt_init_start\n&quot;);    idt_desc_init();            &#x2F;&#x2F;初始化中断描述符表    exception_init();           &#x2F;&#x2F;异常名初始化并注册通常的中断处理函数    pic_init();                 &#x2F;&#x2F;初始化8259A    &#x2F;&#x2F;加载idt, idt&#x3D;32位表基址+16位表界限    &#x2F;&#x2F;通过lidt命令加载IDT，开启中断机制    uint64_t idt_operand &#x3D; ((sizeof(idt) - 1) | ((uint64_t) ((uint32_t)idt &lt;&lt; 16)));    asm volatile(&quot;lidt %0&quot; : : &quot;m&quot;(idt_operand));    put_str(&quot;idt_init_done\n&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        以及这就需要我们修改接口：</p><blockquote><p>kernel.S</p></blockquote><pre class="line-numbers language-C" data-language="C"><code class="language-C">[bits 32]%define ERROR_CODE nop      ;若在相关异常中CPU已经自动压入了错误码，为保持栈中格式统一，这里不做操作%define ZERO push 0        ;CPU没有压入错误码，为了统一栈中格式，手工压入0extern idt_table                ;idt_table是C中注册的中断处理程序数组section .data; intr_entry_table位于data段, 之后会和宏中的data段组合在一起(注意: 宏中的text段与intr_entry_table不是同一个段)global intr_entry_tableintr_entry_table:;--------------- 宏 VECTOR 开始, 参数数目为2, 第一个参数为中断号, 第二个参数为该中断对 ERROR_CODE 的操作 -----------%macro VECTOR 2section .textintr%1entry:                ;每个中断处理程序都要压入中断向量号                            ;所以一个终端类型一个中断处理程序                            ;自己知道自己的中断向量号是多少    %2    ;以下是保存上下文环境    push ds    push es    push fs    push gs    pushad    ;如果是  从片 上进入的中断，除了往 从片发生EOI外，还要往主片发EOI    mov al, 0x20             ;中断结束命令 EOI    out 0xa0, al             ;向 从片发生    out 0x20, al             ;向 主片发送    push %1                     ;;不管idt_table中的目标程序是否需要参数，一律压入中断向量号    call [idt_table + %1*4]   ;调用idt_table中的c版本中断处理函数    jmp intr_exitsection .data           ;这个 section .data 的作用就是让数组里全都是地址，编译器会将属性相同的 Section 合成一个大的 Segmengt，所以这里就是紧凑排列的数组了        dd intr%1entry  ;存储各个中断入口程序的地址，形成 intr_entry_table 数组%endmacrosection .textglobal intr_exitintr_exit:;以下是恢复上下文环境        add esp,4       ;跳过中断号        popad        pop gs        pop fs        pop es        pop ds        add esp,4       ;跳过error_code        iretdVECTOR 0x00, ZEROVECTOR 0x01, ZEROVECTOR 0x02, ZEROVECTOR 0x03, ZERO VECTOR 0x04, ZEROVECTOR 0x05, ZEROVECTOR 0x06, ZEROVECTOR 0x07, ZERO VECTOR 0x08, ERROR_CODEVECTOR 0x09, ZEROVECTOR 0x0a, ERROR_CODEVECTOR 0x0b, ERROR_CODE VECTOR 0x0c, ZEROVECTOR 0x0d, ERROR_CODEVECTOR 0x0e, ERROR_CODEVECTOR 0x0f, ZERO VECTOR 0x10, ZEROVECTOR 0x11, ERROR_CODEVECTOR 0x12, ZEROVECTOR 0x13, ZERO VECTOR 0x14, ZEROVECTOR 0x15, ZEROVECTOR 0x16, ZEROVECTOR 0x17, ZERO VECTOR 0x18, ERROR_CODEVECTOR 0x19, ZEROVECTOR 0x1a, ERROR_CODEVECTOR 0x1b, ERROR_CODE VECTOR 0x1c, ZEROVECTOR 0x1d, ERROR_CODEVECTOR 0x1e, ERROR_CODEVECTOR 0x1f, ZERO VECTOR 0x20, ZERO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以了。</p><h1 id="MakeFile-基本库书写-进程临门一脚"><a href="#MakeFile-基本库书写-进程临门一脚" class="headerlink" title="MakeFile 基本库书写 进程临门一脚"></a>MakeFile 基本库书写 进程临门一脚</h1><p>​    本章和第九章合并起来讲，这是因为第八章主要是为后面铺垫一些代码：</p><p>​    首先第一件事情就是：我们改用MakeFile来写代码！</p><p><strong>Makefile的优点</strong></p><ol><li>管理代码的编译，决定该编译什么文件，编译顺序，以及是否需要重新编译；</li><li>节省编译时间。如果文件有更改，只需重新编译此文件即可，无需重新编译整个工程；</li><li>一劳永逸。Makefile通常只需编写一次，后期就不用过多更改。</li></ol><p><strong>命名规则</strong></p><p>一般来说将Makefile命名为<strong>Makefile</strong>或<strong>makefile</strong>都可以，但很多源文件的名字是小写的，所以更多程序员采用的是Makefile的名字，因为这样可以将Makefile居前显示。</p><p>如果将Makefile命为其它名字，比如Makefile_demo，也是允许的，但使用的时候应该采用以下方式：</p><blockquote><p>make -f Makefile_demo</p></blockquote><p><strong>基本规则</strong></p><p>Makefile的基本规则为：</p><p>目标：依赖</p><p>(tab)规则</p><p>目标 —&gt; 需要生成的目标文件 依赖 —&gt; 生成该目标所需的一些文件 规则 —&gt; 由依赖文件生成目标文件的手段 tab —&gt; <strong>每条规则必须以tab开头</strong>，使用空格不行</p><p>例如我们经常写的gcc test.c -o test，使用Makefile可以写成：</p><blockquote><p>test: test.c  gcc test.c -o test</p></blockquote><p>其中，第一行中的test就是要生成的目标，test.c就是依赖，第二行就是由test.c生成test的规则。</p><p>Makefile中有时会有多个目标，但Makefile会<strong>将第一个目标定为终极目标</strong>。</p><p><strong>工作原理</strong></p><blockquote><p><strong>目标的生成：</strong> a. 检查规则中的依赖文件是否存在； b. 若依赖文件不存在，则寻找是否有规则用来生成该依赖文件</p></blockquote><p><strong>自动变量</strong></p><p><strong>常用自动变量：</strong></p><p>Makefile提供了很多自动变量，但常用的为以下三个。这些自动变量只能在规则中的命令中使用，其它地方使用都不行。</p><p>$@ —&gt; 规则中的目标</p><p>$&lt; —&gt; 规则中的第一个依赖条件</p><p>$^ —&gt; 规则中的所有依赖条件</p><p><strong>变量解析</strong></p><p>用括号括起来再加个美元符，如：</p><blockquote><p>FOO = $(OBJ)</p></blockquote><p><strong>伪目标声明</strong>：.PHONY:clean 等，这样我们输入make + 伪目标就可以执行对应的指令（有点像shell）</p><h2 id="Kernel-Assert"><a href="#Kernel-Assert" class="headerlink" title="Kernel Assert"></a>Kernel Assert</h2><p>​        我们下面在内核层面实现Assert断言：</p><h3 id="debug-c"><a href="#debug-c" class="headerlink" title="debug.c"></a>debug.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token keyword">void</span> <span class="token function">panic_spin</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> filename<span class="token punctuation">,</span><span class="token keyword">int</span> line<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> func<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> condition<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">//我的理解是中断关闭防止中断后cpu处理其他进程被调换</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"\n\n\n\\**********ERROR\\**********\\\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"Filename: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_str</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"Line: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">put_int</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"Func: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_str</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>func<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"Condition: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_str</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"\\**********ERROR\\**********\\\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="debug-h"><a href="#debug-h" class="headerlink" title="debug.h"></a>debug.h</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __KERNEL_DEBUG_H#define __KERNEL_DEBUG_Hvoid panic_spin(char* filename,int line,const char* func,const char* condition);&#x2F;&#x2F; __FILE__, __LINE__, __func__, __VA_ARGS__都是内置的宏#define PANIC(...) panic_spin (__FILE__,__LINE__,__func__,__VA_ARGS__)#ifdef NDEBUG #define ASSERT(CONDITION) ((void)0) &#x2F;&#x2F; 空声明，这样就可以回避一些警告#else#define ASSERT(CONDITION) \   if(CONDITION)&#123;&#125;        \   else&#123; PANIC(#CONDITION); &#125;#endifc#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="interrupt-c-新增部分"><a href="#interrupt-c-新增部分" class="headerlink" title="interrupt.c 新增部分"></a>interrupt.c 新增部分</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">enum intr_status intr_enable()&#123;    if(intr_get_status() !&#x3D; INTR_ON)    &#123;    asm volatile(&quot;sti&quot;);    return INTR_OFF;    &#125;    return INTR_ON;&#125;enum intr_status intr_disable()&#123;    if(intr_get_status() !&#x3D; INTR_OFF)    &#123;   asm volatile(&quot;cli&quot;);   return INTR_ON;    &#125;    return INTR_OFF;&#125;enum intr_status intr_set_status(enum intr_status status)&#123;    return (status &amp; INTR_ON) ? intr_enable() : intr_disable();&#125;enum intr_status intr_get_status()&#123;    uint32_t eflags &#x3D; 0;    GET_EFLAGS(eflags);    return (eflags &amp; EFLAGS_IF) ? INTR_ON : INTR_OFF; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="interrupt-h"><a href="#interrupt-h" class="headerlink" title="interrupt.h"></a>interrupt.h</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __KERNEL_INTERRUPT_H#define __KERNEL_INTERRUPT_H#include &quot;stdint.h&quot;typedef void* intr_handler;void idt_init(void);enum intr_status&#123;    INTR_ON,    INTR_OFF&#125;;enum intr_status intr_enable();enum intr_status intr_disable();enum intr_status intr_set_status(enum intr_status status);enum intr_status intr_get_status();#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><pre class="line-numbers language-none"><code class="language-none">#include &quot;print.h&quot;#include &quot;init.h&quot;#include &quot;debug.h&quot;int main(void) &#123;   put_str(&quot;I am kernel\n&quot;);   init_all();   ASSERT(2 &#x3D;&#x3D; 3);   while(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTAwNTE2,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><h2 id="string操作函数"><a href="#string操作函数" class="headerlink" title="string操作函数"></a>string操作函数</h2><p>​        这个我搓过了，这里简单连同位图（就是用比特表示资源的状态）一笔带过</p><h3 id="string-c"><a href="#string-c" class="headerlink" title="string.c"></a>string.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;string.h&quot;#include &quot;debug.h&quot;#include &quot;global.h&quot;void memset(void* dst_,uint8_t value,uint32_t size)&#123;    ASSERT(dst_ !&#x3D; NULL);    uint8_t* dst &#x3D; (uint8_t*) dst_;    while((size--) &gt; 0)    *(dst++) &#x3D; value;    return;&#125;void memcpy(void* dst_,const void* src_,uint32_t size)&#123;    ASSERT(dst_ !&#x3D; NULL &amp;&amp; src_ !&#x3D; NULL);    uint8_t* dst &#x3D; dst_;    const uint8_t* src &#x3D; src_;    while((size--) &gt; 0)    *(dst++) &#x3D; *(src++);    return;&#125;int memcmp(const void* a_,const void* b_, uint32_t size)&#123;    const char* a &#x3D; a_;    const char* b &#x3D; b_;    ASSERT(a !&#x3D; NULL || b !&#x3D; NULL);    while((size--) &gt; 0)    &#123;    if(*a !&#x3D; *b)return (*a &gt; *b) ? 1 : -1;   ++a,++b;    &#125;    return 0;&#125;char* strcpy(char* dsc_,const char* src_)&#123;    ASSERT(dsc_ !&#x3D; NULL &amp;&amp; src_ !&#x3D; NULL);    char* dsc &#x3D; dsc_;    while((*(dsc_++) &#x3D; *(src_++) ));    return dsc;     &#125;uint32_t strlen(const char* str)&#123;    ASSERT(str !&#x3D; NULL);    const char* ptr &#x3D; str;    while(*(ptr++));    return (ptr - str - 1);             &#x2F;&#x2F;例如一个字 1 &#39;\0&#39; ptr会指向&#39;\0&#39;后面一位&#125;int8_t strcmp(const char* a,const char* b)&#123;    ASSERT(a !&#x3D; NULL &amp;&amp; b !&#x3D; NULL);    while(*a &amp;&amp; *a &#x3D;&#x3D; *b)    &#123;    a++,b++;    &#125;       return (*a &lt; *b) ? -1 : (*a &gt; *b) ; &#x2F;&#x2F;这个表达式太猛了 用活了&#125;char* strchr(const char* str,const char ch)&#123;    ASSERT(str !&#x3D; NULL);    while(*str)    &#123;    if(*str &#x3D;&#x3D; ch)return (char*)str;    ++str;    &#125;     return NULL;&#125;char* strrchr(const char* str,const uint8_t ch)&#123;    ASSERT(str !&#x3D; NULL);    char* last_chrptr &#x3D; NULL;    while(*str !&#x3D; 0)    &#123;    if(ch &#x3D;&#x3D; *str)last_chrptr &#x3D; (char*)str;    str++;    &#125;    return last_chrptr;   &#125;char* strcat(char* dsc_,const char* src_)&#123;    ASSERT(dsc_ !&#x3D; NULL &amp;&amp; src_ !&#x3D; NULL);    char* str &#x3D; dsc_;    while(*(str++));    str--;    while(*(str++) &#x3D; *(src_++));    return dsc_;&#125;char* strchrs(const char* str,uint8_t ch)&#123;    ASSERT(str !&#x3D; NULL);    uint32_t ch_cnt &#x3D; 0;    while(*str)    &#123;    if(*str &#x3D;&#x3D; ch) ++ch_cnt;    ++str;    &#125;    return ch_cnt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __LIB_STRING_H#define __LIB_STRING_H#include &quot;stdint.h&quot;#define NULL 0void memset(void* dst_,uint8_t value,uint32_t size);void memcpy(void* dst_,const void* src_,uint32_t size);int memcmp(const void* a_,const void* b_, uint32_t size);char* strcpy(char* dsc_,const char* src_);uint32_t strlen(const char* str);int8_t strcmp(const char* a,const char* b);char* strchr(const char* str,const char ch);char* strrchr(const char* str,const uint8_t ch);char* strcat(char* dsc_,const char* src_);char* strchrs(const char* str,uint8_t ch);#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bitmap-c"><a href="#bitmap-c" class="headerlink" title="bitmap.c"></a>bitmap.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;bitmap.h&quot;            &#x2F;&#x2F;函数定义#include &quot;global.h&quot;            #include &quot;string.h&quot;            &#x2F;&#x2F;memset函数要用#include &quot;interrupt.h&quot;         #include &quot;print.h&quot;             #include &quot;debug.h&quot;#define BITMAP_MASK 1void bitmap_init(struct bitmap* btmp)&#123;    memset(btmp-&gt;bits,0,btmp-&gt;btmp_bytes_len);    return;&#125;bool bitmap_scan_test(struct bitmap* btmp,uint32_t bit_idx)  &#x2F;&#x2F;一个8位的数 bit_idx&#x2F;8 找数组下标 %得索引下的具体位置&#123;    uint32_t byte_idx &#x3D; bit_idx&#x2F;8;    uint32_t byte_pos &#x3D; bit_idx%8;    return (btmp-&gt;bits[byte_idx] &amp; (BITMAP_MASK &lt;&lt; byte_pos));&#125;&#x2F;*   这个函数写很多的原因 是因为刚开始先用一个字节的快速扫描   看是否每个字节中存在 位为0的位置 然后紧接着再看连续位 挺有意思 自己先写写看*&#x2F;int bitmap_scan(struct bitmap* btmp,uint32_t cnt)&#123;    ASSERT(cnt &gt;&#x3D; 1);    uint32_t first_find_idx &#x3D; 0;    &#x2F;&#x2F;解释一下0xff 一共8位 0xff &#x3D; 11111111b    while(first_find_idx &lt; btmp-&gt;btmp_bytes_len &amp;&amp; btmp-&gt;bits[first_find_idx] &#x3D;&#x3D; 0xff)    ++first_find_idx;    if(first_find_idx &#x3D;&#x3D; btmp-&gt;btmp_bytes_len)return -1;        uint32_t find_pos &#x3D; 0;    while((btmp-&gt;bits[first_find_idx] &amp; (BITMAP_MASK &lt;&lt; find_pos)))    ++find_pos;    if(cnt &#x3D;&#x3D; 1)return find_pos + 8*first_find_idx;        uint32_t ret_pos &#x3D; find_pos + 8*first_find_idx + 1,tempcnt &#x3D; 1,endpos &#x3D; (btmp-&gt;btmp_bytes_len)*8;    while(ret_pos &lt; endpos)    &#123;    if(!bitmap_scan_test(btmp,ret_pos))++tempcnt;    else tempcnt &#x3D; 0;    if(tempcnt &#x3D;&#x3D; cnt)        return ret_pos - tempcnt + 1;    ++ret_pos;    &#125;        return -1;&#125;void bitmap_set(struct bitmap* btmp,uint32_t bit_idx,int8_t value)&#123;    ASSERT(value &#x3D;&#x3D; 1 || value &#x3D;&#x3D; 0);    uint32_t byte_idx &#x3D; bit_idx&#x2F;8;    uint32_t byte_pos &#x3D; bit_idx%8;    if(value)btmp-&gt;bits[byte_idx] |&#x3D;  (BITMAP_MASK &lt;&lt; byte_pos);    elsebtmp-&gt;bits[byte_idx] &amp;&#x3D; ~(BITMAP_MASK &lt;&lt; byte_pos);    return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="bitmap-h"><a href="#bitmap-h" class="headerlink" title="bitmap.h"></a>bitmap.h</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__LIB_KERNEL_BITMAP_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIB_KERNEL_BITMAP_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BITMAP_MASK</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> bool<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">bitmap</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> btmp_bytes_len<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span><span class="token operator">*</span> bits<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bitmap_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bitmap</span><span class="token operator">*</span> btmp<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">bitmap_scan_test</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bitmap</span><span class="token operator">*</span> btmp<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> bit_idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span>  <span class="token function">bitmap_scan</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bitmap</span><span class="token operator">*</span> btmp<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">bitmap</span><span class="token operator">*</span> btmp<span class="token punctuation">,</span><span class="token class-name">uint32_t</span> bit_idx<span class="token punctuation">,</span><span class="token class-name">int8_t</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>​        我们知道，现在我们在保护模式之下，我们根据段选择子取出的是虚拟地址，我们需要对这些像是水池的内存进行管理，他们当中有一部分用来跑内核，另一部分跑用户进程！所以，我们的下面的目标就是去实现内存的管理</p><h3 id="memory-h"><a href="#memory-h" class="headerlink" title="memory.h"></a>memory.h</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __KERNEL_MEMORY_H#define __KERNEL_MEMORY_H#include &quot;stdint.h&quot;#include &quot;bitmap.h&quot;struct virtual_addr&#123;    struct bitmap vaddr_bitmap;    uint32_t vaddr_start;&#125;;enum pool_flags&#123;    PF_KERNEL &#x3D; 1,    PF_USER &#x3D; 2&#125;;#define PG_P_1 1#define PG_P_0 0#define PG_RW_R 0#define PG_RW_W 2#define PG_US_S 0#define PG_US_U 4extern struct pool kernel_pool,user_pool;void* vaddr_get(enum pool_flags pf,uint32_t pg_cnt);uint32_t* pte_ptr(uint32_t vaddr); &#x2F;&#x2F; Page Table Entryuint32_t* pde_ptr(uint32_t vaddr); &#x2F;&#x2F; Page Directory Entryvoid* palloc(struct pool* m_pool); &#x2F;&#x2F; Page Allocationvoid page_table_add(void* _vaddr,void* _page_phyaddr);void* malloc_page(enum pool_flags pf,uint32_t pg_cnt);void* get_kernel_pages(uint32_t pg_cnt);void mem_pool_init(uint32_t all_mem);void mem_init(void);#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="memory-c"><a href="#memory-c" class="headerlink" title="memory.c"></a>memory.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;memory.h&quot;#include &quot;stdint.h&quot;#include &quot;print.h&quot;#include &quot;bitmap.h&quot;#include &quot;debug.h&quot;#include &quot;string.h&quot;#define PG_SIZE 4096#define MEM_BITMAP_BASE 0Xc009a000   &#x2F;&#x2F;位图开始存放的位置#define K_HEAP_START    0xc0100000   &#x2F;&#x2F;内核栈起始位置#define PDE_IDX(addr) ((addr &amp; 0xffc00000) &gt;&gt; 22)#define PTE_IDX(addr) ((addr &amp; 0x003ff000) &gt;&gt; 12)struct pool&#123;    struct bitmap pool_bitmap; &#x2F;&#x2F;位图来管理内存使用    uint32_t phy_addr_start;   &#x2F;&#x2F;内存池开始的起始地址    uint32_t pool_size;&#x2F;&#x2F;池容量&#125;;struct pool kernel_pool ,user_pool; &#x2F;&#x2F;生成内核内存池 和 用户内存池struct virtual_addr kernel_vaddr;    &#x2F;&#x2F;内核虚拟内存管理池void* vaddr_get(enum pool_flags pf,uint32_t pg_cnt)&#123;    int vaddr_start &#x3D; 0,bit_idx_start &#x3D; -1;    uint32_t cnt &#x3D; 0;    if(pf &#x3D;&#x3D; PF_KERNEL)    &#123;    bit_idx_start &#x3D; bitmap_scan(&amp;kernel_vaddr.vaddr_bitmap,pg_cnt);    if(bit_idx_start &#x3D;&#x3D; -1)return NULL;    while(cnt &lt; pg_cnt)    bitmap_set(&amp;kernel_vaddr.vaddr_bitmap,bit_idx_start + (cnt++),1);    vaddr_start &#x3D; kernel_vaddr.vaddr_start + bit_idx_start * PG_SIZE;    &#125;    else    &#123;&#125;    return (void*)vaddr_start;&#125;uint32_t* pte_ptr(uint32_t vaddr)&#123;    uint32_t* pte &#x3D; (uint32_t*)(0xffc00000 + ((vaddr &amp; 0xffc00000) &gt;&gt; 10) + PTE_IDX(vaddr) * 4);    return pte;&#125;uint32_t* pde_ptr(uint32_t vaddr)&#123;    uint32_t* pde &#x3D; (uint32_t*) ((0xfffff000) + PDE_IDX(vaddr) * 4);    return pde;&#125;void* palloc(struct pool* m_pool)&#123;    int bit_idx &#x3D; bitmap_scan(&amp;m_pool-&gt;pool_bitmap,1);    if(bit_idx &#x3D;&#x3D; -1)return NULL;    bitmap_set(&amp;m_pool-&gt;pool_bitmap,bit_idx,1);    uint32_t page_phyaddr &#x3D; ((bit_idx * PG_SIZE) + m_pool-&gt;phy_addr_start);    return (void*)page_phyaddr;&#125;void page_table_add(void* _vaddr,void* _page_phyaddr)&#123;    uint32_t vaddr &#x3D; (uint32_t)_vaddr,page_phyaddr &#x3D; (uint32_t)_page_phyaddr;    uint32_t* pde &#x3D; pde_ptr(vaddr);    uint32_t* pte &#x3D; pte_ptr(vaddr);        if(*pde &amp; 0x00000001)    &#123;    ASSERT(!(*pte &amp; 0x00000001));    if(!(*pte &amp; 0x00000001))        *pte &#x3D; (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    else    &#123;        PANIC(&quot;pte repeat&quot;);        *pte &#x3D; (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    &#125;    &#125;     else    &#123;    uint32_t pde_phyaddr &#x3D; (uint32_t)palloc(&amp;kernel_pool);    *pde &#x3D; (pde_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    memset((void*)((int)pte &amp; 0xfffff000),0,PG_SIZE);    ASSERT(!(*pte &amp; 0x00000001));    *pte &#x3D; (page_phyaddr | PG_US_U | PG_RW_W | PG_P_1);    &#125;    return;&#125;void* malloc_page(enum pool_flags pf,uint32_t pg_cnt)&#123;    ASSERT(pg_cnt &gt; 0 &amp;&amp; pg_cnt &lt; 3840);        void* vaddr_start &#x3D; vaddr_get(pf,pg_cnt);    if(vaddr_start &#x3D;&#x3D; NULL)return NULL;            uint32_t vaddr &#x3D; (uint32_t)vaddr_start,cnt &#x3D; pg_cnt;    struct pool* mem_pool &#x3D; pf &amp; PF_KERNEL ? &amp;kernel_pool : &amp;user_pool;        while(cnt-- &gt; 0)    &#123;    void* page_phyaddr &#x3D; palloc(mem_pool);    if(page_phyaddr &#x3D;&#x3D; NULL)return NULL;    page_table_add((void*)vaddr,page_phyaddr);    vaddr +&#x3D; PG_SIZE;    &#125;    return vaddr_start;&#125;void* get_kernel_pages(uint32_t pg_cnt)&#123;    void* vaddr &#x3D; malloc_page(PF_KERNEL,pg_cnt);    if(vaddr !&#x3D; NULL)memset(vaddr,0,pg_cnt*PG_SIZE);    return vaddr;&#125;void mem_pool_init(uint32_t all_mem)&#123;    put_str(&quot;    mem_pool_init start!\n&quot;);    uint32_t page_table_size &#x3D; PG_SIZE * 256;       &#x2F;&#x2F;页表占用的大小    uint32_t used_mem &#x3D; page_table_size + 0x100000; &#x2F;&#x2F;低端1MB的内存 + 页表所占用的大小    uint32_t free_mem &#x3D; all_mem - used_mem;        uint16_t all_free_pages &#x3D; free_mem &#x2F; PG_SIZE;   &#x2F;&#x2F;空余的页数 &#x3D; 总空余内存 &#x2F; 一页的大小        uint16_t kernel_free_pages &#x3D; all_free_pages &#x2F;2; &#x2F;&#x2F;内核 与 用户 各平分剩余内存    uint16_t user_free_pages &#x3D; all_free_pages - kernel_free_pages; &#x2F;&#x2F;万一是奇数 就会少1 减去即可        &#x2F;&#x2F;kbm kernel_bitmap ubm user_bitmap    uint32_t kbm_length &#x3D; kernel_free_pages &#x2F; 8;    &#x2F;&#x2F;一位即可表示一页 8位一个数    uint32_t ubm_length &#x3D; user_free_pages &#x2F; 8;        &#x2F;&#x2F;kp kernel_pool up user_pool    uint32_t kp_start &#x3D; used_mem;    uint32_t up_start &#x3D; kp_start + kernel_free_pages * PG_SIZE;        kernel_pool.phy_addr_start &#x3D; kp_start;    user_pool.phy_addr_start &#x3D; up_start;        kernel_pool.pool_size &#x3D; kernel_free_pages * PG_SIZE;    user_pool.pool_size &#x3D; user_free_pages * PG_SIZE;        kernel_pool.pool_bitmap.bits &#x3D; (void*)MEM_BITMAP_BASE;    user_pool.pool_bitmap.bits &#x3D; (void*)(MEM_BITMAP_BASE + kbm_length);        kernel_pool.pool_bitmap.btmp_bytes_len &#x3D; kbm_length;    user_pool.pool_bitmap.btmp_bytes_len &#x3D; ubm_length;         put_str(&quot;        kernel_pool_bitmap_start:&quot;);    put_int((int)kernel_pool.pool_bitmap.bits);    put_str(&quot; kernel_pool_phy_addr_start:&quot;);    put_int(kernel_pool.phy_addr_start);    put_char(&#39;\n&#39;);    put_str(&quot;        user_pool_bitmap_start:&quot;);    put_int((int)user_pool.pool_bitmap.bits);    put_str(&quot; user_pool_phy_addr_start:&quot;);    put_int(user_pool.phy_addr_start);    put_char(&#39;\n&#39;);        bitmap_init(&amp;kernel_pool.pool_bitmap);    bitmap_init(&amp;user_pool.pool_bitmap);        kernel_vaddr.vaddr_bitmap.bits &#x3D; (void*)(MEM_BITMAP_BASE + kbm_length + ubm_length);    kernel_vaddr.vaddr_bitmap.btmp_bytes_len &#x3D; kbm_length;        kernel_vaddr.vaddr_start &#x3D; K_HEAP_START;    bitmap_init(&amp;kernel_vaddr.vaddr_bitmap);    put_str(&quot;    mem_pool_init done\n&quot;);    return;&#125;void mem_init()&#123;    put_str(&quot;mem_init start!\n&quot;);    uint32_t mem_bytes_total &#x3D; (*(uint32_t*)(0xb00)); &#x2F;&#x2F;我们把总内存的值放在了0xb00，现在取出来！     mem_pool_init(mem_bytes_total);    put_str(&quot;mem_init done!\n&quot;);    return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后在init.c<strong>加了一个<code>#include &quot;memory.h</code>“ 和 一句 <code>mem_init();</code></strong>就可以。</p><h3 id="main-c-1"><a href="#main-c-1" class="headerlink" title="main.c"></a>main.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;print.h&quot;#include &quot;init.h&quot;#include &quot;debug.h&quot;#include &quot;string.h&quot;#include &quot;memory.h&quot;int main(void) &#123;   put_str(&quot;I am kernel\n&quot;);   init_all();      void* addr &#x3D; get_kernel_pages(3);   put_str(&quot;\n get_kernel_page start vaddr is &quot;);   put_int((uint32_t)addr);   put_char(&#39;\n&#39;);      while(1);   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h3><pre class="line-numbers language-none"><code class="language-none">BUILD_DIR &#x3D; .&#x2F;buildENTRY_POINT &#x3D; 0xc0001500AS &#x3D; nasmCC &#x3D; gccLD &#x3D; ldLIB &#x3D; -I lib&#x2F; -I lib&#x2F;kernel&#x2F; -I lib&#x2F;user&#x2F; -I kernel&#x2F; -I device&#x2F; ASFLAGS &#x3D; -f elfCFLAGS &#x3D; -Wall -m32 -fno-stack-protector $(LIB) -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypesLDFLAGS &#x3D;  -m elf_i386 -Ttext $(ENTRY_POINT) -e main -Map $(BUILD_DIR)&#x2F;kernel.mapOBJS &#x3D; $(BUILD_DIR)&#x2F;main.o $(BUILD_DIR)&#x2F;init.o $(BUILD_DIR)&#x2F;interrupt.o \      $(BUILD_DIR)&#x2F;timer.o $(BUILD_DIR)&#x2F;kernel.o $(BUILD_DIR)&#x2F;print.o \      $(BUILD_DIR)&#x2F;debug.o $(BUILD_DIR)&#x2F;string.o $(BUILD_DIR)&#x2F;memory.o \      $(BUILD_DIR)&#x2F;bitmap.o##############     c代码编译     ###############$(BUILD_DIR)&#x2F;main.o: kernel&#x2F;main.c lib&#x2F;kernel&#x2F;print.h \        lib&#x2F;stdint.h kernel&#x2F;init.h lib&#x2F;string.h kernel&#x2F;memory.h$(CC) $(CFLAGS) $&lt; -o $@$(BUILD_DIR)&#x2F;init.o: kernel&#x2F;init.c kernel&#x2F;init.h lib&#x2F;kernel&#x2F;print.h \        lib&#x2F;stdint.h kernel&#x2F;interrupt.h device&#x2F;timer.h kernel&#x2F;memory.h$(CC) $(CFLAGS) $&lt; -o $@$(BUILD_DIR)&#x2F;interrupt.o: kernel&#x2F;interrupt.c kernel&#x2F;interrupt.h \        lib&#x2F;stdint.h kernel&#x2F;global.h lib&#x2F;kernel&#x2F;io.h lib&#x2F;kernel&#x2F;print.h$(CC) $(CFLAGS) $&lt; -o $@$(BUILD_DIR)&#x2F;timer.o: device&#x2F;timer.c device&#x2F;timer.h lib&#x2F;stdint.h\        lib&#x2F;kernel&#x2F;io.h lib&#x2F;kernel&#x2F;print.h$(CC) $(CFLAGS) $&lt; -o $@$(BUILD_DIR)&#x2F;debug.o: kernel&#x2F;debug.c kernel&#x2F;debug.h \        lib&#x2F;kernel&#x2F;print.h lib&#x2F;stdint.h kernel&#x2F;interrupt.h$(CC) $(CFLAGS) $&lt; -o $@$(BUILD_DIR)&#x2F;string.o: lib&#x2F;string.c lib&#x2F;string.h \kernel&#x2F;debug.h kernel&#x2F;global.h$(CC) $(CFLAGS) $&lt; -o $@$(BUILD_DIR)&#x2F;memory.o: kernel&#x2F;memory.c kernel&#x2F;memory.h \lib&#x2F;stdint.h lib&#x2F;kernel&#x2F;bitmap.h kernel&#x2F;debug.h lib&#x2F;string.h$(CC) $(CFLAGS) $&lt; -o $@$(BUILD_DIR)&#x2F;bitmap.o: lib&#x2F;kernel&#x2F;bitmap.c lib&#x2F;kernel&#x2F;bitmap.h \lib&#x2F;string.h kernel&#x2F;interrupt.h lib&#x2F;kernel&#x2F;print.h kernel&#x2F;debug.h$(CC) $(CFLAGS) $&lt; -o $@##############    汇编代码编译    ###############$(BUILD_DIR)&#x2F;kernel.o: kernel&#x2F;kernel.S$(AS) $(ASFLAGS) $&lt; -o $@$(BUILD_DIR)&#x2F;print.o: lib&#x2F;kernel&#x2F;print.S$(AS) $(ASFLAGS) $&lt; -o $@##############    链接所有目标文件    #############$(BUILD_DIR)&#x2F;kernel.bin: $(OBJS)$(LD) $(LDFLAGS) $^ -o $@.PHONY : mk_dir hd clean allmk_dir:if [ ! -d $(BUILD_DIR) ]; then mkdir $(BUILD_DIR); fihd:dd if&#x3D;$(BUILD_DIR)&#x2F;kernel.bin \           of&#x3D;&#x2F;home&#x2F;cooiboi&#x2F;bochs&#x2F;hd60M.img \           bs&#x3D;512 count&#x3D;200 seek&#x3D;9 conv&#x3D;notruncclean:cd $(BUILD_DIR) &amp;&amp; rm -f  .&#x2F;*build: $(BUILD_DIR)&#x2F;kernel.binall: mk_dir build hd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTAwNTE2,size_16,color_FFFFFF,t_70-1700827068976-3.png" alt="在这里插入图片描述"></p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>​        线程可以说是自进程之后最小的作业单元了！他进一步细分了进程，让进程成为了被分配的单元之一而实际进行改成了进程来实现！</p><p>​        内核级线程 指的是操作系统支持线程 即提供了线程这个概念 程序员可以在操作系统的帮助下来进程创建线程操作 线程这个实物概念对于操作系统是可见的<br>而用户级线程 是指的是 操作系统不支持线程这个概念 用户 程序员在写进程程序的时候 自己写了调度器或者自己写了一个执行流 而线程的切换是通过进程本身来调节的</p><p>​        用户级线程的好处是切换线程时不需要陷入内核，切换线程的代价要小的多，速度非常快。但坏处是一旦发生阻塞，操作系统是不清楚有这个线程的存在，可能就直接把进程撤下，整个的进程就直接阻塞</p><p>​        我们所以实现内核级线程：</p><h3 id="thread-h"><a href="#thread-h" class="headerlink" title="thread.h"></a>thread.h</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__THREAD_THREAD_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__THREAD_THREAD_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里有点不懂定义的什么意思 搜了搜博客 发现是函数声明 </span>                          <span class="token keyword">enum</span> <span class="token class-name">task_status</span><span class="token punctuation">&#123;</span>    TASK_RUNNING<span class="token punctuation">,</span> <span class="token comment">// 0</span>    TASK_READY<span class="token punctuation">,</span>   <span class="token comment">// 1</span>    TASK_BLOCKED<span class="token punctuation">,</span> <span class="token comment">// 2</span>    TASK_WAITING<span class="token punctuation">,</span> <span class="token comment">// 3</span>    TASK_HANGING<span class="token punctuation">,</span> <span class="token comment">// 4</span>    TASK_DIED     <span class="token comment">// 5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/*         intr_stack 用于处理中断被切换的上下文环境储存 */</span><span class="token comment">/*   这里我又去查了一下 为什么是反着的 越在后面的参数 地址越高 */</span><span class="token keyword">struct</span> <span class="token class-name">intr_struct</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> vec_no<span class="token punctuation">;</span> <span class="token comment">//中断号</span>    <span class="token class-name">uint32_t</span> edi<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> esi<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ebp<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> esp_dummy<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ebx<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> edx<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ecx<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> eax<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> gs<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> fs<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> es<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ds<span class="token punctuation">;</span>        <span class="token class-name">uint32_t</span> err_code<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>eip<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//这里声明了一个函数指针 </span>    <span class="token class-name">uint32_t</span> cs<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> eflags<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> esp<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ss<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/*线程栈 保护线程环境 */</span><span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> ebp<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ebx<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> edi<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> esi<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>eip<span class="token punctuation">)</span> <span class="token punctuation">(</span>thread_func<span class="token operator">*</span> func<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//和下面的相互照应 以ret 汇编代码进入kernel_thread函数调用</span>        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>unused_retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//占位数 在栈顶站住了返回地址的位置 因为是汇编ret </span>    thread_func<span class="token operator">*</span> function<span class="token punctuation">;</span>                          <span class="token comment">//进入kernel_thread要调用的函数地址</span>    <span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">;</span>      <span class="token comment">//参数指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span><span class="token operator">*</span> self_kstack<span class="token punctuation">;</span>                          <span class="token comment">//pcb中的 kernel_stack 内核栈</span>    <span class="token keyword">enum</span> <span class="token class-name">task_status</span> status<span class="token punctuation">;</span>                        <span class="token comment">//线程状态</span>    <span class="token class-name">uint8_t</span> priority<span class="token punctuation">;</span>      <span class="token comment">//特权级</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> stack_magic<span class="token punctuation">;</span>      <span class="token comment">//越界检查  因为我们pcb上面的就是我们要用的栈了 到时候还要越界检查</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">kernel_thread</span><span class="token punctuation">(</span>thread_func<span class="token operator">*</span> function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">thread_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">,</span>thread_func function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> prio<span class="token punctuation">,</span>thread_func function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="kernel-c"><a href="#kernel-c" class="headerlink" title="kernel.c"></a>kernel.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span>   <span class="token comment">//函数声明 各种结构体</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span>   <span class="token comment">//前缀</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span>   <span class="token comment">//memset</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span>   <span class="token comment">//不清楚</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span>   <span class="token comment">//分配页需要</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PG_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span class="token keyword">void</span> <span class="token function">kernel_thread</span><span class="token punctuation">(</span>thread_func<span class="token operator">*</span> function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">function</span><span class="token punctuation">(</span>func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">thread_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">,</span>thread_func function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    pthread<span class="token operator">-></span>self_kstack <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">intr_struct</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//减去中断栈的空间</span>    pthread<span class="token operator">-></span>self_kstack <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token operator">*</span> kthread_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token operator">*</span><span class="token punctuation">)</span>pthread<span class="token operator">-></span>self_kstack<span class="token punctuation">;</span>     kthread_stack<span class="token operator">-></span>eip <span class="token operator">=</span> kernel_thread<span class="token punctuation">;</span>                 <span class="token comment">//地址为kernel_thread 由kernel_thread 执行function</span>    kthread_stack<span class="token operator">-></span>function <span class="token operator">=</span> function<span class="token punctuation">;</span>    kthread_stack<span class="token operator">-></span>func_arg <span class="token operator">=</span> func_arg<span class="token punctuation">;</span>    kthread_stack<span class="token operator">-></span>ebp <span class="token operator">=</span> kthread_stack<span class="token operator">-></span>ebx <span class="token operator">=</span> kthread_stack<span class="token operator">-></span>ebx <span class="token operator">=</span> kthread_stack<span class="token operator">-></span>esi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//初始化一下</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">init_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> prio<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pthread<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>pthread<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//pcb位置清0</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>name<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    pthread<span class="token operator">-></span>status <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>    pthread<span class="token operator">-></span>priority <span class="token operator">=</span> prio<span class="token punctuation">;</span>    pthread<span class="token operator">-></span>self_kstack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pthread <span class="token operator">+</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//刚开始的位置是最低位置 栈顶位置+一页</span>    pthread<span class="token operator">-></span>stack_magic <span class="token operator">=</span> <span class="token number">0x23333333</span><span class="token punctuation">;</span>                               <span class="token comment">//设置的魔数 检测是否越界限</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> prio<span class="token punctuation">,</span>thread_func function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> thread <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_thread</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span>name<span class="token punctuation">,</span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_create</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span>function<span class="token punctuation">,</span>func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"movl %0,%%esp; pop %%ebp; pop %%ebx; pop %%edi; pop %%esi; ret"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"g"</span><span class="token punctuation">(</span>thread<span class="token operator">-></span>self_kstack<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//栈顶的位置为 thread->self_kstack </span>    <span class="token keyword">return</span> thread<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="main-c-2"><a href="#main-c-2" class="headerlink" title="main.c"></a>main.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../thread/thread.h"</span></span><span class="token keyword">void</span> <span class="token function">test_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"kernel_thread_a"</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span>test_thread<span class="token punctuation">,</span><span class="token string">"argA "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向链表（这个我熟）（喜）"><a href="#双向链表（这个我熟）（喜）" class="headerlink" title="双向链表（这个我熟）（喜）"></a>双向链表（这个我熟）（喜）</h2><p>​        不说了，这个我搓过了，直接上代码，没啥好讲的</p><h3 id="list-c"><a href="#list-c" class="headerlink" title="list.c"></a>list.c</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token comment">//初始化双向链表</span><span class="token keyword">void</span> <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    list<span class="token operator">-></span>head<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    list<span class="token operator">-></span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>list<span class="token operator">-></span>tail<span class="token punctuation">;</span>    list<span class="token operator">-></span>tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token operator">&amp;</span>list<span class="token operator">-></span>head<span class="token punctuation">;</span>    list<span class="token operator">-></span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//把链表 elem放在 before前面</span><span class="token keyword">void</span> <span class="token function">list_insert_before</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> before<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> elem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           elem<span class="token operator">-></span>next <span class="token operator">=</span> before<span class="token punctuation">;</span>    elem<span class="token operator">-></span>prev <span class="token operator">=</span> before<span class="token operator">-></span>prev<span class="token punctuation">;</span>    before<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> elem<span class="token punctuation">;</span>    before<span class="token operator">-></span>prev <span class="token operator">=</span> elem<span class="token punctuation">;</span>        <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token comment">//添加元素到链表队首</span><span class="token keyword">void</span> <span class="token function">list_push</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> elem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">list_insert_before</span><span class="token punctuation">(</span>plist<span class="token operator">-></span>head<span class="token punctuation">.</span>next<span class="token punctuation">,</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//添加元素到链表队尾</span><span class="token keyword">void</span> <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> elem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">list_insert_before</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>plist<span class="token operator">-></span>tail<span class="token punctuation">,</span>elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//让pelem脱离链表</span><span class="token keyword">void</span> <span class="token function">list_remove</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> pelem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pelem<span class="token operator">-></span>prev<span class="token operator">-></span>next <span class="token operator">=</span> pelem<span class="token operator">-></span>next<span class="token punctuation">;</span>    pelem<span class="token operator">-></span>next<span class="token operator">-></span>prev <span class="token operator">=</span> pelem<span class="token operator">-></span>prev<span class="token punctuation">;</span>        <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//让链表的第一个元素脱离链表</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> <span class="token function">list_pop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>plist<span class="token operator">-></span>head<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token operator">&amp;</span>plist<span class="token operator">-></span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> ret <span class="token operator">=</span> plist<span class="token operator">-></span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token function">list_remove</span><span class="token punctuation">(</span>plist<span class="token operator">-></span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>plist<span class="token operator">-></span>head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token operator">&amp;</span>plist<span class="token operator">-></span>tail <span class="token operator">?</span> true <span class="token operator">:</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">uint32_t</span> <span class="token function">list_len</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> next <span class="token operator">=</span> plist<span class="token operator">-></span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>next <span class="token operator">!=</span> <span class="token operator">&amp;</span>plist<span class="token operator">-></span>tail<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    next <span class="token operator">=</span> next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token operator">++</span>ret<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">,</span>function func<span class="token punctuation">,</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> elem <span class="token operator">=</span> plist<span class="token operator">-></span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">list_empty</span><span class="token punctuation">(</span>plist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>elem <span class="token operator">!=</span> <span class="token operator">&amp;</span>plist<span class="token operator">-></span>tail<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span>elem<span class="token punctuation">,</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> elem<span class="token punctuation">;</span>    elem <span class="token operator">=</span> elem<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bool <span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> obj_elem<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> ptr <span class="token operator">=</span> plist<span class="token operator">-></span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ptr <span class="token operator">!=</span> <span class="token operator">&amp;</span>plist<span class="token operator">-></span>tail<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ptr <span class="token operator">==</span> obj_elem<span class="token punctuation">)</span><span class="token keyword">return</span> true<span class="token punctuation">;</span>     ptr <span class="token operator">=</span> ptr<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="list-h"><a href="#list-h" class="headerlink" title="list.h"></a>list.h</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__LIB_KERNEL_LIST_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIB_KERNEL_LIST_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">offset</span><span class="token expression"><span class="token punctuation">(</span>struct_type<span class="token punctuation">,</span>member<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>struct_type<span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-></span>member<span class="token punctuation">)</span> </span><span class="token comment">//  就是结构体的成员寻址偏移</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">elem2entry</span><span class="token expression"><span class="token punctuation">(</span>struct_type<span class="token punctuation">,</span>struct_member_name<span class="token punctuation">,</span>elem_ptr<span class="token punctuation">)</span> </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">(</span>struct_type<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>elem_ptr <span class="token operator">-</span> <span class="token function">offset</span><span class="token punctuation">(</span>struct_type<span class="token punctuation">,</span>struct_member_name<span class="token punctuation">)</span><span class="token punctuation">)</span> </span><span class="token comment">// 就是结构体的成员寻址偏移</span></span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> prev<span class="token punctuation">;</span> <span class="token comment">//前面的节点</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment">//后面的节点</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> head<span class="token punctuation">;</span> <span class="token comment">// 亘古不变的头部</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> tail<span class="token punctuation">;</span> <span class="token comment">// 亘古不变的尾部</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token function">bool</span> <span class="token punctuation">(</span>function<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">list_insert_before</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> before<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">list_push</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">list_remove</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> pelem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> <span class="token function">list_pop</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">uint32_t</span> <span class="token function">list_len</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">,</span>function func<span class="token punctuation">,</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list</span><span class="token operator">*</span> plist<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> obj_elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="PCB结果完善"><a href="#PCB结果完善" class="headerlink" title="PCB结果完善"></a>PCB结果完善</h2><p><strong><code>1、先创建线程</code></strong><br><strong><code>2、打开中断 每个时钟中断调用中断函数 减去当前时间片</code></strong><br><strong><code>3、时间片为0 简称到期了 到期之后 调用schedule调度器 切换线程</code></strong><br><strong><code>4、schedule 把在最前面的准备队列的任务的pcb获取 把当前的放到最后</code></strong><br><strong><code>5、之后转到switch_to 保存寄存器 上下文环境 切换esp 即切换线程</code></strong><br><strong><code>main</code>主线程的本来<code>pcb</code>的内存空间就是留了的 这部分的问题在上面已经说过了 分配了一页内存后 <code>pcb</code>的核心部分在最低端的内存处 最高处是中断栈 就是存放各种寄存器的位置 最高处的下面就是内核栈 里面有四个我们相关的寄存器 还有一个<code>esp</code>的位置 剩下的就是第一次被切换所需要的内容了</strong></p><hr><h4 id="thread-c"><a href="#thread-c" class="headerlink" title="thread.c"></a>thread.c</h4><hr><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span>   <span class="token comment">//函数声明 各种结构体</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span>   <span class="token comment">//前缀</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span>   <span class="token comment">//memset</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span>   </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span>   <span class="token comment">//分配页需要</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PG_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> main_thread<span class="token punctuation">;</span>                        <span class="token comment">//主线程main_thread的pcb</span><span class="token keyword">struct</span> <span class="token class-name">list</span> thread_ready_list<span class="token punctuation">;</span>  <span class="token comment">//就绪队列</span><span class="token keyword">struct</span> <span class="token class-name">list</span> thread_all_list<span class="token punctuation">;</span>  <span class="token comment">//总线程队列</span><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">switch_to</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取 pcb 指针</span><span class="token comment">// 这部分我可以来稍微解释一下</span><span class="token comment">// 我们线程所在的esp 肯定是在 我们get得到的那一页内存 pcb页上下浮动 但是我们的pcb的最起始位置是整数的 除去后面的12位</span><span class="token comment">// 那么我们对前面的取 &amp; 则可以得到 我们的地址所在地</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">uint32_t</span> esp<span class="token punctuation">;</span>    <span class="token keyword">asm</span> <span class="token punctuation">(</span><span class="token string">"mov %%esp,%0"</span> <span class="token operator">:</span> <span class="token string">"=g"</span><span class="token punctuation">(</span>esp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>esp <span class="token operator">&amp;</span> <span class="token number">0xfffff000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">kernel_thread</span><span class="token punctuation">(</span>thread_func<span class="token operator">*</span> function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//开中断 防止后面的时间中断被屏蔽无法切换线程</span>    <span class="token function">function</span><span class="token punctuation">(</span>func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">thread_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">,</span>thread_func function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    pthread<span class="token operator">-></span>self_kstack <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">intr_struct</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//减去中断栈的空间</span>    pthread<span class="token operator">-></span>self_kstack <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token operator">*</span> kthread_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token operator">*</span><span class="token punctuation">)</span>pthread<span class="token operator">-></span>self_kstack<span class="token punctuation">;</span>     kthread_stack<span class="token operator">-></span>eip <span class="token operator">=</span> kernel_thread<span class="token punctuation">;</span>                 <span class="token comment">//地址为kernel_thread 由kernel_thread 执行function</span>    kthread_stack<span class="token operator">-></span>function <span class="token operator">=</span> function<span class="token punctuation">;</span>    kthread_stack<span class="token operator">-></span>func_arg <span class="token operator">=</span> func_arg<span class="token punctuation">;</span>    kthread_stack<span class="token operator">-></span>ebp <span class="token operator">=</span> kthread_stack<span class="token operator">-></span>ebx <span class="token operator">=</span> kthread_stack<span class="token operator">-></span>ebx <span class="token operator">=</span> kthread_stack<span class="token operator">-></span>esi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//初始化一下</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">init_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> prio<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pthread<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>pthread<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//pcb位置清0</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>name<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pthread <span class="token operator">==</span> main_thread<span class="token punctuation">)</span>    pthread<span class="token operator">-></span>status <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>                              <span class="token comment">//我们的主线程肯定是在运行的</span>    <span class="token keyword">else</span>    pthread<span class="token operator">-></span>status <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span><span class="token comment">//放到就绪队列里面</span>        pthread<span class="token operator">-></span>self_kstack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>pthread <span class="token operator">+</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//刚开始的位置是最低位置 栈顶位置+一页得最顶部</span>                                                                     <span class="token comment">//后面还要对这个值进行修改</span>                                                                     pthread<span class="token operator">-></span>priority <span class="token operator">=</span> prio<span class="token punctuation">;</span>                                            pthread<span class="token operator">-></span>ticks <span class="token operator">=</span> prio<span class="token punctuation">;</span>                                           <span class="token comment">//和特权级 相同的时间片</span>    pthread<span class="token operator">-></span>elapsed_ticks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pthread<span class="token operator">-></span>pgdir <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                                           <span class="token comment">//线程没有单独的地址</span>    pthread<span class="token operator">-></span>stack_magic <span class="token operator">=</span> <span class="token number">0x23333333</span><span class="token punctuation">;</span>                               <span class="token comment">//设置的魔数 检测是否越界限</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> prio<span class="token punctuation">,</span>thread_func function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> thread <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_thread</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span>name<span class="token punctuation">,</span>prio<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_create</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span>function<span class="token punctuation">,</span>func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>thread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//之前不应该在就绪队列里面</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>thread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> thread<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//之前在loader.S的时候已经 mov esp,0xc0009f00</span><span class="token comment">//现在的esp已经就在预留的pcb位置上了</span><span class="token keyword">void</span> <span class="token function">make_main_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    main_thread <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//得到main_thread 的pcb指针</span>    <span class="token function">init_thread</span><span class="token punctuation">(</span>main_thread<span class="token punctuation">,</span><span class="token string">"main"</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>main_thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>main_thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> INTR_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//得到当前pcb的地址</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>status <span class="token operator">==</span> TASK_RUNNING<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>cur<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//目前在运行的肯定ready_list是不在的</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>cur<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//加入尾部</span>        cur<span class="token operator">-></span>status <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span>    cur<span class="token operator">-></span>ticks <span class="token operator">=</span> cur<span class="token operator">-></span>priority<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> thread_tag <span class="token operator">=</span> <span class="token function">list_pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//书上面的有点难理解 代码我写了一个我能理解的</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>thread_tag <span class="token operator">&amp;</span> <span class="token number">0xfffff000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    next<span class="token operator">-></span>status <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>    <span class="token function">switch_to</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//esp头顶的是 返回地址 +12是next +8是cur</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init start!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">make_main_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="thread-h-1"><a href="#thread-h-1" class="headerlink" title="thread.h"></a>thread.h</h4><hr><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__THREAD_THREAD_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__THREAD_THREAD_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span></span><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token function">thread_func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里有点不懂定义的什么意思 搜了搜博客 发现是函数声明 </span>                          <span class="token keyword">enum</span> <span class="token class-name">task_status</span><span class="token punctuation">&#123;</span>    TASK_RUNNING<span class="token punctuation">,</span> <span class="token comment">// 0</span>    TASK_READY<span class="token punctuation">,</span>   <span class="token comment">// 1</span>    TASK_BLOCKED<span class="token punctuation">,</span> <span class="token comment">// 2</span>    TASK_WAITING<span class="token punctuation">,</span> <span class="token comment">// 3</span>    TASK_HANGING<span class="token punctuation">,</span> <span class="token comment">// 4</span>    TASK_DIED     <span class="token comment">// 5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/*         intr_stack 用于处理中断被切换的上下文环境储存 */</span><span class="token comment">/*   这里我又去查了一下 为什么是反着的 越在后面的参数 地址越高 */</span><span class="token keyword">struct</span> <span class="token class-name">intr_struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">uint32_t</span> vec_no<span class="token punctuation">;</span> <span class="token comment">//中断号</span>    <span class="token keyword">uint32_t</span> edi<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> esi<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> ebp<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> esp_dummy<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> ebx<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> edx<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> ecx<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> eax<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> gs<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> fs<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> es<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> ds<span class="token punctuation">;</span>        <span class="token keyword">uint32_t</span> err_code<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>eip<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//这里声明了一个函数指针 </span>    <span class="token keyword">uint32_t</span> cs<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> eflags<span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token operator">*</span> esp<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> ss<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/*线程栈 保护线程环境 */</span><span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token punctuation">&#123;</span>    <span class="token keyword">uint32_t</span> ebp<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> ebx<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> edi<span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> esi<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>eip<span class="token punctuation">)</span> <span class="token punctuation">(</span>thread_func<span class="token operator">*</span> func<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//和下面的相互照应 以ret 汇编代码进入kernel_thread函数调用</span>        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>unused_retaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">//占位数 在栈顶站住了返回地址的位置 因为是汇编ret </span>    thread_func<span class="token operator">*</span> function<span class="token punctuation">;</span>                          <span class="token comment">//进入kernel_thread要调用的函数地址</span>    <span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">;</span>      <span class="token comment">//参数指针</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">uint32_t</span><span class="token operator">*</span> self_kstack<span class="token punctuation">;</span>                          <span class="token comment">//pcb中的 kernel_stack 内核栈</span>    <span class="token keyword">enum</span> <span class="token class-name">task_status</span> status<span class="token punctuation">;</span>                        <span class="token comment">//线程状态</span>    <span class="token keyword">uint8_t</span> priority<span class="token punctuation">;</span>      <span class="token comment">//特权级</span>    <span class="token keyword">uint8_t</span> ticks<span class="token punctuation">;</span>      <span class="token comment">//在cpu 运行的滴答数 看ticks 来判断是否用完了时间片</span>    <span class="token keyword">uint32_t</span> elapsed_ticks<span class="token punctuation">;</span>                         <span class="token comment">//一共执行了多久</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> general_tag<span class="token punctuation">;</span>                   <span class="token comment">//就绪队列中的连接节点</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> all_list_tag<span class="token punctuation">;</span>      <span class="token comment">//总队列的连接节点</span>        <span class="token keyword">uint32_t</span><span class="token operator">*</span> pgdir<span class="token punctuation">;</span>      <span class="token comment">//进程自己页表的虚拟地址 线程没有                  </span>    <span class="token keyword">uint32_t</span> stack_magic<span class="token punctuation">;</span>      <span class="token comment">//越界检查  因为我们pcb上面的就是我们要用的栈了 到时候还要越界检查</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">kernel_thread</span><span class="token punctuation">(</span>thread_func<span class="token operator">*</span> function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">thread_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">,</span>thread_func function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> prio<span class="token punctuation">,</span>thread_func function<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span> func_arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">make_main_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="interrupt-c"><a href="#interrupt-c" class="headerlink" title="interrupt.c"></a>interrupt.c</h4><hr><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"io.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PIC_M_CTRL</span> <span class="token expression"><span class="token number">0x20</span>       </span><span class="token comment">// 这里用的可编程中断控制器是8259A,主片的控制端口是0x20</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PIC_M_DATA</span> <span class="token expression"><span class="token number">0x21</span>       </span><span class="token comment">// 主片的数据端口是0x21</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PIC_S_CTRL</span> <span class="token expression"><span class="token number">0xa0</span>       </span><span class="token comment">// 从片的控制端口是0xa0</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PIC_S_DATA</span> <span class="token expression"><span class="token number">0xa1</span>       </span><span class="token comment">// 从片的数据端口是0xa1</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IDT_DESC_CNT</span> <span class="token expression"><span class="token number">0x21</span>      </span><span class="token comment">// 目前总共支持的中断数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EFLAGS_IF</span>   <span class="token expression"><span class="token number">0x00000200</span>       </span><span class="token comment">// eflags寄存器中的if位为1</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_EFLAGS</span><span class="token expression"><span class="token punctuation">(</span>EFLAG_VAR<span class="token punctuation">)</span> <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span></span><span class="token string">"pushfl; popl %0"</span> <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=g"</span> <span class="token expression"><span class="token punctuation">(</span>EFLAG_VAR<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token comment">/*中断门描述符结构体*/</span><span class="token keyword">struct</span> <span class="token class-name">gate_desc</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">uint16_t</span>    func_offset_low_word<span class="token punctuation">;</span>   <span class="token keyword">uint16_t</span>    selector<span class="token punctuation">;</span>   <span class="token keyword">uint8_t</span>     dcount<span class="token punctuation">;</span>   <span class="token comment">//此项为双字计数字段，是门描述符中的第4字节。此项固定值，不用考虑</span>   <span class="token keyword">uint8_t</span>     attribute<span class="token punctuation">;</span>   <span class="token keyword">uint16_t</span>    func_offset_high_word<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 静态函数声明,非必须</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">make_idt_desc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gate_desc</span><span class="token operator">*</span> p_gdesc<span class="token punctuation">,</span> <span class="token keyword">uint8_t</span> attr<span class="token punctuation">,</span> intr_handler function<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">general_intr_handler</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> vec_nr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exception_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">idt_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">register_handler</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> vec_no<span class="token punctuation">,</span>intr_handler function<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">gate_desc</span> idt<span class="token punctuation">[</span>IDT_DESC_CNT<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// idt是中断描述符表,本质上就是个中断门描述符数组</span><span class="token keyword">void</span> <span class="token function">register_handler</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> vec_no<span class="token punctuation">,</span>intr_handler function<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> intr_name<span class="token punctuation">[</span>IDT_DESC_CNT<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 用于保存异常的名字</span><span class="token comment">/********    定义中断处理程序数组    ******** * 在kernel.S中定义的intrXXentry只是中断处理程序的入口, * 最终调用的是ide_table中的处理程序*/</span>intr_handler idt_table<span class="token punctuation">[</span>IDT_DESC_CNT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/********************************************/</span><span class="token keyword">extern</span> intr_handler intr_entry_table<span class="token punctuation">[</span>IDT_DESC_CNT<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 声明引用定义在kernel.S中的中断处理函数入口数组</span><span class="token comment">/* 初始化可编程中断控制器8259A */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/* 初始化主片 */</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_CTRL<span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0x04</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW3: IR2接从片. </span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW4: 8086模式, 正常EOI</span>   <span class="token comment">/* 初始化从片 */</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_CTRL<span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0x28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0x02</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ICW3: 设置从片连接到主片的IR2引脚</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ICW4: 8086模式, 正常EOI</span>      <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0xfe</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"   pic_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 创建中断门描述符 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">make_idt_desc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gate_desc</span><span class="token operator">*</span> p_gdesc<span class="token punctuation">,</span> <span class="token keyword">uint8_t</span> attr<span class="token punctuation">,</span> intr_handler function<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    p_gdesc<span class="token operator">-></span>func_offset_low_word <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>function <span class="token operator">&amp;</span> <span class="token number">0x0000FFFF</span><span class="token punctuation">;</span>   p_gdesc<span class="token operator">-></span>selector <span class="token operator">=</span> SELECTOR_K_CODE<span class="token punctuation">;</span>   p_gdesc<span class="token operator">-></span>dcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   p_gdesc<span class="token operator">-></span>attribute <span class="token operator">=</span> attr<span class="token punctuation">;</span>   p_gdesc<span class="token operator">-></span>func_offset_high_word <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>function <span class="token operator">&amp;</span> <span class="token number">0xFFFF0000</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*初始化中断描述符表*/</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">idt_desc_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> lastindex <span class="token operator">=</span> IDT_DESC_CNT <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> IDT_DESC_CNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">make_idt_desc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>idt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> IDT_DESC_ATTR_DPL0<span class="token punctuation">,</span> intr_entry_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token comment">/* 单独处理系统调用,系统调用对应的中断门dpl为3, * 中断处理程序为单独的syscall_handler */</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"   idt_desc_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 通用的中断处理函数,一般用在异常出现时的处理 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">general_intr_handler</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> vec_nr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>vec_nr <span class="token operator">==</span> <span class="token number">0x27</span> <span class="token operator">||</span> vec_nr <span class="token operator">==</span> <span class="token number">0x2f</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 0x2f是从片8259A上的最后一个irq引脚，保留</span>      <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token comment">//IRQ7和IRQ15会产生伪中断(spurious interrupt),无须处理。</span>   <span class="token punctuation">&#125;</span>   <span class="token function">set_cursor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                         <span class="token comment">//光标设置在0号位</span>   <span class="token keyword">int</span> cursor_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cursor_pos<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">320</span><span class="token punctuation">)</span>    <span class="token comment">//一行80字 4行空格</span>   <span class="token function">put_char</span><span class="token punctuation">(</span><span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">set_cursor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"!!!!!!            excetion message begin            !!!!!!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">set_cursor</span><span class="token punctuation">(</span><span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//第二行第八个字开始打印</span>   <span class="token function">put_str</span><span class="token punctuation">(</span>intr_name<span class="token punctuation">[</span>vec_nr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">//打印中断向量号</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>vec_nr <span class="token operator">==</span> <span class="token number">14</span><span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> page_fault_vaddr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">asm</span><span class="token punctuation">(</span><span class="token string">"movl %%cr2,%0"</span> <span class="token operator">:</span> <span class="token string">"=r"</span> <span class="token punctuation">(</span>page_fault_vaddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//把虚拟地址 出错的放到了这个变量里面</span><span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"\npage fault addr is "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_int</span><span class="token punctuation">(</span>page_fault_vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"!!!!!!            excetion message end              !!!!!!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                              <span class="token comment">//悬停</span><span class="token punctuation">&#125;</span><span class="token comment">/* 完成一般中断处理函数注册及异常名称注册 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exception_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 完成一般中断处理函数注册及异常名称注册</span>   <span class="token keyword">int</span> i<span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> IDT_DESC_CNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/* idt_table数组中的函数是在进入中断后根据中断向量号调用的, * 见kernel/kernel.S的call [idt_table + %1*4] */</span>      idt_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> general_intr_handler<span class="token punctuation">;</span>    <span class="token comment">// 默认为general_intr_handler。</span>    <span class="token comment">// 以后会由register_handler来注册具体处理函数。</span>      intr_name<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"unknown"</span><span class="token punctuation">;</span>    <span class="token comment">// 先统一赋值为unknown </span>   <span class="token punctuation">&#125;</span>   intr_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#DE Divide Error"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#DB Debug Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"NMI Interrupt"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#BP Breakpoint Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#OF Overflow Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#BR BOUND Range Exceeded Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#UD Invalid Opcode Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#NM Device Not Available Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#DF Double Fault Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Coprocessor Segment Overrun"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#TS Invalid TSS Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#NP Segment Not Present"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#SS Stack Fault Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#GP General Protection Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#PF Page-Fault Exception"</span><span class="token punctuation">;</span>   <span class="token comment">// intr_name[15] 第15项是intel保留项，未使用</span>   intr_name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#MF x87 FPU Floating-Point Error"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#AC Alignment Check Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#MC Machine-Check Exception"</span><span class="token punctuation">;</span>   intr_name<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"#XF SIMD Floating-Point Exception"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*完成有关中断的所有初始化工作*/</span><span class="token keyword">void</span> <span class="token function">idt_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"idt_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">idt_desc_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 初始化中断描述符表</span>   <span class="token function">exception_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 异常名初始化并注册通常的中断处理函数</span>   <span class="token function">pic_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 初始化8259A</span>   <span class="token comment">/* 加载idt */</span>   <span class="token keyword">uint64_t</span> idt_operand <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>idt<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint64_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span><span class="token punctuation">)</span>idt <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"lidt %0"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"m"</span> <span class="token punctuation">(</span>idt_operand<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"idt_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">register_handler</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> vec_no<span class="token punctuation">,</span>intr_handler function<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//把相关向量号的注册函数指针放进去了</span>    idt_table<span class="token punctuation">[</span>vec_no<span class="token punctuation">]</span> <span class="token operator">=</span> function<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">enum</span> <span class="token class-name">intr_status</span> <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> INTR_ON<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"sti"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> INTR_OFF<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> INTR_ON<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">enum</span> <span class="token class-name">intr_status</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> INTR_OFF<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>   <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"cli"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> INTR_ON<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> INTR_OFF<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">enum</span> <span class="token class-name">intr_status</span> <span class="token function">intr_set_status</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">intr_status</span> status<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> INTR_ON<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">enum</span> <span class="token class-name">intr_status</span> <span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">uint32_t</span> eflags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">GET_EFLAGS</span><span class="token punctuation">(</span>eflags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>eflags <span class="token operator">&amp;</span> EFLAGS_IF<span class="token punctuation">)</span> <span class="token operator">?</span> INTR_ON <span class="token operator">:</span> INTR_OFF<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="switch-S"><a href="#switch-S" class="headerlink" title="switch.S"></a>switch.S</h4><hr><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">[bits 32]section .textglobal switch_toswitch_to:    push esi            ;这里是根据ABI原则保护四个寄存器 放到栈里面    push edi    push ebx    push ebp        mov eax,[esp+20]    ;esp+20的位置是cur cur的pcb赋值给eax    mov [eax],esp       ;[eax]为pcb的内核栈指针变量 把当前环境的esp值记录下来        mov eax,[esp+24]    mov esp,[eax]       ;把要切换的线程的pcb 内核栈esp取出来    pop ebp    pop ebx    pop edi    pop esi    ret                 ;这里的返回地址为 kernel_thread的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="稍加修改过的print-S"><a href="#稍加修改过的print-S" class="headerlink" title="稍加修改过的print.S"></a>稍加修改过的print.S</h4><hr><p><strong>为了用<code>set_cursor</code> 修改了一下 把<code>set_cursor</code>变成可以调用的函数了</strong></p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">TI_GDT equ  0RPL0  equ   0SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0section .dataput_int_buffer    dq    0     ; 定义8字节缓冲区用于数字到字符的转换[bits 32]section .text;--------------------------------------------;put_str 通过put_char来打印以0字符结尾的字符串;--------------------------------------------global put_strput_str:;由于本函数中只用到了ebx和ecx,只备份这两个寄存器   push ebx   push ecx   xor ecx, ecx      ; 准备用ecx存储参数,清空   mov ebx, [esp + 12]      ; 从栈中得到待打印的字符串地址 .goon:   mov cl, [ebx]   cmp cl, 0      ; 如果处理到了字符串尾,跳到结束处返回   jz .str_over   push ecx      ; 为put_char函数传递参数   call put_char   add esp, 4      ; 回收参数所占的栈空间   inc ebx      ; 使ebx指向下一个字符   jmp .goon.str_over:   pop ecx   pop ebx   ret;--------------------   将小端字节序的数字变成对应的ascii后，倒置   -----------------------;输入：栈中参数为待打印的数字;输出：在屏幕上打印16进制数字,并不会打印前缀0x,如打印10进制15时，只会直接打印f，不会是0xf;------------------------------------------------------------------------------------------global put_intput_int:   pushad   mov ebp, esp   mov eax, [ebp+4*9]       ; call的返回地址占4字节+pushad的8个4字节   mov edx, eax   mov edi, 7                          ; 指定在put_int_buffer中初始的偏移量   mov ecx, 8       ; 32位数字中,16进制数字的位数是8个   mov ebx, put_int_buffer;将32位数字按照16进制的形式从低位到高位逐个处理,共处理8个16进制数字.16based_4bits:       ; 每4位二进制是16进制数字的1位,遍历每一位16进制数字   and edx, 0x0000000F       ; 解析16进制数字的每一位。and与操作后,edx只有低4位有效   cmp edx, 9       ; 数字0～9和a~f需要分别处理成对应的字符   jg .is_A2F    add edx, &#39;0&#39;       ; ascii码是8位大小。add求和操作后,edx低8位有效。   jmp .store.is_A2F:   sub edx, 10       ; A~F 减去10 所得到的差,再加上字符A的ascii码,便是A~F对应的ascii码   add edx, &#39;A&#39;;将每一位数字转换成对应的字符后,按照类似“大端”的顺序存储到缓冲区put_int_buffer;高位字符放在低地址,低位字符要放在高地址,这样和大端字节序类似,只不过咱们这里是字符序..store:; 此时dl中应该是数字对应的字符的ascii码   mov [ebx+edi], dl          dec edi   shr eax, 4   mov edx, eax    loop .16based_4bits;现在put_int_buffer中已全是字符,打印之前,;把高位连续的字符去掉,比如把字符000123变成123.ready_to_print:   inc edi       ; 此时edi退减为-1(0xffffffff),加1使其为0.skip_prefix_0:     cmp edi,8       ; 若已经比较第9个字符了，表示待打印的字符串为全0    je .full0 ;找出连续的0字符, edi做为非0的最高位字符的偏移.go_on_skip:      mov cl, [put_int_buffer+edi]   inc edi   cmp cl, &#39;0&#39;    je .skip_prefix_0       ; 继续判断下一位字符是否为字符0(不是数字0)   dec edi       ;edi在上面的inc操作中指向了下一个字符,若当前字符不为&#39;0&#39;,要恢复edi指向当前字符          jmp .put_each_num.full0:   mov cl,&#39;0&#39;       ; 输入的数字为全0时，则只打印0.put_each_num:   push ecx       ; 此时cl中为可打印的字符   call put_char   add esp, 4   inc edi       ; 使edi指向下一个字符   mov cl, [put_int_buffer+edi]       ; 获取下一个字符到cl寄存器   cmp edi,8   jl .put_each_num   popad   ret;------------------------   put_char   -----------------------------;功能描述:把栈中的1个字符写入光标所在处;-------------------------------------------------------------------   global put_charput_char:   pushad   ;备份32位寄存器环境   ;需要保证gs中为正确的视频段选择子,为保险起见,每次打印时都为gs赋值   mov ax, SELECTOR_VIDEO       ; 不能直接把立即数送入段寄存器   mov gs, ax;;;;;;;;;  获取当前光标位置 ;;;;;;;;;   ;先获得高8位   mov dx, 0x03d4  ;索引寄存器   mov al, 0x0e   ;用于提供光标位置的高8位   out dx, al   mov dx, 0x03d5  ;通过读写数据端口0x3d5来获得或设置光标位置    in al, dx   ;得到了光标位置的高8位   mov ah, al   ;再获取低8位   mov dx, 0x03d4   mov al, 0x0f   out dx, al   mov dx, 0x03d5    in al, dx   ;将光标存入bx   mov bx, ax     ;下面这行是在栈中获取待打印的字符   mov ecx, [esp + 36]      ;pushad压入4×8＝32字节,加上主调函数的返回地址4字节,故esp+36字节   cmp cl, 0xd  ;CR是0x0d,LF是0x0a   jz .is_carriage_return   cmp cl, 0xa   jz .is_line_feed   cmp cl, 0x8  ;BS(backspace)的asc码是8   jz .is_backspace   jmp .put_other   ;;;;;;;;;;;;;;;;;; .is_backspace:      ;;;;;;;;;;;;       backspace的一点说明     ;;;;;;;;;;; 当为backspace时,本质上只要将光标移向前一个显存位置即可.后面再输入的字符自然会覆盖此处的字符; 但有可能在键入backspace后并不再键入新的字符,这时在光标已经向前移动到待删除的字符位置,但字符还在原处,; 这就显得好怪异,所以此处添加了空格或空字符0   dec bx   shl bx,1   mov byte [gs:bx], 0x20  ;将待删除的字节补为0或空格皆可   inc bx   mov byte [gs:bx], 0x07   shr bx,1   jmp set_cursor;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; .put_other:   shl bx, 1  ; 光标位置是用2字节表示,将光标值乘2,表示对应显存中的偏移字节   mov [gs:bx], cl  ; ascii字符本身   inc bx   mov byte [gs:bx],0x07  ; 字符属性   shr bx, 1  ; 恢复老的光标值   inc bx  ; 下一个光标值   cmp bx, 2000      jl set_cursor  ; 若光标值小于2000,表示未写到显存的最后,则去设置新的光标值  ; 若超出屏幕字符数大小(2000)则换行处理 .is_line_feed:  ; 是换行符LF(\n) .is_carriage_return:  ; 是回车符CR(\r)  ; 如果是CR(\r),只要把光标移到行首就行了。   xor dx, dx  ; dx是被除数的高16位,清0.   mov ax, bx  ; ax是被除数的低16位.   mov si, 80  ; 由于是效仿linux，linux中\n便表示下一行的行首，所以本系统中，   div si  ; 把\n和\r都处理为linux中\n的意思，也就是下一行的行首。   sub bx, dx  ; 光标值减去除80的余数便是取整  ; 以上4行处理\r的代码 .is_carriage_return_end:                 ; 回车符CR处理结束   add bx, 80   cmp bx, 2000 .is_line_feed_end:  ; 若是LF(\n),将光标移+80便可。     jl set_cursor;屏幕行范围是0~24,滚屏的原理是将屏幕的1~24行搬运到0~23行,再将第24行用空格填充 .roll_screen:  ; 若超出屏幕大小，开始滚屏   cld     mov ecx, 960  ; 一共有2000-80&#x3D;1920个字符要搬运,共1920*2&#x3D;3840字节.一次搬4字节,共3840&#x2F;4&#x3D;960次    mov esi, 0xc00b80a0  ; 第1行行首   mov edi, 0xc00b8000  ; 第0行行首   rep movsd  ;;;;;;;将最后一行填充为空白   mov ebx, 3840  ; 最后一行首字符的第一个字节偏移&#x3D; 1920 * 2   mov ecx, 80  ;一行是80字符(160字节),每次清理1字符(2字节),一行需要移动80次 .cls:   mov word [gs:ebx], 0x0720  ;0x0720是黑底白字的空格键   add ebx, 2   loop .cls    mov bx,1920  ;将光标值重置为1920,最后一行的首字符.global set_cursor:set_cursor:     ;将光标设为bx值;;;;;;; 1 先设置高8位 ;;;;;;;;   mov dx, 0x03d4  ;索引寄存器   mov al, 0x0e  ;用于提供光标位置的高8位   out dx, al   mov dx, 0x03d5  ;通过读写数据端口0x3d5来获得或设置光标位置    mov al, bh   out dx, al;;;;;;; 2 再设置低8位 ;;;;;;;;;   mov dx, 0x03d4   mov al, 0x0f   out dx, al   mov dx, 0x03d5    mov al, bl   out dx, al .put_char_done:    popad   ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="稍微修改了一下的stdint-h"><a href="#稍微修改了一下的stdint-h" class="headerlink" title="稍微修改了一下的stdint.h"></a>稍微修改了一下的stdint.h</h4><hr><p><strong>发现<code>bool</code> 经常会出错 而且<code>true</code> <code>false</code>报错 就这里加了一下</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__LIB_STDINT_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIB_STDINT_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">true</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">false</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token keyword">bool</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">signed</span> <span class="token keyword">char</span> <span class="token keyword">int8_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">signed</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token keyword">int16_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">signed</span> <span class="token keyword">int</span> <span class="token keyword">int32_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">signed</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token keyword">int64_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token keyword">uint8_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token keyword">uint16_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token keyword">uint32_t</span><span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token keyword">uint64_t</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="timer-c"><a href="#timer-c" class="headerlink" title="timer.c"></a>timer.c</h4><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"timer.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"io.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../kernel/interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../thread/thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IRQ0_FREQUENCY</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INPUT_FREQUENCY</span>        <span class="token expression"><span class="token number">1193180</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COUNTER0_VALUE</span><span class="token expression">INPUT_FREQUENCY <span class="token operator">/</span> IRQ0_FREQUENCY</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COUNTER0_PORT</span><span class="token expression"><span class="token number">0X40</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COUNTER0_NO</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COUNTER_MODE</span><span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">READ_WRITE_LATCH</span><span class="token expression"><span class="token number">3</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PIT_COUNTROL_PORT</span><span class="token expression"><span class="token number">0x43</span></span></span><span class="token comment">//自中断开启以来总的滴答数</span><span class="token class-name">uint32_t</span> ticks<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">frequency_set</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> counter_port <span class="token punctuation">,</span><span class="token class-name">uint8_t</span> counter_no<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> rwl<span class="token punctuation">,</span><span class="token class-name">uint8_t</span> counter_mode<span class="token punctuation">,</span><span class="token class-name">uint16_t</span> counter_value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">outb</span><span class="token punctuation">(</span>PIT_COUNTROL_PORT<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>counter_no <span class="token operator">&lt;&lt;</span> <span class="token number">6</span> <span class="token operator">|</span> rwl <span class="token operator">&lt;&lt;</span> <span class="token number">4</span> <span class="token operator">|</span> counter_mode <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span>counter_port<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span>counter_value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span>counter_port<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span>counter_value <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">void</span> <span class="token function">intr_timer_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur_thread <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//得到pcb指针</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>cur_thread<span class="token operator">-></span>stack_magic <span class="token operator">==</span> <span class="token number">0x23333333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//检测栈是否溢出</span>        <span class="token operator">++</span>ticks<span class="token punctuation">;</span>    <span class="token operator">++</span>cur_thread<span class="token operator">-></span>elapsed_ticks<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cur_thread<span class="token operator">-></span>ticks<span class="token punctuation">)</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token operator">--</span>cur_thread<span class="token operator">-></span>ticks<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">timer_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"timer_init start!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">frequency_set</span><span class="token punctuation">(</span>COUNTER0_PORT<span class="token punctuation">,</span>COUNTER0_NO<span class="token punctuation">,</span>READ_WRITE_LATCH<span class="token punctuation">,</span>COUNTER_MODE<span class="token punctuation">,</span>COUNTER0_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">register_handler</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">,</span>intr_timer_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//注册时间中断函数 0x20向量号函数更换</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"timer_init done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="timer-h"><a href="#timer-h" class="headerlink" title="timer.h"></a>timer.h</h4><hr><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__DEVICE_TIME_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__DEVICE_TIME_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token keyword">void</span> <span class="token function">frequency_set</span><span class="token punctuation">(</span><span class="token keyword">uint8_t</span> counter_port <span class="token punctuation">,</span><span class="token keyword">uint8_t</span> counter_no<span class="token punctuation">,</span><span class="token keyword">uint8_t</span> rwl<span class="token punctuation">,</span><span class="token keyword">uint8_t</span> counter_mode<span class="token punctuation">,</span><span class="token keyword">uint16_t</span> counter_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">intr_timer_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">timer_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">mtime_sleep</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> m_seconds<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h4><hr><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BUILD_DIR <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token operator">/</span>buildENTRY_POINT <span class="token operator">=</span> <span class="token number">0xc0001500</span>AS <span class="token operator">=</span> nasmCC <span class="token operator">=</span> gccLD <span class="token operator">=</span> ldLIB <span class="token operator">=</span> <span class="token operator">-</span>I lib<span class="token operator">/</span> <span class="token operator">-</span>I lib<span class="token operator">/</span>kernel<span class="token operator">/</span> <span class="token operator">-</span>I lib<span class="token operator">/</span>user<span class="token operator">/</span> <span class="token operator">-</span>I kernel<span class="token operator">/</span> <span class="token operator">-</span>I device<span class="token operator">/</span> ASFLAGS <span class="token operator">=</span> <span class="token operator">-</span>f elfCFLAGS <span class="token operator">=</span> <span class="token operator">-</span>Wall <span class="token operator">-</span>m32 <span class="token operator">-</span>fno<span class="token operator">-</span>stack<span class="token operator">-</span>protector $<span class="token punctuation">(</span>LIB<span class="token punctuation">)</span> <span class="token operator">-</span>c <span class="token operator">-</span>fno<span class="token operator">-</span>builtin <span class="token operator">-</span>W <span class="token operator">-</span>Wstrict<span class="token operator">-</span>prototypes <span class="token operator">-</span>Wmissing<span class="token operator">-</span>prototypesLDFLAGS <span class="token operator">=</span>  <span class="token operator">-</span>m elf_i386 <span class="token operator">-</span>Ttext $<span class="token punctuation">(</span>ENTRY_POINT<span class="token punctuation">)</span> <span class="token operator">-</span>e main <span class="token operator">-</span>Map $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>kernel<span class="token punctuation">.</span>mapOBJS <span class="token operator">=</span> $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>main<span class="token punctuation">.</span>o $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>init<span class="token punctuation">.</span>o $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>interrupt<span class="token punctuation">.</span>o \      $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>timer<span class="token punctuation">.</span>o $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>kernel<span class="token punctuation">.</span>o $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>print<span class="token punctuation">.</span>o \      $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>debug<span class="token punctuation">.</span>o $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>string<span class="token punctuation">.</span>o $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>memory<span class="token punctuation">.</span>o \      $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>bitmap<span class="token punctuation">.</span>o $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>thread<span class="token punctuation">.</span>o $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>list<span class="token punctuation">.</span>o $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">switch</span><span class="token punctuation">.</span>o      ##############     c代码编译     ###############$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>main<span class="token punctuation">.</span>o<span class="token operator">:</span> kernel<span class="token operator">/</span>main<span class="token punctuation">.</span>c lib<span class="token operator">/</span>kernel<span class="token operator">/</span>print<span class="token punctuation">.</span>h \        lib<span class="token operator">/</span>stdint<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>init<span class="token punctuation">.</span>h lib<span class="token operator">/</span>string<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>memory<span class="token punctuation">.</span>h \        thread<span class="token operator">/</span>thread<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>interrupt<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>init<span class="token punctuation">.</span>o<span class="token operator">:</span> kernel<span class="token operator">/</span>init<span class="token punctuation">.</span>c kernel<span class="token operator">/</span>init<span class="token punctuation">.</span>h lib<span class="token operator">/</span>kernel<span class="token operator">/</span>print<span class="token punctuation">.</span>h \        lib<span class="token operator">/</span>stdint<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>interrupt<span class="token punctuation">.</span>h device<span class="token operator">/</span>timer<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>memory<span class="token punctuation">.</span>h \        thread<span class="token operator">/</span>thread<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>interrupt<span class="token punctuation">.</span>o<span class="token operator">:</span> kernel<span class="token operator">/</span>interrupt<span class="token punctuation">.</span>c kernel<span class="token operator">/</span>interrupt<span class="token punctuation">.</span>h \        lib<span class="token operator">/</span>stdint<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>global<span class="token punctuation">.</span>h lib<span class="token operator">/</span>kernel<span class="token operator">/</span>io<span class="token punctuation">.</span>h lib<span class="token operator">/</span>kernel<span class="token operator">/</span>print<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>timer<span class="token punctuation">.</span>o<span class="token operator">:</span> device<span class="token operator">/</span>timer<span class="token punctuation">.</span>c device<span class="token operator">/</span>timer<span class="token punctuation">.</span>h lib<span class="token operator">/</span>kernel<span class="token operator">/</span>io<span class="token punctuation">.</span>h lib<span class="token operator">/</span>kernel<span class="token operator">/</span>print<span class="token punctuation">.</span>h \        kernel<span class="token operator">/</span>interrupt<span class="token punctuation">.</span>h thread<span class="token operator">/</span>thread<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>debug<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>debug<span class="token punctuation">.</span>o<span class="token operator">:</span> kernel<span class="token operator">/</span>debug<span class="token punctuation">.</span>c kernel<span class="token operator">/</span>debug<span class="token punctuation">.</span>h \        lib<span class="token operator">/</span>kernel<span class="token operator">/</span>print<span class="token punctuation">.</span>h lib<span class="token operator">/</span>stdint<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>interrupt<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>string<span class="token punctuation">.</span>o<span class="token operator">:</span> lib<span class="token operator">/</span>string<span class="token punctuation">.</span>c lib<span class="token operator">/</span>string<span class="token punctuation">.</span>h \kernel<span class="token operator">/</span>debug<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>global<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>memory<span class="token punctuation">.</span>o<span class="token operator">:</span> kernel<span class="token operator">/</span>memory<span class="token punctuation">.</span>c kernel<span class="token operator">/</span>memory<span class="token punctuation">.</span>h \lib<span class="token operator">/</span>stdint<span class="token punctuation">.</span>h lib<span class="token operator">/</span>kernel<span class="token operator">/</span>bitmap<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>debug<span class="token punctuation">.</span>h lib<span class="token operator">/</span>string<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>bitmap<span class="token punctuation">.</span>o<span class="token operator">:</span> lib<span class="token operator">/</span>kernel<span class="token operator">/</span>bitmap<span class="token punctuation">.</span>c lib<span class="token operator">/</span>kernel<span class="token operator">/</span>bitmap<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>global<span class="token punctuation">.</span>h \lib<span class="token operator">/</span>string<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>interrupt<span class="token punctuation">.</span>h lib<span class="token operator">/</span>kernel<span class="token operator">/</span>print<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>debug<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>thread<span class="token punctuation">.</span>o<span class="token operator">:</span> thread<span class="token operator">/</span>thread<span class="token punctuation">.</span>c thread<span class="token operator">/</span>thread<span class="token punctuation">.</span>h \lib<span class="token operator">/</span>stdint<span class="token punctuation">.</span>h lib<span class="token operator">/</span>string<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>global<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>memory<span class="token punctuation">.</span>h \kernel<span class="token operator">/</span>debug<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>interrupt<span class="token punctuation">.</span>h lib<span class="token operator">/</span>kernel<span class="token operator">/</span>print<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>list<span class="token punctuation">.</span>o<span class="token operator">:</span> lib<span class="token operator">/</span>kernel<span class="token operator">/</span>list<span class="token punctuation">.</span>c lib<span class="token operator">/</span>kernel<span class="token operator">/</span>list<span class="token punctuation">.</span>h \kernel<span class="token operator">/</span>interrupt<span class="token punctuation">.</span>h lib<span class="token operator">/</span>stdint<span class="token punctuation">.</span>h kernel<span class="token operator">/</span>debug<span class="token punctuation">.</span>h$<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@##############    汇编代码编译    ###############$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>kernel<span class="token punctuation">.</span>o<span class="token operator">:</span> kernel<span class="token operator">/</span>kernel<span class="token punctuation">.</span>S$<span class="token punctuation">(</span>AS<span class="token punctuation">)</span> $<span class="token punctuation">(</span>ASFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>print<span class="token punctuation">.</span>o<span class="token operator">:</span> lib<span class="token operator">/</span>kernel<span class="token operator">/</span>print<span class="token punctuation">.</span>S$<span class="token punctuation">(</span>AS<span class="token punctuation">)</span> $<span class="token punctuation">(</span>ASFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">switch</span><span class="token punctuation">.</span>o<span class="token operator">:</span> thread<span class="token operator">/</span><span class="token keyword">switch</span><span class="token punctuation">.</span>S$<span class="token punctuation">(</span>AS<span class="token punctuation">)</span> $<span class="token punctuation">(</span>ASFLAGS<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>o $@##############    链接所有目标文件    #############$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>kernel<span class="token punctuation">.</span>bin<span class="token operator">:</span> $<span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span>$<span class="token punctuation">(</span>LD<span class="token punctuation">)</span> $<span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> $<span class="token operator">^</span> <span class="token operator">-</span>o $@<span class="token punctuation">.</span>PHONY <span class="token operator">:</span> mk_dir hd clean allmk_dir<span class="token operator">:</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token operator">-</span>d $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> then mkdir $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token punctuation">;</span> fihd<span class="token operator">:</span>dd <span class="token keyword">if</span><span class="token operator">=</span>$<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token operator">/</span>kernel<span class="token punctuation">.</span>bin \           of<span class="token operator">=</span><span class="token operator">/</span>home<span class="token operator">/</span>cooiboi<span class="token operator">/</span>bochs<span class="token operator">/</span>hd60M<span class="token punctuation">.</span>img \           bs<span class="token operator">=</span><span class="token number">512</span> count<span class="token operator">=</span><span class="token number">200</span> seek<span class="token operator">=</span><span class="token number">9</span> conv<span class="token operator">=</span>notruncclean<span class="token operator">:</span>cd $<span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> rm <span class="token operator">-</span>f  <span class="token punctuation">.</span><span class="token comment">/*build: $(BUILD_DIR)/kernel.binall: mk_dir build hd</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意，这样的代码会抛出GP异常，我们会在下一张实现锁来防止错乱。</p><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="关于锁的概念"><a href="#关于锁的概念" class="headerlink" title="关于锁的概念"></a>关于锁的概念</h2><p>​        <strong>公共资源：可以是公共内存、公共文件、公共硬件等，总之是被所有任务共享的一套资源。</strong></p><p>​        <strong>互斥：互斥也可称为排他，是指某一时刻公共资源只能被1个任务独享，其他任务想访问公共资源时，必须等待当前公共资源的访问者使用完资源后再开始访问。</strong></p><p>​        <strong>临界区：程序要想使用某些资源，必然通过一些指令去访问这些资源，若多个任务都访问同一公共资源，那么各任务中访问公共资源的指令代码组成的区域就称为临界区。强调一下，临界区是指程序中那些访问公共资源的指令代码，即临界区是指令，并不是受访的静态公共资源。</strong></p><p>​        <strong>竞争条件：竞争条件是指多个任务以非互斥的方式同时进入临界区，大家对公共资源的访问是以竞争的方式并行进行的，因此公共资源的最终状态依赖于这些任务的临界区中的微操作执行次序。</strong></p><p>​        所以同步机制的核心，就是让公共资源在某一时刻只能被一个线程的临界区所访问，并且要让它执行完。</p><p>​        围绕上面的目的，我们提出信号量的概念，它实质就是个计数器，有真实含义（如某个资源的数量），常见取值是0与1。当某个进程的临界区需要访问公共资源，就要去查询这个公共资源的信号量，只有信号量&gt;0时（一般就是1），也就是资源可用，才能访问公共资源，此时该公共资源的信号量被减为0。另个进程此时要来访问这个公共资源，发现信号量为0，也就意味着自己需要的资源不可用，但是进程没有所需要的资源，就无法继续推进，所以最好的方法不是让进程在此处死等，而是将自己换下处理器让出处理器，这就是把自己阻塞起来，等待信号量为1后才能被唤醒运行。我们把只有0和1两种情况的信号量叫做二元信号量。</p><p>​        所以，同步机制的核心，现在就变成了，获得信号量的进程才可以运行，没有获得信号量的进程把自己阻塞起来，获得信号量的进程运行完毕释放信号量的时候，要把阻塞起来的进程唤醒，唤醒就是把阻塞进程的pcb从信号量的阻塞队列移入就绪队列。</p><p>​        为了实现同步机制，我们先实现两个函数thread_block与thread_unlock，前者用于将进程阻塞起来，实现原理就是将线程的pcb中的状态字段修改，然后使用调度schedule函数（后面需要修改其对于BLOCKED线程的调度策略）；后者用于将进程解除阻塞，原理就是修改pcb的状态字段，然后将线程的pcb放入就绪队列队首（为了尽快调度）。这两个函数均不涉及对某信号量的阻塞队列的操作，我们在别处实现</p><p>​        我们先再加上我们的thread.c, thread.h</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">thread_block</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">task_status</span> stat<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//设置block状态的参数必须是下面三个以下的</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>stat <span class="token operator">==</span> TASK_BLOCKED<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>stat <span class="token operator">==</span> TASK_WAITING<span class="token punctuation">)</span> <span class="token operator">||</span> stat <span class="token operator">==</span> TASK_HANGING<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//关中断</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur_thread <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     cur_thread<span class="token operator">-></span>status <span class="token operator">=</span> stat<span class="token punctuation">;</span> <span class="token comment">//把状态重新设置</span>        <span class="token comment">//调度器切换其他进程了 而且由于status不是running 不会再被放到就绪队列中</span>    <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//被切换回来之后再进行的指令了</span>    <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//由锁拥有者来执行的 善良者把原来自我阻塞的线程重新放到队列中</span><span class="token keyword">void</span> <span class="token function">thread_unblock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>status <span class="token operator">==</span> TASK_BLOCKED<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>pthread<span class="token operator">-></span>status <span class="token operator">==</span> TASK_WAITING<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>pthread<span class="token operator">-></span>status <span class="token operator">==</span> TASK_HANGING<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>status <span class="token operator">!=</span> TASK_READY<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token comment">//被阻塞线程 不应该存在于就绪队列中）</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>pthread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>pthread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"thread_unblock: blocked thread in ready_list\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//debug.h中定义过</span>        <span class="token comment">//让阻塞了很久的任务放在就绪队列最前面</span>    <span class="token function">list_push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span><span class="token operator">&amp;</span>pthread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//状态改为就绪态</span>    pthread<span class="token operator">-></span>status <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">thread_block</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">task_status</span> stat<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">thread_unblock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        接下来我们要实现锁机制，来实现对二元信号量的有序分配。首先为信号量与锁建立数据结构。信号量与锁的关系：信号量是对某项资源的管理，实际就是表示资源有多少，与哪些线程在等待这个资源。锁是在信号量机制上实现的，相比信号量多了记录谁造成了锁（也就是二元信号量，或者叫资源分配给了谁）</p><h3 id="sync-c-sync-h"><a href="#sync-c-sync-h" class="headerlink" title="sync.c/ sync.h"></a>sync.c/ sync.h</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __THREAD_SYNC_H#define __THREAD_SYNC_H#include &quot;list.h&quot;#include &quot;stdint.h&quot;#include &quot;thread.h&quot;&#x2F;* 信号量结构 *&#x2F;struct semaphore &#123;   uint8_t  value;              &#x2F;&#x2F;一个信号量肯定有值来表示这个量   struct   list waiters;       &#x2F;&#x2F;用一个双链表结点来管理所有阻塞在该信号量上的线程&#125;;&#x2F;* 锁结构 *&#x2F;struct lock &#123;   struct   task_struct* holder;    &#x2F;&#x2F;用于记录谁把二元信号量申请走了，而导致了该信号量的锁   struct   semaphore semaphore;    &#x2F;&#x2F;一个锁肯定是来管理信号量的   uint32_t holder_repeat_nr;    &#x2F;&#x2F;有时候线程拿到了信号量，但是线程内部不止一次使用该信号量对应公共资源，就会不止一次申请锁                                        &#x2F;&#x2F;内外层函数在释放锁时就会对一个锁释放多次，所以必须要记录重复申请的次数&#125;;void sema_init(struct semaphore* psema, uint8_t value); void sema_down(struct semaphore* psema);void sema_up(struct semaphore* psema);void lock_init(struct lock* plock);void lock_acquire(struct lock* plock);void lock_release(struct lock* plock);#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;sync.h&quot;#include &quot;list.h&quot;#include &quot;global.h&quot;#include &quot;debug.h&quot;#include &quot;interrupt.h&quot;&#x2F;&#x2F;用于初始化信号量，传入参数就是指向信号量的指针与初值void sema_init(struct semaphore* psema, uint8_t value) &#123;   psema-&gt;value &#x3D; value;       &#x2F;&#x2F; 为信号量赋初值   list_init(&amp;psema-&gt;waiters); &#x2F;&#x2F;初始化信号量的等待队列&#125;&#x2F;&#x2F;用于初始化锁，传入参数是指向该锁的指针void lock_init(struct lock* plock) &#123;   plock-&gt;holder &#x3D; NULL;   plock-&gt;holder_repeat_nr &#x3D; 0;   sema_init(&amp;plock-&gt;semaphore, 1); &#x2F;&#x2F;将信号量初始化为1，因为此函数一般处理二元信号量&#125;&#x2F;&#x2F;信号量的down操作，也就是减1操作，传入参数是指向要操作的信号量指针。线程想要申请信号量的时候用此函数void sema_down(struct semaphore* psema) &#123;   enum intr_status old_status &#x3D; intr_disable();         &#x2F;&#x2F;对于信号量的操作是必须关中断的   &#x2F;&#x2F;一个自旋锁，来不断判断是否信号量已经被分配出去了。为什么不用if，见书p450。    while(psema-&gt;value &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; 若value为0,表示已经被别人持有        ASSERT(!elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag));        &#x2F;* 当前线程不应该已在信号量的waiters队列中 *&#x2F;        if (elem_find(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag)) &#123;        PANIC(&quot;sema_down: thread blocked has been in waiters_list\n&quot;);        &#125;        &#x2F;&#x2F;如果此时信号量为0，那么就将该线程加入阻塞队列,为什么不用判断是否在阻塞队列中呢？因为线程被阻塞后，会加入阻塞队列，除非被唤醒，否则不会        &#x2F;&#x2F;分配到处理器资源，自然也不会重复判断是否有信号量，也不会重复加入阻塞队列        list_append(&amp;psema-&gt;waiters, &amp;running_thread()-&gt;general_tag);         thread_block(TASK_BLOCKED);    &#x2F;&#x2F; 阻塞线程,直到被唤醒    &#125;&#x2F;* 若value为1或被唤醒后,会执行下面的代码,也就是获得了锁。*&#x2F;    psema-&gt;value--;    ASSERT(psema-&gt;value &#x3D;&#x3D; 0);    &#x2F;* 恢复之前的中断状态 *&#x2F;    intr_set_status(old_status);&#125;&#x2F;&#x2F;信号量的up操作，也就是+1操作，传入参数是指向要操作的信号量的指针。且释放信号量时，应唤醒阻塞在该信号量阻塞队列上的一个进程void sema_up(struct semaphore* psema) &#123;&#x2F;* 关中断,保证原子操作 *&#x2F;   enum intr_status old_status &#x3D; intr_disable();   ASSERT(psema-&gt;value &#x3D;&#x3D; 0);       if (!list_empty(&amp;psema-&gt;waiters)) &#123;   &#x2F;&#x2F;判断信号量阻塞队列应为非空，这样才能执行唤醒操作      struct task_struct* thread_blocked &#x3D; elem2entry(struct task_struct, general_tag, list_pop(&amp;psema-&gt;waiters));      thread_unblock(thread_blocked);   &#125;   psema-&gt;value++;   ASSERT(psema-&gt;value &#x3D;&#x3D; 1);    &#x2F;* 恢复之前的中断状态 *&#x2F;   intr_set_status(old_status);&#125;&#x2F;&#x2F;获取锁的函数,传入参数是指向锁的指针void lock_acquire(struct lock* plock) &#123;&#x2F;&#x2F;这是为了排除掉线程自己已经拿到了锁，但是还没有释放就重新申请的情况   if (plock-&gt;holder !&#x3D; running_thread()) &#123;         sema_down(&amp;plock-&gt;semaphore);    &#x2F;&#x2F;对信号量进行down操作        plock-&gt;holder &#x3D; running_thread();        ASSERT(plock-&gt;holder_repeat_nr &#x3D;&#x3D; 0);        plock-&gt;holder_repeat_nr &#x3D; 1;    &#x2F;&#x2F;申请了一次锁   &#125; else &#123;        plock-&gt;holder_repeat_nr++;   &#125;&#125;&#x2F;&#x2F;释放锁的函数，参数是指向锁的指针void lock_release(struct lock* plock) &#123;   ASSERT(plock-&gt;holder &#x3D;&#x3D; running_thread());   &#x2F;&#x2F;如果&gt;1，说明自己多次申请了该锁，现在还不能立即释放锁   if (plock-&gt;holder_repeat_nr &gt; 1) &#123;         plock-&gt;holder_repeat_nr--;      return;   &#125;   ASSERT(plock-&gt;holder_repeat_nr &#x3D;&#x3D; 1);    &#x2F;&#x2F;判断现在lock的重复持有数是不是1只有为1，才能释放   plock-&gt;holder &#x3D; NULL;   &#x2F;&#x2F;这句必须放在up操作前，因为现在并不在关中断下运行，有可能会被切换出去，如果在up后面，就可能出现还没有置空，就切换出去，此时有了信号量，下个进程申请到了，将holder改成下个进程，这个进程切换回来就把holder改成空，就错了   plock-&gt;holder_repeat_nr &#x3D; 0;   sema_up(&amp;plock-&gt;semaphore);   &#x2F;&#x2F; 信号量的V操作,也是原子操作&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，我们利用锁机制，建立锁console_lock（意为终端锁）用于协调打印，将原有的put_int，put_char，put_str进行封装。</p><h3 id="device-console-c-console-h"><a href="#device-console-c-console-h" class="headerlink" title="device/console.c, console.h"></a>device/console.c, console.h</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sync.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">lock</span> console_lock<span class="token punctuation">;</span>    <span class="token comment">// 控制台锁</span><span class="token comment">/* 初始化终端 */</span><span class="token keyword">void</span> <span class="token function">console_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>console_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token comment">/* 获取终端 */</span><span class="token keyword">void</span> <span class="token function">console_acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>console_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 释放终端 */</span><span class="token keyword">void</span> <span class="token function">console_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>console_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 终端中输出字符串 */</span><span class="token keyword">void</span> <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">console_acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">console_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 终端中输出字符 */</span><span class="token keyword">void</span> <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> char_asci<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">console_acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_char</span><span class="token punctuation">(</span>char_asci<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">console_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 终端中输出16进制整数 */</span><span class="token keyword">void</span> <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> num<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">console_acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_int</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">console_release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef __DEVICE_CONSOLE_H#define __DEVICE_CONSOLE_H#include &quot;stdint.h&quot;void console_init(void);void console_acquire(void);void console_release(void);void console_put_str(char* str);void console_put_char(uint8_t char_asci);void console_put_int(uint32_t num);#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        放进init.c</p><h3 id="init-c"><a href="#init-c" class="headerlink" title="init.c"></a>init.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;init.h&quot;#include &quot;print.h&quot;#include &quot;interrupt.h&quot;#include &quot;timer.h&quot;#include &quot;memory.h&quot;#include &quot;thread.h&quot;#include &quot;console.h&quot;&#x2F;*负责初始化所有模块 *&#x2F;void init_all() &#123;   put_str(&quot;init_all\n&quot;);   idt_init();   &#x2F;&#x2F;初始化中断   mem_init();  &#x2F;&#x2F; 初始化内存管理系统   thread_init(); &#x2F;&#x2F; 初始化线程相关结构   timer_init();     console_init();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="main-c-3"><a href="#main-c-3" class="headerlink" title="main.c"></a>main.c</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;print.h&quot;#include &quot;init.h&quot;#include &quot;thread.h&quot;#include &quot;interrupt.h&quot;#include &quot;console.h&quot;void k_thread_a(void*);void k_thread_b(void*);int main(void) &#123;   put_str(&quot;I am kernel\n&quot;);   init_all();   thread_start(&quot;k_thread_a&quot;, 31, k_thread_a, &quot;argA &quot;);   thread_start(&quot;k_thread_b&quot;, 8, k_thread_b, &quot;argB &quot;);   intr_enable();   while(1) &#123;      console_put_str(&quot;Main &quot;);   &#125;;   return 0;&#125;&#x2F;* 在线程中运行的函数 *&#x2F;void k_thread_a(void* arg) &#123;     &#x2F;* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 *&#x2F;   char* para &#x3D; arg;   while(1) &#123;      console_put_str(para);   &#125;&#125;&#x2F;* 在线程中运行的函数 *&#x2F;void k_thread_b(void* arg) &#123;     &#x2F;* 用void*来通用表示参数,被调用的函数知道自己需要什么类型的参数,自己转换再用 *&#x2F;   char* para &#x3D; arg;   while(1) &#123;      console_put_str(para);   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="键盘驱动"><a href="#键盘驱动" class="headerlink" title="键盘驱动"></a>键盘驱动</h2><p>​        在键盘内部，会有一个8048芯片，主板内部有8042芯片，当我们按下某个键/松开某个键，8048就会报告这个按键的按下与松开情况给8042，然后8042向中断控制器发送信号。<br><img src="42983122991a420eb83b6bdd18c1d94f.png" alt="在这里插入图片描述"><br>键盘按下键位后的流程：</p><p>1、当键位被按下(不弹起)<br>​ 2、8048 监控哪个键位被按下，8048 把键位对应的通码（用于描述一个键按下的码，断码就是描述一个键松开的码）发送给 8042，如果不松开，那么就持续发送<br>​ 3、8042 接收到通码后，便知道具体哪个键位被按下了，对其进行处理，接着保存通码到自己的寄存器<br>​ 4、8042 接着向中断代理 8259A 发送中断，如果不松开，那么就持续发送中断<br>​ 5、发生中断后，处理器执行对应的中断处理程序</p><p>键位弹起的过程和按下的过程一致。</p><p>扫描码（通码与断码合称扫描码）由键盘编码器决定，不同的键盘编码器会产生不同的编码方案，如今有三套：</p><p>scan code set 1, 应用：XT 键盘<br>​ scan code set 2, 应用：AT 键盘<br>​ scan code set 3, 应用：IBM PS/2 系列高端计算机所用键盘</p><p>现在大多数用的都是第二套，因此大多数键盘向 8042 发生的都是第二套的扫描码，为了兼容，不管我们用的是第几套编码方案，当键盘发送扫描码到 8042 后，由 8042 进行处理，转为第一套扫描码，这也是 8042 存在的理由之一。因此我们只需要在键盘的中断处理程序中只处理第一套扫描码就可以了。</p><p><strong>p465、p466、p467剖析代码kernel.S、interrupt.c、main.c、keyboard.c：</strong></p><p><strong>1、代码功能</strong></p><p>按下键盘任意键后，屏幕上打印字符k，如果一直按住不松开，那么就连续打印</p><p><strong>2、实现原理</strong></p><p>键盘信号最后都是由中断处理器来处理，最后都是由对应的中断处理函数来处理</p><p><strong>3、代码逻辑</strong></p><p><strong>A</strong>、为键盘中断建立中断处理函数</p><p><strong>B</strong>、设定中断控制器，打开键盘中断信号</p><p><strong>4、怎么写代码？</strong></p><p><strong>A</strong>、kernel.S：增加用汇编模板定义的汇编中断函数处理入口</p><p><strong>B</strong>、kerboard.c：写出键盘中断处理函数intr_keyboard_handler；写出键盘初始化函数keyboard_init（调用中断注册函数注册键盘中断处理函数），并将其封装进入init_all</p><p><strong>C</strong>、interrupt.c：修改支持中断数量；修改中断控制器初始化代码pic_inic，只打开键盘中断（键盘中断信号接在主片的IR1引脚上）</p><p><strong>D</strong>、写出测试代码main.c，就是一个死循环</p><p>​        我们先扩展中断向量表：</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">[bits 32]%define ERROR_CODE nop ; 若在相关的异常中cpu已经自动压入了错误码,为保持栈中格式统一,这里不做操作.%define ZERO push 0 ; 若在相关的异常中cpu没有压入错误码,为了统一栈中格式,就手工压入一个0extern put_str;extern idt_table;section .dataglobal intr_entry_tableintr_entry_table:%macro VECTOR 2section .textintr%1entry: ; 每个中断处理程序都要压入中断向量号,所以一个中断类型一个中断处理程序，自己知道自己的中断向量号是多少   %2 ; 中断若有错误码会压在eip后面 ; 以下是保存上下文环境   push ds   push es   push fs   push gs   pushad ; PUSHAD指令压入32位寄存器,其入栈顺序是: EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI   ; 如果是从片上进入的中断,除了往从片上发送EOI外,还要往主片上发送EOI    mov al,0x20                   ; 中断结束命令EOI   out 0xa0,al                   ; 向从片发送   out 0x20,al                   ; 向主片发送   push %1 ; 不管idt_table中的目标程序是否需要参数,都一律压入中断向量号,调试时很方便   call [idt_table + %1*4]       ; 调用idt_table中的C版本中断处理函数   jmp intr_exitsection .data   dd    intr%1entry ; 存储各个中断入口程序的地址，形成intr_entry_table数组%endmacrosection .textglobal intr_exitintr_exit:     ; 以下是恢复上下文环境   add esp, 4   ; 跳过中断号   popad   pop gs   pop fs   pop es   pop ds   add esp, 4   ; 跳过error_code   iretdVECTOR 0x0 ,ZEROVECTOR 0X1 ,ZEROVECTOR 0X2 ,ZEROVECTOR 0x3 ,ZEROVECTOR 0X4 ,ZEROVECTOR 0X5 ,ZEROVECTOR 0x6 ,ZEROVECTOR 0X7 ,ZEROVECTOR 0X8 ,ERROR_CODEVECTOR 0x9 ,ZEROVECTOR 0XA ,ERROR_CODEVECTOR 0XB ,ERROR_CODEVECTOR 0XC ,ERROR_CODEVECTOR 0XD ,ERROR_CODEVECTOR 0XE ,ERROR_CODEVECTOR 0XF ,ZEROVECTOR 0X10 ,ZEROVECTOR 0X11 ,ERROR_CODEVECTOR 0x12 ,ZEROVECTOR 0X13 ,ZEROVECTOR 0X14 ,ZEROVECTOR 0x15 ,ZEROVECTOR 0X16 ,ZEROVECTOR 0X17 ,ZEROVECTOR 0X18 ,ZEROVECTOR 0X19 ,ZEROVECTOR 0X1A ,ZEROVECTOR 0X1B ,ZEROVECTOR 0X1C ,ZEROVECTOR 0X1D ,ZEROVECTOR 0X1E ,ERROR_CODE                               ;处理器自动推错误码VECTOR 0X1F ,ZEROVECTOR 0X20 ,ZERO;时钟中断VECTOR 0X21 ,ZERO;键盘中断VECTOR 0X22 ,ZERO;级联VECTOR 0X23 ,ZERO;串口2VECTOR 0X24 ,ZERO;串口1VECTOR 0X25 ,ZERO;并口2VECTOR 0X26 ,ZERO;软盘VECTOR 0X27 ,ZERO;并口1VECTOR 0X28 ,ZERO;实时时钟VECTOR 0X29 ,ZERO;重定向VECTOR 0X2A ,ZERO;保留VECTOR 0x2B ,ZERO;保留VECTOR 0x2C ,ZERO;ps&#x2F;2 鼠标VECTOR 0x2D ,ZERO;fpu 浮点单元异常VECTOR 0x2E ,ZERO;硬盘VECTOR 0x2F ,ZERO;保留<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="修改interrupt-c"><a href="#修改interrupt-c" class="headerlink" title="修改interrupt.c"></a>修改interrupt.c</h4><hr><p><strong>主要修改这两个地方</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IDT_DESC_CNT</span> <span class="token expression"><span class="token number">0x30</span>       </span><span class="token comment">// 目前总共支持的中断数</span></span><span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0xfd</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里修改了 只打开键盘中断</span><span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="编写keyboard-c"><a href="#编写keyboard-c" class="headerlink" title="编写keyboard.c"></a>编写keyboard.c</h4><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"keyboard.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"io.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KBD_BUF_PORT</span> <span class="token expression"><span class="token number">0X60</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KBD_BUF_PORT</span> <span class="token expression"><span class="token number">0X60</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">esc</span> <span class="token char">'\033'</span><span class="token comment">//esc 和 delete都没有</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">delete</span> <span class="token char">'\0177'</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">enter</span> <span class="token char">'\r'</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">tab</span> <span class="token char">'\t'</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">backspace</span> <span class="token char">'\b'</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">char_invisible</span> <span class="token expression"><span class="token number">0</span></span><span class="token comment">//功能性 不可见字符均设置为0</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_l_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_r_char</span> <span class="token expression">char_invisible </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">shift_l_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">shift_r_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_l_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_r_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">caps_lock_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">shift_l_make</span> <span class="token expression"><span class="token number">0x2a</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">shift_r_make</span> <span class="token expression"><span class="token number">0x36</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_l_make</span> <span class="token expression"><span class="token number">0x38</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_r_make</span> <span class="token expression"><span class="token number">0xe038</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_r_break</span> <span class="token expression"><span class="token number">0xe0b8</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_l_make</span> <span class="token expression"><span class="token number">0x1d</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_r_make</span> <span class="token expression"><span class="token number">0xe01d</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_r_break</span> <span class="token expression"><span class="token number">0xe09d</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">caps_lock_make</span> <span class="token expression"><span class="token number">0x3a</span></span></span>bool ctrl_status <span class="token operator">=</span> false<span class="token punctuation">,</span>shift_status <span class="token operator">=</span> false<span class="token punctuation">,</span>alt_status <span class="token operator">=</span> false<span class="token punctuation">,</span>caps_lock_status <span class="token operator">=</span> false<span class="token punctuation">,</span>ext_scancode <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token comment">// 键值映射</span><span class="token keyword">char</span> keymap<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token comment">/* 0x00 */</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x01 */</span><span class="token punctuation">&#123;</span>esc<span class="token punctuation">,</span>esc<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x02 */</span><span class="token punctuation">&#123;</span><span class="token char">'1'</span><span class="token punctuation">,</span><span class="token char">'!'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x03 */</span><span class="token punctuation">&#123;</span><span class="token char">'2'</span><span class="token punctuation">,</span><span class="token char">'@'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x04 */</span><span class="token punctuation">&#123;</span><span class="token char">'3'</span><span class="token punctuation">,</span><span class="token char">'#'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x05 */</span><span class="token punctuation">&#123;</span><span class="token char">'4'</span><span class="token punctuation">,</span><span class="token char">'$'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x06 */</span><span class="token punctuation">&#123;</span><span class="token char">'5'</span><span class="token punctuation">,</span><span class="token char">'%'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x07 */</span><span class="token punctuation">&#123;</span><span class="token char">'6'</span><span class="token punctuation">,</span><span class="token char">'^'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x08 */</span><span class="token punctuation">&#123;</span><span class="token char">'7'</span><span class="token punctuation">,</span><span class="token char">'&amp;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x09 */</span><span class="token punctuation">&#123;</span><span class="token char">'8'</span><span class="token punctuation">,</span><span class="token char">'*'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0A */</span><span class="token punctuation">&#123;</span><span class="token char">'9'</span><span class="token punctuation">,</span><span class="token char">'('</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0B */</span><span class="token punctuation">&#123;</span><span class="token char">'0'</span><span class="token punctuation">,</span><span class="token char">')'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0C */</span><span class="token punctuation">&#123;</span><span class="token char">'-'</span><span class="token punctuation">,</span><span class="token char">'_'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0D */</span><span class="token punctuation">&#123;</span><span class="token char">'='</span><span class="token punctuation">,</span><span class="token char">'+'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0E */</span><span class="token punctuation">&#123;</span>backspace<span class="token punctuation">,</span> backspace<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0F */</span><span class="token punctuation">&#123;</span>tab<span class="token punctuation">,</span>tab<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x10 */</span><span class="token punctuation">&#123;</span><span class="token char">'q'</span><span class="token punctuation">,</span><span class="token char">'Q'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x11 */</span><span class="token punctuation">&#123;</span><span class="token char">'w'</span><span class="token punctuation">,</span><span class="token char">'W'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x12 */</span><span class="token punctuation">&#123;</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'E'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x13 */</span><span class="token punctuation">&#123;</span><span class="token char">'r'</span><span class="token punctuation">,</span><span class="token char">'R'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x14 */</span><span class="token punctuation">&#123;</span><span class="token char">'t'</span><span class="token punctuation">,</span><span class="token char">'T'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x15 */</span><span class="token punctuation">&#123;</span><span class="token char">'y'</span><span class="token punctuation">,</span><span class="token char">'Y'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x16 */</span><span class="token punctuation">&#123;</span><span class="token char">'u'</span><span class="token punctuation">,</span><span class="token char">'U'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x17 */</span><span class="token punctuation">&#123;</span><span class="token char">'i'</span><span class="token punctuation">,</span><span class="token char">'I'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x18 */</span><span class="token punctuation">&#123;</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">'O'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x19 */</span><span class="token punctuation">&#123;</span><span class="token char">'p'</span><span class="token punctuation">,</span><span class="token char">'P'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1A */</span><span class="token punctuation">&#123;</span><span class="token char">'['</span><span class="token punctuation">,</span><span class="token char">'&#123;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1B */</span><span class="token punctuation">&#123;</span><span class="token char">']'</span><span class="token punctuation">,</span><span class="token char">'&#125;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1C */</span><span class="token punctuation">&#123;</span>enter<span class="token punctuation">,</span>  enter<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1D */</span><span class="token punctuation">&#123;</span>ctrl_l_char<span class="token punctuation">,</span> ctrl_l_char<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1E */</span><span class="token punctuation">&#123;</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'A'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1F */</span><span class="token punctuation">&#123;</span><span class="token char">'s'</span><span class="token punctuation">,</span><span class="token char">'S'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x20 */</span><span class="token punctuation">&#123;</span><span class="token char">'d'</span><span class="token punctuation">,</span><span class="token char">'D'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x21 */</span><span class="token punctuation">&#123;</span><span class="token char">'f'</span><span class="token punctuation">,</span><span class="token char">'F'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x22 */</span><span class="token punctuation">&#123;</span><span class="token char">'g'</span><span class="token punctuation">,</span><span class="token char">'G'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x23 */</span><span class="token punctuation">&#123;</span><span class="token char">'h'</span><span class="token punctuation">,</span><span class="token char">'H'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x24 */</span><span class="token punctuation">&#123;</span><span class="token char">'j'</span><span class="token punctuation">,</span><span class="token char">'J'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x25 */</span><span class="token punctuation">&#123;</span><span class="token char">'k'</span><span class="token punctuation">,</span><span class="token char">'K'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x26 */</span><span class="token punctuation">&#123;</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'L'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x27 */</span><span class="token punctuation">&#123;</span><span class="token char">';'</span><span class="token punctuation">,</span><span class="token char">':'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x28 */</span><span class="token punctuation">&#123;</span><span class="token char">'\''</span><span class="token punctuation">,</span><span class="token char">'"'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x29 */</span><span class="token punctuation">&#123;</span><span class="token char">'`'</span><span class="token punctuation">,</span><span class="token char">'~'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2A */</span><span class="token punctuation">&#123;</span>shift_l_char<span class="token punctuation">,</span> shift_l_char<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2B */</span><span class="token punctuation">&#123;</span><span class="token char">'\\'</span><span class="token punctuation">,</span><span class="token char">'|'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2C */</span><span class="token punctuation">&#123;</span><span class="token char">'z'</span><span class="token punctuation">,</span><span class="token char">'Z'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2D */</span><span class="token punctuation">&#123;</span><span class="token char">'x'</span><span class="token punctuation">,</span><span class="token char">'X'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2E */</span><span class="token punctuation">&#123;</span><span class="token char">'c'</span><span class="token punctuation">,</span><span class="token char">'C'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2F */</span><span class="token punctuation">&#123;</span><span class="token char">'v'</span><span class="token punctuation">,</span><span class="token char">'V'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x30 */</span><span class="token punctuation">&#123;</span><span class="token char">'b'</span><span class="token punctuation">,</span><span class="token char">'B'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x31 */</span><span class="token punctuation">&#123;</span><span class="token char">'n'</span><span class="token punctuation">,</span><span class="token char">'N'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x32 */</span><span class="token punctuation">&#123;</span><span class="token char">'m'</span><span class="token punctuation">,</span><span class="token char">'M'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x33 */</span><span class="token punctuation">&#123;</span><span class="token char">','</span><span class="token punctuation">,</span><span class="token char">'&lt;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x34 */</span><span class="token punctuation">&#123;</span><span class="token char">'.'</span><span class="token punctuation">,</span><span class="token char">'>'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x35 */</span><span class="token punctuation">&#123;</span><span class="token char">'/'</span><span class="token punctuation">,</span><span class="token char">'?'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x36*/</span><span class="token punctuation">&#123;</span>shift_r_char<span class="token punctuation">,</span> shift_r_char<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x37 */</span><span class="token punctuation">&#123;</span><span class="token char">'*'</span><span class="token punctuation">,</span><span class="token char">'*'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">/* 0x38 */</span><span class="token punctuation">&#123;</span>alt_l_char<span class="token punctuation">,</span> alt_l_char<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x39 */</span><span class="token punctuation">&#123;</span><span class="token char">' '</span><span class="token punctuation">,</span><span class="token char">' '</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x3A */</span><span class="token punctuation">&#123;</span>caps_lock_char<span class="token punctuation">,</span> caps_lock_char<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"keyboard init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">register_handler</span><span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">,</span>intr_keyboard_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"keyboard init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">intr_keyboard_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    bool ctrl_down_last <span class="token operator">=</span> ctrl_status<span class="token punctuation">;</span>    bool shift_down_last <span class="token operator">=</span> shift_status<span class="token punctuation">;</span>    bool caps_lock_last <span class="token operator">=</span> caps_lock_status<span class="token punctuation">;</span>        bool break_code<span class="token punctuation">;</span>    <span class="token class-name">uint16_t</span> scancode <span class="token operator">=</span> <span class="token function">inb</span><span class="token punctuation">(</span>KBD_BUF_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0xe0</span><span class="token punctuation">)</span><span class="token comment">//多字节处理</span>    <span class="token punctuation">&#123;</span>    ext_scancode <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        break_code <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>scancode <span class="token operator">&amp;</span> <span class="token number">0x0080</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//断码 = 通码 + 0x80 通码最小比0x80小 则只有断码才可以有</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>break_code<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token class-name">uint16_t</span> make_code <span class="token operator">=</span> <span class="token punctuation">(</span>scancode <span class="token operator">&amp;=</span> <span class="token number">0xff7f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//多字节不处理</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>make_code <span class="token operator">==</span> ctrl_l_make <span class="token operator">||</span> make_code <span class="token operator">==</span> ctrl_r_make<span class="token punctuation">)</span> ctrl_status <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>make_code <span class="token operator">==</span> shift_l_make <span class="token operator">||</span> make_code <span class="token operator">==</span> shift_r_make<span class="token punctuation">)</span> shift_status <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>make_code <span class="token operator">==</span> alt_l_make <span class="token operator">||</span> make_code <span class="token operator">==</span> alt_r_make<span class="token punctuation">)</span> alt_status <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>scancode <span class="token operator">></span> <span class="token number">0x00</span> <span class="token operator">&amp;&amp;</span> scancode <span class="token operator">&lt;</span> <span class="token number">0x3b</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> alt_r_make<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> ctrl_r_make<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    bool shift <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">//先默认设置成false</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>scancode <span class="token operator">&lt;</span> <span class="token number">0x0e</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x29</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x1a</span><span class="token punctuation">)</span> <span class="token operator">||</span> \    <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x1b</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x2b</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x27</span><span class="token punctuation">)</span> <span class="token operator">||</span> \    <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x28</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x33</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x34</span><span class="token punctuation">)</span> <span class="token operator">||</span> \    <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x35</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>shift_down_last<span class="token punctuation">)</span>shift <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>shift_down_last <span class="token operator">&amp;&amp;</span> caps_lock_last<span class="token punctuation">)</span>shift <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">//效果确实是这样子的 我试了一下</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>shift_down_last <span class="token operator">||</span> caps_lock_last<span class="token punctuation">)</span> shift <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">//其中任意一个都是大写的作用</span>        <span class="token keyword">else</span> shift <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token class-name">uint8_t</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>scancode <span class="token operator">&amp;</span> <span class="token number">0x00ff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> cur_char <span class="token operator">=</span> keymap<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>shift<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur_char<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>        <span class="token function">put_char</span><span class="token punctuation">(</span>cur_char<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> ctrl_l_make <span class="token operator">||</span> scancode <span class="token operator">==</span> ctrl_r_make<span class="token punctuation">)</span>        ctrl_status <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> shift_l_make <span class="token operator">||</span> scancode <span class="token operator">==</span> shift_r_make<span class="token punctuation">)</span>            shift_status <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> alt_l_make <span class="token operator">||</span> scancode <span class="token operator">==</span> alt_r_make<span class="token punctuation">)</span>    alt_status <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> caps_lock_make<span class="token punctuation">)</span>    caps_lock_status <span class="token operator">=</span> <span class="token operator">!</span>caps_lock_status<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"unknown key\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="编写keyboard-h"><a href="#编写keyboard-h" class="headerlink" title="编写keyboard.h"></a>编写keyboard.h</h4><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__DEVICE_KEYBOARD_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__DEVICE_KEYBOARD_H</span></span><span class="token keyword">void</span> <span class="token function">intr_keyboard_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="修改main-c"><a href="#修改main-c" class="headerlink" title="修改main.c"></a>修改main.c</h4><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../thread/thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../device/console.h"</span></span><span class="token keyword">void</span> <span class="token function">test_thread1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test_thread2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//thread_start("kernel_thread_a",8,test_thread1,"Arga ");</span>   <span class="token comment">//thread_start("kernel_thread_b",8,test_thread2,"Argb ");</span>   <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/*&#123;   console_put_str("Main ");   &#125;*/</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test_thread1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test_thread2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="修改init-c"><a href="#修改init-c" class="headerlink" title="修改init.c"></a>修改init.c</h4><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../device/timer.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../thread/thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../device/console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../device/keyboard.h"</span></span><span class="token comment">/*负责初始化所有模块 */</span><span class="token keyword">void</span> <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"init_all\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">idt_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化中断</span>   <span class="token function">mem_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">timer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//新增</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="修改MakeFile"><a href="#修改MakeFile" class="headerlink" title="修改MakeFile"></a>修改MakeFile</h4><hr><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">BUILD_DIR <span class="token operator">=</span> ./buildENTRY_POINT <span class="token operator">=</span> 0xc0001500AS <span class="token operator">=</span> nasmCC <span class="token operator">=</span> gccLD <span class="token operator">=</span> ldLIB <span class="token operator">=</span> -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ ASFLAGS <span class="token operator">=</span> -f elfCFLAGS <span class="token operator">=</span> -Wall -m32 -fno-stack-protector <span class="token variable">$</span><span class="token punctuation">(</span>LIB<span class="token punctuation">)</span> -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypesLDFLAGS <span class="token operator">=</span>  -m elf_i386 -Ttext <span class="token variable">$</span><span class="token punctuation">(</span>ENTRY_POINT<span class="token punctuation">)</span> -e main -Map <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/kernel.mapOBJS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/main.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/init.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/interrupt.o \      <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/timer.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/kernel.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/print.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/switch.o \      <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/debug.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/string.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/memory.o \      <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/bitmap.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/thread.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/list.o \      <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/sync.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/console.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/keyboard.o      <span class="token comment">##############     c代码编译     ###############</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/main.o</span><span class="token punctuation">:</span> kernel/main.c lib/kernel/print.h \        lib/stdint.h kernel/init.h lib/string.h kernel/memory.h \        thread/thread.h kernel/interrupt.h device/console.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/init.o</span><span class="token punctuation">:</span> kernel/init.c kernel/init.h lib/kernel/print.h \        lib/stdint.h kernel/interrupt.h device/timer.h kernel/memory.h \        thread/thread.h device/console.h device/keyboard.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/interrupt.o</span><span class="token punctuation">:</span> kernel/interrupt.c kernel/interrupt.h \        lib/stdint.h kernel/global.h lib/kernel/io.h lib/kernel/print.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/timer.o</span><span class="token punctuation">:</span> device/timer.c device/timer.h lib/kernel/io.h lib/kernel/print.h \        kernel/interrupt.h thread/thread.h kernel/debug.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/debug.o</span><span class="token punctuation">:</span> kernel/debug.c kernel/debug.h \        lib/kernel/print.h lib/stdint.h kernel/interrupt.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/string.o</span><span class="token punctuation">:</span> lib/string.c lib/string.h \kernel/debug.h kernel/global.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/memory.o</span><span class="token punctuation">:</span> kernel/memory.c kernel/memory.h \lib/stdint.h lib/kernel/bitmap.h kernel/debug.h lib/string.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/bitmap.o</span><span class="token punctuation">:</span> lib/kernel/bitmap.c lib/kernel/bitmap.h kernel/global.h \lib/string.h kernel/interrupt.h lib/kernel/print.h kernel/debug.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/thread.o</span><span class="token punctuation">:</span> thread/thread.c thread/thread.h \lib/stdint.h lib/string.h kernel/global.h kernel/memory.h \kernel/debug.h kernel/interrupt.h lib/kernel/print.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/list.o</span><span class="token punctuation">:</span> lib/kernel/list.c lib/kernel/list.h \kernel/interrupt.h lib/stdint.h kernel/debug.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/sync.o</span><span class="token punctuation">:</span> thread/sync.c thread/sync.h \lib/stdint.h thread/thread.h kernel/debug.h kernel/interrupt.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/console.o</span><span class="token punctuation">:</span> device/console.c device/console.h \lib/kernel/print.h thread/sync.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/keyboard.o</span><span class="token punctuation">:</span> device/keyboard.c device/keyboard.h \lib/kernel/print.h lib/kernel/io.h kernel/interrupt.h \kernel/global.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment">##############    汇编代码编译    ###############</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/kernel.o</span><span class="token punctuation">:</span> kernel/kernel.S<span class="token variable">$</span><span class="token punctuation">(</span>AS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>ASFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/print.o</span><span class="token punctuation">:</span> lib/kernel/print.S<span class="token variable">$</span><span class="token punctuation">(</span>AS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>ASFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/switch.o</span><span class="token punctuation">:</span> thread/switch.S<span class="token variable">$</span><span class="token punctuation">(</span>AS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>ASFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment">##############    链接所有目标文件    #############</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/kernel.bin</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>LD<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> mk_dir hd clean all<span class="token target symbol">mk_dir</span><span class="token punctuation">:</span>if [ ! -d <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span> ]<span class="token punctuation">;</span> then mkdir <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token punctuation">;</span> fi<span class="token target symbol">hd</span><span class="token punctuation">:</span>dd if<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/kernel.bin \           of<span class="token operator">=</span>/home/cooiboi/bochs/hd60M.img \           bs<span class="token operator">=</span>512 count<span class="token operator">=</span>200 seek<span class="token operator">=</span>9 conv<span class="token operator">=</span>notrunc<span class="token target symbol">clean</span><span class="token punctuation">:</span>cd <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span> &amp;&amp; rm -f  ./*<span class="token target symbol">build</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/kernel.bin<span class="token target symbol">all</span><span class="token punctuation">:</span> mk_dir build hd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现环形缓冲区-生产者消费者"><a href="#实现环形缓冲区-生产者消费者" class="headerlink" title="实现环形缓冲区 生产者消费者"></a>实现环形缓冲区 生产者消费者</h3><hr><p>我们下面就是搞一下缓冲区，这是为了可以让指令可以完整的进行处理！</p><h4 id="编写ioqueue-h"><a href="#编写ioqueue-h" class="headerlink" title="编写ioqueue.h"></a>编写ioqueue.h</h4><hr><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__DEVICE__IOQUEUE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__DEVICE__IOQUEUE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../thread/thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../thread/sync.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">bufsize</span> <span class="token expression"><span class="token number">64</span></span></span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">lock</span> lock<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> consumer<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> producer<span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span>bufsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">uint32_t</span> head<span class="token punctuation">;</span><span class="token comment">//头部读入数据</span>    <span class="token keyword">uint32_t</span> tail<span class="token punctuation">;</span><span class="token comment">//尾部拿数据</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init_ioqueue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">uint32_t</span> <span class="token function">next_pos</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">ioq_full</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">ioq_empty</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ioq_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span><span class="token operator">*</span> waiter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//这里是waiter的二级指针 取二级指针的原因是这样可以对指针的地址值进行修改</span><span class="token keyword">void</span> <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span><span class="token operator">*</span> waiter<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">char</span> <span class="token function">ioq_getchar</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ioq_putchar</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">,</span><span class="token keyword">char</span> chr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="编写ioqueue-c"><a href="#编写ioqueue-c" class="headerlink" title="编写ioqueue.c"></a>编写ioqueue.c</h4><hr><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ioqueue.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token keyword">void</span> <span class="token function">init_ioqueue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioq<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    ioq<span class="token operator">-></span>consumer <span class="token operator">=</span> ioq<span class="token operator">-></span>producer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    ioq<span class="token operator">-></span>head <span class="token operator">=</span> ioq<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">uint32_t</span> <span class="token function">next_pos</span><span class="token punctuation">(</span><span class="token keyword">uint32_t</span> pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>bufsize<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">ioq_full</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> INTR_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">next_pos</span><span class="token punctuation">(</span>ioq<span class="token operator">-></span>head<span class="token punctuation">)</span> <span class="token operator">==</span> ioq<span class="token operator">-></span>tail<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token function">ioq_empty</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> INTR_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ioq<span class="token operator">-></span>head <span class="token operator">==</span> ioq<span class="token operator">-></span>tail<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">ioq_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span><span class="token operator">*</span> waiter<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>waiter <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>waiter <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>waiter <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_block</span><span class="token punctuation">(</span>TASK_BLOCKED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span><span class="token operator">*</span> waiter<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">*</span>waiter <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_unblock</span><span class="token punctuation">(</span><span class="token operator">*</span>waiter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>waiter <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span> <span class="token function">ioq_getchar</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> INTR_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//空的时候就需要动锁了 把另外的消费者卡住</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">ioq_empty</span><span class="token punctuation">(</span>ioq<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioq<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ioq_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioq<span class="token operator">-></span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioq<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">char</span> retchr <span class="token operator">=</span> ioq<span class="token operator">-></span>buf<span class="token punctuation">[</span>ioq<span class="token operator">-></span>tail<span class="token punctuation">]</span><span class="token punctuation">;</span>    ioq<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token function">next_pos</span><span class="token punctuation">(</span>ioq<span class="token operator">-></span>tail<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ioq<span class="token operator">-></span>producer<span class="token punctuation">)</span>    <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioq<span class="token operator">-></span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> retchr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">ioq_putchar</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span><span class="token operator">*</span> ioq<span class="token punctuation">,</span><span class="token keyword">char</span> chr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> INTR_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">ioq_full</span><span class="token punctuation">(</span>ioq<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioq<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ioq_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioq<span class="token operator">-></span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioq<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        ioq<span class="token operator">-></span>buf<span class="token punctuation">[</span>ioq<span class="token operator">-></span>head<span class="token punctuation">]</span> <span class="token operator">=</span> chr<span class="token punctuation">;</span>    ioq<span class="token operator">-></span>head <span class="token operator">=</span> <span class="token function">next_pos</span><span class="token punctuation">(</span>ioq<span class="token operator">-></span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ioq<span class="token operator">-></span>consumer<span class="token punctuation">)</span>    <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioq<span class="token operator">-></span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="稍修修改一下的keyboard-c"><a href="#稍修修改一下的keyboard-c" class="headerlink" title="稍修修改一下的keyboard.c"></a>稍修修改一下的keyboard.c</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"keyboard.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"io.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ioqueue.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">KBD_BUF_PORT</span> <span class="token expression"><span class="token number">0X60</span></span></span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span> ioqueue<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">esc</span> <span class="token char">'\033'</span><span class="token comment">//esc 和 delete都没有</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">delete</span> <span class="token char">'\0177'</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">enter</span> <span class="token char">'\r'</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">tab</span> <span class="token char">'\t'</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">backspace</span> <span class="token char">'\b'</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">char_invisible</span> <span class="token expression"><span class="token number">0</span></span><span class="token comment">//功能性 不可见字符均设置为0</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_l_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_r_char</span> <span class="token expression">char_invisible </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">shift_l_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">shift_r_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_l_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_r_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">caps_lock_char</span> <span class="token expression">char_invisible</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">shift_l_make</span> <span class="token expression"><span class="token number">0x2a</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">shift_r_make</span> <span class="token expression"><span class="token number">0x36</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_l_make</span> <span class="token expression"><span class="token number">0x38</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_r_make</span> <span class="token expression"><span class="token number">0xe038</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">alt_r_break</span> <span class="token expression"><span class="token number">0xe0b8</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_l_make</span> <span class="token expression"><span class="token number">0x1d</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_r_make</span> <span class="token expression"><span class="token number">0xe01d</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ctrl_r_break</span> <span class="token expression"><span class="token number">0xe09d</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">caps_lock_make</span> <span class="token expression"><span class="token number">0x3a</span></span></span>bool ctrl_status <span class="token operator">=</span> false<span class="token punctuation">,</span>shift_status <span class="token operator">=</span> false<span class="token punctuation">,</span>alt_status <span class="token operator">=</span> false<span class="token punctuation">,</span>caps_lock_status <span class="token operator">=</span> false<span class="token punctuation">,</span>ext_scancode <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token comment">/* 以通码make_code为索引的二维数组 */</span><span class="token keyword">static</span> <span class="token keyword">char</span> keymap<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token comment">/* 扫描码   未与shift组合  与shift组合*/</span><span class="token comment">/* ---------------------------------- */</span><span class="token comment">/* 0x00 */</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x01 */</span><span class="token punctuation">&#123;</span>esc<span class="token punctuation">,</span>esc<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x02 */</span><span class="token punctuation">&#123;</span><span class="token char">'1'</span><span class="token punctuation">,</span><span class="token char">'!'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x03 */</span><span class="token punctuation">&#123;</span><span class="token char">'2'</span><span class="token punctuation">,</span><span class="token char">'@'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x04 */</span><span class="token punctuation">&#123;</span><span class="token char">'3'</span><span class="token punctuation">,</span><span class="token char">'#'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x05 */</span><span class="token punctuation">&#123;</span><span class="token char">'4'</span><span class="token punctuation">,</span><span class="token char">'$'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x06 */</span><span class="token punctuation">&#123;</span><span class="token char">'5'</span><span class="token punctuation">,</span><span class="token char">'%'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x07 */</span><span class="token punctuation">&#123;</span><span class="token char">'6'</span><span class="token punctuation">,</span><span class="token char">'^'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x08 */</span><span class="token punctuation">&#123;</span><span class="token char">'7'</span><span class="token punctuation">,</span><span class="token char">'&amp;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x09 */</span><span class="token punctuation">&#123;</span><span class="token char">'8'</span><span class="token punctuation">,</span><span class="token char">'*'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0A */</span><span class="token punctuation">&#123;</span><span class="token char">'9'</span><span class="token punctuation">,</span><span class="token char">'('</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0B */</span><span class="token punctuation">&#123;</span><span class="token char">'0'</span><span class="token punctuation">,</span><span class="token char">')'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0C */</span><span class="token punctuation">&#123;</span><span class="token char">'-'</span><span class="token punctuation">,</span><span class="token char">'_'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0D */</span><span class="token punctuation">&#123;</span><span class="token char">'='</span><span class="token punctuation">,</span><span class="token char">'+'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0E */</span><span class="token punctuation">&#123;</span>backspace<span class="token punctuation">,</span> backspace<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x0F */</span><span class="token punctuation">&#123;</span>tab<span class="token punctuation">,</span>tab<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x10 */</span><span class="token punctuation">&#123;</span><span class="token char">'q'</span><span class="token punctuation">,</span><span class="token char">'Q'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x11 */</span><span class="token punctuation">&#123;</span><span class="token char">'w'</span><span class="token punctuation">,</span><span class="token char">'W'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x12 */</span><span class="token punctuation">&#123;</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'E'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x13 */</span><span class="token punctuation">&#123;</span><span class="token char">'r'</span><span class="token punctuation">,</span><span class="token char">'R'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x14 */</span><span class="token punctuation">&#123;</span><span class="token char">'t'</span><span class="token punctuation">,</span><span class="token char">'T'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x15 */</span><span class="token punctuation">&#123;</span><span class="token char">'y'</span><span class="token punctuation">,</span><span class="token char">'Y'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x16 */</span><span class="token punctuation">&#123;</span><span class="token char">'u'</span><span class="token punctuation">,</span><span class="token char">'U'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x17 */</span><span class="token punctuation">&#123;</span><span class="token char">'i'</span><span class="token punctuation">,</span><span class="token char">'I'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x18 */</span><span class="token punctuation">&#123;</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">'O'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x19 */</span><span class="token punctuation">&#123;</span><span class="token char">'p'</span><span class="token punctuation">,</span><span class="token char">'P'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1A */</span><span class="token punctuation">&#123;</span><span class="token char">'['</span><span class="token punctuation">,</span><span class="token char">'&#123;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1B */</span><span class="token punctuation">&#123;</span><span class="token char">']'</span><span class="token punctuation">,</span><span class="token char">'&#125;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1C */</span><span class="token punctuation">&#123;</span>enter<span class="token punctuation">,</span>  enter<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1D */</span><span class="token punctuation">&#123;</span>ctrl_l_char<span class="token punctuation">,</span> ctrl_l_char<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1E */</span><span class="token punctuation">&#123;</span><span class="token char">'a'</span><span class="token punctuation">,</span><span class="token char">'A'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x1F */</span><span class="token punctuation">&#123;</span><span class="token char">'s'</span><span class="token punctuation">,</span><span class="token char">'S'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x20 */</span><span class="token punctuation">&#123;</span><span class="token char">'d'</span><span class="token punctuation">,</span><span class="token char">'D'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x21 */</span><span class="token punctuation">&#123;</span><span class="token char">'f'</span><span class="token punctuation">,</span><span class="token char">'F'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x22 */</span><span class="token punctuation">&#123;</span><span class="token char">'g'</span><span class="token punctuation">,</span><span class="token char">'G'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x23 */</span><span class="token punctuation">&#123;</span><span class="token char">'h'</span><span class="token punctuation">,</span><span class="token char">'H'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x24 */</span><span class="token punctuation">&#123;</span><span class="token char">'j'</span><span class="token punctuation">,</span><span class="token char">'J'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x25 */</span><span class="token punctuation">&#123;</span><span class="token char">'k'</span><span class="token punctuation">,</span><span class="token char">'K'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x26 */</span><span class="token punctuation">&#123;</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'L'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x27 */</span><span class="token punctuation">&#123;</span><span class="token char">';'</span><span class="token punctuation">,</span><span class="token char">':'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x28 */</span><span class="token punctuation">&#123;</span><span class="token char">'\''</span><span class="token punctuation">,</span><span class="token char">'"'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x29 */</span><span class="token punctuation">&#123;</span><span class="token char">'`'</span><span class="token punctuation">,</span><span class="token char">'~'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2A */</span><span class="token punctuation">&#123;</span>shift_l_char<span class="token punctuation">,</span> shift_l_char<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2B */</span><span class="token punctuation">&#123;</span><span class="token char">'\\'</span><span class="token punctuation">,</span><span class="token char">'|'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2C */</span><span class="token punctuation">&#123;</span><span class="token char">'z'</span><span class="token punctuation">,</span><span class="token char">'Z'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2D */</span><span class="token punctuation">&#123;</span><span class="token char">'x'</span><span class="token punctuation">,</span><span class="token char">'X'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2E */</span><span class="token punctuation">&#123;</span><span class="token char">'c'</span><span class="token punctuation">,</span><span class="token char">'C'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x2F */</span><span class="token punctuation">&#123;</span><span class="token char">'v'</span><span class="token punctuation">,</span><span class="token char">'V'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x30 */</span><span class="token punctuation">&#123;</span><span class="token char">'b'</span><span class="token punctuation">,</span><span class="token char">'B'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x31 */</span><span class="token punctuation">&#123;</span><span class="token char">'n'</span><span class="token punctuation">,</span><span class="token char">'N'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x32 */</span><span class="token punctuation">&#123;</span><span class="token char">'m'</span><span class="token punctuation">,</span><span class="token char">'M'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x33 */</span><span class="token punctuation">&#123;</span><span class="token char">','</span><span class="token punctuation">,</span><span class="token char">'&lt;'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x34 */</span><span class="token punctuation">&#123;</span><span class="token char">'.'</span><span class="token punctuation">,</span><span class="token char">'>'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x35 */</span><span class="token punctuation">&#123;</span><span class="token char">'/'</span><span class="token punctuation">,</span><span class="token char">'?'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x36 */</span><span class="token punctuation">&#123;</span>shift_r_char<span class="token punctuation">,</span> shift_r_char<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x37 */</span><span class="token punctuation">&#123;</span><span class="token char">'*'</span><span class="token punctuation">,</span><span class="token char">'*'</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">/* 0x38 */</span><span class="token punctuation">&#123;</span>alt_l_char<span class="token punctuation">,</span> alt_l_char<span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x39 */</span><span class="token punctuation">&#123;</span><span class="token char">' '</span><span class="token punctuation">,</span><span class="token char">' '</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token comment">/* 0x3A */</span><span class="token punctuation">&#123;</span>caps_lock_char<span class="token punctuation">,</span> caps_lock_char<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"keyboard init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">register_handler</span><span class="token punctuation">(</span><span class="token number">0x21</span><span class="token punctuation">,</span>intr_keyboard_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_ioqueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"keyboard init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">intr_keyboard_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    bool ctrl_down_last <span class="token operator">=</span> ctrl_status<span class="token punctuation">;</span>    bool shift_down_last <span class="token operator">=</span> shift_status<span class="token punctuation">;</span>    bool caps_lock_last <span class="token operator">=</span> caps_lock_status<span class="token punctuation">;</span>        bool break_code<span class="token punctuation">;</span>    <span class="token class-name">uint16_t</span> scancode <span class="token operator">=</span> <span class="token function">inb</span><span class="token punctuation">(</span>KBD_BUF_PORT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0xe0</span><span class="token punctuation">)</span><span class="token comment">//多字节处理</span>    <span class="token punctuation">&#123;</span>    ext_scancode <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        break_code <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>scancode <span class="token operator">&amp;</span> <span class="token number">0x0080</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//断码 = 通码 + 0x80 通码最小比0x80小 则只有断码才可以有</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>break_code<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token class-name">uint16_t</span> make_code <span class="token operator">=</span> <span class="token punctuation">(</span>scancode <span class="token operator">&amp;=</span> <span class="token number">0xff7f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//多字节不处理</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>make_code <span class="token operator">==</span> ctrl_l_make <span class="token operator">||</span> make_code <span class="token operator">==</span> ctrl_r_make<span class="token punctuation">)</span> ctrl_status <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>make_code <span class="token operator">==</span> shift_l_make <span class="token operator">||</span> make_code <span class="token operator">==</span> shift_r_make<span class="token punctuation">)</span> shift_status <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>make_code <span class="token operator">==</span> alt_l_make <span class="token operator">||</span> make_code <span class="token operator">==</span> alt_r_make<span class="token punctuation">)</span> alt_status <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>scancode <span class="token operator">></span> <span class="token number">0x00</span> <span class="token operator">&amp;&amp;</span> scancode <span class="token operator">&lt;</span> <span class="token number">0x3b</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> alt_r_make<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> ctrl_r_make<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    bool shift <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">//先默认设置成false</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>scancode <span class="token operator">&lt;</span> <span class="token number">0x0e</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x29</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x1a</span><span class="token punctuation">)</span> <span class="token operator">||</span> \    <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x1b</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x2b</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x27</span><span class="token punctuation">)</span> <span class="token operator">||</span> \    <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x28</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x33</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x34</span><span class="token punctuation">)</span> <span class="token operator">||</span> \    <span class="token punctuation">(</span>scancode <span class="token operator">==</span> <span class="token number">0x35</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>shift_down_last<span class="token punctuation">)</span>shift <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>shift_down_last <span class="token operator">&amp;&amp;</span> caps_lock_last<span class="token punctuation">)</span>shift <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">//效果确实是这样子的 我试了一下</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>shift_down_last <span class="token operator">||</span> caps_lock_last<span class="token punctuation">)</span> shift <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">//其中任意一个都是大写的作用</span>        <span class="token keyword">else</span> shift <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token class-name">uint8_t</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>scancode <span class="token operator">&amp;</span> <span class="token number">0x00ff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> cur_char <span class="token operator">=</span> keymap<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>shift<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cur_char<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ioq_full</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioqueue<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">ioq_putchar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioqueue<span class="token punctuation">,</span>cur_char<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//put_char(cur_char);</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> ctrl_l_make <span class="token operator">||</span> scancode <span class="token operator">==</span> ctrl_r_make<span class="token punctuation">)</span>        ctrl_status <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> shift_l_make <span class="token operator">||</span> scancode <span class="token operator">==</span> shift_r_make<span class="token punctuation">)</span>            shift_status <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> alt_l_make <span class="token operator">||</span> scancode <span class="token operator">==</span> alt_r_make<span class="token punctuation">)</span>    alt_status <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>scancode <span class="token operator">==</span> caps_lock_make<span class="token punctuation">)</span>    caps_lock_status <span class="token operator">=</span> <span class="token operator">!</span>caps_lock_status<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"unknown key\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="稍微修改一下的keyboard-h"><a href="#稍微修改一下的keyboard-h" class="headerlink" title="稍微修改一下的keyboard.h"></a>稍微修改一下的keyboard.h</h4><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__DEVICE_KEYBOARD_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__DEVICE_KEYBOARD_H</span></span><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">ioqueue</span> ioqueue<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">intr_keyboard_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="稍微修改一下的interrupt-c"><a href="#稍微修改一下的interrupt-c" class="headerlink" title="稍微修改一下的interrupt.c"></a>稍微修改一下的interrupt.c</h4><hr><p><strong>这里就只把修改部分贴出来</strong><br><strong>第0位 是键盘中断 第1位 是时钟中断 这两位得是0 1表示屏蔽<br>则 <code>1100（二进制） == 0xc（16进制）</code></strong><br><strong>换一下即可</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/* 初始化主片 */</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_CTRL<span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0x04</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW3: IR2接从片. </span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW4: 8086模式, 正常EOI</span>   <span class="token comment">/* 初始化从片 */</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_CTRL<span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0x28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0x02</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ICW3: 设置从片连接到主片的IR2引脚</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// ICW4: 8086模式, 正常EOI</span>      <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0xfc</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"   pic_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="稍微修改一下的main-c"><a href="#稍微修改一下的main-c" class="headerlink" title="稍微修改一下的main.c"></a>稍微修改一下的main.c</h4><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../thread/thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../device/console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../device/ioqueue.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../device/keyboard.h"</span></span><span class="token keyword">void</span> <span class="token function">test_thread1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test_thread2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"kernel_thread_a"</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span>test_thread1<span class="token punctuation">,</span><span class="token string">" A_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"kernel_thread_b"</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span>test_thread2<span class="token punctuation">,</span><span class="token string">" B_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test_thread1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ioq_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioqueue<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>       <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> chr <span class="token operator">=</span> <span class="token function">ioq_getchar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">console_put_char</span><span class="token punctuation">(</span>chr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">test_thread2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ioq_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioqueue<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>       <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> chr <span class="token operator">=</span> <span class="token function">ioq_getchar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ioqueue<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">console_put_char</span><span class="token punctuation">(</span>chr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="修改后的MakeFile"><a href="#修改后的MakeFile" class="headerlink" title="修改后的MakeFile"></a>修改后的MakeFile</h4><hr><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">BUILD_DIR <span class="token operator">=</span> ./buildENTRY_POINT <span class="token operator">=</span> 0xc0001500AS <span class="token operator">=</span> nasmCC <span class="token operator">=</span> gccLD <span class="token operator">=</span> ldLIB <span class="token operator">=</span> -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ ASFLAGS <span class="token operator">=</span> -f elfCFLAGS <span class="token operator">=</span> -Wall -m32 -fno-stack-protector <span class="token variable">$</span><span class="token punctuation">(</span>LIB<span class="token punctuation">)</span> -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypesLDFLAGS <span class="token operator">=</span>  -m elf_i386 -Ttext <span class="token variable">$</span><span class="token punctuation">(</span>ENTRY_POINT<span class="token punctuation">)</span> -e main -Map <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/kernel.mapOBJS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/main.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/init.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/interrupt.o \      <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/timer.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/kernel.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/print.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/switch.o \      <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/debug.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/string.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/memory.o \      <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/bitmap.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/thread.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/list.o \      <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/sync.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/console.o <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/keyboard.o \      <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/ioqueue.o<span class="token comment">##############     c代码编译     ###############</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/main.o</span><span class="token punctuation">:</span> kernel/main.c lib/kernel/print.h \        lib/stdint.h kernel/init.h lib/string.h kernel/memory.h \        thread/thread.h kernel/interrupt.h device/console.h \        device/keyboard.h device/ioqueue.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/init.o</span><span class="token punctuation">:</span> kernel/init.c kernel/init.h lib/kernel/print.h \        lib/stdint.h kernel/interrupt.h device/timer.h kernel/memory.h \        thread/thread.h device/console.h device/keyboard.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/interrupt.o</span><span class="token punctuation">:</span> kernel/interrupt.c kernel/interrupt.h \        lib/stdint.h kernel/global.h lib/kernel/io.h lib/kernel/print.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/timer.o</span><span class="token punctuation">:</span> device/timer.c device/timer.h lib/kernel/io.h lib/kernel/print.h \        kernel/interrupt.h thread/thread.h kernel/debug.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/debug.o</span><span class="token punctuation">:</span> kernel/debug.c kernel/debug.h \        lib/kernel/print.h lib/stdint.h kernel/interrupt.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/string.o</span><span class="token punctuation">:</span> lib/string.c lib/string.h \kernel/debug.h kernel/global.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/memory.o</span><span class="token punctuation">:</span> kernel/memory.c kernel/memory.h \lib/stdint.h lib/kernel/bitmap.h kernel/debug.h lib/string.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/bitmap.o</span><span class="token punctuation">:</span> lib/kernel/bitmap.c lib/kernel/bitmap.h kernel/global.h \lib/string.h kernel/interrupt.h lib/kernel/print.h kernel/debug.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/thread.o</span><span class="token punctuation">:</span> thread/thread.c thread/thread.h \lib/stdint.h lib/string.h kernel/global.h kernel/memory.h \kernel/debug.h kernel/interrupt.h lib/kernel/print.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/list.o</span><span class="token punctuation">:</span> lib/kernel/list.c lib/kernel/list.h \kernel/interrupt.h lib/stdint.h kernel/debug.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/sync.o</span><span class="token punctuation">:</span> thread/sync.c thread/sync.h \lib/stdint.h thread/thread.h kernel/debug.h kernel/interrupt.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/console.o</span><span class="token punctuation">:</span> device/console.c device/console.h \lib/kernel/print.h thread/sync.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/keyboard.o</span><span class="token punctuation">:</span> device/keyboard.c device/keyboard.h \lib/kernel/print.h lib/kernel/io.h kernel/interrupt.h \kernel/global.h lib/stdint.h device/ioqueue.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/ioqueue.o</span><span class="token punctuation">:</span> device/ioqueue.c device/ioqueue.h \kernel/interrupt.h kernel/global.h kernel/debug.h<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment">##############    汇编代码编译    ###############</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/kernel.o</span><span class="token punctuation">:</span> kernel/kernel.S<span class="token variable">$</span><span class="token punctuation">(</span>AS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>ASFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/print.o</span><span class="token punctuation">:</span> lib/kernel/print.S<span class="token variable">$</span><span class="token punctuation">(</span>AS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>ASFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/switch.o</span><span class="token punctuation">:</span> thread/switch.S<span class="token variable">$</span><span class="token punctuation">(</span>AS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>ASFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment">##############    链接所有目标文件    #############</span><span class="token target symbol"><span class="token variable">$</span>(BUILD_DIR)/kernel.bin</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>LD<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span> <span class="token variable">$^</span> -o <span class="token variable">$@</span><span class="token builtin-target builtin">.PHONY</span> <span class="token punctuation">:</span> mk_dir hd clean all<span class="token target symbol">mk_dir</span><span class="token punctuation">:</span>if [ ! -d <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span> ]<span class="token punctuation">;</span> then mkdir <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token punctuation">;</span> fi<span class="token target symbol">hd</span><span class="token punctuation">:</span>dd if<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/kernel.bin \           of<span class="token operator">=</span>/home/cooiboi/bochs/hd60M.img \           bs<span class="token operator">=</span>512 count<span class="token operator">=</span>200 seek<span class="token operator">=</span>9 conv<span class="token operator">=</span>notrunc<span class="token target symbol">clean</span><span class="token punctuation">:</span>cd <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span> &amp;&amp; rm -f  ./*<span class="token target symbol">build</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/kernel.bin<span class="token target symbol">all</span><span class="token punctuation">:</span> mk_dir build hd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h1><p>​        我们来看看用户进程，从这里开始，我们就进入了用户世界。TSS之前就聊过了，这里复习一下：</p><p>​        <strong>TSS</strong>：是用于存储任务状态的一个数据结构，每个任务都有自己的TSS。这个数据结构包含了在任务切换时需要保存和恢复的信息，例如处理器寄存器的值、堆栈指针、页目录基地址寄存器的值等，它放在内存的一块连续区域中。TSS是硬件级别任务切换机制的一部分。以下是TSS的使用方式：</p><ol><li>初始化TSS：在操作系统启动时，它会初始化一个或多个TSS。每个TSS都被初始化为包含一个任务的初始状态。比如，TSS可能被初始化为指向新任务的代码段的入口点，堆栈指针可能被初始化为指向新任务的栈顶，等等。</li><li>将TSS的描述符添加到GDT中：操作系统会为每个TSS在全局描述符表（GDT）中创建一个描述符。TSS描述符包含了TSS的基地址和大小，以及其他一些标志。一旦TSS描述符被添加到GDT中，处理器就可以使用这个描述符来访问这个TSS了。</li><li>使用LTR指令加载TSS：当操作系统想要切换到一个新任务时，它会使用LTR（Load Task Register）指令将新任务的TSS描述符加载到任务寄存器（TR）中，TR寄存器中是这个任务的TSS的GDT选择子。这个操作告诉处理器新任务的TSS在哪里。</li><li>任务切换：当处理器执行任务切换时，它会自动保存当前任务的状态到当前任务的TSS中，并从新任务的TSS中恢复新任务的状态。这包括保存和恢复处理器寄存器的值、堆栈指针的值，等等。</li></ol><p><img src="4d7e7fd9cf1f4f1e9a064030351c5f0e.png" alt="在这里插入图片描述"><br>        现代x86体系上的操作系统并没有采用intel设计CPU时想的那种任务切换方式，因为其开销过大而导致效率过低，而是采用的一种基于TSS机制（因为这是硬件提供的，绕不开）的缩减版任务切换方式，在这种情况下，TSS<strong>主要被用于存储每个处理器的内核栈地址，以支持从用户模式到内核模式的切换，以下是关于利用TSS实现任务切换的一些要点。</strong><br>1、当一个中断发生在用户态（特权级 3)，处理器将从当前任务的 TSS 中获取 SS0 和 ESP0 字段的值。<br>2、每个 CPU 中只创建一个 TSS，在各个 CPU 上执行的所有任务都共享一个 TSS。<br>3、在 TR 加载 TSS 后，该 TR 寄存器将永远指向那一个 TSS，之后再也不会重新加载 TSS。<br>4、在进程切换时，只需要把 TSS 中的 SS0 和 ESP0 更新为新任务的内核栈的段地址以及栈指针。<br>5、Linux 对 TSS 的操作是一次性加载 TSS 到 TR，之后不断修改同一个 TSS 的内容，不再重复加载。<br>6、Linux 中任务切换不使用 call 和 jmp 指令，避免了任务切换的低效。<br>任务的状态信息存储位置： 当用户态触发中断后，由特权级 3 陷入特权级 0 后，CPU 自动从当前任务的 TSS 中获取 SS0 和 ESP0 字段的值，作为特权级 0 的栈，然后手动执行一系列 push 指令将任务的状态保存在特权级0的栈中</p><p>​        TSS作为绕不开的硬件机制，所以我们必须要先进入这种机制。也就是必须要GDT表中为其创建一个TSS段描述符，然后用加载选择子进入TR寄存器。现在我们来编写代码来做这件事情，为用户进程做准备。</p><p>​        <strong>首先，我们修改kernel/global.h，在其中添加模块化的段描述符字段，为我们后面拼凑段描述符（TSS段描述符、用户程序用的代码段，数据段，栈段描述符）做准备。并且定义TSS的选择子、同时也要定义用户程序用的代码段、数据段、栈段选择子 字段含义查看p151</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ----------------  GDT描述符属性  ----------------</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token macro-name">DESC_G_4K</span>    <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token macro-name">DESC_D_32</span>    <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_L</span>     <span class="token expression"><span class="token number">0</span>        </span><span class="token comment">// 64位代码标记，此处标记为0便可。</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_AVL</span>     <span class="token expression"><span class="token number">0</span>        </span><span class="token comment">// cpu不用此位，暂置为0  </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_P</span>     <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_DPL_0</span>   <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_DPL_1</span>   <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_DPL_2</span>   <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_DPL_3</span>   <span class="token expression"><span class="token number">3</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_S_CODE</span><span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_S_DATA</span><span class="token expression">DESC_S_CODE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_S_SYS</span><span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_TYPE_CODE</span><span class="token expression"><span class="token number">8</span></span><span class="token comment">// x=1,c=0,r=0,a=0 代码段是可执行的,非依从的,不可读的,已访问位a清0.  </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_TYPE_DATA</span>  <span class="token expression"><span class="token number">2</span></span><span class="token comment">// x=0,e=0,w=1,a=0 数据段是不可执行的,向上扩展的,可写的,已访问位a清0.</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_TYPE_TSS</span>   <span class="token expression"><span class="token number">9</span></span><span class="token comment">// B位为0,不忙</span></span><span class="token comment">//定义不同的用户程序用的段描述符选择子</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SELECTOR_U_CODE</span>   <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>TI_GDT <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> RPL3<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SELECTOR_U_DATA</span>   <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>TI_GDT <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> RPL3<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SELECTOR_U_STACK</span>   <span class="token expression">SELECTOR_U_DATA</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GDT_ATTR_HIGH</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>DESC_G_4K <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_D_32 <span class="token operator">&lt;&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_L <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_AVL <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    </span><span class="token comment">//定义段描述符的高32位的高字</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GDT_CODE_ATTR_LOW_DPL3</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>DESC_P <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_DPL_3 <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_S_CODE <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> DESC_TYPE_CODE<span class="token punctuation">)</span>  </span><span class="token comment">//定义用户程序用的代码段描述符高32位的低字</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GDT_DATA_ATTR_LOW_DPL3</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>DESC_P <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_DPL_3 <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_S_DATA <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> DESC_TYPE_DATA<span class="token punctuation">)</span>  </span><span class="token comment">//定义用户程序用的数据段描述符高32位的低字</span></span><span class="token comment">//---------------  TSS描述符属性  ------------</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSS_DESC_D</span>  <span class="token expression"><span class="token number">0</span>   </span><span class="token comment">//这个D/B位在其他段描述中用于表示操作数的大小，但这里不是，实际上它根本就没有被使用（总是设置为0）。</span></span>                        <span class="token comment">//这是因为TSS的大小和结构并不依赖于处理器运行在16位模式还是32位模式。</span>                        <span class="token comment">//无论何时，TSS都包含了32位的寄存器值、32位的线性地址等等，因此没有必要用D/B位来表示操作的大小</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSS_ATTR_HIGH</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>DESC_G_4K <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>TSS_DESC_D <span class="token operator">&lt;&lt;</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_L <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_AVL <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">0x0</span><span class="token punctuation">)</span>    </span><span class="token comment">//TSS段描述符高32位高字</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TSS_ATTR_LOW</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>DESC_P <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_DPL_0 <span class="token operator">&lt;&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>DESC_S_SYS <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> DESC_TYPE_TSS<span class="token punctuation">)</span>            </span><span class="token comment">//TSS段描述符高32位低字</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SELECTOR_TSS</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>TI_GDT <span class="token operator">&lt;&lt;</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token operator">+</span> RPL0<span class="token punctuation">)</span></span></span><span class="token keyword">struct</span> <span class="token class-name">gdt_desc</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint16_t</span> limit_low_word<span class="token punctuation">;</span>   <span class="token class-name">uint16_t</span> base_low_word<span class="token punctuation">;</span>   <span class="token class-name">uint8_t</span>  base_mid_byte<span class="token punctuation">;</span>   <span class="token class-name">uint8_t</span>  attr_low_byte<span class="token punctuation">;</span>   <span class="token class-name">uint8_t</span>  limit_high_attr_high<span class="token punctuation">;</span>   <span class="token class-name">uint8_t</span>  base_high_byte<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PG_SIZE</span> <span class="token expression"><span class="token number">4096</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们写函数，来完成TSS段描述符的创建与初始化</p><p><strong>userprog/tss.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tss.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token comment">//定义tss的数据结构，在内存中tss的分布就是这个结构体</span><span class="token keyword">struct</span> <span class="token class-name">tss</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> backlink<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span><span class="token operator">*</span> esp0<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ss0<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span><span class="token operator">*</span> esp1<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ss1<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span><span class="token operator">*</span> esp2<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ss2<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> cr3<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>eip<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> eflags<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> eax<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ecx<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> edx<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ebx<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> esp<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ebp<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> esi<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> edi<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> es<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> cs<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ss<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ds<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> fs<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> gs<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> ldt<span class="token punctuation">;</span>    <span class="token class-name">uint16_t</span> trace<span class="token punctuation">;</span>    <span class="token class-name">uint16_t</span> io_base<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">tss</span> tss<span class="token punctuation">;</span><span class="token comment">//用于更新TSS中的esp0的值，让它指向线程/进程的0级栈</span><span class="token keyword">void</span> <span class="token function">update_tss_esp</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   tss<span class="token punctuation">.</span>esp0 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pthread <span class="token operator">+</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//用于创建gdt描述符，传入参数1，段基址，传入参数2，段界限；参数3，属性低字节，参数4，属性高字节(要把低四位置0，高4位才是属性)</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">gdt_desc</span> <span class="token function">make_gdt_desc</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span> desc_addr<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> limit<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> attr_low<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> attr_high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span> desc_base <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>desc_addr<span class="token punctuation">;</span>   <span class="token keyword">struct</span> <span class="token class-name">gdt_desc</span> desc<span class="token punctuation">;</span>   desc<span class="token punctuation">.</span>limit_low_word <span class="token operator">=</span> limit <span class="token operator">&amp;</span> <span class="token number">0x0000ffff</span><span class="token punctuation">;</span>   desc<span class="token punctuation">.</span>base_low_word <span class="token operator">=</span> desc_base <span class="token operator">&amp;</span> <span class="token number">0x0000ffff</span><span class="token punctuation">;</span>   desc<span class="token punctuation">.</span>base_mid_byte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>desc_base <span class="token operator">&amp;</span> <span class="token number">0x00ff0000</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   desc<span class="token punctuation">.</span>attr_low_byte <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>attr_low<span class="token punctuation">)</span><span class="token punctuation">;</span>   desc<span class="token punctuation">.</span>limit_high_attr_high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>limit <span class="token operator">&amp;</span> <span class="token number">0x000f0000</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span>attr_high<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   desc<span class="token punctuation">.</span>base_high_byte <span class="token operator">=</span> desc_base <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> desc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在gdt中创建tss并重新加载gdt */</span><span class="token keyword">void</span> <span class="token function">tss_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"tss_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> tss_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>tss<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tss<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> tss_size<span class="token punctuation">)</span><span class="token punctuation">;</span>   tss<span class="token punctuation">.</span>ss0 <span class="token operator">=</span> SELECTOR_K_STACK<span class="token punctuation">;</span>   tss<span class="token punctuation">.</span>io_base <span class="token operator">=</span> tss_size<span class="token punctuation">;</span><span class="token comment">/* gdt段基址为0x900,把tss放到第4个位置,也就是0x900+0x20的位置 */</span>  <span class="token comment">//在gdt表中添加tss段描述符，在本系统的，GDT表的起始位置为0x00000900，那么tss的段描述就应该在0x920(0x900+十进制4*8)</span>  <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gdt_desc</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xc0000920</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">make_gdt_desc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>tss<span class="token punctuation">,</span> tss_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> TSS_ATTR_LOW<span class="token punctuation">,</span> TSS_ATTR_HIGH<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* 在gdt中添加dpl为3的数据段和代码段描述符 */</span>  <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gdt_desc</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xc0000928</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">make_gdt_desc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">,</span> GDT_CODE_ATTR_LOW_DPL3<span class="token punctuation">,</span> GDT_ATTR_HIGH<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">gdt_desc</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xc0000930</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">make_gdt_desc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0xfffff</span><span class="token punctuation">,</span> GDT_DATA_ATTR_LOW_DPL3<span class="token punctuation">,</span> GDT_ATTR_HIGH<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/* gdt 16位的limit 32位的段基址 */</span>   <span class="token class-name">uint64_t</span> gdt_operand <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token number">7</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token number">0xc0000900</span> <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 7个描述符大小</span>   <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"lgdt %0"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"m"</span> <span class="token punctuation">(</span>gdt_operand<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"ltr %w0"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"r"</span> <span class="token punctuation">(</span>SELECTOR_TSS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"tss_init and ltr done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>建立userprog/tss.h 增加函数声明</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__USERPROG_TSS_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__USERPROG_TSS_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token keyword">void</span> <span class="token function">update_tss_esp</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">tss_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改kernel/init.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"timer.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"keyboard.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tss.h"</span></span><span class="token comment">/*负责初始化所有模块 */</span><span class="token keyword">void</span> <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"init_all\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">idt_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化中断</span>   <span class="token function">mem_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化内存管理系统</span>   <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化线程相关结构</span>   <span class="token function">timer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化PIT</span>   <span class="token function">console_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 控制台初始化最好放在开中断之前</span>   <span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 键盘初始化</span>   <span class="token function">tss_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// tss初始化</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们实现用户进程</p><p>进程与内核线程的核心区别是有两个：</p><p>1、进程有单独的4GB空间（虚拟）</p><p>2、进程运行在特权级3，而内核线程运行在特权级0</p><p>现在我们来实现核心1，它包含两个方面，A、一个管理自己虚拟地址空间的地址池；B、一个自己独立的页表</p><p>现在实现上述核心1的A方面。这就意味着每个进程肯定要有个内存池结构体来管理这个虚拟地址空间，所以修改 <strong>  thread/thread.h</strong> 中的task_struct结构体，增加虚拟内存池结构体，来管理自己的虚拟地址空间</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span><span class="token operator">*</span> self_kstack<span class="token punctuation">;</span>        <span class="token comment">// 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息</span>   <span class="token keyword">enum</span> <span class="token class-name">task_status</span> status<span class="token punctuation">;</span>   <span class="token class-name">uint8_t</span> priority<span class="token punctuation">;</span>        <span class="token comment">// 线程优先级</span>   <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                   <span class="token comment">//用于存储自己的线程的名字</span>   <span class="token class-name">uint8_t</span> ticks<span class="token punctuation">;</span>                 <span class="token comment">//线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时</span>   <span class="token class-name">uint32_t</span> elapsed_ticks<span class="token punctuation">;</span>          <span class="token comment">//此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/</span>   <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> general_tag<span class="token punctuation">;</span><span class="token comment">//general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点</span>   <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> all_list_tag<span class="token punctuation">;</span>   <span class="token comment">//all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点</span>   <span class="token class-name">uint32_t</span><span class="token operator">*</span> pgdir<span class="token punctuation">;</span>              <span class="token comment">// 进程自己页表的虚拟地址</span>   <span class="token keyword">struct</span> <span class="token class-name">virtual_addr</span> userprog_vaddr<span class="token punctuation">;</span>   <span class="token comment">// 用户进程的虚拟地址</span>   <span class="token class-name">uint32_t</span> stack_magic<span class="token punctuation">;</span>       <span class="token comment">//如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>增加了这个内存池结构体，自然就意味着我们创建进程的时候我们要初始化它，由于我们创建进程大部分工作与创建线程重合，所以就不修改创建线程的函数也就是增加初始化内存池结构体的代码，因为线程没有自己的虚拟地址空间。所以我们单独写个初始化虚拟内存池结构体的函数</p><p><strong>userprog/process.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span>   <span class="token comment">//定义了PG_SIZE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"bitmap.h"</span></span><span class="token comment">//用于初始化进程pcb中的用于管理自己虚拟地址空间的虚拟内存池结构体</span><span class="token keyword">void</span> <span class="token function">create_user_vaddr_bitmap</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> user_prog<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   user_prog<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_start <span class="token operator">=</span> USER_VADDR_START<span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> bitmap_pg_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0xc0000000</span> <span class="token operator">-</span> USER_VADDR_START<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE <span class="token operator">/</span> <span class="token number">8</span> <span class="token punctuation">,</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//计算出管理用于进程那么大的虚拟地址的</span>                                                                                                        <span class="token comment">//位图需要多少页的空间来存储（向上取整结果）</span>   user_prog<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>bits <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span>bitmap_pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//申请位图空间</span>   user_prog<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>btmp_bytes_len <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0xc0000000</span> <span class="token operator">-</span> USER_VADDR_START<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>   <span class="token comment">//计算出位图长度（字节单位）</span>   <span class="token function">bitmap_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>user_prog<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//初始化位图</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持代码 userprog/process.h</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__USERPROG_PROCESS_H </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__USERPROG_PROCESS_H</span> </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token keyword">void</span> <span class="token function">create_user_vaddr_bitmap</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> user_prog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">USER_VADDR_START</span> <span class="token expression"><span class="token number">0x8048000</span> </span><span class="token comment">//linux下大部分可执行程序的入口地址（虚拟）都是这个附近，我们也仿照这个设定</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持代码   kernel/global.h</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DIV_ROUND_UP</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">,</span> STEP<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>X <span class="token operator">+</span> STEP <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>STEP<span class="token punctuation">)</span><span class="token punctuation">)</span>  </span><span class="token comment">//用于向上取整的宏，如9/10=1</span></span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接着，我们实现上述核心1的B方面。即独立的页表</p><p><strong>userprog/process.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token comment">//用于为进程创建页目录表，并初始化（系统映射+页目录表最后一项是自己的物理地址，以此来动态操作页目录表），成功后，返回页目录表虚拟地址，失败返回空地址</span><span class="token class-name">uint32_t</span><span class="token operator">*</span> <span class="token function">create_page_dir</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span><span class="token operator">*</span> page_dir_vaddr <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//用户进程的页表不能让用户直接访问到,所以在内核空间来申请</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>page_dir_vaddr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">"create_page_dir: get_kernel_page failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">//将内核页目录表的768号项到1022号项复制过来</span>   <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>page_dir_vaddr <span class="token operator">+</span> <span class="token number">768</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0xfffff000</span> <span class="token operator">+</span> <span class="token number">768</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">255</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> new_page_dir_phy_addr <span class="token operator">=</span> <span class="token function">addr_v2p</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>page_dir_vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//将进程的页目录表的虚拟地址，转换成物理地址</span>   page_dir_vaddr<span class="token punctuation">[</span><span class="token number">1023</span><span class="token punctuation">]</span> <span class="token operator">=</span> new_page_dir_phy_addr <span class="token operator">|</span> PG_US_U <span class="token operator">|</span> PG_RW_W <span class="token operator">|</span> PG_P_1<span class="token punctuation">;</span>   <span class="token comment">//页目录表最后一项填自己的地址，为的是动态操作页表</span>   <span class="token keyword">return</span> page_dir_vaddr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数声明   userprog/process.h</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span><span class="token operator">*</span> <span class="token function">create_page_dir</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>支持代码   kernel/memory.c 物理内存池结构体增加锁，为的是互斥访问物理内存池，增加函数函数addr_v_to_p与get_user_pages，其余的函数只是增加了锁相关的操作</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sync.h"</span></span><span class="token comment">/* 核心数据结构，物理内存池， 生成两个实例用于管理内核物理内存池和用户物理内存池 */</span><span class="token keyword">struct</span> <span class="token class-name">pool</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">struct</span> <span class="token class-name">bitmap</span> pool_bitmap<span class="token punctuation">;</span> <span class="token comment">// 本内存池用到的位图结构,用于管理物理内存</span>   <span class="token class-name">uint32_t</span> phy_addr_start<span class="token punctuation">;</span>     <span class="token comment">// 本内存池所管理物理内存的起始地址</span>   <span class="token class-name">uint32_t</span> pool_size<span class="token punctuation">;</span>    <span class="token comment">// 本内存池字节容量</span>   <span class="token keyword">struct</span> <span class="token class-name">lock</span> lock<span class="token punctuation">;</span> <span class="token comment">// 申请内存时互斥</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//初始化内核物理内存池与用户物理内存池</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mem_pool_init</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> all_mem<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"   mem_pool_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> page_table_size <span class="token operator">=</span> PG_SIZE <span class="token operator">*</span> <span class="token number">256</span><span class="token punctuation">;</span>  <span class="token comment">// 页表大小= 1页的页目录表+第0和第768个页目录项指向同一个页表+</span>                                                  <span class="token comment">// 第769~1022个页目录项共指向254个页表,共256个页表</span>   <span class="token class-name">uint32_t</span> used_mem <span class="token operator">=</span> page_table_size <span class="token operator">+</span> <span class="token number">0x100000</span><span class="token punctuation">;</span>  <span class="token comment">// 已使用内存 = 1MB + 256个页表</span>   <span class="token class-name">uint32_t</span> free_mem <span class="token operator">=</span> all_mem <span class="token operator">-</span> used_mem<span class="token punctuation">;</span>   <span class="token class-name">uint16_t</span> all_free_pages <span class="token operator">=</span> free_mem <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span>        <span class="token comment">//将所有可用内存转换为页的数量，内存分配以页为单位，丢掉的内存不考虑</span>   <span class="token class-name">uint16_t</span> kernel_free_pages <span class="token operator">=</span> all_free_pages <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment">//可用内存是用户与内核各一半，所以分到的页自然也是一半</span>   <span class="token class-name">uint16_t</span> user_free_pages <span class="token operator">=</span> all_free_pages <span class="token operator">-</span> kernel_free_pages<span class="token punctuation">;</span>   <span class="token comment">//用于存储用户空间分到的页</span><span class="token comment">/* 为简化位图操作，余数不处理，坏处是这样做会丢内存。好处是不用做内存的越界检查,因为位图表示的内存少于实际物理内存*/</span>   <span class="token class-name">uint32_t</span> kbm_length <span class="token operator">=</span> kernel_free_pages <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment">// 内核物理内存池的位图长度,位图中的一位表示一页,以字节为单位</span>   <span class="token class-name">uint32_t</span> ubm_length <span class="token operator">=</span> user_free_pages <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>  <span class="token comment">// 用户物理内存池的位图长度.</span>   <span class="token class-name">uint32_t</span> kp_start <span class="token operator">=</span> used_mem<span class="token punctuation">;</span>  <span class="token comment">// Kernel Pool start,内核使用的物理内存池的起始地址</span>   <span class="token class-name">uint32_t</span> up_start <span class="token operator">=</span> kp_start <span class="token operator">+</span> kernel_free_pages <span class="token operator">*</span> PG_SIZE<span class="token punctuation">;</span>  <span class="token comment">// User Pool start,用户使用的物理内存池的起始地址</span>   kernel_pool<span class="token punctuation">.</span>phy_addr_start <span class="token operator">=</span> kp_start<span class="token punctuation">;</span>       <span class="token comment">//赋值给内核使用的物理内存池的起始地址</span>   user_pool<span class="token punctuation">.</span>phy_addr_start   <span class="token operator">=</span> up_start<span class="token punctuation">;</span>       <span class="token comment">//赋值给用户使用的物理内存池的起始地址</span>   kernel_pool<span class="token punctuation">.</span>pool_size <span class="token operator">=</span> kernel_free_pages <span class="token operator">*</span> PG_SIZE<span class="token punctuation">;</span>     <span class="token comment">//赋值给内核使用的物理内存池的总大小</span>   user_pool<span class="token punctuation">.</span>pool_size <span class="token operator">=</span> user_free_pages <span class="token operator">*</span> PG_SIZE<span class="token punctuation">;</span>       <span class="token comment">//赋值给用户使用的物理内存池的总大小</span>   kernel_pool<span class="token punctuation">.</span>pool_bitmap<span class="token punctuation">.</span>btmp_bytes_len <span class="token operator">=</span> kbm_length<span class="token punctuation">;</span>     <span class="token comment">//赋值给管理内核使用的物理内存池的位图长度</span>   user_pool<span class="token punctuation">.</span>pool_bitmap<span class="token punctuation">.</span>btmp_bytes_len  <span class="token operator">=</span> ubm_length<span class="token punctuation">;</span>   <span class="token comment">//赋值给管理用户使用的物理内存池的位图长度</span><span class="token comment">/*********    内核内存池和用户内存池位图   *********** *   位图是全局的数据，长度不固定。 *   全局或静态的数组需要在编译时知道其长度， *   而我们需要根据总内存大小算出需要多少字节。 *   所以改为指定一块内存来生成位图. *   ************************************************/</span><span class="token comment">// 内核使用的最高地址是0xc009f000,这是主线程的栈地址.(内核的大小预计为70K左右)</span><span class="token comment">// 32M内存占用的位图是2k.内核内存池的位图先定在MEM_BITMAP_BASE(0xc009a000)处.</span>   kernel_pool<span class="token punctuation">.</span>pool_bitmap<span class="token punctuation">.</span>bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>MEM_BITMAP_BASE<span class="token punctuation">;</span>      <span class="token comment">//管理内核使用的物理内存池的位图起始地址</span>       <span class="token comment">/* 用户内存池的位图紧跟在内核内存池位图之后 */</span>   user_pool<span class="token punctuation">.</span>pool_bitmap<span class="token punctuation">.</span>bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>MEM_BITMAP_BASE <span class="token operator">+</span> kbm_length<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//管理用户使用的物理内存池的位图起始地址</span>   <span class="token comment">/******************** 输出内存池信息 **********************/</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"      kernel_pool_bitmap_start:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>kernel_pool<span class="token punctuation">.</span>pool_bitmap<span class="token punctuation">.</span>bits<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">" kernel_pool_phy_addr_start:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_int</span><span class="token punctuation">(</span>kernel_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"      user_pool_bitmap_start:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>user_pool<span class="token punctuation">.</span>pool_bitmap<span class="token punctuation">.</span>bits<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">" user_pool_phy_addr_start:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">put_int</span><span class="token punctuation">(</span>user_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 将位图置0*/</span>   <span class="token function">bitmap_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kernel_pool<span class="token punctuation">.</span>pool_bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">bitmap_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>user_pool<span class="token punctuation">.</span>pool_bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kernel_pool<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>user_pool<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 下面初始化内核虚拟地址的位图,按实际物理内存大小生成数组。*/</span>   kernel_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>btmp_bytes_len <span class="token operator">=</span> kbm_length<span class="token punctuation">;</span>      <span class="token comment">// 赋值给管理内核可以动态使用的虚拟地址池（堆区）的位图长度，</span>         <span class="token comment">//其大小与管理内核可使用的物理内存池位图长度相同，因为虚拟内存最终都要转换为真实的物理内存，可用虚拟内存大小超过可用物理内存大小在</span>         <span class="token comment">//我们这个简单操作系统无意义（现代操作系统中有意义，因为我们可以把真实物理内存不断换出，回收，来让可用物理内存变相变大)</span>  <span class="token comment">/* 位图的数组指向一块未使用的内存,目前定位在内核内存池和用户内存池之外*/</span>   kernel_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>MEM_BITMAP_BASE <span class="token operator">+</span> kbm_length <span class="token operator">+</span> ubm_length<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//赋值给管理内核可以动态使用的虚拟内存池（堆区）的位图起始地址</span>   kernel_vaddr<span class="token punctuation">.</span>vaddr_start <span class="token operator">=</span> K_HEAP_START<span class="token punctuation">;</span>     <span class="token comment">//赋值给内核可以动态使用的虚拟地址空间的起始地址</span>   <span class="token function">bitmap_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kernel_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//初始化管理内核可以动态使用的虚拟地址池的位图</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"   mem_pool_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 从内核物理内存池中申请pg_cnt页内存,成功则返回其虚拟地址,失败则返回NULL */</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kernel_pool<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> vaddr <span class="token operator">=</span>  <span class="token function">malloc_page</span><span class="token punctuation">(</span>PF_KERNEL<span class="token punctuation">,</span> pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>vaddr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 若分配的地址不为空,将页框清0后返回</span>      <span class="token function">memset</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> pg_cnt <span class="token operator">*</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kernel_pool<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> vaddr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在用户空间中申请4k内存,并返回其虚拟地址 */</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get_user_pages</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>user_pool<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> vaddr <span class="token operator">=</span> <span class="token function">malloc_page</span><span class="token punctuation">(</span>PF_USER<span class="token punctuation">,</span> pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">memset</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> pg_cnt <span class="token operator">*</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>user_pool<span class="token punctuation">.</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> vaddr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//将虚拟地址转换成真实的物理地址</span><span class="token class-name">uint32_t</span> <span class="token function">addr_v2p</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> vaddr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span><span class="token operator">*</span> pte <span class="token operator">=</span> <span class="token function">pte_ptr</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将虚拟地址转换成页表对应的页表项的地址</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> <span class="token number">0xfffff000</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>vaddr <span class="token operator">&amp;</span> <span class="token number">0x00000fff</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//(*pte)的值是页表所在的物理页框地址,去掉其低12位的页表项属性+虚拟地址vaddr的低12位</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数声明   kernel/memory.h </strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">addr_v2p</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get_user_pages</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在来完成核心2，从特权级0进入特权级3</p><p>特权级从0到3的途径之一是中断返回：执行iret时，此时cs中加载的是用户程序代码段的选择子（RPL = 3）。所以完成特权级的切换核心就是围绕在中断返回时让CS是用户程序的代码段选择子。</p><p>我们先要初始化中断栈的数据，为第一次启动进程做准备。由于我们的进程是基于线程，所以我们新加入的函数模块最好不要修改原有的线程执行逻辑。在原有内核线程中，我们是通过switch_to的ret指令进入了kernel_thread这个线程启动器，由线程启动器去执行我们真正的内核线程。</p><p>所以，我们在这个基础上修改，让这个线程启动器kernel_thread进入中断栈初始化函数，也就是我们到时候送入kernel_thread的参数不是我们要执行的进程地址，而是中断栈初始化函数start_process。也就是在ret基础上加上了iret。</p><p><strong>userprog/process.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">intr_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用于初始化进入进程所需要的中断栈中的信息，传入参数是实际要运行的函数地址(进程)，这个函数是用线程启动器进入的（kernel_thread）</span><span class="token keyword">void</span> <span class="token function">start_process</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> filename_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">void</span><span class="token operator">*</span> function <span class="token operator">=</span> filename_<span class="token punctuation">;</span>   <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   cur<span class="token operator">-></span>self_kstack <span class="token operator">+=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//当我们进入到这里的时候，cur->self_kstack指向thread_stack的起始地址，跳过这里，才能设置intr_stack</span>   <span class="token keyword">struct</span> <span class="token class-name">intr_stack</span><span class="token operator">*</span> proc_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">intr_stack</span><span class="token operator">*</span><span class="token punctuation">)</span>cur<span class="token operator">-></span>self_kstack<span class="token punctuation">;</span>    proc_stack<span class="token operator">-></span>edi <span class="token operator">=</span> proc_stack<span class="token operator">-></span>esi <span class="token operator">=</span> proc_stack<span class="token operator">-></span>ebp <span class="token operator">=</span> proc_stack<span class="token operator">-></span>esp_dummy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   proc_stack<span class="token operator">-></span>ebx <span class="token operator">=</span> proc_stack<span class="token operator">-></span>edx <span class="token operator">=</span> proc_stack<span class="token operator">-></span>ecx <span class="token operator">=</span> proc_stack<span class="token operator">-></span>eax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   proc_stack<span class="token operator">-></span>gs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//用户态根本用不上这个，所以置为0（gs我们一般用于访问显存段，这个让内核态来访问）</span>   proc_stack<span class="token operator">-></span>ds <span class="token operator">=</span> proc_stack<span class="token operator">-></span>es <span class="token operator">=</span> proc_stack<span class="token operator">-></span>fs <span class="token operator">=</span> SELECTOR_U_DATA<span class="token punctuation">;</span>         proc_stack<span class="token operator">-></span>eip <span class="token operator">=</span> function<span class="token punctuation">;</span> <span class="token comment">//设定要执行的函数（进程）的地址</span>   proc_stack<span class="token operator">-></span>cs <span class="token operator">=</span> SELECTOR_U_CODE<span class="token punctuation">;</span>   proc_stack<span class="token operator">-></span>eflags <span class="token operator">=</span> <span class="token punctuation">(</span>EFLAGS_IOPL_0 <span class="token operator">|</span> EFLAGS_MBS <span class="token operator">|</span> EFLAGS_IF_1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//设置用户态下的eflages的相关字段</span>    <span class="token comment">//下面这一句是在初始化中断栈中的栈顶位置，我们先为虚拟地址0xc0000000 - 0x1000申请了个物理页，然后将虚拟地址+4096置为栈顶</span>   proc_stack<span class="token operator">-></span>esp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token function">get_a_page</span><span class="token punctuation">(</span>PF_USER<span class="token punctuation">,</span> USER_STACK3_VADDR<span class="token punctuation">)</span> <span class="token operator">+</span> PG_SIZE<span class="token punctuation">)</span> <span class="token punctuation">;</span>   proc_stack<span class="token operator">-></span>ss <span class="token operator">=</span> SELECTOR_U_DATA<span class="token punctuation">;</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"movl %0, %%esp; jmp intr_exit"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"g"</span> <span class="token punctuation">(</span>proc_stack<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持代码  userprog/process.h</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">USER_STACK3_VADDR</span>  <span class="token expression"><span class="token punctuation">(</span><span class="token number">0xc0000000</span> <span class="token operator">-</span> <span class="token number">0x1000</span><span class="token punctuation">)</span>    </span><span class="token comment">//定义了一页C语言程序的栈顶起始地址（虚拟）,书p511</span></span><span class="token keyword">void</span> <span class="token function">start_process</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> filename_<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">intr_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> func<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>支持代码  kernel/global.h</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//定义eflages寄存器用的一些字段，含义见书p511</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EFLAGS_MBS</span><span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span></span><span class="token comment">// 此项必须要设置</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EFLAGS_IF_1</span><span class="token expression"><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">9</span><span class="token punctuation">)</span></span><span class="token comment">// if为1,开中断</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EFLAGS_IF_0</span><span class="token expression"><span class="token number">0</span></span><span class="token comment">// if为0,关中断</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EFLAGS_IOPL_3</span><span class="token expression"><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span></span><span class="token comment">// IOPL3,用于测试用户程序在非系统调用下进行IO</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EFLAGS_IOPL_0</span><span class="token expression"><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span></span><span class="token comment">// IOPL0</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持代码  kernel/memory.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token comment">//用于为指定的虚拟地址申请一个物理页，传入参数是这个虚拟地址，要申请的物理页所在的地址池的标志。申请失败，返回null</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get_a_page</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> pf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> vaddr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">pool</span><span class="token operator">*</span> mem_pool <span class="token operator">=</span> pf <span class="token operator">&amp;</span> PF_KERNEL <span class="token operator">?</span> <span class="token operator">&amp;</span>kernel_pool <span class="token operator">:</span> <span class="token operator">&amp;</span>user_pool<span class="token punctuation">;</span><span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> bit_idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">/* 若当前是用户进程申请用户内存,就修改用户进程自己的虚拟地址位图 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>pgdir <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pf <span class="token operator">==</span> PF_USER<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>bit_idx <span class="token operator">=</span> <span class="token punctuation">(</span>vaddr <span class="token operator">-</span> cur<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span><span class="token function">ASSERT</span><span class="token punctuation">(</span>bit_idx <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> bit_idx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>pgdir <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pf <span class="token operator">==</span> PF_KERNEL<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">/* 如果是内核线程申请内核内存,就修改kernel_vaddr. */</span>bit_idx <span class="token operator">=</span> <span class="token punctuation">(</span>vaddr <span class="token operator">-</span> kernel_vaddr<span class="token punctuation">.</span>vaddr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span><span class="token function">ASSERT</span><span class="token punctuation">(</span>bit_idx <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kernel_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> bit_idx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"get_a_page:not allow kernel alloc userspace or user alloc kernelspace by get_a_page"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> page_phyaddr <span class="token operator">=</span> <span class="token function">palloc</span><span class="token punctuation">(</span>mem_pool<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>page_phyaddr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token function">page_table_add</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>vaddr<span class="token punctuation">,</span> page_phyaddr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>vaddr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>kernel/memory.h 函数声明</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">get_a_page</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> pf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        现在还没有完成所有的工作，上述工作仅仅是初始化或者叫创建一个进程。当进程由由于主进程的时间片到期而调度上机时。A、需要切换到进程自己的页表，这个还没有做到。B、中断退出进入进程执行，但是当进程执行过程中，由于时钟中断发生，需要从TSS中取出进程0级的ss与esp，才能顺利切换到内核栈中，所以，我们需要修改schedule函数，将进程的内核栈的esp0保存到TSS中。</p><p><strong>userprog/process.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tss.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token comment">/* 激活页表 */</span><span class="token keyword">void</span> <span class="token function">page_dir_activate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> p_thread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/******************************************************** * 执行此函数时,当前任务可能是线程。 * 之所以对线程也要重新安装页表, 原因是上一次被调度的可能是进程, * 否则不恢复页表的话,线程就会使用进程的页表了。 ********************************************************/</span><span class="token comment">/* 若为内核线程,需要重新填充页表为0x100000 */</span>   <span class="token class-name">uint32_t</span> pagedir_phy_addr <span class="token operator">=</span> <span class="token number">0x100000</span><span class="token punctuation">;</span>  <span class="token comment">// 默认为内核的页目录物理地址,也就是内核线程所用的页目录表</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>p_thread<span class="token operator">-></span>pgdir <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//如果不为空，说明要调度的是个进程，那么就要执行加载页表，所以先得到进程页目录表的物理地址</span>        pagedir_phy_addr <span class="token operator">=</span> <span class="token function">addr_v2p</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>p_thread<span class="token operator">-></span>pgdir<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"movl %0, %%cr3"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"r"</span> <span class="token punctuation">(</span>pagedir_phy_addr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//更新页目录寄存器cr3,使新页表生效</span><span class="token punctuation">&#125;</span><span class="token comment">//用于加载进程自己的页目录表，同时更新进程自己的0特权级esp0到TSS中</span><span class="token keyword">void</span> <span class="token function">process_activate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> p_thread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>p_thread <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 激活该进程或线程的页表 */</span>    <span class="token function">page_dir_activate</span><span class="token punctuation">(</span>p_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 内核线程特权级本身就是0,处理器进入中断时并不会从tss中获取0特权级栈地址,故不需要更新esp0 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p_thread<span class="token operator">-></span>pgdir<span class="token punctuation">)</span>        <span class="token function">update_tss_esp</span><span class="token punctuation">(</span>p_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">/* 更新该进程的esp0,用于此进程被中断时保留上下文 */</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持代码 userprog/process.h</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">page_dir_activate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> p_thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">process_activate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> p_thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>在  thread/thread.c中的schedule使用上面的process_activate函数</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token comment">/* 实现任务调度 */</span><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> INTR_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>status <span class="token operator">==</span> TASK_RUNNING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若此线程只是cpu时间片到了,将其加入到就绪队列尾</span>      <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cur<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cur<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>      cur<span class="token operator">-></span>ticks <span class="token operator">=</span> cur<span class="token operator">-></span>priority<span class="token punctuation">;</span>     <span class="token comment">// 重新将当前线程的ticks再重置为其priority;</span>      cur<span class="token operator">-></span>status <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>       <span class="token comment">/* 若此线程需要某事件发生后才能继续上cpu运行,      不需要将其加入队列,因为当前线程不在就绪队列中。*/</span>   <span class="token punctuation">&#125;</span>   <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   thread_tag <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// thread_tag清空</span><span class="token comment">/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */</span>   thread_tag <span class="token operator">=</span> <span class="token function">list_pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> general_tag<span class="token punctuation">,</span> thread_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>   next<span class="token operator">-></span>status <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>   <span class="token function">process_activate</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//激活任务页表</span>   <span class="token function">switch_to</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们进行封装，将之前写的，封装成一个用于创建进程的函数</p><p><strong>userprog/process.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token comment">//用于创建进程，参数是进程要执行的函数与他的名字</span><span class="token keyword">void</span> <span class="token function">process_execute</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">/* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> thread <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_thread</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> name<span class="token punctuation">,</span> default_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">create_user_vaddr_bitmap</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_create</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> start_process<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token operator">-></span>pgdir <span class="token operator">=</span> <span class="token function">create_page_dir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持代码，  userprog/process.h</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">default_prio</span> <span class="token expression"><span class="token number">31</span> </span><span class="token comment">//定义默认的优先级</span></span><span class="token keyword">struct</span> <span class="token class-name">list</span> thread_ready_list<span class="token punctuation">;</span> <span class="token comment">//线程就绪队列</span><span class="token keyword">struct</span> <span class="token class-name">list</span> thread_all_list<span class="token punctuation">;</span>   <span class="token comment">//线程全部队列</span><span class="token keyword">void</span> <span class="token function">process_execute</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> func<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>支持代码，  thread/thread.h</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> thread_ready_list<span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> thread_all_list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>测试函数  main.c</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> test_var_a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> test_var_b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_a"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_a<span class="token punctuation">,</span> <span class="token string">"argA "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_b"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_b<span class="token punctuation">,</span> <span class="token string">"argB "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_a<span class="token punctuation">,</span> <span class="token string">"user_prog_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_b<span class="token punctuation">,</span> <span class="token string">"user_prog_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" v_a:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">console_put_int</span><span class="token punctuation">(</span>test_var_a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" v_b:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">console_put_int</span><span class="token punctuation">(</span>test_var_b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      test_var_a<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      test_var_b<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们这里做一个总结，归纳进程是怎么创建与被调度切换的。</p><p>如同内核线程一样，进程需要有一个自己的task_struct结构体（内核空间中），这个结构体中存着进程自己的管理信息，相比于内核线程，进程的task_struct中多出了至关重要的虚拟内存池结构体用于管理进程自己的虚拟地址空间（这个结构体与它的位图都在内核空间中），以及记录自己的页目录表位置的变量（创建的页目录表与页表均放在内核空间中），这个就体现了为什么进程有自己独立的虚拟地址空间。</p><p>switch_to的ret进入的start_process函数准备进程的中断栈中的内容，通过iret去真正进入进程要执行的函数（作为对比，内核线程是switch_to中的ret进入线程启动器直接执行函数，相当于进程在线程的基础上多了iret），所以我们只要在中断栈中准备好iret返回的信息就行了，中断栈里面的段寄存器选择子字段全是DPL = 3，所以iret之后，就进入了用户态。而且中断栈中要设定好用户栈的栈顶位置（这个栈空间就要在用户空间中）。</p><p>切换到进程执行前，我们要去TSS中，设定好下次进程进入中断时用到的内核栈的栈顶。</p><p>当进程运行的好好的，发生中断后（如时钟中断），CPU会自动从TSS中取出ss0与esp0，然后将进程在用户态运行的信息保存在取出的ss0:esp0指向的内核栈中（相当于内核栈中存着用户栈的栈顶位置）。假设此时发生切换，那么内核栈的栈顶位置将会保存在task_struct结构体中与TSS中。当下次被切换上CPU时，从task_struct中取出内核栈的栈顶位置，然后从中弹出用户栈的栈顶位置与其他执行环境，最后iret发返回（时钟中断的）回到用户态继续执行。</p><h1 id="进一步完善我们的内核"><a href="#进一步完善我们的内核" class="headerlink" title="进一步完善我们的内核"></a>进一步完善我们的内核</h1><p>​        为了方便在操作系统上的应用程序开发，操作系统必须提供一系列接口供程序调用，这就是我们所说的系统调用。系统调用允许用户程序请求操作系统的服务。现在主流操作系统实现系统调用的方法都是利用中断机制，所以在实现系统调用之前，我们需要复习一下这个操作系统上中断机制的运作流程：</p><blockquote><ol><li>当外部设备有事件发生时，会通过中断代理向CPU发送一个带有号码的中断信号；</li><li>CPU会根据传入的中断号码并结合IDTR寄存器中指向的IDT表找到对应这个中断号码的中断门描述符；</li><li>从上一步的中断门描述符中取出CS选择子与IP，然后跳转到这个CS:IP对应的中断处理程序执行。</li><li>然后，上述的第3步中跳转的是汇编语言编写的中断处理程序，它会负责保存现场（保存用户态的上下文到内核栈中），并跳转到用C语言编写的中断处理程序。</li></ol></blockquote><p>​        在x86体系的Linux中，系统调用是通过将要执行的系统调用号码放入EAX寄存器，然后主动调用INT 0x80软中断实现的。由于系统调用机制是基于中断机制，所以系统调用的流程和中断流程非常类似：</p><blockquote><ol><li>程序用int 0x80触发软中断</li><li>CPU结合IDTR寄存器指向的IDT表找到0x80对应的中断门描述符；</li><li>从上一步的中断门描述符中取出CS选择子与IP，然后跳转到这个CS:IP对应的中断处理程序执行；</li><li>中断处理程序根据EAX中存放的值，去调用对应的系统调用函数。中断处理程序也是汇编编写的，它将负责保存现场（保存用户态的上下文到内核栈中）并根据EAX寄存器中的系统调用号码，跳转到对应的C语言编写的系统调用函数中去执行。</li></ol></blockquote><p>​        所以，我们现在来依据这个基于中断机制的系统调用流程来实现系统调用机制：</p><p>​        首先，我们来准备用户程序的系统调用入口，也就是用于触发int 0x80的程序。我们定义4个用户系统调用程序入口，用于不同的系统调用参数数量场景。寄存器参数传递规则参考linux 实现方法</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token comment">/* 无参数的系统调用 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall0</span><span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">int</span> retval<span class="token punctuation">;</span>               </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>       </span><span class="token punctuation">\</span>   <span class="token string">"int $0x80"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=a"</span> <span class="token expression"><span class="token punctuation">(</span>retval<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"a"</span> <span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"memory"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression">retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 一个参数的系统调用 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall1</span><span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">,</span> ARG1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">int</span> retval<span class="token punctuation">;</span>               </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>       </span><span class="token punctuation">\</span>   <span class="token string">"int $0x80"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=a"</span> <span class="token expression"><span class="token punctuation">(</span>retval<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"a"</span> <span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"b"</span> <span class="token expression"><span class="token punctuation">(</span>ARG1<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"memory"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression">retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 两个参数的系统调用 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall2</span><span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">,</span> ARG1<span class="token punctuation">,</span> ARG2<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">int</span> retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>       </span><span class="token punctuation">\</span>   <span class="token string">"int $0x80"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=a"</span> <span class="token expression"><span class="token punctuation">(</span>retval<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"a"</span> <span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"b"</span> <span class="token expression"><span class="token punctuation">(</span>ARG1<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"c"</span> <span class="token expression"><span class="token punctuation">(</span>ARG2<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"memory"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression">retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 三个参数的系统调用 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall3</span><span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">,</span> ARG1<span class="token punctuation">,</span> ARG2<span class="token punctuation">,</span> ARG3<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">int</span> retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>       </span><span class="token punctuation">\</span>      <span class="token string">"int $0x80"</span>       <span class="token punctuation">\</span>      <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=a"</span> <span class="token expression"><span class="token punctuation">(</span>retval<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>      <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"a"</span> <span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"b"</span> <span class="token expression"><span class="token punctuation">(</span>ARG1<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"c"</span> <span class="token expression"><span class="token punctuation">(</span>ARG2<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token string">"d"</span> <span class="token expression"><span class="token punctuation">(</span>ARG3<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>      <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"memory"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression">retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们准备0x80软中断对应的中断门描述符, 修改 （<strong>kernel/interrput.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">IDT_DESC_CNT</span> <span class="token expression"><span class="token number">0x81</span>      </span><span class="token comment">// 目前总共支持的中断数，最后一个支持的中断号0x80 + 1</span></span><span class="token keyword">extern</span> <span class="token class-name">uint32_t</span> <span class="token function">syscall_handler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//定义的汇编中断处理程序代码</span><span class="token comment">//此函数用来循环调用make_idt_desc函数来完成中断门描述符与中断处理函数映射关系的建立,传入三个参数：中断描述符表某个中段描述符（一个结构体）的地址</span><span class="token comment">//属性字段，中断处理函数的地址</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">idt_desc_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> lastindex <span class="token operator">=</span> IDT_DESC_CNT <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> IDT_DESC_CNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">make_idt_desc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>idt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> IDT_DESC_ATTR_DPL0<span class="token punctuation">,</span> intr_entry_table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token comment">//单独处理系统调用,系统调用对应的中断门dpl为3,中断处理程序为汇编的syscall_handler</span>   <span class="token function">make_idt_desc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>idt<span class="token punctuation">[</span>lastindex<span class="token punctuation">]</span><span class="token punctuation">,</span> IDT_DESC_ATTR_DPL3<span class="token punctuation">,</span> syscall_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"   idt_desc_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们定义汇编版的系统调用处理函数 （<strong>kernel/kernel.S</strong>）</p><pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">;;;;;;;;;;;;;;;;   0x80号中断   ;;;;;;;;;;;;;;;;[bits 32]extern syscall_table            ;如同之前我们中断处理机制中引入了C中定义的中断处理程序入口地址表一样，这里引入了C中定义的系统调用函数入口地址表section .textglobal syscall_handlersyscall_handler:                                ;1 保存上下文环境，为了复用之前写好的intr_exit:，所以我们仿照中断处理机制压入的东西，构建系统调用压入的东西   push 0            ; 压入0, 使栈中格式统一   push ds   push es   push fs   push gs   pushad            ; PUSHAD指令压入32位寄存器，其入栈顺序是:EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI     push 0x80        ; 此位置压入0x80也是为了保持统一的栈格式                                ;2 为系统调用子功能传入参数，由于这个函数是3个参数的用户程序系统调用入口都会使用                                ; 所以我们为了格式统一，直接按照最高参数数量压入3个参数   push edx            ; 系统调用中第3个参数   push ecx            ; 系统调用中第2个参数   push ebx            ; 系统调用中第1个参数                                ;3 调用c中定义的功能处理函数   call [syscall_table + eax*4]    ; 编译器会在栈中根据C函数声明匹配正确数量的参数   add esp, 12        ; 跨过上面的三个参数                                ;4 将call调用后的返回值存入待当前内核栈中eax的位置，c语言会自动把返回值放入eax中（c语言的ABI规定）   mov [esp + 8*4], eax   jmp intr_exit        ; intr_exit返回,恢复上下文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后，我们实现类似于中断机制中那种汇编代码跳入c中断处理程序的机制，这样我们就能用c管理系统调用 （<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">syscall_nr</span> <span class="token expression"><span class="token number">32</span> </span></span><span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token operator">*</span> syscall<span class="token punctuation">;</span>syscall syscall_table<span class="token punctuation">[</span>syscall_nr<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        至此，我们的系统调用机制就已经构建完成，以后我们只需要将c写好的<a href="https://so.csdn.net/so/search?q=系统调用函数&amp;spm=1001.2101.3001.7020">系统调用函数</a>地址放入这个数组就行了</p><p>​        现在，我们来为我们的系统增加第一个系统调用<code>sys_get_pid</code>用于获得进程或线程的进程号，其实它就是将进程/线程pcb中的pid值返回回来</p><p>​        首先，我们先在进程/线程的pcb中添加pid成员，不然都没有pid这个成员，<code>sys_get_pid</code>返回啥呢 修改（<strong>thread/thread.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token class-name">uint16_t</span> <span class="token class-name">pid_t</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span><span class="token operator">*</span> self_kstack<span class="token punctuation">;</span>        <span class="token comment">// 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息</span>   <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>   <span class="token keyword">enum</span> <span class="token class-name">task_status</span> status<span class="token punctuation">;</span>   <span class="token class-name">uint8_t</span> priority<span class="token punctuation">;</span>        <span class="token comment">// 线程优先级</span>   <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                   <span class="token comment">//用于存储自己的线程的名字</span>   <span class="token class-name">uint8_t</span> ticks<span class="token punctuation">;</span>                 <span class="token comment">//线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时</span>   <span class="token class-name">uint32_t</span> elapsed_ticks<span class="token punctuation">;</span>          <span class="token comment">//此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/</span>   <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> general_tag<span class="token punctuation">;</span><span class="token comment">//general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点</span>   <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> all_list_tag<span class="token punctuation">;</span>   <span class="token comment">//all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点</span>   <span class="token class-name">uint32_t</span><span class="token operator">*</span> pgdir<span class="token punctuation">;</span>              <span class="token comment">// 进程自己页表的虚拟地址</span>   <span class="token keyword">struct</span> <span class="token class-name">virtual_addr</span> userprog_vaddr<span class="token punctuation">;</span>   <span class="token comment">// 用户进程的虚拟地址</span>   <span class="token class-name">uint32_t</span> stack_magic<span class="token punctuation">;</span>       <span class="token comment">//如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pcb有了这个pid这个成员，那么自然我们创建进程/线程的时候要去为这个成员赋值 修改（<strong>thread/thread.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sync.h"</span></span><span class="token keyword">struct</span> <span class="token class-name">lock</span> pid_lock<span class="token punctuation">;</span>    <span class="token comment">// 分配pid锁</span><span class="token comment">/* 分配pid */</span><span class="token keyword">static</span> <span class="token class-name">pid_t</span> <span class="token function">allocate_pid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">static</span> <span class="token class-name">pid_t</span> next_pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>   next_pid<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> next_pid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 初始化线程基本信息 , pcb中存储的是线程的管理信息，此函数用于根据传入的pcb的地址，线程的名字等来初始化线程的管理信息*/</span><span class="token keyword">void</span> <span class="token function">init_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> prio<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">memset</span><span class="token punctuation">(</span>pthread<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>pthread<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token comment">//把pcb初始化为0</span>   pthread<span class="token operator">-></span>pid <span class="token operator">=</span> <span class="token function">allocate_pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">strcpy</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>name<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>                                         <span class="token comment">//将传入的线程的名字填入线程的pcb中</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>pthread <span class="token operator">==</span> main_thread<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      pthread<span class="token operator">-></span>status <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>     <span class="token comment">//由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */  </span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span>      pthread<span class="token operator">-></span>status <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   pthread<span class="token operator">-></span>priority <span class="token operator">=</span> prio<span class="token punctuation">;</span>                                                                                    <span class="token comment">/* self_kstack是线程自己在内核态下使用的栈顶地址 */</span>   pthread<span class="token operator">-></span>ticks <span class="token operator">=</span> prio<span class="token punctuation">;</span>   pthread<span class="token operator">-></span>elapsed_ticks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   pthread<span class="token operator">-></span>pgdir <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//线程没有自己的地址空间，进程的pcb这一项才有用，指向自己的页表虚拟地址</span>   pthread<span class="token operator">-></span>self_kstack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pthread <span class="token operator">+</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//本操作系统比较简单，线程不会太大，就将线程栈顶定义为pcb地址</span>                                                                        <span class="token comment">//+4096的地方，这样就留了一页给线程的信息（包含管理信息与运行信息）空间</span>   pthread<span class="token operator">-></span>stack_magic <span class="token operator">=</span> <span class="token number">0x19870916</span><span class="token punctuation">;</span>                                <span class="token comment">// /定义的边界数字，随便选的数字来判断线程的栈是否已经生长到覆盖pcb信息了              </span><span class="token punctuation">&#125;</span><span class="token comment">/* 初始化线程环境 */</span><span class="token keyword">void</span> <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 将当前main函数创建为线程 */</span>   <span class="token function">make_main_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们来写这个<code>sys_get_pid</code>函数，并将这个函数地址放入我们的系统调用表syscall_table中 修改（<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token comment">/* 返回当前任务的pid */</span><span class="token class-name">uint32_t</span> <span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明 （<strong>userprog/syscall-init.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__USERPROG_SYSCALLINIT_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__USERPROG_SYSCALLINIT_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">uint32_t</span> <span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码 （<strong>user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__LIB_USER_SYSCALL_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIB_USER_SYSCALL_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span> <span class="token punctuation">&#123;</span>   SYS_GETPID<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，在<code>init_all</code>中调用<code>syscall_init</code>完成系统调用处理函数的安装 修改（<strong>kernel/init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token comment">/*负责初始化所有模块 */</span><span class="token keyword">void</span> <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"init_all\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">idt_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化中断</span>   <span class="token function">mem_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化内存管理系统</span>   <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化线程相关结构</span>   <span class="token function">timer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化PIT</span>   <span class="token function">console_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 控制台初始化最好放在开中断之前</span>   <span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 键盘初始化</span>   <span class="token function">tss_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// tss初始化</span>   <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 初始化系统调用</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，我们写一个用户程序进行系统调用的入口 （<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 返回当前任务pid */</span><span class="token class-name">uint32_t</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> <span class="token function">_syscall0</span><span class="token punctuation">(</span>SYS_GETPID<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后函数声明 （<strong>user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一定要区分作为实际系统调用处理函数的<code>sys_getpid</code>与作为用户程序入口的<code>getpid</code>，前者是运行在内核态的，后者是用户态程序的入口去执行int 0x80的。</p><p>测试代码 （<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> prog_a_pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> prog_b_pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_a<span class="token punctuation">,</span> <span class="token string">"user_prog_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_b<span class="token punctuation">,</span> <span class="token string">"user_prog_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" main_pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_a"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_a<span class="token punctuation">,</span> <span class="token string">"argA "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_b"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_b<span class="token punctuation">,</span> <span class="token string">"argB "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_a_pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" prog_a_pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span>prog_a_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_b_pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" prog_b_pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span>prog_b_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   prog_a_pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   prog_b_pid <span class="token operator">=</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        之前，我们是用寄存器来进行参数传递，其实，我们也能用栈来进行参数传递。原理就是因为系统调用机制基于中断机制，当通过用户程序入口进行系统调用时，用户程序入口会将系统调用号与参数压入用户栈中，然后触发int 0x80软中断，此时特权级切换，cpu会自动在内核栈中压入用户栈的位置，如果我们从内核栈中获取到这个用户栈的位置，那么自然就能获得系统调用号与参数，然后调用对应的系统调用处理函数。</p><p><strong>请注意，这个实验只是为你展示可以用栈传递参数，并不作为后续开发的基础！</strong></p><p>修改（<strong>user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 无参数的系统调用 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall0</span><span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">int</span> retval<span class="token punctuation">;</span>               </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>       </span><span class="token punctuation">\</span>   <span class="token string">"pushl %[number]; int $0x80; addl $4, %%esp"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=a"</span> <span class="token expression"><span class="token punctuation">(</span>retval<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> <span class="token punctuation">[</span>number<span class="token punctuation">]</span> </span><span class="token string">"i"</span> <span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span>         </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"memory"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression">retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 一个参数的系统调用 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall1</span><span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">,</span> ARG0<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">int</span> retval<span class="token punctuation">;</span>               </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>       </span><span class="token punctuation">\</span>   <span class="token string">"pushl %[arg0]; pushl %[number]; int $0x80; addl $8, %%esp"</span> <span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=a"</span> <span class="token expression"><span class="token punctuation">(</span>retval<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> <span class="token punctuation">[</span>number<span class="token punctuation">]</span> </span><span class="token string">"i"</span> <span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>arg0<span class="token punctuation">]</span> </span><span class="token string">"g"</span> <span class="token expression"><span class="token punctuation">(</span>ARG0<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"memory"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression">retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 两个参数的系统调用 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall2</span><span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">,</span> ARG0<span class="token punctuation">,</span> ARG1<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">int</span> retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>       </span><span class="token punctuation">\</span>   <span class="token string">"pushl %[arg1]; pushl %[arg0]; "</span>       <span class="token punctuation">\</span>   <span class="token string">"pushl %[number]; int $0x80; addl $12, %%esp"</span>       <span class="token punctuation">\</span>      <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=a"</span> <span class="token expression"><span class="token punctuation">(</span>retval<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>      <span class="token expression"><span class="token operator">:</span> <span class="token punctuation">[</span>number<span class="token punctuation">]</span> </span><span class="token string">"i"</span> <span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span><span class="token punctuation">,</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">[</span>arg0<span class="token punctuation">]</span> </span><span class="token string">"g"</span> <span class="token expression"><span class="token punctuation">(</span>ARG0<span class="token punctuation">)</span><span class="token punctuation">,</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">[</span>arg1<span class="token punctuation">]</span> </span><span class="token string">"g"</span> <span class="token expression"><span class="token punctuation">(</span>ARG1<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>      <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"memory"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression">retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span class="token comment">/* 三个参数的系统调用 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">_syscall3</span><span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">,</span> ARG0<span class="token punctuation">,</span> ARG1<span class="token punctuation">,</span> ARG2<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">int</span> retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression"><span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>       </span><span class="token punctuation">\</span>      <span class="token string">"pushl %[arg2]; pushl %[arg1]; pushl %[arg0]; "</span>       <span class="token punctuation">\</span>      <span class="token string">"pushl %[number]; int $0x80; addl $16, %%esp"</span>       <span class="token punctuation">\</span>      <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"=a"</span> <span class="token expression"><span class="token punctuation">(</span>retval<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>      <span class="token expression"><span class="token operator">:</span> <span class="token punctuation">[</span>number<span class="token punctuation">]</span> </span><span class="token string">"i"</span> <span class="token expression"><span class="token punctuation">(</span>NUMBER<span class="token punctuation">)</span><span class="token punctuation">,</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">[</span>arg0<span class="token punctuation">]</span> </span><span class="token string">"g"</span> <span class="token expression"><span class="token punctuation">(</span>ARG0<span class="token punctuation">)</span><span class="token punctuation">,</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">[</span>arg1<span class="token punctuation">]</span> </span><span class="token string">"g"</span> <span class="token expression"><span class="token punctuation">(</span>ARG1<span class="token punctuation">)</span><span class="token punctuation">,</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">[</span>arg2<span class="token punctuation">]</span> </span><span class="token string">"g"</span> <span class="token expression"><span class="token punctuation">(</span>ARG2<span class="token punctuation">)</span>       </span><span class="token punctuation">\</span>      <span class="token expression"><span class="token operator">:</span> </span><span class="token string">"memory"</span>       <span class="token punctuation">\</span>   <span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span>       </span><span class="token punctuation">\</span>   <span class="token expression">retval<span class="token punctuation">;</span>       </span><span class="token punctuation">\</span><span class="token expression"><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改（<strong>kernel/kernel.S</strong>）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">;;;;;;;;;;;;;;;;   0x80号中断   ;;;;;;;;;;;;;;;;[bits 32]extern syscall_table            ;如同之前我们中断处理机制中引入了C中定义的中断处理程序入口地址表一样，这里引入了C中定义的系统调用函数入口地址表section .textglobal syscall_handlersyscall_handler:                                ;1 保存上下文环境，为了复用之前写好的intr_exit:，所以我们仿照中断处理机制压入的东西，构建系统调用压入的东西    push 0            ; 压入0, 使栈中格式统一    push ds    push es    push fs    push gs    pushad            ; PUSHAD指令压入32位寄存器，其入栈顺序是:EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI      push 0x80        ; 此位置压入0x80也是为了保持统一的栈格式                                ;2 从内核栈中获取cpu自动压入的用户栈指针esp的值    mov ebx, [esp + 4 + 48 + 4 + 12]                                                                                             ; 为系统调用子功能传入参数，由于这个函数是3个参数的用户程序系统调用入口都会使用                                ; 所以我们为了格式统一，直接按照最高参数数量压入3个参数,  此时ebx是用户栈指针    push dword [ebx + 12]; 系统调用中第3个参数    push dword [ebx + 8]; 系统调用中第2个参数    push dword [ebx + 4]; 系统调用中第1个参数    mov edx, [ebx]              ; 系统调用的子功能号                                             ;3 调用c中定义的功能处理函数    call [syscall_table + edx*4]; 编译器会在栈中根据C函数声明匹配正确数量的参数    add esp, 12        ; 跨过上面的三个参数                                ;4 将call调用后的返回值存入待当前内核栈中eax的位置，c语言会自动把返回值放入eax中（c语言的ABI规定）    mov [esp + 8*4], eax    jmp intr_exit        ; intr_exit返回,恢复上下文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改kernel.S中的核心是获取到用户栈的栈顶位置</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov ebx, [esp + 4 + 48 + 4 + 12]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        此时内核栈的栈顶位置 + 4 是跳过了压入的0x80，+ 48 是跳过 push ad 与 gs fs es ds，+ 4 是跳过了 push 0，最后 + 12是因为用户程序调用int 0x80触发软中断，然后导致特权级切换，cpu会自动向内核栈中按照顺序压入此时的用户程序执行时的ss, esp, eflag, cs, eip，跳过12字节（ss = 2, esp = 4, eflag = 4, cs = 2）就是此时用户栈的栈顶位置eip</p><p>之前，我们一直用的是put_str, put_ch, put_int来用于打印，这些函数只能用于内核态。现在我们要实现用户态打印功能，也就是像c语言中的printf一样。c语言的printf是libc库提供的，它调用了很多系统调用来实现功能，其一是write系统调用，如果我们写一个简单的打印hello的c函数，然后编译，用strace命令去追踪这个编译好的可执行二进制文件，如<code>strace ./hello.bin</code>我们能清楚看见调用了write系统调用，这个系统调用在此处发挥的功能就是向标准输出文件（也就是我们的控制台shell，控制台在Linux中抽象成了一个文件，叫标准输出）写入hello。<br>我们printf也是仿照这个，最终是调用write系统调用来实现，但是由于我们现在没有实现文件系统，所以我们的write是一个简易版本的。现在我们来增加这个write系统调用。首先，我们来增加write系统调用号。</p><p>修改（<strong>lib/users/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span> <span class="token punctuation">&#123;</span>   SYS_GETPID<span class="token punctuation">,</span>   SYS_WRITE<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们实现write系统调用的用户程序入口。</p><p>修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 打印字符串str */</span><span class="token class-name">uint32_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_WRITE<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>之后，我们声明write系统调用的用户程序入口。</p><p>修改（<strong>lib/users/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在我们已经实现了write系统调用的用户程序入口，现在来实现真正的系统调用执行函数。并将其添加进入系统调用表中。</p><p>修改（<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token comment">/* 打印字符串str(未实现文件系统前的版本) */</span><span class="token class-name">uint32_t</span> <span class="token function">sys_write</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>   syscall_table<span class="token punctuation">[</span>SYS_WRITE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_write<span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后声明这个系统调用函数</p><p>修改（<strong>userprog/syscall-init.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">sys_write</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于现在我们开启了页表机制，任何地址都将视作虚拟地址。我们之前编写print.S时，由于是给内核用的，所以用于与显存段打交道的地址有些是借助于内核页目录表0号项进行寻址的，现在我们将print共享给了用户进程，而用户进程无法去访问内核页目录表0号项。但是由于进程页目录表768号项与内核页目录表0号项指向同一张内核的页表（因为进程页目录表768号项就是拷贝的内核页目录表768号项）。所以我们能通过进程页目录表768号项访问原来通过内核页目录表0号项访问的地址。所以，我们需要修改print.S中的一些地址访问，将其升高3G，这样才能让原本通过内核页目录表0号项访问的地址，现在能通过进程页目录表768号项访问。</p><p>修改（<strong>lib/kernel/print.S</strong>）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">.roll_screen:                                ; 若超出屏幕大小，开始滚屏    cld                                                         mov ecx, 960                            ; 一共有2000-80&#x3D;1920个字符要搬运,共1920*2&#x3D;3840字节.一次搬4字节,共3840&#x2F;4&#x3D;960次     ;mov esi, 0xb80a0                            mov esi, 0xc00b80a0; 第1行行首    ;mov edi, 0xb8000                            mov edi, 0xc00b8000; 第0行行首    rep movsd                                ;rep movs word ptr es:[edi], word ptr ds:[esi] 简写为: rep movsw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们就完整实现了系统调用write用于输出文字。你可以在用户进程中尝试用write进行输出。</p><p>我们的write只支持：字符串输出（因为底层实现是用put_str）与一个字符串地址参数；而c语言中的printf不仅能处理字符串，还能处理数字、字符、地址等。而且参数可以无限多，如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a = %x, b = %c, c = %p, d = %s"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以printf绝不是简单调用write，而是增加了：1、将多种格式转换成字符串供write打印。比如上述例子中，我们将a的值直接拿去替换第一个%x，b的值去替换第二个%c…然后将整个字符串打印出来；2、支持可变参数 ，也就是不限制参数数量（一般来说，我们写一个函数，然后建立函数声明必须指定参数数量与类型，这样编译器才知道给函数开辟多大的栈空间。可变参数原理见书p536）。</p><p>可变参数依靠的是编译器的特性，其原理的核心就是，调用者依据c调用约定，从右到左依次向栈中压入参数，而被调用者是能够依据栈中的数据来找到传入的参数。就用上述printf来举例子，当一个函数调用printf，被调者的栈是如下分布：</p><pre class="line-numbers language-none"><code class="language-none">200 d 字符串的地址高地址196 c 地址值195 b 字符的ascii码值191 a 32位值187 &quot;a &#x3D; %x, b &#x3D; %c, c &#x3D; %p, d &#x3D; %s&quot; 字符串地址183 eip 返回地址 低地址123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要我们知道第一个参数的位置，也就是那个字符串地址，然后知道每个参数类型（知道参数类型才知道参数在栈中的大小，才能通过移动指针的方式找到参数），就能找到之后所有的参数。而这两个都不难。</p><p>现在来编写printf函数，但是由于这个函数功能非常多，所以我们现在只增加支持16进制输出。</p><p>（<strong>myso/lib/stdio.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">va_start</span><span class="token expression"><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> v<span class="token punctuation">)</span> ap <span class="token operator">=</span> <span class="token punctuation">(</span>va_list<span class="token punctuation">)</span><span class="token operator">&amp;</span>v        </span><span class="token comment">// 把ap指向第一个固定参数v</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">va_arg</span><span class="token expression"><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ap <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         </span><span class="token comment">// ap指向下一个参数并返回其值</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">va_end</span><span class="token expression"><span class="token punctuation">(</span>ap<span class="token punctuation">)</span> ap <span class="token operator">=</span> <span class="token constant">NULL</span>               </span><span class="token comment">// 清除ap</span></span><span class="token comment">/* 将整型转换成字符(integer to ascii) */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">itoa</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> value<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> buf_ptr_addr<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> base<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span> m <span class="token operator">=</span> value <span class="token operator">%</span> base<span class="token punctuation">;</span>                  <span class="token comment">// 求模,最先掉下来的是最低位   </span>   <span class="token class-name">uint32_t</span> i <span class="token operator">=</span> value <span class="token operator">/</span> base<span class="token punctuation">;</span>                  <span class="token comment">// 取整</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token comment">// 如果倍数不为0则递归调用。</span>      <span class="token function">itoa</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> buf_ptr_addr<span class="token punctuation">,</span> base<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 如果余数是0~9</span>      <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>buf_ptr_addr<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token char">'0'</span><span class="token punctuation">;</span>  <span class="token comment">// 将数字0~9转换为字符'0'~'9'</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 否则余数是A~F</span>      <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>buf_ptr_addr<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token char">'A'</span><span class="token punctuation">;</span> <span class="token comment">// 将数字A~F转换为字符'A'~'F'</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 将参数ap按照格式format输出到字符串str,并返回替换后str长度 */</span><span class="token class-name">uint32_t</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> va_list ap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> buf_ptr <span class="token operator">=</span> str<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> index_ptr <span class="token operator">=</span> format<span class="token punctuation">;</span><span class="token keyword">char</span> index_char <span class="token operator">=</span> <span class="token operator">*</span>index_ptr<span class="token punctuation">;</span><span class="token class-name">int32_t</span> arg_int<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>index_char<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>index_char <span class="token operator">!=</span> <span class="token char">'%'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span><span class="token punctuation">(</span>buf_ptr<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">=</span> index_char<span class="token punctuation">;</span>index_char <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>index_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>index_char <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>index_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 得到%后面的字符</span><span class="token keyword">switch</span><span class="token punctuation">(</span>index_char<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token char">'x'</span><span class="token operator">:</span>arg_int <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">itoa</span><span class="token punctuation">(</span>arg_int<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf_ptr<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> index_char <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>index_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 跳过格式字符并更新index_char</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 格式化输出字符串format */</span><span class="token class-name">uint32_t</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   va_list args<span class="token punctuation">;</span>   <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 使args指向format</span>   <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>       <span class="token comment">// 用于存储拼接后的字符串</span>   <span class="token function">vsprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码（<strong>lib/stdio.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__LIB_STDIO_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIB_STDIO_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token keyword">typedef</span> <span class="token keyword">char</span><span class="token operator">*</span> va_list<span class="token punctuation">;</span><span class="token class-name">uint32_t</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">uint32_t</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> va_list ap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_a<span class="token punctuation">,</span> <span class="token string">"user_prog_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_b<span class="token punctuation">,</span> <span class="token string">"user_prog_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" main_pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_a"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_a<span class="token punctuation">,</span> <span class="token string">"argA "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_b"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_b<span class="token punctuation">,</span> <span class="token string">"argB "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_a_pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_b_pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" prog_a_pid:0x%x\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" prog_b_pid:0x%x\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改Makefile为新增加的文件增加编译规则</p><p>修改（<strong>Makefile</strong>）</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">CFLAGS<span class="token operator">=</span> -Wall <span class="token variable">$</span><span class="token punctuation">(</span>LIB<span class="token punctuation">)</span> -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes -m32 -fno-stack-protector <span class="token comment"># 保护栈</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，我们完善printf，增加处理%s, %c, %d的功能</p><p><strong>修改（lib/stdio.c）</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span><span class="token operator">*</span> arg_str<span class="token punctuation">;</span><span class="token comment">/* 将参数ap按照格式format输出到字符串str,并返回替换后str长度 */</span><span class="token class-name">uint32_t</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> va_list ap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> buf_ptr <span class="token operator">=</span> str<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> index_ptr <span class="token operator">=</span> format<span class="token punctuation">;</span><span class="token keyword">char</span> index_char <span class="token operator">=</span> <span class="token operator">*</span>index_ptr<span class="token punctuation">;</span><span class="token class-name">int32_t</span> arg_int<span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> arg_str<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>index_char<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>index_char <span class="token operator">!=</span> <span class="token char">'%'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span><span class="token punctuation">(</span>buf_ptr<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">=</span> index_char<span class="token punctuation">;</span>index_char <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>index_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>index_char <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>index_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 得到%后面的字符</span><span class="token keyword">switch</span><span class="token punctuation">(</span>index_char<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">case</span> <span class="token char">'s'</span><span class="token operator">:</span>    arg_str <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>buf_ptr<span class="token punctuation">,</span> arg_str<span class="token punctuation">)</span><span class="token punctuation">;</span>    buf_ptr <span class="token operator">+=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>arg_str<span class="token punctuation">)</span><span class="token punctuation">;</span>    index_char <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>index_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token keyword">case</span> <span class="token char">'c'</span><span class="token operator">:</span>    <span class="token operator">*</span><span class="token punctuation">(</span>buf_ptr<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    index_char <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>index_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'d'</span><span class="token operator">:</span>    arg_int <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arg_int <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       arg_int <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> arg_int<span class="token punctuation">;</span><span class="token comment">/* 若是负数, 将其转为正数后,再正数前面输出个负号'-'. */</span>       <span class="token operator">*</span>buf_ptr<span class="token operator">++</span> <span class="token operator">=</span> <span class="token char">'-'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">itoa</span><span class="token punctuation">(</span>arg_int<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf_ptr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     index_char <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>index_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token char">'x'</span><span class="token operator">:</span>arg_int <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>ap<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">itoa</span><span class="token punctuation">(</span>arg_int<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buf_ptr<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> index_char <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>index_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 跳过格式字符并更新index_char</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_a<span class="token punctuation">,</span> <span class="token string">"u_prog_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_b<span class="token punctuation">,</span> <span class="token string">"u_prog_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" I am main, my pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_a"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_a<span class="token punctuation">,</span> <span class="token string">"I am thread_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_b"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_b<span class="token punctuation">,</span> <span class="token string">"I am thread_b "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" I am thread_a, my pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" I am thread_b, my pid:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token function">sys_getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token string">"prog_a"</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" I am %s, my pid:%d%c"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token string">"prog_b"</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" I am %s, my pid:%d%c"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在进行接下来的开发之前，我们先填坑。是否记得我们之前实现页分配时，只实现了内核页面的分配，而把用户页面分配代码是空着的！</p><p>修改（<strong>kernel/memory.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 在pf表示的虚拟内存池中申请pg_cnt个虚拟页, * 成功则返回虚拟页的起始地址, 失败则返回NULL */</span><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">vaddr_get</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> pf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> vaddr_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bit_idx_start <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>pf <span class="token operator">==</span> PF_KERNEL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      bit_idx_start  <span class="token operator">=</span> <span class="token function">bitmap_scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kernel_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_idx_start <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kernel_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> bit_idx_start <span class="token operator">+</span> cnt<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      vaddr_start <span class="token operator">=</span> kernel_vaddr<span class="token punctuation">.</span>vaddr_start <span class="token operator">+</span> bit_idx_start <span class="token operator">*</span> PG_SIZE<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 用户内存池</span>      <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      bit_idx_start  <span class="token operator">=</span> <span class="token function">bitmap_scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>bit_idx_start <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> bit_idx_start <span class="token operator">+</span> cnt<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      vaddr_start <span class="token operator">=</span> cur<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_start <span class="token operator">+</span> bit_idx_start <span class="token operator">*</span> PG_SIZE<span class="token punctuation">;</span>   <span class="token comment">/* (0xc0000000 - PG_SIZE)做为用户3级栈已经在start_process被分配 */</span>      <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>vaddr_start <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">0xc0000000</span> <span class="token operator">-</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>vaddr_start<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        之前，我们的内存管理是：</p><blockquote><ol><li><p>只有分配没有释放；</p></li><li><p>以页为单位；</p></li><li><p>只能内核态使用；</p></li></ol></blockquote><p>现在我们完善内存管理：</p><blockquote><ol><li><p>实现释放机制；</p></li><li><p>实现释放机制；</p></li><li><p>用户态也可以使用；</p></li></ol></blockquote><p>释放机制的实现很简单，是分配机制的逆操作；</p><p>​        更细粒度的内存管理单位，需要依靠arena模型的理解与实现。在这个模型中，我们先申请一个完整的4KB页面，然后将这个4KB页面划分成不同的小块，如256个16B小块、8个512B的小块，然后这些独立的小块就成了分配与释放的基本单位；用户态使用，直接使用系统调用机制。首先，我们来进行底层数据结构的建立：</p><p>修改（<strong>kernel/memory.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span></span><span class="token comment">/* 内存块 */</span><span class="token keyword">struct</span> <span class="token class-name">mem_block</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> free_elem<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* 内存块描述符 */</span><span class="token keyword">struct</span> <span class="token class-name">mem_block_desc</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span> block_size<span class="token punctuation">;</span> <span class="token comment">// 内存块大小</span>   <span class="token class-name">uint32_t</span> blocks_per_arena<span class="token punctuation">;</span> <span class="token comment">// 本arena中可容纳此mem_block的数量.</span>   <span class="token keyword">struct</span> <span class="token class-name">list</span> free_list<span class="token punctuation">;</span> <span class="token comment">// 目前可用的mem_block链表</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DESC_CNT</span> <span class="token expression"><span class="token number">7</span>   </span><span class="token comment">// 内存块描述符个数</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改（<strong>kernel/memory.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 内存仓库arena元信息 */</span><span class="token keyword">struct</span> <span class="token class-name">arena</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">struct</span> <span class="token class-name">mem_block_desc</span><span class="token operator">*</span> desc<span class="token punctuation">;</span> <span class="token comment">// 此arena关联的mem_block_desc</span>   <span class="token class-name">uint32_t</span> cnt<span class="token punctuation">;</span>   bool large<span class="token punctuation">;</span>   <span class="token comment">/* large为ture时,cnt表示的是页框数。否则cnt表示空闲mem_block数量 */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>struct mem_block_desc</code>、<code>struct mem_block</code>、<code>struct arena</code>的关系：</p><p><code>struct mem_block_desc</code>描述了不同类型的小块，比如刚刚那个例子：4KB页面划分成不同的小块，如256个16B小块、8个512B的小块。512B的小块对应一个<code>mem_block_desc</code>，而16B的小块对应另一个。<code>block_size</code>就是记录这个<code>mem_block_desc</code>用于描述哪种大小的小内存块，比如512或者16。<code>blocks_per_arena</code>用于记录一个页面拆分成了多少个小块，比如8个或者256个。<code>free_list</code>用于管理可以分配的小块，也就是用于将可以分配的小块形成链表。</p><p><code>struct mem_block</code>其实本意是用来描述这个由4KB页面二次划分而成的固定小块，但是作者为了实现更通用的管理逻辑，所以这个结构体里面只包含了一个用于管理这个空闲小块的链表节点。</p><p><code>struct arena</code>用于描述这个arena，<code>desc</code>用于指向这个管理这种arena的mem_block_desc结构体，cnt的值意义取决于large的值，如果large = true，那么表示本arena占用的页框数目，否则表示本arena中还有多少空闲小内存块可用。需要注意的是，一个mem_block_desc对应的arena数量可不止一个，其实很好理解，当一个arena的小内存块分配完毕，我们就要再分配一个新的页充当arena然后划分成固定大小的小块。然后初始化管理内核不同种类型arena的不同mem_block_desc</p><p>修改（<strong>kernel/memory.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mem_block_desc</span> k_block_descs<span class="token punctuation">[</span>DESC_CNT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 内核内存块描述符数组</span><span class="token comment">//初始化管理不同种类型arena的不同mem_block_desc</span><span class="token keyword">void</span> <span class="token function">block_desc_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mem_block_desc</span><span class="token operator">*</span> desc_array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token class-name">uint16_t</span> desc_idx<span class="token punctuation">,</span> block_size <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>desc_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> desc_idx <span class="token operator">&lt;</span> DESC_CNT<span class="token punctuation">;</span> desc_idx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      desc_array<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>block_size <span class="token operator">=</span> block_size<span class="token punctuation">;</span>      desc_array<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>blocks_per_arena <span class="token operator">=</span> <span class="token punctuation">(</span>PG_SIZE <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">arena</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> block_size<span class="token punctuation">;</span>        <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>desc_array<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>free_list<span class="token punctuation">)</span><span class="token punctuation">;</span>      block_size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token comment">// 更新为下一个规格内存块</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 内存管理部分初始化入口 */</span><span class="token keyword">void</span> <span class="token function">mem_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"mem_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> mem_bytes_total <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0xb00</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">mem_pool_init</span><span class="token punctuation">(</span>mem_bytes_total<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化内存池</span>   <span class="token function">block_desc_init</span><span class="token punctuation">(</span>k_block_descs<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"mem_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加函数声明，修改（<strong>kernel/memory.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">block_desc_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mem_block_desc</span><span class="token operator">*</span> desc_array<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内核有了管理不同类型arena的mem_block_desck数组。我们说进程是独立分配资源的单位，进程拥有自己的独立虚拟地址空间，那么进程也应该拥有管理自己不同类型arena的mem_block_desc数组。这样进程分配内存，就去进程自己的mem_block_desc数组中找对应的mem_block_desc，然后通过free_list找到空闲小块就行了。</p><p>修改（<strong>thread/thread.h</strong>）为task_struct添加<code>u_block_desc</code>，这样每个task_struct都有了这个mem_block_desc数组</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span><span class="token operator">*</span> self_kstack<span class="token punctuation">;</span>        <span class="token comment">// 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息</span>   <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>   <span class="token keyword">enum</span> <span class="token class-name">task_status</span> status<span class="token punctuation">;</span>   <span class="token class-name">uint8_t</span> priority<span class="token punctuation">;</span>        <span class="token comment">// 线程优先级</span>   <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                   <span class="token comment">//用于存储自己的线程的名字</span>   <span class="token class-name">uint8_t</span> ticks<span class="token punctuation">;</span>                 <span class="token comment">//线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时</span>   <span class="token class-name">uint32_t</span> elapsed_ticks<span class="token punctuation">;</span>          <span class="token comment">//此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/</span>   <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> general_tag<span class="token punctuation">;</span><span class="token comment">//general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点</span>   <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> all_list_tag<span class="token punctuation">;</span>   <span class="token comment">//all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点</span>   <span class="token class-name">uint32_t</span><span class="token operator">*</span> pgdir<span class="token punctuation">;</span>              <span class="token comment">// 进程自己页表的虚拟地址</span>   <span class="token keyword">struct</span> <span class="token class-name">virtual_addr</span> userprog_vaddr<span class="token punctuation">;</span>   <span class="token comment">// 用户进程的虚拟地址</span>   <span class="token keyword">struct</span> <span class="token class-name">mem_block_desc</span> u_block_desc<span class="token punctuation">[</span>DESC_CNT<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 用户进程内存块描述符</span>   <span class="token class-name">uint32_t</span> stack_magic<span class="token punctuation">;</span>       <span class="token comment">//如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是，我们只初始化进程的mem_block_desc数组</p><p>修改（<strong>userprog/process.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//用于创建进程，参数是进程要执行的函数与他的名字</span><span class="token keyword">void</span> <span class="token function">process_execute</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> filename<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">/* pcb内核的数据结构,由内核来维护进程信息,因此要在内核内存池中申请 */</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> thread <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_thread</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> name<span class="token punctuation">,</span> default_prio<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">create_user_vaddr_bitmap</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_create</span><span class="token punctuation">(</span>thread<span class="token punctuation">,</span> start_process<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token operator">-></span>pgdir <span class="token operator">=</span> <span class="token function">create_page_dir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">block_desc_init</span><span class="token punctuation">(</span>thread<span class="token operator">-></span>u_block_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们来编写能够与arena模型配合的<code>sys_malloc</code>，用于真正进行内存分配</p><p>修改（<strong>kernel/memory.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token comment">/* 返回arena中第idx个内存块的地址 */</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">mem_block</span><span class="token operator">*</span> <span class="token function">arena2block</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">arena</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mem_block</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>a <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">arena</span><span class="token punctuation">)</span> <span class="token operator">+</span> idx <span class="token operator">*</span> a<span class="token operator">-></span>desc<span class="token operator">-></span>block_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 返回内存块b所在的arena地址 */</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">arena</span><span class="token operator">*</span> <span class="token function">block2arena</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mem_block</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">arena</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>b <span class="token operator">&amp;</span> <span class="token number">0xfffff000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在堆中申请size字节内存 */</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> PF<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pool</span><span class="token operator">*</span> mem_pool<span class="token punctuation">;</span><span class="token class-name">uint32_t</span> pool_size<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mem_block_desc</span><span class="token operator">*</span> descs<span class="token punctuation">;</span><span class="token comment">//用于存储mem_block_desc数组地址</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur_thread <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 判断用哪个内存池*/</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cur_thread<span class="token operator">-></span>pgdir <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 若为内核线程</span>PF <span class="token operator">=</span> PF_KERNEL<span class="token punctuation">;</span> pool_size <span class="token operator">=</span> kernel_pool<span class="token punctuation">.</span>pool_size<span class="token punctuation">;</span>mem_pool <span class="token operator">=</span> <span class="token operator">&amp;</span>kernel_pool<span class="token punctuation">;</span>descs <span class="token operator">=</span> k_block_descs<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 用户进程pcb中的pgdir会在为其分配页表时创建</span>PF <span class="token operator">=</span> PF_USER<span class="token punctuation">;</span>pool_size <span class="token operator">=</span> user_pool<span class="token punctuation">.</span>pool_size<span class="token punctuation">;</span>mem_pool <span class="token operator">=</span> <span class="token operator">&amp;</span>user_pool<span class="token punctuation">;</span>descs <span class="token operator">=</span> cur_thread<span class="token operator">-></span>u_block_desc<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 若申请的内存不在内存池容量范围内则直接返回NULL */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> size <span class="token operator">&lt;</span> pool_size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">struct</span> <span class="token class-name">arena</span><span class="token operator">*</span> a<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">mem_block</span><span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 超过最大内存块1024, 就分配页框 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">1024</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">uint32_t</span> page_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">arena</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 向上取整需要的页框数</span>a <span class="token operator">=</span> <span class="token function">malloc_page</span><span class="token punctuation">(</span>PF<span class="token punctuation">,</span> page_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> page_cnt <span class="token operator">*</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将分配的内存清0  </span><span class="token comment">/* 对于分配的大块页框,将desc置为NULL, cnt置为页框数,large置为true */</span>a<span class="token operator">-></span>desc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>a<span class="token operator">-></span>cnt <span class="token operator">=</span> page_cnt<span class="token punctuation">;</span>a<span class="token operator">-></span>large <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 跨过arena大小，把剩下的内存返回</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 若申请的内存小于等于1024,可在各种规格的mem_block_desc中去适配</span><span class="token class-name">uint8_t</span> desc_idx<span class="token punctuation">;</span><span class="token comment">/* 从内存块描述符中匹配合适的内存块规格 */</span><span class="token keyword">for</span> <span class="token punctuation">(</span>desc_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> desc_idx <span class="token operator">&lt;</span> DESC_CNT<span class="token punctuation">;</span> desc_idx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> descs<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>block_size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 从小往大后,找到后退出</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 若mem_block_desc的free_list中已经没有可用的mem_block,* 就创建新的arena提供mem_block */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>descs<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>free_list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">=</span> <span class="token function">malloc_page</span><span class="token punctuation">(</span>PF<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 分配1页框做为arena</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 对于分配的小块内存,将desc置为相应内存块描述符, * cnt置为此arena可用的内存块数,large置为false */</span>a<span class="token operator">-></span>desc <span class="token operator">=</span> <span class="token operator">&amp;</span>descs<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token operator">-></span>large <span class="token operator">=</span> false<span class="token punctuation">;</span>a<span class="token operator">-></span>cnt <span class="token operator">=</span> descs<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>blocks_per_arena<span class="token punctuation">;</span><span class="token class-name">uint32_t</span> block_idx<span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 开始将arena拆分成内存块,并添加到内存块描述符的free_list中 */</span><span class="token keyword">for</span> <span class="token punctuation">(</span>block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> block_idx <span class="token operator">&lt;</span> descs<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>blocks_per_arena<span class="token punctuation">;</span> block_idx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>b <span class="token operator">=</span> <span class="token function">arena2block</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> block_idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">-></span>desc<span class="token operator">-></span>free_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token operator">-></span>free_elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">-></span>desc<span class="token operator">-></span>free_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token operator">-></span>free_elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">/* 开始分配内存块 */</span>b <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mem_block</span><span class="token punctuation">,</span> free_elem<span class="token punctuation">,</span> <span class="token function">list_pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>descs<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>free_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> descs<span class="token punctuation">[</span>desc_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>block_size<span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">block2arena</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取内存块b所在的arena</span>a<span class="token operator">-></span>cnt<span class="token operator">--</span><span class="token punctuation">;</span>   <span class="token comment">// 将此arena中的空闲内存块数减1</span><span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明函数，修改（<strong>kernel/memory.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码，修改（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_a"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_a<span class="token punctuation">,</span> <span class="token string">"I am thread_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_b"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_b<span class="token punctuation">,</span> <span class="token string">"I am thread_b "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" I am thread_a, sys_malloc(33), addr is 0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">63</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" I am thread_b, sys_malloc(63), addr is 0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token string">"prog_a"</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" I am %s, my pid:%d%c"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token string">"prog_b"</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" I am %s, my pid:%d%c"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来实现页级别的内存回收，页回收是页分配的逆操作：1、清除物理内存池中位图的位；2、清除虚拟地址对应的页表表项；3、清除虚拟内存池中位图的位；</p><p>修改（<strong>kernel/memory.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//将物理地址pg_phy_addr回收到物理内存池，实质就是清除物理内存池中位图的位</span><span class="token keyword">void</span> <span class="token function">pfree</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> pg_phy_addr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">pool</span><span class="token operator">*</span> mem_pool<span class="token punctuation">;</span><span class="token class-name">uint32_t</span> bit_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pg_phy_addr <span class="token operator">>=</span> user_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 用户物理内存池</span>mem_pool <span class="token operator">=</span> <span class="token operator">&amp;</span>user_pool<span class="token punctuation">;</span>bit_idx <span class="token operator">=</span> <span class="token punctuation">(</span>pg_phy_addr <span class="token operator">-</span> user_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 内核物理内存池</span>mem_pool <span class="token operator">=</span> <span class="token operator">&amp;</span>kernel_pool<span class="token punctuation">;</span>bit_idx <span class="token operator">=</span> <span class="token punctuation">(</span>pg_phy_addr <span class="token operator">-</span> kernel_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>pool_bitmap<span class="token punctuation">,</span> bit_idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将位图中该位清0</span><span class="token punctuation">&#125;</span><span class="token comment">/* 去掉页表中虚拟地址vaddr的映射,只去掉vaddr对应的pte */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">page_table_pte_remove</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> vaddr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span><span class="token operator">*</span> pte <span class="token operator">=</span> <span class="token function">pte_ptr</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">*</span>pte <span class="token operator">&amp;=</span> <span class="token operator">~</span>PG_P_1<span class="token punctuation">;</span><span class="token comment">// 将页表项pte的P位置0</span>   <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"invlpg %0"</span><span class="token operator">::</span><span class="token string">"m"</span> <span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token operator">:</span><span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//更新tlb</span><span class="token punctuation">&#125;</span><span class="token comment">//在虚拟地址池中释放以_vaddr起始的连续pg_cnt个虚拟页地址，实质就是清楚虚拟内存池位图的位</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">vaddr_remove</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> pf<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> _vaddr<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">uint32_t</span> bit_idx_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> vaddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>_vaddr<span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pf <span class="token operator">==</span> PF_KERNEL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 内核虚拟内存池</span>bit_idx_start <span class="token operator">=</span> <span class="token punctuation">(</span>vaddr <span class="token operator">-</span> kernel_vaddr<span class="token punctuation">.</span>vaddr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kernel_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> bit_idx_start <span class="token operator">+</span> cnt<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 用户虚拟内存池</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur_thread <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bit_idx_start <span class="token operator">=</span> <span class="token punctuation">(</span>vaddr <span class="token operator">-</span> cur_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> bit_idx_start <span class="token operator">+</span> cnt<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 释放以虚拟地址vaddr为起始的cnt个物理页框 */</span><span class="token keyword">void</span> <span class="token function">mfree_page</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> pf<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> _vaddr<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">uint32_t</span> pg_phy_addr<span class="token punctuation">;</span><span class="token class-name">uint32_t</span> vaddr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span>_vaddr<span class="token punctuation">,</span> page_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">ASSERT</span><span class="token punctuation">(</span>pg_cnt <span class="token operator">>=</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> vaddr <span class="token operator">%</span> PG_SIZE <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pg_phy_addr <span class="token operator">=</span> <span class="token function">addr_v2p</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取虚拟地址vaddr对应的物理地址</span><span class="token comment">/* 确保待释放的物理内存在低端1M+1k大小的页目录+1k大小的页表地址范围外 */</span><span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pg_phy_addr <span class="token operator">%</span> PG_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pg_phy_addr <span class="token operator">>=</span> <span class="token number">0x102000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 判断pg_phy_addr属于用户物理内存池还是内核物理内存池 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pg_phy_addr <span class="token operator">>=</span> user_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 位于user_pool内存池</span>vaddr <span class="token operator">-=</span> PG_SIZE<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>page_cnt <span class="token operator">&lt;</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vaddr <span class="token operator">+=</span> PG_SIZE<span class="token punctuation">;</span>pg_phy_addr <span class="token operator">=</span> <span class="token function">addr_v2p</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 确保物理地址属于用户物理内存池 */</span><span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pg_phy_addr <span class="token operator">%</span> PG_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> pg_phy_addr <span class="token operator">>=</span> user_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 先将对应的物理页框归还到内存池 */</span><span class="token function">pfree</span><span class="token punctuation">(</span>pg_phy_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 再从页表中清除此虚拟地址所在的页表项pte */</span><span class="token function">page_table_pte_remove</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>page_cnt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 清空虚拟地址的位图中的相应位 */</span><span class="token function">vaddr_remove</span><span class="token punctuation">(</span>pf<span class="token punctuation">,</span> _vaddr<span class="token punctuation">,</span> pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 位于kernel_pool内存池</span>vaddr <span class="token operator">-=</span> PG_SIZE<span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>page_cnt <span class="token operator">&lt;</span> pg_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>vaddr <span class="token operator">+=</span> PG_SIZE<span class="token punctuation">;</span>pg_phy_addr <span class="token operator">=</span> <span class="token function">addr_v2p</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 确保待释放的物理内存只属于内核物理内存池 */</span><span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pg_phy_addr <span class="token operator">%</span> PG_SIZE<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> \pg_phy_addr <span class="token operator">>=</span> kernel_pool<span class="token punctuation">.</span>phy_addr_start <span class="token operator">&amp;&amp;</span> \pg_phy_addr <span class="token operator">&lt;</span> user_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 先将对应的物理页框归还到内存池 */</span><span class="token function">pfree</span><span class="token punctuation">(</span>pg_phy_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 再从页表中清除此虚拟地址所在的页表项pte */</span><span class="token function">page_table_pte_remove</span><span class="token punctuation">(</span>vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>page_cnt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 清空虚拟地址的位图中的相应位 */</span><span class="token function">vaddr_remove</span><span class="token punctuation">(</span>pf<span class="token punctuation">,</span> _vaddr<span class="token punctuation">,</span> pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明：修改（<strong>kernel/memory.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">mfree_page</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> pf<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> _vaddr<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">pfree</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> pg_phy_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，我们实现与arena模型分配机制对应的回收机制，并将之前的页回收封装进入，直接实现统一的内存回收系统调用<code>sys_free</code></p><p>修改（<strong>kernel/memory.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 回收内存ptr */</span><span class="token keyword">void</span> <span class="token function">sys_free</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">ASSERT</span><span class="token punctuation">(</span>ptr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> PF<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">pool</span><span class="token operator">*</span> mem_pool<span class="token punctuation">;</span><span class="token comment">/* 判断是线程还是进程 */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>pgdir <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>ptr <span class="token operator">>=</span> K_HEAP_START<span class="token punctuation">)</span><span class="token punctuation">;</span>PF <span class="token operator">=</span> PF_KERNEL<span class="token punctuation">;</span> mem_pool <span class="token operator">=</span> <span class="token operator">&amp;</span>kernel_pool<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>PF <span class="token operator">=</span> PF_USER<span class="token punctuation">;</span>mem_pool <span class="token operator">=</span> <span class="token operator">&amp;</span>user_pool<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">struct</span> <span class="token class-name">mem_block</span><span class="token operator">*</span> b <span class="token operator">=</span> ptr<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">arena</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token function">block2arena</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 把mem_block转换成arena,获取元信息</span><span class="token function">ASSERT</span><span class="token punctuation">(</span>a<span class="token operator">-></span>large <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> a<span class="token operator">-></span>large <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token operator">-></span>desc <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> a<span class="token operator">-></span>large <span class="token operator">==</span> true<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 大于1024的内存</span><span class="token function">mfree_page</span><span class="token punctuation">(</span>PF<span class="token punctuation">,</span> a<span class="token punctuation">,</span> a<span class="token operator">-></span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 小于等于1024的内存块先将内存块回收到free_list</span><span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">-></span>desc<span class="token operator">-></span>free_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token operator">-></span>free_elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 再判断此arena中的内存块是否都是空闲,如果是就释放arena */</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token operator">-></span>cnt <span class="token operator">==</span> a<span class="token operator">-></span>desc<span class="token operator">-></span>blocks_per_arena<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">uint32_t</span> block_idx<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> block_idx <span class="token operator">&lt;</span> a<span class="token operator">-></span>desc<span class="token operator">-></span>blocks_per_arena<span class="token punctuation">;</span> block_idx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">mem_block</span><span class="token operator">*</span>  b <span class="token operator">=</span> <span class="token function">arena2block</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> block_idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token operator">-></span>desc<span class="token operator">-></span>free_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token operator">-></span>free_elem<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">list_remove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token operator">-></span>free_elem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">mfree_page</span><span class="token punctuation">(</span>PF<span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span>   <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>kernel/memory.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sys_free</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_a"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_a<span class="token punctuation">,</span> <span class="token string">"I am thread_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_b"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_b<span class="token punctuation">,</span> <span class="token string">"I am thread_b "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr1<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr4<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr5<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr6<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr7<span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_a start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span>max<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>      addr1 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>       size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>       addr2 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>       size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>       addr3 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr4 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>       size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>       addr5 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr6 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr5<span class="token punctuation">)</span><span class="token punctuation">;</span>      size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>       addr7 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr6<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr7<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr4<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_a end\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span><span class="token operator">*</span> para <span class="token operator">=</span> arg<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr1<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr4<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr5<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr6<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr7<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr8<span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr9<span class="token punctuation">;</span>   <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_b start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span>max<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>      addr1 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>       addr2 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token function">sys_free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr3 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr4 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr5 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr6 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr5<span class="token punctuation">)</span><span class="token punctuation">;</span>      size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>       addr7 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr6<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr7<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr4<span class="token punctuation">)</span><span class="token punctuation">;</span>      size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> size <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>       addr1 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr2 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr3 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr4 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr5 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr6 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr7 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr8 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      addr9 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr4<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr5<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr6<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr7<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr8<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_free</span><span class="token punctuation">(</span>addr9<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_b end\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token string">"prog_a"</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" I am %s, my pid:%d%c"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">char</span><span class="token operator">*</span> name <span class="token operator">=</span> <span class="token string">"prog_b"</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" I am %s, my pid:%d%c"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，我们来将<code>sys_malloc</code>与<code>sys_free</code>封装成用户程序可用的调用接口</p><p>增加系统调用号，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span> <span class="token punctuation">&#123;</span>   SYS_GETPID<span class="token punctuation">,</span>   SYS_WRITE<span class="token punctuation">,</span>   SYS_MALLOC<span class="token punctuation">,</span>   SYS_FREE<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>封装系统调用用户入口，修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 申请size字节大小的内存,并返回结果 */</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_MALLOC<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 释放ptr指向的内存 */</span><span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_FREE<span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明函数，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注册系统调用函数</p><p>修改（<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span> </span><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>syscall_table<span class="token punctuation">[</span>SYS_WRITE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_write<span class="token punctuation">;</span>syscall_table<span class="token punctuation">[</span>SYS_MALLOC<span class="token punctuation">]</span> <span class="token operator">=</span> sys_malloc<span class="token punctuation">;</span>   syscall_table<span class="token punctuation">[</span>SYS_FREE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_free<span class="token punctuation">;</span><span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试函数（<strong>kernel/main.c</strong>），相比作者代码，k_thread_a与k_thread_b内的消耗时间变量由100000增加到了9999999，否则不会出现书上结果，因为线程在切换前就已经释放了地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_a<span class="token punctuation">,</span> <span class="token string">"u_prog_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_b<span class="token punctuation">,</span> <span class="token string">"u_prog_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_a"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_a<span class="token punctuation">,</span> <span class="token string">"I am thread_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_b"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_b<span class="token punctuation">,</span> <span class="token string">"I am thread_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_a malloc addr:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">9999999</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_b malloc addr:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">999999</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" prog_a malloc addr:0x%x,0x%x,0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" prog_b malloc addr:0x%x,0x%x,0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        本章是编写磁盘驱动，也就是用于与磁盘打交道（比如读、写）的程序。未来我们实现文件系统是放在磁盘上的，所以编写磁盘驱动必不可少。然后在输入框依次输入以下，输入一个，按一次回车</p><pre class="line-numbers language-none"><code class="language-none">1hdflat80hd80M.img<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们在bochsrc.disk文件中，写入</p><pre class="line-numbers language-none"><code class="language-none">ata0-slave: type&#x3D;disk, path&#x3D;&quot;hd80M.img&quot;, mode&#x3D;flat,cylinders&#x3D;162,heads&#x3D;16,spt&#x3D;63<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样，bochs虚拟机启动时，就会识别这个磁盘并且自动挂载。</p><p>​        现在，我们来为这个新的磁盘进行分区，这是为了之后的文件系统做准备。分区的本质，就是将多个连续的柱面（详见书P123）划分为一个区域。</p><p>​        在bochs目录下，输入：</p><pre class="line-numbers language-none"><code class="language-none">fdisk .&#x2F;hd80M.img<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来使用fdisk工具来为刚刚创建的磁盘开始进行分区。</p><p>然后在输入框依次输入以下，输入一个，按一次回车</p><p><code>m</code> 显示菜单</p><p><code>x</code> 使用额外功能</p><p><code>m</code> 显示菜单</p><p><code>c</code> 设定柱面</p><pre class="line-numbers language-none"><code class="language-none">162<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>h</code> 设定磁头数</p><pre class="line-numbers language-none"><code class="language-none">16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>r</code> 返回上一级菜单</p><p><code>n</code> 新增一个分区</p><p><code>p</code> 分区是个主分区</p><p><code>1</code> 分区号设定为1</p><p><code>2048</code> 在旧的fdisk版本中，通常使用”柱面”（Cylinders）、“磁头”（Heads）和”扇区”（Sectors）这些术语来描述磁盘布局。现代磁盘和磁盘管理工具通常直接以扇区为单位进行操作。作者的1分区起始柱面是1，计算得起始扇区应该是63 * 16 = 1008，我们创建hd80M.img时，会提示<code>Creating hard disk image &#39;hd80M.img&#39; with CHS=162/16/63</code>，意思就是柱面162个，磁头16个，每个磁道63个扇区。但是由于fdisk工具指定第一个分区最小起始扇区为2048，所以我们只能设定1分区起始扇区为2048</p><p><code>33263</code> 作者指定了1分区结束柱面为32，计算得结束扇区为（32 + 1）<em> 16 </em> 63 - 1 = 33263，-1 是因为扇区从0开始编号</p><p><code>n</code> 新增一个分区</p><p><code>e</code> 分区是个扩展分区。最初磁盘只支持最多分4个区。但是后来由于需求增加，磁盘需要支持能分更多区，同时又为了能够兼容旧有的最多支持4个分区，所以就发明了扩展分区。扩展分区并不直接用于存储数据，而是作为一个容器，可以创建多个逻辑分区在其中。这样，即使主分区的数量限制为四个，我们仍然可以在一个扩展分区中创建多个逻辑分区，从而实现对更多分区的需求。一个磁盘，最多一个扩展分区。</p><p><code>4</code> 分区号码设定为4</p><p><code>33264</code> 分区起始扇区设定为分区1结束扇区下一个扇区</p><p><code>163295</code> 分区结束扇区设定为整个磁盘最后一个扇区，也就是说我们这个磁盘就两个分区，一个主分区1，一个扩展分区4</p><p><code>p</code> 查看现有分区</p><p><code>n</code> 创建分区，由于我们现在磁盘已经被两个分区占满了，所以不能再支持新的主分区创建，又由于扩展分区只能有1个，所以不能再支持扩展分区的创建。所以此时输入n，直接是创建逻辑分区（扩展分区再次分区后，每个分区叫做逻辑分区）</p><p><code>35312</code> 直接设定工具允许的逻辑分区起始最小扇区</p><p><code>51407</code> 作者指定了逻辑分区5结束柱面为50，计算得结束扇区为（50 + 1）<em> 16 </em> 63 - 1 = 51407，-1 是因为扇区从0开始编号</p><p><code>n</code> 创建分区</p><p><code>53456</code> 直接设定工具允许的逻辑分区起始最小扇区</p><p><code>76607</code> 作者指定了逻辑分区6结束柱面为75，计算得结束扇区为（75 + 1）<em> 16 </em> 63 - 1 = 76607，-1 是因为扇区从0开始编号</p><p><code>n</code> 创建分区</p><p><code>78656</code> 直接设定工具允许的逻辑分区起始最小扇区</p><p><code>91727</code> 作者指定了逻辑分区7结束柱面为90，计算得结束扇区为（90 + 1）<em> 16 </em> 63 - 1 = 91727，-1 是因为扇区从0开始编号</p><p><code>n</code> 创建分区</p><p><code>93776</code> 直接设定工具允许的逻辑分区起始最小扇区</p><p><code>121967</code> 作者指定了逻辑分区8结束柱面为120，计算得结束扇区为（120 + 1）<em> 16 </em> 63 - 1 = 121967，-1 是因为扇区从0开始编号</p><p><code>n</code> 创建分区</p><p><code>124016</code> 直接设定工具允许的逻辑分区起始最小扇区</p><p><code>163295</code> 设定最后一个可用扇区为逻辑分区9的结束扇区</p><p><code>p</code> 显示分区</p><p><code>t</code> 设定分区类型id</p><p><code>5</code> 改变逻辑分区5的类型id</p><p><code>66</code> 设定类型id为0x66</p><p><code>t</code> 设定分区类型id</p><p><code>6</code> 改变逻辑分区6的类型id</p><p><code>66</code> 设定类型id为0x66</p><p><code>t</code> 设定分区类型id</p><p><code>7</code> 改变逻辑分区7的类型id</p><p><code>66</code> 设定类型id为0x66</p><p><code>t</code> 设定分区类型id</p><p><code>8</code> 改变逻辑分区8的类型id</p><p><code>66</code> 设定类型id为0x66</p><p><code>t</code> 设定分区类型id</p><p><code>9</code> 改变逻辑分区9的类型id</p><p><code>66</code> 设定类型id为0x66</p><p><code>p</code> 显示分区</p><p><code>w</code> 将分区表写入磁盘，并退出fdisk 分区表是用于描述每个分区的信息，详见P571</p><p><code>fdisk -l hd80M.img</code> 查看分区信息</p><p>至此，我们创建分区就完毕了。我们创建的分区布局如下图：<br><img src="f28c7a1f2af84add9a9a8e8a9045b8f6.png" alt="在这里插入图片描述"><br>这里面有几个要强调的点：</p><p>1、子拓展分区在逻辑上等同于一整块硬盘，也就是说，我们把总拓展分区划分成了多块硬盘；</p><p>2、MBR分区表共有4项，用于标识4个分区的起始扇区与大小，只不过我们只创建了一个分区，另一分区用作总扩展分区。而EBR分区表也有4项，第一项用于表示这个子拓展分区的逻辑分区偏移与大小，第二项用于表示下一个子拓展分区的偏移与大小，第3项与第4项没有使用，所以说一个子拓展分区就一个逻辑分区</p><p>在以前，我们内核态下进行打印一直用的console_put_xxx之类的函数，这很不方便，因为我们经常打印信息需要调用console_put_int, console_put_str, console_put_ch这三个函数配合使用。所以我们先来实现一个类似于用户态函数printf的内核态函数printk</p><p>（<strong>lib/kernel/stdio-kernel.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio-kernel.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">va_start</span><span class="token expression"><span class="token punctuation">(</span>args<span class="token punctuation">,</span> first_fix<span class="token punctuation">)</span> args <span class="token operator">=</span> <span class="token punctuation">(</span>va_list<span class="token punctuation">)</span><span class="token operator">&amp;</span>first_fix</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">va_end</span><span class="token expression"><span class="token punctuation">(</span>args<span class="token punctuation">)</span> args <span class="token operator">=</span> <span class="token constant">NULL</span></span></span><span class="token comment">/* 供内核使用的格式化输出函数 */</span><span class="token keyword">void</span> <span class="token function">printk</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    va_list args<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">vsprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">console_put_str</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明（<strong>lib/kernel/stdio-kernel.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__LIB_KERNEL_STDIOSYS_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIB_KERNEL_STDIOSYS_H</span></span><span class="token keyword">void</span> <span class="token function">printk</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>再实现一个用于将格式化字符串放入缓冲区的函数sprintf，同printf相比，它不将信息打印在屏幕上，而是放入缓冲区中。</p><p>修改（<strong>lib/stdio.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 同printf不同的地方就是字符串不是写到终端,而是写到buf中 */</span><span class="token class-name">uint32_t</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   va_list args<span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> retval<span class="token punctuation">;</span>   <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>   retval <span class="token operator">=</span> <span class="token function">vsprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> retval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加函数声明，修改（<strong>lib/stdio.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来我们正式编写硬盘驱动</p><p>首先，我们需要做的是打开硬盘对应的中断信号，主板上有两个IDE通道，每个通道可以挂载两个硬盘。第一个IDE通道的中断信号通过8259A从片的IRQ14线进入，而第二个IDE通道的中断信号通过8259A从片的IRQ15线进入（虽然下面的图上写的是保留）</p><p><img src="045a31f121cc446781235b44779fdca5.png" alt="在这里插入图片描述"><br>由于我们的两个磁盘都是挂在了IDE通道0上，而IDE通道0又是挂在了IRQ14线上，所以我们只需要再打开这条线的中断信号就行</p><p>修改（<strong>kernel/interrupt.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 初始化可编程中断控制器8259A */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pic_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">/* 初始化主片 */</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_CTRL<span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW2: 起始中断向量号为0x20,也就是IR[0-7] 为 0x20 ~ 0x27.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0x04</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW3: IR2接从片. </span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// ICW4: 8086模式, 正常EOI</span>   <span class="token comment">/* 初始化从片 */</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_CTRL<span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ICW1: 边沿触发,级联8259, 需要ICW4.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0x28</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ICW2: 起始中断向量号为0x28,也就是IR[8-15] 为 0x28 ~ 0x2F.</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0x02</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ICW3: 设置从片连接到主片的IR2引脚</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ICW4: 8086模式, 正常EOI</span>    <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_M_DATA<span class="token punctuation">,</span> <span class="token number">0xf8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//IRQ2用于级联从片,必须打开,否则无法响应从片上的中断主片上打开的中断有IRQ0的时钟,IRQ1的键盘和级联从片的IRQ2,其它全部关闭</span>   <span class="token function">outb</span> <span class="token punctuation">(</span>PIC_S_DATA<span class="token punctuation">,</span> <span class="token number">0xbf</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//打开从片上的IRQ14,此引脚接收硬盘控制器的中断 </span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"   pic_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>硬盘是真实存在的硬件，我们要想在软件中管理它们，只能从逻辑上抓住这些硬件的特性，将它们抽象成一些数据结构，用这些数据结构来组织硬件的信息及状态，我们管理这些数据结构就是在管理真实的硬盘。所以，我们来实现与硬盘相关的数据结构。注意，以下3个数据结构形成了层级关系，即：通道挂载硬盘，共有两个通道，每个通道可挂载一主一从两个硬盘；每个硬盘都有分区，可以最多支持4个主分区，一个主分区划分成扩展分区后可以再次划分出多个逻辑分区。</p><p>（<strong>device/ide.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__DEVICE_IDE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__DEVICE_IDE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sync.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"bitmap.h"</span></span><span class="token comment">/* 分区结构 */</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> start_lba<span class="token punctuation">;</span> <span class="token comment">// 起始扇区</span>    <span class="token class-name">uint32_t</span> sec_cnt<span class="token punctuation">;</span> <span class="token comment">// 扇区数</span>    <span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> my_disk<span class="token punctuation">;</span> <span class="token comment">// 分区所属的硬盘</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> part_tag<span class="token punctuation">;</span> <span class="token comment">// 用于队列中的标记，用于将分区形成链表进行管理</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 分区名称</span>    <span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token operator">*</span> sb<span class="token punctuation">;</span> <span class="token comment">// 本分区的超级块</span>    <span class="token keyword">struct</span> <span class="token class-name">bitmap</span> block_bitmap<span class="token punctuation">;</span> <span class="token comment">// 块位图</span>    <span class="token keyword">struct</span> <span class="token class-name">bitmap</span> inode_bitmap<span class="token punctuation">;</span> <span class="token comment">// i结点位图</span>    <span class="token keyword">struct</span> <span class="token class-name">list</span> open_inodes<span class="token punctuation">;</span> <span class="token comment">// 本分区打开的i结点队列</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* 硬盘结构 */</span><span class="token keyword">struct</span> <span class="token class-name">disk</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 本硬盘的名称，如sda等</span>    <span class="token keyword">struct</span> <span class="token class-name">ide_channel</span><span class="token operator">*</span> my_channel<span class="token punctuation">;</span>   <span class="token comment">// 此块硬盘归属于哪个ide通道</span>    <span class="token class-name">uint8_t</span> dev_no<span class="token punctuation">;</span>   <span class="token comment">// 本硬盘是主0还是从1</span>    <span class="token keyword">struct</span> <span class="token class-name">partition</span> prim_parts<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 主分区顶多是4个</span>    <span class="token keyword">struct</span> <span class="token class-name">partition</span> logic_parts<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 逻辑分区数量无限,但总得有个支持的上限,那就支持8个</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* ata通道结构 */</span><span class="token keyword">struct</span> <span class="token class-name">ide_channel</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 本ata通道名称 </span>    <span class="token class-name">uint16_t</span> port_base<span class="token punctuation">;</span> <span class="token comment">// 本通道的起始端口号（书p126）</span>    <span class="token class-name">uint8_t</span> irq_no<span class="token punctuation">;</span> <span class="token comment">// 本通道所用的中断号</span>    <span class="token keyword">struct</span> <span class="token class-name">lock</span> lock<span class="token punctuation">;</span> <span class="token comment">// 通道锁</span>    bool expecting_intr<span class="token punctuation">;</span> <span class="token comment">// 表示等待硬盘的中断</span>    <span class="token keyword">struct</span> <span class="token class-name">semaphore</span> disk_done<span class="token punctuation">;</span> <span class="token comment">// 用于阻塞、唤醒驱动程序</span>    <span class="token keyword">struct</span> <span class="token class-name">disk</span> devices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 一个通道上连接两个硬盘，一主一从</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了数据结构，自然就需要根据我们的环境来创建并初始化（<strong>device.ide.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ide.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sync.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio-kernel.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token comment">/* 定义硬盘各寄存器的端口号，见书p126 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_data</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">(</span>channel<span class="token operator">-></span>port_base <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_error</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">(</span>channel<span class="token operator">-></span>port_base <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_sect_cnt</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">(</span>channel<span class="token operator">-></span>port_base <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_lba_l</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">(</span>channel<span class="token operator">-></span>port_base <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_lba_m</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">(</span>channel<span class="token operator">-></span>port_base <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_lba_h</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">(</span>channel<span class="token operator">-></span>port_base <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_dev</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">(</span>channel<span class="token operator">-></span>port_base <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_status</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">(</span>channel<span class="token operator">-></span>port_base <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_cmd</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">reg_status</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_alt_status</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span>  <span class="token punctuation">(</span>channel<span class="token operator">-></span>port_base <span class="token operator">+</span> <span class="token number">0x206</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">reg_ctl</span><span class="token expression"><span class="token punctuation">(</span>channel<span class="token punctuation">)</span> <span class="token function">reg_alt_status</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span></span></span><span class="token comment">/* reg_alt_status寄存器的一些关键位，见书p128 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIT_STAT_BSY</span> <span class="token expression"><span class="token number">0x80</span>      </span><span class="token comment">// 硬盘忙</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIT_STAT_DRDY</span> <span class="token expression"><span class="token number">0x40</span>      </span><span class="token comment">// 设备准备好 </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIT_STAT_DRQ</span> <span class="token expression"><span class="token number">0x8</span>      </span><span class="token comment">// 数据传输准备好了</span></span><span class="token comment">/* device寄存器的一些关键位 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIT_DEV_MBS</span><span class="token expression"><span class="token number">0xa0</span>    </span><span class="token comment">// 第7位和第5位固定为1</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIT_DEV_LBA</span><span class="token expression"><span class="token number">0x40</span>        </span><span class="token comment">//指定为LBA寻址方式</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIT_DEV_DEV</span><span class="token expression"><span class="token number">0x10</span>        </span><span class="token comment">//指定主盘或从盘，DEV位为1表示从盘，为0表示主盘</span></span><span class="token comment">/* 一些硬盘操作的指令 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_IDENTIFY</span>   <span class="token expression"><span class="token number">0xec</span>    </span><span class="token comment">// identify指令</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_READ_SECTOR</span>   <span class="token expression"><span class="token number">0x20</span>     </span><span class="token comment">// 读扇区指令</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CMD_WRITE_SECTOR</span>   <span class="token expression"><span class="token number">0x30</span>    </span><span class="token comment">// 写扇区指令</span></span><span class="token comment">/* 定义可读写的最大扇区数,调试用的 */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">max_lba</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">/</span><span class="token number">512</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></span><span class="token comment">// 只支持80MB硬盘</span></span><span class="token class-name">uint8_t</span> channel_cnt<span class="token punctuation">;</span>   <span class="token comment">// 记录通道数</span><span class="token keyword">struct</span> <span class="token class-name">ide_channel</span> channels<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 有两个ide通道</span><span class="token comment">/* 硬盘数据结构初始化 */</span><span class="token keyword">void</span> <span class="token function">ide_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"ide_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> hd_cnt <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x475</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 获取硬盘的数量</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>hd_cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    channel_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>hd_cnt<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道</span>    <span class="token keyword">struct</span> <span class="token class-name">ide_channel</span><span class="token operator">*</span> channel<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> channel_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 处理每个通道上的硬盘 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>channel_no <span class="token operator">&lt;</span> channel_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        channel <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span>channel_no<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>channel<span class="token operator">-></span>name<span class="token punctuation">,</span> <span class="token string">"ide%d"</span><span class="token punctuation">,</span> channel_no<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 为每个ide通道初始化端口基址及中断向量 */</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>channel_no<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>            channel<span class="token operator">-></span>port_base <span class="token operator">=</span> <span class="token number">0x1f0</span><span class="token punctuation">;</span>   <span class="token comment">// ide0通道的起始端口号是0x1f0</span>            channel<span class="token operator">-></span>irq_no <span class="token operator">=</span> <span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">14</span><span class="token punctuation">;</span>   <span class="token comment">// 从片8259a上倒数第二的中断引脚,温盘,也就是ide0通道的的中断向量号</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>            channel<span class="token operator">-></span>port_base <span class="token operator">=</span> <span class="token number">0x170</span><span class="token punctuation">;</span>   <span class="token comment">// ide1通道的起始端口号是0x170</span>            channel<span class="token operator">-></span>irq_no <span class="token operator">=</span> <span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">15</span><span class="token punctuation">;</span>   <span class="token comment">// 从8259A上的最后一个中断引脚,我们用来响应ide1通道上的硬盘中断</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        channel<span class="token operator">-></span>expecting_intr <span class="token operator">=</span> false<span class="token punctuation">;</span>   <span class="token comment">// 未向硬盘写入指令时不期待硬盘的中断</span>        <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>channel<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">/* 初始化为0,目的是向硬盘控制器请求数据后,硬盘驱动sema_down此信号量会阻塞线程,    直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */</span>        <span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>channel<span class="token operator">-></span>disk_done<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        channel_no<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">// 下一个channel</span>    <span class="token punctuation">&#125;</span>   <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"ide_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，并把通道数量与通道数组全局声明，修改（<strong>device/ide.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ide_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token class-name">uint8_t</span> channel_cnt<span class="token punctuation">;</span><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">ide_channel</span> channels<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来我们实现一个<code>idle</code>线程，用于在就绪队列为空时运行。需要注意一点：我们之前没有<code>idle</code>线程，我们的系统没有出现书上说的由于就绪队列为空然后被<code>ASSERT(!list_empty(&amp;thread_ready_list);</code>悬停的情况，是因为我们的主线程（简单理解，就是main函数里面的while(1)）会一直被不断加入就绪队列，所以就绪队列并不存在为空的时候。</p><p>修改（<strong>thread/thread.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> idle_thread<span class="token punctuation">;</span>    <span class="token comment">// idle线程</span><span class="token comment">/* 系统空闲时运行的线程 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">idle</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg UNUSED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">thread_block</span><span class="token punctuation">(</span>TASK_BLOCKED<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//执行hlt时必须要保证目前处在开中断的情况下</span>      <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span><span class="token string">"sti; hlt"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 实现任务调度 */</span><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> INTR_OFF<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>status <span class="token operator">==</span> TASK_RUNNING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若此线程只是cpu时间片到了,将其加入到就绪队列尾</span>      <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cur<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cur<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>      cur<span class="token operator">-></span>ticks <span class="token operator">=</span> cur<span class="token operator">-></span>priority<span class="token punctuation">;</span>     <span class="token comment">// 重新将当前线程的ticks再重置为其priority;</span>      cur<span class="token operator">-></span>status <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>       <span class="token comment">/* 若此线程需要某事件发生后才能继续上cpu运行,      不需要将其加入队列,因为当前线程不在就绪队列中。*/</span>   <span class="token punctuation">&#125;</span>      <span class="token comment">/* 如果就绪队列中没有可运行的任务,就唤醒idle */</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">thread_unblock</span><span class="token punctuation">(</span>idle_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">list_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   thread_tag <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// thread_tag清空</span><span class="token comment">/* 将thread_ready_list队列中的第一个就绪线程弹出,准备将其调度上cpu. */</span>   thread_tag <span class="token operator">=</span> <span class="token function">list_pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> next <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> general_tag<span class="token punctuation">,</span> thread_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>   next<span class="token operator">-></span>status <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span>   <span class="token function">process_activate</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//激活任务页表</span>   <span class="token function">switch_to</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token comment">/* 初始化线程环境 */</span><span class="token keyword">void</span> <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 将当前main函数创建为线程 */</span>   <span class="token function">make_main_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* 创建idle线程 */</span>   idle_thread <span class="token operator">=</span> <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"idle"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> idle<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码，修改（<strong>kernel/global.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">UNUSED</span> <span class="token expression"><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>unused<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>硬盘是一个相对于CPU来说及其低速的设备，所以，当硬盘在进行需要长时间才能完成的工作时（比如写入数据），我们最好能让驱动程序把CPU让给其他任务。所以，我们来实现一个<code>thread_yield</code>函数，就是用于把CPU让出来。实质就是将调用者重新放入就绪队列队尾。</p><p>修改（<strong>thread/thread.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 主动让出cpu,换其它线程运行 */</span><span class="token keyword">void</span> <span class="token function">thread_yield</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cur<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cur<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>   cur<span class="token operator">-></span>status <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span>   <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>thread_yield</code>中有个关中断的操作，会不会导致切换后由于关闭中断，而不响应时钟中断导致一直运行在切换后的进程/线程中呢？其实并不会，我们讨论两种情况，一种是进程/线程第一次上机运行，一种是进程/线程之前已经运行过，但由于时间片到期而换下过处理器。对于前者，我们进程/线程第一次上机运行都会经过<code>kernel_thread</code>这个线程启动器，而这个里面是有开中断的代码的。对于后者，当切换回进程/线程时，它们执行<code>kernel.S</code>中的中断退出代码<code>jmp intr_exit</code>，这里面有一条指令<code>iretd</code>会打开中断，让处理器能够继续响应中断代理发送来的中断信号。</p><p>由于<code>thread_yield</code>不是由于时间片到期而换下处理器，所以当再次调度运行时，并不会执行<code>kernel.S</code>中的中断退出代码<code>jmp intr_exit</code>，所以要人为写上恢复中断状态的代码（开中断）。</p><p>函数声明（<strong>thread/thread.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">thread_yield</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之前我们实现的<code>thread_yield</code>是将当前任务加入就绪队列队尾，仅仅是把CPU让出来一次。我们来实现一个定时让出CPU的函数，也就是让一个任务在固定时间内都不执行。</p><p>修改（<strong>device/timer.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">mil_seconds_per_intr</span> <span class="token expression"><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">/</span> IRQ0_FREQUENCY<span class="token punctuation">)</span></span></span><span class="token comment">/* 以tick为单位的sleep,任何时间形式的sleep会转换此ticks形式 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ticks_to_sleep</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> sleep_ticks<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span> start_tick <span class="token operator">=</span> ticks<span class="token punctuation">;</span>   <span class="token comment">/* 若间隔的ticks数不够便让出cpu */</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span>ticks <span class="token operator">-</span> start_tick <span class="token operator">&lt;</span> sleep_ticks<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">thread_yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 以毫秒为单位的sleep   1秒= 1000毫秒 */</span><span class="token keyword">void</span> <span class="token function">mtime_sleep</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> m_seconds<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token class-name">uint32_t</span> sleep_ticks <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>m_seconds<span class="token punctuation">,</span> mil_seconds_per_intr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">ASSERT</span><span class="token punctuation">(</span>sleep_ticks <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">ticks_to_sleep</span><span class="token punctuation">(</span>sleep_ticks<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>device/timer.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token keyword">void</span> <span class="token function">mtime_sleep</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> m_seconds<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，我们来实现驱动程序的主体部分，也就是实际与硬盘打交道的函数，实质就是将一系列寄存器操作进行封装</p><p>修改（<strong>device/ide.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"io.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"timer.h"</span></span><span class="token comment">/* 选择读写的硬盘 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">select_disk</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> reg_device <span class="token operator">=</span> BIT_DEV_MBS <span class="token operator">|</span> BIT_DEV_LBA<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hd<span class="token operator">-></span>dev_no <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 若是从盘就置DEV位为1</span>        reg_device <span class="token operator">|=</span> BIT_DEV_DEV<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token function">reg_dev</span><span class="token punctuation">(</span>hd<span class="token operator">-></span>my_channel<span class="token punctuation">)</span><span class="token punctuation">,</span> reg_device<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 向硬盘控制器写入起始扇区地址及要读写的扇区数 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">select_sector</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> lba<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> sec_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">ASSERT</span><span class="token punctuation">(</span>lba <span class="token operator">&lt;=</span> max_lba<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">struct</span> <span class="token class-name">ide_channel</span><span class="token operator">*</span> channel <span class="token operator">=</span> hd<span class="token operator">-></span>my_channel<span class="token punctuation">;</span>   <span class="token comment">/* 写入要读写的扇区数*/</span>   <span class="token function">outb</span><span class="token punctuation">(</span><span class="token function">reg_sect_cnt</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">,</span> sec_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果sec_cnt为0,则表示写入256个扇区</span>   <span class="token comment">/* 写入lba地址(即扇区号) */</span>   <span class="token function">outb</span><span class="token punctuation">(</span><span class="token function">reg_lba_l</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">,</span> lba<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lba地址的低8位,不用单独取出低8位.outb函数中的汇编指令outb %b0, %w1会只用al。</span>   <span class="token function">outb</span><span class="token punctuation">(</span><span class="token function">reg_lba_m</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">,</span> lba <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lba地址的8~15位</span>   <span class="token function">outb</span><span class="token punctuation">(</span><span class="token function">reg_lba_h</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">,</span> lba <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lba地址的16~23位</span>   <span class="token comment">/* 因为lba地址的24~27位要存储在device寄存器的0～3位,    * 无法单独写入这4位,所以在此处把device寄存器再重新写入一次*/</span>   <span class="token function">outb</span><span class="token punctuation">(</span><span class="token function">reg_dev</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">,</span> BIT_DEV_MBS <span class="token operator">|</span> BIT_DEV_LBA <span class="token operator">|</span> <span class="token punctuation">(</span>hd<span class="token operator">-></span>dev_no <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> BIT_DEV_DEV <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">|</span> lba <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 向通道channel发命令cmd */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cmd_out</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ide_channel</span><span class="token operator">*</span> channel<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> cmd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">/* 只要向硬盘发出了命令便将此标记置为true,硬盘中断处理程序需要根据它来判断 */</span>    channel<span class="token operator">-></span>expecting_intr <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token function">outb</span><span class="token punctuation">(</span><span class="token function">reg_cmd</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">,</span> cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 硬盘读入sec_cnt个扇区的数据到buf */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">read_from_sector</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> sec_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> size_in_byte<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sec_cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */</span>        size_in_byte <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">512</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>         size_in_byte <span class="token operator">=</span> sec_cnt <span class="token operator">*</span> <span class="token number">512</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token function">insw</span><span class="token punctuation">(</span><span class="token function">reg_data</span><span class="token punctuation">(</span>hd<span class="token operator">-></span>my_channel<span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size_in_byte <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 将buf中sec_cnt扇区的数据写入硬盘 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">write2sector</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> sec_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> size_in_byte<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sec_cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 因为sec_cnt是8位变量,由主调函数将其赋值时,若为256则会将最高位的1丢掉变为0 */</span>        size_in_byte <span class="token operator">=</span> <span class="token number">256</span> <span class="token operator">*</span> <span class="token number">512</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>         size_in_byte <span class="token operator">=</span> sec_cnt <span class="token operator">*</span> <span class="token number">512</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token function">outsw</span><span class="token punctuation">(</span><span class="token function">reg_data</span><span class="token punctuation">(</span>hd<span class="token operator">-></span>my_channel<span class="token punctuation">)</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size_in_byte <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 等待30秒 */</span><span class="token keyword">static</span> bool <span class="token function">busy_wait</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">ide_channel</span><span class="token operator">*</span> channel <span class="token operator">=</span> hd<span class="token operator">-></span>my_channel<span class="token punctuation">;</span>    <span class="token class-name">uint16_t</span> time_limit <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>     <span class="token comment">// 可以等待30000毫秒</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>time_limit <span class="token operator">-=</span> <span class="token number">10</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">inb</span><span class="token punctuation">(</span><span class="token function">reg_status</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> BIT_STAT_BSY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">inb</span><span class="token punctuation">(</span><span class="token function">reg_status</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> BIT_STAT_DRQ<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token function">mtime_sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 睡眠10毫秒</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 从硬盘读取sec_cnt个扇区到buf */</span><span class="token keyword">void</span> <span class="token function">ide_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> lba<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> sec_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token function">ASSERT</span><span class="token punctuation">(</span>lba <span class="token operator">&lt;=</span> max_lba<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>sec_cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lock_acquire</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>hd<span class="token operator">-></span>my_channel<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 1 先选择操作的硬盘 */</span>    <span class="token function">select_disk</span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> secs_op<span class="token punctuation">;</span> <span class="token comment">// 每次操作的扇区数</span>    <span class="token class-name">uint32_t</span> secs_done <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已完成的扇区数</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>secs_done <span class="token operator">&lt;</span> sec_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>secs_done <span class="token operator">+</span> <span class="token number">256</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> sec_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            secs_op <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            secs_op <span class="token operator">=</span> sec_cnt <span class="token operator">-</span> secs_done<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">/* 2 写入待读入的扇区数和起始扇区号 */</span>        <span class="token function">select_sector</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> lba <span class="token operator">+</span> secs_done<span class="token punctuation">,</span> secs_op<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 3 执行的命令写入reg_cmd寄存器 */</span>        <span class="token function">cmd_out</span><span class="token punctuation">(</span>hd<span class="token operator">-></span>my_channel<span class="token punctuation">,</span> CMD_READ_SECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 准备开始读数据</span>    <span class="token comment">/*********************   阻塞自己的时机  ***********************         在硬盘已经开始工作(开始在内部读数据或写数据)后才能阻塞自己,现在硬盘已经开始忙了,        将自己阻塞,等待硬盘完成读操作后通过中断处理程序唤醒自己*/</span>        <span class="token function">sema_down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hd<span class="token operator">-></span>my_channel<span class="token operator">-></span>disk_done<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*************************************************************/</span>    <span class="token comment">/* 4 检测硬盘状态是否可读 */</span>        <span class="token comment">/* 醒来后开始执行下面代码*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">busy_wait</span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若失败</span>            <span class="token keyword">char</span> error<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">sprintf</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> <span class="token string">"%s read sector %d failed!!!!!!\n"</span><span class="token punctuation">,</span> hd<span class="token operator">-></span>name<span class="token punctuation">,</span> lba<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PANIC</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">/* 5 把数据从硬盘的缓冲区中读出 */</span>        <span class="token function">read_from_sector</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>buf <span class="token operator">+</span> secs_done <span class="token operator">*</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> secs_op<span class="token punctuation">)</span><span class="token punctuation">;</span>        secs_done <span class="token operator">+=</span> secs_op<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hd<span class="token operator">-></span>my_channel<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 将buf中sec_cnt扇区数据写入硬盘 */</span><span class="token keyword">void</span> <span class="token function">ide_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> lba<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> sec_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>lba <span class="token operator">&lt;=</span> max_lba<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>sec_cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lock_acquire</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>hd<span class="token operator">-></span>my_channel<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 1 先选择操作的硬盘 */</span>    <span class="token function">select_disk</span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> secs_op<span class="token punctuation">;</span> <span class="token comment">// 每次操作的扇区数</span>    <span class="token class-name">uint32_t</span> secs_done <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已完成的扇区数</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>secs_done <span class="token operator">&lt;</span> sec_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>secs_done <span class="token operator">+</span> <span class="token number">256</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> sec_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            secs_op <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            secs_op <span class="token operator">=</span> sec_cnt <span class="token operator">-</span> secs_done<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">/* 2 写入待写入的扇区数和起始扇区号 */</span>        <span class="token function">select_sector</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> lba <span class="token operator">+</span> secs_done<span class="token punctuation">,</span> secs_op<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 3 执行的命令写入reg_cmd寄存器 */</span>        <span class="token function">cmd_out</span><span class="token punctuation">(</span>hd<span class="token operator">-></span>my_channel<span class="token punctuation">,</span> CMD_WRITE_SECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 准备开始写数据</span>    <span class="token comment">/* 4 检测硬盘状态是否可读 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">busy_wait</span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 若失败</span>            <span class="token keyword">char</span> error<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">sprintf</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> <span class="token string">"%s write sector %d failed!!!!!!\n"</span><span class="token punctuation">,</span> hd<span class="token operator">-></span>name<span class="token punctuation">,</span> lba<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">PANIC</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token comment">/* 5 将数据写入硬盘 */</span>        <span class="token function">write2sector</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>buf <span class="token operator">+</span> secs_done <span class="token operator">*</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">,</span> secs_op<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 在硬盘响应期间阻塞自己 */</span>        <span class="token function">sema_down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hd<span class="token operator">-></span>my_channel<span class="token operator">-></span>disk_done<span class="token punctuation">)</span><span class="token punctuation">;</span>        secs_done <span class="token operator">+=</span> secs_op<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 醒来后开始释放锁*/</span>    <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hd<span class="token operator">-></span>my_channel<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 硬盘中断处理程序 */</span><span class="token keyword">void</span> <span class="token function">intr_hd_handler</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> irq_no<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>irq_no <span class="token operator">==</span> <span class="token number">0x2e</span> <span class="token operator">||</span> irq_no <span class="token operator">==</span> <span class="token number">0x2f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> ch_no <span class="token operator">=</span> irq_no <span class="token operator">-</span> <span class="token number">0x2e</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">ide_channel</span><span class="token operator">*</span> channel <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span>ch_no<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>channel<span class="token operator">-></span>irq_no <span class="token operator">==</span> irq_no<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 不必担心此中断是否对应的是这一次的expecting_intr,    * 每次读写硬盘时会申请锁,从而保证了同步一致性 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token operator">-></span>expecting_intr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        channel<span class="token operator">-></span>expecting_intr <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token function">sema_up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>channel<span class="token operator">-></span>disk_done<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 读取状态寄存器使硬盘控制器认为此次的中断已被处理,从而硬盘可以继续执行新的读写 */</span>        <span class="token function">inb</span><span class="token punctuation">(</span><span class="token function">reg_status</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 硬盘数据结构初始化 */</span><span class="token keyword">void</span> <span class="token function">ide_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"ide_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> hd_cnt <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x475</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 获取硬盘的数量</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>hd_cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    channel_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>hd_cnt<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道</span>    <span class="token keyword">struct</span> <span class="token class-name">ide_channel</span><span class="token operator">*</span> channel<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> channel_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 处理每个通道上的硬盘 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>channel_no <span class="token operator">&lt;</span> channel_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        channel <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span>channel_no<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>channel<span class="token operator">-></span>name<span class="token punctuation">,</span> <span class="token string">"ide%d"</span><span class="token punctuation">,</span> channel_no<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 为每个ide通道初始化端口基址及中断向量 */</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>channel_no<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>            channel<span class="token operator">-></span>port_base <span class="token operator">=</span> <span class="token number">0x1f0</span><span class="token punctuation">;</span>   <span class="token comment">// ide0通道的起始端口号是0x1f0</span>            channel<span class="token operator">-></span>irq_no <span class="token operator">=</span> <span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">14</span><span class="token punctuation">;</span>   <span class="token comment">// 从片8259a上倒数第二的中断引脚,温盘,也就是ide0通道的的中断向量号</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>            channel<span class="token operator">-></span>port_base <span class="token operator">=</span> <span class="token number">0x170</span><span class="token punctuation">;</span>   <span class="token comment">// ide1通道的起始端口号是0x170</span>            channel<span class="token operator">-></span>irq_no <span class="token operator">=</span> <span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">15</span><span class="token punctuation">;</span>   <span class="token comment">// 从8259A上的最后一个中断引脚,我们用来响应ide1通道上的硬盘中断</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        channel<span class="token operator">-></span>expecting_intr <span class="token operator">=</span> false<span class="token punctuation">;</span>   <span class="token comment">// 未向硬盘写入指令时不期待硬盘的中断</span>        <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>channel<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">/* 初始化为0,目的是向硬盘控制器请求数据后,硬盘驱动sema_down此信号量会阻塞线程,    直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */</span>        <span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>channel<span class="token operator">-></span>disk_done<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">register_handler</span><span class="token punctuation">(</span>channel<span class="token operator">-></span>irq_no<span class="token punctuation">,</span> intr_hd_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>        channel_no<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">// 下一个channel</span>    <span class="token punctuation">&#125;</span>   <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"ide_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>device/ide.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">ide_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> lba<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> sec_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ide_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> lba<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> sec_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">intr_hd_handler</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> irq_no<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们来验证驱动程序能够运行，我们用它来：1、发送identify命令给硬盘来获取硬盘信息；2、扫描分区表；</p><p>修改（<strong>device/ide.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token comment">/* 用于记录总扩展分区的起始lba,初始为0,partition_scan时以此为标记 */</span><span class="token class-name">int32_t</span> ext_lba_base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">uint8_t</span> p_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用来记录硬盘主分区和逻辑分区的下标</span><span class="token keyword">struct</span> <span class="token class-name">list</span> partition_list<span class="token punctuation">;</span> <span class="token comment">// 分区队列</span><span class="token comment">/* 构建一个16字节大小的结构体,用来存分区表项 */</span><span class="token keyword">struct</span> <span class="token class-name">partition_table_entry</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span>  bootable<span class="token punctuation">;</span> <span class="token comment">// 是否可引导</span>    <span class="token class-name">uint8_t</span>  start_head<span class="token punctuation">;</span> <span class="token comment">// 起始磁头号</span>    <span class="token class-name">uint8_t</span>  start_sec<span class="token punctuation">;</span> <span class="token comment">// 起始扇区号</span>    <span class="token class-name">uint8_t</span>  start_chs<span class="token punctuation">;</span> <span class="token comment">// 起始柱面号</span>    <span class="token class-name">uint8_t</span>  fs_type<span class="token punctuation">;</span> <span class="token comment">// 分区类型</span>    <span class="token class-name">uint8_t</span>  end_head<span class="token punctuation">;</span> <span class="token comment">// 结束磁头号</span>    <span class="token class-name">uint8_t</span>  end_sec<span class="token punctuation">;</span> <span class="token comment">// 结束扇区号</span>    <span class="token class-name">uint8_t</span>  end_chs<span class="token punctuation">;</span> <span class="token comment">// 结束柱面号</span>    <span class="token comment">/* 更需要关注的是下面这两项 */</span>    <span class="token class-name">uint32_t</span> start_lba<span class="token punctuation">;</span> <span class="token comment">// 本分区起始扇区的lba地址</span>    <span class="token class-name">uint32_t</span> sec_cnt<span class="token punctuation">;</span> <span class="token comment">// 本分区的扇区数目</span><span class="token punctuation">&#125;</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证此结构是16字节大小</span><span class="token comment">/* 引导扇区,mbr或ebr所在的扇区 */</span><span class="token keyword">struct</span> <span class="token class-name">boot_sector</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span>  other<span class="token punctuation">[</span><span class="token number">446</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 引导代码</span>    <span class="token keyword">struct</span>   <span class="token class-name">partition_table_entry</span> partition_table<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 分区表中有4项,共64字节</span>    <span class="token class-name">uint16_t</span> signature<span class="token punctuation">;</span> <span class="token comment">// 启动扇区的结束标志是0x55,0xaa,</span><span class="token punctuation">&#125;</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 将dst中len个相邻字节交换位置后存入buf */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap_pairs_bytes</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> idx<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> idx <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> idx <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">/* buf中存储dst中两相邻元素交换位置后的字符串*/</span>        buf<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>dst<span class="token operator">++</span><span class="token punctuation">;</span>           buf<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token operator">*</span>dst<span class="token operator">++</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>    buf<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 获得硬盘参数信息 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">identify_disk</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> id_info<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">select_disk</span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">cmd_out</span><span class="token punctuation">(</span>hd<span class="token operator">-></span>my_channel<span class="token punctuation">,</span> CMD_IDENTIFY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 向硬盘发送指令后便通过信号量阻塞自己,    * 待硬盘处理完成后,通过中断处理程序将自己唤醒 */</span>    <span class="token function">sema_down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hd<span class="token operator">-></span>my_channel<span class="token operator">-></span>disk_done<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 醒来后开始执行下面代码*/</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">busy_wait</span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">//  若失败</span>        <span class="token keyword">char</span> error<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> <span class="token string">"%s identify failed!!!!!!\n"</span><span class="token punctuation">,</span> hd<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PANIC</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">read_from_sector</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> id_info<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> sn_start <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> sn_len <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> md_start <span class="token operator">=</span> <span class="token number">27</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> md_len <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>    <span class="token function">swap_pairs_bytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>id_info<span class="token punctuation">[</span>sn_start<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> sn_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"   disk %s info:\n      SN: %s\n"</span><span class="token punctuation">,</span> hd<span class="token operator">-></span>name<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap_pairs_bytes</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>id_info<span class="token punctuation">[</span>md_start<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> md_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"      MODULE: %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> sectors <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>id_info<span class="token punctuation">[</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"      SECTORS: %d\n"</span><span class="token punctuation">,</span> sectors<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"      CAPACITY: %dMB\n"</span><span class="token punctuation">,</span> sectors <span class="token operator">*</span> <span class="token number">512</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 扫描硬盘hd中地址为ext_lba的扇区中的所有分区 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">partition_scan</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> ext_lba<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">boot_sector</span><span class="token operator">*</span> bs <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">boot_sector</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ide_read</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> ext_lba<span class="token punctuation">,</span> bs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> part_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//用于遍历主分区的变量</span>    <span class="token keyword">struct</span> <span class="token class-name">partition_table_entry</span><span class="token operator">*</span> p <span class="token operator">=</span> bs<span class="token operator">-></span>partition_table<span class="token punctuation">;</span>    <span class="token comment">/* 遍历分区表4个分区表项 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>part_idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>fs_type <span class="token operator">==</span> <span class="token number">0x5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若为扩展分区</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ext_lba_base <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                 <span class="token comment">/* 子扩展分区的start_lba是相对于主引导扇区中的总扩展分区地址 */</span>                <span class="token function">partition_scan</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> p<span class="token operator">-></span>start_lba <span class="token operator">+</span> ext_lba_base<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>             <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// ext_lba_base为0表示是第一次读取引导块,也就是主引导记录所在的扇区</span>            <span class="token comment">/* 记录下扩展分区的起始lba地址,后面所有的扩展分区地址都相对于此 */</span>                ext_lba_base <span class="token operator">=</span> p<span class="token operator">-></span>start_lba<span class="token punctuation">;</span>                <span class="token function">partition_scan</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> p<span class="token operator">-></span>start_lba<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>fs_type <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若是有效的分区类型</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ext_lba <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 此时全是主分区</span>                hd<span class="token operator">-></span>prim_parts<span class="token punctuation">[</span>p_no<span class="token punctuation">]</span><span class="token punctuation">.</span>start_lba <span class="token operator">=</span> ext_lba <span class="token operator">+</span> p<span class="token operator">-></span>start_lba<span class="token punctuation">;</span>                hd<span class="token operator">-></span>prim_parts<span class="token punctuation">[</span>p_no<span class="token punctuation">]</span><span class="token punctuation">.</span>sec_cnt <span class="token operator">=</span> p<span class="token operator">-></span>sec_cnt<span class="token punctuation">;</span>                hd<span class="token operator">-></span>prim_parts<span class="token punctuation">[</span>p_no<span class="token punctuation">]</span><span class="token punctuation">.</span>my_disk <span class="token operator">=</span> hd<span class="token punctuation">;</span>                <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>partition_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hd<span class="token operator">-></span>prim_parts<span class="token punctuation">[</span>p_no<span class="token punctuation">]</span><span class="token punctuation">.</span>part_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">sprintf</span><span class="token punctuation">(</span>hd<span class="token operator">-></span>prim_parts<span class="token punctuation">[</span>p_no<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"%s%d"</span><span class="token punctuation">,</span> hd<span class="token operator">-></span>name<span class="token punctuation">,</span> p_no <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                p_no<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token function">ASSERT</span><span class="token punctuation">(</span>p_no <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 0,1,2,3</span>            <span class="token punctuation">&#125;</span>             <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                hd<span class="token operator">-></span>logic_parts<span class="token punctuation">[</span>l_no<span class="token punctuation">]</span><span class="token punctuation">.</span>start_lba <span class="token operator">=</span> ext_lba <span class="token operator">+</span> p<span class="token operator">-></span>start_lba<span class="token punctuation">;</span>                hd<span class="token operator">-></span>logic_parts<span class="token punctuation">[</span>l_no<span class="token punctuation">]</span><span class="token punctuation">.</span>sec_cnt <span class="token operator">=</span> p<span class="token operator">-></span>sec_cnt<span class="token punctuation">;</span>                hd<span class="token operator">-></span>logic_parts<span class="token punctuation">[</span>l_no<span class="token punctuation">]</span><span class="token punctuation">.</span>my_disk <span class="token operator">=</span> hd<span class="token punctuation">;</span>                <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>partition_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hd<span class="token operator">-></span>logic_parts<span class="token punctuation">[</span>l_no<span class="token punctuation">]</span><span class="token punctuation">.</span>part_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">sprintf</span><span class="token punctuation">(</span>hd<span class="token operator">-></span>logic_parts<span class="token punctuation">[</span>l_no<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"%s%d"</span><span class="token punctuation">,</span> hd<span class="token operator">-></span>name<span class="token punctuation">,</span> l_no <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 逻辑分区数字是从5开始,主分区是1～4.</span>                l_no<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l_no <span class="token operator">>=</span> <span class="token number">8</span><span class="token punctuation">)</span>    <span class="token comment">// 只支持8个逻辑分区,避免数组越界</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>         p<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>bs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 打印分区信息 */</span><span class="token keyword">static</span> bool <span class="token function">partition_info</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> pelem<span class="token punctuation">,</span> <span class="token keyword">int</span> arg UNUSED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token operator">*</span> part <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token punctuation">,</span> part_tag<span class="token punctuation">,</span> pelem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"   %s start_lba:0x%x, sec_cnt:0x%x\n"</span><span class="token punctuation">,</span>part<span class="token operator">-></span>name<span class="token punctuation">,</span> part<span class="token operator">-></span>start_lba<span class="token punctuation">,</span> part<span class="token operator">-></span>sec_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 在此处return false与函数本身功能无关,    * 只是为了让主调函数list_traversal继续向下遍历元素 */</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 硬盘数据结构初始化 */</span><span class="token keyword">void</span> <span class="token function">ide_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"ide_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> hd_cnt <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x475</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 获取硬盘的数量</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>hd_cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>partition_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    channel_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>hd_cnt<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 一个ide通道上有两个硬盘,根据硬盘数量反推有几个ide通道</span>    <span class="token keyword">struct</span> <span class="token class-name">ide_channel</span><span class="token operator">*</span> channel<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> channel_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> dev_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">/* 处理每个通道上的硬盘 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>channel_no <span class="token operator">&lt;</span> channel_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        channel <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span>channel_no<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sprintf</span><span class="token punctuation">(</span>channel<span class="token operator">-></span>name<span class="token punctuation">,</span> <span class="token string">"ide%d"</span><span class="token punctuation">,</span> channel_no<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 为每个ide通道初始化端口基址及中断向量 */</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>channel_no<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>            channel<span class="token operator">-></span>port_base <span class="token operator">=</span> <span class="token number">0x1f0</span><span class="token punctuation">;</span>   <span class="token comment">// ide0通道的起始端口号是0x1f0</span>            channel<span class="token operator">-></span>irq_no <span class="token operator">=</span> <span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">14</span><span class="token punctuation">;</span>   <span class="token comment">// 从片8259a上倒数第二的中断引脚,温盘,也就是ide0通道的的中断向量号</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>            channel<span class="token operator">-></span>port_base <span class="token operator">=</span> <span class="token number">0x170</span><span class="token punctuation">;</span>   <span class="token comment">// ide1通道的起始端口号是0x170</span>            channel<span class="token operator">-></span>irq_no <span class="token operator">=</span> <span class="token number">0x20</span> <span class="token operator">+</span> <span class="token number">15</span><span class="token punctuation">;</span>   <span class="token comment">// 从8259A上的最后一个中断引脚,我们用来响应ide1通道上的硬盘中断</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        channel<span class="token operator">-></span>expecting_intr <span class="token operator">=</span> false<span class="token punctuation">;</span>   <span class="token comment">// 未向硬盘写入指令时不期待硬盘的中断</span>        <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>channel<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">/* 初始化为0,目的是向硬盘控制器请求数据后,硬盘驱动sema_down此信号量会阻塞线程,    直到硬盘完成后通过发中断,由中断处理程序将此信号量sema_up,唤醒线程. */</span>        <span class="token function">sema_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>channel<span class="token operator">-></span>disk_done<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">register_handler</span><span class="token punctuation">(</span>channel<span class="token operator">-></span>irq_no<span class="token punctuation">,</span> intr_hd_handler<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 分别获取两个硬盘的参数及分区信息 */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>dev_no <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd <span class="token operator">=</span> <span class="token operator">&amp;</span>channel<span class="token operator">-></span>devices<span class="token punctuation">[</span>dev_no<span class="token punctuation">]</span><span class="token punctuation">;</span>            hd<span class="token operator">-></span>my_channel <span class="token operator">=</span> channel<span class="token punctuation">;</span>            hd<span class="token operator">-></span>dev_no <span class="token operator">=</span> dev_no<span class="token punctuation">;</span>            <span class="token function">sprintf</span><span class="token punctuation">(</span>hd<span class="token operator">-></span>name<span class="token punctuation">,</span> <span class="token string">"sd%c"</span><span class="token punctuation">,</span> <span class="token char">'a'</span> <span class="token operator">+</span> channel_no <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> dev_no<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">identify_disk</span><span class="token punctuation">(</span>hd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取硬盘参数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dev_no <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 内核本身的裸硬盘(hd60M.img)不处理</span>                <span class="token function">partition_scan</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 扫描该硬盘上的分区  </span>            <span class="token punctuation">&#125;</span>            p_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            dev_no<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>        dev_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// 将硬盘驱动器号置0,为下一个channel的两个硬盘初始化。</span>        channel_no<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">// 下一个channel</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\n   all partition info\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 打印所有分区信息 */</span>    <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>partition_list<span class="token punctuation">,</span> partition_info<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"ide_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改（<strong>kernel/init.c</strong>）完成ide的初始化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"timer.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"keyboard.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"tss.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ide.h"</span></span><span class="token comment">/*负责初始化所有模块 */</span><span class="token keyword">void</span> <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"init_all\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">idt_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化中断</span>   <span class="token function">mem_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化内存管理系统</span>   <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化线程相关结构</span>   <span class="token function">timer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化PIT</span>   <span class="token function">console_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 控制台初始化最好放在开中断之前</span>   <span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 键盘初始化</span>   <span class="token function">tss_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// tss初始化</span>   <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 初始化系统调用</span>   <span class="token function">ide_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化硬盘</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_a<span class="token punctuation">,</span> <span class="token string">"u_prog_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_b<span class="token punctuation">,</span> <span class="token string">"u_prog_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_a"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_a<span class="token punctuation">,</span> <span class="token string">"I am thread_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_b"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_b<span class="token punctuation">,</span> <span class="token string">"I am thread_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_a malloc addr:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_b malloc addr:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" prog_a malloc addr:0x%x,0x%x,0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" prog_b malloc addr:0x%x,0x%x,0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        由于我们fdisk工具分区时，设定分区起始与大小是用扇区做单位而非作者操作时的柱面，所以我们显示的硬盘分区信息<code>start_lba</code>与<code>sec_cnt</code>与他不一样。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件系统中，最核心的就是三个概念：inode、目录（目录也是文件）和超级块。文件系统是以分区为单位，也就是每个分区都有自己的文件系统。</p><ol><li>inode<ul><li>inode记录了文件与磁盘位置的映射。</li><li>每个文件对应一个inode。当我们找到了这个文件对应的inode，就能知道这个文件在磁盘中的存储位置。</li><li>每个磁盘分区的所有inode都会形成一个数组。使用文件的inode数组下标，我们可以在该数组中查找对应的inode信息。</li></ul></li><li>目录<ul><li>一个目录其实也是一个特殊的文件。</li><li>目录由众多目录项构成，目录项记录了文件名到inode的映射。如果一个目录管理<code>/Desktop</code>文件夹，那么这个目录下的众多目录项就是管理<code>/Desktop</code>文件夹下的各个文件和子目录。</li></ul></li><li>超级块<ul><li>超级块包含了关于inode、目录及其他文件系统元数据的信息。</li><li>通常，它位于每个磁盘分区的第二个扇区，这是一个固定位置。</li><li>对于inode，它记录了inode数组在磁盘中的起始位置；对于根目录，超级块还会记录其inode标号。</li></ul></li></ol><p>查找文件的流程示例：</p><p>如果我们要查找一个<code>/home/test.c</code>，那么文件系统是如何工作的呢？</p><ul><li>首先，由于超级块位置固定，我们可以去磁盘中直接访问它。</li><li>从超级块中，我们能知道根目录的inode标号和inode数组的位置。</li><li>使用根目录的inode标号与inode数组位置，我们可以找到根目录文件对应的inode，然后在磁盘中找到根目录文件。</li><li>在根目录文件中，我们查找一个名叫<code>home</code>的目录项，从中取出<code>home</code>的inode数组标号。</li><li>使用<code>home</code>的inode标号，我们再次访问inode数组，找到<code>home</code>目录文件在磁盘上的实际位置。</li><li>最后，在<code>home</code>目录文件中，我们查找一个名叫<code>test.c</code>的目录项，从中取出<code>test.c</code>的inode数组标号，进而找到<code>test.c</code>在磁盘上的位置。</li></ul><p>一个典型的文件系统元数据结构在磁盘中的位置如图所示<br><img src="e733cd92bfb942948f91cc688e3090b2.png" alt="在这里插入图片描述"><br>小节a：</p><p>我们就是写一个函数<code>partition_format</code>用于创建文件系统，也就是创建文件系统元数据（超级块，空闲块位图，inode位图，inode数组，根目录）；</p><p>然后写一个函数<code>filesys_init</code>遍历所有分区，如果该分区没有文件系统就调用<code>partition_format</code>来创建文件系统</p><p>首先我们来准备数据结构</p><p>超级块 （<strong>fs/super_block.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__FS_SUPER_BLOCK_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FS_SUPER_BLOCK_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token comment">/* 超级块 */</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> magic<span class="token punctuation">;</span>    <span class="token comment">// 用来标识文件系统类型,支持多文件系统的操作系统通过此标志来识别文件系统类型</span>    <span class="token class-name">uint32_t</span> sec_cnt<span class="token punctuation">;</span>    <span class="token comment">// 本分区总共的扇区数</span>    <span class="token class-name">uint32_t</span> inode_cnt<span class="token punctuation">;</span>    <span class="token comment">// 本分区中inode数量</span>    <span class="token class-name">uint32_t</span> part_lba_base<span class="token punctuation">;</span>    <span class="token comment">// 本分区的起始lba地址</span>    <span class="token class-name">uint32_t</span> block_bitmap_lba<span class="token punctuation">;</span>    <span class="token comment">// 块位图本身起始扇区地址</span>    <span class="token class-name">uint32_t</span> block_bitmap_sects<span class="token punctuation">;</span>     <span class="token comment">// 扇区位图本身占用的扇区数量</span>    <span class="token class-name">uint32_t</span> inode_bitmap_lba<span class="token punctuation">;</span>    <span class="token comment">// i结点位图起始扇区lba地址</span>    <span class="token class-name">uint32_t</span> inode_bitmap_sects<span class="token punctuation">;</span>    <span class="token comment">// i结点位图占用的扇区数量</span>    <span class="token class-name">uint32_t</span> inode_table_lba<span class="token punctuation">;</span>    <span class="token comment">// i结点表起始扇区lba地址</span>    <span class="token class-name">uint32_t</span> inode_table_sects<span class="token punctuation">;</span>    <span class="token comment">// i结点表占用的扇区数量</span>    <span class="token class-name">uint32_t</span> data_start_lba<span class="token punctuation">;</span>    <span class="token comment">// 数据区开始的第一个扇区号</span>    <span class="token class-name">uint32_t</span> root_inode_no<span class="token punctuation">;</span>    <span class="token comment">// 根目录所在的I结点号</span>    <span class="token class-name">uint32_t</span> dir_entry_size<span class="token punctuation">;</span>    <span class="token comment">// 目录项大小</span>    <span class="token class-name">uint8_t</span>  pad<span class="token punctuation">[</span><span class="token number">460</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 加上460字节,凑够512字节1扇区大小</span><span class="token punctuation">&#125;</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>inode （<strong>fs/inode.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__FS_INODE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FS_INODE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"list.h"</span></span><span class="token comment">/* inode结构 */</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> i_no<span class="token punctuation">;</span>    <span class="token comment">// inode编号</span>    <span class="token comment">/* 当此inode是文件时,i_size是指文件大小,    若此inode是目录,i_size是指该目录下所有目录项大小之和*/</span>    <span class="token class-name">uint32_t</span> i_size<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> i_open_cnts<span class="token punctuation">;</span>   <span class="token comment">// 记录此文件被打开的次数</span>    bool write_deny<span class="token punctuation">;</span>   <span class="token comment">// 写文件不能并行,进程写文件前检查此标识</span>    <span class="token comment">/* i_sectors[0-11]是直接块, i_sectors[12]用来存储一级间接块指针 */</span>    <span class="token class-name">uint32_t</span> i_sectors<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> inode_tag<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>目录与目录项 （<strong>fs/dir.h</strong>） 需要注意的是：目录的数据结构<code>struct dir</code>只会存在于内存之中，因为它管理的是对一个目录文件的操作（比如打开一个目录文件，就会在内存中创建这样一个结构体）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__FS_DIR_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FS_DIR_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"inode.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_FILE_NAME_LEN</span>  <span class="token expression"><span class="token number">16</span> </span><span class="token comment">// 最大文件名长度</span></span><span class="token comment">/* 目录结构 */</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token operator">*</span> inode<span class="token punctuation">;</span>       <span class="token class-name">uint32_t</span> dir_pos<span class="token punctuation">;</span>  <span class="token comment">// 记录在目录内的偏移</span>    <span class="token class-name">uint8_t</span> dir_buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 目录的数据缓存</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* 目录项结构 */</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> filename<span class="token punctuation">[</span>MAX_FILE_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 普通文件或目录名称</span>    <span class="token class-name">uint32_t</span> i_no<span class="token punctuation">;</span>      <span class="token comment">// 普通文件或目录对应的inode编号</span>    <span class="token keyword">enum</span> <span class="token class-name">file_types</span> f_type<span class="token punctuation">;</span>      <span class="token comment">// 文件类型</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件类型定义： （<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__FS_FS_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__FS_FS_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_FILES_PER_PART</span> <span class="token expression"><span class="token number">4096</span>    </span><span class="token comment">// 每个分区所支持最大创建的文件数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BITS_PER_SECTOR</span> <span class="token expression"><span class="token number">4096</span>    </span><span class="token comment">// 每扇区的位数</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SECTOR_SIZE</span> <span class="token expression"><span class="token number">512</span>    </span><span class="token comment">// 扇区字节大小</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BLOCK_SIZE</span> <span class="token expression">SECTOR_SIZE    </span><span class="token comment">// 块字节大小</span></span><span class="token comment">/* 文件类型 */</span><span class="token keyword">enum</span> <span class="token class-name">file_types</span> <span class="token punctuation">&#123;</span>    FT_UNKNOWN<span class="token punctuation">,</span>  <span class="token comment">// 不支持的文件类型</span>    FT_REGULAR<span class="token punctuation">,</span>  <span class="token comment">// 普通文件</span>    FT_DIRECTORY  <span class="token comment">// 目录</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编写函数<code>partition_format</code>用于创建文件系统，也就是创建文件系统元数据（超级块，空闲块位图，inode位图，inode数组，根目录）</p><p>（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"inode.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ide.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"super_block.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"dir.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio-kernel.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token comment">/* 格式化分区,也就是初始化分区的元信息,创建文件系统 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">partition_format</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token operator">*</span> part<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* 为方便实现,一个块大小是一扇区 */</span>    <span class="token class-name">uint32_t</span> boot_sector_sects <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token class-name">uint32_t</span> super_block_sects <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> inode_bitmap_sects <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>MAX_FILES_PER_PART<span class="token punctuation">,</span> BITS_PER_SECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// I结点位图占用的扇区数.最多支持4096个文件</span>    <span class="token class-name">uint32_t</span> inode_table_sects <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span> <span class="token operator">*</span> MAX_FILES_PER_PART<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> used_sects <span class="token operator">=</span> boot_sector_sects <span class="token operator">+</span> super_block_sects <span class="token operator">+</span> inode_bitmap_sects <span class="token operator">+</span> inode_table_sects<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> free_sects <span class="token operator">=</span> part<span class="token operator">-></span>sec_cnt <span class="token operator">-</span> used_sects<span class="token punctuation">;</span>      <span class="token comment">/************** 简单处理块位图占据的扇区数 ***************/</span>    <span class="token class-name">uint32_t</span> block_bitmap_sects<span class="token punctuation">;</span>    block_bitmap_sects <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>free_sects<span class="token punctuation">,</span> BITS_PER_SECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* block_bitmap_bit_len是位图中位的长度,也是可用块的数量 */</span>    <span class="token class-name">uint32_t</span> block_bitmap_bit_len <span class="token operator">=</span> free_sects <span class="token operator">-</span> block_bitmap_sects<span class="token punctuation">;</span>     block_bitmap_sects <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>block_bitmap_bit_len<span class="token punctuation">,</span> BITS_PER_SECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">/*********************************************************/</span>        <span class="token comment">/* 超级块初始化 */</span>    <span class="token keyword">struct</span> <span class="token class-name">super_block</span> sb<span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>magic <span class="token operator">=</span> <span class="token number">0x19590318</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>sec_cnt <span class="token operator">=</span> part<span class="token operator">-></span>sec_cnt<span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>inode_cnt <span class="token operator">=</span> MAX_FILES_PER_PART<span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>part_lba_base <span class="token operator">=</span> part<span class="token operator">-></span>start_lba<span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>block_bitmap_lba <span class="token operator">=</span> sb<span class="token punctuation">.</span>part_lba_base <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 第0块是引导块,第1块是超级块</span>    sb<span class="token punctuation">.</span>block_bitmap_sects <span class="token operator">=</span> block_bitmap_sects<span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>inode_bitmap_lba <span class="token operator">=</span> sb<span class="token punctuation">.</span>block_bitmap_lba <span class="token operator">+</span> sb<span class="token punctuation">.</span>block_bitmap_sects<span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>inode_bitmap_sects <span class="token operator">=</span> inode_bitmap_sects<span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>inode_table_lba <span class="token operator">=</span> sb<span class="token punctuation">.</span>inode_bitmap_lba <span class="token operator">+</span> sb<span class="token punctuation">.</span>inode_bitmap_sects<span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>inode_table_sects <span class="token operator">=</span> inode_table_sects<span class="token punctuation">;</span>     sb<span class="token punctuation">.</span>data_start_lba <span class="token operator">=</span> sb<span class="token punctuation">.</span>inode_table_lba <span class="token operator">+</span> sb<span class="token punctuation">.</span>inode_table_sects<span class="token punctuation">;</span>  <span class="token comment">//数据区的起始就是inode数组的结束</span>    sb<span class="token punctuation">.</span>root_inode_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span>dir_entry_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s info:\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"   magic:0x%x\n   part_lba_base:0x%x\n   all_sectors:0x%x\n   inode_cnt:0x%x\n   block_bitmap_lba:0x%x\n   block_bitmap_sectors:0x%x\n   inode_bitmap_lba:0x%x\n   inode_bitmap_sectors:0x%x\n   inode_table_lba:0x%x\n   inode_table_sectors:0x%x\n   data_start_lba:0x%x\n"</span><span class="token punctuation">,</span> sb<span class="token punctuation">.</span>magic<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>part_lba_base<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>sec_cnt<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>inode_cnt<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>block_bitmap_lba<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>block_bitmap_sects<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>inode_bitmap_lba<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>inode_bitmap_sects<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>inode_table_lba<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>inode_table_sects<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>data_start_lba<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd <span class="token operator">=</span> part<span class="token operator">-></span>my_disk<span class="token punctuation">;</span>    <span class="token comment">/*******************************     * 1 将超级块写入本分区的1扇区 *     ******************************/</span>    <span class="token function">ide_write</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> part<span class="token operator">-></span>start_lba <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sb<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"   super_block_lba:0x%x\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>start_lba <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 找出数据量最大的元信息,用其尺寸做存储缓冲区*/</span>    <span class="token class-name">uint32_t</span> buf_size <span class="token operator">=</span> <span class="token punctuation">(</span>sb<span class="token punctuation">.</span>block_bitmap_sects <span class="token operator">>=</span> sb<span class="token punctuation">.</span>inode_bitmap_sects <span class="token operator">?</span> sb<span class="token punctuation">.</span>block_bitmap_sects <span class="token operator">:</span> sb<span class="token punctuation">.</span>inode_bitmap_sects<span class="token punctuation">)</span><span class="token punctuation">;</span>    buf_size <span class="token operator">=</span> <span class="token punctuation">(</span>buf_size <span class="token operator">>=</span> sb<span class="token punctuation">.</span>inode_table_sects <span class="token operator">?</span> buf_size <span class="token operator">:</span> sb<span class="token punctuation">.</span>inode_table_sects<span class="token punctuation">)</span> <span class="token operator">*</span> SECTOR_SIZE<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span><span class="token operator">*</span> buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span>buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 申请的内存由内存管理系统清0后返回</span>        <span class="token comment">/**************************************     * 2 将块位图初始化并写入sb.block_bitmap_lba *     *************************************/</span>    <span class="token comment">/* 初始化块位图block_bitmap */</span>    buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">0x01</span><span class="token punctuation">;</span>       <span class="token comment">// 第0个块预留给根目录,位图中先占位</span>    <span class="token class-name">uint32_t</span> block_bitmap_last_byte <span class="token operator">=</span> block_bitmap_bit_len <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">//计算出块位图最后一字节的偏移</span>    <span class="token class-name">uint8_t</span>  block_bitmap_last_bit  <span class="token operator">=</span> block_bitmap_bit_len <span class="token operator">%</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">//计算出块位图最后一位的偏移</span>    <span class="token class-name">uint32_t</span> last_size <span class="token operator">=</span> SECTOR_SIZE <span class="token operator">-</span> <span class="token punctuation">(</span>block_bitmap_last_byte <span class="token operator">%</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// last_size是位图所在最后一个扇区中，不足一扇区的其余部分</span>    <span class="token comment">/* 1 先将位图最后一字节到其所在的扇区的结束全置为1,即超出实际块数的部分直接置为已占用*/</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buf<span class="token punctuation">[</span>block_bitmap_last_byte<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0xff</span><span class="token punctuation">,</span> last_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 2 再将上一步中覆盖的最后一字节内的有效位重新置0 */</span>    <span class="token class-name">uint8_t</span> bit_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>bit_idx <span class="token operator">&lt;=</span> block_bitmap_last_bit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        buf<span class="token punctuation">[</span>block_bitmap_last_byte<span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit_idx<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">ide_write</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>block_bitmap_lba<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>block_bitmap_sects<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/***************************************     * 3 将inode位图初始化并写入sb.inode_bitmap_lba *     ***************************************/</span>    <span class="token comment">/* 先清空缓冲区*/</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">|=</span> <span class="token number">0x1</span><span class="token punctuation">;</span>      <span class="token comment">// 第0个inode分给了根目录</span>    <span class="token comment">/* 由于inode_table中共4096个inode,位图inode_bitmap正好占用1扇区,        * 即inode_bitmap_sects等于1, 所以位图中的位全都代表inode_table中的inode,        * 无须再像block_bitmap那样单独处理最后一扇区的剩余部分,        * inode_bitmap所在的扇区中没有多余的无效位 */</span>    <span class="token function">ide_write</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>inode_bitmap_lba<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>inode_bitmap_sects<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/***************************************     * 4 将inode数组初始化并写入sb.inode_table_lba *     ***************************************/</span>    <span class="token comment">/* 准备写inode_table中的第0项,即根目录所在的inode */</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 先清空缓冲区buf</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token operator">*</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">;</span>     i<span class="token operator">-></span>i_size <span class="token operator">=</span> sb<span class="token punctuation">.</span>dir_entry_size <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// .和..</span>    i<span class="token operator">-></span>i_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 根目录占inode数组中第0个inode</span>    i<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> sb<span class="token punctuation">.</span>data_start_lba<span class="token punctuation">;</span>     <span class="token comment">// 由于上面的memset,i_sectors数组的其它元素都初始化为0 </span>    <span class="token function">ide_write</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>inode_table_lba<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>inode_table_sects<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/***************************************     * 5 将根目录初始化并写入sb.data_start_lba     ***************************************/</span>    <span class="token comment">/* 写入根目录的两个目录项.和.. */</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span><span class="token operator">*</span> p_de <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span><span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">;</span>    <span class="token comment">/* 初始化当前目录"." */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>p_de<span class="token operator">-></span>filename<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p_de<span class="token operator">-></span>i_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    p_de<span class="token operator">-></span>f_type <span class="token operator">=</span> FT_DIRECTORY<span class="token punctuation">;</span>    p_de<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">/* 初始化当前目录父目录".." */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>p_de<span class="token operator">-></span>filename<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p_de<span class="token operator">-></span>i_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 根目录的父目录依然是根目录自己</span>    p_de<span class="token operator">-></span>f_type <span class="token operator">=</span> FT_DIRECTORY<span class="token punctuation">;</span>    <span class="token comment">/* sb.data_start_lba已经分配给了根目录,里面是根目录的目录项 */</span>    <span class="token function">ide_write</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> sb<span class="token punctuation">.</span>data_start_lba<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"   root_dir_lba:0x%x\n"</span><span class="token punctuation">,</span> sb<span class="token punctuation">.</span>data_start_lba<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s format done\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        采用无限迭代，直到值稳定下来的方法。这个代码实际解决的问题就是：在总量不变的情况下，有多少是可用资源，有多少是管理资源。</p><p>修改（<strong>fs/fs.c/partition_format</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/************** 简单处理块位图占据的扇区数 ***************/</span><span class="token class-name">uint32_t</span> block_bitmap_sects<span class="token punctuation">;</span>block_bitmap_sects <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>free_sects<span class="token punctuation">,</span> BITS_PER_SECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* block_bitmap_bit_len是位图中位的长度,也是可用块的数量 */</span><span class="token class-name">uint32_t</span> block_bitmap_bit_len <span class="token operator">=</span> free_sects <span class="token operator">-</span> block_bitmap_sects<span class="token punctuation">;</span> block_bitmap_sects <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>block_bitmap_bit_len<span class="token punctuation">,</span> BITS_PER_SECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/*********************************************************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/************** 简单处理块位图占据的扇区数 ***************/</span><span class="token class-name">uint32_t</span> now_total_free_sects <span class="token operator">=</span> free_sects<span class="token punctuation">;</span> <span class="token comment">// 定义一个现在总的可用扇区数</span><span class="token class-name">uint32_t</span> prev_block_bitmap_sects <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 之前的块位图扇区数</span><span class="token class-name">uint32_t</span> block_bitmap_sects <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>now_total_free_sects<span class="token punctuation">,</span> BITS_PER_SECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始估算</span><span class="token class-name">uint32_t</span> block_bitmap_bit_len<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>block_bitmap_sects <span class="token operator">!=</span> prev_block_bitmap_sects<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    prev_block_bitmap_sects <span class="token operator">=</span> block_bitmap_sects<span class="token punctuation">;</span>    <span class="token comment">/* block_bitmap_bit_len是位图中位的长度,也是可用块的数量 */</span>    block_bitmap_bit_len <span class="token operator">=</span> now_total_free_sects <span class="token operator">-</span> block_bitmap_sects<span class="token punctuation">;</span>    block_bitmap_sects <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>block_bitmap_bit_len<span class="token punctuation">,</span> BITS_PER_SECTOR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/*********************************************************/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于block_bitmap_last_bit实际含义是块位图最后一字节有效位的数量，且bit_idx从0开始取，所以以下while循环会多循环1次，应该修改：（<strong>fs/fs.c/partition_format</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>bit_idx <span class="token operator">&lt;=</span> block_bitmap_last_bit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    buf<span class="token punctuation">[</span>block_bitmap_last_byte<span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit_idx<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">while</span> <span class="token punctuation">(</span>bit_idx <span class="token operator">&lt;</span> block_bitmap_last_bit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    buf<span class="token punctuation">[</span>block_bitmap_last_byte<span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> bit_idx<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后写一个函数<code>filesys_init</code>遍历所有分区，如果该分区没有文件系统就调用<code>partition_format</code>来创建文件系统</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token comment">/* 在磁盘上搜索文件系统,若没有则格式化分区创建文件系统 */</span><span class="token keyword">void</span> <span class="token function">filesys_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> channel_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> dev_no<span class="token punctuation">,</span> part_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* sb_buf用来存储从硬盘上读入的超级块 */</span>    <span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token operator">*</span> sb_buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span>SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sb_buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"alloc memory failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"searching filesystem......\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>channel_no <span class="token operator">&lt;</span> channel_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//遍历两个通道</span>        dev_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>dev_no <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//遍历通道下1主1从两个硬盘</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dev_no <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 跨过裸盘hd60M.img</span>                dev_no<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span>channel_no<span class="token punctuation">]</span><span class="token punctuation">.</span>devices<span class="token punctuation">[</span>dev_no<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token operator">*</span> part <span class="token operator">=</span> hd<span class="token operator">-></span>prim_parts<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>part_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 遍历硬盘的分区，4个主分区+8个逻辑</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>part_idx <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 开始处理逻辑分区</span>                    part <span class="token operator">=</span> hd<span class="token operator">-></span>logic_parts<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                        <span class="token comment">/* channels数组是全局变量,默认值为0,disk属于其嵌套结构,            * partition又为disk的嵌套结构,因此partition中的成员默认也为0.            * 若partition未初始化,则partition中的成员仍为0.             * 下面处理存在的分区. */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>part<span class="token operator">-></span>sec_cnt <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果分区存在</span>                    <span class="token function">memset</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* 读出分区的超级块,根据魔数是否正确来判断是否存在文件系统 */</span>                    <span class="token function">ide_read</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> part<span class="token operator">-></span>start_lba <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> sb_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">/* 只支持自己的文件系统.若磁盘上已经有文件系统就不再格式化了 */</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>sb_buf<span class="token operator">-></span>magic <span class="token operator">==</span> <span class="token number">0x19590318</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s has filesystem\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                     <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 其它文件系统不支持,一律按无文件系统处理</span>                        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"formatting %s`s partition %s......\n"</span><span class="token punctuation">,</span> hd<span class="token operator">-></span>name<span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">partition_format</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                part_idx<span class="token operator">++</span><span class="token punctuation">;</span>                part<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 下一分区</span>            <span class="token punctuation">&#125;</span>            dev_no<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 下一磁盘</span>        <span class="token punctuation">&#125;</span>        channel_no<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 下一通道</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明 修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">filesys_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改 （<strong>kernel/init.c</strong>）以初始化文件系统</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token comment">/*负责初始化所有模块 */</span><span class="token keyword">void</span> <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"init_all\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">idt_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化中断</span><span class="token function">mem_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化内存管理系统</span><span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化线程相关结构</span><span class="token function">timer_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化PIT</span><span class="token function">console_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 控制台初始化最好放在开中断之前</span><span class="token function">keyboard_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 键盘初始化</span><span class="token function">tss_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// tss初始化</span><span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 初始化系统调用</span><span class="token function">intr_enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 后面的ide_init需要打开中断</span><span class="token function">ide_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 初始化硬盘</span><span class="token function">filesys_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 初始化文件系统</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall-init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_a<span class="token punctuation">,</span> <span class="token string">"u_prog_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">process_execute</span><span class="token punctuation">(</span>u_prog_b<span class="token punctuation">,</span> <span class="token string">"u_prog_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_a"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_a<span class="token punctuation">,</span> <span class="token string">"I am thread_a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"k_thread_b"</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> k_thread_b<span class="token punctuation">,</span> <span class="token string">"I am thread_b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_a malloc addr:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在线程中运行的函数 */</span><span class="token keyword">void</span> <span class="token function">k_thread_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">" thread_b malloc addr:0x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_int</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_char</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_a</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" prog_a malloc addr:0x%x,0x%x,0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 测试用户进程 */</span><span class="token keyword">void</span> <span class="token function">u_prog_b</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">void</span><span class="token operator">*</span> addr3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">254</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">" prog_b malloc addr:0x%x,0x%x,0x%x\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> cpu_delay <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span>cpu_delay<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">free</span><span class="token punctuation">(</span>addr3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Makefile 除了增加编译fs.c的规则外，还要新增<code>-I fs/</code></p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">LIB<span class="token operator">=</span> -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ -I thread/ -I userprog/-I fs/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>建议在运行前，先备份<code>hd80M.img</code>，不然出错了，很可能这里面会写入无意义数据。命令：<code>cp hd80M.img hd80M.img-beifen</code></p><p>小节b：</p><p>之前我们写好了函数用于创建文件系统元数据，并且将其写入了磁盘。当我们实际要用到某个分区的数据，就需要挂载该分区，也就是读取磁盘中文件系统元数据（超级块，块位图，inode位图，inode数组由于过大，不读入到内存中，）到内存中，然后对这些元数据的改动，要及时同步到磁盘中。现在我们就来写这个挂载分区的函数<code>mount_partition</code>。这个函数会被<code>list_traversal</code>调用。</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token operator">*</span> cur_part<span class="token punctuation">;</span> <span class="token comment">// 默认情况下操作的是哪个分区</span><span class="token comment">/* 在分区链表中找到名为part_name的分区,并将其指针赋值给cur_part */</span><span class="token keyword">static</span> bool <span class="token function">mount_partition</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> pelem<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span><span class="token operator">*</span> part_name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token operator">*</span> part <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token punctuation">,</span> part_tag<span class="token punctuation">,</span> pelem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>part<span class="token operator">-></span>name<span class="token punctuation">,</span> part_name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cur_part <span class="token operator">=</span> part<span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd <span class="token operator">=</span> cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">;</span>        <span class="token comment">/* sb_buf用来存储从硬盘上读入的超级块 */</span>        <span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token operator">*</span> sb_buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span>SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 在内存中创建分区cur_part的超级块 */</span>        cur_part<span class="token operator">-></span>sb <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_part<span class="token operator">-></span>sb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"alloc memory failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 读入超级块 */</span>        <span class="token function">memset</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> cur_part<span class="token operator">-></span>start_lba <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> sb_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">/* 把sb_buf中超级块的信息复制到分区的超级块sb中。*/</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>sb<span class="token punctuation">,</span> sb_buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">/**********     将硬盘上的块位图读入到内存    ****************/</span>        cur_part<span class="token operator">-></span>block_bitmap<span class="token punctuation">.</span>bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span>sb_buf<span class="token operator">-></span>block_bitmap_sects <span class="token operator">*</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_part<span class="token operator">-></span>block_bitmap<span class="token punctuation">.</span>bits <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"alloc memory failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur_part<span class="token operator">-></span>block_bitmap<span class="token punctuation">.</span>btmp_bytes_len <span class="token operator">=</span> sb_buf<span class="token operator">-></span>block_bitmap_sects <span class="token operator">*</span> SECTOR_SIZE<span class="token punctuation">;</span>        <span class="token comment">/* 从硬盘上读入块位图到分区的block_bitmap.bits */</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> sb_buf<span class="token operator">-></span>block_bitmap_lba<span class="token punctuation">,</span> cur_part<span class="token operator">-></span>block_bitmap<span class="token punctuation">.</span>bits<span class="token punctuation">,</span> sb_buf<span class="token operator">-></span>block_bitmap_sects<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">/*************************************************************/</span>        <span class="token comment">/**********     将硬盘上的inode位图读入到内存    ************/</span>        cur_part<span class="token operator">-></span>inode_bitmap<span class="token punctuation">.</span>bits <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span>sb_buf<span class="token operator">-></span>inode_bitmap_sects <span class="token operator">*</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_part<span class="token operator">-></span>inode_bitmap<span class="token punctuation">.</span>bits <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"alloc memory failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        cur_part<span class="token operator">-></span>inode_bitmap<span class="token punctuation">.</span>btmp_bytes_len <span class="token operator">=</span> sb_buf<span class="token operator">-></span>inode_bitmap_sects <span class="token operator">*</span> SECTOR_SIZE<span class="token punctuation">;</span>        <span class="token comment">/* 从硬盘上读入inode位图到分区的inode_bitmap.bits */</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> sb_buf<span class="token operator">-></span>inode_bitmap_lba<span class="token punctuation">,</span> cur_part<span class="token operator">-></span>inode_bitmap<span class="token punctuation">.</span>bits<span class="token punctuation">,</span> sb_buf<span class="token operator">-></span>inode_bitmap_sects<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">/*************************************************************/</span>        <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur_part<span class="token operator">-></span>open_inodes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mount %s done!\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 此处返回true是为了迎合主调函数list_traversal的实现,与函数本身功能无关。        只有返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历.*/</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span>     <span class="token comment">// 使list_traversal继续遍历</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改（<strong>fs/fs.c</strong>）<code>filesys_init</code>增加使用<code>list_traversal</code>调用<code>mount_partition</code>挂载指定分区文件系统的代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 在磁盘上搜索文件系统,若没有则格式化分区创建文件系统 */</span><span class="token keyword">void</span> <span class="token function">filesys_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> channel_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> dev_no<span class="token punctuation">,</span> part_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* sb_buf用来存储从硬盘上读入的超级块 */</span>    <span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token operator">*</span> sb_buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span>SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sb_buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"alloc memory failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"searching filesystem......\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>channel_no <span class="token operator">&lt;</span> channel_cnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//遍历两个通道</span>        dev_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>dev_no <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//遍历通道下1主1从两个硬盘</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dev_no <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 跨过裸盘hd60M.img</span>                dev_no<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">struct</span> <span class="token class-name">disk</span><span class="token operator">*</span> hd <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span>channel_no<span class="token punctuation">]</span><span class="token punctuation">.</span>devices<span class="token punctuation">[</span>dev_no<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token operator">*</span> part <span class="token operator">=</span> hd<span class="token operator">-></span>prim_parts<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>part_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// 遍历硬盘的分区，4个主分区+8个逻辑</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>part_idx <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 开始处理逻辑分区</span>                    part <span class="token operator">=</span> hd<span class="token operator">-></span>logic_parts<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                        <span class="token comment">/* channels数组是全局变量,默认值为0,disk属于其嵌套结构,            * partition又为disk的嵌套结构,因此partition中的成员默认也为0.            * 若partition未初始化,则partition中的成员仍为0.             * 下面处理存在的分区. */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>part<span class="token operator">-></span>sec_cnt <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果分区存在</span>                    <span class="token function">memset</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* 读出分区的超级块,根据魔数是否正确来判断是否存在文件系统 */</span>                    <span class="token function">ide_read</span><span class="token punctuation">(</span>hd<span class="token punctuation">,</span> part<span class="token operator">-></span>start_lba <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> sb_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">/* 只支持自己的文件系统.若磁盘上已经有文件系统就不再格式化了 */</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>sb_buf<span class="token operator">-></span>magic <span class="token operator">==</span> <span class="token number">0x19590318</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s has filesystem\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                     <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 其它文件系统不支持,一律按无文件系统处理</span>                        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"formatting %s`s partition %s......\n"</span><span class="token punctuation">,</span> hd<span class="token operator">-></span>name<span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">partition_format</span><span class="token punctuation">(</span>part<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                part_idx<span class="token operator">++</span><span class="token punctuation">;</span>                part<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 下一分区</span>            <span class="token punctuation">&#125;</span>            dev_no<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 下一磁盘</span>        <span class="token punctuation">&#125;</span>        channel_no<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 下一通道</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 确定默认操作的分区 */</span>   <span class="token keyword">char</span> default_part<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"sdb1"</span><span class="token punctuation">;</span>   <span class="token comment">/* 挂载分区 */</span>   <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>partition_list<span class="token punctuation">,</span> mount_partition<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>default_part<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改（<strong>device/ide.h</strong>）</p><p>(这个分区链表是我们挂载磁盘<code>ide_init</code>函数中调用<code>partition_scan</code>就创建了的，所以上一小节创建分区文件系统，其实我们可以去遍历这个链表)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">list</span> partition_list<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>mount_partition</code>内的<code>sb_buf</code>没有释放！会造成内存泄漏！</p><p>修改（<strong>fs/fs.c/mountpartition</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur_part<span class="token operator">-></span>open_inodes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mount %s done!\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 此处返回true是为了迎合主调函数list_traversal的实现,与函数本身功能无关。    只有返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历.*/</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>     <span class="token comment">// 使list_traversal继续遍历</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur_part<span class="token operator">-></span>open_inodes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mount %s done!\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 此处返回true是为了迎合主调函数list_traversal的实现,与函数本身功能无关。    只有返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历.*/</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> false<span class="token punctuation">;</span>     <span class="token comment">// 使list_traversal继续遍历</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节c：</p><p>文件系统的核心功能是管理文件（inode）与其在磁盘上存储位置之间的映射关系。但当我们谈到实际的文件操作（如打开、读取、写入），这些操作总是基于特定的进程或线程来进行。所以我们需要一个机制来建立进程或线程到文件（inode）的映射，这正是文件描述符的作用。而文件描述符则是基于“文件结构”来实现的。</p><p>文件结构详细描述了应用进程对于一个文件的当前操作状态：</p><ul><li>当应用进程操作（比如打开）一个文件时，操作系统会创建一个对应的全局文件结构，放置于全局文件结构数组（也叫文件表）中，用于跟踪该进程在该文件上的操作状态。</li><li>文件结构中包含一个<code>fd_pos</code>字段，它表示当前进程操作的位置。例如，当我们打开一个文件<code>test.txt</code>，<code>fd_pos</code>的初始值通常是文件的开头。</li><li>当我们对文件执行实际的读写操作，<code>fd_pos</code>会被更新到操作的位置。例如，如果在文件中间开始写入数据，<code>fd_pos</code>会更新为那个位置并随着写入操作继续前移。当进行编辑操作时，输入的内容首先被存放在一个内存输入缓冲区中。按下<code>ctrl + s</code>后，操作系统会使用文件结构中的<code>fd_pos</code>作为起始点，将缓冲区的内容写入磁盘文件中，同时更新<code>fd_pos</code>到写入结束后的位置。</li><li>文件结构还包含一个字段<code>fd_inode</code>，它是对应文件的inode的指针。通过这个<code>fd_inode</code>字段，操作系统可以轻松地找到文件在磁盘上的位置，并将内存输入缓冲区的内容写入磁盘。</li></ul><p><img src="4c08accb54ae4938adb5e6bf1e034f5c.png" alt="在这里插入图片描述"><br>由于文件结构与具体的应用程序高度相关，我们需要引入一个新的概念：<strong>文件描述符数组</strong>。</p><ul><li><p>文件描述符数组是存储在进程的进程控制块（PCB）中的一个数组。每个元素都是一个文件描述符（就是一个数字），它指向全局文件结构数组中的一个特定条目。</p></li><li><p>当进程打开一个文件，操作系统会为这个文件创建一个文件结构并将其放入全局文件结构数组中。接着，操作系统会将这个文件结构在全局数组中的位置（或索引）赋给进程的文件描述符数组中的一个空闲元素。</p><p>例如一个进程打开了两个文件，它们在全局文件结构数组中的位置分别是32和58。那么，进程的PCB中的文件描述符数组的第0个元素就会被赋值为32，而第1个元素则会被赋值为58。</p></li><li><p>PCB中的文件描述符数组的大小限制了一个进程能够同时打开文件的最大数量。如果进程打开一个新的文件，但文件描述符数组已满，则操作将失败。</p></li><li><p>需要注意的是，打开不同的文件当然会消耗一个文件描述符。但由于我们在文件结构中引入了文件操作位置的概念（即<code>fd_pos</code>），如果一个进程多次打开同一个文件（即每次打开都有自己的读写位置），那么每次打开都会消耗一个新的文件描述符。<br><img src="ceebfc3073334166b8f4cd947f2077ee.png" alt="在这里插入图片描述"><br>文件系统这一章函数，代码非常多，<strong>其实核心就是处理超级块，inode，目录，文件结构这四个概念之间的交互</strong>。</p></li></ul><p>为了支持文件描述符，我们要取修改<code>task_struct</code>结构体的定义。（还新增了<code>parent_id</code>与<code>cwd_inode_nr</code>）</p><p>修改（<strong>thread/thread.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_FILES_OPEN_PER_PROC</span> <span class="token expression"><span class="token number">8</span></span></span><span class="token comment">/* 进程或线程的pcb,程序控制块, 此结构体用于存储线程的管理信息*/</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>self_kstack<span class="token punctuation">;</span> <span class="token comment">// 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">enum</span> <span class="token class-name">task_status</span> status<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> priority<span class="token punctuation">;</span> <span class="token comment">// 线程优先级</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 用于存储自己的线程的名字</span>    <span class="token class-name">uint8_t</span> ticks<span class="token punctuation">;</span>                                <span class="token comment">// 线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时</span>    <span class="token class-name">uint32_t</span> elapsed_ticks<span class="token punctuation">;</span>                       <span class="token comment">// 此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> general_tag<span class="token punctuation">;</span>                 <span class="token comment">// general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> all_list_tag<span class="token punctuation">;</span>                <span class="token comment">// all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>pgdir<span class="token punctuation">;</span>                              <span class="token comment">// 进程自己页表的虚拟地址</span>    <span class="token keyword">struct</span> <span class="token class-name">virtual_addr</span> userprog_vaddr<span class="token punctuation">;</span>           <span class="token comment">// 用户进程的虚拟地址</span>    <span class="token class-name">int32_t</span> fd_table<span class="token punctuation">[</span>MAX_FILES_OPEN_PER_PROC<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 已打开文件数组</span>    <span class="token class-name">uint32_t</span> cwd_inode_nr<span class="token punctuation">;</span>                        <span class="token comment">// 进程所在的工作目录的inode编号</span>    <span class="token class-name">int16_t</span> parent_pid<span class="token punctuation">;</span>                           <span class="token comment">// 父进程pid</span>    <span class="token keyword">struct</span> <span class="token class-name">mem_block_desc</span> u_block_desc<span class="token punctuation">[</span>DESC_CNT<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用户进程内存块描述符</span>    <span class="token class-name">uint32_t</span> stack_magic<span class="token punctuation">;</span>                         <span class="token comment">// 如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在创建进程/线程的初始化pcb环节，增加对这个文件描述符数组以及<code>parent_id</code>和<code>cwd_inode_nr</code>初始化代码</p><p>修改（<strong>thread/thread.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 初始化线程基本信息 , pcb中存储的是线程的管理信息，此函数用于根据传入的pcb的地址，线程的名字等来初始化线程的管理信息*/</span><span class="token keyword">void</span> <span class="token function">init_thread</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>pthread<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> prio<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>pthread<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>pthread<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把pcb初始化为0</span>    pthread<span class="token operator">-></span>pid <span class="token operator">=</span> <span class="token function">allocate_pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>name<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将传入的线程的名字填入线程的pcb中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pthread <span class="token operator">==</span> main_thread<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        pthread<span class="token operator">-></span>status <span class="token operator">=</span> TASK_RUNNING<span class="token punctuation">;</span> <span class="token comment">// 由于把main函数也封装成一个线程,并且它一直是运行的,故将其直接设为TASK_RUNNING */</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        pthread<span class="token operator">-></span>status <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pthread<span class="token operator">-></span>priority <span class="token operator">=</span> prio<span class="token punctuation">;</span>    <span class="token comment">/* self_kstack是线程自己在内核态下使用的栈顶地址 */</span>    pthread<span class="token operator">-></span>ticks <span class="token operator">=</span> prio<span class="token punctuation">;</span>    pthread<span class="token operator">-></span>elapsed_ticks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pthread<span class="token operator">-></span>pgdir <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                                            <span class="token comment">// 线程没有自己的地址空间，进程的pcb这一项才有用，指向自己的页表虚拟地址</span>    pthread<span class="token operator">-></span>self_kstack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>pthread <span class="token operator">+</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 本操作系统比较简单，线程不会太大，就将线程栈顶定义为pcb地址</span>                                                                      <span class="token comment">//+4096的地方，这样就留了一页给线程的信息（包含管理信息与运行信息）空间</span>    <span class="token comment">/* 标准输入输出先空出来 */</span>    pthread<span class="token operator">-></span>fd_table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pthread<span class="token operator">-></span>fd_table<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    pthread<span class="token operator">-></span>fd_table<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">/* 其余的全置为-1 */</span>    <span class="token class-name">uint8_t</span> fd_idx <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fd_idx <span class="token operator">&lt;</span> MAX_FILES_OPEN_PER_PROC<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        pthread<span class="token operator">-></span>fd_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        fd_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pthread<span class="token operator">-></span>cwd_inode_nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// 以根目录做为默认工作路径</span>    pthread<span class="token operator">-></span>parent_pid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// -1表示没有父进程</span>    pthread<span class="token operator">-></span>stack_magic <span class="token operator">=</span> <span class="token number">0x19870916</span><span class="token punctuation">;</span> <span class="token comment">// 定义的边界数字，随便选的数字来判断线程的栈是否已经生长到覆盖pcb信息了</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任何有关文件及目录的操作都了不开对inode的操作，因为我们需要通过inode知道文件的存储位置，所以操作文件，总是意味着要找到该文件的inode。接下来我们实现一堆对于inode的处理函数。涉及：找到一个inode在磁盘中的位置，初始化一个inode，加载该inode到内存中，修改内存中的inode之后同步到磁盘中，从内存中删除一个inode。</p><p><code>inode_locate</code>用于通过传入指定inode在inode数组中的索引，来获取inode所在扇区和扇区内的偏移。原理：由于传入了inode在inode数组中的索引，且超级块（挂载文件系统后，超级块在内存中）中已经记录了inode数组起始扇区。所以我们能通过索引 * 每个inode大小，计算出这个inode所在扇区和扇区内的偏移。</p><p>（<strong>fs/inode.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ide.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"inode.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"super_block.h"</span></span><span class="token comment">/* 用来存储inode位置 */</span><span class="token keyword">struct</span> <span class="token class-name">inode_position</span> <span class="token punctuation">&#123;</span>   bool two_sec<span class="token punctuation">;</span><span class="token comment">// inode是否跨扇区</span>   <span class="token class-name">uint32_t</span> sec_lba<span class="token punctuation">;</span><span class="token comment">// inode所在的扇区号</span>   <span class="token class-name">uint32_t</span> off_size<span class="token punctuation">;</span><span class="token comment">// inode在扇区内的字节偏移量</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* 获取inode所在的扇区和扇区内的偏移量 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inode_locate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode_position</span> <span class="token operator">*</span>inode_pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* inode_table在硬盘上是连续的 */</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>inode_no <span class="token operator">&lt;</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> inode_table_lba <span class="token operator">=</span> part<span class="token operator">-></span>sb<span class="token operator">-></span>inode_table_lba<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> inode_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> off_size <span class="token operator">=</span> inode_no <span class="token operator">*</span> inode_size<span class="token punctuation">;</span> <span class="token comment">// 第inode_no号I结点相对于inode_table_lba的字节偏移量</span>    <span class="token class-name">uint32_t</span> off_sec <span class="token operator">=</span> off_size <span class="token operator">/</span> <span class="token number">512</span><span class="token punctuation">;</span>         <span class="token comment">// 第inode_no号I结点相对于inode_table_lba的扇区偏移量</span>    <span class="token class-name">uint32_t</span> off_size_in_sec <span class="token operator">=</span> off_size <span class="token operator">%</span> <span class="token number">512</span><span class="token punctuation">;</span> <span class="token comment">// 待查找的inode所在扇区中的起始地址</span>    <span class="token comment">/* 判断此i结点是否跨越2个扇区 */</span>    <span class="token class-name">uint32_t</span> left_in_sec <span class="token operator">=</span> <span class="token number">512</span> <span class="token operator">-</span> off_size_in_sec<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left_in_sec <span class="token operator">&lt;</span> inode_size<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若扇区内剩下的空间不足以容纳一个inode,必然是I结点跨越了2个扇区</span>        inode_pos<span class="token operator">-></span>two_sec <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 否则,所查找的inode未跨扇区</span>        inode_pos<span class="token operator">-></span>two_sec <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    inode_pos<span class="token operator">-></span>sec_lba <span class="token operator">=</span> inode_table_lba <span class="token operator">+</span> off_sec<span class="token punctuation">;</span>    inode_pos<span class="token operator">-></span>off_size <span class="token operator">=</span> off_size_in_sec<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>inode_sync</code>用于将一个inode写入磁盘中inode数组对应的位置处。原理：调用<code>inode_locate</code>解析出这个inode在磁盘中的位置，然后将这个inode所在的块整个读出到内存缓冲中，再将这个inode写入缓冲中对应的位置处，再将整个块写回磁盘。</p><p>修改（<strong>fs/inode.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token comment">/* 将inode写入到分区part */</span><span class="token keyword">void</span> <span class="token function">inode_sync</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">// io_buf是用于硬盘io的缓冲区</span>    <span class="token class-name">uint8_t</span> inode_no <span class="token operator">=</span> inode<span class="token operator">-></span>i_no<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode_position</span> inode_pos<span class="token punctuation">;</span>    <span class="token function">inode_locate</span><span class="token punctuation">(</span>part<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inode_pos<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inode位置信息会存入inode_pos</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>inode_pos<span class="token punctuation">.</span>sec_lba <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>part<span class="token operator">-></span>start_lba <span class="token operator">+</span> part<span class="token operator">-></span>sec_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 硬盘中的inode中的成员inode_tag和i_open_cnts是不需要的,     * 它们只在内存中记录链表位置和被多少进程共享 */</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> pure_inode<span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pure_inode<span class="token punctuation">,</span> inode<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 以下inode的三个成员只存在于内存中,现在将inode同步到硬盘,清掉这三项即可 */</span>    pure_inode<span class="token punctuation">.</span>i_open_cnts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pure_inode<span class="token punctuation">.</span>write_deny <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// 置为false,以保证在硬盘中读出时为可写</span>    pure_inode<span class="token punctuation">.</span>inode_tag<span class="token punctuation">.</span>prev <span class="token operator">=</span> pure_inode<span class="token punctuation">.</span>inode_tag<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>inode_buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>io_buf<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_pos<span class="token punctuation">.</span>two_sec<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>                                                             <span class="token comment">// 若是跨了两个扇区,就要读出两个扇区再写入两个扇区</span>                                                                  <span class="token comment">/* 读写硬盘是以扇区为单位,若写入的数据小于一扇区,要将原硬盘上的内容先读出来再和新数据拼成一扇区后再写入  */</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inode在format中写入硬盘时是连续写入的,所以读入2块扇区</span>        <span class="token comment">/* 开始将待写入的inode拼入到这2个扇区中的相应位置 */</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span>inode_buf <span class="token operator">+</span> inode_pos<span class="token punctuation">.</span>off_size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pure_inode<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 将拼接好的数据再写入磁盘 */</span>        <span class="token function">ide_write</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若只是一个扇区</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span>inode_buf <span class="token operator">+</span> inode_pos<span class="token punctuation">.</span>off_size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pure_inode<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ide_write</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>inode_open</code>用于打开一个inode，也就是根据传入的inode数组索引找到该inode并加载到内存中。由于我们在管理分区的结构体struct partition中维护了一个本分区打开文件的inode链表，所以我们优先去这个链表中查找（这个链表在内存中），找不到再去磁盘中找，也就是调用<code>inode_locate</code>解析他在磁盘中的位置，然后读到内存中。由于打开的Inode链表需要对所有进程共享，所有我们存放inode的内存需要去内核堆区申请（因为所有的进程均可访问内核）</p><p>修改（<strong>fs/inode.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 根据i结点号返回相应的i结点 */</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token function">inode_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 先在已打开inode链表中找inode,此链表是为提速创建的缓冲区 */</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> <span class="token operator">*</span>elem <span class="token operator">=</span> part<span class="token operator">-></span>open_inodes<span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode_found<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>elem <span class="token operator">!=</span> <span class="token operator">&amp;</span>part<span class="token operator">-></span>open_inodes<span class="token punctuation">.</span>tail<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        inode_found <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">,</span> inode_tag<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_found<span class="token operator">-></span>i_no <span class="token operator">==</span> inode_no<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            inode_found<span class="token operator">-></span>i_open_cnts<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> inode_found<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        elem <span class="token operator">=</span> elem<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*由于open_inodes链表中找不到,下面从硬盘上读入此inode并加入到此链表 */</span>    <span class="token keyword">struct</span> <span class="token class-name">inode_position</span> inode_pos<span class="token punctuation">;</span>    <span class="token comment">/* inode位置信息会存入inode_pos, 包括inode所在扇区地址和扇区内的字节偏移量 */</span>    <span class="token function">inode_locate</span><span class="token punctuation">(</span>part<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inode_pos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 为使通过sys_malloc创建的新inode被所有任务共享,     * 需要将inode置于内核空间,故需要临时     * 将cur_pbc->pgdir置为NULL */</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>cur_pagedir_bak <span class="token operator">=</span> cur<span class="token operator">-></span>pgdir<span class="token punctuation">;</span>    cur<span class="token operator">-></span>pgdir <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment">/* 以上三行代码完成后下面分配的内存将位于内核区 */</span>    inode_found <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 恢复pgdir */</span>    cur<span class="token operator">-></span>pgdir <span class="token operator">=</span> cur_pagedir_bak<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>inode_buf<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_pos<span class="token punctuation">.</span>two_sec<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 考虑跨扇区的情况</span>        inode_buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* i结点表是被partition_format函数连续写入扇区的,         * 所以下面可以连续读出来 */</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 否则,所查找的inode未跨扇区,一个扇区大小的缓冲区足够</span>        inode_buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>inode_found<span class="token punctuation">,</span> inode_buf <span class="token operator">+</span> inode_pos<span class="token punctuation">.</span>off_size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 因为一会很可能要用到此inode,故将其插入到队首便于提前检索到 */</span>    <span class="token function">list_push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>part<span class="token operator">-></span>open_inodes<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inode_found<span class="token operator">-></span>inode_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    inode_found<span class="token operator">-></span>i_open_cnts <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>inode_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> inode_found<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>inode_close</code>用于关闭一个inode，也就是从内存中移除一个inode。由于一个inode可以被多次打开，我们需要判断此时是否还有进程/线程打开这个inode，再决定是否真正移除。移除的inode所占用的内存空间是内核的堆空间。</p><p>修改（<strong>fs/inode.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token comment">/* 关闭inode或减少inode的打开数 */</span><span class="token keyword">void</span> <span class="token function">inode_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 若没有进程再打开此文件,将此inode去掉并释放空间 */</span>    <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>inode<span class="token operator">-></span>i_open_cnts <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">list_remove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>inode<span class="token operator">-></span>inode_tag<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将I结点从part->open_inodes中去掉</span>                                        <span class="token comment">/* inode_open时为实现inode被所有进程共享,                                         * 已经在sys_malloc为inode分配了内核空间,                                         * 释放inode时也要确保释放的是内核内存池 */</span>        <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">uint32_t</span> <span class="token operator">*</span>cur_pagedir_bak <span class="token operator">=</span> cur<span class="token operator">-></span>pgdir<span class="token punctuation">;</span>        cur<span class="token operator">-></span>pgdir <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token function">sys_free</span><span class="token punctuation">(</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>        cur<span class="token operator">-></span>pgdir <span class="token operator">=</span> cur_pagedir_bak<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>inode_init</code>通过传入inode编号初始化一个inode</p><p>修改（<strong>fs/inode.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 初始化new_inode */</span><span class="token keyword">void</span> <span class="token function">inode_init</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>new_inode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    new_inode<span class="token operator">-></span>i_no <span class="token operator">=</span> inode_no<span class="token punctuation">;</span>    new_inode<span class="token operator">-></span>i_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    new_inode<span class="token operator">-></span>i_open_cnts <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    new_inode<span class="token operator">-></span>write_deny <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token comment">/* 初始化块索引数组i_sector */</span>    <span class="token class-name">uint8_t</span> sec_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>sec_idx <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* i_sectors[12]为一级间接块地址 */</span>        new_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>sec_idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        sec_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明：修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">inode_sync</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token operator">*</span> part<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token operator">*</span> inode<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token function">inode_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">inode_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">inode_init</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>new_inode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">1234</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来实现一堆与目录相关的函数，涉及目录打开、关闭，在一个目录文件中寻找指定目录项，初始化一个目录项，将目录项写入父目录中</p><p><code>open_root_dir</code>用于根据传入的分区，调用<code>inode_open</code>将根目录文件的inode调入内存，并将全局变量<code>struct root_dir</code>中的inode指针，指向根目录文件的inode</p><p>(<strong>fs/dir.c</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"dir.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"inode.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"super_block.h"</span></span><span class="token keyword">struct</span> <span class="token class-name">dir</span> root_dir<span class="token punctuation">;</span> <span class="token comment">// 根目录</span><span class="token comment">/* 打开根目录 */</span><span class="token keyword">void</span> <span class="token function">open_root_dir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    root_dir<span class="token punctuation">.</span>inode <span class="token operator">=</span> <span class="token function">inode_open</span><span class="token punctuation">(</span>part<span class="token punctuation">,</span> part<span class="token operator">-></span>sb<span class="token operator">-></span>root_inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>    root_dir<span class="token punctuation">.</span>dir_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dir_open</code>用于根据传入的分区与inode偏移，申请一块内存区域存放目录，调用<code>inode_open</code>找到这个目录对应的inode并载入内存，然后让目录中的inode指针指向这个inode。功能和<code>open_root_dir</code>类似，只不过一个是直接修改全局变量，一个要自行申请内存。</p><p>修改(<strong>fs/dir.c</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 在分区part上打开i结点为inode_no的目录并返回目录指针 */</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span><span class="token function">dir_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>pdir <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pdir<span class="token operator">-></span>inode <span class="token operator">=</span> <span class="token function">inode_open</span><span class="token punctuation">(</span>part<span class="token punctuation">,</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>    pdir<span class="token operator">-></span>dir_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pdir<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以我们可以发现，打开目录，就是建立目录（struct dir结构体）与inode之间的关系。为什么？因为目录是一个内存中的概念，但它本身是磁盘中的一个文件！为了建立从内存到磁盘的关系，所以我们需要建立struct dir与inode之间的关系。所以我们打开目录，自然意味着这个struct dir结构体要在内存中。再进一步思考，我们打开目录，肯定意味着要查找这个目录下什么东西（就像是你打开文件夹，是为了找到文件夹下某个文件），而只有inode记录着这个目录文件在磁盘中的位置，而目录文件就是一大堆目录项的集合，这些目录项记录着这个目录有啥。所以为了找到目录下有啥，我们肯定要找到它的inode，调入内存，并建立二者之间的关系。</p><p><code>search_dir_entry</code>用于在某个目录内找到指定名称的目录项。核心原理就是目录结构体struct dir 有一个指向自己inode的成员，该成员记录了该目录在磁盘中存储的位置（inode的i_sectors[ ]）我们可以根据这个找到目录文件，然后遍历其中的目录项即可</p><p>修改(<strong>fs/dir.c</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio-kernel.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token comment">/* 在part分区内的pdir目录内寻找名为name的文件或目录, * 找到后返回true并将其目录项存入dir_e,否则返回false */</span>bool <span class="token function">search_dir_entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>pdir<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> block_cnt <span class="token operator">=</span> <span class="token number">140</span><span class="token punctuation">;</span> <span class="token comment">// 12个直接块+128个一级间接块=140块</span>    <span class="token comment">/* 12个直接块大小+128个间接块,共560字节 */</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>all_blocks <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">48</span> <span class="token operator">+</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"search_dir_entry: sys_malloc for all_blocks failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> false<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint32_t</span> block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> pdir<span class="token operator">-></span>inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pdir<span class="token operator">-></span>inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若含有一级间接块表</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> pdir<span class="token operator">-></span>inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 至此,all_blocks存储的是该文件或目录的所有扇区地址 */</span>    <span class="token comment">/* 写目录项的时候已保证目录项不跨扇区,     * 这样读目录项时容易处理, 只申请容纳1个扇区的内存 */</span>    <span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span>SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>p_de <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">;</span> <span class="token comment">// p_de为指向目录项的指针,值为buf起始地址</span>    <span class="token class-name">uint32_t</span> dir_entry_size <span class="token operator">=</span> part<span class="token operator">-></span>sb<span class="token operator">-></span>dir_entry_size<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> dir_entry_cnt <span class="token operator">=</span> SECTOR_SIZE <span class="token operator">/</span> dir_entry_size<span class="token punctuation">;</span> <span class="token comment">// 1扇区内可容纳的目录项个数</span>    <span class="token comment">/* 开始在所有块中查找目录项 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> block_cnt<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* 块地址为0时表示该块中无数据,继续在其它块中找 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            block_idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">uint32_t</span> dir_entry_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/* 遍历扇区中所有目录项 */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>dir_entry_idx <span class="token operator">&lt;</span> dir_entry_cnt<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 若找到了,就直接复制整个目录项 */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>p_de<span class="token operator">-></span>filename<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>dir_e<span class="token punctuation">,</span> p_de<span class="token punctuation">,</span> dir_entry_size<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">sys_free</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">sys_free</span><span class="token punctuation">(</span>all_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> true<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            dir_entry_idx<span class="token operator">++</span><span class="token punctuation">;</span>            p_de<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>        p_de <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">;</span> <span class="token comment">// 此时p_de已经指向扇区内最后一个完整目录项了,需要恢复p_de指向为buf</span>        <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将buf清0,下次再用</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>all_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dir_close</code>用于关闭目录，实质就是调用<code>inode_close</code>从内存中释放该目录的inode占用的内存，并且释放目录占用的内存，也就是解绑struct dir与inode之间的关系。需要注意的是：根目录不能被释放，因为一定会反复被用到</p><p>修改(<strong>fs/dir.c</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 关闭目录 */</span><span class="token keyword">void</span> <span class="token function">dir_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/*************      根目录不能关闭     ***************     *1 根目录自打开后就不应该关闭,否则还需要再次open_root_dir();     *2 root_dir所在的内存是低端1M之内,并非在堆中,free会出问题 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">==</span> <span class="token operator">&amp;</span>root_dir<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* 不做任何处理直接返回*/</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">inode_close</span><span class="token punctuation">(</span>dir<span class="token operator">-></span>inode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>create_dir_entry</code>用于初始化一个目录项，也就是给目录项指向的文件一个名字与inode索引</p><p>修改(<strong>fs/dir.c</strong>)</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;debug.h&quot;&#x2F;* 在内存中初始化目录项p_de *&#x2F;void create_dir_entry(char *filename, uint32_t inode_no, uint8_t file_type, struct dir_entry *p_de)&#123;    ASSERT(strlen(filename) &lt;&#x3D; MAX_FILE_NAME_LEN);    &#x2F;* 初始化目录项 *&#x2F;    memcpy(p_de-&gt;filename, filename, strlen(filename));    p_de-&gt;i_no &#x3D; inode_no;    p_de-&gt;f_type &#x3D; file_type;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sync_dir_entry</code>用于将目录项写入父目录中。核心原理就是：父目录结构体struct dir有一个指向自己inode的成员，该成员记录了该父目录文件在磁盘中存储的位置（inode的i_sectors[ ]）我们可以根据这个找到目录文件，然后遍历目录文件找到空位，然后将目录项插入到这个空位即可。有些麻烦的是，需要判断inode的i_sectors[ ]这些元素是否为空，如果为空，那么我们还需要申请块用于承载目录文件。</p><p>修改(<strong>fs/dir.c</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"file.h"</span></span><span class="token comment">/* 将目录项p_de写入父目录parent_dir中,io_buf由主调函数提供 */</span>bool <span class="token function">sync_dir_entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>p_de<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>dir_inode <span class="token operator">=</span> parent_dir<span class="token operator">-></span>inode<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> dir_size <span class="token operator">=</span> dir_inode<span class="token operator">-></span>i_size<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> dir_entry_size <span class="token operator">=</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>dir_entry_size<span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>dir_size <span class="token operator">%</span> dir_entry_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// dir_size应该是dir_entry_size的整数倍</span>    <span class="token class-name">uint32_t</span> dir_entrys_per_sec <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">512</span> <span class="token operator">/</span> dir_entry_size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每扇区最大的目录项数目</span>    <span class="token class-name">int32_t</span> block_lba <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/* 将该目录的所有扇区地址(12个直接块+ 128个间接块)存入all_blocks */</span>    <span class="token class-name">uint8_t</span> block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> all_blocks<span class="token punctuation">[</span><span class="token number">140</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// all_blocks保存目录所有的块</span>    <span class="token comment">/* 将12个直接块存入all_blocks */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span>io_buf<span class="token punctuation">;</span> <span class="token comment">// dir_e用来在io_buf中遍历目录项</span>    <span class="token class-name">int32_t</span> block_bitmap_idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/* 开始遍历所有块以寻找目录项空位,若已有扇区中没有空闲位,     * 在不超过文件大小的情况下申请新扇区来存储新目录项 */</span>    block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">140</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 文件(包括目录)最大支持12个直接块+128个间接块＝140个块</span>        block_bitmap_idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 在三种情况下分配块</span>            block_lba <span class="token operator">=</span> <span class="token function">block_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>block_lba <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc block bitmap for sync_dir_entry failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> false<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 每分配一个块就同步一次block_bitmap */</span>            block_bitmap_idx <span class="token operator">=</span> block_lba <span class="token operator">-</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>            <span class="token function">ASSERT</span><span class="token punctuation">(</span>block_bitmap_idx <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>            block_bitmap_idx <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 若是直接块</span>                dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>block_idx <span class="token operator">==</span> <span class="token number">12</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                                         <span class="token comment">// 若是尚未分配一级间接块表(block_idx等于12表示第0个间接块地址为0)</span>                dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span> <span class="token comment">// 将上面分配的块做为一级间接块表地址</span>                block_lba <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                block_lba <span class="token operator">=</span> <span class="token function">block_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 再分配一个块做为第0个间接块</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>block_lba <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    block_bitmap_idx <span class="token operator">=</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">-</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>                    <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur_part<span class="token operator">-></span>block_bitmap<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"alloc block bitmap for sync_dir_entry failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> false<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">/* 每分配一个块就同步一次block_bitmap */</span>                block_bitmap_idx <span class="token operator">=</span> block_lba <span class="token operator">-</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>                <span class="token function">ASSERT</span><span class="token punctuation">(</span>block_bitmap_idx <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>                all_blocks<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>                <span class="token comment">/* 把新分配的第0个间接块地址写入一级间接块表 */</span>                <span class="token function">ide_write</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 若是间接块未分配</span>                all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>                <span class="token comment">/* 把新分配的第(block_idx-12)个间接块地址写入一级间接块表 */</span>                <span class="token function">ide_write</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 再将新目录项p_de写入新分配的间接块 */</span>            <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> p_de<span class="token punctuation">,</span> dir_entry_size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">ide_write</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            dir_inode<span class="token operator">-></span>i_size <span class="token operator">+=</span> dir_entry_size<span class="token punctuation">;</span>            <span class="token keyword">return</span> true<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 若第block_idx块已存在,将其读进内存,然后在该块中查找空目录项 */</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 在扇区内查找空目录项 */</span>        <span class="token class-name">uint8_t</span> dir_entry_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>dir_entry_idx <span class="token operator">&lt;</span> dir_entrys_per_sec<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">)</span><span class="token operator">-></span>f_type <span class="token operator">==</span> FT_UNKNOWN<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// FT_UNKNOWN为0,无论是初始化或是删除文件后,都会将f_type置为FT_UNKNOWN.</span>                <span class="token function">memcpy</span><span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">,</span> p_de<span class="token punctuation">,</span> dir_entry_size<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">ide_write</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dir_inode<span class="token operator">-></span>i_size <span class="token operator">+=</span> dir_entry_size<span class="token punctuation">;</span>                <span class="token keyword">return</span> true<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            dir_entry_idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"directory is full!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码：</p><p>修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">partition</span><span class="token operator">*</span> cur_part<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于作者在这两句代码中，</p><p>(<strong>fs/fs.c/sync_dir_entry</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将12个直接块存入all_blocks */</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span> block_idx<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>仅仅从目录文件中读出了前12个直接块，导致all_blocks数组仅前12项是有非0值的。假设整个目录文件，前12个直接块指向的块已经存满了目录项，那么新的目录项只能存储至一级间接块（i_sectors[12]）指向的块其中某个地址指向的目录文件中。但是代码逻辑，会必然判断出all_blocks[12] == 0，然后进入block_idx == 12，就会重新申请一个块充当一级间接块，就把原有的一级间接块覆盖了。这会导致对之前存储在间接块中的所有目录项的引用丢失，这是一个严重的数据完整性问题。</p><p>修改如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将12个直接块存入all_blocks */</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span> block_idx<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 若含有一级间接块表</span>   <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明：</p><p>修改(<strong>fs/dir.h</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">open_root_dir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span><span class="token function">dir_open</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">search_dir_entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>pdir<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">dir_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">create_dir_entry</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> file_type<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>p_de<span class="token punctuation">)</span><span class="token punctuation">;</span>bool <span class="token function">sync_dir_entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>p_de<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们要实现路径解析功能。比如我们要查找某个文件，我们提供路径<code>/home/kanshan/Desktop/test.c</code>，然后系统为我们找到它。解析路径的核心原理我们在本章一开始就提到了，就是那个查找<code>/home/test.c</code>文件系统是如何工作的例子。</p><p><code>path_parse</code>每次调用就会解析最上层路径名，并且在缓冲区<code>name_store</code>中存储解析的路径名，由于根目录是所有路径的最上层，所以不用参与解析（如<code>/home/test.c</code>目录层次是<code>/</code>，<code>home</code>，<code>test.c</code>，但是<code>/</code>是所有目录最上层，我们可以忽略，所以<code>/home/test.c</code>目录层次就可以认为是<code>home</code>，<code>test.c</code>）。比如此函数解析<code>/home/kanshan/Desktop/test.c</code>，第一次调用返回<code>/kanshan/Desktop/test.c</code>，<code>name_store</code>中存储<code>home</code>。再次调用返回<code>/Desktop/test.c</code>，<code>name_store</code>中存储<code>kanshan</code>…</p><p>修改(<strong>fs/fs.c</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将最上层路径名称解析出来 */</span><span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">path_parse</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name_store<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pathname<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 根目录不需要单独解析</span>        <span class="token comment">/* 路径中出现1个或多个连续的字符'/',将这些'/'跳过,如"///a/b" */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">++</span>pathname<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 开始一般的路径解析 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>pathname <span class="token operator">!=</span> <span class="token char">'/'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>pathname <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">*</span>name_store<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>pathname<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pathname<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若路径字符串为空则返回NULL</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> pathname<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>path_depth_cnt</code>用于返回路径深度，比如<code>/home/charliechen114514/Desktop/test.c</code>路径深度就是4。原理就是循环调用<code>path_parse</code>，看看返回值是不是空，决定是否继续调用`path_parse</p><p>修改(<strong>fs/fs.c</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 返回路径深度,比如/a/b/c,深度为3 */</span><span class="token class-name">int32_t</span> <span class="token function">path_depth_cnt</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>pathname <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> pathname<span class="token punctuation">;</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span>MAX_FILE_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用于path_parse的参数做路径解析</span>    <span class="token class-name">uint32_t</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 解析路径,从中拆分出各级名称 */</span>    p <span class="token operator">=</span> <span class="token function">path_parse</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        depth<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_FILE_NAME_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 如果p不等于NULL,继续分析路径</span>            p <span class="token operator">=</span> <span class="token function">path_parse</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> depth<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明</p><p>修改(<strong>fs/fs.h</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">path_depth_cnt</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来实现文件检索功能</p><p><code>search_file</code>用于提供文件路径，然后返回inode索引。核心原理就是不断循环：1，调用<code>path_parse</code>进行地址解析得到除根目录外最上层目录的名字；2，然后调用<code>search_dir_entry</code>从搜索目录中（第一次调用这个函数，其搜索目录自然是根目录）查找 1 得到的名字；3，然后更新下一次的搜索目录（就是 2 查找出来的目录项）；继续解析，然后继续查找，继续更新搜索目录…</p><p>修改(<strong>fs/fs.h</strong>)增加用于记录搜索路径的结构体</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_PATH_LEN</span> <span class="token expression"><span class="token number">512</span> </span><span class="token comment">// 路径最大长度</span></span><span class="token comment">/* 用来记录查找文件过程中已找到的上级路径,也就是查找文件过程中"走过的地方" */</span><span class="token keyword">struct</span> <span class="token class-name">path_search_record</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> searched_path<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 查找过程中的父路径</span>    <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir<span class="token punctuation">;</span>           <span class="token comment">// 文件或目录所在的直接父目录</span>    <span class="token keyword">enum</span> <span class="token class-name">file_types</span> file_type<span class="token punctuation">;</span>        <span class="token comment">// 找到的是普通文件还是目录,找不到将为未知类型(FT_UNKNOWN)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改(<strong>fs/fs.c</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 搜索文件pathname,若找到则返回其inode号,否则返回-1 */</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">search_file</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">path_search_record</span> <span class="token operator">*</span>searched_record<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 如果待查找的是根目录,为避免下面无用的查找,直接返回已知根目录信息 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token string">"/."</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token string">"/.."</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        searched_record<span class="token operator">-></span>parent_dir <span class="token operator">=</span> <span class="token operator">&amp;</span>root_dir<span class="token punctuation">;</span>        searched_record<span class="token operator">-></span>file_type <span class="token operator">=</span> FT_DIRECTORY<span class="token punctuation">;</span>        searched_record<span class="token operator">-></span>searched_path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 搜索路径置空</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint32_t</span> path_len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 保证pathname至少是这样的路径/x且小于最大长度 */</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>pathname<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span> <span class="token operator">&amp;&amp;</span> path_len <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> path_len <span class="token operator">&lt;</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>sub_path <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pathname<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir <span class="token operator">=</span> <span class="token operator">&amp;</span>root_dir<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> dir_e<span class="token punctuation">;</span>    <span class="token comment">/* 记录路径解析出来的各级名称,如路径"/a/b/c",     * 数组name每次的值分别是"a","b","c" */</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span>MAX_FILE_NAME_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    searched_record<span class="token operator">-></span>parent_dir <span class="token operator">=</span> parent_dir<span class="token punctuation">;</span>    searched_record<span class="token operator">-></span>file_type <span class="token operator">=</span> FT_UNKNOWN<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> parent_inode_no <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 父目录的inode号</span>    sub_path <span class="token operator">=</span> <span class="token function">path_parse</span><span class="token punctuation">(</span>sub_path<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若第一个字符就是结束符,结束循环</span>        <span class="token comment">/* 记录查找过的路径,但不能超过searched_path的长度512字节 */</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>searched_record<span class="token operator">-></span>searched_path<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 记录已存在的父目录 */</span>        <span class="token function">strcat</span><span class="token punctuation">(</span>searched_record<span class="token operator">-></span>searched_path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">strcat</span><span class="token punctuation">(</span>searched_record<span class="token operator">-></span>searched_path<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 在所给的目录中查找文件 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">search_dir_entry</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> parent_dir<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dir_e<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">memset</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_FILE_NAME_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 若sub_path不等于NULL,也就是未结束时继续拆分路径 */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sub_path<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                sub_path <span class="token operator">=</span> <span class="token function">path_parse</span><span class="token punctuation">(</span>sub_path<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>FT_DIRECTORY <span class="token operator">==</span> dir_e<span class="token punctuation">.</span>f_type<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 如果被打开的是目录</span>                parent_inode_no <span class="token operator">=</span> parent_dir<span class="token operator">-></span>inode<span class="token operator">-></span>i_no<span class="token punctuation">;</span>                <span class="token function">dir_close</span><span class="token punctuation">(</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>                parent_dir <span class="token operator">=</span> <span class="token function">dir_open</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> dir_e<span class="token punctuation">.</span>i_no<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新父目录</span>                searched_record<span class="token operator">-></span>parent_dir <span class="token operator">=</span> parent_dir<span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>FT_REGULAR <span class="token operator">==</span> dir_e<span class="token punctuation">.</span>f_type<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 若是普通文件</span>                searched_record<span class="token operator">-></span>file_type <span class="token operator">=</span> FT_REGULAR<span class="token punctuation">;</span>                <span class="token keyword">return</span> dir_e<span class="token punctuation">.</span>i_no<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若找不到,则返回-1</span>            <span class="token comment">/* 找不到目录项时,要留着parent_dir不要关闭,             * 若是创建新文件的话需要在parent_dir中创建 */</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 执行到此,必然是遍历了完整路径并且查找的文件或目录只有同名目录存在 */</span>    <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token operator">-></span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 保存被查找目录的直接父目录 */</span>    searched_record<span class="token operator">-></span>parent_dir <span class="token operator">=</span> <span class="token function">dir_open</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> parent_inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>    searched_record<span class="token operator">-></span>file_type <span class="token operator">=</span> FT_DIRECTORY<span class="token punctuation">;</span>    <span class="token keyword">return</span> dir_e<span class="token punctuation">.</span>i_no<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码：</p><p>修改(<strong>fs/dir.h</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">dir</span> root_dir<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来实现文件创建功能</p><p><code>file_create</code>用于创建文件，若成功就会返回文件描述符。核心步骤：1，创建新文件的inode，其中涉及inode位图修改，inode初始化；2，文件结构创建，因为文件结构是描述进程或线程对于文件的操作状态，创建自然也属于这种操作状态。其中涉及全局打开文件结构数组更改；3、创建对应目录项；4、同步新文件的目录项到父目录中去；同步父目录inode，父节点inode其中会涉及inode-&gt;i_size，inode-&gt;i_sectors[ ]（因为文件的目录项会存在父目录文件中，可能会涉及新的块申请）。同步inode也会同步磁盘中的inode数组；创建文件的inode；inode位图；5、将新文件的inode加入打开链表；6、在创建文件进程或线程的pcb中安装文件描述符；</p><p>我们可以发现文件创建，核心就是要处理inode，目录，文件结构之间的关系。</p><p>修改（<strong>fs/file.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token comment">/* 创建文件,若成功则返回文件描述符,否则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">file_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 后续操作的公共缓冲区 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>io_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>io_buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"in file_creat: sys_malloc for io_buf failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint8_t</span> rollback_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用于操作失败时回滚各资源状态</span>    <span class="token comment">/* 为新文件分配inode */</span>    <span class="token class-name">int32_t</span> inode_no <span class="token operator">=</span> <span class="token function">inode_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"in file_creat: allocate inode failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 此inode要从堆中申请内存,不可生成局部变量(函数退出时会释放)     * 因为file_table数组中的文件描述符的inode指针要指向它.*/</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>new_file_inode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_file_inode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_create: sys_malloc for inode failded\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rollback_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> rollback<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">inode_init</span><span class="token punctuation">(</span>inode_no<span class="token punctuation">,</span> new_file_inode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化i结点</span>    <span class="token comment">/* 返回的是file_table数组的下标 */</span>    <span class="token keyword">int</span> fd_idx <span class="token operator">=</span> <span class="token function">get_free_slot_in_global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd_idx <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"exceed max open files\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rollback_step <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> rollback<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode <span class="token operator">=</span> new_file_inode<span class="token punctuation">;</span>    file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_flag <span class="token operator">=</span> flag<span class="token punctuation">;</span>    file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token operator">-></span>write_deny <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> new_dir_entry<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>new_dir_entry<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">create_dir_entry</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> FT_REGULAR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_dir_entry<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// create_dir_entry只是内存操作不出意外,不会返回失败</span>    <span class="token comment">/* 同步内存数据到硬盘 */</span>    <span class="token comment">/* a 在目录parent_dir下安装目录项new_dir_entry, 写入硬盘后返回true,否则false */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sync_dir_entry</span><span class="token punctuation">(</span>parent_dir<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_dir_entry<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sync dir_entry to disk failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rollback_step <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> rollback<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* b 将父目录i结点的内容同步到硬盘 */</span>    <span class="token function">inode_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> parent_dir<span class="token operator">-></span>inode<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* c 将新创建文件的i结点内容同步到硬盘 */</span>    <span class="token function">inode_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> new_file_inode<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* d 将inode_bitmap位图同步到硬盘 */</span>    <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> INODE_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* e 将创建的文件i结点添加到open_inodes链表 */</span>    <span class="token function">list_push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur_part<span class="token operator">-></span>open_inodes<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_file_inode<span class="token operator">-></span>inode_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    new_file_inode<span class="token operator">-></span>i_open_cnts <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">pcb_fd_install</span><span class="token punctuation">(</span>fd_idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*创建文件需要创建相关的多个资源,若某步失败则会执行到下面的回滚步骤 */</span>rollback<span class="token operator">:</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>rollback_step<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>        <span class="token comment">/* 失败时,将file_table中的相应位清空 */</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token function">sys_free</span><span class="token punctuation">(</span>new_file_inode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>        <span class="token comment">/* 如果新文件的i结点创建失败,之前位图中分配的inode_no也要恢复 */</span>        <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur_part<span class="token operator">-></span>inode_bitmap<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码块</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 为新文件分配inode */</span><span class="token class-name">int32_t</span> inode_no <span class="token operator">=</span> <span class="token function">inode_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"in file_creat: allocate inode failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改成</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 为新文件分配inode */</span><span class="token class-name">int32_t</span> inode_no <span class="token operator">=</span> <span class="token function">inode_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"in file_creat: allocate inode failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">goto</span> rollback<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明：</p><p>修改（<strong>fs/file.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"dir.h"</span></span><span class="token class-name">int32_t</span> <span class="token function">file_create</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>sys_open</code>用于根据传入的路径打开或创建文件，并返回文件描述符，由于现在是写个初版，我们只实现创建功能。核心原理就是：先调用<code>search_file</code>来查找指定路径是否有这个文件，如果没有，直接调用<code>file_create</code>来创建文件。从查找是否存在，到最后创建之间，要排除以下情况：1、找到了，但是找到的是个目录；2、查找过程中某个中间路径就不存在，比如我要创建<code>/home/kanshan/test.c</code>，但是调用<code>search_file</code>之后，发现，这个<code>/kanshan</code>目录都不存在；3、在最后一个路径上没找到，但是没有传入表示创建文件的标志；4、要创建的文件已经存在；</p><p>修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 打开文件的选项 */</span><span class="token keyword">enum</span> <span class="token class-name">oflags</span><span class="token punctuation">&#123;</span>    O_RDONLY<span class="token punctuation">,</span>   <span class="token comment">// 只读</span>    O_WRONLY<span class="token punctuation">,</span>   <span class="token comment">// 只写</span>    O_RDWR<span class="token punctuation">,</span>     <span class="token comment">// 读写</span>    O_CREAT <span class="token operator">=</span> <span class="token number">4</span> <span class="token comment">// 创建</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改(<strong>fs/fs.c</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"file.h"</span></span><span class="token comment">/* 打开或创建文件成功后,返回文件描述符,否则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> flags<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 对目录要用dir_open,这里只有open文件 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pathname<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>pathname<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"can`t open a directory %s\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>flags <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 默认为找不到</span>    <span class="token keyword">struct</span> <span class="token class-name">path_search_record</span> searched_record<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>searched_record<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path_search_record</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 记录目录深度.帮助判断中间某个目录不存在的情况 */</span>    <span class="token class-name">uint32_t</span> pathname_depth <span class="token operator">=</span> <span class="token function">path_depth_cnt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 先检查文件是否存在 */</span>    <span class="token keyword">int</span> inode_no <span class="token operator">=</span> <span class="token function">search_file</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>searched_record<span class="token punctuation">)</span><span class="token punctuation">;</span>    bool found <span class="token operator">=</span> inode_no <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> true <span class="token operator">:</span> false<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>file_type <span class="token operator">==</span> FT_DIRECTORY<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"can`t open a direcotry with open(), use opendir() to instead\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint32_t</span> path_searched_depth <span class="token operator">=</span> <span class="token function">path_depth_cnt</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>searched_path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 先判断是否把pathname的各层目录都访问到了,即是否在某个中间目录就失败了 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pathname_depth <span class="token operator">!=</span> path_searched_depth<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 说明并没有访问到全部的路径,某个中间目录是不存在的</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"cannot access %s: Not a directory, subpath %s is`t exist\n"</span><span class="token punctuation">,</span>               pathname<span class="token punctuation">,</span> searched_record<span class="token punctuation">.</span>searched_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 若是在最后一个路径上没找到,并且并不是要创建文件,直接返回-1 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>found <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CREAT<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"in path %s, file %s is`t exist\n"</span><span class="token punctuation">,</span>               searched_record<span class="token punctuation">.</span>searched_path<span class="token punctuation">,</span>               <span class="token punctuation">(</span><span class="token function">strrchr</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>searched_path<span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>found <span class="token operator">&amp;&amp;</span> flags <span class="token operator">&amp;</span> O_CREAT<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若要创建的文件已存在</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s has already exist!\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CREAT<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> O_CREAT<span class="token operator">:</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"creating file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fd <span class="token operator">=</span> <span class="token function">file_create</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token function">strrchr</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 此fd是指任务pcb->fd_table数组中的元素下标,         * 并不是指全局file_table中的下标 */</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> fd<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明：</p><p>修改(<strong>fs/fs.h</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>filesys_init</code>，在<code>list_traversal</code>轮询分区时调用<code>mount_partition</code>以挂载分区。然后调用<code>open_root_dir</code>加入打开的当前分区的根目录，初始化全局打开文件结构数组</p><p>修改（<strong>fs/fs.c/filesys_init</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token function">sys_free</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 确定默认操作的分区 */</span>    <span class="token keyword">char</span> default_part<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"sdb1"</span><span class="token punctuation">;</span>    <span class="token comment">/* 挂载分区 */</span>    <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>partition_list<span class="token punctuation">,</span> mount_partition<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>default_part<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token function">sys_free</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 确定默认操作的分区 */</span>    <span class="token keyword">char</span> default_part<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"sdb1"</span><span class="token punctuation">;</span>    <span class="token comment">/* 挂载分区 */</span>    <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>partition_list<span class="token punctuation">,</span> mount_partition<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>default_part<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 将当前分区的根目录打开 */</span>    <span class="token function">open_root_dir</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 初始化文件表 */</span>    <span class="token class-name">uint32_t</span> fd_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fd_idx <span class="token operator">&lt;</span> MAX_FILE_OPEN<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        file_table<span class="token punctuation">[</span>fd_idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码，修改（<strong>fs/file.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> file_table<span class="token punctuation">[</span>MAX_FILE_OPEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码，修改（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/file1"</span><span class="token punctuation">,</span> O_CREAT<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了方便调试，我们修改（<strong>fs/fs.c/mount_partition</strong>），调试完毕需删除增加的代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mount %s done!\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 此处返回true是为了迎合主调函数list_traversal的实现,与函数本身功能无关。    只有返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历.*/</span><span class="token function">sys_free</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mount %s done!\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sb1 data_start_lba: %x\n"</span><span class="token punctuation">,</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 此处返回true是为了迎合主调函数list_traversal的实现,与函数本身功能无关。    只有返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历.*/</span><span class="token function">sys_free</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当启动虚拟机后，会显示sdb 1的数据区起始扇区（我是A6B，如果你一直跟着我做，那么也应该是这个），由于我们的根目录文件的第一个块就放在数据区第一个扇区中，所以我们拿到这个数据后将其 * 512，然后带入以下代命令，就可以查看hd80M.img 数据区开始 512字节的数据，我们就可以得到书上的效果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xxd <span class="token parameter variable">-s</span> <span class="token number">1365504</span> <span class="token parameter variable">-l</span> <span class="token number">512</span> hd80M.img<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>小节d：</p><p>文件的打开与关闭</p><p><code>file_open</code>：用于打开文件，实质就是让文件结构指向一个内存中的inode。原理：传入需要打开文件的inode数组索引，调用<code>get_free_slot_in_global</code>在全局打开文件结构数组中找个空位，调用<code>inode_open</code>将inode调入内存中，然后让该文件结构指向这个inode，最后调用<code>pcb_fd_install</code>安装文件描述符。为了同步性，以写的方式打开的文件不应该是正在写入的文件，需要判断该文件对应inode中的正在写入标志。</p><p>修改（<strong>fs/file.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token comment">/* 打开编号为inode_no的inode对应的文件,若成功则返回文件描述符,否则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">file_open</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> fd_idx <span class="token operator">=</span> <span class="token function">get_free_slot_in_global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd_idx <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"exceed max open files\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode <span class="token operator">=</span> <span class="token function">inode_open</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>    file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 每次打开文件,要将fd_pos还原为0,即让文件内的指针指向开头</span>    file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_flag <span class="token operator">=</span> flag<span class="token punctuation">;</span>    bool <span class="token operator">*</span>write_deny <span class="token operator">=</span> <span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token operator">-></span>write_deny<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">&amp;</span> O_WRONLY <span class="token operator">||</span> flag <span class="token operator">&amp;</span> O_RDWR<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 只要是关于写文件,判断是否有其它进程正写此文件</span>        <span class="token comment">// 若是读文件,不考虑write_deny</span>        <span class="token comment">/* 以下进入临界区前先关中断 */</span>        <span class="token keyword">enum</span> <span class="token class-name">intr_status</span> old_status <span class="token operator">=</span> <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>write_deny<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                                <span class="token comment">// 若当前没有其它进程写该文件,将其占用.</span>            <span class="token operator">*</span>write_deny <span class="token operator">=</span> true<span class="token punctuation">;</span>          <span class="token comment">// 置为true,避免多个进程同时写此文件</span>            <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 恢复中断</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 直接失败返回</span>            <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file can`t be write now, try again later\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token comment">// 若是读文件或创建文件,不用理会write_deny,保持默认</span>    <span class="token keyword">return</span> <span class="token function">pcb_fd_install</span><span class="token punctuation">(</span>fd_idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以与写有关的方式打开文件，但是遇见其他线程或进程正在写这个文件，作者代码没有释放文件结构！所以，修改</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">else</span><span class="token punctuation">&#123;</span> <span class="token comment">// 直接失败返回</span>    <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file can`t be write now, try again later\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">else</span><span class="token punctuation">&#123;</span> <span class="token comment">// 直接失败返回</span>    <span class="token function">intr_set_status</span><span class="token punctuation">(</span>old_status<span class="token punctuation">)</span><span class="token punctuation">;</span>    file_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file can`t be write now, try again later\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之前我们实现的<code>sys_open</code>只有创建文件功能，现在我们将<code>file_open</code>封装进入，这样<code>sys_open</code>就有了打开文件的功能了</p><p>修改（<strong>fs/fs.c/sys_open</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">switch</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CREAT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> O_CREAT<span class="token operator">:</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"creating file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fd <span class="token operator">=</span> <span class="token function">file_create</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token function">strrchr</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 此fd是指任务pcb->fd_table数组中的元素下标,     * 并不是指全局file_table中的下标 */</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> fd<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">switch</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> O_CREAT<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> O_CREAT<span class="token operator">:</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"creating file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fd <span class="token operator">=</span> <span class="token function">file_create</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token function">strrchr</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span>    <span class="token comment">/* 其余情况均为打开已存在文件:     * O_RDONLY,O_WRONLY,O_RDWR */</span>    fd <span class="token operator">=</span> <span class="token function">file_open</span><span class="token punctuation">(</span>inode_no<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 此fd是指任务pcb->fd_table数组中的元素下标, * 并不是指全局file_table中的下标 */</span><span class="token keyword">return</span> fd<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>file_close</code>用传入的文件结构指针关闭文件。步骤：将文件正在写标志关闭，调用<code>inode_close</code>移除内存中的inode，并解除文件结构与inode的关系。</p><p>修改（<strong>fs/file.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 关闭文件 */</span><span class="token class-name">int32_t</span> <span class="token function">file_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>write_deny <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token function">inode_close</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token punctuation">)</span><span class="token punctuation">;</span>    file<span class="token operator">-></span>fd_inode <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 使文件结构可用</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>到这里我们发现，打开关闭文件，就是在处理文件结构与inode的关系。</p><p>函数声明，修改（<strong>fs/file.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">file_open</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">file_close</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>fd_local2global</code>，用于将文件描述符转换为全局打开文件结构数组下标，原理就是去当前正在运行的进程或线程的pcb中的fd_table数组中找到文件描述符对应的元素，这里面存的就是全局打开文件结构数组下标。</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将文件描述符转化为文件表的下标 */</span><span class="token keyword">static</span> <span class="token class-name">uint32_t</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> local_fd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> global_fd <span class="token operator">=</span> cur<span class="token operator">-></span>fd_table<span class="token punctuation">[</span>local_fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>global_fd <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> global_fd <span class="token operator">&lt;</span> MAX_FILE_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>global_fd<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_close</code>用传入的文件描述符关闭文件，原理：调用<code>fd_close2global</code>将文件描述符转换为全局打开文件结构数组下标，然后调用<code>file_close</code>关闭这个文件结构对应的文件，最后清空pcb中的文件描述符位</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 关闭文件描述符fd指向的文件,成功返回0,否则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_close</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 返回值默认为-1,即失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">uint32_t</span> _fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token function">file_close</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>_fd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>fd_table<span class="token punctuation">[</span>fd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 使该文件描述符位可用</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_close</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码，修改（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/file1"</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fd:%d\n"</span><span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d closed now\n"</span><span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节e：</p><p><code>file_write</code>，用于把buf中的count个字节写入文件。核心原理：传进函数的文件结构<code>struct file</code>指针中有个指向操作文件inode的指针，通过这个inode中的i_size与i_sectors[ ]，我们可以顺利知道文件大小与存储位置信息。先将文件已有数据的最后一块数据读出来并与将要写入的数据在缓冲区中共同拼凑成一个完整的块，然后写入磁盘。剩下的数据以块为单位继续写入磁盘即可。</p><p>修改（<strong>fs/file.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 把buf中的count个字节写入file,成功则返回写入的字节数,失败则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">file_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size <span class="token operator">+</span> count<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">*</span> <span class="token number">140</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 文件目前最大只支持512*140=71680字节</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"exceed max file_size 71680 bytes, write file failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint8_t</span> <span class="token operator">*</span>io_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>io_buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_write: sys_malloc for io_buf failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>all_blocks <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用来记录文件所有的块地址</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_write: sys_malloc for all_blocks failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">const</span> <span class="token class-name">uint8_t</span> <span class="token operator">*</span>src <span class="token operator">=</span> buf<span class="token punctuation">;</span>      <span class="token comment">// 用src指向buf中待写入的数据</span>    <span class="token class-name">uint32_t</span> bytes_written <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 用来记录已写入数据大小</span>    <span class="token class-name">uint32_t</span> size_left <span class="token operator">=</span> count<span class="token punctuation">;</span>    <span class="token comment">// 用来记录未写入数据大小</span>    <span class="token class-name">int32_t</span> block_lba <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 块地址</span>    <span class="token class-name">uint32_t</span> block_bitmap_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用来记录block对应于block_bitmap中的索引,做为参数传给bitmap_sync</span>    <span class="token class-name">uint32_t</span> sec_idx<span class="token punctuation">;</span>              <span class="token comment">// 用来索引扇区</span>    <span class="token class-name">uint32_t</span> sec_lba<span class="token punctuation">;</span>              <span class="token comment">// 扇区地址</span>    <span class="token class-name">uint32_t</span> sec_off_bytes<span class="token punctuation">;</span>        <span class="token comment">// 扇区内字节偏移量</span>    <span class="token class-name">uint32_t</span> sec_left_bytes<span class="token punctuation">;</span>       <span class="token comment">// 扇区内剩余字节量</span>    <span class="token class-name">uint32_t</span> chunk_size<span class="token punctuation">;</span>           <span class="token comment">// 每次写入硬盘的数据块大小</span>    <span class="token class-name">int32_t</span> indirect_block_table<span class="token punctuation">;</span>  <span class="token comment">// 用来获取一级间接表地址</span>    <span class="token class-name">uint32_t</span> block_idx<span class="token punctuation">;</span>            <span class="token comment">// 块索引</span>    <span class="token comment">/* 判断文件是否是第一次写,如果是,先为其分配一个块 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        block_lba <span class="token operator">=</span> <span class="token function">block_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block_lba <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_write: block_bitmap_alloc failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>        <span class="token comment">/* 每分配一个块就将位图同步到硬盘 */</span>        block_bitmap_idx <span class="token operator">=</span> block_lba <span class="token operator">-</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>block_bitmap_idx <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 写入count个字节前,该文件已经占用的块数 */</span>    <span class="token class-name">uint32_t</span> file_has_used_blocks <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size <span class="token operator">/</span> BLOCK_SIZE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/* 存储count字节后该文件将占用的块数 */</span>    <span class="token class-name">uint32_t</span> file_will_use_blocks <span class="token operator">=</span> <span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size <span class="token operator">+</span> count<span class="token punctuation">)</span> <span class="token operator">/</span> BLOCK_SIZE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>file_will_use_blocks <span class="token operator">&lt;=</span> <span class="token number">140</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 通过此增量判断是否需要分配扇区,如增量为0,表示原扇区够用 */</span>    <span class="token class-name">uint32_t</span> add_blocks <span class="token operator">=</span> file_will_use_blocks <span class="token operator">-</span> file_has_used_blocks<span class="token punctuation">;</span>    <span class="token comment">/* 开始将文件所有块地址收集到all_blocks,(系统中块大小等于扇区大小)     * 后面都统一在all_blocks中获取写入扇区地址 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>add_blocks <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* 在同一扇区内写入数据,不涉及到分配新扇区 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>file_has_used_blocks <span class="token operator">&lt;=</span> <span class="token number">12</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                                         <span class="token comment">// 文件数据量将在12块之内</span>            block_idx <span class="token operator">=</span> file_has_used_blocks <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 指向最后一个已有数据的扇区</span>            all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 未写入新数据之前已经占用了间接块,需要将间接块地址读进来 */</span>            <span class="token function">ASSERT</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            indirect_block_table <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> indirect_block_table<span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* 若有增量,便涉及到分配新扇区及是否分配一级间接块表,下面要分三种情况处理 */</span>        <span class="token comment">/* 第一种情况:12个直接块够用*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>file_will_use_blocks <span class="token operator">&lt;=</span> <span class="token number">12</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 先将有剩余空间的可继续用的扇区地址写入all_blocks */</span>            block_idx <span class="token operator">=</span> file_has_used_blocks <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token function">ASSERT</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">/* 再将未来要用的扇区分配好后写入all_blocks */</span>            block_idx <span class="token operator">=</span> file_has_used_blocks<span class="token punctuation">;</span> <span class="token comment">// 指向第一个要分配的新扇区</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> file_will_use_blocks<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                block_lba <span class="token operator">=</span> <span class="token function">block_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>block_lba <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_write: block_bitmap_alloc for situation 1 failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">/* 写文件时,不应该存在块未使用但已经分配扇区的情况,当文件删除时,就会把块地址清0 */</span>                <span class="token function">ASSERT</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保尚未分配扇区地址</span>                file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>                <span class="token comment">/* 每分配一个块就将位图同步到硬盘 */</span>                block_bitmap_idx <span class="token operator">=</span> block_lba <span class="token operator">-</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>                <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>                block_idx<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 下一个分配的新扇区</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>file_has_used_blocks <span class="token operator">&lt;=</span> <span class="token number">12</span> <span class="token operator">&amp;&amp;</span> file_will_use_blocks <span class="token operator">></span> <span class="token number">12</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 第二种情况: 旧数据在12个直接块内,新数据将使用间接块*/</span>            <span class="token comment">/* 先将有剩余空间的可继续用的扇区地址收集到all_blocks */</span>            block_idx <span class="token operator">=</span> file_has_used_blocks <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 指向旧数据所在的最后一个扇区</span>            all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">/* 创建一级间接块表 */</span>            block_lba <span class="token operator">=</span> <span class="token function">block_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>block_lba <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_write: block_bitmap_alloc for situation 2 failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">ASSERT</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保一级间接块表未分配</span>            <span class="token comment">/* 分配一级间接块索引表 */</span>            indirect_block_table <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>            block_idx <span class="token operator">=</span> file_has_used_blocks<span class="token punctuation">;</span> <span class="token comment">// 第一个未使用的块,即本文件最后一个已经使用的直接块的下一块</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> file_will_use_blocks<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                block_lba <span class="token operator">=</span> <span class="token function">block_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>block_lba <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_write: block_bitmap_alloc for situation 2 failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                                                      <span class="token comment">// 新创建的0~11块直接存入all_blocks数组</span>                    <span class="token function">ASSERT</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保尚未分配扇区地址</span>                    file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span>                <span class="token punctuation">&#123;</span> <span class="token comment">// 间接块只写入到all_block数组中,待全部分配完成后一次性同步到硬盘</span>                    all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">/* 每分配一个块就将位图同步到硬盘 */</span>                block_bitmap_idx <span class="token operator">=</span> block_lba <span class="token operator">-</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>                <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>                block_idx<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 下一个新扇区</span>            <span class="token punctuation">&#125;</span>            <span class="token function">ide_write</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> indirect_block_table<span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 同步一级间接块表到硬盘</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>file_has_used_blocks <span class="token operator">></span> <span class="token number">12</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 第三种情况:新数据占据间接块*/</span>            <span class="token function">ASSERT</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 已经具备了一级间接块表</span>            indirect_block_table <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 获取一级间接表地址</span>            <span class="token comment">/* 已使用的间接块也将被读入all_blocks,无须单独收录 */</span>            <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> indirect_block_table<span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取所有间接块地址</span>            block_idx <span class="token operator">=</span> file_has_used_blocks<span class="token punctuation">;</span> <span class="token comment">// 第一个未使用的间接块,即已经使用的间接块的下一块</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> file_will_use_blocks<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                block_lba <span class="token operator">=</span> <span class="token function">block_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>block_lba <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_write: block_bitmap_alloc for situation 3 failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                all_blocks<span class="token punctuation">[</span>block_idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>                <span class="token comment">/* 每分配一个块就将位图同步到硬盘 */</span>                block_bitmap_idx <span class="token operator">=</span> block_lba <span class="token operator">-</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>                <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">ide_write</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> indirect_block_table<span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 同步一级间接块表到硬盘</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    bool first_write_block <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// 含有剩余空间的扇区标识</span>    <span class="token comment">/* 块地址已经收集到all_blocks中,下面开始写数据 */</span>    file<span class="token operator">-></span>fd_pos <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 置fd_pos为文件大小-1,下面在写数据时随时更新</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>bytes_written <span class="token operator">&lt;</span> count<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 直到写完所有数据</span>        <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        sec_idx <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size <span class="token operator">/</span> BLOCK_SIZE<span class="token punctuation">;</span>        sec_lba <span class="token operator">=</span> all_blocks<span class="token punctuation">[</span>sec_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        sec_off_bytes <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size <span class="token operator">%</span> BLOCK_SIZE<span class="token punctuation">;</span>        sec_left_bytes <span class="token operator">=</span> BLOCK_SIZE <span class="token operator">-</span> sec_off_bytes<span class="token punctuation">;</span>        <span class="token comment">/* 判断此次写入硬盘的数据大小 */</span>        chunk_size <span class="token operator">=</span> size_left <span class="token operator">&lt;</span> sec_left_bytes <span class="token operator">?</span> size_left <span class="token operator">:</span> sec_left_bytes<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first_write_block<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> sec_lba<span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            first_write_block <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>io_buf <span class="token operator">+</span> sec_off_bytes<span class="token punctuation">,</span> src<span class="token punctuation">,</span> chunk_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ide_write</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> sec_lba<span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file write at lba 0x%x\n"</span><span class="token punctuation">,</span> sec_lba<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调试,完成后去掉</span>        src <span class="token operator">+=</span> chunk_size<span class="token punctuation">;</span>                    <span class="token comment">// 将指针推移到下个新数据</span>        file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size <span class="token operator">+=</span> chunk_size<span class="token punctuation">;</span> <span class="token comment">// 更新文件大小</span>        file<span class="token operator">-></span>fd_pos <span class="token operator">+=</span> chunk_size<span class="token punctuation">;</span>        bytes_written <span class="token operator">+=</span> chunk_size<span class="token punctuation">;</span>        size_left <span class="token operator">-=</span> chunk_size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">inode_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> file<span class="token operator">-></span>fd_inode<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>all_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bytes_written<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/file.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">file_write</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们之前在第十二章实现printf时，实现了sys_write，由于当时没有文件系统，所以它就是调用了console_put_str打印字符串，现在我们改进sys_write</p><p><code>sys_write</code>用于将buf中连续count个字节写入文件描述符fd。如果传入的fd表示标准输出，直接调用console_put_str打印即可。如果不是，直接调用<code>file_write</code>即可</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token comment">/* 将buf中连续count个字节写入文件描述符fd,成功则返回写入的字节数,失败返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_write</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_write: fd error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> stdout_no<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> tmp_buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>tmp_buf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">console_put_str</span><span class="token punctuation">(</span>tmp_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint32_t</span> _fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>wr_file <span class="token operator">=</span> <span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>_fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>wr_file<span class="token operator">-></span>fd_flag <span class="token operator">&amp;</span> O_WRONLY <span class="token operator">||</span> wr_file<span class="token operator">-></span>fd_flag <span class="token operator">&amp;</span> O_RDWR<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">uint32_t</span> bytes_written <span class="token operator">=</span> <span class="token function">file_write</span><span class="token punctuation">(</span>wr_file<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bytes_written<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">"sys_write: not allowed to write file without flag O_RDWR or O_WRONLY\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码，修改（<strong>fs/file.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 标准输入输出描述符 */</span><span class="token keyword">enum</span> <span class="token class-name">std_fd</span> <span class="token punctuation">&#123;</span>   stdin_no<span class="token punctuation">,</span>   <span class="token comment">// 0 标准输入</span>   stdout_no<span class="token punctuation">,</span>  <span class="token comment">// 1 标准输出</span>   stderr_no   <span class="token comment">// 2 标准错误</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_write</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改（<strong>userprog/syscall-init.c</strong>），删除原有<code>sys_write</code>定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 打印字符串str(未实现文件系统前的版本) */</span><span class="token class-name">uint32_t</span> <span class="token function">sys_write</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后（<strong>userprog/syscall-init.c</strong>）添加<code>fs.h</code>头文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后删除（<strong>userprog/syscall-init.c</strong>）的<code>sys_write</code>声明</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">sys_write</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后修改用户态的入口<code>write</code></p><p>修改（<strong>fs/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 打印字符串str */</span><span class="token class-name">uint32_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_WRITE<span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 把buf中count个字符写入文件描述符fd */</span><span class="token class-name">uint32_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall3</span><span class="token punctuation">(</span>SYS_WRITE<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改函数声明</p><p>修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后修改<code>printf</code>，改为向标准输出写入替换后的字符串</p><p>修改（<strong>lib/stdio.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 格式化输出字符串format */</span><span class="token class-name">uint32_t</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   va_list args<span class="token punctuation">;</span>   <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 使args指向format</span>   <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>       <span class="token comment">// 用于存储拼接后的字符串</span>   <span class="token function">vsprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token function">write</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 格式化输出字符串format */</span><span class="token class-name">uint32_t</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    va_list args<span class="token punctuation">;</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使args指向format</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token comment">// 用于存储拼接后的字符串</span>    <span class="token function">vsprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/file1"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fd:%d\n"</span><span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token string">"hello,world\n"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d closed now\n"</span><span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>xxd -s 屏幕显示写入地址 *512 -l 512 hd80M.img</code>查看磁盘中的文件</p><p>小节f：</p><p><code>file_read</code>从文件file中读取count个字节到buf。核心原理：文件结构<code>struct file</code>内有个<code>fd_pos</code>表示当前操作的文件内容位置，其实就是要读取的内容在文件中的起始位置，比如1个1KB大小的文本文件，fd_pos = 500，那么就是表示读取当前文件中偏移500字节的这个字符开始的内容。通过<code>struct file</code>中的<code>fd_pos</code>与传入函数的<code>count</code>，我们可以确定要读取的内容相对于整个文件的字节偏移量。然后<code>struct file</code>中有个指向操作文件inode的指 针，通过这个inode中的i_size与i_sectors[ ]，我们可以顺利知道文件存储位置信息。所以，自然就能知道要读取内容在磁盘中的位置。由于我们操作单位是块，所以对于起始位置，我们要抛弃这个块前面的无用数据，对于结束位置，我们要抛弃这个块后面的无用数据。</p><p>修改（<strong>fs/file.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 从文件file中读取count个字节写入buf, 返回读出的字节数,若到文件尾则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">file_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> <span class="token operator">*</span>buf_dst <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>buf<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> size <span class="token operator">=</span> count<span class="token punctuation">,</span> size_left <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token comment">/* 若要读取的字节数超过了文件可读的剩余量, 就用剩余量做为待读取的字节数 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_pos <span class="token operator">+</span> count<span class="token punctuation">)</span> <span class="token operator">></span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        size <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size <span class="token operator">-</span> file<span class="token operator">-></span>fd_pos<span class="token punctuation">;</span>        size_left <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若到文件尾则返回-1</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint8_t</span> <span class="token operator">*</span>io_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>io_buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_read: sys_malloc for io_buf failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>all_blocks <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">sys_malloc</span><span class="token punctuation">(</span>BLOCK_SIZE <span class="token operator">+</span> <span class="token number">48</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用来记录文件所有的块地址</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file_read: sys_malloc for all_blocks failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">uint32_t</span> block_read_start_idx <span class="token operator">=</span> file<span class="token operator">-></span>fd_pos <span class="token operator">/</span> BLOCK_SIZE<span class="token punctuation">;</span>        <span class="token comment">// 数据所在块的起始地址</span>    <span class="token class-name">uint32_t</span> block_read_end_idx <span class="token operator">=</span> <span class="token punctuation">(</span>file<span class="token operator">-></span>fd_pos <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token operator">/</span> BLOCK_SIZE<span class="token punctuation">;</span> <span class="token comment">// 数据所在块的终止地址</span>    <span class="token class-name">uint32_t</span> read_blocks <span class="token operator">=</span> block_read_start_idx <span class="token operator">-</span> block_read_end_idx<span class="token punctuation">;</span> <span class="token comment">// 如增量为0,表示数据在同一扇区</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>block_read_start_idx <span class="token operator">&lt;</span> <span class="token number">139</span> <span class="token operator">&amp;&amp;</span> block_read_end_idx <span class="token operator">&lt;</span> <span class="token number">139</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> indirect_block_table<span class="token punctuation">;</span> <span class="token comment">// 用来获取一级间接表地址</span>    <span class="token class-name">uint32_t</span> block_idx<span class="token punctuation">;</span>           <span class="token comment">// 获取待读的块地址</span>    <span class="token comment">/* 以下开始构建all_blocks块地址数组,专门存储用到的块地址(本程序中块大小同扇区大小) */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>read_blocks <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 在同一扇区内读数据,不涉及到跨扇区读取</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>block_read_end_idx <span class="token operator">==</span> block_read_start_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block_read_end_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 待读的数据在12个直接块之内</span>            block_idx <span class="token operator">=</span> block_read_end_idx<span class="token punctuation">;</span>            all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若用到了一级间接块表,需要将表中间接块读进来</span>            indirect_block_table <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> indirect_block_table<span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>   <span class="token comment">// 若要读多个块</span>        <span class="token comment">/* 第一种情况: 起始块和终止块属于直接块*/</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>block_read_end_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 数据结束所在的块属于直接块</span>            block_idx <span class="token operator">=</span> block_read_start_idx<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;=</span> block_read_end_idx<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>                block_idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>block_read_start_idx <span class="token operator">&lt;</span> <span class="token number">12</span> <span class="token operator">&amp;&amp;</span> block_read_end_idx <span class="token operator">>=</span> <span class="token number">12</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 第二种情况: 待读入的数据跨越直接块和间接块两类*/</span>            <span class="token comment">/* 先将直接块地址写入all_blocks */</span>            block_idx <span class="token operator">=</span> block_read_start_idx<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>                block_idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">ASSERT</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保已经分配了一级间接块表</span>            <span class="token comment">/* 再将间接块地址写入all_blocks */</span>            indirect_block_table <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> indirect_block_table<span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将一级间接块表读进来写入到第13个块的位置之后</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 第三种情况: 数据在间接块中*/</span>            <span class="token function">ASSERT</span><span class="token punctuation">(</span>file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 确保已经分配了一级间接块表</span>            indirect_block_table <span class="token operator">=</span> file<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token comment">// 获取一级间接表地址</span>            <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> indirect_block_table<span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将一级间接块表读进来写入到第13个块的位置之后</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 用到的块地址已经收集到all_blocks中,下面开始读数据 */</span>    <span class="token class-name">uint32_t</span> sec_idx<span class="token punctuation">,</span> sec_lba<span class="token punctuation">,</span> sec_off_bytes<span class="token punctuation">,</span> sec_left_bytes<span class="token punctuation">,</span> chunk_size<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> bytes_read <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>bytes_read <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 直到读完为止</span>        sec_idx <span class="token operator">=</span> file<span class="token operator">-></span>fd_pos <span class="token operator">/</span> BLOCK_SIZE<span class="token punctuation">;</span>        sec_lba <span class="token operator">=</span> all_blocks<span class="token punctuation">[</span>sec_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        sec_off_bytes <span class="token operator">=</span> file<span class="token operator">-></span>fd_pos <span class="token operator">%</span> BLOCK_SIZE<span class="token punctuation">;</span>        sec_left_bytes <span class="token operator">=</span> BLOCK_SIZE <span class="token operator">-</span> sec_off_bytes<span class="token punctuation">;</span>        chunk_size <span class="token operator">=</span> size_left <span class="token operator">&lt;</span> sec_left_bytes <span class="token operator">?</span> size_left <span class="token operator">:</span> sec_left_bytes<span class="token punctuation">;</span> <span class="token comment">// 待读入的数据大小</span>        <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> BLOCK_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> sec_lba<span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>buf_dst<span class="token punctuation">,</span> io_buf <span class="token operator">+</span> sec_off_bytes<span class="token punctuation">,</span> chunk_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        buf_dst <span class="token operator">+=</span> chunk_size<span class="token punctuation">;</span>        file<span class="token operator">-></span>fd_pos <span class="token operator">+=</span> chunk_size<span class="token punctuation">;</span>        bytes_read <span class="token operator">+=</span> chunk_size<span class="token punctuation">;</span>        size_left <span class="token operator">-=</span> chunk_size<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>all_blocks<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> bytes_read<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/file.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">file_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>sys_read</code>根据传入的文件描述符，调用<code>fd_local2global</code>将文件描述符转换成指定的全局打开文件结构数组索引，然后调用<code>file_read</code>读出count字节放入<code>buf</code>中</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 从文件描述符fd指向的文件中读取count个字节到buf,若成功则返回读出的字节数,到文件尾则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_read</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_read: fd error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>buf <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> _fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">file_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>_fd<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_read</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码，（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token class-name">uint32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/file1"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open /file1, fd:%d\n"</span><span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> read_bytes <span class="token operator">=</span> <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1_ read %d bytes:\n%s\n"</span><span class="token punctuation">,</span> read_bytes<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   read_bytes <span class="token operator">=</span> <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2_ read %d bytes:\n%s"</span><span class="token punctuation">,</span> read_bytes<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   read_bytes <span class="token operator">=</span> <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3_ read %d bytes:\n%s"</span><span class="token punctuation">,</span> read_bytes<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"________  close file1 and reopen  ________\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/file1"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   read_bytes <span class="token operator">=</span> <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"4_ read %d bytes:\n%s"</span><span class="token punctuation">,</span> read_bytes<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节g：</p><p><code>sys_lseek</code>用于根据传入的参照物与偏移，重置传入的文件描述符对应的全局打开文件结构中的<code>fd_pos</code>。核心原理：根据传入的文件描述符，调用<code>fd_local2global</code>将文件描述符转换成指定的全局打开文件结构数组索引，然后switch case对传入的参照物情况进行选择，以对<code>fd_pos</code>做不同处理。参照物为<code>SEET_SET</code>，那么新的<code>fd_pos</code>就等于传入的偏移；参照物为<code>SEET_CUR</code>，那么新的<code>fd_pos</code> = 原来<code>fd_pos</code> + 传入偏移；参照物为<code>SEET_END</code>，那么新的<code>fd_pos</code>为原来文件大小 + 偏移（此时偏移量不出意外的话是负数）</p><p>定义参照位置，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 文件读写位置偏移量 */</span><span class="token keyword">enum</span> <span class="token class-name">whence</span><span class="token punctuation">&#123;</span>    <span class="token constant">SEEK_SET</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token constant">SEEK_CUR</span><span class="token punctuation">,</span>    <span class="token constant">SEEK_END</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数<code>sys_lseek</code>，修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 重置用于文件读写操作的偏移指针,成功时返回新的偏移量,出错时返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_lseek</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> offset<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> whence<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_lseek: fd error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>whence <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> whence <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> _fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>pf <span class="token operator">=</span> <span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>_fd<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> new_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 新的偏移量必须位于文件大小之内</span>    <span class="token class-name">int32_t</span> file_size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span>pf<span class="token operator">-></span>fd_inode<span class="token operator">-></span>i_size<span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>whence<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token comment">/* SEEK_SET 新的读写位置是相对于文件开头再增加offset个位移量 */</span>    <span class="token keyword">case</span> <span class="token constant">SEEK_SET</span><span class="token operator">:</span>        new_pos <span class="token operator">=</span> offset<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token comment">/* SEEK_CUR 新的读写位置是相对于当前的位置增加offset个位移量 */</span>    <span class="token keyword">case</span> <span class="token constant">SEEK_CUR</span><span class="token operator">:</span> <span class="token comment">// offse可正可负</span>        new_pos <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span>pf<span class="token operator">-></span>fd_pos <span class="token operator">+</span> offset<span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token comment">/* SEEK_END 新的读写位置是相对于文件尺寸再增加offset个位移量 */</span>    <span class="token keyword">case</span> <span class="token constant">SEEK_END</span><span class="token operator">:</span> <span class="token comment">// 此情况下,offset应该为负值</span>        new_pos <span class="token operator">=</span> file_size <span class="token operator">+</span> offset<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_pos <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> new_pos <span class="token operator">></span> <span class="token punctuation">(</span>file_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    pf<span class="token operator">-></span>fd_pos <span class="token operator">=</span> new_pos<span class="token punctuation">;</span>    <span class="token keyword">return</span> pf<span class="token operator">-></span>fd_pos<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_lseek</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> offset<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/file1"</span><span class="token punctuation">,</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"open /file1, fd:%d\n"</span><span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> read_bytes <span class="token operator">=</span> <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1_ read %d bytes:\n%s\n"</span><span class="token punctuation">,</span> read_bytes<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    read_bytes <span class="token operator">=</span> <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2_ read %d bytes:\n%s"</span><span class="token punctuation">,</span> read_bytes<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    read_bytes <span class="token operator">=</span> <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"3_ read %d bytes:\n%s"</span><span class="token punctuation">,</span> read_bytes<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"________  SEEK_SET 0  ________\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    read_bytes <span class="token operator">=</span> <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"4_ read %d bytes:\n%s"</span><span class="token punctuation">,</span> read_bytes<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节h：</p><p>我们接下来实现文件删除功能，其过程是创建文件的逆过程。涉及inode与目录项。</p><p>首先是实现删除inode：</p><p><code>inode_delete</code>，传入要删除的inode在inode数组中的索引，然后删除磁盘中的这个inode。这个函数可有可无，因为inode分配是依靠inode位图来完成的，我们回收一个inode，只需要回收一个inode位图中的位即可。因为下次分配这个inode位之后，新的inode数据会覆盖旧有inode数据，这样还能避免不必要的磁盘读写。函数原理：调用<code>inode_locate</code>可以将inode数组索引转换为这个inode在磁盘中的起始扇区和字节偏移。我们将这个inode所在整体扇区读出内存缓冲区中，然后将这个内存缓冲区中的inode清除，再将内存缓冲区中的数据写回磁盘中即可。</p><p>修改（<strong>fs/inode.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将硬盘分区part上的inode清空 */</span><span class="token keyword">void</span> <span class="token function">inode_delete</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>inode_no <span class="token operator">&lt;</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode_position</span> inode_pos<span class="token punctuation">;</span>    <span class="token function">inode_locate</span><span class="token punctuation">(</span>part<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> <span class="token operator">&amp;</span>inode_pos<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inode位置信息会存入inode_pos</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>inode_pos<span class="token punctuation">.</span>sec_lba <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>part<span class="token operator">-></span>start_lba <span class="token operator">+</span> part<span class="token operator">-></span>sec_cnt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>inode_buf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>io_buf<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_pos<span class="token punctuation">.</span>two_sec<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// inode跨扇区,读入2个扇区</span>        <span class="token comment">/* 将原硬盘上的内容先读出来 */</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 将inode_buf清0 */</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span>inode_buf <span class="token operator">+</span> inode_pos<span class="token punctuation">.</span>off_size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 用清0的内存数据覆盖磁盘 */</span>        <span class="token function">ide_write</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 未跨扇区,只读入1个扇区就好</span>        <span class="token comment">/* 将原硬盘上的内容先读出来 */</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 将inode_buf清0 */</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token punctuation">(</span>inode_buf <span class="token operator">+</span> inode_pos<span class="token punctuation">.</span>off_size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 用清0的内存数据覆盖磁盘 */</span>        <span class="token function">ide_write</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_pos<span class="token punctuation">.</span>sec_lba<span class="token punctuation">,</span> inode_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>inode_release</code>删除文件，包含：删除磁盘中的inode，并回收文件占用的块。这个过程包含：1、回收文件所占用的所有块，通过inode中的i_sectors[ ]即可知道占用了哪些块，然后去清除对应的块位图中的位即可，也就是并没有真正删除文件数据；2、回收inode，首先清除该inode在inode位图中对应的位，然后调用<code>inode_delete</code>删除在磁盘中的这个inode</p><p>修改（<strong>fs/inode.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"file.h"</span></span><span class="token comment">/* 回收inode的数据块和inode本身 */</span><span class="token keyword">void</span> <span class="token function">inode_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>inode_to_del <span class="token operator">=</span> <span class="token function">inode_open</span><span class="token punctuation">(</span>part<span class="token punctuation">,</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>inode_to_del<span class="token operator">-></span>i_no <span class="token operator">==</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 1 回收inode占用的所有块 */</span>    <span class="token class-name">uint8_t</span> block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> block_cnt <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> block_bitmap_idx<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> all_blocks<span class="token punctuation">[</span><span class="token number">140</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 12个直接块+128个间接块</span>    <span class="token comment">/* a 先将前12个直接块存入all_blocks */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> inode_to_del<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* b 如果一级间接块表存在,将其128个间接块读到all_blocks[12~], 并释放一级间接块表所占的扇区 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_to_del<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> inode_to_del<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        block_cnt <span class="token operator">=</span> <span class="token number">140</span><span class="token punctuation">;</span>        <span class="token comment">/* 回收一级间接块表占用的扇区 */</span>        block_bitmap_idx <span class="token operator">=</span> inode_to_del<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">-</span> part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>block_bitmap_idx <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>part<span class="token operator">-></span>block_bitmap<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* c inode所有的块地址已经收集到all_blocks中,下面逐个回收 */</span>    block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> block_cnt<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            block_bitmap_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            block_bitmap_idx <span class="token operator">=</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">-</span> part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>            <span class="token function">ASSERT</span><span class="token punctuation">(</span>block_bitmap_idx <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>part<span class="token operator">-></span>block_bitmap<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/*2 回收该inode所占用的inode */</span>    <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>part<span class="token operator">-></span>inode_bitmap<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> INODE_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/******     以下inode_delete是调试用的    ******     * 此函数会在inode_table中将此inode清0,     * 但实际上是不需要的,inode分配是由inode位图控制的,     * 硬盘上的数据不需要清0,可以直接覆盖*/</span>    <span class="token keyword">void</span> <span class="token operator">*</span>io_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inode_delete</span><span class="token punctuation">(</span>part<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/***********************************************/</span>    <span class="token function">inode_close</span><span class="token punctuation">(</span>inode_to_del<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/inode.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">inode_delete</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">inode_release</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来是删除一个目录项：</p><p><code>delete_dir_entry</code>删除指定文件对应在磁盘中的目录项。核心原理：传入的要删除文件的父目录结构体struct dir指针内有inode成员，这个inode内有i_sectors[ ]记录着这个目录文件的存储位置，我们自然可以以块为单位从磁盘中把父目录文件读取到缓冲区中，然后遍历找到要删除的目录项，删除缓冲区内对应的目录项，然后写回缓冲区数据。</p><p>在这个过程中：如果发现该目录项所在块（非.所在块）仅有要删除的这一个目录项，那么就采取回收这个块（删除块位图中的位，然后同步块位图）的方式清除目录项。回收这个块时，还要判断这个块是不是一级间接块当中的唯一一个的那个块，如果是，则还需要回收这个一级间接块。</p><p>修改（<strong>fs/dir.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 把分区part目录pdir中编号为inode_no的目录项删除 */</span>bool <span class="token function">delete_dir_entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>pdir<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>dir_inode <span class="token operator">=</span> pdir<span class="token operator">-></span>inode<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> all_blocks<span class="token punctuation">[</span><span class="token number">140</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">/* 收集目录全部块地址 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 目录项在存储时保证不会跨扇区 */</span>    <span class="token class-name">uint32_t</span> dir_entry_size <span class="token operator">=</span> part<span class="token operator">-></span>sb<span class="token operator">-></span>dir_entry_size<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> dir_entrys_per_sec <span class="token operator">=</span> <span class="token punctuation">(</span>SECTOR_SIZE <span class="token operator">/</span> dir_entry_size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每扇区最大的目录项数目</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span>io_buf<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_entry_found <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> dir_entry_idx<span class="token punctuation">,</span> dir_entry_cnt<span class="token punctuation">;</span>    bool is_dir_first_block <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment">// 目录的第1个块</span>    <span class="token comment">/* 遍历所有块,寻找目录项 */</span>    block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">140</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        is_dir_first_block <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            block_idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        dir_entry_idx <span class="token operator">=</span> dir_entry_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 读取扇区,获得目录项 */</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 遍历所有的目录项,统计该扇区的目录项数量及是否有待删除的目录项 */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>dir_entry_idx <span class="token operator">&lt;</span> dir_entrys_per_sec<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">)</span><span class="token operator">-></span>f_type <span class="token operator">!=</span> FT_UNKNOWN<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">)</span><span class="token operator">-></span>filename<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    is_dir_first_block <span class="token operator">=</span> true<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">)</span><span class="token operator">-></span>filename<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                         <span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">)</span><span class="token operator">-></span>filename<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    dir_entry_cnt<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 统计此扇区内的目录项个数,用来判断删除目录项后是否回收该扇区</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">)</span><span class="token operator">-></span>i_no <span class="token operator">==</span> inode_no<span class="token punctuation">)</span>                    <span class="token punctuation">&#123;</span>                                    <span class="token comment">// 如果找到此i结点,就将其记录在dir_entry_found</span>                        <span class="token function">ASSERT</span><span class="token punctuation">(</span>dir_entry_found <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 确保目录中只有一个编号为inode_no的inode,找到一次后dir_entry_found就不再是NULL</span>                        dir_entry_found <span class="token operator">=</span> dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">;</span>                        <span class="token comment">/* 找到后也继续遍历,统计总共的目录项数 */</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            dir_entry_idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 若此扇区未找到该目录项,继续在下个扇区中找 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dir_entry_found <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            block_idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 在此扇区中找到目录项后,清除该目录项并判断是否回收扇区,随后退出循环直接返回 */</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>dir_entry_cnt <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 除目录第1个扇区外,若该扇区上只有该目录项自己,则将整个扇区回收 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dir_entry_cnt <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>is_dir_first_block<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* a 在块位图中回收该块 */</span>            <span class="token class-name">uint32_t</span> block_bitmap_idx <span class="token operator">=</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">-</span> part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>            <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>part<span class="token operator">-></span>block_bitmap<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* b 将块地址从数组i_sectors或索引表中去掉 */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 在一级间接索引表中擦除该间接块地址</span>                <span class="token comment">/*先判断一级间接索引表中间接块的数量,如果仅有这1个间接块,连同间接索引表所在的块一同回收 */</span>                <span class="token class-name">uint32_t</span> indirect_blocks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token class-name">uint32_t</span> indirect_block_idx <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>indirect_block_idx <span class="token operator">&lt;</span> <span class="token number">140</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks<span class="token punctuation">[</span>indirect_block_idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token punctuation">&#123;</span>                        indirect_blocks<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">ASSERT</span><span class="token punctuation">(</span>indirect_blocks <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 包括当前间接块</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>indirect_blocks <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span> <span class="token comment">// 间接索引表中还包括其它间接块,仅在索引表中擦除当前这个间接块地址</span>                    all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token function">ide_write</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span>                <span class="token punctuation">&#123;</span> <span class="token comment">// 间接索引表中就当前这1个间接块,直接把间接索引表所在的块回收,然后擦除间接索引表块地址</span>                    <span class="token comment">/* 回收间接索引表所在的块 */</span>                    block_bitmap_idx <span class="token operator">=</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">-</span> part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>                    <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>part<span class="token operator">-></span>block_bitmap<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* 将间接索引表地址清0 */</span>                    dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 仅将该目录项清空</span>            <span class="token function">memset</span><span class="token punctuation">(</span>dir_entry_found<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> dir_entry_size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">ide_write</span><span class="token punctuation">(</span>part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 更新i结点信息并同步到硬盘 */</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>dir_inode<span class="token operator">-></span>i_size <span class="token operator">>=</span> dir_entry_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        dir_inode<span class="token operator">-></span>i_size <span class="token operator">-=</span> dir_entry_size<span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inode_sync</span><span class="token punctuation">(</span>part<span class="token punctuation">,</span> dir_inode<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 所有块中未找到则返回false,若出现这种情况应该是serarch_file出错了 */</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/dir.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">delete_dir_entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">partition</span> <span class="token operator">*</span>part<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>pdir<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> inode_no<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>sys_unlink</code>用于根据传入路径，删除非目录文件。原理：首先调用<code>search_file</code>搜索路径以返回文件的inode，判断该inode是否对应某个打开全局文件结构，如果是，则说明此文件正在被使用，那么就不应该被删除。如果不是，调用<code>delete_dir_entry</code>删除这个文件在磁盘中的目录项，调用<code>inode_release</code>删除inode对应的文件，这就完成了删除。</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 删除文件(非目录),成功返回0,失败返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>pathname<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 先检查待删除的文件是否存在 */</span>    <span class="token keyword">struct</span> <span class="token class-name">path_search_record</span> searched_record<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>searched_record<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path_search_record</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> inode_no <span class="token operator">=</span> <span class="token function">search_file</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>searched_record<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>inode_no <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file %s not found!\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>file_type <span class="token operator">==</span> FT_DIRECTORY<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"can`t delete a direcotry with unlink(), use rmdir() to instead\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 检查是否在已打开文件列表(文件表)中 */</span>    <span class="token class-name">uint32_t</span> file_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>file_idx <span class="token operator">&lt;</span> MAX_FILE_OPEN<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>file_table<span class="token punctuation">[</span>file_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>inode_no <span class="token operator">==</span> file_table<span class="token punctuation">[</span>file_idx<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token operator">-></span>i_no<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        file_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file_idx <span class="token operator">&lt;</span> MAX_FILE_OPEN<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file %s is in use, not allow to delete!\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>file_idx <span class="token operator">==</span> MAX_FILE_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 为delete_dir_entry申请缓冲区 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>io_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>SECTOR_SIZE <span class="token operator">+</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>io_buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_unlink: malloc for io_buf failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir <span class="token operator">=</span> searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">;</span>    <span class="token function">delete_dir_entry</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> parent_dir<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inode_release</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 成功删除文件</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/file1 delete %s!\n"</span><span class="token punctuation">,</span> <span class="token function">sys_unlink</span><span class="token punctuation">(</span><span class="token string">"/file1"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"done"</span> <span class="token operator">:</span> <span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了方便调试，我们修改（<strong>fs/fs.c/mount_partition</strong>），调试完毕需删除增加的代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mount %s done!\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 此处返回true是为了迎合主调函数list_traversal的实现,与函数本身功能无关。    只有返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历.*/</span><span class="token function">sys_free</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"mount %s done!\n"</span><span class="token punctuation">,</span> part<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sdb1's block_bitmap_lba: %x\n"</span><span class="token punctuation">,</span> sb_buf<span class="token operator">-></span>block_bitmap_lba<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sdb1's inode_bitmap_lba: %x\n"</span><span class="token punctuation">,</span> sb_buf<span class="token operator">-></span>inode_bitmap_lba<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sdb1's inode_table_lba: %x\n"</span><span class="token punctuation">,</span> sb_buf<span class="token operator">-></span>inode_table_lba<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sdb1's data_start_lba: %x\n"</span><span class="token punctuation">,</span> sb_buf<span class="token operator">-></span>data_start_lba<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 此处返回true是为了迎合主调函数list_traversal的实现,与函数本身功能无关。    只有返回true时list_traversal才会停止遍历,减少了后面元素无意义的遍历.*/</span><span class="token function">sys_free</span><span class="token punctuation">(</span>sb_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节i：</p><p>创建目录文件涉及的工作，其实就是涉及到了inode与目录项</p><ol><li>确认待创建的新目录在文件系统上不存在。</li><li>为新目录创建inode。</li><li>为新目录分配1个块存储该目录文件中的目录项。</li><li>在新目录中创建两个目录项“…”和“.”，这是每个目录都必须存在的两个目录项。</li><li>在新目录的父目录中添加新目录的目录项。</li><li>将以上资源的变更同步到磁盘。</li></ol><p><code>sys_mkdir</code>用于根据传入的路径创建目录文件。核心原理：1、调用<code>search_file</code>来确认待创建的新目录文件在文件系统上不存在；2、调用inode_bitmap_alloc来为新目录分配inode索引，并调用inode_init来初始化这个inode；3、调用block_bitmap_alloc来分配一个块用于承载该目录的目录文件。同时设定inode的i_sectors[0]，并调用bitmap_sync同步块位图；4、清零缓冲区，然后写入.与…两个目录项，之后将缓冲区内容写入到目录文件中，这就完成了.与…两个目录项的创建；5、创建并设定自己的目录项，调用sync_dir_entry来将目录项同步到父目录中；6、inode_sync同步父目录的inode与自己的inode，bitmap_sync同步inode位图</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 创建目录pathname,成功返回0,失败返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_mkdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> rollback_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用于操作失败时回滚各资源状态</span>    <span class="token keyword">void</span> <span class="token operator">*</span>io_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>SECTOR_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>io_buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_mkdir: sys_malloc for io_buf failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">path_search_record</span> searched_record<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>searched_record<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path_search_record</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> inode_no <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    inode_no <span class="token operator">=</span> <span class="token function">search_file</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>searched_record<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 如果找到了同名目录或文件,失败返回</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_mkdir: file or directory %s exist!\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        rollback_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> rollback<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若未找到,也要判断是在最终目录没找到还是某个中间目录不存在</span>        <span class="token class-name">uint32_t</span> pathname_depth <span class="token operator">=</span> <span class="token function">path_depth_cnt</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">uint32_t</span> path_searched_depth <span class="token operator">=</span> <span class="token function">path_depth_cnt</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>searched_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 先判断是否把pathname的各层目录都访问到了,即是否在某个中间目录就失败了 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pathname_depth <span class="token operator">!=</span> path_searched_depth<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 说明并没有访问到全部的路径,某个中间目录是不存在的</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_mkdir: can`t access %s, subpath %s is`t exist\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">,</span> searched_record<span class="token punctuation">.</span>searched_path<span class="token punctuation">)</span><span class="token punctuation">;</span>            rollback_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> rollback<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir <span class="token operator">=</span> searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">;</span>    <span class="token comment">/* 目录名称后可能会有字符'/',所以最好直接用searched_record.searched_path,无'/' */</span>    <span class="token keyword">char</span> <span class="token operator">*</span>dirname <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>searched_path<span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    inode_no <span class="token operator">=</span> <span class="token function">inode_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_mkdir: allocate inode failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rollback_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> rollback<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> new_dir_inode<span class="token punctuation">;</span>    <span class="token function">inode_init</span><span class="token punctuation">(</span>inode_no<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_dir_inode<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化i结点</span>    <span class="token class-name">uint32_t</span> block_bitmap_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用来记录block对应于block_bitmap中的索引</span>    <span class="token class-name">int32_t</span> block_lba <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/* 为目录分配一个块,用来写入目录.和.. */</span>    block_lba <span class="token operator">=</span> <span class="token function">block_bitmap_alloc</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>block_lba <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_mkdir: block_bitmap_alloc for create directory failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rollback_step <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> rollback<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    new_dir_inode<span class="token punctuation">.</span>i_sectors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> block_lba<span class="token punctuation">;</span>    <span class="token comment">/* 每分配一个块就将位图同步到硬盘 */</span>    block_bitmap_idx <span class="token operator">=</span> block_lba <span class="token operator">-</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>block_bitmap_idx <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> block_bitmap_idx<span class="token punctuation">,</span> BLOCK_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 将当前目录的目录项'.'和'..'写入目录 */</span>    <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空io_buf</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>p_de <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span>io_buf<span class="token punctuation">;</span>    <span class="token comment">/* 初始化当前目录"." */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>p_de<span class="token operator">-></span>filename<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p_de<span class="token operator">-></span>i_no <span class="token operator">=</span> inode_no<span class="token punctuation">;</span>    p_de<span class="token operator">-></span>f_type <span class="token operator">=</span> FT_DIRECTORY<span class="token punctuation">;</span>    p_de<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment">/* 初始化当前目录".." */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>p_de<span class="token operator">-></span>filename<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p_de<span class="token operator">-></span>i_no <span class="token operator">=</span> parent_dir<span class="token operator">-></span>inode<span class="token operator">-></span>i_no<span class="token punctuation">;</span>    p_de<span class="token operator">-></span>f_type <span class="token operator">=</span> FT_DIRECTORY<span class="token punctuation">;</span>    <span class="token function">ide_write</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> new_dir_inode<span class="token punctuation">.</span>i_sectors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    new_dir_inode<span class="token punctuation">.</span>i_size <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>dir_entry_size<span class="token punctuation">;</span>    <span class="token comment">/* 在父目录中添加自己的目录项 */</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> new_dir_entry<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>new_dir_entry<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">create_dir_entry</span><span class="token punctuation">(</span>dirname<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> FT_DIRECTORY<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_dir_entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空io_buf</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sync_dir_entry</span><span class="token punctuation">(</span>parent_dir<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_dir_entry<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// sync_dir_entry中将block_bitmap通过bitmap_sync同步到硬盘</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_mkdir: sync_dir_entry to disk failed!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rollback_step <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> rollback<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 父目录的inode同步到硬盘 */</span>    <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inode_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> parent_dir<span class="token operator">-></span>inode<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 将新创建目录的inode同步到硬盘 */</span>    <span class="token function">memset</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inode_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> <span class="token operator">&amp;</span>new_dir_inode<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 将inode位图同步到硬盘 */</span>    <span class="token function">bitmap_sync</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> INODE_BITMAP<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 关闭所创建目录的父目录 */</span>    <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">/*创建文件或目录需要创建相关的多个资源,若某步失败则会执行到下面的回滚步骤 */</span>rollback<span class="token operator">:</span> <span class="token comment">// 因为某步骤操作失败而回滚</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>rollback_step<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur_part<span class="token operator">-></span>inode_bitmap<span class="token punctuation">,</span> inode_no<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果新文件的inode创建失败,之前位图中分配的inode_no也要恢复</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>        <span class="token comment">/* 关闭所创建目录的父目录 */</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_mkdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 create %s!\n"</span><span class="token punctuation">,</span> <span class="token function">sys_mkdir</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"done"</span> <span class="token operator">:</span> <span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1 create %s!\n"</span><span class="token punctuation">,</span> <span class="token function">sys_mkdir</span><span class="token punctuation">(</span><span class="token string">"/dir1"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"done"</span> <span class="token operator">:</span> <span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"now, /dir1/subdir1 create %s!\n"</span><span class="token punctuation">,</span> <span class="token function">sys_mkdir</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">"done"</span> <span class="token operator">:</span> <span class="token string">"fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1/file2"</span><span class="token punctuation">,</span> O_CREAT<span class="token operator">|</span>O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1/file2 create done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token string">"Catch me if you can!\n"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>      <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1/file2 says:\n%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sys_close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节j：</p><p><code>sys_opendir</code>用于根据传入的路径打开目录。原理：调用<code>search_file</code>将路径转换为inode索引，然后调用<code>dir_open</code>创建目录结构并将对应的inode载入内存</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 目录打开成功后返回目录指针,失败返回NULL */</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span><span class="token function">sys_opendir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 如果是根目录'/',直接返回&amp;root_dir */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">&amp;</span>root_dir<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 先检查待打开的目录是否存在 */</span>    <span class="token keyword">struct</span> <span class="token class-name">path_search_record</span> searched_record<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>searched_record<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path_search_record</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> inode_no <span class="token operator">=</span> <span class="token function">search_file</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>searched_record<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>ret <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 如果找不到目录,提示不存在的路径</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"In %s, sub path %s not exist\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> searched_record<span class="token punctuation">.</span>searched_path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>file_type <span class="token operator">==</span> FT_REGULAR<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s is regular file!\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>file_type <span class="token operator">==</span> FT_DIRECTORY<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ret <span class="token operator">=</span> <span class="token function">dir_open</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_closedir</code>就是<code>dir_close</code>的封装</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 成功关闭目录dir返回0,失败返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_closedir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">dir_close</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token number">1234567891011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span><span class="token function">sys_opendir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">sys_closedir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>p_dir <span class="token operator">=</span> <span class="token function">sys_opendir</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p_dir<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 open done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_closedir</span><span class="token punctuation">(</span>p_dir<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 close done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 close fail!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 open fail!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节k：</p><p><code>dir_read</code>用于根据传入的目录指针，一次返回一个该目录下的目录项，比如该目录文件下目录项分布：a，空，b，空，c，第一次调用返回a，第二次调用返回b，第三次调用返回c…原理：目录内有个指向自己inode的指针，该inode内有i_sectors[ ]，所以能在磁盘中找到该目录文件，将其读出到缓冲区然后按需设定遍历规则即可。</p><p>代码中<code>dir_pos</code>实际含义是已经返回过的目录项总大小，<code>cur_dir_entry_pos</code>的含义是此次调用遍历过程中，扫描过的非空目录项总大小。当扫描到的非空目录项时，此时若<code>cur_dir_entry_pos</code>与<code>dir_pos</code>相等，自然就可以判断出这个非空目录项应该返回。</p><p>修改（<strong>fs/dir.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 读取目录,成功返回1个目录项,失败返回NULL */</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token function">dir_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span>dir<span class="token operator">-></span>dir_buf<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>dir_inode <span class="token operator">=</span> dir<span class="token operator">-></span>inode<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> all_blocks<span class="token punctuation">[</span><span class="token number">140</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> block_cnt <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> dir_entry_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若含有一级间接块表</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        block_cnt <span class="token operator">=</span> <span class="token number">140</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> cur_dir_entry_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前目录项的偏移,此项用来判断是否是之前已经返回过的目录项</span>    <span class="token class-name">uint32_t</span> dir_entry_size <span class="token operator">=</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>dir_entry_size<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> dir_entrys_per_sec <span class="token operator">=</span> SECTOR_SIZE <span class="token operator">/</span> dir_entry_size<span class="token punctuation">;</span> <span class="token comment">// 1扇区内可容纳的目录项个数</span>    <span class="token comment">/* 因为此目录内可能删除了某些文件或子目录,所以要遍历所有块 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> block_cnt<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token operator">-></span>dir_pos <span class="token operator">>=</span> dir_inode<span class="token operator">-></span>i_size<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 如果此块地址为0,即空块,继续读出下一块</span>            block_idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dir_e<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> dir_e<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dir_entry_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/* 遍历扇区内所有目录项 */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>dir_entry_idx <span class="token operator">&lt;</span> dir_entrys_per_sec<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">)</span><span class="token operator">-></span>f_type<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 如果f_type不等于0,即不等于FT_UNKNOWN</span>                <span class="token comment">/* 判断是不是最新的目录项,避免返回曾经已经返回过的目录项 */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_dir_entry_pos <span class="token operator">&lt;</span> dir<span class="token operator">-></span>dir_pos<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    cur_dir_entry_pos <span class="token operator">+=</span> dir_entry_size<span class="token punctuation">;</span>                    dir_entry_idx<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">ASSERT</span><span class="token punctuation">(</span>cur_dir_entry_pos <span class="token operator">==</span> dir<span class="token operator">-></span>dir_pos<span class="token punctuation">)</span><span class="token punctuation">;</span>                dir<span class="token operator">-></span>dir_pos <span class="token operator">+=</span> dir_entry_size<span class="token punctuation">;</span> <span class="token comment">// 更新为新位置,即下一个返回的目录项地址</span>                <span class="token keyword">return</span> dir_e <span class="token operator">+</span> dir_entry_idx<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            dir_entry_idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/dir.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token function">dir_read</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>sys_readdir</code>，就是<code>dir_read</code>的封装</p><p><code>sys_rewinddir</code>将目录的dir_pos置为0</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 读取目录dir的1个目录项,成功后返回其目录项地址,到目录尾时或出错时返回NULL */</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token function">sys_readdir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>dir <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">dir_read</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 把目录dir的指针dir_pos置0 */</span><span class="token keyword">void</span> <span class="token function">sys_rewinddir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    dir<span class="token operator">-></span>dir_pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token function">sys_readdir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">sys_rewinddir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>测试代码，（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"dir.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/********  测试代码  ********/</span>    <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>p_dir <span class="token operator">=</span> <span class="token function">sys_opendir</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p_dir<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 open done!\ncontent:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>type <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">=</span> <span class="token function">sys_readdir</span><span class="token punctuation">(</span>p_dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dir_e<span class="token operator">-></span>f_type <span class="token operator">==</span> FT_REGULAR<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                type <span class="token operator">=</span> <span class="token string">"regular"</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                type <span class="token operator">=</span> <span class="token string">"directory"</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"      %s   %s\n"</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> dir_e<span class="token operator">-></span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_closedir</span><span class="token punctuation">(</span>p_dir<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 close done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 close fail!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 open fail!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/********  测试代码  ********/</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节l：</p><p><code>dir_is_empty</code>判断目录是否为空。原理：为空的目录对应的目录文件中只有两个目录项，分别是.和…。所以，我们直接判断目录对应的inode中的i_size是否等于两个目录项大小即可</p><p><code>dir_remove</code>传入父目录与子目录指针，在指定父目录中删除子目录。原理：判断子目录为空，然后调用<code>delete_dir_entry</code>删除父目录的目录文件中的子目录目录项，最后调用<code>inode_release</code>删除子目录的目录文件（子目录目录文件中只应该有.与…）</p><p>修改（<strong>myso/fs/dir.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 判断目录是否为空 */</span>bool <span class="token function">dir_is_empty</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>dir_inode <span class="token operator">=</span> dir<span class="token operator">-></span>inode<span class="token punctuation">;</span>    <span class="token comment">/* 若目录下只有.和..这两个目录项则目录为空 */</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>dir_inode<span class="token operator">-></span>i_size <span class="token operator">==</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>dir_entry_size <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 在父目录parent_dir中删除child_dir */</span><span class="token class-name">int32_t</span> <span class="token function">dir_remove</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>child_dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>child_dir_inode <span class="token operator">=</span> child_dir<span class="token operator">-></span>inode<span class="token punctuation">;</span>    <span class="token comment">/* 空目录只在inode->i_sectors[0]中有扇区,其它扇区都应该为空 */</span>    <span class="token class-name">int32_t</span> block_idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">13</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>child_dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>io_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>SECTOR_SIZE <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>io_buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"dir_remove: malloc for io_buf failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 在父目录parent_dir中删除子目录child_dir对应的目录项 */</span>    <span class="token function">delete_dir_entry</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> parent_dir<span class="token punctuation">,</span> child_dir_inode<span class="token operator">-></span>i_no<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 回收inode中i_secotrs中所占用的扇区,并同步inode_bitmap和block_bitmap */</span>    <span class="token function">inode_release</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> child_dir_inode<span class="token operator">-></span>i_no<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/dir.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">bool <span class="token function">dir_is_empty</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">dir_remove</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>parent_dir<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>child_dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>sys_rmdir</code>用于根据传入路径删除空目录。原理：先调用<code>search_file</code>查找这个路径对应目录的inode，如果存在且该inode对应的确实是个目录文件，然后调用<code>dir_open</code>将该inode调入内存并创建对应的struct dir，调用<code>dir_is_empty</code>判断该目录为空，最后调用<code>dir_remove</code>删除该目录。</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 删除空目录,成功时返回0,失败时返回-1*/</span><span class="token class-name">int32_t</span> <span class="token function">sys_rmdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 先检查待删除的文件是否存在 */</span>    <span class="token keyword">struct</span> <span class="token class-name">path_search_record</span> searched_record<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>searched_record<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path_search_record</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> inode_no <span class="token operator">=</span> <span class="token function">search_file</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>searched_record<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>inode_no <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> retval <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 默认返回值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"In %s, sub path %s not exist\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">,</span> searched_record<span class="token punctuation">.</span>searched_path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>file_type <span class="token operator">==</span> FT_REGULAR<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"%s is regular file!\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir <span class="token operator">=</span> <span class="token function">dir_open</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dir_is_empty</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 非空目录不可删除</span>                <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"dir %s is not empty, it is not allowed to delete a nonempty directory!\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dir_remove</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    retval <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">dir_close</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> retval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_rmdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"dir.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/********  测试代码  ********/</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1 content before delete /dir1/subdir1:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir <span class="token operator">=</span> <span class="token function">sys_opendir</span><span class="token punctuation">(</span><span class="token string">"/dir1/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>type <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">=</span> <span class="token function">sys_readdir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dir_e<span class="token operator">-></span>f_type <span class="token operator">==</span> FT_REGULAR<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            type <span class="token operator">=</span> <span class="token string">"regular"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            type <span class="token operator">=</span> <span class="token string">"directory"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"      %s   %s\n"</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> dir_e<span class="token operator">-></span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"try to delete nonempty directory /dir1/subdir1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_rmdir</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sys_rmdir: /dir1/subdir1 delete fail!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"try to delete /dir1/subdir1/file2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_rmdir</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1/file2"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sys_rmdir: /dir1/subdir1/file2 delete fail!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_unlink</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1/file2"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sys_unlink: /dir1/subdir1/file2 delete done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"try to delete directory /dir1/subdir1 again\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_rmdir</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1/subdir1 delete done!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1 content after delete /dir1/subdir1:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_rewinddir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">=</span> <span class="token function">sys_readdir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>dir_e<span class="token operator">-></span>f_type <span class="token operator">==</span> FT_REGULAR<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            type <span class="token operator">=</span> <span class="token string">"regular"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            type <span class="token operator">=</span> <span class="token string">"directory"</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"      %s   %s\n"</span><span class="token punctuation">,</span> type<span class="token punctuation">,</span> dir_e<span class="token operator">-></span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/********  测试代码  ********/</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节m：</p><p>任务的工作目录</p><p><code>get_parent_dir_inode_nr</code>传入子目录inode索引返回父目录的inode索引。原理：调用inode_open将子目录对应的inode加载到内存中，取出inode其中i_sectors[0]地址，加载这个目录文件到内存中，找到…对应的目录项，从中取出父目录对应的inode索引返回即可。</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 获得父目录的inode编号 */</span><span class="token keyword">static</span> <span class="token class-name">uint32_t</span> <span class="token function">get_parent_dir_inode_nr</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> child_inode_nr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>child_dir_inode <span class="token operator">=</span> <span class="token function">inode_open</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> child_inode_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 目录中的目录项".."中包括父目录inode编号,".."位于目录的第0块 */</span>    <span class="token class-name">uint32_t</span> block_lba <span class="token operator">=</span> child_dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>block_lba <span class="token operator">>=</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>data_start_lba<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">inode_close</span><span class="token punctuation">(</span>child_dir_inode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> block_lba<span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span>io_buf<span class="token punctuation">;</span>    <span class="token comment">/* 第0个目录项是".",第1个目录项是".." */</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>dir_e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>i_no <span class="token operator">&lt;</span> <span class="token number">4096</span> <span class="token operator">&amp;&amp;</span> dir_e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>f_type <span class="token operator">==</span> FT_DIRECTORY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> dir_e<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>i_no<span class="token punctuation">;</span> <span class="token comment">// 返回..即父目录的inode编号</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>get_child_dir_name</code>通过传入的父目录inode索引与子目录inode索引，返回子目录的名字。原理：调用<code>inode_open</code>将父目录的inode载入内存，然后通过inode中的i_sectors[ ]加载父目录的目录文件到内存中，遍历其中的目录项，遍历过程中比对目录项的i_nr是否与子目录的inode索引相等，如果是，则拷贝名字到缓冲区中。</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 在inode编号为p_inode_nr的目录中查找inode编号为c_inode_nr的子目录的名字, * 将名字存入缓冲区path.成功返回0,失败返-1 */</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">get_child_dir_name</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> p_inode_nr<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> c_inode_nr<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>parent_dir_inode <span class="token operator">=</span> <span class="token function">inode_open</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> p_inode_nr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 填充all_blocks,将该目录的所占扇区地址全部写入all_blocks */</span>    <span class="token class-name">uint8_t</span> block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> all_blocks<span class="token punctuation">[</span><span class="token number">140</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> block_cnt <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span> <span class="token operator">=</span> parent_dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent_dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若包含了一级间接块表,将共读入all_blocks.</span>        <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> parent_dir_inode<span class="token operator">-></span>i_sectors<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span> all_blocks <span class="token operator">+</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        block_cnt <span class="token operator">=</span> <span class="token number">140</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">inode_close</span><span class="token punctuation">(</span>parent_dir_inode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span>io_buf<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> dir_entry_size <span class="token operator">=</span> cur_part<span class="token operator">-></span>sb<span class="token operator">-></span>dir_entry_size<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> dir_entrys_per_sec <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">512</span> <span class="token operator">/</span> dir_entry_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    block_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 遍历所有块 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>block_idx <span class="token operator">&lt;</span> block_cnt<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 如果相应块不为空则读入相应块</span>            <span class="token function">ide_read</span><span class="token punctuation">(</span>cur_part<span class="token operator">-></span>my_disk<span class="token punctuation">,</span> all_blocks<span class="token punctuation">[</span>block_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> io_buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">uint8_t</span> dir_e_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">/* 遍历每个目录项 */</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>dir_e_idx <span class="token operator">&lt;</span> dir_entrys_per_sec<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_e_idx<span class="token punctuation">)</span><span class="token operator">-></span>i_no <span class="token operator">==</span> c_inode_nr<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">strcat</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">strcat</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token punctuation">(</span>dir_e <span class="token operator">+</span> dir_e_idx<span class="token punctuation">)</span><span class="token operator">-></span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                dir_e_idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        block_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_getcwd</code>用于解析当前正在运行进程或线程的绝对工作路径。原理：我们之前已经为PCB中添加了cwd_inode_nr用于表示任务工作目录inode索引，假设现在这个inode索引是正确的。首先调用<code>get_parent_dir_inode_nr</code>得到父目录inode索引，此时原来的cwd_inode_nr就变成了子目录inode索引，然后就可以调用<code>get_child_dir_name</code>得到子目录名称，然后将父目录inode索引转换成新的子目录索引，又调用<code>get_parent_dir_inode_nr</code>得到新的父目录索引…如此循环，缓冲区中就会存储反转的绝对路径。比如一个进程工作在/home/kanshan/test下，缓冲区就会存入/test/kanshan/home，所以我们最后把这个路径反转过来即可。</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 把当前工作目录绝对路径写入buf, size是buf的大小. 当buf为NULL时,由操作系统分配存储工作路径的空间并返回地址 失败则返回NULL */</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">sys_getcwd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 确保buf不为空,若用户进程提供的buf为NULL,    系统调用getcwd中要为用户进程通过malloc分配内存 */</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>buf <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>io_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>SECTOR_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>io_buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>cur_thread <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> parent_inode_nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> child_inode_nr <span class="token operator">=</span> cur_thread<span class="token operator">-></span>cwd_inode_nr<span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>child_inode_nr <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> child_inode_nr <span class="token operator">&lt;</span> <span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最大支持4096个inode</span>    <span class="token comment">/* 若当前目录是根目录,直接返回'/' */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>child_inode_nr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>        buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> buf<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> full_path_reverse<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 用来做全路径缓冲区</span>    <span class="token comment">/* 从下往上逐层找父目录,直到找到根目录为止.     * 当child_inode_nr为根目录的inode编号(0)时停止,     * 即已经查看完根目录中的目录项 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>child_inode_nr<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        parent_inode_nr <span class="token operator">=</span> <span class="token function">get_parent_dir_inode_nr</span><span class="token punctuation">(</span>child_inode_nr<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_child_dir_name</span><span class="token punctuation">(</span>parent_inode_nr<span class="token punctuation">,</span> child_inode_nr<span class="token punctuation">,</span> full_path_reverse<span class="token punctuation">,</span> io_buf<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 或未找到名字,失败退出</span>            <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        child_inode_nr <span class="token operator">=</span> parent_inode_nr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>full_path_reverse<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 至此full_path_reverse中的路径是反着的,     * 即子目录在前(左),父目录在后(右) ,     * 现将full_path_reverse中的路径反置 */</span>    <span class="token keyword">char</span> <span class="token operator">*</span>last_slash<span class="token punctuation">;</span> <span class="token comment">// 用于记录字符串中最后一个斜杠地址</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>last_slash <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span>full_path_reverse<span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">uint16_t</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>buf <span class="token operator">+</span> len<span class="token punctuation">,</span> last_slash<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 在full_path_reverse中添加结束字符,做为下一次执行strcpy中last_slash的边界 */</span>        <span class="token operator">*</span>last_slash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_chdir</code>传入一个目录的路径，然后改变当前正在运行的进程或线程的工作目录索引。原理：调用<code>search_file</code>将传入路径解析成一个对应的inode索引，然后直接去修改当前任务pcb的cwd_inode_nr为之前返回的inode索引就行了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 更改当前工作目录为绝对路径path,成功则返回0,失败返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_chdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">path_search_record</span> searched_record<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>searched_record<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path_search_record</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> inode_no <span class="token operator">=</span> <span class="token function">search_file</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token operator">&amp;</span>searched_record<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>file_type <span class="token operator">==</span> FT_DIRECTORY<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>cwd_inode_nr <span class="token operator">=</span> inode_no<span class="token punctuation">;</span>            ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_chdir: %s is regular file or other!\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">sys_getcwd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">sys_chdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>测试代码（<strong>kernle/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"dir.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/********  测试代码  ********/</span>   <span class="token keyword">char</span> cwd_buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>   <span class="token function">sys_getcwd</span><span class="token punctuation">(</span>cwd_buf<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cwd:%s\n"</span><span class="token punctuation">,</span> cwd_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_chdir</span><span class="token punctuation">(</span><span class="token string">"/dir1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"change cwd now\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">sys_getcwd</span><span class="token punctuation">(</span>cwd_buf<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cwd:%s\n"</span><span class="token punctuation">,</span> cwd_buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/********  测试代码  ********/</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节n：</p><p>获得文件属性</p><p>修改（<strong>fs/fs.h</strong>），增加记录文件属性的结构体定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 文件属性结构体 */</span><span class="token keyword">struct</span> <span class="token class-name">stat</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> st_ino<span class="token punctuation">;</span>             <span class="token comment">// inode编号</span>    <span class="token class-name">uint32_t</span> st_size<span class="token punctuation">;</span>            <span class="token comment">// 尺寸</span>    <span class="token keyword">enum</span> <span class="token class-name">file_types</span> st_filetype<span class="token punctuation">;</span> <span class="token comment">// 文件类型</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_stat</code>传入一个路径，调用search_file解析该路径，获得该路径对应的inode索引，然后调用<code>inode_open</code>将该inode调入内存，然后赋值struct stat对应的成员即可</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 在buf中填充文件结构相关信息,成功时返回0,失败返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 若直接查看根目录'/' */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">"/."</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">"/.."</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        buf<span class="token operator">-></span>st_filetype <span class="token operator">=</span> FT_DIRECTORY<span class="token punctuation">;</span>        buf<span class="token operator">-></span>st_ino <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        buf<span class="token operator">-></span>st_size <span class="token operator">=</span> root_dir<span class="token punctuation">.</span>inode<span class="token operator">-></span>i_size<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 默认返回值</span>    <span class="token keyword">struct</span> <span class="token class-name">path_search_record</span> searched_record<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>searched_record<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">path_search_record</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 记得初始化或清0,否则栈中信息不知道是什么</span>    <span class="token keyword">int</span> inode_no <span class="token operator">=</span> <span class="token function">search_file</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token operator">&amp;</span>searched_record<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>inode_no <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>obj_inode <span class="token operator">=</span> <span class="token function">inode_open</span><span class="token punctuation">(</span>cur_part<span class="token punctuation">,</span> inode_no<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只为获得文件大小</span>        buf<span class="token operator">-></span>st_size <span class="token operator">=</span> obj_inode<span class="token operator">-></span>i_size<span class="token punctuation">;</span>        <span class="token function">inode_close</span><span class="token punctuation">(</span>obj_inode<span class="token punctuation">)</span><span class="token punctuation">;</span>        buf<span class="token operator">-></span>st_filetype <span class="token operator">=</span> searched_record<span class="token punctuation">.</span>file_type<span class="token punctuation">;</span>        buf<span class="token operator">-></span>st_ino <span class="token operator">=</span> inode_no<span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_stat: %s not found\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">dir_close</span><span class="token punctuation">(</span>searched_record<span class="token punctuation">.</span>parent_dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试代码（<strong>kernle/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/********  测试代码  ********/</span>    <span class="token keyword">struct</span> <span class="token class-name">stat</span> obj_stat<span class="token punctuation">;</span>    <span class="token function">sys_stat</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>obj_stat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/`s info\n   i_no:%d\n   size:%d\n   filetype:%s\n"</span><span class="token punctuation">,</span>           obj_stat<span class="token punctuation">.</span>st_ino<span class="token punctuation">,</span> obj_stat<span class="token punctuation">.</span>st_size<span class="token punctuation">,</span>           obj_stat<span class="token punctuation">.</span>st_filetype <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token string">"directory"</span> <span class="token operator">:</span> <span class="token string">"regular"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_stat</span><span class="token punctuation">(</span><span class="token string">"/dir1"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>obj_stat<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"/dir1`s info\n   i_no:%d\n   size:%d\n   filetype:%s\n"</span><span class="token punctuation">,</span>           obj_stat<span class="token punctuation">.</span>st_ino<span class="token punctuation">,</span> obj_stat<span class="token punctuation">.</span>st_size<span class="token punctuation">,</span>           obj_stat<span class="token punctuation">.</span>st_filetype <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token string">"directory"</span> <span class="token operator">:</span> <span class="token string">"regular"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/********  测试代码  ********/</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="与系统交互"><a href="#与系统交互" class="headerlink" title="与系统交互"></a>与系统交互</h1><p>这一小节，我们要实现fork</p><p>fork是用于复制进程的，也就是根据父进程复制出一个子进程。但是由于他们本质是两个进程，所以还是有很多不相同的地方，比如独立的资源，单独的pid之类的。</p><p>有这样一段代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"who am I ? my pid is %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当执行完fork()后，fork之后的代码会由于属于两个进程（调用fork的主进程与被复制出来的子进程）而被执行两次（自然是主进程与子进程各执行一次）。</p><p>由于fork复制进程，而且复制步骤是在fork自己的代码结束前就完成（假设fork代码1000行，第800行就完成了复制），所以fork代码最后一行的return 就会被执行两次。对于父进程来说，fork会返回子进程pid。对于子进程来说，fork会返回0。我们就可以根据fork返回的不同值来区别父子进程，以让父子进程执行<a href="https://so.csdn.net/so/search?q=不同的&amp;spm=1001.2101.3001.7020">不同的</a>代码。比如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am father, my pid is d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I am child, my pid is d\n"</span><span class="token punctuation">,</span><span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在开始实现fork，先实现一些基础设施函数</p><p><code>fork_pid</code>就是封装了<code>allocate_pid</code>，因为<code>allocate_pid</code>之前实现的时候有<a href="https://so.csdn.net/so/search?q=关键字&amp;spm=1001.2101.3001.7020">关键字</a>static，所以作者为了不去修改这个，就采取了进一步封装</p><p>修改（<strong>thread/thread.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* fork进程时为其分配pid,因为allocate_pid已经是静态的,别的文件无法调用.不想改变函数定义了,故定义fork_pid函数来封装一下。*/</span><span class="token class-name">pid_t</span> <span class="token function">fork_pid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">allocate_pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>thread/thread.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pid_t</span> <span class="token function">fork_pid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>get_a_page_without_opvaddrbitmap</code>用于为指定的虚拟地址创建物理页映射，与<code>get_a_page</code>相比，少了操作进程pcb中的虚拟内存池位图</p><p>修改（<strong>kernel/memory.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 安装1页大小的vaddr,专门针对fork时虚拟地址位图无须操作的情况 */</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">get_a_page_without_opvaddrbitmap</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> pf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> vaddr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">pool</span> <span class="token operator">*</span>mem_pool <span class="token operator">=</span> pf <span class="token operator">&amp;</span> PF_KERNEL <span class="token operator">?</span> <span class="token operator">&amp;</span>kernel_pool <span class="token operator">:</span> <span class="token operator">&amp;</span>user_pool<span class="token punctuation">;</span>    <span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>page_phyaddr <span class="token operator">=</span> <span class="token function">palloc</span><span class="token punctuation">(</span>mem_pool<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>page_phyaddr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">page_table_add</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>vaddr<span class="token punctuation">,</span> page_phyaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>vaddr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>kernel/memory.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">get_a_page_without_opvaddrbitmap</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">pool_flags</span> pf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>copy_pcb_vaddrbitmap_stack0</code>用于根据传入的父子进程pcb指针，先复制整个父进程pcb内容到子进程pcb中，然后再针对设置子进程pcb内容，包含：pid, elapsed_ticks, status, ticks, parent_pid, general_tag, all_list_tag, u_block_desc, userprog_vaddr（让子进程拥有自己的用户虚拟地址空间内存池，但是其位图是拷贝父进程的）。这个过程中，内核栈中的内容被完全拷贝了。</p><p>（<strong>userprog/fork.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fork.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"process.h"</span></span><span class="token comment">/* 将父进程的pcb、虚拟地址位图拷贝给子进程 */</span><span class="token keyword">static</span> <span class="token class-name">int32_t</span> <span class="token function">copy_pcb_vaddrbitmap_stack0</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>child_thread<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>parent_thread<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* a 复制pcb所在的整个页,里面包含进程pcb信息及特级0极的栈,里面包含了返回地址, 然后再单独修改个别部分 */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>child_thread<span class="token punctuation">,</span> parent_thread<span class="token punctuation">,</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    child_thread<span class="token operator">-></span>pid <span class="token operator">=</span> <span class="token function">fork_pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    child_thread<span class="token operator">-></span>elapsed_ticks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    child_thread<span class="token operator">-></span>status <span class="token operator">=</span> TASK_READY<span class="token punctuation">;</span>    child_thread<span class="token operator">-></span>ticks <span class="token operator">=</span> child_thread<span class="token operator">-></span>priority<span class="token punctuation">;</span> <span class="token comment">// 为新进程把时间片充满</span>    child_thread<span class="token operator">-></span>parent_pid <span class="token operator">=</span> parent_thread<span class="token operator">-></span>pid<span class="token punctuation">;</span>    child_thread<span class="token operator">-></span>general_tag<span class="token punctuation">.</span>prev <span class="token operator">=</span> child_thread<span class="token operator">-></span>general_tag<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    child_thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">.</span>prev <span class="token operator">=</span> child_thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token function">block_desc_init</span><span class="token punctuation">(</span>child_thread<span class="token operator">-></span>u_block_desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* b 复制父进程的虚拟地址池的位图 */</span>    <span class="token class-name">uint32_t</span> bitmap_pg_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0xc0000000</span> <span class="token operator">-</span> USER_VADDR_START<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">,</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>vaddr_btmp <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span>bitmap_pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>vaddr_btmp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/* 此时child_thread->userprog_vaddr.vaddr_bitmap.bits还是指向父进程虚拟地址的位图地址     * 下面将child_thread->userprog_vaddr.vaddr_bitmap.bits指向自己的位图vaddr_btmp */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>vaddr_btmp<span class="token punctuation">,</span> child_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>bits<span class="token punctuation">,</span> bitmap_pg_cnt <span class="token operator">*</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    child_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>bits <span class="token operator">=</span> vaddr_btmp<span class="token punctuation">;</span>    <span class="token comment">/* 调试用 */</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>child_thread<span class="token operator">-></span>name<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pcb.name的长度是16,为避免下面strcat越界</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>child_thread<span class="token operator">-></span>name<span class="token punctuation">,</span> <span class="token string">"_fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>copy_body_stack3</code>用于根据传入的父子进程pcb指针，复制进程的用户空间堆与栈中的数据。核心原理：遍历父进程的userprog_vaddr当中的虚拟地址空间位图，来判断父进程的用户虚拟地址空间中是否有数据。如果有，就拷贝到内核空间的中转区中，然后调用<code>page_dir_activate</code>，切换到子进程页表，调用<code>get_a_page_without_opvaddrbitmap</code>为子进程特定虚拟地址申请一个物理页（其中并不涉及子进程userprog_vaddr中的位图修改），然后从内核中转区中把数据拷贝到子进程相同的虚拟地址内。</p><p>修改（<strong>userprog/fork.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">intr_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 复制子进程的进程体(代码和数据)及用户栈 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">copy_body_stack3</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>child_thread<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>parent_thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf_page<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint8_t</span> <span class="token operator">*</span>vaddr_btmp <span class="token operator">=</span> parent_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>bits<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> btmp_bytes_len <span class="token operator">=</span> parent_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>btmp_bytes_len<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> vaddr_start <span class="token operator">=</span> parent_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_start<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> idx_byte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> idx_bit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> prog_vaddr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 在父进程的用户空间中查找已有数据的页 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>idx_byte <span class="token operator">&lt;</span> btmp_bytes_len<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>vaddr_btmp<span class="token punctuation">[</span>idx_byte<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            idx_bit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>idx_bit <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>BITMAP_MASK <span class="token operator">&lt;&lt;</span> idx_bit<span class="token punctuation">)</span> <span class="token operator">&amp;</span> vaddr_btmp<span class="token punctuation">[</span>idx_byte<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    prog_vaddr <span class="token operator">=</span> <span class="token punctuation">(</span>idx_byte <span class="token operator">*</span> <span class="token number">8</span> <span class="token operator">+</span> idx_bit<span class="token punctuation">)</span> <span class="token operator">*</span> PG_SIZE <span class="token operator">+</span> vaddr_start<span class="token punctuation">;</span>                    <span class="token comment">/* 下面的操作是将父进程用户空间中的数据通过内核空间做中转,最终复制到子进程的用户空间 */</span>                    <span class="token comment">/* a 将父进程在用户空间中的数据复制到内核缓冲区buf_page,                    目的是下面切换到子进程的页表后,还能访问到父进程的数据*/</span>                    <span class="token function">memcpy</span><span class="token punctuation">(</span>buf_page<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>prog_vaddr<span class="token punctuation">,</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* b 将页表切换到子进程,目的是避免下面申请内存的函数将pte及pde安装在父进程的页表中 */</span>                    <span class="token function">page_dir_activate</span><span class="token punctuation">(</span>child_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* c 申请虚拟地址prog_vaddr */</span>                    <span class="token function">get_a_page_without_opvaddrbitmap</span><span class="token punctuation">(</span>PF_USER<span class="token punctuation">,</span> prog_vaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* d 从内核缓冲区中将父进程数据复制到子进程的用户空间 */</span>                    <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>prog_vaddr<span class="token punctuation">,</span> buf_page<span class="token punctuation">,</span> PG_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">/* e 恢复父进程页表 */</span>                    <span class="token function">page_dir_activate</span><span class="token punctuation">(</span>parent_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                idx_bit<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        idx_byte<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>build_child_stack</code>用于修改子进程的返回值和设定其内核栈。子进程返回0原理：我们之前构建系统调用机制时，系统调用的返回值会放入内核栈中的中断栈（<code>intr_stack</code>）eax的位置，这样中断退出（<code>intr_exit</code>）就会push eax时将返回值放入eax中。所以我们将子进程的内核栈中断栈eax的值改成0。</p><p>我们的子进程上机运行是通过让自己就绪之后，等待某个时钟中断调用switch_to函数上机</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">mov eax, [esp + 24] mov esp, [eax] pop ebppop ebxpop edipop esiret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>switch_to会从子进程的pcb中找到内核栈的栈顶放入esp中，然后执行switch_to的那4条pop和ret指令，我们现在经过拷贝后的子进程内核栈布局如图：</p><p><img src="252badadffac484cbd88f3f09e529b28.png" alt="在这里插入图片描述"><br>所以，我们直接去用子进程这样的内核栈布局肯定不行，要人为去修改成<br><img src="014da05bbf6f40b49b8abb41735ca29d.png" alt="在这里插入图片描述"><br>也就是在intr_stack前面增加switch_to栈（也就是书p694提到的thread_stack），让pcb最顶端的esp指向switch_to栈栈顶，并且switch_to栈中返回地址要填上<code>intr_exit</code>函数地址。这样执行ret之后，就能去执行<code>intr_exit</code>，并利用intr_stack执行中断返回，由于intr_stack中拷贝了父进程进入中断时的用户栈信息，cs: ip 信息，所以中断退出后，子进程将会继续执行父进程之后的代码。</p><p>修改（<strong>userprog/fork.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 为子进程构建thread_stack和修改返回值 */</span><span class="token keyword">static</span> <span class="token class-name">int32_t</span> <span class="token function">build_child_stack</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>child_thread<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* a 使子进程pid返回值为0 */</span>    <span class="token comment">/* 获取子进程0级栈栈顶 */</span>    <span class="token keyword">struct</span> <span class="token class-name">intr_stack</span> <span class="token operator">*</span>intr_0_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">intr_stack</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>child_thread <span class="token operator">+</span> PG_SIZE <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">intr_stack</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 修改子进程的返回值为0 */</span>    intr_0_stack<span class="token operator">-></span>eax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* b 为switch_to 构建 struct thread_stack,将其构建在紧临intr_stack之下的空间*/</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>ret_addr_in_thread_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>intr_0_stack <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">/***   这三行不是必要的,只是为了梳理thread_stack中的关系 ***/</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>esi_ptr_in_thread_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>intr_0_stack <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>edi_ptr_in_thread_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>intr_0_stack <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>ebx_ptr_in_thread_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>intr_0_stack <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">/**********************************************************/</span>    <span class="token comment">/* ebp在thread_stack中的地址便是当时的esp(0级栈的栈顶),    即esp为"(uint32_t*)intr_0_stack - 5" */</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>ebp_ptr_in_thread_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>intr_0_stack <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment">/* switch_to的返回地址更新为intr_exit,直接从中断返回 */</span>    <span class="token operator">*</span>ret_addr_in_thread_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>intr_exit<span class="token punctuation">;</span>    <span class="token comment">/* 下面这两行赋值只是为了使构建的thread_stack更加清晰,其实也不需要,     * 因为在进入intr_exit后一系列的pop会把寄存器中的数据覆盖 */</span>    <span class="token operator">*</span>ebp_ptr_in_thread_stack <span class="token operator">=</span> <span class="token operator">*</span>ebx_ptr_in_thread_stack <span class="token operator">=</span>        <span class="token operator">*</span>edi_ptr_in_thread_stack <span class="token operator">=</span> <span class="token operator">*</span>esi_ptr_in_thread_stack <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/*********************************************************/</span>    <span class="token comment">/* 把构建的thread_stack的栈顶做为switch_to恢复数据时的栈顶 */</span>    child_thread<span class="token operator">-></span>self_kstack <span class="token operator">=</span> ebp_ptr_in_thread_stack<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>update_inode_open_cnts</code>由于fork出来的子进程几乎和父进程一样，所以父进程打开的文件，子进程也要打开。所以，父进程的全局打开文件结构中记录文件打开的次数都需要 + 1。原理：遍历进程pcb（父，子均可）中的文件描述符，找到对应的全局打开文件结构索引就行了</p><p>修改（<strong>user/fork.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;file.h></span></span><span class="token comment">/* 更新inode打开数 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update_inode_open_cnts</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>thread<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> local_fd <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> global_fd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>local_fd <span class="token operator">&lt;</span> MAX_FILES_OPEN_PER_PROC<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        global_fd <span class="token operator">=</span> thread<span class="token operator">-></span>fd_table<span class="token punctuation">[</span>local_fd<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>global_fd <span class="token operator">&lt;</span> MAX_FILE_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>global_fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token operator">-></span>i_open_cnts<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        local_fd<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>copy_process</code>就是fork时用于复制父进程资源的函数，就是前面函数的封装。原理：调用<code>copy_pcb_vaddrbitmap_stack0</code>复制父进程的pcb、虚拟地址位图、内核栈到子进程；然后调用<code>create_page_dir</code>为子进程创建页表，这个页表已经包含了内核地址空间的映射；然后调用<code>copy_body_stack3</code>复制进程的用户空间堆与栈中的数据；然后调用<code>build_child_stack</code>用于修改子进程的返回值和设定其内核栈；最后调用<code>update_inode_open_cnts</code>更新inode的打开数。</p><p>修改（<strong>user/fork.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 拷贝父进程本身所占资源给子进程 */</span><span class="token keyword">static</span> <span class="token class-name">int32_t</span> <span class="token function">copy_process</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>child_thread<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>parent_thread<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 内核缓冲区,作为父进程用户空间的数据复制到子进程用户空间的中转 */</span>    <span class="token keyword">void</span> <span class="token operator">*</span>buf_page <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>buf_page <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* a 复制父进程的pcb、虚拟地址位图、内核栈到子进程 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_pcb_vaddrbitmap_stack0</span><span class="token punctuation">(</span>child_thread<span class="token punctuation">,</span> parent_thread<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* b 为子进程创建页表,此页表仅包括内核空间 */</span>    child_thread<span class="token operator">-></span>pgdir <span class="token operator">=</span> <span class="token function">create_page_dir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>child_thread<span class="token operator">-></span>pgdir <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* c 复制父进程进程体及用户栈给子进程 */</span>    <span class="token function">copy_body_stack3</span><span class="token punctuation">(</span>child_thread<span class="token punctuation">,</span> parent_thread<span class="token punctuation">,</span> buf_page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* d 构建子进程thread_stack和修改返回值pid */</span>    <span class="token function">build_child_stack</span><span class="token punctuation">(</span>child_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* e 更新文件inode的打开数 */</span>    <span class="token function">update_inode_open_cnts</span><span class="token punctuation">(</span>child_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mfree_page</span><span class="token punctuation">(</span>PF_KERNEL<span class="token punctuation">,</span> buf_page<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_fork</code>用于复制出一个进程，并将其加入就绪队列</p><p>（<strong>userprog/fork.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"interrupt.h"</span></span><span class="token comment">/* fork子进程,内核线程不可直接调用 */</span><span class="token class-name">pid_t</span> <span class="token function">sys_fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>parent_thread <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>child_thread <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为子进程创建pcb(task_struct结构)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>child_thread <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>INTR_OFF <span class="token operator">==</span> <span class="token function">intr_get_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> parent_thread<span class="token operator">-></span>pgdir <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copy_process</span><span class="token punctuation">(</span>child_thread<span class="token punctuation">,</span> parent_thread<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 添加到就绪线程队列和所有线程队列,子进程由调试器安排运行 */</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_thread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_thread<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_append</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>child_thread<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> child_thread<span class="token operator">-></span>pid<span class="token punctuation">;</span> <span class="token comment">// 父进程返回子进程的pid</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明（<strong>userprog/fork.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__USERPROG_FORK_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__USERPROG_FORK_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token class-name">pid_t</span> <span class="token function">sys_fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们添加<code>fork</code>系统调用</p><p>添加系统调用号，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span> <span class="token punctuation">&#123;</span>   SYS_GETPID<span class="token punctuation">,</span>   SYS_WRITE<span class="token punctuation">,</span>   SYS_MALLOC<span class="token punctuation">,</span>   SYS_FREE<span class="token punctuation">,</span>   SYS_FORK<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户态系统调用入口，修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token comment">/* 派生子进程,返回子进程pid */</span><span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall0</span><span class="token punctuation">(</span>SYS_FORK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pid_t</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>系统调用表中添加实际系统调用函数，修改（<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fork.h"</span></span><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>syscall_table<span class="token punctuation">[</span>SYS_WRITE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_write<span class="token punctuation">;</span>syscall_table<span class="token punctuation">[</span>SYS_MALLOC<span class="token punctuation">]</span> <span class="token operator">=</span> sys_malloc<span class="token punctuation">;</span>   syscall_table<span class="token punctuation">[</span>SYS_FREE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_free<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FORK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_fork<span class="token punctuation">;</span><span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>init</code>进程：我们学习Linux做法，让<code>init</code>作为pid为1的用户进程，所以必须要放在主线程创建之创建。后续所有的进程都是它的孩子，它还负责所有子进程的资源回收</p><p>修改（<strong>thread/thread.c/thread_init</strong>），让<code>init</code>的pid为1</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 初始化线程环境 */</span><span class="token keyword">void</span> <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 先创建第一个用户进程:init */</span>    <span class="token function">process_execute</span><span class="token punctuation">(</span>init<span class="token punctuation">,</span> <span class="token string">"init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 放在第一个初始化,这是第一个进程,init进程的pid为1</span>    <span class="token comment">/* 将当前main函数创建为线程 */</span>    <span class="token function">make_main_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 创建idle线程 */</span>    idle_thread <span class="token operator">=</span> <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"idle"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> idle<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码与<code>init</code>进程实现</p><p>（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fork.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* init进程 */</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> ret_pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am father, my pid is %d, child pid is %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ret_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"i am child, my pid is %d, ret pid is %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ret_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译运行会报页错误，经过排查，修改（<strong>thread/thread.c/thread_create</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 先预留中断使用栈的空间,可见thread.h中定义的结构 */</span><span class="token comment">// pthread->self_kstack -= sizeof(struct intr_stack);  //-=结果是sizeof(struct intr_stack)的4倍</span><span class="token comment">// self_kstack类型为uint32_t*，也就是一个明确指向uint32_t类型值的地址，那么加减操作，都是会是sizeof(uint32_t) = 4 的倍数</span>pthread<span class="token operator">-></span>self_kstack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>self_kstack<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">intr_stack</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 再留出线程栈空间,可见thread.h中定义 */</span><span class="token comment">// pthread->self_kstack -= sizeof(struct thread_stack);</span>pthread<span class="token operator">-></span>self_kstack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>self_kstack<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 先预留中断使用栈的空间,可见thread.h中定义的结构 */</span>pthread<span class="token operator">-></span>self_kstack <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">intr_stack</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//-=结果是sizeof(struct intr_stack)的4倍</span><span class="token comment">// self_kstack类型为uint32_t*，也就是一个明确指向uint32_t类型值的地址，那么加减操作，都是会是sizeof(uint32_t) = 4 的倍数</span><span class="token comment">// pthread->self_kstack = (uint32_t *)((int)(pthread->self_kstack) - sizeof(struct intr_stack));</span><span class="token comment">/* 再留出线程栈空间,可见thread.h中定义 */</span>pthread<span class="token operator">-></span>self_kstack <span class="token operator">-=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_stack</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// pthread->self_kstack = (uint32_t *)((int)(pthread->self_kstack) - sizeof(struct thread_stack));</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节b：</p><p>获取键盘输入</p><p><code>sys_read</code>用于从指定文件描述符中获取conunt字节数据，如果文件描述符是stdin_no，那么直接循环调用<code>ioq_getchar</code>从键盘获取内容，否则调用<code>file_read</code>从文件中读取内容</p><p><code>sys_put_char</code>用于向屏幕输出一个字符</p><p>修改（<strong>fs/fs.c/sys_read</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"keyboard.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ioqueue.h"</span></span><span class="token comment">/* 从文件描述符fd指向的文件中读取count个字节到buf,若成功则返回读出的字节数,到文件尾则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_read</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>buf <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> fd <span class="token operator">==</span> stdout_no <span class="token operator">||</span> fd <span class="token operator">==</span> stderr_no<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_read: fd error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> stdin_no<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>buffer <span class="token operator">=</span> buf<span class="token punctuation">;</span>        <span class="token class-name">uint32_t</span> bytes_read <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>bytes_read <span class="token operator">&lt;</span> count<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token operator">*</span>buffer <span class="token operator">=</span> <span class="token function">ioq_getchar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kbd_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            bytes_read<span class="token operator">++</span><span class="token punctuation">;</span>            buffer<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ret <span class="token operator">=</span> <span class="token punctuation">(</span>bytes_read <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span>bytes_read<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">uint32_t</span> _fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token function">file_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>_fd<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 向屏幕输出一个字符 */</span><span class="token keyword">void</span> <span class="token function">sys_putchar</span><span class="token punctuation">(</span><span class="token keyword">char</span> char_asci<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">console_put_char</span><span class="token punctuation">(</span>char_asci<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sys_putchar</span><span class="token punctuation">(</span><span class="token keyword">char</span> char_asci<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>cls_screen</code>用于清空屏幕，核心原理：向代表80列×25行，共2000个字符位置的内存写入空格符，然后设定光标位置为左上角（即位置0）</p><p>修改（<strong>lib/kernel/print.S</strong>）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">global cls_screencls_screen:pushad; 由于用户程序的cpl为3,显存段的dpl为0,故用于显存段的选择子gs在低于自己特权的环境中为0,; 导致用户程序再次进入中断后,gs为0,故直接在put_str中每次都为gs赋值. mov ax, SELECTOR_VIDEO       ; 不能直接把立即数送入gs,须由ax中转mov gs, axmov ebx, 0mov ecx, 80*25.cls:mov word [gs:ebx], 0x0720  ;0x0720是黑底白字的空格键add ebx, 2loop .cls mov ebx, 0.set_cursor:  ;直接把set_cursor搬过来用,省事;;;;;; 1 先设置高8位 ;;;;;;;;mov dx, 0x03d4  ;索引寄存器mov al, 0x0e  ;用于提供光标位置的高8位out dx, almov dx, 0x03d5  ;通过读写数据端口0x3d5来获得或设置光标位置 mov al, bhout dx, al;;;;;;; 2 再设置低8位 ;;;;;;;;;mov dx, 0x03d4mov al, 0x0fout dx, almov dx, 0x03d5 mov al, blout dx, alpopadret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>lib/kernel/print.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">cls_screen</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>sys_read</code>、<code>sys_putchar</code>、<code>cls_screen</code>做成系统调用</p><p>添加系统调用号，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span><span class="token punctuation">&#123;</span>    SYS_GETPID<span class="token punctuation">,</span>    SYS_WRITE<span class="token punctuation">,</span>    SYS_MALLOC<span class="token punctuation">,</span>    SYS_FREE<span class="token punctuation">,</span>    SYS_FORK<span class="token punctuation">,</span>    SYS_READ<span class="token punctuation">,</span>    SYS_PUTCHAR<span class="token punctuation">,</span>    SYS_CLEAR<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>准备好<code>read</code>、<code>put_char</code>与<code>clear</code>的用户态入口，修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 从文件描述符fd中读取count个字节到buf */</span><span class="token class-name">int32_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall3</span><span class="token punctuation">(</span>SYS_READ<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 输出一个字符 */</span><span class="token keyword">void</span> <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token keyword">char</span> char_asci<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_PUTCHAR<span class="token punctuation">,</span> char_asci<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 清空屏幕 */</span><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">_syscall0</span><span class="token punctuation">(</span>SYS_CLEAR<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后声明函数，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token keyword">char</span> char_asci<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将系统调用实际执行程序，添加至系统调用表中，修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_WRITE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_write<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MALLOC<span class="token punctuation">]</span> <span class="token operator">=</span> sys_malloc<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FREE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_free<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FORK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_fork<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READ<span class="token punctuation">]</span> <span class="token operator">=</span> sys_read<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PUTCHAR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_putchar<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLEAR<span class="token punctuation">]</span> <span class="token operator">=</span> cls_screen<span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shell是用户与操作系统之间交互的接口，我们天天使用的Linux终端就是一个shell。它的功能就是获取用户的键盘输入，然后从中解析命令，然后根据命令去执行对应的动作。</p><p><code>print_prompt</code>用于输出命令提示符，也就是我们在终端输入命令时，前面那串字符</p><p>（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shell.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">char</span> cwd_cache<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* 输出提示符 */</span><span class="token keyword">void</span> <span class="token function">print_prompt</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"[rabbit@localhost %s]$ "</span><span class="token punctuation">,</span> cwd_cache<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>readline</code>循环调用<code>read</code>从键盘输入缓冲读取字符，每次读取一个，最多读入count个字节到buf。根据每次读入的值不同，处理方式也不同：/n，/r表示按下enter键，用户输入命令结束，缓冲区输入个0表示命令字符串结尾。/b表示按下退格键，就删除一个字符。普通字符就直接读入buf。每种字符都调用了<code>putchar</code>进行打印，是因为我们的键盘中断处理函数已经删除打印功能。</p><p>修改（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"file.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token comment">/* 从键盘缓冲区中最多读入count个字节到buf。*/</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>buf <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pos <span class="token operator">=</span> buf<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>stdin_no<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pos <span class="token operator">-</span> buf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> count<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 在不出错情况下,直到找到回车符才返回</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token operator">*</span>pos<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 找到回车或换行符后认为键入的命令结束,直接返回 */</span>        <span class="token keyword">case</span> <span class="token char">'\n'</span><span class="token operator">:</span>        <span class="token keyword">case</span> <span class="token char">'\r'</span><span class="token operator">:</span>            <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 添加cmd_line的终止字符0</span>            <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'\b'</span><span class="token operator">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\b'</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>          <span class="token comment">// 阻止删除非本次输入的信息</span>                <span class="token operator">--</span>pos<span class="token punctuation">;</span> <span class="token comment">// 退回到缓冲区cmd_line中上一个字符</span>                <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">/* 非控制键则输出字符 */</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token operator">*</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>            pos<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"readline: can`t find enter_key in the cmd_line, max num of char is 128\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>my_shell</code>就是shell进程，不断循环：调用<code>print_prompt</code>输出命令提示符，然后调用<code>readline</code>获取用户输入</p><p>修改（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">cmd_len</span> <span class="token expression"><span class="token number">128</span> </span><span class="token comment">// 最大支持键入128个字符的命令行输入</span></span><span class="token keyword">static</span> <span class="token keyword">char</span> cmd_line<span class="token punctuation">[</span>cmd_len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* 简单的shell */</span><span class="token keyword">void</span> <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cwd_cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print_prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cmd_len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readline</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> cmd_len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd_line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若只键入了一个回车</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"my_shell: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，（<strong>shell/shell.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__KERNEL_SHELL_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__KERNEL_SHELL_H</span></span><span class="token keyword">void</span> <span class="token function">print_prompt</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们让<code>init</code>来开启<code>shell</code>，修改（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fork.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shell.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">cls_screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">"[rabbit@localhost /]$ "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* init进程 */</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> ret_pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"init: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除（<strong>device/keyboard.c/intr_keyboard_handler</strong>）中的打印语句</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">put_char</span><span class="token punctuation">(</span>cur_char<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 临时的</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>makefile记得新增包含静态库</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">LIB<span class="token operator">=</span> -I lib/ -I lib/kernel/ -I lib/user/ -I kernel/ -I device/ -I thread/ -I userprog/-I fs/ -I shell/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里的问题：</p><p>1、main函数中有打印命令提示符的语句，而<code>init_all</code>中调用<code>thread_init</code>调用<code>process_execute</code>创建了init进程，init运行时会fork出只调用shell的进程，这个进程会调用<code>print_prompt</code>打印命令提示符，这就和main当中打印是冲突了的。要想实现书上的效果，那么fork出运行shell的进程调用<code>print_prompt</code>必须在<code>main</code>调用<code>cls_screen</code>之前。这依赖于特定的任务执行顺序，不过一般不会出错。</p><p>小节c：</p><p>添加快捷键</p><p><code>readline</code>中新增加对于组合键的处理，ctrl + l 清除除了当前行外的其他行。ctrl + u清除本行的输入，效果类似于连续按下多个退格。我们在键盘中断处理程序中已经预先写好了按下ctrl + l 与 ctrl + u 的处理</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ctrl_status <span class="token operator">&amp;&amp;</span> cur_char <span class="token operator">==</span> <span class="token char">'l'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>ctrl_status <span class="token operator">&amp;&amp;</span> cur_char <span class="token operator">==</span> <span class="token char">'u'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    cur_char <span class="token operator">-=</span> <span class="token char">'a'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">ioq_full</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kbd_buf<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token function">ioq_putchar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kbd_buf<span class="token punctuation">,</span> cur_char<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说，我们按下ctrl + l 与 ctrl + u时，放入键盘输入缓冲区的字符是ascii 码为 ‘l’ - ‘a’ 与 ‘u’ - ‘a’，这两个ascii码都属于不可见的控制字符。所以我们只需要增加<code>readline</code>读出这两种情况的处理逻辑即可</p><p>修改（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 从键盘缓冲区中最多读入count个字节到buf。*/</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">readline</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>buf <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pos <span class="token operator">=</span> buf<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>stdin_no<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pos <span class="token operator">-</span> buf<span class="token punctuation">)</span> <span class="token operator">&lt;</span> count<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 在不出错情况下,直到找到回车符才返回</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token operator">*</span>pos<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 找到回车或换行符后认为键入的命令结束,直接返回 */</span>        <span class="token keyword">case</span> <span class="token char">'\n'</span><span class="token operator">:</span>        <span class="token keyword">case</span> <span class="token char">'\r'</span><span class="token operator">:</span>            <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 添加cmd_line的终止字符0</span>            <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token char">'\b'</span><span class="token operator">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd_line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'\b'</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>          <span class="token comment">// 阻止删除非本次输入的信息</span>                <span class="token operator">--</span>pos<span class="token punctuation">;</span> <span class="token comment">// 退回到缓冲区cmd_line中上一个字符</span>                <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">/* ctrl+l 清屏 */</span>        <span class="token keyword">case</span> <span class="token char">'l'</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token operator">:</span>            <span class="token comment">/* 1 先将当前的字符'l'-'a'置为0 */</span>            <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">/* 2 再将屏幕清空 */</span>            <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 3 打印提示符 */</span>            <span class="token function">print_prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 4 将之前键入的内容再次打印 */</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">/* ctrl+u 清掉输入 */</span>        <span class="token keyword">case</span> <span class="token char">'u'</span> <span class="token operator">-</span> <span class="token char">'a'</span><span class="token operator">:</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>buf <span class="token operator">!=</span> pos<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token char">'\b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">*</span><span class="token punctuation">(</span>pos<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token comment">/* 非控制键则输出字符 */</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token operator">*</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>            pos<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"readline: can`t find enter_key in the cmd_line, max num of char is 128\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节d：</p><p>解析键入的字符</p><p><code>cmd_parse</code>分析字符串cmd_str中以token为分隔符的单词，将各单词的指针存入argv数组。这个函数就是个字符串处理函数，从诸如 ‘ls dir ’ 这样的命令中拆单词，拆成 ‘ls’ 与 ‘dir’</p><p>修改（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define MAX_ARG_NR 16   &#x2F;&#x2F; 加上命令名外,最多支持15个参数&#x2F;* 分析字符串cmd_str中以token为分隔符的单词,将各单词的指针存入argv数组 *&#x2F;static int32_t cmd_parse(char *cmd_str, char **argv, char token)&#123;    ASSERT(cmd_str !&#x3D; NULL);    int32_t arg_idx &#x3D; 0;    while (arg_idx &lt; MAX_ARG_NR)    &#123;        argv[arg_idx] &#x3D; NULL;        arg_idx++;    &#125;    char *next &#x3D; cmd_str;    int32_t argc &#x3D; 0;    &#x2F;* 外层循环处理整个命令行 *&#x2F;    while (*next)    &#123;        &#x2F;* 去除命令字或参数之间的空格 *&#x2F;        while (*next &#x3D;&#x3D; token)        &#123;            next++;        &#125;        &#x2F;* 处理最后一个参数后接空格的情况,如&quot;ls dir2 &quot; *&#x2F;        if (*next &#x3D;&#x3D; 0)        &#123;            break;        &#125;        argv[argc] &#x3D; next;        &#x2F;* 内层循环处理命令行中的每个命令字及参数 *&#x2F;        while (*next &amp;&amp; *next !&#x3D; token)        &#123; &#x2F;&#x2F; 在字符串结束前找单词分隔符            next++;        &#125;        &#x2F;* 如果未结束(是token字符),使tocken变成0 *&#x2F;        if (*next)        &#123;            *next++ &#x3D; 0; &#x2F;&#x2F; 将token字符替换为字符串结束符0,做为一个单词的结束,并将字符指针next指向下一个字符        &#125;        &#x2F;* 避免argv数组访问越界,参数过多则返回0 *&#x2F;        if (argc &gt; MAX_ARG_NR)        &#123;            return -1;        &#125;        argc++;    &#125;    return argc;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>my_shell</code>增加测试代码， 输出每个分离出来的单词</p><p>修改（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span>MAX_ARG_NR<span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// argv必须为全局变量，为了以后exec的程序可访问参数</span><span class="token keyword">char</span> final_path<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 用于洗路径时的缓冲</span><span class="token class-name">int32_t</span> argc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cwd_cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print_prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>final_path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readline</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd_line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若只键入了一个回车</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        argc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        argc <span class="token operator">=</span> <span class="token function">cmd_parse</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num of arguments exceed %d\n"</span><span class="token punctuation">,</span> MAX_ARG_NR<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">int32_t</span> arg_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arg_idx <span class="token operator">&lt;</span> argc<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s "</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            arg_idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"my_shell: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节e：</p><p>实现输入命令，然后调用对应的函数</p><p>先实现一个ps系统调用</p><p><code>pad_print</code>用于对齐输出，也就是有一个buf区长度10字节，然后我们无论要输出什么，都向这个buf中写入，然后空余部分全部填充空格，最后将整个buf输出。比如输出“hello”，经过处理就变成了”hello “</p><p><code>elem2thread_info</code>调用<code>pad_print</code>来对齐输出每个pcb的pid, ppid, status, elapsed_ticks, name</p><p><code>sys_ps</code>调用<code>list_traversal</code>遍历所有任务队列，在其中回调<code>elem2thread_info</code>来输出进程或线程pcb中的信息</p><p>修改（<strong>thread/thread.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"file.h"</span></span><span class="token comment">/* 以填充空格的方式输出buf */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pad_print</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> buf_len<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token keyword">char</span> format<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> buf_len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> out_pad_0idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>format<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token char">'s'</span><span class="token operator">:</span>        out_pad_0idx <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token char">'d'</span><span class="token operator">:</span>        out_pad_0idx <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">int16_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token char">'x'</span><span class="token operator">:</span>        out_pad_0idx <span class="token operator">=</span> <span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"%x"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>out_pad_0idx <span class="token operator">&lt;</span> buf_len<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 以空格填充</span>        buf<span class="token punctuation">[</span>out_pad_0idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">;</span>        out_pad_0idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_write</span><span class="token punctuation">(</span>stdout_no<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> buf_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 用于在list_traversal函数中的回调函数,用于针对线程队列的处理 */</span><span class="token keyword">static</span> bool <span class="token function">elem2thread_info</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span> <span class="token operator">*</span>pelem<span class="token punctuation">,</span> <span class="token keyword">int</span> arg UNUSED<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>pthread <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> all_list_tag<span class="token punctuation">,</span> pelem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> out_pad<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pthread<span class="token operator">-></span>pid<span class="token punctuation">,</span> <span class="token char">'d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pthread<span class="token operator">-></span>parent_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"NULL"</span><span class="token punctuation">,</span> <span class="token char">'s'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pthread<span class="token operator">-></span>parent_pid<span class="token punctuation">,</span> <span class="token char">'d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>pthread<span class="token operator">-></span>status<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>        <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"RUNNING"</span><span class="token punctuation">,</span> <span class="token char">'s'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>        <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"READY"</span><span class="token punctuation">,</span> <span class="token char">'s'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>        <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"BLOCKED"</span><span class="token punctuation">,</span> <span class="token char">'s'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>        <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"WAITING"</span><span class="token punctuation">,</span> <span class="token char">'s'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">4</span><span class="token operator">:</span>        <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"HANGING"</span><span class="token punctuation">,</span> <span class="token char">'s'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>        <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"DIED"</span><span class="token punctuation">,</span> <span class="token char">'s'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">pad_print</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pthread<span class="token operator">-></span>elapsed_ticks<span class="token punctuation">,</span> <span class="token char">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>name<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> pthread<span class="token operator">-></span>name<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>pthread<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">,</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_write</span><span class="token punctuation">(</span>stdout_no<span class="token punctuation">,</span> out_pad<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>out_pad<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">// 此处返回false是为了迎合主调函数list_traversal,只有回调函数返回false时才会继续调用此函数</span><span class="token punctuation">&#125;</span><span class="token comment">/* 打印任务列表 */</span><span class="token keyword">void</span> <span class="token function">sys_ps</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ps_title <span class="token operator">=</span> <span class="token string">"PID            PPID           STAT           TICKS          COMMAND\n"</span><span class="token punctuation">;</span>    <span class="token function">sys_write</span><span class="token punctuation">(</span>stdout_no<span class="token punctuation">,</span> ps_title<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>ps_title<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> elem2thread_info<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加函数声明，修改（<strong>thread/thread.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sys_ps</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后将上一章和本章实现的sys开头的函数，全部封装成系统调用</p><p>首先添加系统调用号，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span><span class="token punctuation">&#123;</span>    SYS_GETPID<span class="token punctuation">,</span>    SYS_WRITE<span class="token punctuation">,</span>    SYS_MALLOC<span class="token punctuation">,</span>    SYS_FREE<span class="token punctuation">,</span>    SYS_FORK<span class="token punctuation">,</span>    SYS_READ<span class="token punctuation">,</span>    SYS_PUTCHAR<span class="token punctuation">,</span>    SYS_CLEAR<span class="token punctuation">,</span>    SYS_GETCWD<span class="token punctuation">,</span>    SYS_OPEN<span class="token punctuation">,</span>    SYS_CLOSE<span class="token punctuation">,</span>    SYS_LSEEK<span class="token punctuation">,</span>    SYS_UNLINK<span class="token punctuation">,</span>    SYS_MKDIR<span class="token punctuation">,</span>    SYS_OPENDIR<span class="token punctuation">,</span>    SYS_CLOSEDIR<span class="token punctuation">,</span>    SYS_CHDIR<span class="token punctuation">,</span>    SYS_RMDIR<span class="token punctuation">,</span>    SYS_READDIR<span class="token punctuation">,</span>    SYS_REWINDDIR<span class="token punctuation">,</span>    SYS_STAT<span class="token punctuation">,</span>    SYS_PS<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后实现它们的用户态入口，修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 获取当前工作目录 */</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">_syscall2</span><span class="token punctuation">(</span>SYS_GETCWD<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 以flag方式打开文件pathname */</span><span class="token class-name">int32_t</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> flag<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall2</span><span class="token punctuation">(</span>SYS_OPEN<span class="token punctuation">,</span> pathname<span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 关闭文件fd */</span><span class="token class-name">int32_t</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_CLOSE<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 设置文件偏移量 */</span><span class="token class-name">int32_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> offset<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> whence<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall3</span><span class="token punctuation">(</span>SYS_LSEEK<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 删除文件pathname */</span><span class="token class-name">int32_t</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_UNLINK<span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 创建目录pathname */</span><span class="token class-name">int32_t</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_MKDIR<span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 打开目录name */</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span><span class="token function">opendir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_OPENDIR<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 关闭目录dir */</span><span class="token class-name">int32_t</span> <span class="token function">closedir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_CLOSEDIR<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 删除目录pathname */</span><span class="token class-name">int32_t</span> <span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_RMDIR<span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 读取目录dir */</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token function">readdir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_READDIR<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 回归目录指针 */</span><span class="token keyword">void</span> <span class="token function">rewinddir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_REWINDDIR<span class="token punctuation">,</span> dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 获取path属性到buf中 */</span><span class="token class-name">int32_t</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall2</span><span class="token punctuation">(</span>SYS_STAT<span class="token punctuation">,</span> path<span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 改变工作目录为path */</span><span class="token class-name">int32_t</span> <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_CHDIR<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 显示任务列表 */</span><span class="token keyword">void</span> <span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">_syscall0</span><span class="token punctuation">(</span>SYS_PS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加系统调用用户态入口函数声明，修改修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> offset<span class="token punctuation">,</span> <span class="token class-name">uint8_t</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span><span class="token function">opendir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">closedir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span><span class="token function">readdir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">rewinddir</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">ps</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后在系统调用表中添加真正的系统调用执行函数，修改（<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_WRITE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_write<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MALLOC<span class="token punctuation">]</span> <span class="token operator">=</span> sys_malloc<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FREE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_free<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FORK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_fork<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READ<span class="token punctuation">]</span> <span class="token operator">=</span> sys_read<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PUTCHAR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_putchar<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLEAR<span class="token punctuation">]</span> <span class="token operator">=</span> cls_screen<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETCWD<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getcwd<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPEN<span class="token punctuation">]</span> <span class="token operator">=</span> sys_open<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_close<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_LSEEK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_lseek<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_UNLINK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_unlink<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MKDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_mkdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPENDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_opendir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSEDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_closedir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CHDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_chdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_RMDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rmdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_readdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_REWINDDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rewinddir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_STAT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_stat<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PS<span class="token punctuation">]</span> <span class="token operator">=</span> sys_ps<span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>操作系统为了方便用户使用，一般都会提供相对路径功能。比如我们当前工作路径是/home/kanshan/Desktop，我们想要运行一个编译好的程序输入./test，实际上是被操作系统解析成了/home/kanshan/Desktop/test，也就是当前工作路径 + 相对路径 = 绝对路径。</p><p><code>wash_path</code>将路径old_abs_path（这是调用者提供的绝对路径）中的…和.转换为实际路径后存入new_abs_path。例如，给定路径<code>/a/b/..</code>应被转换成<code>/a</code>。给定路径<code>/a/b/.</code>应被转换成<code>/a/b</code>。核心原理：调用<code>path_parse</code>解析路径，如果是<code>..</code>，则退回上一层路径。如果是<code>.</code>，则什么都不做。带入一个例子，比如<code>/a/../home/.</code>就可以明白次函数如何工作</p><p><code>make_clear_abs_path</code>将路径（包含相对路径与绝对路径两种）处理成不含…和.的绝对路径,存储在final_path中。核心原理：判断输入路径是相对路径还是绝对路径，如果是相对路径，调用getcwd获得当前工作目录的绝对路径，将用户输入的路径追加到工作目录路径之后形成绝对目录路径，将其作为参数传给<code>wash_path</code>进行路径转换。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"buildin_cmd.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"dir.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token comment">/* 将路径old_abs_path中的..和.转换为实际路径后存入new_abs_path */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">wash_path</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>old_abs_path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>new_abs_path<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>old_abs_path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span>MAX_FILE_NAME_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>sub_path <span class="token operator">=</span> old_abs_path<span class="token punctuation">;</span>    sub_path <span class="token operator">=</span> <span class="token function">path_parse</span><span class="token punctuation">(</span>sub_path<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若只键入了"/",直接将"/"存入new_abs_path后返回</span>        new_abs_path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>        new_abs_path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    new_abs_path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 避免传给new_abs_path的缓冲区不干净</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>new_abs_path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* 如果是上一级目录“..” */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">".."</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> <span class="token operator">*</span>slash_ptr <span class="token operator">=</span> <span class="token function">strrchr</span><span class="token punctuation">(</span>new_abs_path<span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/*如果未到new_abs_path中的顶层目录,就将最右边的'/'替换为0,            这样便去除了new_abs_path中最后一层路径,相当于到了上一级目录 */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>slash_ptr <span class="token operator">!=</span> new_abs_path<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 如new_abs_path为“/a/b”,".."之后则变为“/a”</span>                <span class="token operator">*</span>slash_ptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>   <span class="token comment">// 如new_abs_path为"/a",".."之后则变为"/"</span>                <span class="token comment">/* 若new_abs_path中只有1个'/',即表示已经到了顶层目录,                就将下一个字符置为结束符0. */</span>                <span class="token operator">*</span><span class="token punctuation">(</span>slash_ptr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 如果路径不是‘.’,就将name拼接到new_abs_path</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>new_abs_path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 如果new_abs_path不是"/",就拼接一个"/",此处的判断是为了避免路径开头变成这样"//"</span>                <span class="token function">strcat</span><span class="token punctuation">(</span>new_abs_path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">strcat</span><span class="token punctuation">(</span>new_abs_path<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">// 若name为当前目录".",无须处理new_abs_path</span>        <span class="token comment">/* 继续遍历下一层路径 */</span>        <span class="token function">memset</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_FILE_NAME_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sub_path<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            sub_path <span class="token operator">=</span> <span class="token function">path_parse</span><span class="token punctuation">(</span>sub_path<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 将path处理成不含..和.的绝对路径,存储在final_path */</span><span class="token keyword">void</span> <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>final_path<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> abs_path<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">/* 先判断是否输入的是绝对路径 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若输入的不是绝对路径,就拼接成绝对路径</span>        <span class="token function">memset</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getcwd</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'/'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>abs_path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 若abs_path表示的当前目录不是根目录/</span>                <span class="token function">strcat</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">wash_path</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题1：代码中：new_abs_path[0] = 0;意义何在？</p><p>确保了后续在<code>new_abs_path</code>上的任何字符串连接（例如通过<code>strcat</code>函数）都会从头开始。</p><p>函数声明，（<strong>shell/buildin_cmd.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__SHELL_BUILDIN_CMD_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__SHELL_BUILDIN_CMD_H</span></span><span class="token keyword">void</span> <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>final_path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码，修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">path_parse</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name_store<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">path_parse</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name_store<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>my_shell</code>增加测试代码，修改（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"buildin_cmd.h"</span></span><span class="token keyword">void</span> <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cwd_cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>    cwd_cache<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print_prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>final_path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readline</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd_line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若只键入了一个回车</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        argc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        argc <span class="token operator">=</span> <span class="token function">cmd_parse</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num of arguments exceed %d\n"</span><span class="token punctuation">,</span> MAX_ARG_NR<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">int32_t</span> arg_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arg_idx <span class="token operator">&lt;</span> argc<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s -> %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            arg_idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"my_shell: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节f：</p><p>实现一系列内建命令</p><p>shell命令分为外部命令与内部命令。执行外部命令，实际上就是执行了一个进程。而内部命令，就是执行操作系统自带的函数。我们现在来实现一系列内部命令所需要的内建函数。</p><p>每个内建函数都会传入两个参数：</p><ol><li><code>uint32_t argc</code>: 这个参数表示传入到该函数的参数个数。在命令 <code>ls -l</code> 中，<code>ls</code> 是命令，而 <code>-l</code> 是<code>ls</code>的参数。在这个例子中，<code>argc</code> 就是2，因为有两个参数：<code>ls</code> 和 <code>-l</code>。</li><li><code>char** argv</code>: 这是一个指向字符串数组的指针，代表传入的参数值。<code>argv</code> 的每一个元素都是一个字符串，表示命令行上的一个参数。</li></ol><p><code>buildin_pwd</code>就是调用了`getcwd</p><p>修改（<strong>shell/buildin_cmd.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shell.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token comment">/* pwd命令的内建函数 */</span><span class="token keyword">void</span> <span class="token function">buildin_pwd</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv UNUSED<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pwd: no argument support!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>final_path<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"pwd: get current work directory failed.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码，修改（<strong>shell/shell.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token keyword">extern</span> <span class="token keyword">char</span> final_path<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>buildin_cd</code>就是调用了<code>make_clear_abs_path</code>解析<code>argv[1]</code>成绝对路径，然后调用<code>chdir</code>来切换目录</p><p>修改（<strong>shell/buildin_cmd.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* cd命令的内建函数 */</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">buildin_cd</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cd: only support 1 argument!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 若是只键入cd而无参数,直接返回到根目录. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        final_path<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>        final_path<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">chdir</span><span class="token punctuation">(</span>final_path<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cd: no such directory %s\n"</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> final_path<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>buildin_ls</code>:用于列出文件或目录</p><p>函数核心原理：</p><ol><li><p>命令行参数解析:使用while循环遍历所有的命令行参数argv，并进行以下处理：</p><ul><li>如果参数以 <code>-</code> 开头，那么它被视为一个选项。目前支持两个选项：<code>-l</code> 和 <code>-h</code>。其中 <code>-l</code> 选项使信息以长格式输出，而 <code>-h</code> 选项则打印帮助信息</li><li>如果参数不是一个选项，则被视为一个路径参数。函数只支持一个路径参数。</li></ul></li><li><p><strong>设置默认路径</strong>:<br>如果用户未提供路径参数，函数将使用当前工作目录作为默认路径。</p></li><li><p><strong>获取文件或目录状态</strong>:<br>使用 <code>stat</code> 函数检查指定路径文件或目录的状态。如果路径不存在，函数将打印错误信息并返回。</p></li><li><p>目录处理</p><p>如果指定的路径是一个目录：</p><ul><li>打开这个目录。</li><li>如果使用了 <code>-l</code> 选项，则以长格式输出目录中的每个目录项。这包括文件类型（目录或普通文件）、i节点号、文件大小和文件名。</li><li>如果没有使用 <code>-l</code> 选项，则只输出文件名。</li><li>最后，关闭目录。</li></ul></li><li><p>文件处理</p><p>如果指定的路径是一个文件：</p><ul><li>如果使用了 <code>-l</code> 选项，则以长格式输出文件的信息。</li><li>如果没有使用 <code>-l</code> 选项，则只输出文件名。</li></ul></li></ol><p>修改（<strong>shell/buildin_cmd.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ls命令的内建函数 */</span><span class="token keyword">void</span> <span class="token function">buildin_ls</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>pathname <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">stat</span> file_stat<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_stat<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">stat</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    bool long_info <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> arg_path_nr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> arg_idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 跨过argv[0],argv[0]是字符串“ls”</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>arg_idx <span class="token operator">&lt;</span> argc<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'-'</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 如果是选项,单词的首字符是-</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"-l"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 如果是参数-l</span>                long_info <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"-h"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 参数-h</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usage: -l list all infomation about the file.\n-h for help\nlist all files in the current dirctory if no option\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 只支持-h -l两个选项</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ls: invalid option %s\nTry `ls -h' for more information.\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// ls的路径参数</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arg_path_nr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                pathname <span class="token operator">=</span> argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span><span class="token punctuation">;</span>                arg_path_nr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ls: only support one path\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        arg_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pathname <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若只输入了ls 或 ls -l,没有输入操作路径,默认以当前路径的绝对路径为参数.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">!=</span> <span class="token function">getcwd</span><span class="token punctuation">(</span>final_path<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            pathname <span class="token operator">=</span> final_path<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ls: getcwd for default path failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        pathname <span class="token operator">=</span> final_path<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>file_stat<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ls: cannot access %s: No such file or directory\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file_stat<span class="token punctuation">.</span>st_filetype <span class="token operator">==</span> FT_DIRECTORY<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">struct</span> <span class="token class-name">dir</span> <span class="token operator">*</span>dir <span class="token operator">=</span> <span class="token function">opendir</span><span class="token punctuation">(</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">dir_entry</span> <span class="token operator">*</span>dir_e <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> sub_pathname<span class="token punctuation">[</span>MAX_PATH_LEN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">uint32_t</span> pathname_len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">uint32_t</span> last_char_idx <span class="token operator">=</span> pathname_len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span>sub_pathname<span class="token punctuation">,</span> pathname<span class="token punctuation">,</span> pathname_len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sub_pathname<span class="token punctuation">[</span>last_char_idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            sub_pathname<span class="token punctuation">[</span>pathname_len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>            pathname_len<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">rewinddir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>long_info<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> ftype<span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"total: %d\n"</span><span class="token punctuation">,</span> file_stat<span class="token punctuation">.</span>st_size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">=</span> <span class="token function">readdir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                ftype <span class="token operator">=</span> <span class="token char">'d'</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dir_e<span class="token operator">-></span>f_type <span class="token operator">==</span> FT_REGULAR<span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    ftype <span class="token operator">=</span> <span class="token char">'-'</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                sub_pathname<span class="token punctuation">[</span>pathname_len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token function">strcat</span><span class="token punctuation">(</span>sub_pathname<span class="token punctuation">,</span> dir_e<span class="token operator">-></span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_stat<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">stat</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>sub_pathname<span class="token punctuation">,</span> <span class="token operator">&amp;</span>file_stat<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ls: cannot access %s: No such file or directory\n"</span><span class="token punctuation">,</span> dir_e<span class="token operator">-></span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c  %d  %d  %s\n"</span><span class="token punctuation">,</span> ftype<span class="token punctuation">,</span> dir_e<span class="token operator">-></span>i_no<span class="token punctuation">,</span> file_stat<span class="token punctuation">.</span>st_size<span class="token punctuation">,</span> dir_e<span class="token operator">-></span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dir_e <span class="token operator">=</span> <span class="token function">readdir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s "</span><span class="token punctuation">,</span> dir_e<span class="token operator">-></span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">closedir</span><span class="token punctuation">(</span>dir<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>long_info<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-  %d  %d  %s\n"</span><span class="token punctuation">,</span> file_stat<span class="token punctuation">.</span>st_ino<span class="token punctuation">,</span> file_stat<span class="token punctuation">.</span>st_size<span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> pathname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改（<strong>shell/buildin_cmd.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ps命令内建函数 */</span><span class="token keyword">void</span> <span class="token function">buildin_ps</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv UNUSED<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ps: no argument support!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">ps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>buildin_clear</code>就是调用`clear</p><p>修改（<strong>shell/buildin_cmd.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* clear命令内建函数 */</span><span class="token keyword">void</span> <span class="token function">buildin_clear</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv UNUSED<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"clear: no argument support!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>buildin_mkdir</code>就是调用<code>make_clear_abs_path</code>解析<code>argv[1]</code>成绝对路径，然后调用`mkdir</p><p>修改（<strong>shell/buildin_cmd.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* mkdir命令内建函数 */</span><span class="token class-name">int32_t</span> <span class="token function">buildin_mkdir</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"mkdir: only support 1 argument!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 若创建的不是根目录 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mkdir</span><span class="token punctuation">(</span>final_path<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"mkdir: create directory %s failed.\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>buildin_rmdir</code>就是调用<code>make_clear_abs_path</code>解析<code>argv[1]</code>成绝对路径，然后调用`rmdir</p><p>修改（<strong>shell/buildin_cmd.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* rmdir命令内建函数 */</span><span class="token class-name">int32_t</span> <span class="token function">buildin_rmdir</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rmdir: only support 1 argument!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 若删除的不是根目录 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">rmdir</span><span class="token punctuation">(</span>final_path<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rmdir: remove %s failed.\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>buildin_rm</code>就是调用<code>make_clear_abs_path</code>解析<code>argv[1]</code>成绝对路径，然后调用`unlink</p><p>修改（<strong>shell/buildin_cmd.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* rm命令内建函数 */</span><span class="token class-name">int32_t</span> <span class="token function">buildin_rm</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rm: only support 1 argument!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 若删除的不是根目录 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlink</span><span class="token punctuation">(</span>final_path<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"rm: delete %s failed.\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>shell/buildin_cmd.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token keyword">void</span> <span class="token function">buildin_pwd</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv UNUSED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">buildin_cd</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">buildin_ls</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">buildin_ps</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv UNUSED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">buildin_clear</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv UNUSED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">buildin_mkdir</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">buildin_rmdir</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">int32_t</span> <span class="token function">buildin_rm</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>my_shell</code>就是增加了通过判断arg[0]（这个是要调用的命令名）是什么，然后对应调用内建函数</p><p>修改（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cwd_cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print_prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>final_path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readline</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd_line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若只键入了一个回车</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        argc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        argc <span class="token operator">=</span> <span class="token function">cmd_parse</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num of arguments exceed %d\n"</span><span class="token punctuation">,</span> MAX_ARG_NR<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_ls</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"cd"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">buildin_cd</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">memset</span><span class="token punctuation">(</span>cwd_cache<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">strcpy</span><span class="token punctuation">(</span>cwd_cache<span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_pwd</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"ps"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_ps</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"clear"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_clear</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"mkdir"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_mkdir</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"rmdir"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_rmdir</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"rm"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_rm</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"external command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"my_shell: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节g：</p><p>加载用户进程</p><p><code>segment_load</code>将文件描述符fd指向的文件中，偏移为offset，大小为filesz的段加载到虚拟地址为vaddr的内存。核心原理：我们编译程序后，编译器已经指定好了可加载段的虚拟地址，我们直接按照这个虚拟地址，把段加载到内存中对应的虚拟地址就可以了。由于这个函数是<code>fork</code>之后从磁盘编译好的程序加载可加载段时使用，所以我们使用的是调用fork的进程的页表，所以我们要判断目的内存虚拟地址是否在页表中有效，如果无效，则为指定虚拟地址申请物理内存。申请内存完毕，我们调用<code>sys_read</code>从磁盘中加载可加载段到指定内存虚拟地址中即可。</p><p>（<strong>userprog/exec.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"exec.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"memory.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token keyword">typedef</span> <span class="token class-name">uint32_t</span> Elf32_Word<span class="token punctuation">,</span> Elf32_Addr<span class="token punctuation">,</span> Elf32_Off<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token class-name">uint16_t</span> Elf32_Half<span class="token punctuation">;</span><span class="token comment">/* 32位elf头 */</span><span class="token keyword">struct</span> <span class="token class-name">Elf32_Ehdr</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> e_ident<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    Elf32_Half e_type<span class="token punctuation">;</span>    Elf32_Half e_machine<span class="token punctuation">;</span>    Elf32_Word e_version<span class="token punctuation">;</span>    Elf32_Addr e_entry<span class="token punctuation">;</span>    Elf32_Off e_phoff<span class="token punctuation">;</span>    Elf32_Off e_shoff<span class="token punctuation">;</span>    Elf32_Word e_flags<span class="token punctuation">;</span>    Elf32_Half e_ehsize<span class="token punctuation">;</span>    Elf32_Half e_phentsize<span class="token punctuation">;</span>    Elf32_Half e_phnum<span class="token punctuation">;</span>    Elf32_Half e_shentsize<span class="token punctuation">;</span>    Elf32_Half e_shnum<span class="token punctuation">;</span>    Elf32_Half e_shstrndx<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* 程序头表Program header.就是段描述头 */</span><span class="token keyword">struct</span> <span class="token class-name">Elf32_Phdr</span><span class="token punctuation">&#123;</span>    Elf32_Word p_type<span class="token punctuation">;</span> <span class="token comment">// 见下面的enum segment_type</span>    Elf32_Off p_offset<span class="token punctuation">;</span>    Elf32_Addr p_vaddr<span class="token punctuation">;</span>    Elf32_Addr p_paddr<span class="token punctuation">;</span>    Elf32_Word p_filesz<span class="token punctuation">;</span>    Elf32_Word p_memsz<span class="token punctuation">;</span>    Elf32_Word p_flags<span class="token punctuation">;</span>    Elf32_Word p_align<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* 段类型 */</span><span class="token keyword">enum</span> <span class="token class-name">segment_type</span><span class="token punctuation">&#123;</span>    PT_NULL<span class="token punctuation">,</span>    <span class="token comment">// 忽略</span>    PT_LOAD<span class="token punctuation">,</span>    <span class="token comment">// 可加载程序段</span>    PT_DYNAMIC<span class="token punctuation">,</span> <span class="token comment">// 动态加载信息</span>    PT_INTERP<span class="token punctuation">,</span>  <span class="token comment">// 动态加载器名称</span>    PT_NOTE<span class="token punctuation">,</span>    <span class="token comment">// 一些辅助信息</span>    PT_SHLIB<span class="token punctuation">,</span>   <span class="token comment">// 保留</span>    PT_PHDR     <span class="token comment">// 程序头表</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* 将文件描述符fd指向的文件中,偏移为offset,大小为filesz的段加载到虚拟地址为vaddr的内存 */</span><span class="token keyword">static</span> bool <span class="token function">segment_load</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> offset<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> filesz<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> vaddr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> vaddr_first_page <span class="token operator">=</span> vaddr <span class="token operator">&amp;</span> <span class="token number">0xfffff000</span><span class="token punctuation">;</span>               <span class="token comment">// vaddr地址所在的页框</span>    <span class="token class-name">uint32_t</span> size_in_first_page <span class="token operator">=</span> PG_SIZE <span class="token operator">-</span> <span class="token punctuation">(</span>vaddr <span class="token operator">&amp;</span> <span class="token number">0x00000fff</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加载到内存后,文件在第一个页框中占用的字节大小</span>    <span class="token class-name">uint32_t</span> occupy_pages <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 若一个页框容不下该段 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>filesz <span class="token operator">></span> size_in_first_page<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">uint32_t</span> left_size <span class="token operator">=</span> filesz <span class="token operator">-</span> size_in_first_page<span class="token punctuation">;</span>        occupy_pages <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>left_size<span class="token punctuation">,</span> PG_SIZE<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 1是指vaddr_first_page</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        occupy_pages <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 为进程分配内存 */</span>    <span class="token class-name">uint32_t</span> page_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> vaddr_page <span class="token operator">=</span> vaddr_first_page<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>page_idx <span class="token operator">&lt;</span> occupy_pages<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">uint32_t</span> <span class="token operator">*</span>pde <span class="token operator">=</span> <span class="token function">pde_ptr</span><span class="token punctuation">(</span>vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">uint32_t</span> <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">pte_ptr</span><span class="token punctuation">(</span>vaddr_page<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 如果pde不存在,或者pte不存在就分配内存.         * pde的判断要在pte之前,否则pde若不存在会导致         * 判断pte时缺页异常 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>pde <span class="token operator">&amp;</span> <span class="token number">0x00000001</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> <span class="token number">0x00000001</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_a_page</span><span class="token punctuation">(</span>PF_USER<span class="token punctuation">,</span> vaddr_page<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> false<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token comment">// 如果原进程的页表已经分配了,利用现有的物理页,直接覆盖进程体</span>        vaddr_page <span class="token operator">+=</span> PG_SIZE<span class="token punctuation">;</span>        page_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sys_lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>vaddr<span class="token punctuation">,</span> filesz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> true<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>load</code>根据传入的路径，加载磁盘中的程序的可加载段，最后返回程序入口地址。原理：编译好的程序在磁盘中，起始就是ELF header，我们去把这个读出来，从中得到program header的偏移、数量、每个大小。然后我们根据这些信息去循环读出program header，根据每个program header信息去调用<code>segment_load</code>将可加载段加载到内存中。</p><p>修改（<strong>userprog/exec.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token comment">/* 从文件系统上加载用户程序pathname,成功则返回程序的起始地址,否则返回-1 */</span><span class="token keyword">static</span> <span class="token class-name">int32_t</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Elf32_Ehdr</span> elf_header<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">Elf32_Phdr</span> prog_header<span class="token punctuation">;</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>elf_header<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Elf32_Ehdr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>elf_header<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Elf32_Ehdr</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Elf32_Ehdr</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> done<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 校验elf头 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">memcmp</span><span class="token punctuation">(</span>elf_header<span class="token punctuation">.</span>e_ident<span class="token punctuation">,</span> <span class="token string">"\177ELF\1\1\1"</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">||</span> elf_header<span class="token punctuation">.</span>e_type <span class="token operator">!=</span> <span class="token number">2</span> <span class="token operator">||</span> elf_header<span class="token punctuation">.</span>e_machine <span class="token operator">!=</span> <span class="token number">3</span> <span class="token operator">||</span> elf_header<span class="token punctuation">.</span>e_version <span class="token operator">!=</span> <span class="token number">1</span> <span class="token operator">||</span> elf_header<span class="token punctuation">.</span>e_phnum <span class="token operator">></span> <span class="token number">1024</span> <span class="token operator">||</span> elf_header<span class="token punctuation">.</span>e_phentsize <span class="token operator">!=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Elf32_Phdr</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> done<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Elf32_Off prog_header_offset <span class="token operator">=</span> elf_header<span class="token punctuation">.</span>e_phoff<span class="token punctuation">;</span>    Elf32_Half prog_header_size <span class="token operator">=</span> elf_header<span class="token punctuation">.</span>e_phentsize<span class="token punctuation">;</span>    <span class="token comment">/* 遍历所有程序头 */</span>    <span class="token class-name">uint32_t</span> prog_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>prog_idx <span class="token operator">&lt;</span> elf_header<span class="token punctuation">.</span>e_phnum<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>prog_header<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> prog_header_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 将文件的指针定位到程序头 */</span>        <span class="token function">sys_lseek</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> prog_header_offset<span class="token punctuation">,</span> <span class="token constant">SEEK_SET</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 只获取程序头 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>prog_header<span class="token punctuation">,</span> prog_header_size<span class="token punctuation">)</span> <span class="token operator">!=</span> prog_header_size<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> done<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 如果是可加载段就调用segment_load加载到内存 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>PT_LOAD <span class="token operator">==</span> prog_header<span class="token punctuation">.</span>p_type<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">segment_load</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> prog_header<span class="token punctuation">.</span>p_offset<span class="token punctuation">,</span> prog_header<span class="token punctuation">.</span>p_filesz<span class="token punctuation">,</span> prog_header<span class="token punctuation">.</span>p_vaddr<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">goto</span> done<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 更新下一个程序头的偏移 */</span>        prog_header_offset <span class="token operator">+=</span> elf_header<span class="token punctuation">.</span>e_phentsize<span class="token punctuation">;</span>        prog_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ret <span class="token operator">=</span> elf_header<span class="token punctuation">.</span>e_entry<span class="token punctuation">;</span>done<span class="token operator">:</span>    <span class="token function">sys_close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C和C++中，使用<code>\xHH</code>格式的十六进制转义序列时，需要特别小心，因为这个序列会继续解析所有有效的十六进制数字，直到遇到一个非十六进制数字或序列的长度达到其最大值。字符串 <code>&quot;\x7fELF&quot;</code> 会被解析为一个字符 <code>\x7fE</code>，然后是 <code>LF</code>，而不是我们预期的 <code>\x7f</code> 和 <code>ELF</code>。</p><p><code>sys_execv</code>用path指向的程序替换当前进程，注意，这个函数是<code>fork</code>之后调用的。原理：先调用<code>load</code>加载程序可执行段到内存中，并得到了程序入口地址。然后修改pcb中的数据即可，包括：程序名字、内核栈中中断栈中用于传参的寄存器（该函数运行在内核态下，通过<code>intr_exit</code>返回到用户态执行新的进程，所以中断栈中的数据会被<code>intr_exit</code>的push操作送入寄存器，以此达到传参目的）、中断栈中eip用于跳转程序入口、中断栈esp用于设定新进程的栈顶位置（<code>fork</code>中拷贝了父进程页表、重新申请了物理地址空间用于拷贝用户栈数据，所以并不用担心新进程用户栈用到的虚拟地址没有映射物理地址）。最后通过内联汇编设定esp为中断栈的位置，然后跳转执行<code>intr_exit</code>，就可以执行新的进程了。</p><p>修改（<strong>userprog/exec.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token comment">/* 用path指向的程序替换当前进程 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> argc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>argc<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        argc<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">int32_t</span> entry_point <span class="token operator">=</span> <span class="token function">load</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry_point <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若加载失败则返回-1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 修改进程名 */</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>name<span class="token punctuation">,</span> path<span class="token punctuation">,</span> TASK_NAME_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    cur<span class="token operator">-></span>name<span class="token punctuation">[</span>TASK_NAME_LEN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">intr_stack</span> <span class="token operator">*</span>intr_0_stack <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">intr_stack</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span>cur <span class="token operator">+</span> PG_SIZE <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">intr_stack</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 参数传递给用户进程 */</span>    intr_0_stack<span class="token operator">-></span>ebx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span>argv<span class="token punctuation">;</span>    intr_0_stack<span class="token operator">-></span>ecx <span class="token operator">=</span> argc<span class="token punctuation">;</span>    intr_0_stack<span class="token operator">-></span>eip <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>entry_point<span class="token punctuation">;</span>    <span class="token comment">/* 使新用户进程的栈地址为最高用户空间地址 */</span>    intr_0_stack<span class="token operator">-></span>esp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0xc0000000</span><span class="token punctuation">;</span>    <span class="token comment">/* exec不同于fork,为使新进程更快被执行,直接从中断返回 */</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"movl %0, %%esp; jmp intr_exit"</span> <span class="token operator">:</span> <span class="token operator">:</span> <span class="token string">"g"</span><span class="token punctuation">(</span>intr_0_stack<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token string">"memory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码，修改（<strong>thread/thread.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TASK_NAME_LEN</span> <span class="token expression"><span class="token number">16</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>sys_execv</code>做成系统调用</p><p>添加系统调用号，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span><span class="token punctuation">&#123;</span>    SYS_GETPID<span class="token punctuation">,</span>    SYS_WRITE<span class="token punctuation">,</span>    SYS_MALLOC<span class="token punctuation">,</span>    SYS_FREE<span class="token punctuation">,</span>    SYS_FORK<span class="token punctuation">,</span>    SYS_READ<span class="token punctuation">,</span>    SYS_PUTCHAR<span class="token punctuation">,</span>    SYS_CLEAR<span class="token punctuation">,</span>    SYS_GETCWD<span class="token punctuation">,</span>    SYS_OPEN<span class="token punctuation">,</span>    SYS_CLOSE<span class="token punctuation">,</span>    SYS_LSEEK<span class="token punctuation">,</span>    SYS_UNLINK<span class="token punctuation">,</span>    SYS_MKDIR<span class="token punctuation">,</span>    SYS_OPENDIR<span class="token punctuation">,</span>    SYS_CLOSEDIR<span class="token punctuation">,</span>    SYS_CHDIR<span class="token punctuation">,</span>    SYS_RMDIR<span class="token punctuation">,</span>    SYS_READDIR<span class="token punctuation">,</span>    SYS_REWINDDIR<span class="token punctuation">,</span>    SYS_STAT<span class="token punctuation">,</span>    SYS_PS<span class="token punctuation">,</span>    SYS_EXECV<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用户态系统调用入口，修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall2</span><span class="token punctuation">(</span>SYS_EXECV<span class="token punctuation">,</span> pathname<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>声明用户态系统调用入口，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> pathname<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>系统调用表修改，修改（<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"exec.h"</span></span><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_WRITE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_write<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MALLOC<span class="token punctuation">]</span> <span class="token operator">=</span> sys_malloc<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FREE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_free<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FORK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_fork<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READ<span class="token punctuation">]</span> <span class="token operator">=</span> sys_read<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PUTCHAR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_putchar<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLEAR<span class="token punctuation">]</span> <span class="token operator">=</span> cls_screen<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETCWD<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getcwd<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPEN<span class="token punctuation">]</span> <span class="token operator">=</span> sys_open<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_close<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_LSEEK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_lseek<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_UNLINK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_unlink<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MKDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_mkdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPENDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_opendir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSEDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_closedir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CHDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_chdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_RMDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rmdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_readdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_REWINDDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rewinddir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_STAT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_stat<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PS<span class="token punctuation">]</span> <span class="token operator">=</span> sys_ps<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_EXECV<span class="token punctuation">]</span> <span class="token operator">=</span> sys_execv<span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改<code>my_shell</code>增加对于外部命令去磁盘加载编译好的二进制进程序并执行的代码，核心就是先<code>fork</code>创建子进程，然后子进程调用<code>make_clear_abs_path</code>解析传入的路径，然后调用<code>execv</code>去执行</p><p>修改（<strong>shell/shell.c/my_shell</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token keyword">void</span> <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cwd_cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print_prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>final_path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readline</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd_line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若只键入了一个回车</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        argc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        argc <span class="token operator">=</span> <span class="token function">cmd_parse</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num of arguments exceed %d\n"</span><span class="token punctuation">,</span> MAX_ARG_NR<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_ls</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"cd"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">buildin_cd</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">memset</span><span class="token punctuation">(</span>cwd_cache<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">strcpy</span><span class="token punctuation">(</span>cwd_cache<span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_pwd</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"ps"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_ps</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"clear"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_clear</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"mkdir"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_mkdir</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"rmdir"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_rmdir</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"rm"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">buildin_rm</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 如果是外部命令,需要从磁盘上加载</span>            <span class="token class-name">int32_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>                <span class="token comment">/* 下面这个while必须要加上,否则父进程一般情况下会比子进程先执行,                因此会进行下一轮循环将findl_path清空,这样子进程将无法从final_path中获得参数*/</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>                <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>                argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> final_path<span class="token punctuation">;</span>                <span class="token comment">/* 先判断下文件是否存在 */</span>                <span class="token keyword">struct</span> <span class="token class-name">stat</span> file_stat<span class="token punctuation">;</span>                <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_stat<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">stat</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>file_stat<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my_shell: cannot access %s: No such file or directory\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">else</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">execv</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">int32_t</span> arg_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arg_idx <span class="token operator">&lt;</span> MAX_ARG_NR<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            arg_idx<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"my_shell: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译好一个用户程序<code>prog_no_arg</code>，我们需要自行写入hd60M.img，然后用操作系统从hd60M.img中取到编译好的用户程序到内存，再写入有文件系统的hd80M.img，最后再执行<code>prog_no_arg</code></p><p>（<strong>command/prog_no_arg.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prog_no_arg from disk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于这个程序复用了printf，而printf调用了vsprintf，而vsprintf调用了strcpy，而strcpy调用了ASSERT宏，而ASSERT使用了PANIC，而PANIC使用了panic_spin，而panic_spin使用了，intr_disable()。也就是说，我们调用用户态printf的程序，如果中间strcpy的ASSERT出错，将会直接在用户态调用intr_disable，这是绝对不能允许的，运行会报特权级保护错误！正确的做法是，先通过系统调用切换至内核态，然后再调用intr_disable。</p><p>所以，我们先实现用户态使用的assert</p><p>（<strong>lib/user/assert.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"assert.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token keyword">void</span> <span class="token function">user_spin</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">int</span> line<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>func<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>condition<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n\n\n\nfilename %s\nline %d\nfunction %s\ncondition %s\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">,</span> line<span class="token punctuation">,</span> func<span class="token punctuation">,</span> condition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（<strong>lib/user/assert.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__LIB_USER_ASSERT_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__LIB_USER_ASSERT_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token keyword">void</span> <span class="token function">user_spin</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">int</span> line<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>func<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">panic</span><span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token function">user_spin</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">,</span> __VA_ARGS__<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">NDEBUG</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">assert</span><span class="token expression"><span class="token punctuation">(</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">assert</span><span class="token expression"><span class="token punctuation">(</span>CONDITION<span class="token punctuation">)</span>  </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">)</span>      </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">&#123;</span>                      </span><span class="token punctuation">\</span>        <span class="token expression"><span class="token function">panic</span><span class="token punctuation">(</span>#CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token punctuation">&#125;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/*NDEBUG*/</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/*__LIB_USER_ASSERT_H*/</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如此一来，我们的<code>assert</code>判断出错，将会通过<code>printf</code>内的<code>write</code>系统调用正常进入内核态</p><p>我们去把内核中<strong>用户态</strong>程序用到的ASSERT与PANIC都改掉</p><p>修改（<strong>lib/string.c</strong>）中所有的<code>ASSERT</code>为<code>assert</code>，然后将头文件<code>#include &quot;debug.h&quot;</code>修改为<code>#incldue &quot;assert.h&quot;</code></p><p>修改（<strong>shell/buildin_cmd.c</strong>）中所有的<code>ASSERT</code>为<code>assert</code>，然后将头文件<code>#include &quot;debug.h&quot;</code>修改为<code>#incldue &quot;assert.h&quot;</code></p><p>修改（<strong>shell/shell.c</strong>）中所有的<code>ASSERT</code>为<code>assert</code>，修改所有的<code>PANIC</code>为<code>panic</code>，然后将头文件<code>#include &quot;debug.h&quot;</code>修改为<code>#incldue &quot;assert.h&quot;</code></p><p>修改（<strong>kernel/main.c</strong>）中所有的<code>PANIC</code>为<code>panic</code>，然后将头文件<code>#include &quot;debug.h&quot;</code>修改为<code>#incldue &quot;assert.h&quot;</code></p><p>给出操作prog_no_arg.c的脚本，该脚本主要功能：编译prog_no_arg.c，然后将其与使用到的.o文件进行链接（这里我们复用了给操作系统用的.o文件，按道理来说，我们需要单独实现用户程序的.o文件，但是我们偷个懒吧），最后写入磁盘hd60M.img偏移300扇区的位置</p><p>注意：相较于作者脚本，已经修改好了用到的编译器为gcc-4.4，CFLAGS，ld后面的参数，<strong>一定要自行修改<code>DD_OUT</code>为自己环境中的hd60M.img路径！！！</strong>运行脚本需要在操作系统make all之后（这样用到的.o文件才会出现在build目录下），运行脚本需要在command目录下，脚本运行前需要添加可执行权限，命令：<code>chmod +x compile.sh</code>，执行脚本命令：<code>./compile.sh</code></p><p>（<strong>command/compile.sh</strong>）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">####  此脚本应该在command目录下执行</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"../lib"</span> <span class="token operator">||</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"../build"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"dependent dir don\`t exist!"</span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable">$&#123;cwd<span class="token operator">##</span>*<span class="token operator">/</span>&#125;</span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable">$&#123;cwd<span class="token operator">%</span><span class="token operator">/</span>&#125;</span>   <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$cwd</span> <span class="token operator">!=</span> <span class="token string">"command"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>      <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"you\`d better in command dir<span class="token entity" title="\n">\n</span>"</span>   <span class="token keyword">fi</span>    <span class="token builtin class-name">exit</span><span class="token keyword">fi</span><span class="token assign-left variable">CC</span><span class="token operator">=</span><span class="token string">"gcc-4.4"</span><span class="token assign-left variable">BIN</span><span class="token operator">=</span><span class="token string">"prog_no_arg"</span><span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">"-Wall -c -fno-builtin -W -Wstrict-prototypes \      -Wmissing-prototypes -Wsystem-headers -m32 -fno-stack-protector"</span><span class="token assign-left variable">LIB</span><span class="token operator">=</span><span class="token string">"../lib/"</span><span class="token assign-left variable">OBJS</span><span class="token operator">=</span><span class="token string">"../build/string.o ../build/syscall.o \      ../build/stdio.o ../build/assert.o"</span><span class="token assign-left variable">DD_IN</span><span class="token operator">=</span><span class="token variable">$BIN</span><span class="token assign-left variable">DD_OUT</span><span class="token operator">=</span><span class="token string">"/home/rlk/Desktop/bochs/hd60M.img"</span> <span class="token variable">$CC</span> <span class="token variable">$CFLAGS</span> <span class="token parameter variable">-I</span> <span class="token variable">$LIB</span> <span class="token parameter variable">-o</span> <span class="token variable">$BIN</span><span class="token string">".o"</span> <span class="token variable">$BIN</span><span class="token string">".c"</span>ld <span class="token parameter variable">-e</span> main <span class="token variable">$BIN</span><span class="token string">".o"</span> <span class="token variable">$OBJS</span> <span class="token parameter variable">-o</span> <span class="token variable">$BIN</span> <span class="token parameter variable">-m</span> elf_i386<span class="token assign-left variable">SEC_CNT</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> <span class="token parameter variable">-l</span> $BIN<span class="token operator">|</span><span class="token function">awk</span> '<span class="token punctuation">&#123;</span>printf<span class="token punctuation">(</span><span class="token string">"%d"</span>, <span class="token punctuation">(</span>$5+511<span class="token punctuation">)</span>/512<span class="token variable">)</span></span><span class="token punctuation">&#125;</span>'<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token variable">$BIN</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>   <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>./<span class="token variable">$DD_IN</span> <span class="token assign-left variable">of</span><span class="token operator">=</span><span class="token variable">$DD_OUT</span> <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token punctuation">\</span>   <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token variable">$SEC_CNT</span> <span class="token assign-left variable">seek</span><span class="token operator">=</span><span class="token number">300</span> <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc<span class="token keyword">fi</span><span class="token comment">##########   以上核心就是下面这三条命令   ##########</span><span class="token comment">#gcc -Wall -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes \</span><span class="token comment">#   -Wsystem-headers -I ../lib -o prog_no_arg.o prog_no_arg.c</span><span class="token comment">#ld -e main prog_no_arg.o ../build/string.o ../build/syscall.o\</span><span class="token comment">#   ../build/stdio.o ../build/assert.o -o prog_no_arg</span><span class="token comment">#dd if=prog_no_arg of=/home/work/my_workspace/bochs/hd60M.img \</span><span class="token comment">#   bs=512 count=10 seek=300 conv=notrunc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码，（<strong>kernel/main.c</strong>），注意：<code>file_size</code>这个变量请自行修改成自己的prog_no_arg大小，在command目录下ls -l即可查看prog_no_arg大小。我们前后会make all两次，第一次是为了让prog_no_arg有.o文件可以用，第二次是修改main.c以从hd60M.img中加载prog_no_arg到hd80M.img中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fork.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"assert.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shell.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ide.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio-kernel.h"</span></span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> file_size <span class="token operator">=</span> <span class="token number">20684</span><span class="token punctuation">;</span>      <span class="token comment">//这个变量请自行修改成自己的prog_no_arg大小</span>    <span class="token class-name">uint32_t</span> sec_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>file_size<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">disk</span> <span class="token operator">*</span>sda <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>prog_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>file_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ide_read</span><span class="token punctuation">(</span>sda<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> sec_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/prog_no_arg"</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> file_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file write error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">cls_screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">"[rabbit@localhost /]$ "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* init进程 */</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> ret_pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"init: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行出错，经过排查，修改（<strong>fs/fs.c/sys_getcwd</strong>）为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>child_inode_nr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>    buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>child_inode_nr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    buf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>    buf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">sys_free</span><span class="token punctuation">(</span>io_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改（<strong>kernel/memory.c/get_a_page</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>pgdir <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pf <span class="token operator">==</span> PF_USER<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        bit_idx <span class="token operator">=</span> <span class="token punctuation">(</span>vaddr <span class="token operator">-</span> cur<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>bit_idx <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> bit_idx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>page_phyaddr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token operator">-></span>pgdir <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> pf <span class="token operator">==</span> PF_USER<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        bit_idx <span class="token operator">=</span> <span class="token punctuation">(</span>vaddr <span class="token operator">-</span> cur<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>bit_idx <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cur<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">,</span> bit_idx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>page_phyaddr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节h：</p><p>使用户进程支持传参</p><p><code>_start</code>这个函数将会被<code>execv</code>执行，由它去代为执行真正的用户程序，因为这个函数会在链接用户程序前，成为真正的程序入口，这样可以做到给用户程序传参的目的。因为我们在<code>sys_exec</code>中有设定要开启的程序内核栈中的中断栈ebx，ecx的代码，<code>intr_exit</code>会将ebx中放入参数字符串指针数组的地址，ecx中放入参数个数，然后<code>_start</code>又将这两个寄存器入栈，而标准<code>main</code>函数的声明都是<code>int mian(int argc, char** argv)</code>，所以<code>main</code>就可以自然在栈中找到自己要的参数。而且由于<code>_start</code>入栈传参符合<code>main</code>的函数声明，也就是从左到右依次入栈，所以这个<code>main</code>的运行无需而外设定，就可以正常运行，就像任何普通有参数的c语言函数一样。</p><p>（<strong>command/start.S</strong>）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 32]extern mainsection .textglobal _start_start:   ;下面这两个要和execv中load之后指定的寄存器一致   push ebx  ;压入argv   push  ecx  ;压入argc   call  main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>prog_arg.c</code>中的<code>main</code>开启了个子进程，去执行<code>argv[1]</code>中指明的程序。</p><p>（<strong>commadn/prog_arg.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> arg_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>arg_idx <span class="token operator">&lt;</span> argc<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"argv[%d] is %s\n"</span><span class="token punctuation">,</span> arg_idx<span class="token punctuation">,</span> argv<span class="token punctuation">[</span>arg_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arg_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> delay <span class="token operator">=</span> <span class="token number">900000</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>delay<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n      I`m father prog, my pid:%d, I will show process list\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> abs_path<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n      I`m child prog, my pid:%d, I will exec %s right now\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">getcwd</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">strcat</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">strcat</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">execv</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">execv</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理prog_arg.c脚本（<strong>command/compile.sh</strong>）</p><p>相比于上一小节脚本，修改了要编译的程序BIN，包含头文件LIB，链接.o文件OBJS，编译start.S的命令，创建静态库命令，链接命令。</p><p><code>ar rcs simple_crt.a $OBJS start.o</code>的解释：</p><ol><li><code>ar</code>: 这是一个用来创建、修改和提取静态库的程序。静态库通常用于将多个目标文件（object files）打包成一个文件，这样在链接时就可以一次性链接多个目标文件。</li><li><code>rcs</code>:<ul><li><code>r</code>: 替换或添加指定的目标文件到库中。如果库中已经有了同名的目标文件，那么这个文件会被新文件替换。</li><li><code>c</code>: 如果库文件不存在，那么创建一个新的库文件。</li><li><code>s</code>: 创建目标文件的索引。这可以加速链接时的速度。</li></ul></li><li><code>simple_crt.a</code>: 这是你想要创建或修改的静态库的名字。</li><li><code>$OBJS start.o</code>: 这是一个目标文件列表，将被添加或替换到静态库中。</li></ol><p>所以，整个命令的意思是：将 <code>$OBJS</code> 和 <code>start.o</code> 中列出的所有目标文件添加或替换到 <code>simple_crt.a</code> 静态库中，并为这些目标文件创建一个索引。如果 <code>simple_crt.a</code> 还不存在，那么会创建一个新的静态库文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">####  此脚本应该在command目录下执行</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"../lib"</span> <span class="token operator">||</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"../build"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"dependent dir don\`t exist!"</span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable">$&#123;cwd<span class="token operator">##</span>*<span class="token operator">/</span>&#125;</span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable">$&#123;cwd<span class="token operator">%</span><span class="token operator">/</span>&#125;</span>   <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$cwd</span> <span class="token operator">!=</span> <span class="token string">"command"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>      <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"you\`d better in command dir<span class="token entity" title="\n">\n</span>"</span>   <span class="token keyword">fi</span>    <span class="token builtin class-name">exit</span><span class="token keyword">fi</span><span class="token assign-left variable">CC</span><span class="token operator">=</span><span class="token string">"gcc-4.4"</span><span class="token assign-left variable">BIN</span><span class="token operator">=</span><span class="token string">"prog_arg"</span><span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">"-Wall -c -fno-builtin -W -Wstrict-prototypes \    -Wmissing-prototypes -Wsystem-headers -m32 -fno-stack-protector"</span><span class="token assign-left variable">LIBS</span><span class="token operator">=</span><span class="token string">"-I ../lib -I ../lib/user -I ../fs -I ../thread -I ../lib/kernel -I ../kernel"</span><span class="token assign-left variable">OBJS</span><span class="token operator">=</span><span class="token string">"../build/string.o ../build/syscall.o \      ../build/stdio.o ../build/assert.o start.o"</span><span class="token assign-left variable">DD_IN</span><span class="token operator">=</span><span class="token variable">$BIN</span><span class="token assign-left variable">DD_OUT</span><span class="token operator">=</span><span class="token string">"/home/rlk/Desktop/bochs/hd60M.img"</span>nasm <span class="token parameter variable">-f</span> elf ./start.S <span class="token parameter variable">-o</span> ./start.oar rcs simple_crt.a <span class="token variable">$OBJS</span> start.o<span class="token variable">$CC</span> <span class="token variable">$CFLAGS</span> <span class="token variable">$LIBS</span> <span class="token parameter variable">-o</span> <span class="token variable">$BIN</span><span class="token string">".o"</span> <span class="token variable">$BIN</span><span class="token string">".c"</span>ld <span class="token variable">$BIN</span><span class="token string">".o"</span> simple_crt.a <span class="token parameter variable">-o</span> <span class="token variable">$BIN</span> <span class="token parameter variable">-m</span> elf_i386<span class="token assign-left variable">SEC_CNT</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> <span class="token parameter variable">-l</span> $BIN<span class="token operator">|</span><span class="token function">awk</span> '<span class="token punctuation">&#123;</span>printf<span class="token punctuation">(</span><span class="token string">"%d"</span>, <span class="token punctuation">(</span>$5+511<span class="token punctuation">)</span>/512<span class="token variable">)</span></span><span class="token punctuation">&#125;</span>'<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token variable">$BIN</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>   <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>./<span class="token variable">$DD_IN</span> <span class="token assign-left variable">of</span><span class="token operator">=</span><span class="token variable">$DD_OUT</span> <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token punctuation">\</span>   <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token variable">$SEC_CNT</span> <span class="token assign-left variable">seek</span><span class="token operator">=</span><span class="token number">300</span> <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc<span class="token keyword">fi</span><span class="token comment">##########   以上核心就是下面这三条命令   ##########</span><span class="token comment">#gcc -Wall -c -fno-builtin -W -Wstrict-prototypes -Wmissing-prototypes \</span><span class="token comment">#   -Wsystem-headers -I ../lib -o prog_no_arg.o prog_no_arg.c</span><span class="token comment">#ld -e main prog_no_arg.o ../build/string.o ../build/syscall.o\</span><span class="token comment">#   ../build/stdio.o ../build/assert.o -o prog_no_arg</span><span class="token comment">#dd if=prog_no_arg of=/home/work/my_workspace/bochs/hd60M.img \</span><span class="token comment">#   bs=512 count=10 seek=300 conv=notrunc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fork.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"assert.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shell.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ide.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio-kernel.h"</span></span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> file_size <span class="token operator">=</span> <span class="token number">20840</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> sec_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>file_size<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">disk</span> <span class="token operator">*</span>sda <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>prog_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>file_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ide_read</span><span class="token punctuation">(</span>sda<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> sec_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/prog_arg"</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> file_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file write error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">cls_screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">"[rabbit@localhost /]$ "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* init进程 */</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> ret_pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"init: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>prog_arg.c</code>会与<code>start.S</code>中的代码编译后共同链接成一个新的程序，然后如同上一个小节一样，先写入裸盘hd60M.img，然后<code>main.c</code>中从裸盘加载新的应用程序<code>prog_arg</code>进入内存，然后写入有文件系统的hd80M.img。当我们启动操作系统，在shell中输入<code>./prog_arg /prog_no_arg</code>后，<code>argv[0] = prog_arg, argv[1] = prog_no_arg</code>。首先<code>exec</code>启动<code>prog_arg</code>（因为<code>argv[0]</code>才是要运行的程序，而后续的<code>argv[1+n]</code>是我们传递给这个程序的参数）。我们在<code>sys_exec(exec的真正实现)</code>中已经将程序要用的到参数字符串指针数组地址传递给了<code>ebx</code>，且<code>_start</code>才是<code>prog_arg</code>的真正入口，而<code>_start</code>中有一句<code>push_ebx</code>的代码，也就是说参数字符串指针数组地址已经传递给了<code>prog_arg</code>程序，自然<code>prog_arg</code>程序能够通过<code>argv[1]</code>去启动`prog_no_arg</p><p>小节i：</p><p><strong>进程终止与资源回收</strong></p><p>首先介绍几个重要的概念：</p><p><strong><code>exit</code> 系统调用</strong>：此调用用于终止进程。当一个进程调用 <code>exit</code> 时，它会释放除进程控制块（pcb）以外的所有资源。pcb需要被特别处理，因为它包含了进程的重要信息，如退出状态。特别注意：<code>exit</code>系统调用属于程序运行库内容，无论进程是否主动调用，都会执行。就像我们那个<code>_start</code>函数一样。</p><p><strong><code>wait</code> 系统调用</strong>：这是一个与进程同步和资源回收相关的调用。具体来说，它有以下功能：</p><ol><li>阻塞父进程，直到一个子进程退出，并接收子进程的返回值。</li><li>回收子进程使用过的pcb资源，从而确保没有资源浪费。</li></ol><p>当一个父进程创建一个子进程来执行某项任务时，父进程可能需要知道子进程的退出状态。子进程完成其任务后，会将其退出状态保存在pcb中并调用<code>exit</code>退出。此时，子进程的pcb不会被立即回收，因为它包含了子进程的退出状态。只有当父进程通过<code>wait</code>系统调用来查询子进程的状态时，子进程的pcb才会被回收。</p><p><strong>孤儿进程</strong>：如果一个父进程在其子进程结束之前退出，那么这些子进程将被称为孤儿进程，也就是说没有父进程来回收他们的pcb资源。为了防止资源浪费，这些孤儿进程会被<code>init</code>进程“领养”，即成为<code>init</code>进程的子进程，由<code>init</code>来回收他们的pcb。</p><p><strong>僵尸进程</strong>：当一个子进程终止，但其父进程没有调用<code>wait</code>来回收其资源时，此时这个子进程也无法过继给init，于是这个子进程就变成了僵尸进程。它们仍然占用pcb，但不执行任何操作。僵尸进程的存在可能会导致资源浪费。</p><p>pcb增加表示退出状态的成员，比如正常退出还是其他啥的。修改（<strong>thread/thread.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 进程或线程的pcb,程序控制块, 此结构体用于存储线程的管理信息*/</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>self_kstack<span class="token punctuation">;</span> <span class="token comment">// 用于存储线程的栈顶位置，栈顶放着线程要用到的运行信息</span>    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>    <span class="token keyword">enum</span> <span class="token class-name">task_status</span> status<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> priority<span class="token punctuation">;</span> <span class="token comment">// 线程优先级</span>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 用于存储自己的线程的名字</span>    <span class="token class-name">uint8_t</span> ticks<span class="token punctuation">;</span>                                <span class="token comment">// 线程允许上处理器运行还剩下的滴答值，因为priority不能改变，所以要在其之外另行定义一个值来倒计时</span>    <span class="token class-name">uint32_t</span> elapsed_ticks<span class="token punctuation">;</span>                       <span class="token comment">// 此任务自上cpu运行后至今占用了多少cpu嘀嗒数, 也就是此任务执行了多久*/</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> general_tag<span class="token punctuation">;</span>                 <span class="token comment">// general_tag的作用是用于线程在一般的队列(如就绪队列或者等待队列)中的结点</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> all_list_tag<span class="token punctuation">;</span>                <span class="token comment">// all_list_tag的作用是用于线程队列thread_all_list（这个队列用于管理所有线程）中的结点</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>pgdir<span class="token punctuation">;</span>                              <span class="token comment">// 进程自己页表的虚拟地址</span>    <span class="token keyword">struct</span> <span class="token class-name">virtual_addr</span> userprog_vaddr<span class="token punctuation">;</span>           <span class="token comment">// 用户进程的虚拟地址</span>    <span class="token class-name">int32_t</span> fd_table<span class="token punctuation">[</span>MAX_FILES_OPEN_PER_PROC<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 已打开文件数组</span>    <span class="token class-name">uint32_t</span> cwd_inode_nr<span class="token punctuation">;</span>                        <span class="token comment">// 进程所在的工作目录的inode编号</span>    <span class="token class-name">int16_t</span> parent_pid<span class="token punctuation">;</span>                           <span class="token comment">// 父进程pid</span>    <span class="token keyword">struct</span> <span class="token class-name">mem_block_desc</span> u_block_desc<span class="token punctuation">[</span>DESC_CNT<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用户进程内存块描述符</span>    <span class="token class-name">int8_t</span> exit_status<span class="token punctuation">;</span>                           <span class="token comment">// 进程结束时自己调用exit传入的参数</span>    <span class="token class-name">uint32_t</span> stack_magic<span class="token punctuation">;</span>                         <span class="token comment">// 如果线程的栈无限生长，总会覆盖地pcb的信息，那么需要定义个边界数来检测是否栈已经到了PCB的边界</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>free_a_phy_page</code>用于回收物理地址，实质就是回收了物理地址池位图对应的位。如此，这个物理地址下次就会被再次分配。</p><p>修改（<strong>kernel/memory.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 根据物理页框地址pg_phy_addr在相应的内存池的位图清0,不改动页表*/</span><span class="token keyword">void</span> <span class="token function">free_a_phy_page</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> pg_phy_addr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">pool</span> <span class="token operator">*</span>mem_pool<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> bit_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pg_phy_addr <span class="token operator">>=</span> user_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        mem_pool <span class="token operator">=</span> <span class="token operator">&amp;</span>user_pool<span class="token punctuation">;</span>        bit_idx <span class="token operator">=</span> <span class="token punctuation">(</span>pg_phy_addr <span class="token operator">-</span> user_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        mem_pool <span class="token operator">=</span> <span class="token operator">&amp;</span>kernel_pool<span class="token punctuation">;</span>        bit_idx <span class="token operator">=</span> <span class="token punctuation">(</span>pg_phy_addr <span class="token operator">-</span> kernel_pool<span class="token punctuation">.</span>phy_addr_start<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_pool<span class="token operator">-></span>pool_bitmap<span class="token punctuation">,</span> bit_idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加函数声明，修改（<strong>kernel/memory.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">free_a_phy_page</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> pg_phy_addr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于我们的进程在退出后要释放自己的pid，然而原有的pid管理只有分配，而无回收。所以我们要实现用pid位图来管理pid的分配与回收，修改（<strong>thread/thread.c</strong>）（以下新<code>allocate_pid</code>函数需要替代原有的<code>allocate_pid</code>函数）</p><p><code>allocate_pid</code>用于根据pid位图中空余位的偏移 + 起始pid来分配pid</p><p><code>pid_pool_init</code>用于初始化pid位图，并在<code>thread_init</code>内调用</p><p><code>release_pid</code>来释放pid，实质就是将释放pid对应的pid位图中的位置0</p><p><code>thread_init</code>增加pid池初始化代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* pid的位图,最大支持1024个pid */</span><span class="token class-name">uint8_t</span> pid_bitmap_bits<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">/* pid池 */</span><span class="token keyword">struct</span> <span class="token class-name">pid_pool</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">bitmap</span> pid_bitmap<span class="token punctuation">;</span> <span class="token comment">// pid位图</span>    <span class="token class-name">uint32_t</span> pid_start<span class="token punctuation">;</span>       <span class="token comment">// 起始pid</span>    <span class="token keyword">struct</span> <span class="token class-name">lock</span> pid_lock<span class="token punctuation">;</span>     <span class="token comment">// 分配pid锁</span><span class="token punctuation">&#125;</span> pid_pool<span class="token punctuation">;</span><span class="token comment">/* 分配pid */</span><span class="token keyword">static</span> <span class="token class-name">pid_t</span> <span class="token function">allocate_pid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_pool<span class="token punctuation">.</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> bit_idx <span class="token operator">=</span> <span class="token function">bitmap_scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_pool<span class="token punctuation">.</span>pid_bitmap<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_pool<span class="token punctuation">.</span>pid_bitmap<span class="token punctuation">,</span> bit_idx<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_pool<span class="token punctuation">.</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>bit_idx <span class="token operator">+</span> pid_pool<span class="token punctuation">.</span>pid_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 初始化pid池 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">pid_pool_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    pid_pool<span class="token punctuation">.</span>pid_start <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    pid_pool<span class="token punctuation">.</span>pid_bitmap<span class="token punctuation">.</span>bits <span class="token operator">=</span> pid_bitmap_bits<span class="token punctuation">;</span>    pid_pool<span class="token punctuation">.</span>pid_bitmap<span class="token punctuation">.</span>btmp_bytes_len <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>    <span class="token function">bitmap_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_pool<span class="token punctuation">.</span>pid_bitmap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_pool<span class="token punctuation">.</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 释放pid */</span><span class="token keyword">void</span> <span class="token function">release_pid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">lock_acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_pool<span class="token punctuation">.</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> bit_idx <span class="token operator">=</span> pid <span class="token operator">-</span> pid_pool<span class="token punctuation">.</span>pid_start<span class="token punctuation">;</span>    <span class="token function">bitmap_set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_pool<span class="token punctuation">.</span>pid_bitmap<span class="token punctuation">,</span> bit_idx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">lock_release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid_pool<span class="token punctuation">.</span>pid_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">thread_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pid_pool_init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 先创建第一个用户进程:init */</span>    <span class="token function">process_execute</span><span class="token punctuation">(</span>init<span class="token punctuation">,</span> <span class="token string">"init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 放在第一个初始化,这是第一个进程,init进程的pid为1</span>    <span class="token comment">/* 将当前main函数创建为线程 */</span>    <span class="token function">make_main_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 创建idle线程 */</span>    idle_thread <span class="token operator">=</span> <span class="token function">thread_start</span><span class="token punctuation">(</span><span class="token string">"idle"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> idle<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"thread_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>thread_exit</code>用于回收指定任务的pcb和页表，并将其从就绪队列中删除</p><p><code>pid_check</code>会被<code>list_traversal</code>调用，用于对比传入的<code>all_list_tag</code>指针对应任务的pid是不是要找的传入pid</p><p><code>pid2thread</code>根据传入pid找pcb，原理是使用<code>list_traversal</code>调用<code>pid_check</code>，当<code>pid_check</code>找到了会返回true，于是<code>list_traversal</code>会返回pcb指针</p><p>修改（<strong>thread/thread.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 回收thread_over的pcb和页表,并将其从调度队列中去除 */</span><span class="token keyword">void</span> <span class="token function">thread_exit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>thread_over<span class="token punctuation">,</span> bool need_schedule<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* 要保证schedule在关中断情况下调用 */</span>    <span class="token function">intr_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread_over<span class="token operator">-></span>status <span class="token operator">=</span> TASK_DIED<span class="token punctuation">;</span>    <span class="token comment">/* 如果thread_over不是当前线程,就有可能还在就绪队列中,将其从中删除 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">elem_find</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_ready_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>thread_over<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">list_remove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_over<span class="token operator">-></span>general_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread_over<span class="token operator">-></span>pgdir<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 如是进程,回收进程的页表</span>        <span class="token function">mfree_page</span><span class="token punctuation">(</span>PF_KERNEL<span class="token punctuation">,</span> thread_over<span class="token operator">-></span>pgdir<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 从all_thread_list中去掉此任务 */</span>    <span class="token function">list_remove</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_over<span class="token operator">-></span>all_list_tag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 回收pcb所在的页,主线程的pcb不在堆中,跨过 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>thread_over <span class="token operator">!=</span> main_thread<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">mfree_page</span><span class="token punctuation">(</span>PF_KERNEL<span class="token punctuation">,</span> thread_over<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 归还pid */</span>    <span class="token function">release_pid</span><span class="token punctuation">(</span>thread_over<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 如果需要下一轮调度则主动调用schedule */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>need_schedule<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"thread_exit: should not be here\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 比对任务的pid */</span><span class="token keyword">static</span> bool <span class="token function">pid_check</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span> <span class="token operator">*</span>pelem<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>pthread <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> all_list_tag<span class="token punctuation">,</span> pelem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pthread<span class="token operator">-></span>pid <span class="token operator">==</span> pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 根据pid找pcb,若找到则返回该pcb,否则返回NULL */</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token function">pid2thread</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> <span class="token operator">*</span>pelem <span class="token operator">=</span> <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> pid_check<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pelem <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>thread <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> all_list_tag<span class="token punctuation">,</span> pelem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> thread<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>thread/thread.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">thread_exit</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> thread_over<span class="token punctuation">,</span> bool need_schedule<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> <span class="token function">pid2thread</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">release_pid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>release_prog_resource</code>用于根据传入的pcb指针，释放任务的资源，包括1、页表中对应的物理页面（这里用的方法是遍历页表）；2、虚拟内存池占用的物理页框；3、关闭打开的文件</p><p>（<strong>userprog/wait_exit.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"wait_exit.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"thread.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token comment">/* 释放用户进程资源: * 1 页表中对应的物理页 * 2 虚拟内存池占物理页框 * 3 关闭打开的文件 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">release_prog_resource</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>release_thread<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>pgdir_vaddr <span class="token operator">=</span> release_thread<span class="token operator">-></span>pgdir<span class="token punctuation">;</span>    <span class="token class-name">uint16_t</span> user_pde_nr <span class="token operator">=</span> <span class="token number">768</span><span class="token punctuation">,</span> pde_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> pde <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>v_pde_ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// v表示var,和函数pde_ptr区分</span>    <span class="token class-name">uint16_t</span> user_pte_nr <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span> pte_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>v_pte_ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 加个v表示var,和函数pte_ptr区分</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>first_pte_vaddr_in_pde <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 用来记录pde中第0个pte的地址</span>    <span class="token class-name">uint32_t</span> pg_phy_addr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 回收页表中用户空间的页框 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pde_idx <span class="token operator">&lt;</span> user_pde_nr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        v_pde_ptr <span class="token operator">=</span> pgdir_vaddr <span class="token operator">+</span> pde_idx<span class="token punctuation">;</span>        pde <span class="token operator">=</span> <span class="token operator">*</span>v_pde_ptr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pde <span class="token operator">&amp;</span> <span class="token number">0x00000001</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                                                         <span class="token comment">// 如果页目录项p位为1,表示该页目录项下可能有页表项</span>            first_pte_vaddr_in_pde <span class="token operator">=</span> <span class="token function">pte_ptr</span><span class="token punctuation">(</span>pde_idx <span class="token operator">*</span> <span class="token number">0x400000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 一个页表表示的内存容量是4M,即0x400000</span>            pte_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>pte_idx <span class="token operator">&lt;</span> user_pte_nr<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                v_pte_ptr <span class="token operator">=</span> first_pte_vaddr_in_pde <span class="token operator">+</span> pte_idx<span class="token punctuation">;</span>                pte <span class="token operator">=</span> <span class="token operator">*</span>v_pte_ptr<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> <span class="token number">0x00000001</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token comment">/* 将pte中记录的物理页框直接在相应内存池的位图中清0 */</span>                    pg_phy_addr <span class="token operator">=</span> pte <span class="token operator">&amp;</span> <span class="token number">0xfffff000</span><span class="token punctuation">;</span>                    <span class="token function">free_a_phy_page</span><span class="token punctuation">(</span>pg_phy_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                pte_idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 将pde中记录的物理页框直接在相应内存池的位图中清0 */</span>            pg_phy_addr <span class="token operator">=</span> pde <span class="token operator">&amp;</span> <span class="token number">0xfffff000</span><span class="token punctuation">;</span>            <span class="token function">free_a_phy_page</span><span class="token punctuation">(</span>pg_phy_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        pde_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 回收用户虚拟地址池所占的物理内存*/</span>    <span class="token class-name">uint32_t</span> bitmap_pg_cnt <span class="token operator">=</span> <span class="token punctuation">(</span>release_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>btmp_bytes_len<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> <span class="token operator">*</span>user_vaddr_pool_bitmap <span class="token operator">=</span> release_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>bits<span class="token punctuation">;</span>    <span class="token function">mfree_page</span><span class="token punctuation">(</span>PF_KERNEL<span class="token punctuation">,</span> user_vaddr_pool_bitmap<span class="token punctuation">,</span> bitmap_pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 关闭进程打开的文件 */</span>    <span class="token class-name">uint8_t</span> fd_idx <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>fd_idx <span class="token operator">&lt;</span> MAX_FILES_OPEN_PER_PROC<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>release_thread<span class="token operator">-></span>fd_table<span class="token punctuation">[</span>fd_idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">sys_close</span><span class="token punctuation">(</span>fd_idx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        fd_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>fild_child</code>会被<code>list_traversal</code>调用，用于对比传入的<code>all_list_tag</code>指针对应任务的parient_id是不是要找的传入ppid</p><p>修改（<strong>userprog/wait_exit.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* list_traversal的回调函数, * 查找pelem的parent_pid是否是ppid,成功返回true,失败则返回false */</span><span class="token keyword">static</span> bool <span class="token function">find_child</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span> <span class="token operator">*</span>pelem<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> ppid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">/* elem2entry中间的参数all_list_tag取决于pelem对应的变量名 */</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>pthread <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> all_list_tag<span class="token punctuation">,</span> pelem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pthread<span class="token operator">-></span>parent_pid <span class="token operator">==</span> ppid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>                <span class="token comment">// 若该任务的parent_pid为ppid,返回</span>        <span class="token keyword">return</span> true<span class="token punctuation">;</span> <span class="token comment">// list_traversal只有在回调函数返回true时才会停止继续遍历,所以在此返回true</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">// 让list_traversal继续传递下一个元素</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>find_hanging_child</code>会被<code>list_traversal</code>调用，用于对比传入的<code>all_list_tag</code>指针对应任务的ppid是不是传入的ppid，且状态要是不是TASK_HANGING（进程没有完全退出就是这个状态）。此函数用于父进程来找到自己退出的子进程以回收它的剩余资源</p><p>修改（<strong>userprog/wait_exit.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* list_traversal的回调函数, * 查找状态为TASK_HANGING的任务 */</span><span class="token keyword">static</span> bool <span class="token function">find_hanging_child</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span><span class="token operator">*</span> pelem<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> ppid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token operator">*</span> pthread <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> all_list_tag<span class="token punctuation">,</span> pelem<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>pthread<span class="token operator">-></span>parent_pid <span class="token operator">==</span> ppid <span class="token operator">&amp;&amp;</span> pthread<span class="token operator">-></span>status <span class="token operator">==</span> TASK_HANGING<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> true<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>init_adopt_a_child</code>将传入的<code>all_list_tag</code>指针对应任务<code>parent_pid</code>改为1，也就是将一个子进程过继给init</p><p>修改（<strong>userprog/wait_exit.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* list_traversal的回调函数, * 将一个子进程过继给init */</span><span class="token keyword">static</span> bool <span class="token function">init_adopt_a_child</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">list_elem</span> <span class="token operator">*</span>pelem<span class="token punctuation">,</span> <span class="token class-name">int32_t</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>pthread <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> all_list_tag<span class="token punctuation">,</span> pelem<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pthread<span class="token operator">-></span>parent_pid <span class="token operator">==</span> pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 若该进程的parent_pid为pid,返回</span>        pthread<span class="token operator">-></span>parent_pid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> false<span class="token punctuation">;</span> <span class="token comment">// 让list_traversal继续传递下一个元素</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_wait</code>等待子进程调用exit，将子进程的退出状态保存到status指向的变量，并回收子进程的pcb与页表，最后返回子进程pid。如果子进程都在运行，那么就阻塞自己。这个函数有两种用法，一种是<code>init</code>while(1)不断调用，来不断回收子进程的资源；一种是父进程fork之后调用，然后等待子进程退出后继续运行，然后回收子进程剩余资源。</p><p>修改（<strong>userprog/wait_exit.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 等待子进程调用exit,将子进程的退出状态保存到status指向的变量. * 成功则返回子进程的pid,失败则返回-1 */</span><span class="token class-name">pid_t</span> <span class="token function">sys_wait</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> <span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>parent_thread <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* 优先处理已经是挂起状态的任务 */</span>        <span class="token keyword">struct</span> <span class="token class-name">list_elem</span> <span class="token operator">*</span>child_elem <span class="token operator">=</span> <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> find_hanging_child<span class="token punctuation">,</span> parent_thread<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* 若有挂起的子进程 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>child_elem <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>child_thread <span class="token operator">=</span> <span class="token function">elem2entry</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span class="token punctuation">,</span> all_list_tag<span class="token punctuation">,</span> child_elem<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>status <span class="token operator">=</span> child_thread<span class="token operator">-></span>exit_status<span class="token punctuation">;</span>            <span class="token comment">/* thread_exit之后,pcb会被回收,因此提前获取pid */</span>            <span class="token class-name">uint16_t</span> child_pid <span class="token operator">=</span> child_thread<span class="token operator">-></span>pid<span class="token punctuation">;</span>            <span class="token comment">/* 2 从就绪队列和全部队列中删除进程表项*/</span>            <span class="token function">thread_exit</span><span class="token punctuation">(</span>child_thread<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传入false,使thread_exit调用后回到此处</span>            <span class="token comment">/* 进程表项是进程或线程的最后保留的资源, 至此该进程彻底消失了 */</span>            <span class="token keyword">return</span> child_pid<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 判断是否有子进程 */</span>        child_elem <span class="token operator">=</span> <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> find_child<span class="token punctuation">,</span> parent_thread<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>child_elem <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若没有子进程则出错返回</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 若子进程还未运行完,即还未调用exit,则将自己挂起,直到子进程在执行exit时将自己唤醒 */</span>            <span class="token function">thread_block</span><span class="token punctuation">(</span>TASK_WAITING<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_exit</code>子进程用来结束自己，退出时的事项：1、在自己的pcb中留下退出状态；2、将自己的子进程全部过继给init；3、回收自己除pcb与页表外的资源；4、可能有父进程在等待自己调用<code>exit</code>，所以还要唤醒等待的父进程；5、阻塞自己，也就是换下cpu。这个函数会被运行库调用，进程即使不主动调用，也会执行</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"debug.h"</span></span><span class="token comment">/* 子进程用来结束自己时调用 */</span><span class="token keyword">void</span> <span class="token function">sys_exit</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> status<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>child_thread <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    child_thread<span class="token operator">-></span>exit_status <span class="token operator">=</span> status<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>child_thread<span class="token operator">-></span>parent_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">PANIC</span><span class="token punctuation">(</span><span class="token string">"sys_exit: child_thread->parent_pid is -1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 将进程child_thread的所有子进程都过继给init */</span>    <span class="token function">list_traversal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread_all_list<span class="token punctuation">,</span> init_adopt_a_child<span class="token punctuation">,</span> child_thread<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 回收进程child_thread的资源 */</span>    <span class="token function">release_prog_resource</span><span class="token punctuation">(</span>child_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 如果父进程正在等待子进程退出,将父进程唤醒 */</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>parent_thread <span class="token operator">=</span> <span class="token function">pid2thread</span><span class="token punctuation">(</span>child_thread<span class="token operator">-></span>parent_pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent_thread<span class="token operator">-></span>status <span class="token operator">==</span> TASK_WAITING<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">thread_unblock</span><span class="token punctuation">(</span>parent_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 将自己挂起,等待父进程获取其status,并回收其pcb */</span>    <span class="token function">thread_block</span><span class="token punctuation">(</span>TASK_HANGING<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将<code>sys_wait</code>与<code>sys_exit</code>封装成系统调用</p><p>添加系统调用号，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span> <span class="token punctuation">&#123;</span>   SYS_GETPID<span class="token punctuation">,</span>   SYS_WRITE<span class="token punctuation">,</span>   SYS_MALLOC<span class="token punctuation">,</span>   SYS_FREE<span class="token punctuation">,</span>   SYS_FORK<span class="token punctuation">,</span>   SYS_READ<span class="token punctuation">,</span>   SYS_PUTCHAR<span class="token punctuation">,</span>   SYS_CLEAR<span class="token punctuation">,</span>   SYS_GETCWD<span class="token punctuation">,</span>   SYS_OPEN<span class="token punctuation">,</span>   SYS_CLOSE<span class="token punctuation">,</span>   SYS_LSEEK<span class="token punctuation">,</span>   SYS_UNLINK<span class="token punctuation">,</span>   SYS_MKDIR<span class="token punctuation">,</span>   SYS_OPENDIR<span class="token punctuation">,</span>   SYS_CLOSEDIR<span class="token punctuation">,</span>   SYS_CHDIR<span class="token punctuation">,</span>   SYS_RMDIR<span class="token punctuation">,</span>   SYS_READDIR<span class="token punctuation">,</span>   SYS_REWINDDIR<span class="token punctuation">,</span>   SYS_STAT<span class="token punctuation">,</span>   SYS_PS<span class="token punctuation">,</span>   SYS_EXECV<span class="token punctuation">,</span>   SYS_EXIT<span class="token punctuation">,</span>   SYS_WAIT<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建用户态系统调用入口，修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 以状态status退出 */</span><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> status<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_EXIT<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 等待子进程,子进程状态存储到status */</span><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> <span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_WAIT<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明，用户态系统调用函数入口，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token operator">*</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>系统调用表中，添加实际系统调用处理函数，修改（<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"wait_exit.h"</span></span><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_WRITE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_write<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MALLOC<span class="token punctuation">]</span> <span class="token operator">=</span> sys_malloc<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FREE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_free<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FORK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_fork<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READ<span class="token punctuation">]</span> <span class="token operator">=</span> sys_read<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PUTCHAR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_putchar<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLEAR<span class="token punctuation">]</span> <span class="token operator">=</span> cls_screen<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETCWD<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getcwd<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPEN<span class="token punctuation">]</span> <span class="token operator">=</span> sys_open<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_close<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_LSEEK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_lseek<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_UNLINK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_unlink<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MKDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_mkdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPENDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_opendir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSEDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_closedir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CHDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_chdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_RMDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rmdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_readdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_REWINDDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rewinddir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_STAT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_stat<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PS<span class="token punctuation">]</span> <span class="token operator">=</span> sys_ps<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_EXECV<span class="token punctuation">]</span> <span class="token operator">=</span> sys_execv<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_EXIT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_exit<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_WAIT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_wait<span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将<code>exit</code>函数集成到运行库中。这样，即使程序中没有明确调用<code>exit</code>，它也会在程序结束时自动被调用，与<code>_start</code>相同。需要特别注意的是，子进程的退出机制与普通的函数返回机制不同。当子进程终止时，它并不是“返回”给其父进程；相反，它只是简单地结束了自己的执行。父进程和子进程在内存地址空间和执行上下文中是完全独立的，子进程不可能按照常规的函数调用方式“返回”一个值给父进程（做到这点需要其他的进程间通信机制支持）。取而代之的是，子进程提供一个退出状态，来描述其终止的方式或原因。因此，这里的<code>push eax</code>并不是我们在普通函数调用中看到的那种返回值——比如一个指针或某种计算结果。实际上，它代表了子进程的结束状态，就像我们在每个<code>main</code>函数中写的<code>return 0</code>一样。</p><p>修改（<strong>command/start.S</strong>）</p><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">[bits 32]extern mainextern exit section .textglobal _start_start:    ;下面这两个要和execv中load之后指定的寄存器一致    push ebx  ;压入argv    push  ecx  ;压入argc    call  main    ;将main的返回值通过栈传给exit,gcc用eax存储返回值,这是ABI规定的    push  eax    call exit    ;exit不会返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>cat</code>用于读取文件内容，不是以系统调用的方式存在，而是以用户进程的方式存在。核心原理就是调用<code>read</code>系统调用，然后调用<code>write</code>系统调用来打印</p><p>（<strong>command/cat.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">||</span> argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cat: only support 1 argument.\neg: cat filename\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> buf_size <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> abs_path<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>buf <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cat: malloc memory failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">getcwd</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">strcat</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">strcat</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cat: open: open %s failed\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> read_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        read_bytes <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>read_bytes <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> read_bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">66</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理cat.c的脚本</p><p>（<strong>command/compile.sh</strong>）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">####  此脚本应该在command目录下执行</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"../lib"</span> <span class="token operator">||</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"../build"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"dependent dir don\`t exist!"</span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable">$&#123;cwd<span class="token operator">##</span>*<span class="token operator">/</span>&#125;</span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable">$&#123;cwd<span class="token operator">%</span><span class="token operator">/</span>&#125;</span>   <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$cwd</span> <span class="token operator">!=</span> <span class="token string">"command"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>      <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"you\`d better in command dir<span class="token entity" title="\n">\n</span>"</span>   <span class="token keyword">fi</span>    <span class="token builtin class-name">exit</span><span class="token keyword">fi</span><span class="token assign-left variable">CC</span><span class="token operator">=</span><span class="token string">"gcc-4.4"</span><span class="token assign-left variable">BIN</span><span class="token operator">=</span><span class="token string">"cat"</span><span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">"-Wall -c -fno-builtin -W -Wstrict-prototypes \    -Wmissing-prototypes -Wsystem-headers -m32 -fno-stack-protector"</span><span class="token assign-left variable">LIBS</span><span class="token operator">=</span><span class="token string">"-I ../lib/ -I ../lib/kernel/ -I ../lib/user/ -I \      ../kernel/ -I ../device/ -I ../thread/ -I \      ../userprog/ -I ../fs/ -I ../shell/"</span><span class="token assign-left variable">OBJS</span><span class="token operator">=</span><span class="token string">"../build/string.o ../build/syscall.o \      ../build/stdio.o ../build/assert.o start.o"</span><span class="token assign-left variable">DD_IN</span><span class="token operator">=</span><span class="token variable">$BIN</span><span class="token assign-left variable">DD_OUT</span><span class="token operator">=</span><span class="token string">"/home/rlk/Desktop/bochs/hd60M.img"</span>nasm <span class="token parameter variable">-f</span> elf ./start.S <span class="token parameter variable">-o</span> ./start.oar rcs simple_crt.a <span class="token variable">$OBJS</span> start.o<span class="token variable">$CC</span> <span class="token variable">$CFLAGS</span> <span class="token variable">$LIBS</span> <span class="token parameter variable">-o</span> <span class="token variable">$BIN</span><span class="token string">".o"</span> <span class="token variable">$BIN</span><span class="token string">".c"</span>ld <span class="token variable">$BIN</span><span class="token string">".o"</span> simple_crt.a <span class="token parameter variable">-o</span> <span class="token variable">$BIN</span> <span class="token parameter variable">-m</span> elf_i386<span class="token assign-left variable">SEC_CNT</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> <span class="token parameter variable">-l</span> $BIN<span class="token operator">|</span><span class="token function">awk</span> '<span class="token punctuation">&#123;</span>printf<span class="token punctuation">(</span><span class="token string">"%d"</span>, <span class="token punctuation">(</span>$5+511<span class="token punctuation">)</span>/512<span class="token variable">)</span></span><span class="token punctuation">&#125;</span>'<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token variable">$BIN</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>   <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>./<span class="token variable">$DD_IN</span> <span class="token assign-left variable">of</span><span class="token operator">=</span><span class="token variable">$DD_OUT</span> <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token punctuation">\</span>   <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token variable">$SEC_CNT</span> <span class="token assign-left variable">seek</span><span class="token operator">=</span><span class="token number">300</span> <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在我们有了能够退出程序的机制，终于不用再来用while(1)让程序卡住而不乱跳啦！</p><p>修改（<strong>shell/shell.c/my_shell</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">else</span><span class="token punctuation">&#123;</span> <span class="token comment">// 如果是外部命令,需要从磁盘上加载</span>    <span class="token class-name">int32_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token comment">/* 下面这个while必须要加上,否则父进程一般情况下会比子进程先执行,        因此会进行下一轮循环将findl_path清空,这样子进程将无法从final_path中获得参数*/</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> final_path<span class="token punctuation">;</span>        <span class="token comment">/* 先判断下文件是否存在 */</span>        <span class="token keyword">struct</span> <span class="token class-name">stat</span> file_stat<span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_stat<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">stat</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>file_stat<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my_shell: cannot access %s: No such file or directory\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">execv</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">else</span><span class="token punctuation">&#123;</span> <span class="token comment">// 如果是外部命令,需要从磁盘上加载</span>    <span class="token class-name">int32_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token class-name">int32_t</span> status<span class="token punctuation">;</span>        <span class="token class-name">int32_t</span> child_pid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此时子进程若没有执行exit,my_shell会被阻塞,不再响应键入的命令</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 按理说程序正确的话不会执行到这句,fork出的进程便是shell子进程</span>            <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"my_shell: no child\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child_pid %d, it's status: %d\n"</span><span class="token punctuation">,</span> child_pid<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> final_path<span class="token punctuation">;</span>        <span class="token comment">/* 先判断下文件是否存在 */</span>        <span class="token keyword">struct</span> <span class="token class-name">stat</span> file_stat<span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_stat<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">stat</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>file_stat<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my_shell: cannot access %s: No such file or directory\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">execv</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改（<strong>kernel/main.c</strong>），main函数要完成cat程序从hd60M.img到hd80M.img的加载，并且要退出；init进程不断调用<code>wait</code>来回收过继的僵尸进程资源</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fork.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"assert.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shell.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ide.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio-kernel.h"</span></span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> file_size <span class="token operator">=</span> <span class="token number">21196</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> sec_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>file_size<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">disk</span> <span class="token operator">*</span>sda <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>prog_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>file_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ide_read</span><span class="token punctuation">(</span>sda<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> sec_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"cat.c"</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> file_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file write error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">cls_screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">"[rabbit@localhost /]$ "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_exit</span><span class="token punctuation">(</span><span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* init进程 */</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> ret_pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token keyword">int</span> child_pid<span class="token punctuation">;</span>        <span class="token comment">/* init在此处不停的回收僵尸进程 */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            child_pid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I`m init, My pid is 1, I recieve a child, It`s pid is %d, status is %d\n"</span><span class="token punctuation">,</span> child_pid<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"init: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码，删除（<strong>userprog/fork.c/copy_pcb_vaddrbitmap_stack0</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">ASSERT</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>child_thread<span class="token operator">-></span>name<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pcb.name的长度是16,为避免下面strcat越界</span><span class="token function">strcat</span><span class="token punctuation">(</span>child_thread<span class="token operator">-></span>name<span class="token punctuation">,</span> <span class="token string">"_fork"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>小节j：</p><p>本节要支持管道，管道是用于父子进程通信的机制</p><p>管道本质上是位于内核空间的环形缓冲区。遵循Linux的设计哲学——一切皆文件，我们将管道也视为一个文件。这样，我们就可以通过文件描述符进行对管道的读写操作。在进行父子进程之间的通信时，父进程首先创建一个管道，从而得到两个文件描述符，一个用于读，另一个用于写。随后，父进程使用<code>fork</code>创建子进程。子进程继承了父进程打开的文件，因此也可以通过这些文件描述符与管道进行通信，从而实现与父进程的交互。</p><ol><li><strong>匿名管道</strong>：仅对创建它的进程及其子进程可见，其他进程无法访问。</li><li><strong>有名管道</strong>：可以被系统中的所有进程访问。<br><img src="49536ea264f544e781b377756b84a47b.png" alt="在这里插入图片描述"><br>我们的管道机制将会复用现有文件系统</li></ol><p><code>ioq_length</code>返回环形缓冲区内的数据长度</p><p>修改（<strong>device/ioqueue.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 返回环形缓冲区中的数据长度 */</span><span class="token class-name">uint32_t</span> <span class="token function">ioq_length</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span> <span class="token operator">*</span>ioq<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ioq<span class="token operator">-></span>head <span class="token operator">>=</span> ioq<span class="token operator">-></span>tail<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        len <span class="token operator">=</span> ioq<span class="token operator">-></span>head <span class="token operator">-</span> ioq<span class="token operator">-></span>tail<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        len <span class="token operator">=</span> bufsize <span class="token operator">-</span> <span class="token punctuation">(</span>ioq<span class="token operator">-></span>tail <span class="token operator">-</span> ioq<span class="token operator">-></span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> len<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>device/ioqueue.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">ioq_length</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span> <span class="token operator">*</span>ioq<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>is_pipe</code>判断文件描述符对应的文件是不是管道</p><p>（<strong>shell/pipe.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pipe.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"file.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token comment">/* 判断文件描述符local_fd是否是管道 */</span>bool <span class="token function">is_pipe</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> local_fd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> global_fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>local_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_flag <span class="token operator">==</span> PIPE_FLAG<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，（<strong>shell/pipe.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__SHELL_PIPE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__SHELL_PIPE_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"global.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PIPE_FLAG</span> <span class="token expression"><span class="token number">0xFFFF</span></span></span>bool <span class="token function">is_pipe</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> local_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>支持代码，修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">uint32_t</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> local_fd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> local_fd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并添加函数声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">uint32_t</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> local_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>sys_pipe</code>用于创建管道，核心就是创建了个全局打开文件结构，然后申请一页内核页，并让之前的文件结构内的<code>fd_inode</code>成员指向这个内核页（之前的文件系统中，该成员指向一个struct inode），之后再将这个内核页起始位置创建<code>struct ioqueue</code>并初始化。然后在进程中安装两个文件描述符，指向这个文件结构。最后记录下这两个文件描述符。</p><p>修改（<strong>shell/pipe.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ioqueue.h"</span></span><span class="token comment">/* 创建管道,成功返回0,失败返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_pipe</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> global_fd <span class="token operator">=</span> <span class="token function">get_free_slot_in_global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 申请一页内核内存做环形缓冲区 */</span>    file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode <span class="token operator">=</span> <span class="token function">get_kernel_pages</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 初始化环形缓冲区 */</span>    <span class="token function">ioqueue_init</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span> <span class="token operator">*</span><span class="token punctuation">)</span>file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 将fd_flag复用为管道标志 */</span>    file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_flag <span class="token operator">=</span> PIPE_FLAG<span class="token punctuation">;</span>    <span class="token comment">/* 将fd_pos复用为管道打开数 */</span>    file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_pos <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    pipefd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">pcb_fd_install</span><span class="token punctuation">(</span>global_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    pipefd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">pcb_fd_install</span><span class="token punctuation">(</span>global_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pipe_read</code>传入管道的文件描述符、一个缓冲地址、读取字节数。通过管道的文件描述符找到环形缓冲区<code>struct ioqueue</code>，然后调用<code>ioq_getchar</code>从中读取数据即可。</p><p>修改（<strong>shell/pipe.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 从管道中读数据 */</span><span class="token class-name">uint32_t</span> <span class="token function">pipe_read</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>buffer <span class="token operator">=</span> buf<span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> bytes_read <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> global_fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 获取管道的环形缓冲区 */</span>    <span class="token keyword">struct</span> <span class="token class-name">ioqueue</span> <span class="token operator">*</span>ioq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span> <span class="token operator">*</span><span class="token punctuation">)</span>file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token punctuation">;</span>    <span class="token comment">/* 选择较小的数据读取量,避免阻塞 */</span>    <span class="token class-name">uint32_t</span> ioq_len <span class="token operator">=</span> <span class="token function">ioq_length</span><span class="token punctuation">(</span>ioq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> size <span class="token operator">=</span> ioq_len <span class="token operator">></span> count <span class="token operator">?</span> count <span class="token operator">:</span> ioq_len<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>bytes_read <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">*</span>buffer <span class="token operator">=</span> <span class="token function">ioq_getchar</span><span class="token punctuation">(</span>ioq<span class="token punctuation">)</span><span class="token punctuation">;</span>        bytes_read<span class="token operator">++</span><span class="token punctuation">;</span>        buffer<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bytes_read<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pipe_write</code>传入管道的文件描述符、一个缓冲地址、写入字节数。通过管道的文件描述符找到环形缓冲区<code>struct ioqueue</code>，然后调用<code>ioq_putchar</code>向其写入数据即可。</p><p>修改（<strong>shell/pipe.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 往管道中写数据 */</span><span class="token class-name">uint32_t</span> <span class="token function">pipe_write</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> bytes_write <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> global_fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">ioqueue</span> <span class="token operator">*</span>ioq <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ioqueue</span> <span class="token operator">*</span><span class="token punctuation">)</span>file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token punctuation">;</span>    <span class="token comment">/* 选择较小的数据写入量,避免阻塞 */</span>    <span class="token class-name">uint32_t</span> ioq_left <span class="token operator">=</span> bufsize <span class="token operator">-</span> <span class="token function">ioq_length</span><span class="token punctuation">(</span>ioq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> size <span class="token operator">=</span> ioq_left <span class="token operator">></span> count <span class="token operator">?</span> count <span class="token operator">:</span> ioq_left<span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>buffer <span class="token operator">=</span> buf<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>bytes_write <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">ioq_putchar</span><span class="token punctuation">(</span>ioq<span class="token punctuation">,</span> <span class="token operator">*</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>        bytes_write<span class="token operator">++</span><span class="token punctuation">;</span>        buffer<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> bytes_write<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>shell/pipe.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">sys_pipe</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">uint32_t</span> <span class="token function">pipe_read</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">uint32_t</span> <span class="token function">pipe_write</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>将<code>sys_pipe</code>做成系统调用</p><p>增加系统调用号，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span><span class="token punctuation">&#123;</span>    SYS_GETPID<span class="token punctuation">,</span>    SYS_WRITE<span class="token punctuation">,</span>    SYS_MALLOC<span class="token punctuation">,</span>    SYS_FREE<span class="token punctuation">,</span>    SYS_FORK<span class="token punctuation">,</span>    SYS_READ<span class="token punctuation">,</span>    SYS_PUTCHAR<span class="token punctuation">,</span>    SYS_CLEAR<span class="token punctuation">,</span>    SYS_GETCWD<span class="token punctuation">,</span>    SYS_OPEN<span class="token punctuation">,</span>    SYS_CLOSE<span class="token punctuation">,</span>    SYS_LSEEK<span class="token punctuation">,</span>    SYS_UNLINK<span class="token punctuation">,</span>    SYS_MKDIR<span class="token punctuation">,</span>    SYS_OPENDIR<span class="token punctuation">,</span>    SYS_CLOSEDIR<span class="token punctuation">,</span>    SYS_CHDIR<span class="token punctuation">,</span>    SYS_RMDIR<span class="token punctuation">,</span>    SYS_READDIR<span class="token punctuation">,</span>    SYS_REWINDDIR<span class="token punctuation">,</span>    SYS_STAT<span class="token punctuation">,</span>    SYS_PS<span class="token punctuation">,</span>    SYS_EXECV<span class="token punctuation">,</span>    SYS_EXIT<span class="token punctuation">,</span>    SYS_WAIT<span class="token punctuation">,</span>    SYS_PIPE<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>增加用户态系统调用入口，修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 生成管道,pipefd[0]负责读入管道,pipefd[1]负责写入管道 */</span><span class="token class-name">int32_t</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token function">_syscall1</span><span class="token punctuation">(</span>SYS_PIPE<span class="token punctuation">,</span> pipefd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明用户态系统调用函数，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">int32_t</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> pipefd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>系统调用表中，增加实际系统调用处理函数，修改（<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pipe.h"</span></span><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_WRITE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_write<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MALLOC<span class="token punctuation">]</span> <span class="token operator">=</span> sys_malloc<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FREE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_free<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FORK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_fork<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READ<span class="token punctuation">]</span> <span class="token operator">=</span> sys_read<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PUTCHAR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_putchar<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLEAR<span class="token punctuation">]</span> <span class="token operator">=</span> cls_screen<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETCWD<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getcwd<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPEN<span class="token punctuation">]</span> <span class="token operator">=</span> sys_open<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_close<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_LSEEK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_lseek<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_UNLINK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_unlink<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MKDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_mkdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPENDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_opendir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSEDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_closedir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CHDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_chdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_RMDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rmdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_readdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_REWINDDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rewinddir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_STAT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_stat<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PS<span class="token punctuation">]</span> <span class="token operator">=</span> sys_ps<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_EXECV<span class="token punctuation">]</span> <span class="token operator">=</span> sys_execv<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_EXIT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_exit<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_WAIT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_wait<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PIPE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_pipe<span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_close</code>增加对管道文件的关闭代码，先调用<code>is_pipe</code>判断文件描述符对应的文件结构是管道文件，然后文件结构中的<code>fd_pos</code> -1（该成员记录管道文件的打开次数，在之前文件系统中，该成员记录文件当前操作的位置），如果此时<code>fd_pos</code>为0，那么直接释放环形缓冲区对应的那页内存即可。</p><p>修改（<strong>fs/fs.c/sys_close</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pipe.h"</span></span><span class="token comment">/* 关闭文件描述符fd指向的文件,成功返回0,否则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_close</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 返回值默认为-1,即失败</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">uint32_t</span> global_fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 如果此管道上的描述符都被关闭,释放管道的环形缓冲区 */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">mfree_page</span><span class="token punctuation">(</span>PF_KERNEL<span class="token punctuation">,</span> file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            ret <span class="token operator">=</span> <span class="token function">file_close</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>fd_table<span class="token punctuation">[</span>fd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 使该文件描述符位可用</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_write</code>增加对管道文件的写入代码，在<code>fd == stdout_no</code>增加调用<code>is_pipe</code>判断文件描述符对应的文件是不是管道文件（标准输出有可能会被重定向为管道文件），如果是，则调用<code>pipe_write</code>。然后增加fd即使不是标准输出判断是不是管道文件，如果是，调用<code>pipe_write</code>写入。</p><p>修改（<strong>fs/fs.c/sys_write</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将buf中连续count个字节写入文件描述符fd,成功则返回写入的字节数,失败返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_write</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_write: fd error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> stdout_no<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* 标准输出有可能被重定向为管道缓冲区, 因此要判断 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token function">pipe_write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> tmp_buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>tmp_buf<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">console_put_str</span><span class="token punctuation">(</span>tmp_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> count<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">/* 若是管道就调用管道的方法 */</span>        <span class="token keyword">return</span> <span class="token function">pipe_write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">uint32_t</span> _fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>wr_file <span class="token operator">=</span> <span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>_fd<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>wr_file<span class="token operator">-></span>fd_flag <span class="token operator">&amp;</span> O_WRONLY <span class="token operator">||</span> wr_file<span class="token operator">-></span>fd_flag <span class="token operator">&amp;</span> O_RDWR<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token class-name">uint32_t</span> bytes_written <span class="token operator">=</span> <span class="token function">file_write</span><span class="token punctuation">(</span>wr_file<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> bytes_written<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">"sys_write: not allowed to write file without flag O_RDWR or O_WRONLY\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sys_read</code>增加对管道文件的读入代码，在<code>fd == stdoin_no</code>增加调用<code>is_pipe</code>判断文件描述符对应的文件是不是管道文件（标准输入有可能会被重定向为管道文件），如果是，则调用<code>pipe_read</code>。然后增加fd即使不是标准输入判断是不是管道文件，如果是，调用<code>pipe_read</code>读出。</p><p>修改（<strong>fs/fs.c/sys_read</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 从文件描述符fd指向的文件中读取count个字节到buf,若成功则返回读出的字节数,到文件尾则返回-1 */</span><span class="token class-name">int32_t</span> <span class="token function">sys_read</span><span class="token punctuation">(</span><span class="token class-name">int32_t</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> count<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">ASSERT</span><span class="token punctuation">(</span>buf <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> ret <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> global_fd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> fd <span class="token operator">==</span> stdout_no <span class="token operator">||</span> fd <span class="token operator">==</span> stderr_no<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"sys_read: fd error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> stdin_no<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">/* 标准输入有可能被重定向为管道缓冲区, 因此要判断 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            ret <span class="token operator">=</span> <span class="token function">pipe_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">char</span> <span class="token operator">*</span>buffer <span class="token operator">=</span> buf<span class="token punctuation">;</span>            <span class="token class-name">uint32_t</span> bytes_read <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>bytes_read <span class="token operator">&lt;</span> count<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token operator">*</span>buffer <span class="token operator">=</span> <span class="token function">ioq_getchar</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kbd_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>                bytes_read<span class="token operator">++</span><span class="token punctuation">;</span>                buffer<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            ret <span class="token operator">=</span> <span class="token punctuation">(</span>bytes_read <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token class-name">int32_t</span><span class="token punctuation">)</span>bytes_read<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">/* 若是管道就调用管道的方法 */</span>        ret <span class="token operator">=</span> <span class="token function">pipe_read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        global_fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token function">file_read</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>update_inode_open</code>增加对于管道文件的处理代码，如果是，那么<code>fd_pos</code> + 1</p><p>修改（<strong>userprog/fork.c/update_inode_open</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pipe.h"</span></span><span class="token comment">/* 更新inode打开数 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update_inode_open_cnts</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>thread<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> local_fd <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> global_fd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>local_fd <span class="token operator">&lt;</span> MAX_FILES_OPEN_PER_PROC<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        global_fd <span class="token operator">=</span> thread<span class="token operator">-></span>fd_table<span class="token punctuation">[</span>local_fd<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">ASSERT</span><span class="token punctuation">(</span>global_fd <span class="token operator">&lt;</span> MAX_FILE_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>global_fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_pipe</span><span class="token punctuation">(</span>local_fd<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_pos<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token operator">-></span>i_open_cnts<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        local_fd<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>release_prog_resource</code>增加程序退出时对于打开的管道文件资源的处理代码，原理与<code>sys_close</code>增加的代码一样</p><p>修改（<strong>userprog/wait_exit.c/release_prog_resource</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pipe.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"file.h"</span></span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">release_prog_resource</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>release_thread<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>pgdir_vaddr <span class="token operator">=</span> release_thread<span class="token operator">-></span>pgdir<span class="token punctuation">;</span>    <span class="token class-name">uint16_t</span> user_pde_nr <span class="token operator">=</span> <span class="token number">768</span><span class="token punctuation">,</span> pde_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> pde <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>v_pde_ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// v表示var,和函数pde_ptr区分</span>    <span class="token class-name">uint16_t</span> user_pte_nr <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">,</span> pte_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> pte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>v_pte_ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 加个v表示var,和函数pte_ptr区分</span>    <span class="token class-name">uint32_t</span> <span class="token operator">*</span>first_pte_vaddr_in_pde <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 用来记录pde中第0个pte的地址</span>    <span class="token class-name">uint32_t</span> pg_phy_addr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/* 回收页表中用户空间的页框 */</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>pde_idx <span class="token operator">&lt;</span> user_pde_nr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        v_pde_ptr <span class="token operator">=</span> pgdir_vaddr <span class="token operator">+</span> pde_idx<span class="token punctuation">;</span>        pde <span class="token operator">=</span> <span class="token operator">*</span>v_pde_ptr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pde <span class="token operator">&amp;</span> <span class="token number">0x00000001</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>                                                         <span class="token comment">// 如果页目录项p位为1,表示该页目录项下可能有页表项</span>            first_pte_vaddr_in_pde <span class="token operator">=</span> <span class="token function">pte_ptr</span><span class="token punctuation">(</span>pde_idx <span class="token operator">*</span> <span class="token number">0x400000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 一个页表表示的内存容量是4M,即0x400000</span>            pte_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>pte_idx <span class="token operator">&lt;</span> user_pte_nr<span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                v_pte_ptr <span class="token operator">=</span> first_pte_vaddr_in_pde <span class="token operator">+</span> pte_idx<span class="token punctuation">;</span>                pte <span class="token operator">=</span> <span class="token operator">*</span>v_pte_ptr<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">&amp;</span> <span class="token number">0x00000001</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token comment">/* 将pte中记录的物理页框直接在相应内存池的位图中清0 */</span>                    pg_phy_addr <span class="token operator">=</span> pte <span class="token operator">&amp;</span> <span class="token number">0xfffff000</span><span class="token punctuation">;</span>                    <span class="token function">free_a_phy_page</span><span class="token punctuation">(</span>pg_phy_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                pte_idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/* 将pde中记录的物理页框直接在相应内存池的位图中清0 */</span>            pg_phy_addr <span class="token operator">=</span> pde <span class="token operator">&amp;</span> <span class="token number">0xfffff000</span><span class="token punctuation">;</span>            <span class="token function">free_a_phy_page</span><span class="token punctuation">(</span>pg_phy_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        pde_idx<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* 回收用户虚拟地址池所占的物理内存*/</span>    <span class="token class-name">uint32_t</span> bitmap_pg_cnt <span class="token operator">=</span> <span class="token punctuation">(</span>release_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>btmp_bytes_len<span class="token punctuation">)</span> <span class="token operator">/</span> PG_SIZE<span class="token punctuation">;</span>    <span class="token class-name">uint8_t</span> <span class="token operator">*</span>user_vaddr_pool_bitmap <span class="token operator">=</span> release_thread<span class="token operator">-></span>userprog_vaddr<span class="token punctuation">.</span>vaddr_bitmap<span class="token punctuation">.</span>bits<span class="token punctuation">;</span>    <span class="token function">mfree_page</span><span class="token punctuation">(</span>PF_KERNEL<span class="token punctuation">,</span> user_vaddr_pool_bitmap<span class="token punctuation">,</span> bitmap_pg_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 关闭进程打开的文件 */</span>    <span class="token class-name">uint8_t</span> local_fd <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>local_fd <span class="token operator">&lt;</span> MAX_FILES_OPEN_PER_PROC<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>release_thread<span class="token operator">-></span>fd_table<span class="token punctuation">[</span>local_fd<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_pipe</span><span class="token punctuation">(</span>local_fd<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token class-name">uint32_t</span> global_fd <span class="token operator">=</span> <span class="token function">fd_local2global</span><span class="token punctuation">(</span>local_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">&#123;</span>                    <span class="token function">mfree_page</span><span class="token punctuation">(</span>PF_KERNEL<span class="token punctuation">,</span> file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    file_table<span class="token punctuation">[</span>global_fd<span class="token punctuation">]</span><span class="token punctuation">.</span>fd_inode <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                <span class="token function">sys_close</span><span class="token punctuation">(</span>local_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        local_fd<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试管道的用户进程（<strong>command/prog_pipe.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdint.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">int32_t</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>                 <span class="token comment">// 父进程</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭输入</span>        <span class="token function">write</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"Hi, my son, I love you!"</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nI`m father, my pid is %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 关闭输出</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nI`m child, my pid is %d\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I`m child, my father said to me: \"%s\"\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">9</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理prog_pipe的脚本</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">####  此脚本应该在command目录下执行<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token operator">-</span>d <span class="token string">"../lib"</span> <span class="token operator">||</span> <span class="token operator">!</span> <span class="token operator">-</span>d <span class="token string">"../build"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>then   echo <span class="token string">"dependent dir don\`t exist!"</span>   cwd<span class="token operator">=</span>$<span class="token punctuation">(</span>pwd<span class="token punctuation">)</span>   cwd<span class="token operator">=</span>$<span class="token punctuation">&#123;</span>cwd##<span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">&#125;</span>   cwd<span class="token operator">=</span>$<span class="token punctuation">&#123;</span>cwd<span class="token operator">%</span><span class="token operator">/</span><span class="token punctuation">&#125;</span>   <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> $cwd <span class="token operator">!=</span> <span class="token string">"command"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>then      echo <span class="token operator">-</span>e <span class="token string">"you\`d better in command dir\n"</span>   fi    exitfiCC<span class="token operator">=</span><span class="token string">"gcc-4.4"</span>BIN<span class="token operator">=</span><span class="token string">"prog_pipe"</span>CFLAGS<span class="token operator">=</span><span class="token string">"-Wall -c -fno-builtin -W -Wstrict-prototypes \    -Wmissing-prototypes -Wsystem-headers -m32 -fno-stack-protector"</span>LIBS<span class="token operator">=</span><span class="token string">"-I ../lib/ -I ../lib/kernel/ -I ../lib/user/ -I \      ../kernel/ -I ../device/ -I ../thread/ -I \      ../userprog/ -I ../fs/ -I ../shell/"</span>OBJS<span class="token operator">=</span><span class="token string">"../build/string.o ../build/syscall.o \      ../build/stdio.o ../build/assert.o start.o"</span>DD_IN<span class="token operator">=</span>$BINDD_OUT<span class="token operator">=</span><span class="token string">"/home/rlk/Desktop/bochs/hd60M.img"</span>nasm <span class="token operator">-</span>f elf <span class="token punctuation">.</span><span class="token operator">/</span>start<span class="token punctuation">.</span>S <span class="token operator">-</span>o <span class="token punctuation">.</span><span class="token operator">/</span>start<span class="token punctuation">.</span>oar rcs simple_crt<span class="token punctuation">.</span>a $OBJS start<span class="token punctuation">.</span>o$CC $CFLAGS $LIBS <span class="token operator">-</span>o $BIN<span class="token string">".o"</span> $BIN<span class="token string">".c"</span>ld $BIN<span class="token string">".o"</span> simple_crt<span class="token punctuation">.</span>a <span class="token operator">-</span>o $BIN <span class="token operator">-</span>m elf_i386SEC_CNT<span class="token operator">=</span>$<span class="token punctuation">(</span>ls <span class="token operator">-</span>l $BIN<span class="token operator">|</span>awk <span class="token char">'&#123;printf("%d", ($5+511)/512)&#125;'</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">-</span>f $BIN <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>then   dd <span class="token keyword">if</span><span class="token operator">=</span><span class="token punctuation">.</span><span class="token operator">/</span>$DD_IN of<span class="token operator">=</span>$DD_OUT bs<span class="token operator">=</span><span class="token number">512</span> \   count<span class="token operator">=</span>$SEC_CNT seek<span class="token operator">=</span><span class="token number">300</span> conv<span class="token operator">=</span>notruncfi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码，用于将prog_pipe从hd60M.img加载到hd80M.img中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fork.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"assert.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shell.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ide.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio-kernel.h"</span></span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> file_size <span class="token operator">=</span> <span class="token number">21432</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> sec_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>file_size<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">disk</span> <span class="token operator">*</span>sda <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>prog_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>file_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ide_read</span><span class="token punctuation">(</span>sda<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> sec_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/prog_pipe"</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> file_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file write error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">cls_screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">"[rabbit@localhost /]$ "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_exit</span><span class="token punctuation">(</span><span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* init进程 */</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> ret_pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token keyword">int</span> child_pid<span class="token punctuation">;</span>        <span class="token comment">/* init在此处不停的回收僵尸进程 */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            child_pid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I`m init, My pid is 1, I recieve a child, It`s pid is %d, status is %d\n"</span><span class="token punctuation">,</span> child_pid<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"init: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小节k：</p><p>在shell中支持管道</p><p>一般来说，键盘充当程序的输入源，而屏幕则是程序的输出目标，这被称为标准输入和输出。然而，程序也可以从文件接收输入或将其输出发送到文件中，这种方式被称为非标准输入和输出。当我们想从标准输入输出切换到文件输入输出时，我们使用输入输出重定向。通过这种方式，我们可以将一个命令的输出用作另一个命令的输入，这正是管道的功能。在Linux中，这种操作通常是通过命令行的管道符“|”完成的。例如，在命令<code>ls | grep kanshan</code>中，<code>ls</code>命令列出当前目录下的所有文件并原本会将其输出到屏幕，但由于存在管道符<code>|</code>，它的输出会利用管道重定向为<code>grep</code>命令的输入。</p><p><code>sys_fd_redirect</code>其功能是将一个已有的文件描述符<code>old_local_fd</code>重定向为另一个文件描述符<code>new_local_fd</code>。实际用法如：<code>fd_redirect(1,fd[1]);</code>（fd[1]是管道文件对应的文件描述符，其全局文件结构索引一定大于2）用于标准输入重定位到管道文件（结合<code>sys_write</code>理解）；<code>fd_redirect(1,1);</code>用于恢复标准输出（结合<code>sys_write</code>理解）</p><p>修改（<strong>shell/pipe.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将文件描述符old_local_fd重定向为new_local_fd */</span><span class="token keyword">void</span> <span class="token function">sys_fd_redirect</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> old_local_fd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> new_local_fd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>cur <span class="token operator">=</span> <span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 针对恢复标准描述符 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>new_local_fd <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        cur<span class="token operator">-></span>fd_table<span class="token punctuation">[</span>old_local_fd<span class="token punctuation">]</span> <span class="token operator">=</span> new_local_fd<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token class-name">uint32_t</span> new_global_fd <span class="token operator">=</span> cur<span class="token operator">-></span>fd_table<span class="token punctuation">[</span>new_local_fd<span class="token punctuation">]</span><span class="token punctuation">;</span>        cur<span class="token operator">-></span>fd_table<span class="token punctuation">[</span>old_local_fd<span class="token punctuation">]</span> <span class="token operator">=</span> new_global_fd<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数声明，修改（<strong>shell/pipe.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sys_fd_redirect</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> old_local_fd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> new_local_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>sys_help</code>打印系统支持的内部命令</p><p>修改（<strong>fs/fs.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 显示系统支持的内部命令 */</span><span class="token keyword">void</span> <span class="token function">sys_help</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"\ buildin commands:\n\       ls: show directory or file information\n\       cd: change current work directory\n\       mkdir: create a directory\n\       rmdir: remove a empty directory\n\       rm: remove a regular file\n\       pwd: show current work directory\n\       ps: show process information\n\       clear: clear screen\n\ shortcut key:\n\       ctrl+l: clear screen\n\       ctrl+u: clear input\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加声明，修改（<strong>fs/fs.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sys_help</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将<code>sys_fd_redirect</code>与<code>sys_help</code>做成系统调用</p><p>添加系统调用号，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">SYSCALL_NR</span><span class="token punctuation">&#123;</span>    SYS_GETPID<span class="token punctuation">,</span>    SYS_WRITE<span class="token punctuation">,</span>    SYS_MALLOC<span class="token punctuation">,</span>    SYS_FREE<span class="token punctuation">,</span>    SYS_FORK<span class="token punctuation">,</span>    SYS_READ<span class="token punctuation">,</span>    SYS_PUTCHAR<span class="token punctuation">,</span>    SYS_CLEAR<span class="token punctuation">,</span>    SYS_GETCWD<span class="token punctuation">,</span>    SYS_OPEN<span class="token punctuation">,</span>    SYS_CLOSE<span class="token punctuation">,</span>    SYS_LSEEK<span class="token punctuation">,</span>    SYS_UNLINK<span class="token punctuation">,</span>    SYS_MKDIR<span class="token punctuation">,</span>    SYS_OPENDIR<span class="token punctuation">,</span>    SYS_CLOSEDIR<span class="token punctuation">,</span>    SYS_CHDIR<span class="token punctuation">,</span>    SYS_RMDIR<span class="token punctuation">,</span>    SYS_READDIR<span class="token punctuation">,</span>    SYS_REWINDDIR<span class="token punctuation">,</span>    SYS_STAT<span class="token punctuation">,</span>    SYS_PS<span class="token punctuation">,</span>    SYS_EXECV<span class="token punctuation">,</span>    SYS_EXIT<span class="token punctuation">,</span>    SYS_WAIT<span class="token punctuation">,</span>    SYS_PIPE<span class="token punctuation">,</span>    SYS_FD_REDIRECT<span class="token punctuation">,</span>    SYS_HELP<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现用户态系统调用入口，修改（<strong>lib/user/syscall.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 将文件描述符old_local_fd重定向到new_local_fd */</span><span class="token keyword">void</span> <span class="token function">fd_redirect</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> old_local_fd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> new_local_fd<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">_syscall2</span><span class="token punctuation">(</span>SYS_FD_REDIRECT<span class="token punctuation">,</span> old_local_fd<span class="token punctuation">,</span> new_local_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* 显示系统支持的命令 */</span><span class="token keyword">void</span> <span class="token function">help</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">_syscall0</span><span class="token punctuation">(</span>SYS_HELP<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明用户态系统调用函数，修改（<strong>lib/user/syscall.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">fd_redirect</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> old_local_fd<span class="token punctuation">,</span> <span class="token class-name">uint32_t</span> new_local_fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">help</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>系统调用表添加实际系统调用处理函数，修改（<strong>userprog/syscall-init.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 初始化系统调用 */</span><span class="token keyword">void</span> <span class="token function">syscall_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init start\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETPID<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getpid<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_WRITE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_write<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MALLOC<span class="token punctuation">]</span> <span class="token operator">=</span> sys_malloc<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FREE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_free<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FORK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_fork<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READ<span class="token punctuation">]</span> <span class="token operator">=</span> sys_read<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PUTCHAR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_putchar<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLEAR<span class="token punctuation">]</span> <span class="token operator">=</span> cls_screen<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_GETCWD<span class="token punctuation">]</span> <span class="token operator">=</span> sys_getcwd<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPEN<span class="token punctuation">]</span> <span class="token operator">=</span> sys_open<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_close<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_LSEEK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_lseek<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_UNLINK<span class="token punctuation">]</span> <span class="token operator">=</span> sys_unlink<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_MKDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_mkdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_OPENDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_opendir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CLOSEDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_closedir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_CHDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_chdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_RMDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rmdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_READDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_readdir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_REWINDDIR<span class="token punctuation">]</span> <span class="token operator">=</span> sys_rewinddir<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_STAT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_stat<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PS<span class="token punctuation">]</span> <span class="token operator">=</span> sys_ps<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_EXECV<span class="token punctuation">]</span> <span class="token operator">=</span> sys_execv<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_EXIT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_exit<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_WAIT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_wait<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_PIPE<span class="token punctuation">]</span> <span class="token operator">=</span> sys_pipe<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_FD_REDIRECT<span class="token punctuation">]</span> <span class="token operator">=</span> sys_fd_redirect<span class="token punctuation">;</span>    syscall_table<span class="token punctuation">[</span>SYS_HELP<span class="token punctuation">]</span> <span class="token operator">=</span> sys_help<span class="token punctuation">;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"syscall_init done\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将<code>help</code>封装成内建命令，修改（<strong>shell/buildin_cmd.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 显示内建命令列表 */</span><span class="token keyword">void</span> <span class="token function">buildin_help</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc UNUSED<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv UNUSED<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">help</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token number">123456</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明，修改（<strong>shell/buildin_cmd.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">buildin_help</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc UNUSED<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv UNUSED<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>cmd_execute</code>去取代原有shell中执行内部与外部命令功能</p><p>修改（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 执行命令 */</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cmd_execute</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"ls"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">buildin_ls</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"cd"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">buildin_cd</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">memset</span><span class="token punctuation">(</span>cwd_cache<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">strcpy</span><span class="token punctuation">(</span>cwd_cache<span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">buildin_pwd</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"ps"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">buildin_ps</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"clear"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">buildin_clear</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"mkdir"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">buildin_mkdir</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"rmdir"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">buildin_rmdir</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"rm"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">buildin_rm</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token string">"help"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">buildin_help</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 如果是外部命令,需要从磁盘上加载</span>        <span class="token class-name">int32_t</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pid<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>            <span class="token class-name">int32_t</span> status<span class="token punctuation">;</span>            <span class="token class-name">int32_t</span> child_pid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此时子进程若没有执行exit,my_shell会被阻塞,不再响应键入的命令</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>child_pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span> <span class="token comment">// 按理说程序正确的话不会执行到这句,fork出的进程便是shell子进程</span>                <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"my_shell: no child\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"child_pid %d, it's status: %d\n"</span><span class="token punctuation">,</span> child_pid<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>            <span class="token function">make_clear_abs_path</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> final_path<span class="token punctuation">)</span><span class="token punctuation">;</span>            argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> final_path<span class="token punctuation">;</span>            <span class="token comment">/* 先判断下文件是否存在 */</span>            <span class="token keyword">struct</span> <span class="token class-name">stat</span> file_stat<span class="token punctuation">;</span>            <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>file_stat<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">stat</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">stat</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>file_stat<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"my_shell: cannot access %s: No such file or directory\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                <span class="token function">execv</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新的<code>my_shell</code>，主要功能是从用户获取命令行输入，解析并执行命令，尤其支持管道<code>|</code>命令的功能。</p><p>主要新增部分：检查用户输入中是否包含管道符号<code>|</code></p><ul><li>如果有管道命令：<ol><li>创建一个管道。</li><li>重定向标准输出到管道的写端。</li><li>解析并执行第一个命令。</li><li>重定向标准输入到管道的读端。</li><li>对于每一个中间的命令（除了最后一个）：<ul><li>解析并执行命令。</li></ul></li><li>恢复标准输出到屏幕。</li><li>执行管道中的最后一个命令。</li><li>恢复标准输入为键盘。</li><li>关闭管道。</li></ol></li><li>如果没有管道命令：<ol><li>解析用户输入的命令。</li><li>如果参数数量超过了设定的最大值，则提示错误。</li><li>否则执行命令。</li></ol></li></ul><p>修改（<strong>shell/shell.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"pipe.h"</span></span><span class="token keyword">void</span> <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cwd_cache<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'/'</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">print_prompt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>final_path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">readline</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> MAX_PATH_LEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmd_line<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 若只键入了一个回车</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/* 针对管道的处理 */</span>        <span class="token keyword">char</span> <span class="token operator">*</span>pipe_symbol <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> <span class="token char">'|'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pipe_symbol<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">/* 支持多重管道操作,如cmd1|cmd2|..|cmdn,             * cmd1的标准输出和cmdn的标准输入需要单独处理 */</span>            <span class="token comment">/*1 生成管道*/</span>            <span class="token class-name">int32_t</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// fd[0]用于输入,fd[1]用于输出</span>            <span class="token function">pipe</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 将标准输出重定向到fd[1],使后面的输出信息重定向到内核环形缓冲区 */</span>            <span class="token function">fd_redirect</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/*2 第一个命令 */</span>            <span class="token keyword">char</span> <span class="token operator">*</span>each_cmd <span class="token operator">=</span> cmd_line<span class="token punctuation">;</span>            pipe_symbol <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>each_cmd<span class="token punctuation">,</span> <span class="token char">'|'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">*</span>pipe_symbol <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment">/* 执行第一个命令,命令的输出会写入环形缓冲区 */</span>            argc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            argc <span class="token operator">=</span> <span class="token function">cmd_parse</span><span class="token punctuation">(</span>each_cmd<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">cmd_execute</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 跨过'|',处理下一个命令 */</span>            each_cmd <span class="token operator">=</span> pipe_symbol <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">/* 将标准输入重定向到fd[0],使之指向内核环形缓冲区*/</span>            <span class="token function">fd_redirect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/*3 中间的命令,命令的输入和输出都是指向环形缓冲区 */</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pipe_symbol <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>each_cmd<span class="token punctuation">,</span> <span class="token char">'|'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token operator">*</span>pipe_symbol <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                argc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                argc <span class="token operator">=</span> <span class="token function">cmd_parse</span><span class="token punctuation">(</span>each_cmd<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">cmd_execute</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>                each_cmd <span class="token operator">=</span> pipe_symbol <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">/*4 处理管道中最后一个命令 */</span>            <span class="token comment">/* 将标准输出恢复屏幕 */</span>            <span class="token function">fd_redirect</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/* 执行最后一个命令 */</span>            argc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            argc <span class="token operator">=</span> <span class="token function">cmd_parse</span><span class="token punctuation">(</span>each_cmd<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">cmd_execute</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/*5  将标准输入恢复为键盘 */</span>            <span class="token function">fd_redirect</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/*6 关闭管道 */</span>            <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span> <span class="token comment">// 一般无管道操作的命令</span>            argc <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            argc <span class="token operator">=</span> <span class="token function">cmd_parse</span><span class="token punctuation">(</span>cmd_line<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num of arguments exceed %d\n"</span><span class="token punctuation">,</span> MAX_ARG_NR<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token function">cmd_execute</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"my_shell: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>cat</code>新增无参数时从键盘获得输入（记得删除原有hd80M.img中的cat）</p><p>（<strong>command/cat.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"string.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fs.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cat: argument error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> buf_size <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> abs_path<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>buf <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>buf <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cat: malloc memory failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">getcwd</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">strcat</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">strcat</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        <span class="token function">strcpy</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>abs_path<span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"cat: open: open %s failed\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> read_bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        read_bytes <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> buf_size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>read_bytes <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">write</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> read_bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">free</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">66</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理cat的脚本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">####  此脚本应该在command目录下执行</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"../lib"</span> <span class="token operator">||</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"../build"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>   <span class="token builtin class-name">echo</span> <span class="token string">"dependent dir don\`t exist!"</span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">pwd</span><span class="token variable">)</span></span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable">$&#123;cwd<span class="token operator">##</span>*<span class="token operator">/</span>&#125;</span>   <span class="token assign-left variable">cwd</span><span class="token operator">=</span><span class="token variable">$&#123;cwd<span class="token operator">%</span><span class="token operator">/</span>&#125;</span>   <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$cwd</span> <span class="token operator">!=</span> <span class="token string">"command"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>      <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"you\`d better in command dir<span class="token entity" title="\n">\n</span>"</span>   <span class="token keyword">fi</span>    <span class="token builtin class-name">exit</span><span class="token keyword">fi</span><span class="token assign-left variable">CC</span><span class="token operator">=</span><span class="token string">"gcc-4.4"</span><span class="token assign-left variable">BIN</span><span class="token operator">=</span><span class="token string">"cat"</span><span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">"-Wall -c -fno-builtin -W -Wstrict-prototypes \    -Wmissing-prototypes -Wsystem-headers -m32 -fno-stack-protector"</span><span class="token assign-left variable">LIBS</span><span class="token operator">=</span><span class="token string">"-I ../lib/ -I ../lib/kernel/ -I ../lib/user/ -I \      ../kernel/ -I ../device/ -I ../thread/ -I \      ../userprog/ -I ../fs/ -I ../shell/"</span><span class="token assign-left variable">OBJS</span><span class="token operator">=</span><span class="token string">"../build/string.o ../build/syscall.o \      ../build/stdio.o ../build/assert.o start.o"</span><span class="token assign-left variable">DD_IN</span><span class="token operator">=</span><span class="token variable">$BIN</span><span class="token assign-left variable">DD_OUT</span><span class="token operator">=</span><span class="token string">"/home/rlk/Desktop/bochs/hd60M.img"</span>nasm <span class="token parameter variable">-f</span> elf ./start.S <span class="token parameter variable">-o</span> ./start.oar rcs simple_crt.a <span class="token variable">$OBJS</span> start.o<span class="token variable">$CC</span> <span class="token variable">$CFLAGS</span> <span class="token variable">$LIBS</span> <span class="token parameter variable">-o</span> <span class="token variable">$BIN</span><span class="token string">".o"</span> <span class="token variable">$BIN</span><span class="token string">".c"</span>ld <span class="token variable">$BIN</span><span class="token string">".o"</span> simple_crt.a <span class="token parameter variable">-o</span> <span class="token variable">$BIN</span> <span class="token parameter variable">-m</span> elf_i386<span class="token assign-left variable">SEC_CNT</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span> <span class="token parameter variable">-l</span> $BIN<span class="token operator">|</span><span class="token function">awk</span> '<span class="token punctuation">&#123;</span>printf<span class="token punctuation">(</span><span class="token string">"%d"</span>, <span class="token punctuation">(</span>$5+511<span class="token punctuation">)</span>/512<span class="token variable">)</span></span><span class="token punctuation">&#125;</span>'<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token parameter variable">-f</span> <span class="token variable">$BIN</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">then</span>   <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>./<span class="token variable">$DD_IN</span> <span class="token assign-left variable">of</span><span class="token operator">=</span><span class="token variable">$DD_OUT</span> <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token punctuation">\</span>   <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token variable">$SEC_CNT</span> <span class="token assign-left variable">seek</span><span class="token operator">=</span><span class="token number">300</span> <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码，（<strong>kernel/main.c</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"print.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"init.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"fork.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"syscall.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"assert.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shell.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"console.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ide.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"stdio-kernel.h"</span></span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">put_str</span><span class="token punctuation">(</span><span class="token string">"I am kernel\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">init_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> file_size <span class="token operator">=</span> <span class="token number">21816</span><span class="token punctuation">;</span>    <span class="token class-name">uint32_t</span> sec_cnt <span class="token operator">=</span> <span class="token function">DIV_ROUND_UP</span><span class="token punctuation">(</span>file_size<span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">disk</span> <span class="token operator">*</span>sda <span class="token operator">=</span> <span class="token operator">&amp;</span>channels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>devices<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>prog_buf <span class="token operator">=</span> <span class="token function">sys_malloc</span><span class="token punctuation">(</span>file_size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ide_read</span><span class="token punctuation">(</span>sda<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> sec_cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">int32_t</span> fd <span class="token operator">=</span> <span class="token function">sys_open</span><span class="token punctuation">(</span><span class="token string">"/cat"</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">sys_write</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> prog_buf<span class="token punctuation">,</span> file_size<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"file write error!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                <span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">cls_screen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">console_put_str</span><span class="token punctuation">(</span><span class="token string">"[rabbit@localhost /]$ "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">thread_exit</span><span class="token punctuation">(</span><span class="token function">running_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* init进程 */</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">uint32_t</span> ret_pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret_pid<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 父进程</span>        <span class="token keyword">int</span> status<span class="token punctuation">;</span>        <span class="token keyword">int</span> child_pid<span class="token punctuation">;</span>        <span class="token comment">/* init在此处不停的回收僵尸进程 */</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            child_pid <span class="token operator">=</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I`m init, My pid is 1, I recieve a child, It`s pid is %d, status is %d\n"</span><span class="token punctuation">,</span> child_pid<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span> <span class="token comment">// 子进程</span>        <span class="token function">my_shell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"init: should not be here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行出错，排查后需要修改（<strong>device/ioqueue.h</strong>）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">bufsize</span> <span class="token expression"><span class="token number">64</span> </span><span class="token comment">//定义缓冲区大小.</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">bufsize</span> <span class="token expression"><span class="token number">2048</span> </span><span class="token comment">//定义缓冲区大小.</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下班下班</p>]]></content>
      
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt &amp;&amp; Opencv Config</title>
      <link href="/2023/06/01/Qt-Opencv-Config/"/>
      <url>/2023/06/01/Qt-Opencv-Config/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Qt-opencv各平台编译方法的水博客1（代价是搞了N久）"><a href="#关于Qt-opencv各平台编译方法的水博客1（代价是搞了N久）" class="headerlink" title="关于Qt + opencv各平台编译方法的水博客1（代价是搞了N久）"></a>关于Qt + opencv各平台编译方法的水博客1（代价是搞了N久）</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​        正确选择模块的版本是必要的                                        ——爹的 instruction</p><p>​        首先，如果你是一个构件库者，哥们建议你仔细看看这帮写博客的人他们构建配置的版本是多少！防止坑上加坑，导致人寄上加寄！</p><p>​        下面，我将介绍一下简单的 Windows11/Linux-Ubuntu20.04 Qt5.12.8/Qt6.6.0 + Opencv 4.6.0/Opencv 4.5.3， 如果你是想在自己的电脑上搭建上述系统，烦请按照我下面给出的若干的reference version, 否则在编译，安装，运行，到最后的打包出了问题。。。很正常就会，以及，以及</p><p><strong>注意到本博客尚未解决：基于Windows11下如此操作方法qt6.6.0 + mingw_64bits打包程序的可移植性的问题，具体表现为于纯净Win10下爆出 RunTimeError - Unknown Terminate 以及Windows11下程序双击无反应的问题</strong></p><p>​        成功解决的是下面的，全流程简单的概括为👇</p><h2 id="Windows11-Qt-5-12-8-Opencv4-5-3"><a href="#Windows11-Qt-5-12-8-Opencv4-5-3" class="headerlink" title="Windows11 + Qt 5.12.8 + Opencv4.5.3"></a>Windows11 + Qt 5.12.8 + Opencv4.5.3</h2><p>​        首先，我们需要的是获取上面我提到的资源。</p><p>​        如果打算配置的是6.6.0，Cmake可以不用下，qt有自己自带的Cmake-gui，但是低版本的不自带Cmake-gui，需要自己来下载。</p><p>​        Qt 5.12.8可以通过点击这里获取：<a href="https://download.qt.io/new_archive/qt/5.12/5.12.8/qt-opensource-windows-x86-5.12.8.exe">qt-opensource-windows-x86-5.12.8.exe</a></p><p>​        或者，你想要浏览其他的版本，看这里：<a href="https://download.qt.io/new_archive/qt/">Index of /new_archive/qt</a></p><p>​        至于 opencv，这里给出传送门：</p><p>​        opencv:<a href="https://opencv.org/releases/">Releases - OpenCV</a>，对了，有人有疑问：我是该安装Source版本的还是Windows版本的呢？都一样，前者直接得到压缩包，后者是一个解压程序。基本一致的！结合自身的需求来！</p><p>​        opencv_contrib :  这个用户贡献的contribution的子模块，是需要到 github那里去下载的！注意到这里给出的是 opencv_contrib 4.x 的教程。读者可以自行尝试opencv_contrib 5.x的联合编译。<a href="https://github.com/opencv/opencv_contrib/tree/4.x（不过，不建议编译这个，我自己尝试过在后续的编译中这个会爆炸（爆一大堆错误））">https://github.com/opencv/opencv_contrib/tree/4.x（不过，不建议编译这个，我自己尝试过在后续的编译中这个会爆炸（爆一大堆错误））</a></p><p>​        我们下载好了之后。得到的是若干的压缩包和一个QT安装的SDK。</p><h3 id="安装QT"><a href="#安装QT" class="headerlink" title="安装QT"></a>安装QT</h3><p>​        原则上讲，这个版本的QT不使用线上安装，意味之我们不需要配置Qt tempory repository.注意到如果你先前有一个qt账号，登陆即可，反之，注册一个！直接选择对应的编译包和SDK包就可以了。为了联合演示 mingw_32, mingw_64, MSVC2017_32,MSVC_64编译器下的编译行为，这里我就都下载了，以及，在Tools选择上也都选择了MSVC编译器和mingw编译器（tnnd,13.8G）。Qt作为桌面开发的经典工具，安装也是press几个按钮的事情。这里就不细说说明了。</p><h3 id="安装opencv"><a href="#安装opencv" class="headerlink" title="安装opencv"></a>安装opencv</h3><p>​        解压就完事了！</p><h3 id="开始联合编译Qt-opencv"><a href="#开始联合编译Qt-opencv" class="headerlink" title="开始联合编译Qt + opencv"></a>开始联合编译Qt + opencv</h3><p>​        我们将opencv得到的资源，分别置于一个空间比较大的地方。比如说我的D盘（）。</p><p>​        专门建立一个文件夹，叫：</p><pre class="line-numbers language-none"><code class="language-none">Qt5_12_Opencv453Compile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在底下，再建立三个文件夹！</p><p><img src="image-20230602103923847.png" alt="image-20230602103923847"></p><p><img src="image-20230602103930586.png" alt="image-20230602103930586"></p><p>​        如上图所示。也就是：</p><pre class="line-numbers language-none"><code class="language-none">opencv_buildopencv_contribopencv_source<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我想，你从名字就知道了——<code>opencv_source</code>装源码，把<code>Opencv4.5.3</code>的源码内容放到这里, <code>opencv_contrib</code> 装用户贡献模块，把contrib的所有内容放到这里，而<code>opencv_build</code>,任何一个熟知Cmake编译的人都知道装编译的结果的。</p><p>​        现在，打开你的Cmake-gui</p><p>​    <img src="image-20230602121940454.png" alt="image-20230602121940454"></p><p>​        你的<code>Where is the source code</code>和<code>where to build the binaries</code>，如果先前没有用过会是空的！source code自然在<code>opencv_source</code>下，build产生的文件放到<code>opencv_build</code>下，就像这样一样。</p><p>​        点击Advanced 和 Grouped,防止自己老花眼找半天的Cmake变量。点击Configure</p><p><img src="image-20230602122308408.png" alt="image-20230602122308408"></p><p>​        默认下，这里是没有编译器的，现在，选择Specify native Compliers（指定本地编译器），点击之</p><p><img src="image-20230602122412384.png" alt="image-20230602122412384"></p><p>​        下拉找到<code>Mingw Makefiles</code>，这就是我们想要的编译器了！</p><p>​        Config结束后，点击Next.</p><p>​        指定好自己C,C++语言的编译器位置，他们在自己QT安装的文件下的。</p><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\Tools\mingw730_64\bin\gcc.exe &#x2F;&#x2F; for C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\Tools\mingw730_64\bin\g++.exe &#x2F;&#x2F; for C++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230602122748504.png" alt="image-20230602122748504"></p><p>​        可以看到正在配置了。</p><p>​        同时，记得添加编译器到环境变量！</p><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\5.12.8\mingw73_64\bin;D:\QT\Qt5.12.12\Tools\mingw730_64;D:\QT\Qt5.12.8\Tools\mingw730_64\x86_64-w64-mingw32\bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        他们稍后是为了使系统可以找到Qt库来运行Qt的！</p><p>​        待到你添加完毕之后，现在，回到Cmake界面是满山红</p><p><img src="image-20230602123431972.png" alt="image-20230602123431972"></p><p>​        下面开始配置选项</p><p>​        1. 打开with_OpenGL 和 With_Qt,他们在WITH group下面</p><p>​        2. 配置好contrib模块，就是在Opencv Group下，找到这样的一个变量     OPENCV_EXTRA_MODOLES_PATH</p><p>​        给他写上：</p><pre class="line-numbers language-none"><code class="language-none">D:\QT5_12_Opencv453Compile\opencv_contrib\modules<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        呐！就是我们存放<code>contrib</code>模块下面的<code>modules</code>模块，注意。</p><p>​        再次重新配置：点击Configure</p><p>​        正常来讲，再次编译过后，是不会有红色出现的！但是我这里还是红色出现了！</p><p>​        是Qt5的库路径不知道。给我默认到自己的Anaconda的库里去了。自己手动修改一下，同时，留意一下正斜杠与反斜杠的区别（fuck Windows）</p><p><img src="image-20230602124437202.png" alt="image-20230602124437202"></p><p>​        _这里是为了测试mingw32编译才选择的32编译器_（WRANING!后续的编译中尝试过了！不建议选择这个，64位的系统就选择mingw64!）如果你不想打包库的话，可以选择64位编译器。</p><p>​        以及我看到有教程建议在Opencv的变量中只勾选opencv_world. 这是把若干的库编译成一个，显得笨重！这里就不这样做了！</p><p>​        点击Config</p><p><img src="image-20230602124653801.png" alt="image-20230602124653801"></p><p>​        (留心一下产生的清单里有没有都配置成为你想要的环境，确定了再点击！)</p><p>​        再点击Generate生成可以用的MakeFile.</p><h3 id="PowerShell启用mingw32编译源代码"><a href="#PowerShell启用mingw32编译源代码" class="headerlink" title="PowerShell启用mingw32编译源代码"></a>PowerShell启用mingw32编译源代码</h3><p><img src="image-20230602124918062.png" alt="image-20230602124918062"></p><pre class="line-numbers language-none"><code class="language-none">mingw32-make -j 8 &#x2F;&#x2F; 8 is then_recommend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        后来还是调成8了，因为有一定概率产生多线程编译错误导致编译中止！</p><p>​        CD到自己的Build文件下，敲这个指令！（哈哈，其实是让他所有的CPU资源来调动编译之，可不想等1个小时）</p><p><img src="image-20230602125026896.png" alt="image-20230602125026896"></p><p>​        一敲击回车，程序开始快速的编译。泡杯咖啡休息一下把。</p><p>​        中间可能存在跑错！注意！明确选择的编译器是64位！同时，注意反复确认引入的Cmake选项指向的环境是你想要的那个（错一点都不行！）</p><p>​        _不！要！mingw编译器 停止编译了还要继续继续在原文件夹下再输mingw32-make_了，否则可能会跳过一些库的生成！导致后面程序应用后异常崩溃！</p><pre class="line-numbers language-none"><code class="language-none">mingw32-make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        下载好刚刚那些库！</p><p><img src="image-20230602135455371.png" alt="image-20230602135455371"></p><p>​        现在，我们下载好的库，就在</p><p><img src="image-20230602135533374.png" alt="image-20230602135533374"></p><p>以及opencv可用的文件在：</p><p><img src="image-20230602135559565.png" alt="image-20230602135559565"></p><p>​        打开QT，整一个MainWindow工程。</p><p>​        现在开始检验你配置的是否成功了！（大喜）</p><p>​        在PRO工程文件下，添加</p><pre class="line-numbers language-none"><code class="language-none">INCLUDEPATH +&#x3D; D:\QT5_12_Opencv453Compile\opencv_build\install\includeLIBS +&#x3D; D:\QT5_12_Opencv453Compile\opencv_build\install\x64\mingw\bin\libopencv_*.dll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <strong>然！后！Ctrl+S重载一下工程，否则下面别让自己白忙活！</strong></p><p>​        尝试一下，在MainWindow.cpp下整点：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;opencv2&#x2F;opencv.hpp&gt; &#x2F;&#x2F; 关键时刻！#include&lt;QDebug&gt;using namespace cv;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    Mat img &#x3D; imread(&quot;D:\\QT projects\\5128opencv\\1.png&quot;);&#x2F;&#x2F;嘿！这个别照搬地址！哥们找自己的一张图片扔进来它的地址！    if(img.empty())&#123;       qDebug() &lt;&lt; &quot;Error in loading picture&quot;;    &#125;    namedWindow(&quot;Display window&quot;, WINDOW_AUTOSIZE );    imshow(&quot;Display window&quot;,img);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        好了，如果，我说如果，没有什么问题，那恭喜可以开摆了。。。</p><p>​        但是如果没有呢？</p><p>​        0. Can not find opencv2/opencv.hpp: 好好看看你有没有Ctrl + S你的工程</p><p>​        1.Unrecognize File Format</p><p>​        当你运行上面的代码在QConsole上扔出了这个错误的时候，注意选好你的编译器套餐！留意到你用了什么编译器编译的opencv+QT，就使用哪款编译器！</p><pre><code>    2. ​        程序异常结束</code></pre><p>​        哥们太倒霉了！程序不认识库！也就是说，他没办法按照你给的路径去寻找库，一个一点都不优雅的方法，就是把 自己编译产生的库，在install/x64/bin下的库，原封不动的扔到自己的debug或者是release文件夹下，让G++/GCC编译的时候直接在本地工作文件夹下找到库从而避免一场结束！（Windows的这个屏蔽了过多的细节，没办法）</p><p><img src="image-20230602141655611.png" alt="image-20230602141655611"></p><p>​        这是成功的界面！</p><h3 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h3><p>​        成功了！后面经过调试，成功将这一个环境的qt+ opencv程序应用到了各台电脑上！（不用下载几百MB的库力，喜）</p><p>​        首先，转到自己同名目录下的：</p><pre><code>     很抽象的一个：》</code></pre><pre class="line-numbers language-none"><code class="language-none">D:\QT projects\build-5128opencv-Desktop_Qt_5_12_8_MinGW_64_bit-Release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        将这个目录下的可执行文件拿出来，和这下面的一大堆库一起</p><p><img src="image-20230602143253394.png" alt="image-20230602143253394"></p><p>​        和</p><p><img src="image-20230602143320878.png" alt="image-20230602143320878"></p><p>​        把他们拎出来：</p><p>​        扔到一个建议是<strong>全程不带一点中文名的路径（for example:你的D盘）</strong>，把我说的那一大坨东西，扔到一个新建的文件夹下。</p><p>​        现在，<strong>在应用搜索处，搜索你构建的编译器</strong>，比如说根据这个名字：</p><pre class="line-numbers language-none"><code class="language-none">build-5128opencv-Desktop_Qt_5_12_8_MinGW_64_bit-Release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我应当选择</p><pre class="line-numbers language-none"><code class="language-none">Qt5.12.8 Mingw64bits<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后选择之运行：</p><p><img src="image-20230602144243995.png" alt="image-20230602144243995"></p><p>​        cd 到自己的构建文件夹下</p><pre class="line-numbers language-none"><code class="language-none">windeployqt yourFileName.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后就会给你配置一些库了！</p><p><img src="image-20230602144734439.png" alt="image-20230602144734439"></p><p>​        点击一下</p><p>​        Error 1： 少库了！</p><p>​        总而言之就是少库了！别慌别慌，补一下就好啦！</p><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\5.12.8\mingw73_64\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        找到自己安装QT下的这种文件夹，找到缺什么库就直接Copy即可。</p><p>​        Error 2: Terminate by unknown Error</p><p>​        反正就是扔给你这个未知的错误，本质上来讲就是少库（对可执行文件而言），可能是没有在全英文路径下打包造成。</p><p>​        Error 3：EXE文件在装死</p><p>​        嘛，说白了还是少库，有人急了（是我/(ㄒoㄒ)/~~）咋还少库啊，事实上是：库签名对不上，使用的mingw编译器下的windeployqt没有给你正确的打包！可能还是：没有在全英文路径下打包造成。实在不行库全删了，缺啥补啥！</p><p>​        Anyway，忙活了两天的(大致回忆了一下是块30多个小时处理之)配置这里说完了，下一篇博客我介绍一下<code>Linux + qt5.12.8 + opencv 4.5.3</code>的配置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
