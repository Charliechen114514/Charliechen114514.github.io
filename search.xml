<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高等数学教程（4）</title>
      <link href="/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%884%EF%BC%89/"/>
      <url>/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    定积分是从求解曲边梯形的面积产生的：就是说求解类似于如下的图像的面积</p><p><img src="image-20230124151114672.png" alt="image-20230124151114672"></p><p>​        怎么搞？我们试想一下，使用如下的方式：通过把面积切成很小的小块：</p><p>由于这些面积可以近似成矩形甚至是梯形，我们可以用面积和近似代替曲边梯形的面积。</p><p><img src="image-20230124151244623.png" alt="image-20230124151244623"></p><p>数学上是这么</p><script type="math/tex; mode=display">假设分点:a=x_0<x_1<x_2...<x_{n-1}<x_n=b</script><p>产生了</p><script type="math/tex; mode=display">\Delta x_1,\Delta x_2,...,\Delta x_n,随后令\lambda=max\{\Delta x_1,\Delta x_2,...,\Delta x_n\}</script><p>​        只要切的够小，我们就可以:$S\approx \sum_{k=1}^n \Delta x_kf(\sigma_k)$</p><p>​        其中$\sigma_k$是小区间上的一个任意点。怎么逼近真实值呢？让点取的密集一些：就是令$\lambda \rightarrow 0$就好了：产生的极限就是面积。</p><p>​        我们可以引入定积分了：</p><p>​        定义：$f(x)$在[a,b]有界，在[a,b]上任意插入若干个分点（随便插入），产生N个小区间，其长度为:$x_k(0&lt;k\leq n)$,又在区间上任意取一点$\sigma_i$，现在取出这些区间内最大长度的长度值记成$\lambda$,也就是$\lambda=max\{\Delta x_1,\Delta x_2,…\Delta x_n\}$。这下有了假设和的极限：$\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)$ 假设他存在：就引入这样的记号：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        其中a,b叫积分下限和积分上限，被积函数是f(x),积分区间是[a,b],积分变量是x</p><p>​        注意，这个值（或者说这个定积分）与积分变量无关，也就是说：</p><script type="math/tex; mode=display">\int_a^b f(t)dt=\int_a^b f(x)dx</script><p>​        定理1：函数只要连续就一定可积。</p><p>​        定理2：函数<strong>有界</strong>且<strong>有有限个间断点</strong>也可积。</p><h3 id="定积分的几何意义"><a href="#定积分的几何意义" class="headerlink" title="定积分的几何意义"></a>定积分的几何意义</h3><p>​        1.$f(x)\geq0$</p><p>​        <img src="image-20230124153747909.png" alt="image-20230124153747909"></p><p>​        就是阴影部分面积</p><p>​        2.$f(x)\leq0$</p><p><img src="image-20230124153828323.png" alt="image-20230124153828323"></p><p>​        注意是阴影部分面积的相反数，这是因为：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        中：$f(\sigma_k)&lt;0$</p><h6 id="矩阵法"><a href="#矩阵法" class="headerlink" title="矩阵法"></a>矩阵法</h6><p>​        我们使用切分成矩阵的方式来计算定积分</p><p><img src="image-20230124154130711.png" alt="image-20230124154130711"></p><h6 id="梯形法"><a href="#梯形法" class="headerlink" title="梯形法"></a>梯形法</h6><p><img src="image-20230124154214737.png" alt="image-20230124154214737"></p><p>看看就好，不用他来计算</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1）a=b下：$\int_a^b f(x)dx=0$</p><p>2)$\int_a^b f(x)dx=-\int_b^a f(x)dx$</p><p>3)$\int_a^b (\alpha f(x)+\beta g(x))dx=\alpha \int_a^b f(x)dx+\beta\int_a^b g(x)dx$</p><p>4)$\int_a^b f(x)dx=\int_a^c f(x)dx+\int_c^b f(x)dx$(切成两块加)</p><p>5)$f(x)\equiv 1,\int_a^b 1dx=b-a,\int_a^b kdx=k(b-a)$</p><p>6)$f(x)\geq 0,\int_a^b f(x)dx\geq0$</p><p>7)$f(x)\leq 0,\int_a^b f(x)dx\leq0$</p><p>8)$f(x)\leq g(x),\int_a^b f(x)dx\leq\int_a^b g(x)dx$</p><p>来点推论：</p><p>1.</p><script type="math/tex; mode=display">|\int_a^b f(x)dx|\leq\int_a^b |f(x)|dx</script><p>2.函数的极大值和极小值为$M,m$</p><script type="math/tex; mode=display">m(b-a)\leq\int_a^b f(x)dx\leq M(b-a)</script><p>9)定积分中值定理：$f(x)$连续,$\exists \xi\in[a,b]$</p><script type="math/tex; mode=display">\int_a^b f(x)dx=f(\xi)(b-a)</script><p>这个定理可以用来化简带有积分的极限</p><p><img src="image-20230124155256516.png" alt="image-20230124155256516"></p><h3 id="微积分的基本公式"><a href="#微积分的基本公式" class="headerlink" title="微积分的基本公式"></a>微积分的基本公式</h3><h4 id="积分上限函数"><a href="#积分上限函数" class="headerlink" title="积分上限函数"></a>积分上限函数</h4><p>我们把一个限变成一个变量，有点像把一边可以自由滑动，这样就有一个变限积分函数，我们把目光集中在x上：</p><script type="math/tex; mode=display">\int_a^x f(t)dt</script><p>这样定积分就从一个值变成一个函数</p><script type="math/tex; mode=display">\phi(x)=\int_a^x f(t)dt</script><p>定理1：</p><script type="math/tex; mode=display">\phi'(x)=\frac{d}{dx}\int_a^x f(t)dt=f(x)</script><p>这样来看，$\phi(x)$就是$f(x)$的一个原函数。值得一提的是：</p><script type="math/tex; mode=display">(\int_x^a f(t)dt)'=-f(x)</script><script type="math/tex; mode=display">(\int_a^{\varphi(x)} f(t)dt)'=f(\varphi(x))\varphi'(x)</script><script type="math/tex; mode=display">[\int_{\varphi(x)}^{\phi(x)}f(t)dt]'=f(\phi(x))\varphi'(x)-f(\varphi(x))\phi'(x)</script><p>上面那个可能太抽象，可以使用性质2）插入一个常数点a</p><h4 id="牛顿莱布尼兹公式"><a href="#牛顿莱布尼兹公式" class="headerlink" title="牛顿莱布尼兹公式"></a>牛顿莱布尼兹公式</h4><script type="math/tex; mode=display">\int_a^bf(x)dx=F(x)|_a^b=F(b)-F(a)</script><p>​        其中$F(x)$是$f(x)$的原函数。</p><p>例如：$\int_0^1 x^2dx$</p><p>解：=$\frac{1}{3}x^3|_0^1=\frac{1}{3}$</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><h4 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h4><p>​        定理：我们令$x=\varphi(t)$使之$\varphi(\alpha)=a,\varphi(\beta)=b$</p><script type="math/tex; mode=display">\int_a^bf(x)dx=\int_\alpha^\beta(\varphi(t))\varphi'(t)dt</script><p>例题：</p><p>1）$\int_0^a\sqrt{a^2-x^2}dx$</p><p>解：$令x=a\sin t$,$dx=a\cos tdt$</p><p>$=\int_0^{\frac{\pi}{2}}a^2\cos^2tdt=\frac{\pi}{4}a^2$</p><p>一些技巧：</p><p>1）$[-a,a]$下：$f(x)$偶：$\int_{-a}^{a}f(x)dx=2\int_{0}^{a}f(x)dx$,$f(x)$奇则为0。</p><p>2）$\int_{0}^{\frac{\pi}{2}}f(\sin x)dx=\int_{0}^{\frac{\pi}{2}}f(\cos x)dx$</p><p>3)$\int_{0}^{\pi}xf(\sin x)dx=\frac{\pi}{2}\int_0^{\pi}f(\sin x)dx$</p><p>（2）（3）怎么说？</p><p>2）令：$x=\frac{\pi}{2}-t,dx=-dt$就可以了</p><p>3）令：$x=\pi-t,dx=-dt$带入之后化简一下得到：</p><script type="math/tex; mode=display">\int_{0}^{\pi}xf(\sin x)dx=\int_{0}^{\pi}(\pi-t)f(\sin t)dt=\pi\int_{0}^{\pi}f(\sin x)dx-\int_{0}^{\pi}xf(\sin x)dx</script><p>(上面中因为与积分变量无关由此可以直接替换)</p><p>例题：$\int_0^{\pi}\frac{x\sin x}{1+\cos^2x}dx=\frac{\pi}{2}\int_0^{\pi}\frac{\sin x}{1+\cos^2x}dx=-\frac{\pi}{2}\arctan(\cos x)|_0^\pi=\frac{\pi^2}{4}$</p><p>4)$\int_a^{a+T}f(x)dx=\int_0^Tf(x)dx$(f(x)是一个周期函数，周期是T)</p><p>5）$\int_a^{a+nT}f(x)dx=n\int_0^af(x)dx$</p><h4 id="分部积分"><a href="#分部积分" class="headerlink" title="分部积分"></a>分部积分</h4><p>​        首先回顾$\int udv=uv-\int vdu$这个公式，于是，在定积分的也自然就是：</p><script type="math/tex; mode=display">\int_a^b udv=uv|_a^b - \int_a^b vdu</script><p>​        例如：$\int _0^\frac{1}{2} \arcsin xdx$</p><p>​        注意到$x$也是一个函数：于是$\int _0^\frac{1}{2} \arcsin xdx=x\arcsin x|_0^\frac{1}{2} - \int_0^\frac{1}{2} \frac{x}{\sqrt {1-x^2} }dx=\frac{\pi}{12}+\frac{\sqrt 3}{2}-1$</p><p>​        也有上面提到的方法一块用的积分：</p><p>​        $\int_0^1 e^\sqrt{x}dx$</p><p>​        令:$t=\sqrt x$, 则:$2\int_0^1 te^tdt$=$2te^t|_0^1-2\int_0^1 e^tdt=2$</p><h3 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h3><h4 id="无穷限的反常积分"><a href="#无穷限的反常积分" class="headerlink" title="无穷限的反常积分"></a>无穷限的反常积分</h4><p>​        什么叫反常积分呢？就是说积分区域下函数在这一点反常。比如说，因为积分区域含有无穷的积分：</p><script type="math/tex; mode=display">\int_a^{+\infty} f(x)dx</script><p>​        或者是这样的：</p><script type="math/tex; mode=display">\int_{-\infty}^b  f(x)dx</script><p>​        这样的积分是无穷限的反常积分。我们不妨采用动态的方法：</p><script type="math/tex; mode=display">\int_a^{+\infty} f(x)dx=\lim_\limits{t\rightarrow +\infty}\int_a^t f(x)dx</script><p>​        这下也有类似的：</p><script type="math/tex; mode=display">\int_{-\infty}^b  f(x)dx=\lim_\limits{t\rightarrow -\infty}\int_t^b f(x)dx</script><p>​        牵扯到了极限，因此：如果上面的极限是存在的，那就：之人格积分是收敛的，反之发散。</p><p>​        还有上下限均是无穷的积分，仍采用上面的处理方式。在实际求值的时候，也是直接</p><script type="math/tex; mode=display">\int_a^{+\infty}f(x)dx=F(x)|_a^{+\infty}</script><p>​        一个结论：对于</p><script type="math/tex; mode=display">\int_a^{+\infty}\frac{dx}{x^p}(a>0)</script><p>​        <strong>p&gt;1收敛，p$\leq 1$手来你</strong></p><h4 id="反常积分：无界函数的反常积分"><a href="#反常积分：无界函数的反常积分" class="headerlink" title="反常积分：无界函数的反常积分"></a>反常积分：无界函数的反常积分</h4><p>​        什么意思？就是说函数在某一点没有定义，我们的积分区域却包含了它。比如说</p><script type="math/tex; mode=display">\int_0^1 \frac{1}{x}dx</script><p>​        结合上一小节的类似方法，我们得到</p><script type="math/tex; mode=display">\int_0^1 \frac{1}{x}dx=\lim\limits_{t\rightarrow 0^+}\int_t^1\frac{1}{t}dx</script><p>​        类似的： </p><script type="math/tex; mode=display">\int_{-1}^0 \frac{1}{x}dx=\lim\limits_{t\rightarrow 0^-}\int_{-1}^t\frac{1}{t}dx</script><p>​        如果这样的点在中间，我们就拆开积分区域就好了。</p><h4 id="补充：-Gamma-s-函数"><a href="#补充：-Gamma-s-函数" class="headerlink" title="补充：$\Gamma(s)$函数"></a>补充：$\Gamma(s)$函数</h4><p>​        $\Gamma(s)$函数是这样定义的：</p><script type="math/tex; mode=display">\Gamma(s)=\int_0^{+\infty}e^{-x}x^{s-1}dx(s>0)</script><p>​        具有以下非常好推导的性质：</p><script type="math/tex; mode=display">1)\Gamma(s+1)=s\Gamma(s)</script><script type="math/tex; mode=display">2)\Gamma(1)=1</script><p>基于2)，我们发现了这个函数的一个奇妙公式：</p><script type="math/tex; mode=display">\Gamma(s+1)=s!</script><h4 id="补充：比较审敛原理"><a href="#补充：比较审敛原理" class="headerlink" title="补充：比较审敛原理"></a>补充：比较审敛原理</h4><p>​        我们假设:$f(x)$和$g(x)$在[a,$\infty$ ]上连续，$60 \leq f(x)\leq g(x)$如果：</p><script type="math/tex; mode=display">1)\int_a^{+\infty}g(x)dx收敛\rightarrow\int_a^{+\infty}f(x)dx收敛</script><script type="math/tex; mode=display">1)\int_a^{+\infty}f(x)dx发散\rightarrow\int_a^{+\infty}g(x)dx发散</script><p>​        很好理解：大哥收敛小弟也收敛，小弟嚣张大哥肯定也嚣张。</p><h4 id="补充：比较审敛法"><a href="#补充：比较审敛法" class="headerlink" title="补充：比较审敛法"></a>补充：比较审敛法</h4><p>​    设$f(x)$在[a,$\infty$]连续(a&gt;0)，且$f(x)\geq 0,\exists M&gt;0,p&gt;1$</p><p>​        如果使得:$f(x)\leq \frac{M}{x^p}$那就$\int_a^{+\infty}f(x)dx$收敛</p><p>​        反之：$f(x)\geq \frac{M}{x},$那就$\int_a^{+\infty}f(x)dx$发散</p><h4 id="补充：绝对审敛法"><a href="#补充：绝对审敛法" class="headerlink" title="补充：绝对审敛法"></a>补充：绝对审敛法</h4><p>​        如果$f(x)$在设$f(x)$在[a,$\infty$]连续（a&gt;0), $\int_a^{+\infty}|f(x)|dx$收敛，那么$\int_a^{+\infty}f(x)dx$收敛。</p><p>​        最后不难得到这个定理</p><h4 id="补充：无界函数反常积分的审敛法"><a href="#补充：无界函数反常积分的审敛法" class="headerlink" title="补充：无界函数反常积分的审敛法"></a>补充：无界函数反常积分的审敛法</h4><p>​        回到这个积分</p><script type="math/tex; mode=display">\int_a^b \frac{dx}{(x-a)^q}</script><p>​        $x=a$显然是一个瑕点$q&lt;1$收敛，q$\geq$1发散。</p><p>​        基于这个积分，我们再次应用比较原理：</p><p>​        如果$f(x)$在(a,b]连续,f(x)$\geq$0,如果$\exists M&gt;0$及其$q&lt;1$使得</p><script type="math/tex; mode=display">1)f(x)\leq \frac{M}{(x-a)^q}收敛</script><script type="math/tex; mode=display">2)f(x)\geq \frac{M}{x-a}发散</script><h4 id="补充：极限审敛法"><a href="#补充：极限审敛法" class="headerlink" title="补充：极限审敛法"></a>补充：极限审敛法</h4><p>​        如果$f(x)$在(a,b]连续,f(x)$\geq$0，$x=a$为$f(x)$的瑕点</p><p>​        1）$\exists 0&lt;q&lt;1$使得$\lim\limits_{x\rightarrow a^+}(x-a)^qf(x)=A$直接说明一件事：$\int_a^b f(x)dx$收敛。</p><p>​        2）类比的$\lim\limits_{x\rightarrow a^+}(x-a)f(x)=A$或者是$\infty$，我们直接认为$\int_a^b f(x)dx$发散。</p><h3 id="定积分的元素法"><a href="#定积分的元素法" class="headerlink" title="定积分的元素法"></a>定积分的元素法</h3><p>​        回到定积分的这个定义式：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        <strong>本质上，这样的一个定积分就是描述瞬时元素在某一个维度的积累效应的量化程度</strong>，这就是说：它既可以用来描述面积，又可以描述体积，只需要我们掌握了相应的边界函数，只要对应积分即可。</p><p><img src="image-20230130163127477.png" alt="image-20230130163127477"></p><p>​        比如说，这个的体积就是面积函数A(x)对于高度x的积分</p><script type="math/tex; mode=display">V=\int_{x_1}^{x_2}A(x)dx</script><h3 id="补充一下极坐标"><a href="#补充一下极坐标" class="headerlink" title="补充一下极坐标"></a>补充一下极坐标</h3><p>​        我们重新用一种全新的角度来看待坐标系：我们改用距离原点的距离+偏离X轴正方向的描述方法描述点的坐标。</p><p><img src="image-20230130163636247.png" alt="image-20230130163636247"></p><p>这样，一个点就总是可以表示为$A=(\rho, \theta)$，比如说极坐标下(1,1)变成了$(\sqrt 2,\frac{\pi}{4})$,现在，我们试着求：</p><p><img src="image-20230130174155076.png" alt="image-20230130174155076"></p><p>这个阴影面积：怎么办？延续老方法：假设点沿着曲线挪动一丁点，那么我们的产生的微小的面积则是：</p><script type="math/tex; mode=display">dS=\frac{\rho^2d\theta}{2}</script><p>然后从哪到哪？$\alpha$到$\beta$。</p><script type="math/tex; mode=display">S=\int_\alpha^\beta \frac{\rho^2d\theta}{2}</script><p>结束。</p><h3 id="平面图形的面积"><a href="#平面图形的面积" class="headerlink" title="平面图形的面积"></a>平面图形的面积</h3><h4 id="直角坐标系"><a href="#直角坐标系" class="headerlink" title="直角坐标系"></a>直角坐标系</h4><p>​        我们说函数相交也可以产生一些面积</p><p><img src="image-20230130174758444.png" alt="image-20230130174758444"></p><p>​        这个怎么求呢？</p><p><img src="image-20230130174916021.png" alt="image-20230130174916021"></p><p>​        我们的差面积就是：</p><script type="math/tex; mode=display">S=\int_a^bf(x)dx-\int_a^b g(x)dx=\int_a^bf(x)-g(x)dx</script><p>​        这样的差是X型的面积积分，因为我们拿X作为梯形的高</p><p>​        那就还有Y型面积：</p><p><img src="image-20230130175121419.png" alt="image-20230130175121419"></p><p>​        类比的：</p><script type="math/tex; mode=display">S=\int_c^d \varphi(y)-\phi(y)dy</script><p>​        也即是：</p><p>​            X:$S=\int 上-下dx$</p><p>​            Y:$S=\int 右-左dy$</p><p>​        </p><p>​        总结一下：我们对面积先大致画出来图长什么样：如果是这样的</p><p>​        <img src="image-20230130175729566.png" alt="image-20230130175729566"></p><p>​        就这样使用X，Y对应当打，如果不好判断，就都先试试，哪个更加容易用哪个。</p><p>​        举例：求$y=\frac{1}{2}x^2$,$y=\frac{1}{1+x^2}$在$x \in [-\sqrt 3,\sqrt 3]$下的定积分。</p><p>​        我们可以做出图像：</p><p><img src="image-20230202133001296.png" alt="image-20230202133001296"></p><p>​        砍开来看：</p><script type="math/tex; mode=display">S=\int_{-\sqrt{3}}^{-1}(\frac{1}{2}x^2-\frac{1}{1+x^2})+\int_{-1}^1(\frac{1}{1+x^2}-\frac{1}{2}x^2)+\int_{1}^{\sqrt{3}}(\frac{1}{2}x^2-\frac{1}{1+x^2})</script><p>​        随后使用偶函数的对称性结束计算。</p><p>​        求椭圆的面积：$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$</p><p>​        可以拆开四分之一的部分$S_1=\int_0^aydx$</p><p>​        现在，我们引入椭圆参数方程来消去参数：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=a\cos t \\y=a\sin t \end{aligned} \right . \end{equation}</script><p>来看看变成什么了：</p><script type="math/tex; mode=display">S_1=-\int_0^{\frac{\pi}{2}}a\sin t \times a(-\sin t)dt=\frac{\pi ab}{4}</script><p>这就是为什么：</p><script type="math/tex; mode=display">S=\pi ab</script><h4 id="极坐标下"><a href="#极坐标下" class="headerlink" title="极坐标下"></a>极坐标下</h4><p>​        回忆前面所叙述的：对于方程$R=\rho (\theta)$</p><script type="math/tex; mode=display">S=\frac{1}{2}\int_{\alpha}^{\beta}(\rho (\theta))^2d\theta</script><p>​        比如说：$\rho=a\theta$</p><script type="math/tex; mode=display">S=\frac{1}{2}\int_0^{2\pi}(a\theta)^2d\theta=\frac{4}{3}a^2\pi^3</script><h3 id="旋转体体积求法"><a href="#旋转体体积求法" class="headerlink" title="旋转体体积求法"></a>旋转体体积求法</h3><p>说白了可以切成以$f(x)$为半径的圆，在叠起来（求积分）</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2}\pi f^2(x)dx</script><p> 是通过</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2} A(x)dx</script><p>​        派生来的，只是因为面积恰好是圆。</p><p>​        但是，这样的体积求解的是绕X轴的。绕Y轴的怎么办哪？</p><p>​        简单：那就改写方程为$x=x(y)$就好了：</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2}x^2(y)dy</script><h3 id="弧长的求解"><a href="#弧长的求解" class="headerlink" title="弧长的求解"></a>弧长的求解</h3><h4 id="通用："><a href="#通用：" class="headerlink" title="通用："></a>通用：</h4><p>回来看看这个参数方程：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=\varphi(t) \\y=\phi(t)\end{aligned} \right . \end{equation}</script><p>​        弧微分很容易说：</p><script type="math/tex; mode=display">ds=\sqrt{(dx)^2+(dy)^2}dt=\sqrt{(\varphi'(t))^2+(\phi'(t))^2}dt</script><p>​        于是：</p><script type="math/tex; mode=display">L=\int_\alpha^\beta \sqrt{(\varphi'(t))^2+(\phi'(t))^2}dt</script><p>​        作为积分结果，就是弧长。</p><p>​        以此为源头，开始推广其他的公式：</p><h4 id="直角坐标系下"><a href="#直角坐标系下" class="headerlink" title="直角坐标系下"></a>直角坐标系下</h4><p>​        假如参数方程很容易被表达为$y=y(x)$，那我们就：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=x \\ y=y(x)\\\end{aligned} \right . \end{equation}</script><p>​        那带入：</p><script type="math/tex; mode=display">ds=\sqrt{1+y'^2(x)}dx</script><p>​        再积分：</p><script type="math/tex; mode=display">L=\int_a^b\sqrt{1+y'^2(x)}dx</script><h4 id="极坐标系下"><a href="#极坐标系下" class="headerlink" title="极坐标系下"></a>极坐标系下</h4><p>​        如果不知道的话：科普一下</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=\rho(\theta)\cos \theta \\ y=\rho(\theta)\sin \theta\\\end{aligned} \right . \end{equation}</script><p>​        所有呢，求个导：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x'=\rho'(\theta)\cos \theta- \rho(\theta)\sin \theta\\ y'=\rho(\theta)\cos \theta+\rho'(\theta)\sin \theta\\\end{aligned} \right . \end{equation}</script><p>​        老样子：</p><script type="math/tex; mode=display">ds=\sqrt{(x'^2+y'^2)} d\theta=\sqrt{\rho^2(\theta)+\rho'^2(\theta)d\theta}</script><p>​         嘛，不就完事了！</p><script type="math/tex; mode=display">L=\int_\alpha^\beta\sqrt{\rho^2(\theta)+\rho'^2(\theta)d\theta}</script>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Pycharm（2）</title>
      <link href="/2023/01/31/Opencv-in-Pycharm%EF%BC%882%EF%BC%89/"/>
      <url>/2023/01/31/Opencv-in-Pycharm%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><h3 id="平滑操作"><a href="#平滑操作" class="headerlink" title="平滑操作"></a>平滑操作</h3><p>​        平滑平滑，取平均。我们使用卷积核来处理图像像素点。</p><p><img src="lenaNoise.png" alt="lenaNoise"></p><p>​        针对上面这个噪点图形，我们应用平均卷积操作。我们对噪点抹除，就是通过对周围像素点取平均。我们首先构造一个3$\times$3的矩阵对目标像素点为中心的内核求取内积。（不同于经典矩阵相乘，我们是一一对应的，平凡算法复杂度为$O(N^k)(k \in N^+)$的相乘）随后把结果填充到像素点的中心。</p><p>​        下面我们对这个图操作一下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_path <span class="token operator">=</span> <span class="token string">"img/lenaNoise.png"</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Noise Version"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>blur33<span class="token operator">=</span>cv2<span class="token punctuation">.</span>blur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"3 times 3"</span><span class="token punctuation">,</span>blur33<span class="token punctuation">)</span>blur55<span class="token operator">=</span>cv2<span class="token punctuation">.</span>blur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"3 times 3"</span><span class="token punctuation">,</span>blur55<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        产生的效果是令人满意的：</p><p>3$\times$3：</p><p><img src="3 times 3.png" alt="3 times 3"></p><p>5$\times$5：</p><p><img src="5 times 5.png" alt="5 times 5"></p><p>​        可以看到核越大，越是噪点不明显，但是图像也就越模糊。</p><p>​        还有一个类似的：是BoxFilter函数：（方框滤波）</p><p>​        在OpenCV中，实现方框滤波的函数是cv2.boxFilter（），其语法格式为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">   dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>boxFilter（src<span class="token punctuation">,</span>ddepth<span class="token punctuation">,</span>ksize<span class="token punctuation">,</span>anchor<span class="token punctuation">,</span>normalize<span class="token punctuation">,</span>borderType）   <span class="token comment"># 但是一般的。。。。。。</span>dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>boxFilter（src<span class="token punctuation">,</span>ddepth<span class="token punctuation">,</span>ksize）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>● dst是返回值，表示进行方框滤波后得到的处理结果。● src 是需要处理的图像，即原始图像。它能够有任意数量的通道，并能对各个通道独立处理。图像深度应该是CV_8U、CV_16U、CV_16S、CV_32F 或者 CV_64F中的一种。 ● ddepth是处理结果图像的图像深度，一般使用-1表示与原始图像使用相同的图像深度。 ● ksize 是滤波核的大小。滤波核大小是指在滤波处理过程中所选择的邻域图像的高 度和宽度。● anchor 是锚点，其默认值是（-1,-1），表示当前计算均值的点位于核的中心点位 置。该值使用默认值即可，在特殊情况下可以指定不同的点作为锚点。● normalize 表示在滤波时是否进行归一化（这里指将计算结果规范化为当前像素值范围内的值）处理，该参数是一个逻辑值，可能为真（值为1）或假（值为0）：1.当参数normalize=1时，表示要进行归一化处理，要用邻域像素值的和除以面积。此时方框滤波与均值滤波效果相同。2.当参数normalize=0时，表示不需要进行归一化处理，直接使用邻域像素值的和。当 normalize=0时，因为不进行归一化处理，因此滤波得到的值很可能超过当前像素值范围的最大值，从而被截断为最大值。这样，就会得到一幅纯白色的图像。● borderType是边界样式，该值决定了以何种方式处理边界。通常情况下，在使用方框滤波函数时，对于参数anchor、normalize和borderType，直接采用其默认值即可。因此，函数cv2.boxFilter（）的常用形式为：</code></pre><p>​        可以等效成blur，就是选择更多了而已。如果不进行归一化，就是停在255，所以图像会很白。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Filt1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>boxFilter<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>normalize<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>Filt2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>boxFilter<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>normalize<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Filt1"</span><span class="token punctuation">,</span>Filt1<span class="token punctuation">)</span><span class="token punctuation">;</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Filt2"</span><span class="token punctuation">,</span>Filt2<span class="token punctuation">)</span><span class="token punctuation">;</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Filt1.png"</span><span class="token punctuation">,</span>Filt1<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Filt2.png"</span><span class="token punctuation">,</span>Filt2<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Filt1： 归一化</p><p><img src="Filt1.png" alt="Filt1"></p><p>Filt2: 摆烂</p><p><img src="Filt2.png" alt="Filt2"></p><h4 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h4><p>​        这个改进了平均算法，就是利用空间距离远近来作为计算权重：近的权重大，反之权重小。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Gaussain<span class="token operator">=</span>cv2<span class="token punctuation">.</span>GaussianBlur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Gaussain"</span><span class="token punctuation">,</span>Gaussain<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Gaussain.png"</span><span class="token punctuation">,</span>Gaussain<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="Gaussain.png" alt="Gaussain"></p><h5 id="关于高斯滤波及其算法的扩展"><a href="#关于高斯滤波及其算法的扩展" class="headerlink" title="关于高斯滤波及其算法的扩展"></a>关于高斯滤波及其算法的扩展</h5><p>材料来源：<a href="https://blog.csdn.net/LYSSLQ2015/article/details/125110610">(46条消息) opencv———-高斯滤波_opencv高斯滤波_LYSSLQ2015的博客-CSDN博客</a>！</p><p>​        高斯滤波(Gauss Filter)是<strong>线性滤波</strong>中的一种。在OpenCV图像滤波处理中，高斯滤波用于<strong>平滑图像</strong>，或者说是图像模糊处理，因此高斯滤波是低通的。其广泛的应用在图像处理的减噪过程中，尤其是被高斯噪声所污染的图像上。高斯滤波的基本思想是: 图像上的每一个像素点的值，都由其本身和邻域内其他像素点的值经过加权平均后得到。其具体操作是，用一个核(又称为卷积核、掩模、矩阵)扫描图像中每一个像素点，将邻域内各个像素值与对应位置的权值相称并求和。从数学的角度来看，高斯滤波的过程是图像与高斯正态分布做卷积操作。<br>​        注意: 高斯滤波是将二维高斯正态分布放在图像矩阵上做卷积运算。考虑的是邻域内像素值的空间距离关系，因此对彩色图像处理时应分通道进行操作，也就是说操作的图像原矩阵时用单通道数据，最后合并为彩色图像。</p><p>一、几个概念</p><ol><li><p>什么是<a href="https://so.csdn.net/so/search?q=低通滤波&amp;spm=1001.2101.3001.7020">低通滤波</a>、平滑图像、图像模糊处理？<br>平滑图像与图像模糊处理是相同的含义。平滑处理即是通过操作后，使得图像的像素值与邻域内其他像素值的的变化程度减小。在一张图像上，边缘的像素值是变化程度最剧烈的地方，而其他相对平缓。因此，平滑图像最直观的表现是图像的上物体的边缘轮廓变得模糊。<strong>低通滤波是指仅允许低频率信号通过。一张图像上的大部分能量聚集在低频和中频上，而高频大多是图像中物体的边缘部分，也有可能是高频噪声点。在单通道中，各像素点的取值都在(0~255)中，因此，低通滤波通过一定的阙值设置，有去除高频信号和平缓边缘的效果。</strong></p></li><li><p>什么是核(又称为卷积核、掩模、矩阵)？<br><strong>核的本质其实就是一个大小固定、由数值参数组成的数学矩阵，例如一个3<em>3的核就是一个3</em>3的矩阵,而矩阵中的数据则为权值。</strong></p></li><li><p>什么是卷积运算？<br>卷积运算是指输入图像中某一像素点的邻域的各个值（包括该点）与卷积算子中的值做矩阵相乘运算，最后得到输出值。<br>卷积算子的公式:</p><script type="math/tex; mode=display">g=f*h</script><script type="math/tex; mode=display">g(i,j)=\sum_{k,l}f(i-k,j-l)h(k,l)=\sum_{k,l}f(k,l)h(i-k,j-l)</script></li></ol><p>g(i，j) 代表原图像矩阵上的(i，j)点的值，它是输出值。<br>f(i-k，j-l) 代表原图像矩阵上(i，j)点的邻域中的对应点的值。<br>h(k,，l) 代表与f(i-k ， j-l)这个值在核对应位置的点的值<br><strong>请看下图：这里用的是f(i-k,j-l)h(k,l)</strong></p><p><img src="SouthEast.png" alt="这里写图片描述"></p><p>由上图我们看到，矩阵f是将要进行操作的图像矩阵，当前的(i，j)是(2，2)点。h为核，其以中心(0，0)为参考点。因此f矩阵对应范围即为f(2，2)的邻域。矩阵g为图像输出矩阵，g(2，2)的值为输出值。<br>注意：卷积算子和相关算子在核上是180度翻转的矩阵，请不要搞混</p><p>4.核(卷积核、掩模、矩阵等)<br>在3的卷积运算中，用到的公式是：<br>g(i, j) = ∑ f(i-k, j-l)h(k, l) 。其中 k，l代表核上的坐标。而核的坐标明显与数组下标不一致。因此，我们需要做一个转换以满足用数组下标来访问该核的数据。<br>假设有3<em>3数组a，它与核的对应关系为<br>a(0, 0) ===&gt; h(-1, -1) a(0, 1) ===&gt; h(-1, 0) a(0, 2) ===&gt; h(-1, 1)<br>a(1, 0) ===&gt; h(0, -1) a(1, 1) ===&gt; h(0, 0) a(1, 2) ===&gt; h(0, 1)<br>a(2, 0) ===&gt; h(1, -1) a(2, 1) ===&gt; h(1, 0) a(2, 2) ===&gt; h(1, 1)<br>对于3</em>3数组，其下标是0开始的，假设该数组的参考点(ai, aj)为中心,则有<br>g(i, j) = ∑ f(i-(k-ai), j-(l-aj))h(k, l)<br>带入数组参考点(1, 1)，则有<br>g(i, j) = ∑ f(i-(k-1), j-(l-1))h(k, l)<br>此时，k，l可以从0开始取值<br><img src="SouthEast2.png" alt="这里写图片描述"></p><p> <strong>5.图像通道分离与合并(cv::Mat)</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; src 原图像，多通道&#x2F;&#x2F; [1] 彩色图片通道分离std::vector&lt;cv::Mat&gt; channels;cv::split(&amp;src, channels);&#x2F;&#x2F; [3] 滤波&#x2F;&#x2F; OpenCV中操作&#x2F;&#x2F; channels[0]  &#x3D;&#x3D;&gt;  B通道&#x2F;&#x2F; channels[1]  &#x3D;&#x3D;&gt;  G通道&#x2F;&#x2F; channels[2]  &#x3D;&#x3D;&gt;  R通道&#x2F;&#x2F; 省略对各个通道的处理&#x2F;&#x2F; [4] 合并返回cv::merge(channels, *dst);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二、高斯函数"><a href="#二、高斯函数" class="headerlink" title="二、高斯函数"></a>二、高斯函数</h4><p>高斯滤波，顾名思义，这是一个建立在高斯正态分布基础上的滤波器。首先我们来了解高斯函数。(图片来源于网络)<br>一维高斯函数：<br>可以看到，G(x)的跟<a href="https://so.csdn.net/so/search?q=sigma&amp;spm=1001.2101.3001.7020">sigma</a>的取值有极大的关系。sigma取值越大，图像越平缓，sigma取值越小，图像越尖锐。</p><p><img src="SouthEast10.png" alt="这里写图片描述"><br><img src="SouthEast3.png" alt="这里写图片描述"></p><p>二维高斯函数：<br>二维高斯是构建高斯滤波器的基础。可以看到，G(x,y)在x轴y轴上的分布是一个突起的帽子的形状。这里的sigma可以看作两个值，一个是x轴上的分量sigmaX，另一个是y轴上的分量sigmaY。对图像处理可以直接使用sigma并对图像的行列操作，也可以用sigmaX对图像的行操作，再用sigmaY对图像的列操作。它们是等价的。<br>当sigmaX和sigmaY取值越大，整个形状趋近于扁平；当sigmaX和sigmaY取值越小，整个形状越突起。<br><img src="SouthEast4.png" alt="这里写图片描述"></p><p>高斯滤波原理就是将上图的二维正态分布应用在二维的矩阵上，G(x,y)的值就是矩阵上的权值，将得到的权值进行<a href="https://so.csdn.net/so/search?q=归一化&amp;spm=1001.2101.3001.7020">归一化</a>，将权值的范围约束在[0,1]之间，并且所有的值的总和为1。<br>假设一个3*3的核，sigma取值1.5以及sigma取5.0，归一化后其权值分布分别是：</p><p><img src="SouthEast5.png" alt="这里写图片描述"></p><p>假设一个5*5的核，sigma取值1.5以及sigma取5.0，经归一化后其权值分布分别是：<br><img src="SouthEast6.png" alt="这里写图片描述"><br><img src="SouthEast7.png" alt="这里写图片描述"></p><p>可以看到，权值的分布是以中间高四周低来分布的。并且距离中心越远，其对中心点的影响就越小，权值也就越小。<br>因此可以总结：<br>（1）在核大小固定的情况下，sigma值越大，权值分布越平缓。因此，邻域各个点的值对输出值的影响越大，最终结果造成图像越模糊。<br>（2）在核大小固定的情况下，sigma值越小，权值分布越突起。因此，邻域各个点的值对输出值的影响越小，图像变化也越小。假如中心点权值为1，其他点权值为0，那么最终结果是图像没有任何变化。<br>（3）sigma固定时，核越大图像越模糊。<br>（4）sigma固定时，核越小图像变化越小。</p><p>三、高斯滤波器实现<br>首先看效果：<br>对于椒盐图作处理</p><p><img src="SouthEast8.png" alt="这里写图片描述"></p><p>对于高斯噪声图作处理<br><img src="SouthEast9.png" alt="这里写图片描述"></p><p>（1）main函数：读取图片 ==&gt; 高斯滤波 ==&gt; 结果显示</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// [1] src读入图片</span>    cv<span class="token double-colon punctuation">::</span>Mat src <span class="token operator">=</span> cv<span class="token double-colon punctuation">::</span><span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"Median_pic.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [2] dst目标图片</span>    cv<span class="token double-colon punctuation">::</span>Mat dst<span class="token punctuation">;</span>    <span class="token comment">// [3] 高斯滤波  sigma越大越平越模糊</span>    <span class="token function">myGaussianFilter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>src<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dst<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [4] 窗体显示</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"dst"</span><span class="token punctuation">,</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">destroyAllWindows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）彩色图像通道分离处理，每个通道都进行高斯滤波，最后合并</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void myGaussianFilter(cv::Mat *src, cv::Mat *dst, int n, double sigma)&#123;    &#x2F;&#x2F; [1] 初始化    *dst &#x3D; (*src).clone();    &#x2F;&#x2F; [2] 彩色图片通道分离    std::vector&lt;cv::Mat&gt; channels;    cv::split(*src, channels);    &#x2F;&#x2F; [3] 滤波    &#x2F;&#x2F; [3-1] 确定高斯正态矩阵    double **array &#x3D; getGaussianArray(n, sigma);    &#x2F;&#x2F; [3-2] 高斯滤波处理    for (int i &#x3D; 0; i &lt; 3; i++) &#123;        gaussian(&amp;channels[i], array, n);    &#125;    &#x2F;&#x2F; [4] 合并返回    cv::merge(channels, *dst);    return ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）生成高斯正态分布核(<a href="https://so.csdn.net/so/search?q=卷积核&amp;spm=1001.2101.3001.7020">卷积核</a>，掩模等)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;* 获取高斯分布数组               (核大小， sigma值) *&#x2F;double **getGaussianArray(int arr_size, double sigma)&#123;    int i, j;    &#x2F;&#x2F; [1] 初始化权值数组    double **array &#x3D; new double*[arr_size];    for (i &#x3D; 0; i &lt; arr_size; i++) &#123;        array[i] &#x3D; new double[arr_size];    &#125;    &#x2F;&#x2F; [2] 高斯分布计算    int center_i, center_j;    center_i &#x3D; center_j &#x3D; arr_size &#x2F; 2;    double pi &#x3D; 3.141592653589793;    double sum &#x3D; 0.0f;    &#x2F;&#x2F; [2-1] 高斯函数    for (i &#x3D; 0; i &lt; arr_size; i++ ) &#123;        for (j &#x3D; 0; j &lt; arr_size; j++) &#123;            array[i][j] &#x3D;                 &#x2F;&#x2F;后面进行归一化，这部分可以不用                &#x2F;&#x2F;0.5f *pi*(sigma*sigma) *                 exp( -(1.0f)* ( ((i-center_i)*(i-center_i)+(j-center_j)*(j-center_j))&#x2F; (2.0f*sigma*sigma) ));                                    sum +&#x3D; array[i][j];        &#125;    &#125;    &#x2F;&#x2F; [2-2] 归一化求权值    for (i &#x3D; 0; i &lt; arr_size; i++) &#123;        for (j &#x3D; 0; j &lt; arr_size; j++) &#123;            array[i][j] &#x2F;&#x3D; sum;            printf(&quot; [%.15f] &quot;, array[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return array;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）进行高斯滤波操作</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;* 高斯滤波 (待处理单通道图片, 高斯分布数组， 高斯数组大小(核大小) ) *&#x2F;void gaussian(cv::Mat *_src, double **_array, int _size)&#123;    cv::Mat temp &#x3D; (*_src).clone();    &#x2F;&#x2F; [1] 扫描    for (int i &#x3D; 0; i &lt; (*_src).rows; i++) &#123;        for (int j &#x3D; 0; j &lt; (*_src).cols; j++) &#123;            &#x2F;&#x2F; [2] 忽略边缘            if (i &gt; (_size &#x2F; 2) - 1 &amp;&amp; j &gt; (_size &#x2F; 2) - 1 &amp;&amp;                i &lt; (*_src).rows - (_size &#x2F; 2) &amp;&amp; j &lt; (*_src).cols - (_size &#x2F; 2)) &#123;                &#x2F;&#x2F; [3] 找到图像输入点f(i,j),以输入点为中心与核中心对齐                &#x2F;&#x2F;     核心为中心参考点 卷积算子&#x3D;&gt;高斯矩阵180度转向计算                &#x2F;&#x2F;     x y 代表卷积核的权值坐标   i j 代表图像输入点坐标                &#x2F;&#x2F;     卷积算子     (f*g)(i,j) &#x3D; f(i-k,j-l)g(k,l)          f代表图像输入 g代表核                &#x2F;&#x2F;     带入核参考点 (f*g)(i,j) &#x3D; f(i-(k-ai), j-(l-aj))g(k,l)   ai,aj 核参考点                &#x2F;&#x2F;     加权求和  注意：核的坐标以左上0,0起点                double sum &#x3D; 0.0;                for (int k &#x3D; 0; k &lt; _size; k++) &#123;                    for (int l &#x3D; 0; l &lt; _size; l++) &#123;                        sum +&#x3D; (*_src).ptr&lt;uchar&gt;(i-k+(_size&#x2F;2))[j-l+(_size&#x2F;2)] * _array[k][l];                    &#125;                &#125;                &#x2F;&#x2F; 放入中间结果,计算所得的值与没有计算的值不能混用                temp.ptr&lt;uchar&gt;(i)[j] &#x3D; sum;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 放入原图    （*_src） &#x3D; temp.clone();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>​        什么是中值？就是排序取中间的中位数。那就直接把目标像素点直接换成中位数跑路！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">median<span class="token operator">=</span>cv2<span class="token punctuation">.</span>medianBlur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"median"</span><span class="token punctuation">,</span>median<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"median.png"</span><span class="token punctuation">,</span>median<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <img src="median.png" alt="median"></p><p>​        可以看到效果很好。令人满意。</p><h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><pre><code>    一、概述    使用中值滤波器模糊图像。    该函数使用具有 ksize×ksize 孔径的中值滤波器对图像进行平滑处理。 多通道图像的每个通道都是独立处理的。    中值滤波器在内部使用 BORDER_REPLICATE 来处理边界像素，请参阅 BorderTypes。    下图描述了一个ksize=3×3的滑动窗口（或称滤波器模板、kernel），如黄色部分所示。用这个ksize=3×3的窗口作用于原始图像上的每一个像素，如下图的绿色部分所示，被这个窗口覆盖的9个像素点都参与计算，这样在该像素点上就会得到一个新的像素值，当窗口沿着图像逐个像素进行计算，就会得到一幅新的图像。</code></pre><p><img src="https://img-blog.csdnimg.cn/9f8842b4f8da4836a54e1b6a66ab13fa.png" alt="img"></p><pre><code>     上图中滤波器模板的不同就构成了滤波算法的差异，比如均值平滑算法中滑动窗口中各个像素点的系数均为1/(窗口高*窗口宽)，高斯平滑中系数和中心点的距离满足高斯分布。    中值平滑和均值平滑一样也用到了滑动窗口，但是它并不是计算滑动窗口中的某种加权和，而是使用原图像滑动窗口中所有像素值排序后的中值作为新图像的像素值。    从上图也可以看到，当滑动窗口作用于图像边沿的时候，滑动窗口的某些像素并没有和图像重合，这时就需要对边沿做特殊处理，常用的方法有填0、填1、复制边沿等方式。</code></pre><p>二、medianBlur函数<br>1、函数原型<br>cv::medianBlur (InputArray src, OutputArray dst, int ksize)<br>2、参数详解<br>src    ：输入 1、3 或 4 通道图像； ksize 为 3 或 5 时，图像深度应为 CV_8U、CV_16U 或 CV_32F，对于较大的光圈尺寸，只能为 CV_8U。</p><p>dst    ：与 src 大小和类型相同的目标数组。</p><p>ksize    ：孔径线性尺寸； 它必须是奇数且大于 1，例如：3、5、7 …<br>三、OpenCV源码<br>1、源码路径</p><pre class="line-numbers language-none"><code class="language-none">opencv\modules\imgproc\src\median_blur.dispatch.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、源码代码</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void medianBlur( InputArray _src0, OutputArray _dst, int ksize )&#123;    CV_INSTRUMENT_REGION();CV_Assert(!_src0.empty()); CV_Assert( (ksize % 2 &#x3D;&#x3D; 1) &amp;&amp; (_src0.dims() &lt;&#x3D; 2 )); if( ksize &lt;&#x3D; 1 || _src0.empty() )&#123;   _src0.copyTo(_dst);    return;&#125; CV_OCL_RUN(_dst.isUMat(),         ocl_medianFilter(_src0,_dst, ksize)         ) Mat src0 &#x3D; _src0.getMat();_dst.create( src0.size(), src0.type() );Mat dst &#x3D; _dst.getMat(); CALL_HAL(medianBlur, cv_hal_medianBlur, src0.data, src0.step, dst.data, dst.step, src0.cols, src0.rows, src0.depth(),    src0.channels(), ksize    ); CV_OVX_RUN(true,           openvx_medianFilter(_src0, _dst, ksize)) &#x2F;&#x2F;CV_IPP_RUN_FAST(ipp_medianFilter(src0, dst, ksize)); CV_CPU_DISPATCH(medianBlur, (src0, dst, ksize),    CV_CPU_DISPATCH_MODES_ALL    );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>四、效果图像示例</p><p>原图：</p><p><img src="https://img-blog.csdnimg.cn/7a3c9fa7cb44463cb9c29ea0e1def515.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/9d19f5513c46421094abc1e260e2352d.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/9173c63503904f4eb03c876c4048cfa1.png" alt="img"></p><p>版权声明：本才来哦为CSDN博主「坐望云起」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/bashendixie5/article/details/125255049">https://blog.csdn.net/bashendixie5/article/details/125255049</a></p><h3 id="图像拼接"><a href="#图像拼接" class="headerlink" title="图像拼接"></a>图像拼接</h3><p>​        现在我们使用Numpy的hstack方法拼接一下图片：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>blur33<span class="token punctuation">,</span>Gaussain<span class="token punctuation">,</span>median<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Compare!"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Compare.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="Compare.png" alt="Compare"></p><p>​        起到对比效果（显然不是那么好。。。）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（3）</title>
      <link href="/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%883%EF%BC%89/"/>
      <url>/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学教程（8）不定积分"><a href="#高等数学教程（8）不定积分" class="headerlink" title="高等数学教程（8）不定积分"></a>高等数学教程（8）不定积分</h1><p>​        这一章内容通俗的说：就是求导的反向操作：我们需要求出谁求导的到现在的东西</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​        假设一个函数$f(x)$是一个函数$F(x)$求导的结果，那么称$F(x)$是$f(x)$的一个愿函数</p><p>这是因为$F(x)+C$(C是一个常数)求导也是$f(x)$</p><p>​        原函数存在定理：<strong>连续的函数一定有原函数</strong></p><p>​        说了这么多，我们又该怎么表示一个函数的原函数呢</p><script type="math/tex; mode=display">\int f(x)dx=F(x)+C</script><p>​        比如说：$\int x^2dx=\frac{x^3}{3}+C$</p><p>​        但是注意：这个容易错：$\int \frac{1}{x}dx=\ln{|x|}+C$</p><p>​        因为（x&lt;0）下$\ln{x}$无定义，可以把$\frac{-1}{-x}$看，这样就好了。</p><p>​        下面来看一些式子：</p><script type="math/tex; mode=display">\frac{d}{dx}[\int f(x)dx]=f(x)</script><script type="math/tex; mode=display">d[\int f(x)dx]=f(x)dx</script><p>​        说明了积分号在内微分号在外的式子，没有常数C（本质是$df(x)=f’(x)dx$）</p><p>​        </p><script type="math/tex; mode=display">\int F'(x)dx=F(x)+C</script><p>​        说明了积分号在外微分号在内的式子，有常数C（本质是$\int f(x)dx=F(x)+C$）</p><h3 id="积分表"><a href="#积分表" class="headerlink" title="积分表"></a>积分表</h3><p>​        幂函数的积分</p><script type="math/tex; mode=display">\int x^\mu dx=\frac{x^{\mu+1}}{\mu+1}+C</script><p>​        常数的不定积分：</p><script type="math/tex; mode=display">\int kdx=kx+C</script><p>​        </p><script type="math/tex; mode=display">\int \frac{dx}{1+x^2}dx=\arctan{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\sqrt {1-x^2}}dx=\arcsin{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\cos^2{x}}=\int \sec^2{x}=\tan{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\sin^2{x}}=\int \csc^2{x}=-\cot{x}+C</script><script type="math/tex; mode=display">\int \sec{x}\tan xdx=\sec{x}+C</script><script type="math/tex; mode=display">\int \csc{x}\cot{x}dx=-\csc{x}+C</script><script type="math/tex; mode=display">\int \frac{1}{x}dx=\ln |x|+C</script><script type="math/tex; mode=display">\int \cos{x}dx=\sin{x}+C</script><script type="math/tex; mode=display">\int \sin{x}dx=-\cos{x}+C</script><script type="math/tex; mode=display">\int e^xdx=e^x+C</script><script type="math/tex; mode=display">\int a^xdx=\frac{a^x}{\ln{a}}+C</script><h3 id="不定积分的性质"><a href="#不定积分的性质" class="headerlink" title="不定积分的性质"></a>不定积分的性质</h3><p>​        1）$\int [f(x)\pm g(x)]dx=\int f(x)dx \pm \int g(x)dx$</p><p>​        2)$\int kf(x)dx=k\int f(x)dx$</p><h3 id="第一类换元积分（凑微分法）"><a href="#第一类换元积分（凑微分法）" class="headerlink" title="第一类换元积分（凑微分法）"></a>第一类换元积分（凑微分法）</h3><p>​        首先回到这里：$\int 1 dF(u)=F(u)+C$,现在假设$u=\varphi (x)$,这样，我们就有$\int 1dF(\varphi(x))=F(\varphi(x))+C$,进一步的：$\int f(\varphi(x))\varphi ‘(x)dx=F(\varphi(x))+C$</p><p>说白了，就是复合求导的逆过程，我们的核心过程就是通过合并至d后面从而化简函数：</p><p>1）$\int 2\cos 2xdx$</p><p>解：$\int \cos 2xd(2x)=sin(2x)+C$</p><p>2)$\int \frac{1}{3+2x}dx$</p><p>解：$\int \frac{1}{2}\frac{1}{3+2x}d(2x+3)=\frac{1}{2}\ln|(2x+3)|+C$</p><p>3)$\int 2x e^{x^2}dx$</p><p>解：$\int  e^{x^2}dx^2= e^{x^2}+C$</p><p>4)$\int x\sqrt{1-x^2}dx$</p><p>解：$-\frac{1}{2}\int \sqrt{1-x^2}d(1-x^2)=-\frac{1}{3}(1-x^2)^{1.5}+C$</p><p>5)$\int \frac{x^2}{(x+2)^3}dx$</p><p>解:</p><p>$令:x+2=u$,$\int \frac{(u-2)^2}{u^3}du=\int (\frac{1}{u}-\frac{4}{u^2}+\frac{4}{u^3})du=\ln |u|+\frac{4}{u}-2\frac{1}{u^2}$</p><p>于是:$\ln |x+2|+\frac{4}{x+2}-2\frac{1}{(x+2)^2}$</p><p>6)$\int \frac{1}{a^2+x^2}dx(a\neq 0)$</p><p>解：$=\frac{1}{a}\int \frac{1}{1+(\frac{x}{a})^2}d(\frac{x}{a})=\frac{1}{a}\arctan \frac{x}{a}+C$</p><p>7)$\int \frac{dx}{\sqrt{a^2-x^2}}$</p><p>解：$\frac{1}{a}\int \frac{dx}{\sqrt{1-(\frac{x}{a})^2}}=\arcsin \frac{x}{a}+C$</p><p>8)$\int \frac{dx}{x^2-a^2}$</p><p>解：$\frac{1}{2a}\int (\frac{1}{x-a}-\frac{1}{x+a})dx=\frac{1}{2a}\ln|\frac{x-a}{x+a}|+C$</p><p>9)$\int \frac{dx}{x(1+2\ln x)}$</p><p>解：$\int \frac{d\ln{x}}{1+2\ln x}=\frac{1}{2}\ln|1+2\ln x|+C$</p><p>10）$\int \frac{e^{3\sqrt{x}}}{\sqrt{x}}dx$</p><p>解：$=2\int e^{3\sqrt{x}}d{\sqrt{x}}=\frac{2}{3}e^{3\sqrt{x}}+C$</p><p>11)$\int \sin^3xdx$</p><p>解：$\int sin^2xd\cos x=\int (1-cos^2x)d\cos x=-\cos x-\frac{1}{3}\cos^3x+C$</p><p>12)$\int \sin^2x\cos^5xdx$</p><p>解：$\int \sin^2\cos^4xd\sin x=\int \sin^2x(1-\sin^2x)^2d\sin x=\frac{\sin^3x}{3}-\frac{2\sin^5x}{5}+\frac{\sin^7x}{7}+C$</p><p>13)$\int \tan xdx$</p><p>解：</p><p>$\int \frac{\sin x}{\cos x}dx=-\int \frac{1}{\cos x}d\cos x=-\ln|cos(x)|+C$</p><p>14)$\int \cos^2xdx$</p><p>解：$\int \frac{1+\cos2x}{2}dx=\frac{x}{2}+\frac{\sin 2x}{4}+C$</p><p>15)$\int \sin^2x\cos^4xdx$</p><p>解：$\int \frac{1-\cos{2x}}{2}(\frac{1+\cos{2x}}{2})^2dx=\frac{1}{8}(x+\frac{1}{2}\sin 2x-\frac{1}{2}x-\frac{1}{8}\sin 4x-\frac{1}{2}(\sin 2x-\frac{sin^3 2x}{3}))+C$</p><p>16)$\int \sec^6xdx$</p><p>解：$\int \sec^4xd\tan x=\int (\tan^2x+1)^2d\tan x=\frac{\tan^5x}{5}+\frac{2\tan^3x}{3}+\tan x+C$</p><p>17)$\int \csc xdx$</p><p>解：$\int \frac{1}{\sin x}dx=\frac{\cos \frac{x}{2}dx}{2\sin \frac{x}{2}\cos^2\frac{x}{2}}=\int \frac{\sec^2\frac{x}{2}}{\tan\frac{x}{2}}d(\frac{x}{2})=\int \frac{d\tan\frac{x}{2}}{\tan \frac{x}{2}}=\ln|\tan \frac{x}{2}|+C$</p><p>总结下：三角函数者：奇次提，偶次被倍角公式替换</p><h3 id="第二类换元积分"><a href="#第二类换元积分" class="headerlink" title="第二类换元积分"></a>第二类换元积分</h3><p>​        我们把d()内的东西往外提，化而言之：就是换元$x=\varphi(t)$再求积分：</p><p>$\int f(x)dx=\int f(\varphi(t))\varphi’(t)dt$</p><p>1)$\int \sqrt{a^2-x^2}dx(a&gt;0)$</p><p>解:令：$x=a\sin t,t\in(-\frac{\pi}{2},\frac{\pi}{2})$</p><p>故：$\int \sqrt{a^2-x^2}dx=a\cos tdx$</p><p>$dx=a\cos t$</p><p>因此：$\int a^2\cos^2tdt=a^2(\frac{t}{2}+\frac{\sin2t}{4})+C=a^2t+a^2\frac{\sin t\cos t}{2}+C$</p><p>又$\sin t=\frac{x}{a},\cos t=\frac{\sqrt{a^2-x^2}}{a}$</p><p>这样：$\frac{a^2}{2}\arcsin\frac{x}{a}+\frac{x}{2}\sqrt{a^2-x^2}+C$</p><p>2)$\int \frac{dx}{\sqrt{x^2+a^2}}(a&gt;0)$</p><p>现令：$x=a\tan t$</p><p>则：$\int \frac{dx}{a\sec x}$</p><p>又：$dx=a\sec^2 tdt$</p><p>那么：$\int \sec tdt=\ln|\sec t+\tan t|+C$</p><p>我们可以使用三角形法来看：</p><p><img src="image-20230120122352772.png" alt="image-20230120122352772"></p><p>这下，我们找到了：$\tan t=\frac{x}{a},\sec t= \frac{\sqrt{x^2+a^2}}{a}$</p><p>于是：$=\ln|\frac{\sqrt{x^2+a^2}}{a}+\frac{x}{a}|+C=\ln(\sqrt{x^2+a^2}+x)+C’$</p><p>3)$\int \frac{dx}{\sqrt{x^2-a^2}}$</p><p>解：</p><p>令：$x=a\sec t,则：\int \frac{dx}{a\tan t}$</p><p>$dx=a\sec t\tan tdt$</p><p>于是：$\int \sec tdt=\ln(x+\sqrt{x^2-a^2})+C$</p><p><strong>小总结：</strong></p><p>$\sqrt{a^2-x^2}\longrightarrow x=a\sin t,|a\cos t|$</p><p><strong>$\sqrt{x^2-a^2}\longrightarrow x=a\sec t,|a\tan t|$</strong></p><p>$\sqrt{a^2+x^2}\longrightarrow x=a\tan t,|a\sec t|$</p><p>4)$\int \frac{\sqrt{a^2-x^2}}{x^4}dx$</p><p>解：令：$x=\frac{1}{t}$得：</p><p>$dx=-\frac{1}{t^2}dt,-\int (a^2t^2-1)^{0.5}|t|dt$</p><p>由此：$x&gt;0下 ,=-\frac{(a^2-x^2)^{1.5}}{2a^2x^3}+C$</p><p>或者使用三角函数也可以：</p><p><img src="image-20230120124326362.png" alt="image-20230120124326362"></p><h3 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h3><p>​        我们来看：$\int udv=uv-\int vdu$</p><p>我们就可以化简积分了：如：</p><p>1)$\int xe^xdx=\int xde^x=xe^x-e^x=(x-1)e^x+C$</p><p>有的时候，我们可以尝试的去试试看谁做微分是简单的</p><p>往往$e^x$要放到微分里。</p><p>2)$\int x\cos xdx=\int xd\sin x=x\sin x-\int \sin xdx=x\sin x+\cos x+C$</p><p>往往三角函数要放到微分里。</p><p>那这样呢：</p><p>$\int \sin x e^xdx$</p><p>注意：$=\sin xe^x-\int e^x\cos xdx=\sin x e^x-\cos xe^x-\int \sin x e^xdx$</p><p>居然出现了我们要求的东西：</p><p>于是：$\int \sin x e^xdx=\frac{1}{2}(\sin x e^x-\cos xe^x)$</p><p>3)$\int \arccos xdx=x\arccos x-\frac{1}{2}\int \frac{d(1-x^2)}{\sqrt{1-x^2}}=x\arccos x-\sqrt{1-x^2}+C$</p><h3 id="有理函数"><a href="#有理函数" class="headerlink" title="有理函数"></a>有理函数</h3><p>​        这是针对$\frac{P(x)}{Q(x)}$的有理分式的积分方法：我们主要是添项拆项从而分离成若干简单分式的和差，从而方便我们的积分</p><p>1）P(x)的阶高于Q(x)</p><p>​        我们分离常数使之所有的子分式的分母阶比分子高：</p><p>2）P(x)的阶低于Q(x)</p><p>i.分母一阶的，直接$\ln$</p><p>ii.分母二阶的：</p><p>可以因式分解的：分解因式化简</p><p>不可以因式分解的：配方后变成$(ax+b)^2+C$的$\arctan$类型积分</p><p><img src="image-20230120130430538.png" alt="image-20230120130430538"></p><p>iii.分子分母差一次、</p><p>把分子扔进d里面升次</p><p><img src="image-20230120130642841.png" alt="image-20230120130642841"></p><p>iv.一般的</p><p>我们假设一个式子可以分解成若干的分式和，其分式的特点是：分子比分母底一阶，分子假设为全项的多项式：</p><p>如</p><p><img src="image-20230120130943140.png" alt="image-20230120130943140"></p><p>根式：</p><p>令t为根式，换元即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（2）</title>
      <link href="/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
      <url>/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学基础教程：导数的定义与使用"><a href="#高等数学基础教程：导数的定义与使用" class="headerlink" title="高等数学基础教程：导数的定义与使用"></a>高等数学基础教程：导数的定义与使用</h1><h2 id="一-基本定义和性质"><a href="#一-基本定义和性质" class="headerlink" title="一.基本定义和性质"></a>一.基本定义和性质</h2><h3 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h3><p>​        恭喜！你来到了导数这一章！现在，我们可以使用它来更精确的描述函数是怎么增长变动的！！！</p><p>​        首先，引入一个场景：讨论速度与位移，并且我们都用时间来表示：</p><p>那么，一个平均速度可以用如下这个式子来表达：$v=\frac{f(t)-f(t_0)}{t-t_0}$</p><p>​        这是我们中学就已经熟知的。</p><p>​        现在，让我们让$t\rightarrow{t_0}$ 也就是让t逼近$t_0$。这样，回到高中物理，我们就知道我们得到了瞬时速度。</p><p>​        其实，很多函数变化，都可以类比的使用这种办法得到函数在一个点的变化情况，下面，让我们统一一下，使用一个定义来综述：</p><p>$定义 y=f(x)在x_0的领域内有定义，对x_0取增量\Delta{x}，那么函数的增量就是\Delta{y}=f(x_0+\Delta{x})-f(x_0)，如果\lim\limits_{\Delta{x}\rightarrow{0}}\frac{\Delta{y}}{\Delta{x}}=\lim\limits_{\Delta{x}\rightarrow{0}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}$ $是存在的，我们就称呼y=f(x)在x_0处可导，且这个极限值就是y=f(x)在x_0处的导数$</p><p>​        记作$y’| _{x=x_0},f’(x_0),\frac{dy}{dx}|_{x=x_0}，\frac{df(x)}{dx}|_{x=x_0}$上面四个选一个</p><p>当然，导数还有另一个定义：就是</p><p>​      $如果\lim\limits_{x\rightarrow{x_0}}\frac{\Delta{y}}{\Delta{x}}=\lim\limits_{x\rightarrow{x_0}}\frac{f(x)-f(x_0)}{x-x_0}是存在的，我们就称呼y=f(x)在x_0处可导，且这个极限值就是y=f(x)在x_0处的导数$ </p><p>​        如果函数在一个区间内处处可导，我们就可以再用一个函数刻画导数：导函数$f’(x)$</p><p>​        下面来看一些函数的导（函）数（方便起见使用h代替$\Delta{x}$）</p><p>（1）$f(x)=C$</p><p>则：$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=0$</p><p>故$C’=0$</p><p>(2)$f(x)=x^n$</p><p>1.当n=1时:$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=1$</p><p>2.当n&gt;1时：$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\rightarrow{0}}\frac{(x+h)^n-x^n}{h}$</p><p>而：$(x+y)^n=x^n+nx^{n-1}y+\frac{n(n-1)}{2}x^{n-2}y^{2}+…+ny^{n-1}x+y^n$</p><p>于是$极限=\lim\limits_{h\rightarrow{0}}nx^{n-1}+(…)\times{h}=nx^{n-1}$</p><p>3.当$f(x)=x^{\mu},\mu\in{R}，(x\neq{0})$</p><p>于是：</p><p><img src="image-20221230201314473.png" alt="image-20221230201314473"></p><p>$(x^\mu)’=\mu{x^{\mu-1}}$</p><p>4.$f(x)=\sin{x}$</p><p>$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\rightarrow{0}}\frac{\sin{(x+h)}-\sin{x}}{h}=\lim\limits_{h\rightarrow{0}}\frac{\cos(x+\frac{h}{2})\times{\sin{\frac{h}{2}}}}{\frac{h}{2}}=\cos{x}$</p><p>所以：$\sin’{x}=\cos{x}$</p><p>类似的$\cos’{x}=-\sin{x}$</p><p>5.$(a^x)’=a^x\ln{a},特别的(e^x)’=e^x$</p><p>6.$\log’_{a}{x}=\frac{1}{x\ln{a}},特别的\ln’x=\frac{1}{x}$</p><h3 id="单侧导数"><a href="#单侧导数" class="headerlink" title="单侧导数"></a>单侧导数</h3><p>​        导数也有单侧导数的这一概念，直观的讲，正是导数以不同的方式逼近一个点所产生的：</p><p>​        回忆我们先前的类似概念，左侧导数的定义是这样的：</p><p>​        </p><script type="math/tex; mode=display">f'_{-}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^-} }\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        更容易理解的：右导数的定义是这样的：</p><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^+}}\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        当然，也有第二定义</p><p>​        左导数：</p>$$f'_{-}(x_0)=\lim \limits_{ { x } \rightarrow{x_0^-} } \frac{f(x_0+h)-f(x_0)} {h}$$<p>​        右导数：</p><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{ { x} \rightarrow{x_0^+} }\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        于是，可导的一种判断方式有了：在一个点的左右导数存在相等。</p><p>​        对于$y=|x|$ ，在$x_0$左侧的左导数为-1，右导数为1，这两个不相等，故$|x|$在$x=0$处不存在导数。</p><h3 id="导数也有几何意义"><a href="#导数也有几何意义" class="headerlink" title="导数也有几何意义"></a>导数也有几何意义</h3><p>​        导数也有几何意义，不错。那么，导数的几何意义是什么呢？直接说：导数的几何意义就是函数图像在某一点上的切线的斜率，一个处处可导的曲线必然光滑。</p><p><img src="image-20230104153906913.png" alt="image-20230104153906913"></p><p>​        于是，切线方程可以这样给出</p><script type="math/tex; mode=display">l:y-y_0=f'(x_0)(x-x_0)</script><p>​        有切线了，法线也会有：法线就是过切点的，垂直于切线的线：</p><script type="math/tex; mode=display">l':y-y_0=-\frac{1}{f'(x_0)}(x-x_0)</script><p>​        比如说，让我们求$y=\frac{1}{x}$在$(\frac{1}{2},2)$上的切线：</p><script type="math/tex; mode=display">证明:显然在x_0=\frac{1}{2}这个点上，f'(x_0)=-4</script><script type="math/tex; mode=display">于是切线方程为:y-2=-4(x-\frac{1}{2})</script><script type="math/tex; mode=display">法线方程为：y-2=\frac{1}{4}(x-\frac{1}{2})</script><h3 id="联系起来：探寻可导与连续的关系"><a href="#联系起来：探寻可导与连续的关系" class="headerlink" title="联系起来：探寻可导与连续的关系"></a>联系起来：探寻可导与连续的关系</h3><p>​        我们可以简单的理解认为可导就说明函数曲线的光滑，连续就是函数图像不产生间断。看来：函数如果光滑，则一定没有间断，函数没有间断却不一定光滑。那我们认为：<strong>可导必然连续，连续不一定可导。</strong></p><p>​        对于这件事情：可以想象一排自行车：如果他们想多米诺骨牌一样倒下了 （可 倒（导））说明他们一定连续的放置，反之，如果不去动他们，则他们就算连续放置也不会倒下，可以这样记。</p><p>​        回到数学的定义上，我们对比一下：</p><script type="math/tex; mode=display">连续:\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=0</script><script type="math/tex; mode=display">可导:\lim\limits_{\Delta{x}\rightarrow{0}}\frac{\Delta{y}}{\Delta{x}}=C(const)</script><p>​        于是，如果一个$\Delta{x}\rightarrow{0}$，同时，可导定义比出来的比值还必须是一个常数，由同阶无穷小的定义，我们不得不得出$\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=0$的结论，也就是连续。</p><p>​        反之，我们的$\Delta{y}$可能并不会与$\Delta{x}$属于同阶无穷小，因此，我们的可导定义极限可能发散。于是：就可能并不可导</p><h3 id="求导法则：和差商积"><a href="#求导法则：和差商积" class="headerlink" title="求导法则：和差商积"></a>求导法则：和差商积</h3><p>​        高中我们就接触过了：</p><p>​        首先定义$u,v$是两个可导函数，其值为$u’,v’$</p><script type="math/tex; mode=display">法则1: (u+v)'=u'+v'</script><script type="math/tex; mode=display">法则2:(u-v)'=u'-v'</script><script type="math/tex; mode=display">法则3:(uv)'=uv'+vu'</script><script type="math/tex; mode=display">法则4:(cu)'=cu'(c是常数)</script><script type="math/tex; mode=display">法则5:(\frac{u}{v})'=\frac{u'v-uv'}{v^2}</script><p>法则1234都可以扩展：</p><p>对于有限个$u_i$的可导函数：他们的和的导数为各自导数的和</p><script type="math/tex; mode=display">(u+v+w+...+...+s)'=u'+v'+w'+...+...+s'</script><p>对于有限个$u_i$的可导函数：他们的积的导数为所有$u_i$的积中轮流取出一个$u_k(k\in{(1,i)})$求一次导</p><script type="math/tex; mode=display">(uvw...s)'=u'vw...s+uv'w...s+uvw'...s+...+uvw...s'</script><h3 id="反函数的求导法则"><a href="#反函数的求导法则" class="headerlink" title="反函数的求导法则"></a>反函数的求导法则</h3><p>​        反函数也能求导。</p><script type="math/tex; mode=display">定理:x=f(y)在I_y内单调且可导，同时f'(y)\neq{0},</script><script type="math/tex; mode=display">那么反函数y=f^{-1}(x)的导函数如下：</script><script type="math/tex; mode=display">[f^{-1}(x)]'=\frac{1}{f'(y)}</script><p>​        超前一点，可以引入记号$\frac{dy}{dx}$表达$f(x)$的导数，而$\frac{dx}{dy}$就是反函数，于是：</p><script type="math/tex; mode=display">\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}</script><p>​        他让我们的导数公式可以扩充了：</p><p>​        例如:$x=\sin{y}$作为$y=\sin{x}$的反函数的公式</p><script type="math/tex; mode=display">因为:\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}=\frac{1}{\cos{y}}</script><script type="math/tex; mode=display">且:\sin^2{y}+\cos^2{y}=1\Longrightarrow{\cos{y}=\sqrt{1-\sin^2{y}}=\sqrt{1-x^2}}</script><p>​        于是：$y=\arcsin{x}$的导数公式正是：$\arcsin{x}’=\frac{1}{\sqrt{1-x^2}}$.</p><p>​        这样，我们也还可以求出其他公式：</p><script type="math/tex; mode=display">\arccos{x}'=-\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arctan{x}'=\frac{1}{1+x^2}</script><h3 id="复合函数的求导法则"><a href="#复合函数的求导法则" class="headerlink" title="复合函数的求导法则"></a>复合函数的求导法则</h3><p>​        下面，我们先从严肃的讲起：</p><p>​        假设，我说假设：$f(x)$是一个很复杂的东西：但好消息是，可以是做若干函数的嵌套：比如说$\ln{\sqrt{\frac{1}{cos{\ln{\sin^2{x}}}}}{sin{x}}}$云者，那这样的函数这么求导呢？复合求导法来力！</p><p>​        </p><script type="math/tex; mode=display">法则:简单的，视函数f(x)是由f(u),u=g(x)嵌套，那么它的导数是:</script><script type="math/tex; mode=display">f'(x)=f'(u)\times{g'(x)}</script><p>​        就是说，我们可以视$u$作一个整体，先想象成单一函数$f(x)$求导，不过$x$是$u$,随后对$u$求导，乘起来的时候u要换成x.</p><p>​        使用微分语言是这样描述的：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{dy}{du}\times\frac{du}{dx}</script><p>​        想象成分式乘法，我们自然可以：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{dy}{du}\times\frac{du}{dk}\times\frac{dk}{dw}...\times\frac{ds}{dx}</script><p>​        例如说：对$e^{x^{3}}$求导</p><p>​        我们首先设$u=x^3$，而$e^u$对$u$求导显然是$e^u$，那么$u$对$x$是$3x^2$根据法则，我们要把连着直接相乘$3e^u{x^2}$，但是还没换回来$x$,因此将$u=x^3$换回来得到结果$3e^{x^3}{x^2}$</p><p>​        那么：$y=\ln{\cos{e^x}}$如何？</p><p>​        直接设置$y=\ln{u},u=\cos{v},v=e^x$结合复合函数求导法则。</p><p>​        $y’=\frac{1}{u}\times{-\sin{v}}\times{e^x}$</p><p>​        换元：$y’=\frac{-\sin{e^x}\times{e^x}}{\cos{e^x}}$</p><h3 id="导数公式表"><a href="#导数公式表" class="headerlink" title="导数公式表"></a>导数公式表</h3><p>​        介绍完导数的求导法则，我们也就可以引入一系列的求导表了：</p><script type="math/tex; mode=display">(C)'=0</script><script type="math/tex; mode=display">(x^{\mu})'=\mu{x^{\mu-1}}</script><script type="math/tex; mode=display">\sin{x}'=\cos{x}</script><script type="math/tex; mode=display">\cos{x}'=-\sin{x}</script><script type="math/tex; mode=display">\tan{x}'=\sec^2{x}</script><script type="math/tex; mode=display">\cot{x}'=-\csc^2{x}</script><script type="math/tex; mode=display">\sec{x}'=\sec{x}\tan{x}</script><script type="math/tex; mode=display">\csc{x}'=-\csc{x}\cot{x}</script><script type="math/tex; mode=display">(a^x)'=\ln{a}\times{a^x},(e^x)'={e^x}</script><script type="math/tex; mode=display">\log_a{x}'=\frac{1}{x\ln{a}}</script><script type="math/tex; mode=display">\ln{x}'=\frac{1}{x}</script><script type="math/tex; mode=display">\arcsin{x}'=\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arccos{x}'=-\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arctan{x}'=\frac{1}NaN</script><script type="math/tex; mode=display">arccot{x}'=-\frac{1}NaN</script><h3 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h3><p>​        就是对一个函数求有限次导数：比如说</p><script type="math/tex; mode=display">y=x^3,y'=3x^2,y''=6x,y'''=6,y^{(4)}=0</script><p>​        在微分学里也有专门的符号表示</p><script type="math/tex; mode=display">一阶导数:\frac{dy}{dx}</script><script type="math/tex; mode=display">二阶导数:\frac{d}{dx}(\frac{dy}{dx})=\frac{d^2y}{dx^2}</script><script type="math/tex; mode=display">N阶导数:\underbrace{\frac{d}{dx}\frac{d}{dx}...\frac{d}{dx}\frac{dx}{dy}}_{Ntimes}=\frac{d^ny}{dx^n}</script><p>一些常见的N阶导数公式是如下的：</p><script type="math/tex; mode=display">\sin^{(x)}x=\sin{(x+\frac{n}{2}{\pi})}</script><script type="math/tex; mode=display">\cos^{(x)}x=\cos{(x+\frac{n}{2}{\pi})}</script><script type="math/tex; mode=display">\ln^{(n)}{(x+1)}=(-1)^{n-1}\frac{(n-1)!}{(1+x)^n}</script><script type="math/tex; mode=display">x^{\mu{(n)}}=\mu{(\mu-1)}{(\mu-2)}...{(\mu-n+1)}x^{\mu-n}</script><p>一些法则也是成立的：</p><script type="math/tex; mode=display">(u+v)^{(n)}=u^{(n)}+v^{(n)}</script><p>但是乘法不是，是莱布尼兹公式：</p><script type="math/tex; mode=display">(uv)^{(n)}=\sum^{n}_{k=0}C^{k}_{n}u^{(u-k)}v^{k}</script><h3 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h3><p>​        我们现在接触的函数都是显函数，$y$与$x$都是显然分离的，比如说$y=\sin{x}$云者，有一些函数是$x$和$y$混在一起的，比如说如下的几个式子</p><p>​                                                $                e^{xy}+\sin{y^2}+x^3+8=0$</p><p>​                                                    $e^y-xy-e=0$</p><p>云者。这些被称为隐函数，或者说：关于x的一个方程。</p><p>​        下面，我们介绍这样函数的求导方式：</p><p>​        我们假设$y=y(x)$是一个x的函数，于是，这样的方程成为了一个恒等式：一个关于x的一个大函数$F(x,f(x))=0$的式子。，现在我们求导，就是使用求导法则运算解决问题：右侧作为常数，导数恒为0，对左侧求导即可。下面对：</p><p>​                                                    $e^y-xy-e=0$</p><p>求导</p><p>​        左侧：$e^y\cdot{y’}+y+xy’$</p><p>​        右侧：0</p><p>​        现在参数分离：$y’=-\frac{y}{e^y+x}$</p><p>​                                            $y^5+2y-x-3x^7=0$</p><p>求导：</p><p>​        左侧：$5y^4y’+2y’-1-21x^6=0$</p><p>​        右侧：0</p><p>​        现在参数分离：$y’=\frac{1+21x^6}{5y^4+2}$</p><h3 id="参数方程求导"><a href="#参数方程求导" class="headerlink" title="参数方程求导"></a>参数方程求导</h3><p>​        我们说一些函数可以用</p><script type="math/tex; mode=display">\begin{align*}\begin{split}\left \{\begin{array}{ll}  x= \psi{(t)}                    \\  y=  \varphi{(t)}                               \end{array}\right.\end{split}\end{align*}</script><p>表示，这个时候，可以使用微分形式的公式更好的表达求导：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{\frac{dy}{dt}}{\frac{dx}{dt}}=\frac{\varphi{(x)}'}{\psi{(x)}'}</script><p>微分可以视作增量的一种表达：</p><p>​        回顾增量公式$\Delta{y}=f(x_0+\Delta{x})-f(x_0)$,我们常常发现以这种形式表达的$\Delta{y}$经常可以被写成$A\Delta{x}+o(\Delta{x})$的形式，注意到$A$与$\Delta{x}$是无关的。如果函数的增量可以这样表达：</p><script type="math/tex; mode=display">\Delta{y}=A\Delta{x}+o(\Delta{x})</script><p>​        $A$与$\Delta{x}$是无关,</p><p>​        那么，我们就改写成这样的形式：</p><script type="math/tex; mode=display">dy=Adx</script><p>​        同时，我们还说这样的函数在这一点是可微的：并且，可微一定可导，可导也一定可微：事实上，以此为基准</p><script type="math/tex; mode=display">dy=f'(x_0)dx</script><p>​        微分与导数就是变化率问题的等价表达</p><p>​        于是任何微分公式都可以由上述公式给出：</p><p>​        比如说：$y=x^2,dy=2xdx$</p><h3 id="微分在近似计算的应用"><a href="#微分在近似计算的应用" class="headerlink" title="微分在近似计算的应用"></a>微分在近似计算的应用</h3><p>​        回到上面讲的公式：</p><script type="math/tex; mode=display">\Delta{y}=f(x_0+\Delta{x})-f(x_0)</script><p>​        这个公式，我们可以对一个已知临近量的函数值求另一点相近的函数值的近似值，我们对公式移项：</p><script type="math/tex; mode=display">f(x_0+\Delta{x})=f'(x_0)\Delta{x}+f(x_0)</script><p><img src="image-20230104175543374.png" alt="image-20230104175543374"></p><h2 id="二-导数的应用"><a href="#二-导数的应用" class="headerlink" title="二.导数的应用"></a>二.导数的应用</h2><h4 id="Rolle（罗尔）定理"><a href="#Rolle（罗尔）定理" class="headerlink" title="Rolle（罗尔）定理"></a>Rolle（罗尔）定理</h4><p>​        事实上，为了更好的证明罗尔定理，一般我们需要严格的引入费马定理：</p><h4 id="费马定理"><a href="#费马定理" class="headerlink" title="费马定理"></a>费马定理</h4><p><strong>$f(x)$在$x_0$及其领域有定义，且在$x_0$处可导，如果$f(x)\leqslant{f(x_0)}$(或者$f(x)\geqslant{f(x_0)}$)</strong></p><p><strong>则$\forall{x}\in \cup(x_0)$(这表示领域)，$f’(x_0)=0$</strong></p><p><img src="image-20230106084644861.png" alt="image-20230106084644861"></p><p>​        看起来容易，怎么证明？我们不妨从$x_0$可导入手：</p><p>证明：以$f(x_0)$是最大值为例：函数$f(x)$在$x_0$处可导，那就要求：</p><script type="math/tex; mode=display">x\in \cup(x_0),f(x)\leqslant{f(x_0)}</script><p>​        同时注意到$x_0+\Delta{x}$也是在$\cup(x_0)$上的，于是也有：</p><script type="math/tex; mode=display">x_0+\Delta{x} \in \cup(x_0),f(x_0+\Delta{x})\leqslant{f(x_0)}</script><p>​        同时函数$f(x)$在$x_0$处可导：</p><script type="math/tex; mode=display">f'_{-}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^-}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}\leqslant{0}</script><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^+}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}\geqslant{0}</script><p>​        </p><script type="math/tex; mode=display">f'_{-}(x_0)=f'_{+}(x_0)</script><p>​        上面的三个式子联立：得到$f’_{-}(x_0)=f’_{+}(x_0)=f’(x_0)=0$</p><p>证毕。</p><p>​        于是：又把导数为0的点成为驻点，因为函数在这一点停靠在$y=f(x_0)$上不变化，他们是可能的极值点（会在后面阐述为什么是可能）</p><h4 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h4><p><strong>首先函数$f(x)$满足</strong></p><p><strong>1）在$[a,b]$上连续 2)在$(a,b)$上可导 3）$f(a)=f(b)$</strong></p><p><strong>则至少存在一点$\xi\in(a,b),f’(\xi)=0$</strong></p><p><img src="image-20230106090148355.png" alt="image-20230106090148355"></p><p>这个定理说明了在端点值相等的区间里函数必有<strong>至少</strong>一个驻点。</p><h4 id="拉格朗日中值定理"><a href="#拉格朗日中值定理" class="headerlink" title="拉格朗日中值定理"></a>拉格朗日中值定理</h4><p><strong>要求：1)$[a,b]$连续          2)$(a,b)$可导：</strong></p><p><strong>则函数$f(x)$在$(a,b)$上至少有一个点$\xi$,使得下面的式子成立：</strong></p><script type="math/tex; mode=display">f'(\xi)=\frac{f(b)-f(a)}{b-a}</script><p><img src="image-20230106090806236.png" alt="image-20230106090806236"></p><p>​        说白了，就是罗尔定理的扩展，我们链接两个端点，产生的直线称为函数的一条<strong>弦</strong>在函数上我们至少可以找到一个点的切线斜率等于这条线的斜率的大小。</p><h4 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h4><p>如果$f(x)$和$F(x)$满足：</p><p>1）$[a,b]$连续          2)$(a,b)$可导          3）$\forall{x}\in(a,b),F’(x)\neq{0}$</p><p>则至少有一个点$\xi$,使得$\frac{f(b)-f(a)}{F(b)-F(a)}=\frac{f’(\xi)}{F’(\xi)}$</p><p>​        这又是拉格朗日中值定理的推广。</p><h4 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h4><p>​        这玩意干嘛的？求解未定式$\frac{0}{0}$,$\frac{\infty}{\infty}$的式子</p><p>注意：法则内容如下：</p><p>1）两个函数$f(x),F(x)$在$x\rightarrow a$都同时倾向于$0$或者$\infty$ </p><p>2）在$a$的去心领域内$f’(x),F’(x)$都存在且$F’(x)\neq 0$</p><p>3）$\lim\limits_{x\rightarrow a}\frac{f’(x)}{F’(x)}$存在（或者无穷大）</p><p>则$\lim\limits_{x\rightarrow a}\frac{f(x)}{F(x)}=\lim\limits_{x\rightarrow a}\frac{f(x)}{F(x)}$</p><p>例子：</p><script type="math/tex; mode=display">1)\lim\limits_{x\rightarrow 0}\frac{\sin{ax}}{\sin bx}=\lim\limits_{x\rightarrow 0}\frac{a\cos ax}{b \cos bx}=\frac{a}{b}</script><p>注意：如果使用完一次洛必达后的式子<strong>仍满足洛必达的条件</strong>可以继续使用</p><p>比如说</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow 1}\frac{x^3-3x+2}{x^3-x^2-x+1}=\lim\limits_{x\rightarrow 1}\frac{3x^2-3}{3x^2-2x-1}=\lim\limits_{x\rightarrow 1}\frac{6x}{6x-2}</script><p>​        到这里就不能再使用洛必达法则了：因为$\lim\limits_{x\rightarrow 1}\frac{6x}{6x-2}$不满足条件1)，所以：直接带值得到$\frac{3}{2}$结束</p><p>​        注意，我们可以使用这个法则分析一些常见函数的发散速度：</p><p>命题：比较$\ln x,x^n,e^{\lambda{x}}$的发散速度</p><p>比较$\ln x,x^n$</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{\ln x}{x^n}=\lim\limits_{x\rightarrow \infty}\frac{1}{nx^{n-1}\cdot{x}}=0</script><p>​        这意味这$\ln{x}$的发散速度小于$x^n$的发散速度。</p><p>比较$x^n，e^{\lambda{x}}$</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{x^n}{e^{\lambda{x}}}=\lim\limits_{x\rightarrow \infty}\frac{nx^{n-1}}{\lambda e^{\lambda{x}}}=\lim\limits_{x\rightarrow \infty}\frac{n(n-1)x^{n-2}}{\lambda ^2e^{\lambda{x}}}=...=\lim\limits_{x\rightarrow \infty}\frac{n!}{\lambda ^ne^{\lambda{x}}}=0</script><p>​    这意味这$x^n$的发散速度小于$e^{\lambda{x}}$的发散速度。</p><h4 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h4><p>​        泰勒公式是用若干多项式近似描述函数的一个公式：</p><script type="math/tex; mode=display">P_n(x)=\sum_{k=0}^{n} a_k(x-x_0)^k +R(x)=f(x)</script><p>​        这样一个过程。$R(x)$是高于n阶的一个误差数。</p><p>​        我们求$x_0$一阶导数得到：$f’(x_0)=a_1$</p><p>​        类似的$f’’(x_0)=1\cdot 2a_2$</p><p>​        $f’’’(x_0)=1\cdot 2 \cdot 3a_3$</p><p>​        …</p><p>​        $f^{(n)}(x)=n!a_n$</p><p>​        这样多项式的系数就确定了！替换一下：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)</script><p>其中$R_n(x)=o(x-x_0)^n$当然，由拉格朗日中值定理，$R_n(x)$也可以这样表达：</p><script type="math/tex; mode=display">R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}</script><p>当然还有更紧凑的形式：</p><script type="math/tex; mode=display">f(x)=\sum_{k=0}^{n}\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k+R_n(x)</script><p>我们使用泰勒公式看看一些函数的近似,为了简便，我们自然取$x_0=0$</p><script type="math/tex; mode=display">e^x=1+x+\frac{x^2}{2}+\frac{x^3}{6}+...+\frac{x^n}{n!}+R_n(x)=\sum_{k=0}^{n}\frac{(x-x_0)^k}{k!}+R_n(x)</script><script type="math/tex; mode=display">\sin{x}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-...(-1)^{(m-1)}\frac{x^{(2m-1)}}{(2m-1)!}+R_{2m}(x)=\sum_{k=0}^{n}\frac{(-1)^{(m-1)}(x-x_0)^k}{(2m-1)!}+R_{2m}(x)</script><script type="math/tex; mode=display">\cos{x}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-...(-1)^{(m-1)}\frac{x^{2m}}{(2m)!}+R_{2m}(x)=\sum_{k=0}^{n}\frac{(-1)^{(m-1)}(x-x_0)^k}{(2m)!}+R_{2m}(x)</script><script type="math/tex; mode=display">\ln{(x+1)}=x-\frac{x^2}{2}+\frac{x^3}{3}-...+(-1)^{(n-1)}\frac{x^n}{n}+\sum_{k=1}^{n}(-1)^{(n-1)}\frac{x^n}{n}+R_n(x)</script><script type="math/tex; mode=display">(1+x)^\alpha=1+\alpha{x}+\frac{\alpha(\alpha-1)}{2!}x^2+...+\frac{\alpha(\alpha-1)...(\alpha-n+1)}{n!}(x-x_0)^n=\sum_{k=0}^{n}\frac{C_k^{\alpha}}{k!}(x-x_0)^k</script><h4 id="函数的单调性"><a href="#函数的单调性" class="headerlink" title="函数的单调性"></a>函数的单调性</h4><p>​        现在，我们可以系统的分析函数的单调性了：</p><p>​        函数的单调性分为单调递增和单调递减：( x 在区间 I ,且函数连续)</p><script type="math/tex; mode=display">函数单调递增:f'(x)>0</script><script type="math/tex; mode=display">函数单调递减:f'(x)<0</script><p>​        于是下面给出定理：</p><script type="math/tex; mode=display">y=f(x)在[a,b]连续,(a,b)可导 且f'(x)\geqslant{0},更进一步的等号在有限个点取到</script><script type="math/tex; mode=display">那么我们说：函数在区间(a,b)上单调递增</script><p>​        同理：单调递减的也是类似的</p><script type="math/tex; mode=display">y=f(x)在[a,b]连续,(a,b)可导 且f'(x)\leqslant{0},更进一步的等号在有限个点取到</script><script type="math/tex; mode=display">那么我们说：函数在区间(a,b)上单调递减</script><p>​        函数的单调性与一阶导数息息相关，看一些例题 </p><script type="math/tex; mode=display">分析y=x-\sin x [-\pi,\pi]的单调性</script><p>​        </p><p>​        因为：</p><script type="math/tex; mode=display">y'=1-\cos{x}\geqslant 0</script><p>​        故函数总在$[-\pi,\pi]$单调递增。</p><p>​        这样的一些点是我们在求解一阶导数的时候需要注意的：</p><p>1）$f’(x)=0$  的点：又叫驻点。</p><p>2)导数不存在的点</p><p>例题：</p><script type="math/tex; mode=display">分析f(x)=2x^3-9x^2+12x-3 的单调性</script><script type="math/tex; mode=display">f'(x)=6x^2-18x+12=6(x-1)(x-2)</script><script type="math/tex; mode=display">所以：x<1单增，1\leqslant{x}\leqslant{2}单减，x\geqslant{2} 单增</script><h4 id="函数的凹凸性"><a href="#函数的凹凸性" class="headerlink" title="函数的凹凸性"></a>函数的凹凸性</h4><p>​        我们还要关注函数是怎样的单调递增或者单调递减，这就需要我们使用二阶导数分析函数的凹凸性。</p><p>​        首先我们来看定义：</p><p>​        <strong>仍对于$f(x)$在区间$I$上连续，如果对任意的$x_1,x_2 \in I (x_1\neq{x_2})$</strong></p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2})<\frac{f(x_1)+f(x_2)}{2}</script><p>​        <strong>我们就称呼$f(x)$在区间$I$上的图像是凹的（上凹）</strong></p><p>​        <strong>类比的：如果：</strong></p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2})>\frac{f(x_1)+f(x_2)}{2}</script><p>​        <strong>那么我们又称呼$f(x)$在区间I上的图像是凸的（下凹的）</strong></p><p><img src="image-20230107152418652.png" alt="image-20230107152418652"></p><p>​        函数$f(x)$如果在$I$上是凹（凸）的，那么$-f(x)$是凸(凹)的。</p><p><img src="image-20230107152556639.png" alt="image-20230107152556639"></p><p>​        我们先前就提到过：函数的凸凹性和函数的二阶导数密切相关，下面我们来一睹定理的芳容：</p><p>​        <strong>设$f(x)$在区间$I$上二阶可导，那么：</strong></p><p>​        <strong>（1）若在$I$上$f’’(x)&gt;0$，那么我们说函数是凹的</strong></p><p>​        <strong>（2）若在$I$上$f’’(x)&lt;0$，那么我们说函数是凹的</strong></p><h4 id="极值及其求法"><a href="#极值及其求法" class="headerlink" title="极值及其求法"></a>极值及其求法</h4><p>​        首先我们需要区分一下极值和最值：</p><p>​        极值：邻域内函数的最大最小值</p><p>​        最值：在全函数的定义域内函数的最大最小值</p><p>下面给出严肃的定义：</p><p>​        定义：$f(x)$在$x_0$的领域$\cup (x_0)$下有定义且连续,$\forall{x}\in\mathring{U}(x_0)$,$f(x)<f(x_0)(或者)(f(x)>f(x_0))$那么我们说$f(x_0)$是函数的极大值 or 极小值。</p><p>​        极值的定理 I:(必要条件)函数可导，且在此点$x_0$的导数 $f’(x_0)=0$</p><p>​        极值的定理 II:(第一充分条件)：$f(x)$在$x_0$处连续,且在$\mathring{U}(x_0)$处可导</p><p>（1）$x \in(x_0-\delta,x_0)$ 且$f’(x)&gt;0$,而$x \in(x_0,x_0+\delta)$ 且$f’(x)&lt;0$我们说函数在此点取上极大值</p><p>（2）$x \in(x_0-\delta,x_0)$ 且$f’(x)&lt;0$,而$x \in(x_0,x_0+\delta)$ 且$f’(x)&gt;0$我们说函数在此点取上极小值</p><p>如果不变号，那就不是极值点。</p><p>​        下面总结流程：</p><p>​        （1）求$f’(x)$</p><p>​        （2）求驻点和不可导点</p><p>​        （3）考察上面这些点的变号情况</p><p>例题：$f(x)=(x-4)\sqrt[3]{(x+1)^2}$的极值点.</p><p>$f’(x)=\frac{5(x-1)}{3\sqrt[3]{x+1}}$令$f’(x)=0$</p><p>得到 $x=1$是驻点，$x=-1$是不可导点</p><p>1)$x=-1$,$x&lt;-1$时，$f’(x)&gt;0$, $x&gt;-1$时，$f’(x)&lt;0$,所以这是一个极大值点</p><p>2）$x=1$,$x<1$时，$f'(x)<0$, $x>-1$时，$f'(x)>0$,所以这是一个极小值点</p><p>当然还有别的判断方式：</p><p>​        定理 II’（第二充分条件）函数$f(x)$二阶可导，$f’(x_0)=0,f’’(x_0)\neq{0}$</p><p>当：</p><p>1)$f’’(x)&lt;0$在$x_0$处取极大值</p><p>2)$f’’(x)&gt;0$,在$x_0$处极小值</p><h4 id="函数图像的绘制"><a href="#函数图像的绘制" class="headerlink" title="函数图像的绘制"></a>函数图像的绘制</h4><p>​        下面我们开始绘制函数的图像！这也是系统分析函数的步骤</p><p>​        1）分析函数的定义域，以及可能的奇偶性，周期性</p><p>​        2)求出一阶导数，二阶导数，和他们等于0的点</p><p>​        3)找出函数的间断点（从定义域得到），以及一阶导数，二阶导数不存在的点</p><p>​        4）由此求出函数的单调性凹凸性</p><p>​        5）看看是否有渐近线（铅锤，水平，斜的渐近线）</p><p>​        6）确定极值（带点）</p><p>例如：$y=x^3-x^2-x+1$</p><p>​        显然函数的定义域为$R$，且无奇偶性，周期性</p><p>​        $f’(x)=3x^2-2x-1,f’’(x)=2(3x-1)$</p><p>​        令$f’(x)=0,x=-\frac{1}{3}或x=1$,当$f’’(x)=0,x=\frac{1}{3}$</p><p>​        确定函数的分间断是：$(-\infty,-\frac{1}{3}),[-\frac{1}{3},\frac{1}{3}],[\frac{1}{3},1],[1,+\infty]$</p><p>​        并且列表时按照如下格式列</p><p>![image-20230107161122390]image-20230107161122390.png)</p><p>补充：函数的渐近线是如下公式确定的：</p><script type="math/tex; mode=display">if :\lim{\frac{f(x)}{x}}=k存在，那就有斜渐近线存在</script><script type="math/tex; mode=display">如果存在:则b=\lim{(f(x)-kx)},直线的方程就是y=kx+b</script><p>至于水平渐近线就是$\lim\limits_{x\rightarrow{\infty}}(f(x)-b)=0$那么就是$y=b$</p><p>铅锤渐近线:$\lim\limits_{x\rightarrow{a}}f(x)\rightarrow\infty$则就是$x=a$</p><h4 id="曲率分析："><a href="#曲率分析：" class="headerlink" title="曲率分析："></a>曲率分析：</h4><p>​        我们使用曲率来分析曲线的弯曲程度：</p><p><img src="image-20230107161834749.png" alt="image-20230107161834749"></p><p>​        这样看</p><p><img src="image-20230107161907141.png" alt="image-20230107161907141"></p><p>​        可以看到，如果$M$移动相同单位，其倾角变化越大，那就称之曲率越大：</p><script type="math/tex; mode=display">\overline{K}=|\frac{\Delta{\alpha}}{\Delta s}|</script><p>​        如果我们让图片里的$M,M’$靠拢，不久类比的得到一个点的曲率了吗 ？（ds是弧微分，后面有图片展示）</p><p>​        </p><script type="math/tex; mode=display">K=\lim\limits_{\Delta s \rightarrow 0}|\frac{\Delta{\alpha}}{\Delta s}|=|\frac{d\alpha}{ds}|</script><p>​        这样：直线的曲率:$K=0$</p><p>​        圆的曲率:$K=\frac{1}{r}$（ r 是圆的半径）</p><p><img src="image-20230107162607705.png" alt="image-20230107162607705"></p><p>​        曲率的公式在直角坐标系的公式可以从定义得到:</p><p>​        $y’=\tan{\alpha}$,$y’’=\sec^2{\alpha}$,于是:</p><script type="math/tex; mode=display">|\frac{d\alpha}{dx}|=\frac{y''}{\sec^2{x}}=\frac{y''}{1+\tan^2{\alpha}}=\frac{y''}{1+y'^2}</script><p>​        而$ds=$$\sqrt{1+y’^2}$</p><p><img src="image-20230107163229852.png" alt="image-20230107163229852"></p><p>​                                                                        弧微分</p><p>​        于是：</p><script type="math/tex; mode=display">|\frac{d\alpha}{ds}|=|\frac{\frac{y''}{1+y'^2}}{\sqrt{1+y'^2}}|=|\frac{y''}{(1+y'^2)^\frac{3}{2}}|</script><p>​        类比的，在参数方程下：</p><p><img src="image-20230107163642181.png" alt="image-20230107163642181"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（1）</title>
      <link href="/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h3 id="认识时间复杂度"><a href="#认识时间复杂度" class="headerlink" title="认识时间复杂度"></a>认识时间复杂度</h3><p>​        我们有一些操作是常数时间完成的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int a &#x3D;arr[i];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为我们直接计算偏移量直接取出的</p><p>​        但是这个不是</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int t&#x3D;list.get(i);&#x2F;&#x2F;链表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为链表必须遍历，才能找到元素</p><p>​        以及加减乘除的操作是常数操作。</p><p>​        总而言之：涉及到数据量的操作都是<strong>非常数操作</strong></p><p>​        举个例子，选择排序：这个排序是一种选择某一个数与前面已经排好的数组开始对比。怎么保证前面的已经有序了呢？我们把算法作用在第一个元素上，这个时候那他与第二个元素排序，成功后就是一个有序小数组，这样就满足了递归的条件：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Part I:C version without recurssion#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;&#x2F;&#x2F;using Choose sort to sort the array&#x2F;&#x2F;rand num getterint getRandNum(int maxRange)&#123;    srand((unsigned int)clock());    Sleep(10);    return rand()% maxRange;&#125;void printCurrentArray(int* array,int arraySize)&#123;    printf(&quot;Current array is shown:\n&quot;);    for(int i&#x3D;0; i&lt;arraySize; i++)    &#123;        printf(&quot;%d &quot;,array[i]);    &#125;    printf(&quot;\n&quot;);&#125;void swapInt(int* e1, int* e2)&#123;    int temp&#x3D;*e1;    *e1&#x3D;*e2;    *e2&#x3D;temp;&#125;int main()&#123;    &#x2F;&#x2F;get a rand array    int arr[10]&#x3D;&#123;0&#125;;    for(int i&#x3D;0; i&lt;10; i++)    &#123;        arr[i]&#x3D; getRandNum(100);    &#125;    &#x2F;&#x2F;Sort starts!    for(int i&#x3D;1; i&lt;10; i++)    &#123;        &#x2F;&#x2F;from the second one        &#x2F;&#x2F;Compared with the previous one and the front one        for(int j&#x3D;i;j&gt;0;j--)        &#123;            &#x2F;&#x2F;If inverted,invert them back            if(arr[j]&lt;arr[j-1])            &#123;                swapInt(&amp;arr[j], &amp;arr[j - 1]);            &#125;        &#125;        &#x2F;&#x2F;Target the Current Key and show:        printf(&quot;Current key is:%d\n&quot;,arr[i]);        printCurrentArray(arr,10);        printf(&quot;Enter the newline to go forward!&quot;);        getchar();    &#125;    printf(&quot;Eventually...\n&quot;);    printCurrentArray(arr,10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Or Recussion type#define _CRT_SECURE_NO_WARNINGS 1#include&lt;windows.h&gt;#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;&#x2F;&#x2F;using Choose sort to sort the array&#x2F;&#x2F;rand num getterint getRandNum(int maxRange)&#123;    srand((unsigned int)clock());    Sleep(10);    return rand() % maxRange;&#125;void printCurrentArray(int* array, int arraySize)&#123;    printf(&quot;Current array is shown:\n&quot;);    for (int i &#x3D; 0; i &lt; arraySize; i++)    &#123;        printf(&quot;%d &quot;, array[i]);    &#125;    printf(&quot;\n&quot;);&#125;void swapInt(int* e1, int* e2)&#123;    int temp &#x3D; *e1;    *e1 &#x3D; *e2;    *e2 &#x3D; temp;&#125;void insertSort(int* array, int arraySize, int cur_sort_place)&#123;    if (cur_sort_place &gt; arraySize-1)        return;    int j &#x3D; cur_sort_place;    while (j &gt; 0)    &#123;        if (array[j] &lt; array[j - 1])            swapInt(&amp;array[j], &amp;array[j - 1]);        j--;    &#125;    choiceSort(array, arraySize, cur_sort_place + 1);&#125;int main()&#123;    int arr[10] &#x3D; &#123; 0 &#125;;    for (int i &#x3D; 0; i &lt; 10; i++)    &#123;        arr[i] &#x3D; getRandNum(100);    &#125;    insertSort(arr, 10, 1);    printCurrentArray(arr, 10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个算法的时间复杂度就是O($N^2$)，这是因为操作表达式的最高阶是$N^2$.</p><p>​        注意到O(N)表达的是表达式的最高此项，是衡量巨大数量下算法的优良度</p><p><img src="image-20230126193633933.png" alt="image-20230126193633933"></p><p>​        当时间复杂度相同时，通过==比较常数项==作出判断是否可靠。更多的时候我们选择直接开跑看看怎么样：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void Process1()&#123;    int N&#x3D;1000;    int a&#x3D;1;    for(int i&#x3D;0 ; i&lt;N; i++)    &#123;        a*&#x3D;10;        a&#x3D;a+10;        a&#x3D;6127*9876;    &#125;&#125;public static void Process2()&#123;     int N&#x3D;1000;    int a&#x3D;1;    for(int i&#x3D;0 ; i&lt;N; i++)    &#123;        a&#x3D;10|1;        a^&#x3D;10;        a&#x3D;a&amp;9876;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对，就是这种。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>​        回顾上面的实例代码：我们使用Java写出另一个版本：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">seletionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minIndex<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            minIndex<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token operator">?</span>j<span class="token operator">:</span>minIndex<span class="token punctuation">;</span><span class="token comment">//直接找到最小的地方</span>        <span class="token punctuation">&#125;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Using in swap minindex with arr[i]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>​        我们也可以使用冒泡排序排数，就像大的泡泡向下沉，小的泡泡向上浮。就好了。值得注意的是，我们换完产生的最值区已经换好了，没有必要再参与排序。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>N<span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>conditions<span class="token punctuation">)</span>            swap data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="交换的离奇写法"><a href="#交换的离奇写法" class="headerlink" title="交换的离奇写法"></a>交换的离奇写法</h3><p>请看这个</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>异或：相同为0，不同为1：</p><p>例如：</p><p>A:1011110101001</p><p>B:1000101011001</p><p>  A^B: 0011011110000                        </p><p>也可以理解为无进位相加：</p><p>性质1：0^N=N,N^N=0</p><p>性质2：满足交换律和结合律</p><p>那这是怎么交换的？</p><p>a=a^b  1)</p><p>b=a^b</p><p>a=a^b</p><p>假设a= A,b=B;</p><p>1)a=A^B b=B</p><p>2)a=A^B,b=(A^B)^B =A^(B^B)=A</p><p>3)a=A^B^A=B b=A</p><p>交换完毕</p><p>但是注意：这样的方法不适用于同一块内存，否则会洗成0.</p><p>例题：1）现在有一个整型数组：里面有诺干出现了偶数次的数和一个出现奇数次的数，找出那个奇数次数的数：</p><p>EG：[2,1,3,1,3,1,3,2,1]——-&gt;3</p><p>Solutions：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int ero&#x3D;0;for(int i&#x3D;0;i&lt;arr.length;i++)&#123;ero^&#x3D;arr[i];&#125;printf(&quot;%d &quot;,ero);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是因为异或顺序无关，偶数次数的全消成了0.于是可以引用在奇偶相关次序无关的题目。</p><p>2）现在有一个整型数组：里面有诺干出现了偶数次的数和两个出现奇数次的数，找出那两个奇数次数的数：</p><p>Ok，当我们依旧沿袭上面的方法的时候，我们发现：eor=a^b,这是因为一切出现了偶数次的异或为0，a和b也最后削成一个a^b。下面怎么办？</p><p>注意到a$\neq$b，这样的话：因为最右边的1是a,b作为二进制的特征数（用它来区分a,b），我们就可以提取出来：int rightOne=eor&amp;(~eor+1)，也就是源码与上补码，提取eor上的第右边的1，随后只与这个位置上是1的数，就得到a或者是b了</p><p>​        <img src="image-20230127113335433.png" alt="image-20230127113335433"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printOddTimeNum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> eor<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        eor<span class="token operator">^</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> rightOne<span class="token operator">=</span>eor<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>eor<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找出来最右边的数</span>    <span class="token keyword">int</span> onlyOne<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//eor'</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token operator">:</span>arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cur<span class="token operator">&amp;</span>rightOne<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//别写1，因为出来的只能是0或者是rightOne，如果想要另一个就!=0;</span>            onlyOne<span class="token operator">^=</span>cur<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>onlyOne<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span><span class="token punctuation">(</span>ero<span class="token operator">^</span>onlyOne<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>​        这个就是最上面的代码，就是相当于插牌。这个算法的表现是波动较大的：O(N)~O($N^2$)。</p><p>​        但是算法的复杂度是看最差情况的，所以是O($N^2$).</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><p>​        注意，这个只使用于有序数组。这个数组使用二分查找是最快的。主要思想：找中间，比大小，挪边界，继续二分。这个算法的复杂度因此是$O(\log n)$.</p><h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h3><p>​        假设我们要进行测试方法A，我们使用随机样本产生器，我们随机的产生数据放到多个方法，他们结果要是不一样，那要不就是A错，要不就是B错，要不就是都错了。这个时候人工干预的方式修改方法。</p><h3 id="递归行为下时间复杂度的计算"><a href="#递归行为下时间复杂度的计算" class="headerlink" title="递归行为下时间复杂度的计算"></a>递归行为下时间复杂度的计算</h3><h4 id="求取中点的方法"><a href="#求取中点的方法" class="headerlink" title="求取中点的方法"></a>求取中点的方法</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int mid&#x3D;L+((R-L)&gt;&gt;1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    为什么这样书写：防止R+L溢出int上限、</p><h4 id="使用递归求解数组最大值："><a href="#使用递归求解数组最大值：" class="headerlink" title="使用递归求解数组最大值："></a>使用递归求解数组最大值：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">L</span><span class="token operator">==</span><span class="token class-name">R</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token class-name">L</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> leftMax<span class="token operator">=</span><span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token class-name">L</span><span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightMax<span class="token operator">=</span><span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">,</span>rightMax<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个写法我们是在二分类是常用的：先处理递归左边，再递归处理右边，最后从小到大的返回各层的最大值，最后得到整体的最大值。下面也有C++版本的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;Windows.h&gt;class Finder &#123;public:int getMax(std::vector&lt;int&gt; s) &#123;return Dofindmax(s, 0, s.size()-1);&#125;int Dofindmax(std::vector&lt;int&gt; s, int left, int right)&#123;if (left &#x3D;&#x3D; right)return s[left];int mid &#x3D; left + ((right - left) &gt;&gt; 1);int leftMax &#x3D; Dofindmax(s, left, mid);int rightMax &#x3D; Dofindmax(s, mid + 1, right);return leftMax &gt; rightMax ? leftMax : rightMax;&#125;&#125;;void PrintVector(std::vector&lt;int&gt; s)&#123;for (std::vector&lt;int&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;std::cout&lt;&lt;std::endl;&#125;int getRandNum()&#123;srand((unsigned int)clock());Sleep(10);return rand() % 100;&#125;int main()&#123;std::vector&lt;int&gt; s;for (int i &#x3D; 0; i &lt; 10; i++)s.push_back(getRandNum());PrintVector(s);Finder f;int t &#x3D; f.getMax(s);std::cout &lt;&lt; t;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，别太常用，因为容易把栈搞炸</p><p><img src="image-20230127160815732.png" alt="image-20230127160815732"></p><p>画个递归树</p><h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><script type="math/tex; mode=display">if:T(N)=a*T(\frac{N}{b})+O(N^d)</script><script type="math/tex; mode=display">then:1)\log_ba>d->T(N^{\log_ba})</script><script type="math/tex; mode=display">2)\log_ba=d->T(N^{d}log N)</script><script type="math/tex; mode=display">3)\log_ba<d->T(N^{d})</script><p>有人话版本吗？有的：就是说我们的一次递归可以拆分一个问题为b个子问题，当然右额外开销$N^d$,这样，我们就有分层级讨论：比较$\log_ba$与d的大小从而一步写出公式。</p><p>以上面为例：上面的问题把问题拆成两个子问题：b=2,并且在单个函数体内调用了两次：a=2,剩下的时间复杂度为O(1).这下，我们的公式就是：</p><script type="math/tex; mode=display">T(N)=2*T(N/2)+O(1)</script><p>这样就直接带入公式:T(N)=O(logn).</p><h3 id="补充Reading"><a href="#补充Reading" class="headerlink" title="补充Reading"></a>补充Reading</h3><p>​        平时设计或者阅读一个算法的时候，必然会提到算法的复杂度（包括时间复杂度和空间复杂度）。比如我们说一个二分查找算法的平均时间复杂度为 O(log n)，快速排序可能是 O(n log n)。那这里的 O 是什么意思？这样的表达是否准确呢？</p><p>​        今天来复习一下与算法复杂度相关的知识：函数渐进阶，记号 O、Ω、θ和 o；Master 定理。</p><p>​        先插一句，在算法复杂度分析中，log 通常表示以 2 为底的对数。</p><p>​        算法复杂度（算法复杂性）是用来衡量算法运行所需要的计算机资源（时间、空间）的量。通常我们利用渐进性态来描述算法的复杂度。</p><p>​        用 n 表示问题的规模，T(n) 表示某个给定算法的复杂度。所谓渐进性态就是令 n→∞ 时，T(n) 中增长最快的那部分。严格的定义是：如果存在 $T’(n)$，当 n→∞ 时，有:</p><script type="math/tex; mode=display">\frac{T(n)-T'(n)}{T(n)}\rightarrow 0</script><p>​        我们就说$T’(n)$是 T(n) 当 n→∞ 时的渐进性态。</p><p>​        比如 T(n) = 2 <em> n ^ 2 + n log n + 3，那么显然它的渐进性态是 2 </em> n ^ 2，因为当 n→∞ 时，后两项的增长速度要慢的多，可以忽略掉。引入渐进性态是为了简化算法复杂度的表达式，只考虑其中的主要因素。当比较两个算法复杂度的时候，如果他们的渐进复杂度的阶不相同，那只需要比较彼此的阶（忽略常数系数）就可以了。</p><p>​        总之，分析算法复杂度的时候，并不用严格演算出一个具体的公式，而是只需要分析当问题规模充分大的时候，复杂度在渐进意义下的阶。记号 O、Ω、θ和 o 可以帮助我们了解函数渐进阶的大小。</p><p>​        假设有两个函数 f(n) 和 g(n)，都是定义在正整数集上的正函数。上述四个记号的含义分别是：</p><ul><li>f(n) = O(g(n))：$∃c&gt;0,n_0∈N,∀n≥n_0,f(n)≤cg(n)$；f 的阶<strong>不高于</strong> g 的阶。</li><li>f(n) = Ω(g(n))：$∃c&gt;0,n_0∈N,∀n≥n_0,f(n)≥cg(n)$；f 的阶<strong>不低于</strong> g 的阶。</li><li>f(n) = θ(g(n))：⟺$f(n)=O(g(n))\&amp;\&amp;f(n)=Ω(g(n))$；f 的阶<strong>等于</strong> g 的阶。</li><li>f(n) = o(g(n))：$∀\varepsilon&gt;0,∃n_0∈N,∀n≥n_0,f(n)/g(n)&lt;\varepsilon$；f 的阶<strong>低于</strong> g 的阶。</li></ul><p>​        可见，记号 O 给出了函数 f(n) 在渐进意义下的上界（但不一定是最小的），相反，记号Ω给出的是下界（不一定是最大的）。如果上界与下界相同，表示 f(n) 和 g(n) 在渐进意义下是同阶的（θ），亦即复杂度一样。</p><p>​        列举一些常见的函数之间的渐进阶的关系：</p><p><img src="image-20230127163435272.png" alt="image-20230127163435272"></p><p>​        有些人可能会把这几个记号跟算法的最坏、最好、平均情况复杂度混淆，它们有区别，也有一定的联系。</p><p>​        即使问题的规模相同，随着输入数据本身属性的不同，算法的处理时间也可能会不同。于是就有了最坏情况、最好情况和平均情况下算法复杂度的区别。它们从不同的角度反映了算法的效率，各有用处，也各有局限。</p><p>​        有时候也可以利用最坏情况、最好情况下算法复杂度来粗略地估计算法的性能。比如某个算法在最坏情况下时间复杂度为θ(n ^ 2)，最好情况下为θ(n)，那这个算法的复杂度一定是 O(n ^ 2)、Ω(n) 的。也就是说 n ^ 2 是该算法复杂度的上界，n 是其下界。</p><p>​        接下来看看 Master 定理。</p><p>​        有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的：</p><p>​        设常数 a &gt;= 1，b &gt; 1，f(n) 为函数，T(n) 为非负整数，T(n) = a T(n / b) + f(n)，则有：</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230127163457999.png" alt="image-20230127163457999"></p><p>​        比如常见的二分查找算法，时间复杂度的递推方程为 T(n) = T(n / 2) + θ(1)，显然有 $n^{\log _b^a}⁡=n^0=Θ(1)$，满足 Master 定理第二条，可以得到其时间复杂度为 T(n) = θ(log n)。</p><p>​        再看一个例子，T(n) = 9 T(n / 3) + n，可知 $n^{\log_b^a}=n^2$，令ε取 1，显然满足 Master 定理第一条，可以得到 T(n) = θ(n ^ 2)。</p><p>​        来一个稍微复杂一点儿例子，T(n) = 3 T(n / 4) + n log n。$n^{\log_b^a}=O(n^{0.793})$，取ε = 0.2，显然当 c = 3 / 4 时，对于充分大的 n 可以满足 a <em> f(n / b) = 3 </em> (n / 4) <em> log(n / 4) &lt;= (3 / 4) </em> n <em> log n = c </em> f(n)，符合 Master 定理第三条，因此求得 T(n) = θ(n log n)。</p><p>​        运用 Master 定理的时候，有一点一定要<strong>特别注意</strong>，就是第一条和第三条中的ε必须<strong>大于零</strong>。如果无法找到大于零的ε，就不能使用这两条规则。</p><p>​        举个例子，T(n) = 2 T(n / 2) + n log n。可知 $n^{\log_b^a}=n$，而 f(n) = n log n，显然不满足 Master 定理第二条。但对于第一条和第三条，也无法找到大于零的ε使得 nlog⁡n=O$(n^{1−\varepsilon})$ 或者Ω$(n^{1−\varepsilon})$，因此不能用 Master 定理求解，只能寻求别的方式求解。比如可以利用递归树求出该算法的复杂度为 $T(n)=O(n\log^2n)$。简单的说一下计算过程：</p><p>​        递归树的建立过程，就像是模拟算法的递推过程。树根对应的是输入的规模为 n 的问题，在递归处理子问题之外，还需要 n log n 的处理时间。然后根据递推公式给根节点添加子节点，每个子节点对应一个子问题。这里需要两个子节点，每个节点处理规模为 n / 2 的问题，分别需要 (n / 2) <em> log(n / 2) 的时间。因此在第二层一共需要 n </em> (log n - 1) 的时间。第三层节点就是将第二层的两个节点继续分裂开，得到四个各需要 (n / 4) <em> log(n / 4) 时间的节点，总的时间消耗为 n </em> (log n - 2)。依此类推，第 k（设树根为 k = 0）层有 2 ^ k 的节点，总的时间为 n * (log n - k)。而且可以知道，这棵树总共有 log n 层（最后一层每个节点只处理规模为 1 的子问题，无须再分治）。最后将每一层消耗的时间累加起来，得到：</p><p><img src="image-20230127163854294.png" alt="image-20230127163854294"></p><h3 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h3><p>​        1）整体就很简单，就是一个简单的递归，左边排好序，右边排好序，然后整体就有序。</p><p>​        2）让其整体有序的方式用了排外序方法</p><p>​        3）继续使用master公式求解:$O(N\log N)$，空间复杂度O(N)</p><p>​        4）归并排序的实质</p><p>思路</p><p><img src="image-20230127164408704.png" alt="image-20230127164408704"></p><p>​        对于一块区域，我们使用指针访问：左右双指针法。开辟一块小空间，如果左边的大于右边的，左边指针拷贝同时指针后移一个，右边大于左边的同理。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Solution&#123;    public static void mergeSort(int[] arr)    &#123;        if(arr&#x3D;&#x3D;null||arr.length&lt;2)            return;        process(arr,0,arr.length-1);    &#125;    public static void process(int[] arr,int L, int R)    &#123;        if(L&#x3D;&#x3D;R)            return;      int mid &#x3D; left + ((right - left) &gt;&gt; 1);        process(arr,L,mid);        process(arr,mid+1,R);        merge(arr,L,mid,R);    &#125;    public static void merge(int[] arr,int L,int M,int R)&#123;        int[] helpSort&#x3D;new int[R-L+1];&#x2F;&#x2F;这是辅助空间        int i&#x3D;0;        int p1&#x3D;L;        int p2&#x3D;M+1;&#x2F;&#x2F;划分区域        while(p1&lt;&#x3D;M&amp;&amp;p2&lt;&#x3D;R)&#123;            helpSort[i++]&#x3D;arr[p1]&lt;&#x3D;arr[p2]?arr[p1++]:arr[p2++];            &#125;        while(p1&lt;&#x3D;M)&#123;           helpSort[i++]&#x3D;arr[p1++];        &#125;        while(p2&lt;&#x3D;R)&#123;            helpSort[i++]&#x3D;arr[p2++];        &#125;        for(i&#x3D;0;i&lt;helpSort.length;i++)&#123;            arr[L+i]&#x3D;helpSort[i];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std; void Merge(int arr[],int low,int mid,int high)&#123;    &#x2F;&#x2F;low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素    int i&#x3D;low,j&#x3D;mid+1,k&#x3D;0; &#x2F;&#x2F;mid+1为第2有序区第1个元素，j指向第1个元素    int *temp&#x3D;new(nothrow) int[high-low+1]; &#x2F;&#x2F;temp数组暂存合并的有序序列    if(!temp)&#123; &#x2F;&#x2F;内存分配失败        cout&lt;&lt;&quot;error&quot;;        return;    &#125;    while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;high)&#123;        if(arr[i]&lt;&#x3D;arr[j]) &#x2F;&#x2F;较小的先存入temp中            temp[k++]&#x3D;arr[i++];        else            temp[k++]&#x3D;arr[j++];    &#125;    while(i&lt;&#x3D;mid)&#x2F;&#x2F;若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中        temp[k++]&#x3D;arr[i++];    while(j&lt;&#x3D;high)&#x2F;&#x2F;同上        temp[k++]&#x3D;arr[j++];    for(i&#x3D;low,k&#x3D;0;i&lt;&#x3D;high;i++,k++)&#x2F;&#x2F;将排好序的存回arr中low到high这区间arr[i]&#x3D;temp[k];    delete []temp;&#x2F;&#x2F;删除指针，由于指向的是数组，必须用delete []&#125; &#x2F;&#x2F;用递归应用二路归并函数实现排序——分治法void MergeSort(int arr[],int low,int high)&#123;    if(low&lt;high)&#123;        int mid&#x3D;(low+high)&#x2F;2;        MergeSort(arr,low,mid);        MergeSort(arr,mid+1,high);        Merge(arr,low,mid,high);    &#125;&#125; int main()&#123;    int a[10]&#x3D;&#123;5,1,9,3,7,4,8,6,2,0&#125;;    MergeSort(a,0,9);    for(int i&#x3D;0;i&lt;10;i++)        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展我们的归并排序问题"><a href="#扩展我们的归并排序问题" class="headerlink" title="扩展我们的归并排序问题"></a>扩展我们的归并排序问题</h3><p>​        小和问题：对一个数组中，每个数左边比当前数小的数累加起来，叫做这个数的小和：请写一个程序：求解一个数组的小和。</p><p>Example:[1,3,4,2,5]产生的单个小和是[0,1,4,1,10],故数组的小和是16.</p><p>​        逆序问题：在一个数组中，左边的数如果比右边的数大，则这连哥哥数构成一个逆序对，请打印所有的逆序对。</p><p>​        （1）暴力解法是很简单的：对于位置i直接暴力遍历，但是$O(N^2)$</p><p>​        有没有更快的：有！</p><p>​        仔细思考一下：我们的小和可以这样产生！看一个数右边走，如果有别的数大于它就加一次这个数本身。如[1,3,4,2,5]：看1，右边四个数比他大，就加四次1，看3，右边两个数比他大，就加两个3，依次类推。。。</p><p>​        现在，我们对全数组进行二分。针对拆分后的数组一级一级使用我们新的求小和的过程，我们在比较的同时也排序：如：[1，3，4，2，5]下，拆分成2级[1,3,4]和[2,5]，然后又是:[1,3] [4]  和[2]  [5]最后是:[1] [3] [4] [2] [5]，现在返回去合并：[1,3]产生小和1，[1,3,4]产生1个1，1个3，（左侧小，左侧加小和，左侧移动指针到下一个，于是产生）[2,5]合并产生一个2，之后再次合并产生一个1，一个3，一个4，现在完事了：1+1+1+3+2+1+3+4=16</p><p>​        这个算法为什么是O(NlogN),就是因为排序的时候不需要在暴力遍历之后才知道有几个数比当前的数小。这才省略了新的遍历。</p><p>​        可能不一样的是：在这题里面，我们必须在左右数字相等的时候先拷贝右边的，再拷贝左边的.</p><p>​        （2）类似的，仍可以使用mergeSort，也就是说，只要产生小和操作就是说明产生了逆序。我们只要统计这个就好了</p><p>​        荷兰国旗问题：指定一个数，比他大的放右边，小的放左边，但是注意空间复杂度O(1)</p><p>​        思路：我们把使用两个指针。把小于num的放到左边，与小于区的下一个数字直接交换就好了。这样小于区右扩，否则指针直接右移。</p><p>​        荷兰国旗问题（2）：指定一个数，比他大的放右边，小的放左边，相等的放中间。但是注意空间复杂度O(1)</p><p>​        </p><p>​        还是类似，只不过有趣的是我们可以：</p><p>​        小于：[i]和小于区域的下一个交换，小于区东扩</p><p>​        相等：直接++</p><p>​        大于：[i]和大于区域的上一个交换，大于区西扩，但是i不动（我们还没排序那个交换过来的数嘞！）。</p><p>看看代码实现（看2就好了）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void swap(int* e1, int* e2)&#123;int temp &#x3D; *e1;*e1 &#x3D; *e2;*e2 &#x3D; temp;&#125;typedef struct Pair_ &#123;int pair1;int pair2;&#125;Pair;void arrangeArray(Pair* pair, int* arr, int arrsize,int sortnum)&#123;if (!pair &amp;&amp; !arr)return;if (arrsize &lt; 0)return;int* smaller &#x3D; &amp;arr[-1];int* bigger &#x3D; &amp;arr[10];int* check &#x3D; arr;while (check &lt; bigger)&#123;if (*check &lt; sortnum)&#123;swap(check, smaller + 1);check++;smaller++;&#125;else if (*check &#x3D;&#x3D; sortnum)&#123;check++;&#125;else&#123;swap(check, bigger - 1);bigger--;&#125;&#125;pair-&gt;pair1 &#x3D; smaller - arr;pair-&gt;pair2 &#x3D; bigger - arr;&#125;void PrintArr(int* arr, int arr_size)&#123;for (int i &#x3D; 0; i &lt; arr_size; i++)&#123;printf(&quot;%d &quot;, arr[i]);&#125;printf(&quot;\n&quot;);&#125;int main()&#123;int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;PrintArr(arr, 10);Pair* p&#x3D;(Pair*)malloc(sizeof(Pair));p-&gt;pair1 &#x3D; 0;p-&gt;pair2 &#x3D; 0;arrangeArray(p, arr, 10, 5);PrintArr(arr, 10);printf(&quot;%d\n&quot;, arr[p-&gt;pair1]);printf(&quot;%d\n&quot;, arr[p-&gt;pair2]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        C++:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;class Array &#123;public:void initVal(int* arr, int size) &#123;int* arrayData &#x3D; new int[size];for (int i &#x3D; 0; i &lt; size; i++)&#123;arrayData[i] &#x3D; arr[i];&#125;arraydata &#x3D; arrayData;arraysize &#x3D; size;&#125;void swapPartialData(int swap1,int swap2)&#123;int temp &#x3D; arraydata[swap1];arraydata[swap1] &#x3D; arraydata[swap2];arraydata[swap2] &#x3D; temp;&#125;void arrangeandSort(int sortnum)&#123;int smaller &#x3D; -1;int bigger &#x3D; arraysize;int check &#x3D; 0;while (check &lt; bigger)&#123;if (arraydata[check] &lt; sortnum)&#123;swapPartialData(check, smaller + 1);check++;smaller++;&#125;else if (arraydata[check] &#x3D;&#x3D; sortnum)&#123;check++;&#125;else&#123;swapPartialData(check, bigger - 1);bigger--;&#125;&#125;&#125;void PrintVal()&#123;for (int i &#x3D; 0; i &lt; arraysize; i++)&#123;std::cout &lt;&lt; arraydata[i] &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl;&#125;private:int* arraydata;int arraysize;&#125;;int main()&#123;int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;Array a;a.initVal(arr, 10);a.PrintVal();a.arrangeandSort(5);a.PrintVal();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>​        快速排序请先把上面的代码琢磨明白：快速排序使得我们以一个数区分好了左右，排除掉标杆数我们只要对左右再次区分直到一个尽头结束。这次我们直接拿最后一个数当作标杆进行快排，这样我们就使得整个数组有序了。</p><p>​        这个思想还可以进一步优化：直接把标杆数（最后一个）直接放到中间，左右再递归。</p><p>​        当然，这个时间复杂度很不稳定：当划分值再中间的时候：</p><script type="math/tex; mode=display">T(n)=2T(\frac{T}{2})+O(N)</script><p>​        但是如果划分值再最左边和最右边：则就是经典排序为O($N^2$)。</p><p>​        我们继续改进：如果我们在一个划分区域随机选一个数，是不是就更多的避免了总是遇到最差情况？是的，这就是随机快速排序。这下，我们就可以</p><p><img src="image-20230130193038830.png" alt="image-20230130193038830"></p><p>​        对所有的情况求时间期望:$O(N\log N)$</p><h3 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h3><p>​        堆在逻辑结构上是一个完全二叉树。也就是说，每个非叶子节点必有左节点。怎么实现呢？我们可以将天然的一维数组视作一棵完全二叉树。</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230131092857709.png" alt="image-20230131092857709"></p><p>我们可以使用这个公式快速找到左孩子的节点下标：(i是当前节点的下标)</p><script type="math/tex; mode=display">I_{left}=2i+1</script><p>类似的：</p><script type="math/tex; mode=display">I_{right}=2i+2</script><p>父节点：</p><script type="math/tex; mode=display">I_{father}=\frac{i-1}{2}</script><p>完全二叉树的高度也可以求解：</p><script type="math/tex; mode=display">H=logN+1</script><p>堆在这个概念上派生：他是一个特殊的完全二叉树。大根堆中其父节点总是大于子节点，比如说</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230131093338557.png" alt="image-20230131093338557"></p><p>类比的：小根堆就是父节点总是小于子节点。怎么创建一个堆呢？</p><p>​        假设：我们有一个干净的数组，现在往数组里放数。现在，标记一下一个heapsize:他描述我们现在已经成型的堆的大小。显然刚开始heapsize一定是0！因为压根数没来呢！随着数进来，如果一个数比父节点大，那就准备交换父节点！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">swap(arr[i],arr[(i-1)&#x2F;2]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果作为上一级的子节点还是比父节点大，那不就是又要交换？是的。这就是一个递归算法。但是如果相等呢？没关系，就停在那里就好了！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//不用担心0位置的问题，因为根节点的父节点还是他自己，取等依旧跳出循环</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">></span>add<span class="token punctuation">[</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>index<span class="token punctuation">,</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        index<span class="token operator">=</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><p>​        这下很容易了：arr[0]就是我们的最大值，返回出去就好了。那如果我们要把它抹掉，然后还是一个大根堆。这又如何？很简单，与最后一个数交换，或者是被覆盖。然后heapsize—.然后，我们让父节点和子节点比较。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index，<span class="token keyword">int</span> heapsize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//得到左孩子下标</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> index<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//一旦left&lt;heapsize那显然我们的当前节点就没有孩子节点了</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>heapsize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//比较两个孩子节点谁大，把大的那个下标给largest</span>        <span class="token keyword">int</span> largest<span class="token operator">=</span>            <span class="token comment">//万一没右孩子嘞？判断一下！</span>            left<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>heapsize            <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            <span class="token operator">?</span> left<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">:</span> left <span class="token punctuation">;</span>        <span class="token comment">//父亲和孩子之间谁大？谁大把谁的下表交给largest</span>        largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>        <span class="token comment">//如果到位了，退出循环！</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span> largest<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//反之，交换，继续跑路</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>largest<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        index<span class="token operator">=</span>largest<span class="token punctuation">;</span>        left <span class="token operator">=</span> index<span class="token operator">*</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        OK，现在我们的用户又抽风了，现在它随即指定一个节点变成?，那怎么怎么让他成为一个新的堆？很简单！如果变大了，只能往上走，就像上heapify,变小了那就是向下走。</p><p>​        算法复杂度如何？我们发现他就是遍历了树的高度：也就是说</p><script type="math/tex; mode=display">T(N)=O(\log N)</script><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>​        现在我们拿到一个数组，想要进行堆排序，就首先需要构建堆。使用heapInsert就好了。然后怎么排序？我们想到，heap总是确定最大值，只需要：最大值和最后一个值交换，在heapsize—再堆排序。这是一个逐步弹出最大值的算法排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Array</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> heapsize<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">--</span>heapsize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>heapSize<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">--</span>heapsize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            这个算法：空间复杂度:O(1) 时间复杂度: O(nlogn)</p><p>下面是C++版本：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Array &#123;public:void Updatearray(int* arr, int size) &#123;int* trans &#x3D; new int[size];for (int i &#x3D; 0; i &lt; size; i++) &#123;trans[i] &#x3D; arr[i];&#125;this-&gt;array &#x3D; trans;this-&gt;arraysize &#x3D; size;&#125;void swap(int i1, int i2) &#123;int temp &#x3D; array[i1];array[i1] &#x3D; array[i2];array[i2] &#x3D; temp;&#125;int* getArrayDataPointer() &#123;return this-&gt;array;&#125;int getsize()&#123;return this-&gt;arraysize;&#125;void printArray() &#123;for (int i &#x3D; 0; i &lt; arraysize; i++)&#123;std::cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl;&#125;private:int* array;int arraysize;&#125;;class heapSort &#123;public:void heapInsert(Array a, int index) &#123;while (            a.getArrayDataPointer()[index]             &gt;             a.getArrayDataPointer()[(index - 1) &#x2F; 2]              )         &#123;a.swap(index, (index - 1) &#x2F; 2);index &#x3D; (index - 1) &#x2F; 2;&#125;&#125;void heapify(Array a, int index, int heapsize) &#123;int left &#x3D; 2 * index + 1;while (left &lt; heapsize) &#123;int largest &#x3D;left + 1 &lt; heapsize&amp;&amp;a.getArrayDataPointer()[left + 1] &gt; a.getArrayDataPointer()[left]? left + 1 : left;largest &#x3D; a.getArrayDataPointer()[largest] &gt; a.getArrayDataPointer()[index] ? largest : index;if (index &#x3D;&#x3D; largest)&#123;break;&#125;a.swap(largest, index);index &#x3D; largest;left &#x3D; index * 2 + 1;&#125;&#125;void heapsort(Array a) &#123;if (a.getArrayDataPointer() &#x3D;&#x3D; NULL || a.getsize() &lt; 2)&#123;return;&#125;for (int i &#x3D; 0; i &lt; a.getsize(); i++)heapInsert(a, i);int heapsize &#x3D; a.getsize();a.swap(0, --heapsize);while (heapsize &gt; 0) &#123;heapify(a, 0, heapsize);a.swap(0, --heapsize);&#125;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于几乎排好序的（向我保证在-K~K内有序）数组，我们可以使用小根堆来排序，把小数往前弹就可以了。</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>​        这个算法跟之前的不一样，之前的算法都是基于比较的排序算法，现在介绍一个更逆天的算法：计数排序。这个算法的局限性极大：就是必须为整形，同时空间复杂度为O(N)，这样，我们得知了一个数据范围[K1,K2]，我们创造一个大小为[k2-k1+1]的数组，遇到一个数就在这个数对应的位置上+1，使用位置来衡量这个值的大小。随后，根据值来覆写数组。比如说统计到1的个数10，那就在数组里写10个1.但是，一旦数据量大起来就是寄！</p><p>​        现在，引入一个全新的算法：基数算法：我们首先确定数据的最大几位，对其他数字补齐0操作：如[72,100]-&gt;[072,100]就好了。然后基于个位数，创造10个桶。个位数是0的去0，1去1.。。以此类推，然后，从小到大导倒出来，随后比十位，再百位。。。以此类推</p><p>​        比如说：[17,13,25,100,72]-&gt;[ 017 , 013 , 025 , 100 , 072 ],然后个位入桶。再导出来</p><p><img src="image-20230131115105002.png" alt="image-20230131115105002"></p><p>然后把这个数组再倒入桶，这次按十位数</p><p><img src="image-20230131115241365.png" alt="image-20230131115241365"></p><p>然后把这个数组再倒入桶，这次按百位数</p><p><img src="image-20230131115325430.png" alt="image-20230131115325430"></p><p>倒出来，排好序了</p><p><img src="image-20230131115343881.png" alt="image-20230131115343881"></p><p>本质上，我们是按照位数排序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> _RadixSort<span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token function">radixsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">maxbits</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>       <span class="token comment">//这个函数的本质是求解digit 表示最大的数有几个十进制位数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">maxbits</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> max<span class="token operator">=</span><span class="token class-name">Interger</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            max<span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>max<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            max<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">//digit 表示最大的数有几个十进制位数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">,</span><span class="token keyword">int</span> digit<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> radix<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//准备空间</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>d<span class="token operator">&lt;=</span>digit<span class="token punctuation">;</span>d<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token comment">//有多少位就进出多少次，从个位起步</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count <span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>radix<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//这个代码统计数字频率，改进后则是统计小于等于该位置数的个数</span>             <span class="token comment">//这个count[i]表示小于等于i有count[i]个，数组代替了队列使得我们保证了后进后出</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token class-name">L</span><span class="token punctuation">,</span>i<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                j<span class="token operator">=</span><span class="token function">getDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>                count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>radix<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//改进count</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>count<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token class-name">L</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//取出位数</span>            j<span class="token operator">=</span><span class="token function">getDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//放到辅助数组</span>             bucket<span class="token punctuation">[</span>count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">//我们放置一个,就在频数上减一</span>            count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//出桶</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token class-name">L</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">/</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>d<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Pycharm</title>
      <link href="/2023/01/29/Opencv-in-Pycharm/"/>
      <url>/2023/01/29/Opencv-in-Pycharm/</url>
      
        <content type="html"><![CDATA[<h1 id="Pycharm下的opencv使用1：基本图像操作导论"><a href="#Pycharm下的opencv使用1：基本图像操作导论" class="headerlink" title="Pycharm下的opencv使用1：基本图像操作导论"></a>Pycharm下的opencv使用1：基本图像操作导论</h1><h3 id="在Pycharm中导入opencv"><a href="#在Pycharm中导入opencv" class="headerlink" title="在Pycharm中导入opencv"></a>在Pycharm中导入opencv</h3><p>​        笔者被C++实现的opencv干到心态炸裂了，所以这里先整一篇基于python的opencv的博客。</p><p>​        在pycharm中导入opencv很容易：只需要在Project的setting里给解释器安装上opencv-python库就好了。使用这个程序跑一下看看可不可以读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#向工程文件下新建一个img文件夹,放好你的图片，我这里放的是test.png</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230129194508512.png" alt="image-20230129194508512"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2img_path<span class="token operator">=</span><span class="token string">"img/test.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Test img can be shown below!"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        跳出这个即为成功！开始你的opencv的欢乐时间！</p><p><img src="image-20230129194919800.png" alt="image-20230129194919800"></p><h3 id="计算机眼中的图片"><a href="#计算机眼中的图片" class="headerlink" title="计算机眼中的图片"></a>计算机眼中的图片</h3><p>​        在计算机眼中，图像由矩阵构成</p><p><img src="image-20230115212443109.png" alt="image-20230115212443109"></p><p>​        </p><p>​        数值的大小表明了图像的亮度，而通道表明了一个颜色：一个R通道上的255表明这是在Red上很亮</p><p>​        下面，我们来介绍一下我们应该怎么读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment">#不同于RGB，我们读取的格式是BGR</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#caution:the input should be the addr of the img</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取的结果是：一个nd array</p><p>好抽象：可不可以直接展示图片啊：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们试一下这个：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> showimg <span class="token keyword">as</span> simg<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'1.png'</span><span class="token punctuation">)</span>simg<span class="token punctuation">.</span>imgshow<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以封装一个函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cv_show</span><span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span>     cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以查看一个图片的大小：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>shape<span class="token comment">#(175, 286, 3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以设置读入的方式：比如说读入灰度图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span>，cv2<span class="token punctuation">.</span>IMREAD_GREYSCALE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存我们产出的图像</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">'savedfilename'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 可以计算像素点的个数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>​        视频由图像组成，也就是说，我们可以读取视频：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">vc<span class="token operator">=</span>cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">'videofilepath'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们是不是读取成功了？这个看如下的代码判断：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> vc<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">open</span><span class="token punctuation">.</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token builtin">open</span><span class="token operator">=</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们来运行的读取视频</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> <span class="token builtin">open</span><span class="token punctuation">:</span>ret<span class="token punctuation">,</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> frame <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">if</span> ret<span class="token operator">==</span><span class="token boolean">True</span><span class="token punctuation">:</span>        gray<span class="token operator">=</span>cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>frame<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">,</span>gray<span class="token punctuation">)</span>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token operator">==</span><span class="token number">27</span><span class="token punctuation">:</span><span class="token comment">#按下ESC退出或者视频播放完毕</span>            <span class="token keyword">break</span>vc<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="截取部分图片（ROI）"><a href="#截取部分图片（ROI）" class="headerlink" title="截取部分图片（ROI）"></a>截取部分图片（ROI）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imgread<span class="token punctuation">(</span><span class="token string">'Path'</span><span class="token punctuation">)</span>cat<span class="token operator">=</span>img<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">]</span>cv_show<span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span>cat<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样我们就利用切片截取了部分图片了.</p><h3 id="颜色通道提取"><a href="#颜色通道提取" class="headerlink" title="颜色通道提取"></a>颜色通道提取</h3><p>我们可以分离图片，通过不同的颜色通道提取：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token operator">=</span>cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是效果：1，2，3分别代表b,g,r</p><p><img src="2.png" alt="2"> </p><p>1:</p><p><img src="b.png" alt="b"></p><p>2:</p><p><img src="g.png" alt="g"></p><p>3:<img src="r.png" alt="r"></p><p>当然也可以合回去：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以单独保留，直接修改：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#只保留R</span>cur_img<span class="token operator">=</span>img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span>cur_img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><p>我们可以扩充图像，通过一些方式来对图像进行扩充：请看这里：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token comment">#定位点</span>replicate<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REPLICATE<span class="token punctuation">)</span>reflect<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT<span class="token punctuation">)</span>reflect101<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT_101<span class="token punctuation">)</span>wrap<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_WRAP<span class="token punctuation">)</span>constant<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span>value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们得到了五张图像，随后，我们使用imwrite输出图像，同时导入matplotlib的pyplot子库进行观察：</p><p>​        这是总的效果：</p><p><img src="matplot_version.png" alt="matplot_version"></p><p>​         仔细观察：</p><p><img src="replicate.png" alt="replicate"></p><p><img src="reflect.png" alt="reflect"></p><p><img src="reflect101.png" alt="reflect101"></p><p><img src="wrap.png" alt="wrap"></p><p><img src="constant.png" alt="constant"></p><p>​        第一张图是展示了</p><p>​        replicate：这个单词是复制的意思：直接复制最边缘的像素</p><p>​        reflect：对感兴趣的部分进行两边复制：fedcba|abcdef|fedcba</p><p>​        reflect101:但是是对最边缘的像素为对称轴进行复制:gfedcba|abcdefgh|gfedcba</p><p>​        wrap:外包装：cdefgh|abcdefgh|abcdefg</p><p>​        constant:对图像以默认黑值填充</p><h3 id="对图像进行数值操作"><a href="#对图像进行数值操作" class="headerlink" title="对图像进行数值操作"></a>对图像进行数值操作</h3><p>​        我们可以对numpy进广播操作。人话翻译成C++就是cv2库重载了运算符号，使之我们可以对矩阵进行广义的加法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'cat.jpg'</span><span class="token punctuation">)</span>img_cat_GeneralAdd<span class="token operator">=</span>img_cat<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>img_cat<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>img_cat2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        在控制台上输出就可以发现矩阵里每一个数值都加上了一个10。</p><p><img src="image-20230129191422226.png" alt="image-20230129191422226"></p><p>​        （懒得自己跑，截个图）</p><p>​        那可不可以狭义相加呢？当然可以，结合线性代数的常识，相加的矩阵必须满足大小完全一致。假设我们已经满足了这个前提，直接相加得到的结果是不是就是放到矩阵的值呢？</p><p>​        显然不是！因为RGB有界，不可以超过255.在重载的+中，矩阵的RGB值自动%256，就是除以2256取它的余数放到矩阵里。那还有别的加法吗？有：使用方法add，传入cv2.add(img_cat,img_cat2)就可以了，达到255之后就不会取模，只会停在255不动</p><h3 id="图像叠加"><a href="#图像叠加" class="headerlink" title="图像叠加"></a>图像叠加</h3><p>​        我们也可以对图像进行叠加。但是注意，我们首先要调整图像大小一致：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token punctuation">.</span>shapeimg_dog<span class="token operator">=</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token comment"># path是路径</span>img_dog<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_dog<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token operator">*</span>size required to resize<span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230129192417117.png" alt="image-20230129192417117"></p><p>​        同样的还有其他resize方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">required_pic<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_required_resize<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>fx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>fy<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是个什么玩意呢？指的是我们依照某个点把图像在X轴上拉长3倍数，Y轴不变。</p><p>​        现在，我们使用addWeighted来叠加图像，以混合图片特征。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res<span class="token operator">=</span>cv2<span class="token punctuation">.</span>addWeighted<span class="token punctuation">(</span>img_cat<span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">,</span>img_dog<span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#img_cat*0.4+img_dog*0.6+0//最后一项是亮度提升</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h3><p>​        我们可以使用一些参数，对图像进行有条件的处理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ret<span class="token punctuation">,</span>dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>src<span class="token punctuation">,</span>thresh<span class="token punctuation">,</span>maxval<span class="token punctuation">,</span><span class="token builtin">type</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>src:输入，只能输入单通道图像，通常是灰度图</p><p>dst：输出图</p><p>thresh:执行阈值</p><p>maxval:超过或小于阈值后所赋予的值</p><p>type:方法，如下：</p><p>1.cv2.THRESH_BINARY：超过阈值的取maxval,否则取0</p><p>2.cv2.THRESH_BINARY_INV反过来</p><p>3.THRESH_TRUNC大于阈值的设置成阈值</p><p>4.THRESH_TOZERO大于阈值的不变，否则设置成0</p><p>5.THRESH_TOZERO_INV反转</p><p>我们依旧使用matplotlib的pyplot库放送一下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'2.png'</span><span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY_INV<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh3<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TRUNC<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh4<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh5<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO_INV<span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original Image'</span><span class="token punctuation">,</span><span class="token string">'BINARY'</span><span class="token punctuation">,</span><span class="token string">'BINARY_INV'</span><span class="token punctuation">,</span><span class="token string">'THRESH_TRUNC'</span><span class="token punctuation">,</span><span class="token string">'TOZERO'</span><span class="token punctuation">,</span><span class="token string">'TOZERO_INV'</span><span class="token punctuation">]</span>images<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>thresh1<span class="token punctuation">,</span>thresh2<span class="token punctuation">,</span>thresh3<span class="token punctuation">,</span>thresh4<span class="token punctuation">,</span>thresh5<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看：</p><p><img src="Figure_1.png" alt="Figure_1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（1）</title>
      <link href="/2023/01/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学教程笔记1"><a href="#高等数学教程笔记1" class="headerlink" title="高等数学教程笔记1"></a>高等数学教程笔记1</h1><h2 id="极限运算与函数分析基础"><a href="#极限运算与函数分析基础" class="headerlink" title="极限运算与函数分析基础"></a>极限运算与函数分析基础</h2><h4 id="函数与极限"><a href="#函数与极限" class="headerlink" title="函数与极限"></a>函数与极限</h4><p>函数部分主要是奠基于高中的一些基础，这里做一些简单的复习</p><p>1.映射与函数</p><p>首先来了解以下映射：4</p><p>​        先定义X，Y是两个非空集合。现在有一个法则f，使得X中的每个元素$x$（$X$={$x_0$,$x_1$,$x_2$,…}）,都有<strong>唯一</strong>的y($Y$={$y_0$,$y_1$,$y_2$,$y_3$,…})与之对应。那么，我们称f是一个<strong>映射</strong>。</p><p>​        也就是说，这个定义是围绕f的。他是一个这样的法则（或者说规则）让两个非空的集合建立起如定义所言的联系，仅此而已。</p><p>​        也不必太过担心，映射在这本笔记里大概不会再次出现了。</p><p>不过，我们把它引出来必有我们的目的：回过头来，我们实际上用一大长串定义干了这样一件事：</p><script type="math/tex; mode=display">{X}\xrightarrow{f}Y</script><p>现在，让我们开始取其名字：</p><p>X：是一个定义域，有写法D,或者写法更明确一些：$D_f$</p><p>实际上这是Domain的意思</p><p>Y：是一个值域，有写法R,或者同样更明确一些：$R_f$</p><p>实际上这是Range的意思。</p><p>至于：f，我们刚刚讲过了，这就是一个法则，表明一种对应关系。</p><p>依然有这样的更简单的写法：</p><script type="math/tex; mode=display">X\xrightarrow{f}R_f</script><p>重复一些以下的要点：</p><p>（1）上述定义阐述了三要素：X（定义域），f(法则)，Rf(对应值域)</p><p>（2）对于x属于X这回事，对应的y是唯一的。不可以又对应y1同时对应y2.</p><p>Q:可以多个x对应一个y吗？可以！事实上，用图片表示是这样的：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221226141035208.png" alt="image-20221226141035208"></p><p>（3）Rf属于Y，但不是Y！！！但特别的：当Rf=Y下，我们又称这样厉害的f叫满射。</p><p>（4）在众多的映射中，还有一种特殊的映射：单射。人话就是一一对应</p><p>（5）那么，又是单射又是满射如何？这又有名字：一一映射（一夫一妻）因为必须全部对应且一一对应。</p><p>正过来叫映射，倒过来又如何？</p><p>设 f有如下关系：</p><script type="math/tex; mode=display">X\longrightarrow{Y}</script><p>是一个单射，那么，我们可以倒过来：对于Y属于Rf而言都有唯一的一个$x$属于$X$.这又是一组对应关系，不过是倒过来的。记作如下：</p><script type="math/tex; mode=display">g:R_f\longrightarrow{X}</script><p>这样看不出什么联系，我们采用与 f 相关的表示：</p><script type="math/tex; mode=display">f^-1:D_{f^-1}\longrightarrow{D_f}</script><p>好吧，太复杂了，好好回味一下，我们继续折磨：</p><p>现在我们来看这样一个内容：</p><p>在学习完映射之后，我们来看这样的一个D(定义域),且</p><script type="math/tex; mode=display">D\subset{R}</script><p>换而言之，这个数集是R里的一部分，而f是一个使得：</p><script type="math/tex; mode=display">f:D\longrightarrow{R}</script><p>的映射。</p><p>那么，这样来看我们构造了一个映射使得一个实数集映射到了另一个实数集上。这样的映射有一个大家熟悉的名字：函数，简记作：</p><script type="math/tex; mode=display">y=f(x),x\in{D}</script><p>这下看懂了：</p><p>x是一个自变量，y是一个因变量 ，定义域为D，值域是R（不是实数集的R！！！）</p><p>构成一个函数的两要素，就可以从动态的角度来看了，这使得我们信息的表达可以更为浓缩：$D_f$ ,$ f$ 就可以了</p><p>函数的表达有三种：表格法，图形法，解析法。这个是大家高中就已经熟知的了</p><p>说完了定义和表示，我们来看一个函数最广泛的几个性质：</p><h4 id="1-有界性"><a href="#1-有界性" class="headerlink" title="1.有界性"></a>1.有界性</h4><p>听名字就知道：表明的是一些函数可能是有界限的。但这样的表达不规范。</p><p>仔细思考，函数的界限分为两种：不大于一个数和不小于一个数（当然，也可以说是小于一个数或者是大于一个数）</p><p>那么，我们说：对于总是一个小于一个数或者是不大于一个数的函数，我们说他有上界。表达是这样的：</p><script type="math/tex; mode=display">\exists{k_1},f(x)\leqslant{k_1}</script><p>这是什么东西呢？先别急，它还有另一个符号，也是在数学中相当常见的：$\exists$ , $\forall$</p><p>上面的两个符号，一个表示：存在；另一个表示任意。</p><p>那么，上界是唯一的吗？不是的。比如说：</p><script type="math/tex; mode=display">f(x)=x , x\in{(-\infty,1]}</script><p>这就有无穷个上界：可以是1，可以是2，可以是$\pi$…总而言之，并不唯一。</p><p>那么与之对应的，还会有一个下界：</p><script type="math/tex; mode=display">\exists{k_2} ,f(x)\geqslant{k_2}</script><p>我们说：对于总是一个大于一个数或者是不小于一个数的函数，我们说他有下界。</p><p>同样的，下界也不唯一。</p><p>这在我们后面证明极限的存在时是很有必要的！！！</p><p>统称起来，我们就可以说：函数是有界的：上下界都有！总而言之，这种情况称为有界的。反之，一个函数若是既没有上界有没有下界，或者是只有上界，或者是只有下界，则称这个函数无界。用数学符号定义有界是这样的：</p><script type="math/tex; mode=display">\exists M>0,|f(x)|\leqslant{M}</script><p>那么，无界的是这样定义的：</p><script type="math/tex; mode=display">\forall{M}>0,\exists x_1\in{x},|f(x)|>M</script><h4 id="2-单调性"><a href="#2-单调性" class="headerlink" title="2.单调性"></a>2.单调性</h4><p>这个性质是讨论函数的变化趋势的：是增加还是减少？我们用这个性质衡量：</p><p>当在一个区间里：</p><script type="math/tex; mode=display">x_1<x_2,f(x_1)<f(x_2)</script><p>这样的性质叫单调递增，</p><p>反之：</p><script type="math/tex; mode=display">x_1 < x_2,f( x_1 )>f( x_2 )</script><p>这样的性质叫单调递减，但是注意，这称之为严格单调，后面我们会讲述什么是严格单调什么是广义单调的。</p><h4 id="3-奇偶性"><a href="#3-奇偶性" class="headerlink" title="3.奇偶性"></a>3.奇偶性</h4><p>首先声明一点：我们的函数的定义域必须对称：也就是说：函数的$D_f$必须关于原点对称：</p><p>实数域$R$是对称的，$[-1,1]$是对称的，以此类推。当：$f(x)=f(-x)$时，我们称呼这样的函数是一个偶函数，反之：$f(-x)=-f(x)$或者$-f(-x)=f(x)$ 则称之为奇函数。</p><p>有趣的是：在图像法表达函数时：奇函数关于原点对称，偶函数关于$y$轴对称。</p><h4 id="4-周期性"><a href="#4-周期性" class="headerlink" title="4.周期性"></a>4.周期性</h4><p>有一些函数很有意思，伴随$x$的增大，我们甚至可以看到$f(x)$会有周期的重现。这时候，我们说这个函数具有周期性，用数学语言的表达是如下的：</p><script type="math/tex; mode=display">\exists l>0 , f(x+l)=f(x)</script><p>这个$l$就是周期，同时，我们讨论的周期常常是最小正周期。</p><p>比如说：</p><script type="math/tex; mode=display">y=\sin(x)</script><p>这个函数的（最小正）周期就是2$\pi$。</p><p>但是，不是所有的函数都有最小的正周期。如</p><script type="math/tex; mode=display">D(x)=\begin{cases}1 &  x\in{Q}\\ 0 & x\in{Q^C} \\\end{cases}</script><h4 id="5-反函数"><a href="#5-反函数" class="headerlink" title="5.反函数"></a>5.反函数</h4><p>有点像逆映射的感觉了：</p><p>设$f:D\rightarrow{f(D)}$是一个单射，且$f$单调 则有$f^-1:f(D)\rightarrow{D}$ ，且$f^-1$单调，单调性跟 $f$一致</p><p>那么称$x=f^-1(y)$ 是$y=f(x)$的反函数，且这两个函数的图像是关于$y=x$对称的</p><h4 id="6-复合函数"><a href="#6-复合函数" class="headerlink" title="6.复合函数"></a>6.复合函数</h4><p>引入两个函数：$y=f(t) , t=g(x)$ ,把$t$换成$g(x)$，我们就得到了一个复合函数$f(g(x))$。</p><p>值得注意的是：我们如此操作是把 $t =g(x)$视作了一个自变量， $t$的取值范围（f(x)的自变量范围）由我们的$g(x)$决定了，这就是$g(x)$的值域决定了$f(x)$的定义域， 于是，复合函数想要有定义，其$g(x)$的值域必须在$f(x)$的定义域内部才可以。</p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>下面引入两个函数：$f(x),g(x)$ 其中：其定义域以次为$D_f,D_g$ ，产生的新函数的定义域为$D=D_f\cap{D_g}$</p><p>函数的和差：</p><script type="math/tex; mode=display">(f\pm{g})(x)=f(x)\pm{g(x)}</script><p>函数的乘积：</p><script type="math/tex; mode=display">(f\cdot{g})(x)=f(x)\cdot{g(x)}</script><p>函数的相除：</p><script type="math/tex; mode=display">(\frac{f}{g})(x)=\frac{f(x)}{g(x)}, g(x)\neq0</script><h4 id="常见的初等函数"><a href="#常见的初等函数" class="headerlink" title="常见的初等函数"></a>常见的初等函数</h4><p>幂函数：$y=a^{\mu}$</p><p>指数函数:$y=a^x$</p><p>对数函数$y=log_a{x}$, 当$a=e$时，记作：$y=e^x$</p><p>特别的：当$a=e$时，又记成$y=\ln(x)$，当$a=10$时，又记成 $y=\lg(x)$.</p><p>三角函数：$\sin(x)$</p><p>反三角函数:$\arcsin(x)$</p><p>所有的这些函数经过有限次数的组合，运算得到的函数都是初等函数。</p><h2 id="极限定义与使用"><a href="#极限定义与使用" class="headerlink" title="极限定义与使用"></a>极限定义与使用</h2><h4 id="数列的极限的定义"><a href="#数列的极限的定义" class="headerlink" title="数列的极限的定义"></a>数列的极限的定义</h4><p>​            数列可以简单的理解为一列数：按照一定的规律排放：{$x_1,x_2,x_3,x_4,x_5…$}，我们简记作：$\{x_n\}$（注意到N是无穷大的）,比如说：</p><p>​                                                        $\{\frac{1}{2^n}\}$:$\{\frac{1}{2},\frac{1}{4},\frac{1}{8},\frac{1}{16}…\}$</p><p>其中，我们单取出来一项：这是数列的一个项。对于$\frac{1}{2^n}$这个东西，则我们叫做一般项：因为我们可以通过带入N的值来求得第N项的值来。</p><p>​        再来看一些数列：</p><p>​                                            $\{\frac{1}{n}\}$:{1,$\frac{1}{2},\frac{1}{3},\frac{1}{4},\frac{1}{5},\frac{1}{6},\frac{1}{7}$…}</p><p>​        这些数列似乎都随着N的增大逼近一个数，比如说，上面的这些数列都在$N\rightarrow\infty$下，{$x_n$}都在逼近一个数，比如和上面两个都在向0逼近。</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221227094255924.png" alt="image-20221227094255924"></p><p>​        这是$\{\frac{1}{n}\}$在数轴上的表示：当N越来越大下，数代表的点越来越靠近0代表的点。</p><p>我们称数列随着$N\rightarrow\infty$下，逼近的那一个数称之为这个数列的极限。</p><p>​        大概如此，所以我们来看看数学分析下定义的极限：</p><p>​        定义：$\{x_n\}$作为一个数列，$\forall \varepsilon&gt;0$，总$\exists{N},$当$n&gt;N$下，$|x_n-a|&lt;\varepsilon$</p><p>​        好吧，看一脸懵逼。那这个是什么意思呢？为什么引出这个抽象的定义？</p><p>​        注意到：$\forall \varepsilon&gt;0$ :这个是表明任意的一个$ \varepsilon$，只要它大于0都算，都要让上面的式子成立。</p><p>​        这就是说，我的$ \varepsilon$可以取得任意的小，多小都得行！，而$\exists{N},$表明了存在数列的一个项：使得在之后的项（这在$n&gt;N$已经说明白了）都与一个数a的差的绝对值（嘛，就是之后的项与这个数a的距离）为任意小。还不是相等，是一个动态的过程，因为如同</p><p>$\{\frac{1}{n}\}$中$n=10000000000000$一样，只是$x_n=\frac{1}{10000000000000}$罢了，但绝对不是0！但是，伴随这N取的越来越大，我们的{$x_n$}会越来越逼近0的。这描述的是一个动态的过程。</p><p>下面我们来引入一道经典例题：</p><p>​                                                            $2,\frac{1}{2},\frac{4}{3},\frac{3}{4}…\frac{n+(-1)^{n-1}}{n}$</p><p>​        这个数列的极限如何？</p><p>​        首先分析以下大通项：$\frac{n+(-1)^{n-1}}{n}$，它可以做出分离：$1+\frac{(-1)^{n-1}}{n}$ 注意到$(-1)^{n-1}$是一个震荡的数，在-1与1之间震荡，如果看作是一个函数的话，他是有界的，而$\frac{1}{n}$或者是$-\frac{1}{n}$无论如何都会随N增大而趋向于0.那么，这个数列的极限很明了了：</p><p>​    那我们使用数列的极限来证明：</p><p>​    $证明：$</p><p>​    $    因为 |x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}$</p><p>​    $于是\forall \varepsilon&gt;0,取{N=[\frac{1}{n}]+1}, 此时|x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}&lt;\varepsilon$</p><p>​    于是数列的极限是1.</p><p>​    我们再来看一个例题：</p><p>​    证明：$x_n=\frac{(-1)^n}{(n+1)^2}$的极限是0：</p><p>​    这是好说的：我们照猫画虎：</p><p>​    $证明：$</p><p>​    $    因为：|x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}$</p><p>​    $于是\forall \varepsilon&gt;0，取N=[\frac{1}{\sqrt{ \varepsilon}}]+1,此时有 |x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}&lt;\varepsilon$</p><p>​    于是数列的极限为0.</p><p>​    收敛数列的性质：</p><p>​    我们讨论一个收敛数列，是要关注他有什么特性的：</p><p>​    显然：</p><p>（1）收敛数列的极限唯一。</p><p>​    不太好证，所以我们来引入反证法：</p><p>​    证明：假设$x_n\rightarrow{a}同时x_n\rightarrow{b}$ ($a\neq{b}$),我们取$\varepsilon=\frac{b-a}{2}$（1）,</p><p>​    $于是：\exists{N_1},当n&gt;N_1下 |x_n-a|&lt;\frac{b-a}{2}$（2）</p><p>​    同时，又有$\exists{N_2},当n&gt;N_2下 |x_n-b|&lt;\frac{b-a}{2}$</p><p>​    这个时候，我们处理一下上面的式子：（展开我们的绝对值写成不等式）</p><p>​    此时由（1）得到的是：$x_n&lt;\frac{a+b}{2}$</p><p>​    由（2）得到的是：$x_n&gt;\frac{a+b}{2}$</p><p>​    毫无疑问这是矛盾的。所以，我们的极限不可以同时趋近于两个数。</p><p>​    （2）收敛数列一定有界。</p><p>​    证明：设$\lim\limits_{n\to+\infty}{x_n}=a$，此时此刻，我们可以随意的取一个$\varepsilon=1,\exists {N},当n&gt;N下，|x_n-a|&lt;1$</p><p>​    这个时候：</p><p>​    $    |x_n|=|x_n-a+a|\leqslant|x_n-a|+|a|&lt;1+|a|$</p><p>​        这显然符合有界的定义。但是呢？这是保证了$x&gt;N$的形况下，这个时候，我们只需要取出$M=max\{x_1,x_2,…x_N,1+|a|\}$（取出前N个里中最大的与1+$|a|$中还要大的那个，此时，M就是$\{x_n\}$下最大的一项了），这下子：$x_n\leqslant{M}$肯定有界了</p><p>（3）收敛数列具有保号性</p><p>​        这是什么意思呢？就是说：如果一个数列的极限为正（为负），那么，我们的数列在某一项之后肯定都是正的（负的）</p><p>​        数学的表达是这样的：</p><p>​        $\lim\limits_{n\to+\infty}{x_n}=a$,且$a&gt;0$，$\exists{N},$当$n&gt;N下,x_n&gt;0$</p><p>证明：</p><p>​        $a&gt;0$时，取$\varepsilon=\frac{a}{2}&gt;0,\exists{N},$当$n&gt;N$下,$|x_n-a|&lt;\frac{a}{2},$此后，我们的$0&lt;\frac{a}{2}&lt;x_n&lt;\frac{3a}{2}$</p><p>证毕。</p><p>​        反过来讲，如果数列从一项起都大于（小于）0，并且：$\lim\limits_{n\to+\infty}{x_n}=a$，那么：$a\geqslant0(\leqslant0)$</p><p>​    （4）收敛数列的任意子数列都收敛于同一极限</p><p>子数列：就是从原本的数列中抽取一些元素组成一个全新的数列。</p><p>$x_{n_k}$就是一种表示。</p><p>​        证明:</p><p>记：$\{x_{n_k}\}$是$\{x_{n}\}$的一个子数列，并且$\lim\limits_{n\to+\infty}{x_n}=a$</p><p>则$\forall \varepsilon&gt;0,\exists N&gt;0,n&gt;N下$</p><p>$|x_n-a|&lt;\varepsilon,这时，我们取K=N,k&gt;K时，n_k&gt;n_K=n_N\geqslant{N}$</p><p>${|x_{n_k}-a|}&lt;\varepsilon$</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145330449.png" alt=""></p><p>​        于是，我们又多了一种证明方式：如果一个数列中，存在两个子数列收敛于不同的极限，则我们说这个数列是发散。</p><p>补充：</p><p>​        反三角函数：三角函数的反函数时反三角函数。有如下的对应关系：</p><p>$sin(x)\rightarrow{arcsin(x)}$</p><p>$cos(x)\rightarrow{arccos(x)}$</p><p>$tan(x)\rightarrow{arctan(x)}$</p><p>​        实际上，就是$x=siny$的离谱写法我们看不惯，于是我们选择用一个全新的表达来表达一个全新的函数</p><p>​        图像上，回忆第一小节的笔记，图像关于$y=x$对称，做出来的图像就如下图所示：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145914221.png" alt="image-20221228145914221"></p><p>​        同时，为了保证是函数（还是第一小节的知识），截取我们的函数得到：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145933050.png" alt="image-20221228145933050"></p><p>​        于是：$x\in[-1,1],y\in[-\frac{\pi}{2},\frac{\pi}{2}]$</p><p>​        一些常见的函数值对应表：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228150223124.png" alt="image-20221228150223124"></p><p>其他的：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228150313511.png" alt="image-20221228150313511"></p><h5 id="（二）函数的极限"><a href="#（二）函数的极限" class="headerlink" title="（二）函数的极限"></a>（二）函数的极限</h5><p>​        1）$x\rightarrow{a}$下的函数极限</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.这一大长串，简记成如下：</p><p>法1）$\lim\limits_{x\rightarrow{x_0}}f(x)=A$</p><p>法2)$f(x)\rightarrow{A}(x\rightarrow{x_0})$</p><p>​        这定义还是很抽象：我们用人话讲：就是只要$x到{x_0}$是充分接近的，$f(x)$到$A$的距离可以为任意小。</p><p>​        但是，我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>下面我们就使用这个定义来证明一些命题：</p><p>$(1)\lim\limits_{x\rightarrow x_0}C=C$</p><p>证明：$\forall\varepsilon&gt;0,\exists\delta=N(N&gt;0)$</p><p>使得$0&lt;|x-x_0|&lt;\delta,|f(x)-A|=0,这明显小于\varepsilon$</p><p>证毕</p><p>$(2)\lim\limits_{x\rightarrow{1}}(2x-1)=1$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta=\frac{\varepsilon}{2}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=2|x-1|&lt;\varepsilon$</p><p>$(3)\lim\limits_{x\rightarrow{1}}\frac{x^2-1}{x-1}=2$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta={\varepsilon}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=|x-1|&lt;\varepsilon$</p><p>证毕</p><p>​        回到我刚刚讲到的：因为我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。为了方便描述，我们引入左，右极限的概念来描述从左侧右侧来逼近函数一点时产生的极限</p><p>左极限:$\lim\limits_{x\rightarrow{x_0^-}}f(x)=A$</p><p>右极限:$\lim\limits_{x\rightarrow{x_0^+}}f(x)=A$</p><p>那么，回到这个定义：</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.</p><p>​    其中$x$怎么趋近的方式是已经确定的，于是上面的$|x-x_0|$就可以拆成$x-x_0$或者是$x_0-x$了</p><p>那么，我们再次阐述：</p><p>​        我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>这个定理：$x\rightarrow{x_0}$,$f(x)$的极限存在$\Leftrightarrow$ 左右极限存在且相等</p><p>比如说</p><p>$\begin{equation}f(x)=\left\{\begin{array}{cl}x+1 &amp;  x &gt; 0 \\0  &amp;  x = 0 \\x-1 &amp;  x &lt; 0 \\\end{array} \right.\end{equation}$</p><p>$\lim\limits_{x\rightarrow{0^-}}f(x)=-1$</p><p>$\lim\limits_{x\rightarrow{0^+}}f(x)=1$</p><p>两者不相等，于是$f(x)$在0处的极限是不存在的。</p><p>​        2）$x\rightarrow{\infty}$下的函数极限</p><p>​        假设啊，我们的函数在无穷远处有定义的：这个时候，我们的$x$越远，我们的函数值越是接近某一个数。用数学语言表达是这样的：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X&gt;0,\mbox{使得}|x|&gt;X时，|f(x)-A|&lt;\varepsilon$</p><p>此时，我们简记作$\lim\limits_{x\rightarrow{\infty}}=A$</p><p>例题：</p><p>​        $(1)\lim\limits_{x\rightarrow{\infty}}{\frac{1}{x}=0}$</p><p>证明：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X=\frac{1}{\varepsilon},\mbox{使得}|x|&gt;X时，|\frac{1}{x}|&lt;\varepsilon$</p><p>证明完毕</p><p>​        </p><p>​        说完了，让我们谈谈性质</p><p>​        1)函数的极限唯一性</p><p>​        2)函数的局部有界限：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\exists{M&gt;0},\forall{\delta&gt;0},0&lt;|x-x_0|&lt;\delta时，|f(x)|\leqslant{M}$</p><p>​        3)局部保号性：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,A&gt;0,\exists{\delta&gt;0}则在0&lt;|x-x_0|&lt;\delta,f(x)&gt;0$</p><p>​        4）$Henn$定理：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\{x_n\}\rightarrow{x_0},\lim\limits_{n\rightarrow{\infty}}f(x_n)=\lim\limits_{x\rightarrow{x_0}}f(x)$</p><h6 id="无穷小和无穷大"><a href="#无穷小和无穷大" class="headerlink" title="无穷小和无穷大"></a>无穷小和无穷大</h6><p>​        无穷小：趋于0的一个量（动态的！），是正是负和0都叫无穷小。同时，无穷小除了0意外，无穷小都不确定。具体的定义是这样的：</p><p>​        定义：$x\rightarrow{x_0}(x\rightarrow{\infty})$时，$f(x)$ 的极限为0，称$f(x)$是当$x\rightarrow{x_0}(x\rightarrow{\infty})$下的无穷小</p><p>​        这么说来，无穷小并不唯一，有无穷多个无穷小</p><p>下面介绍以下无穷小的一些性质:</p><p>​        定义$a,b$是两个无穷小</p><p>​        $a+b$是一个无穷小；</p><p>​        $a-b$是一个无穷小;</p><p>​        $a\times b$是一个无穷小;</p><p>​        $c\times{a}$是一个无穷小;</p><p>​        注意！！！$a\div{b}$是未定式，在没有给定a,b的具体情况，我们是不知道这个值究竟是多少的！它本身可以是任何数！！！</p><p>​        无穷大：这个有特定的符号：$\infty$</p><p>​        他也是有定义的：$\lim\limits_{ {x\rightarrow{x_0} } }f(x)= \infty$或者$\lim\limits_{ {x\rightarrow{\infty} } }f(x)=\infty$</p><p>​        注意！！！注意！！！无穷大可以是正无穷大或者是负无穷大！！！于是</p><p>​        引入两个无穷大记作$a,b$</p><p>​        无论是$a+b还是a-b$都是未定义的</p><p>​        但是$a\times{b}$一定是无穷大，$c\times{ \infty }(c\neq{ 0 })$一定是无穷大</p><p>​        $a\div{ b }$结果未知</p><p>​        定理：$f(x)$如果是无穷大，那么$\frac{1}{f(x)}$是无穷小。</p><p>​        $f(x)$如果是无穷小，那么$\frac{1}{f(x)}$是无穷大。（$f(x)\neq{0}$）</p><p>​        极限运算法则</p><p>​        法则1：两个甚至是若干有限个的无穷小的和是无穷小的</p><p>​        <strong>法则2：有界函数与无穷小的乘积是无穷小</strong></p><p>​        推论：常数乘以无穷小还是无穷小</p><p>​                    有限个无穷小的乘积还是无穷小</p><p>​        定理：记：$\lim{f(x)}=A,\lim{g(x)}=B$</p><p>​        1)$\lim{f(x)\pm{g(x)}}=A\pm{B}$</p><p>​        2)$\lim{f(x)\times{g(x)}}=A\times{B}$</p><p>​        3)$\lim{\frac{f(x)}{g(x)}}=\frac{A}{B}(B\neq{0})$</p><p>​        4)$\lim{cf(x)}=c\lim{f(x)}$</p><p>​        5)$\lim{ {f(x)}^n}=[{\lim{f(x) } }]^n$</p><p>对于数列还是一样的</p><p>​        定理:$\psi(x)\geqslant\varphi(x)$,$\lim{\psi(x)}&gt;\lim{\varphi(x)}$</p><p>哎，这后面这么没有等号了呢?举个例子:$\frac{1}{x}$,$-\frac{1}{x}$</p><h5 id="极限存在准则，两个重要极限"><a href="#极限存在准则，两个重要极限" class="headerlink" title="极限存在准则，两个重要极限"></a>极限存在准则，两个重要极限</h5><p>准则I：对于数列$\{x_n\},\{y_n\}$,${z_n}$ (1)$\exists {n_0}\in{N},y_n\leqslant{x_n}\leqslant{z_n}$(2)$\lim{y_n}=lim{z_n}=a$那么：$\lim{x_n}=a$</p><p>准则I’ :对于函数f(x),g(x),h(x),且(1)$g(x)\leqslant{f(x)}\leqslant{h(x)}$(2)$\lim{g(x)}=\lim{h(x)}=A$那么：$lim{f(x)}=A$</p><p>两个重要极限：</p><h6 id="I-lim-limits-x-rightarrow-0-frac-sin-x-x-1"><a href="#I-lim-limits-x-rightarrow-0-frac-sin-x-x-1" class="headerlink" title="I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$"></a>I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$</h6><p>注意一定是$x\rightarrow{0}$！！！</p><p>同时！！！也可以有推广：</p><h6 id="I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1"><a href="#I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1" class="headerlink" title="I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$"></a>I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$</h6><p>其他派生的极限：</p><p>$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=1$</p><p>这是因为：$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=\lim\limits_{x\rightarrow{0}}(\frac{\sin{x}}{x})\times(\frac{1}{\cos{x}})$=1</p><p>例题：$\lim\limits_{x\rightarrow{0}}\frac{1-\cos{x}}{x^2}$</p><p>解：<img src="C:\Users\陈冠豪\Desktop\image-20221229164852173.png" alt="image-20221229164852173"></p><p>等价无穷小：（I派生）</p><p>$\sin{x}\backsim{x}$ , $\tan{x}\backsim{x}$, $\arcsin{x}\backsim{x}$</p><h4 id="准则II：单调有界数列必有极限！"><a href="#准则II：单调有界数列必有极限！" class="headerlink" title="准则II：单调有界数列必有极限！"></a>准则II：单调有界数列必有极限！</h4><p>性质：收敛必有界，而有界不一定收敛</p><p>为什么有界不一定收敛呢？举个反例：$\{(-1)^{N}\}$就可以了，这个数列显然有界：</p><p>II:$\lim\limits_{x\rightarrow{\infty}}(1+\frac{1}{x})^{x}=e$</p><p>注意$x$一定是趋于无穷！！！</p><p>派生的还有。。。</p><p>II’$\lim\limits_{\Box\rightarrow{\infty}}(1+\frac{1}{\Box})^{\Box}=e$</p><p>II’’$\lim\limits_{x\rightarrow{0}}(1+{x})^\frac{1}{x}=e$</p><p>补充：Cauchy极限审敛法：</p><p>$\{x_n\}收敛\Leftrightarrow \forall{\varepsilon&gt;0},\exists N,当m&gt;N时，|x_n-x_m|&lt;\varepsilon$</p><p>无穷小的比较：</p><p>​        不同无穷小趋于0的速度不一样，我们比较无穷小就是比较不同无穷小趋于0的速度：</p><p>方法是简单的，看他们的商的极限即可：</p><p>如：$\lim\limits_{x\rightarrow{0}}x=0,\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$,而$\lim\limits_{x\rightarrow{0}}\frac{x}{\sqrt{x}}=\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$</p><p>于是：我们发现这个极限为0，说明在趋近速度上$x&gt;\sqrt{x}$</p><p>这样，我们就比较出来了</p><p>定义：</p><p>$若\lim\frac{\beta}{\alpha}=0,则称\beta是\alpha的高阶无穷小，记作\beta=o(\alpha)$</p><p>$若\lim\frac{\beta}{\alpha}=\infty,则称\beta是\alpha的低阶无穷小$</p><p>$若\lim\frac{\beta}{\alpha}=c(c\neq{0}),则称\beta是\alpha的同阶无穷小,特别的，当c=1时，又称等价无穷小,记作{\beta}\backsim{\alpha}$</p><p>$若\lim\frac{\beta}{\alpha^k}=c(c\neq{0}),则称\beta是\alpha的k阶无穷小$</p><p>下面是一些常见的等价无穷小：</p><p>1)$x\rightarrow{0}时，\sqrt[n]{1+x}-1\backsim\frac{x}{n},\sin(x)\sim{x}$</p><p>定理：</p><p>1）$\beta于\alpha等价\Leftrightarrow \beta=\alpha+o(\alpha)$</p><p>2)$\alpha\sim\widetilde{\alpha},\beta\sim\widetilde{\beta},且\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}是存在的，则:\lim\frac {\alpha}{\beta}=\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}$</p><p>于是：</p><p>2)$\tan{x}\sim{x},\arcsin{x}\sim{x}$</p><p>上面的$x$都可以被替换成$\Box$</p><p>定理：</p><p>1）两个无穷小相比的极限时，分子分母可以用等价无穷小替换</p><p>2）如果分子或分母是若干因子的乘积，则我们可以对其中一个或者几个无穷小做替换，但是因子用加减法是不可以的！！！！！！！！！！！！！！！！</p><h4 id="函数的连续性"><a href="#函数的连续性" class="headerlink" title="函数的连续性"></a>函数的连续性</h4><p>对于函数增量的定义：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221229174949222.png" alt="image-20221229174949222"></p><p>则增量$\Delta f(x)=f(x+\Delta{x})-f(x)$</p><p>实际上，叫做改变量更切合实际，因为函数也可以递减</p><p>那么，连续的定义由此引出：</p><p>若$\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=\lim\limits_{\Delta{x}\rightarrow{0}}(f(x_0+\Delta{x})-f(x_0))=0$时，则函数在$x_0$处连续</p><p>或者</p><p>$\lim\limits_{x\rightarrow{x_0}}f(x)=f(x_0)$时，则函数在$x_0$处连续</p><p>总结而言，一个函数若是想在$x_0$ 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！</p><p>既然有左右极限，于是也使得函数也有左右连续。函数的左右极限就是由$x$以不同的方向逼近产生的。</p><p>左连续：$\lim\limits_{x\rightarrow{x_0^-}}f(x)=f(x_0)$</p><p>右连续：$\lim\limits_{x\rightarrow{x_0^+}}f(x)=f(x_0)$</p><p>类似的：函数的连续的充要条件是函数即左连续又右连续。</p><h4 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h4><p>回到连续需要满足的条件：</p><p>一个函数若是想在x_0 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！于是，间断点也就有三种产生原因：</p><p>1)在$x_0$无定义</p><p>2)$\lim\limits_{x\rightarrow{x_0}}f(x)$不存在</p><p>3）$\lim\limits_{x\rightarrow{x_0}}f(x)\neq{f(x_0)}$</p><p>举例子：</p><p>1)$y=\tan{x}在x=\frac{\pi}{2}$处无定义，所以在这一点上不连续这是可去间断点.</p><p>2)$y=\sin{\frac{1}{x}}$在x=0处极限不存在，所以在这一点上不连续.</p><p>3）</p><script type="math/tex; mode=display">\begin{equation}f(x)=\left\{\begin{array}{cl}\frac{x^2-1}{x-1} &  x \neq 0 \\0  & x = 0 \\\end{array} \right.\end{equation}</script><p>，这个函数在x=1处不连续。这个间断点叫跳跃间断点</p><p>间断点有两类：</p><p>第一类：左右极限都存在</p><p>有可去间断点，跳跃间断点</p><p>第二类：左右极限不都存在</p><p>有震荡间断点</p><p>连续函数的性质：</p><p>对于$[a,b]$上，且$f(a)f(b)&lt;0$时，则其中至少存在一个点$\xi \in[a,b]，$使得$f(\xi)=0$</p><p>推广：</p><p>定理：$f(x)在[a,b]$上连续,$f(a)=A,f(b)=B$,则$\exists C\in[A ,B]$,至少有一个$\xi \in [a,b]$使得，$f(\xi)=C$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C简单教程（1）</title>
      <link href="/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简单C教程1"><a href="#简单C教程1" class="headerlink" title="简单C教程1"></a>简单C教程1</h1><p>​        首先打开你的VS，或者是已经配置好GCC和相关插件的Vscode,亦或者Dev C++这个东西，以及切换到英文输入法！！！！！！！！！！！！小心中文的分号给你小小的计算机震撼</p><p>​        我们首先明确：C语言是一个人和计算机交流的语言。语言既然有发展的历史，那么，计算机语言也有发展的过程</p><p>​        最开始的时候：我们使用0，1来代表正电负电，后来用助记符 ，而后有用更高级的语言表达一些固定的助记符。C语言由此诞生。</p><p>​        C语言也有标准：C89/C90是我们这个时候学习的主力。</p><h3 id="My-Fisrt-C-Project"><a href="#My-Fisrt-C-Project" class="headerlink" title="My Fisrt C Project"></a>My Fisrt C Project</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression"><span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h</span><span class="token comment">//1</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//2</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//3</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        //1:首先，我们首先引入头文件stdio.h，这个文件里包含了我们以后要使用的函数，我需要把他们包含进来才可以使用，否则编译器不认识他们。</p><p>​        //2:接着，main是主函数的意思，这是我们程序的入口：只能有一个main函数不可以有第二个，更不可以没有main函数，int是integer的缩写，表明的是整形。这个表达的是这个函数返回的是一个整形。这个函数负责完成任务</p><p>​        //3：返回0：这是因为函数需要返回东西，我们返回0表达的是成功完成任务</p><p>​        //4：printf:print formatly标准的打印，里面放进去的是一个字符串”hello world\n”,\n是一个换行符</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><div class="table-container"><table><thead><tr><th style="text-align:left">char</th><th>short</th><th>long</th><th>int</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">long long</td><td>float</td><td>double</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>​    数据类型有上面这几种，生活中无非就是小数，整数。上面就是引申出来的七种类型</p><p>1.char类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;char ch&#x3D;&#39;A&#39;;&#x2F;&#x2F;存放一个字符，我们起了一个名字ch，里面放了一个A    printf(&quot;%c&quot;,ch);&#x2F;&#x2F;使用%c来输出一个字符变量的内容，函数以这样的方式取出一个字符    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.int类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;int stdint&#x3D;114514;&#x2F;&#x2F;存储一个整形，我们起了一个名字叫stdint，里面放了一个114514printf(&quot;%d&quot;,stdint);&#x2F;&#x2F;使用%d来输出一个整形变量的内容，函数以这样的方式取出一个整形return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.long, long long（C99）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;long stdint&#x3D;114514;&#x2F;&#x2F;存储一个长整形，我们起了一个名字叫stdint，里面放了一个114514printf(&quot;%ld&quot;,stdint);&#x2F;&#x2F;使用%ld来输出一个长整形变量的内容，函数以这样的方式取出一个长整形return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.float，double</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;float stdflt&#x3D;114514.1919810;&#x2F;&#x2F;存储一个浮点型，我们起了一个名字叫stdflt，里面放了一个114514.1919810printf(&quot;%f&quot;,stdflt);&#x2F;&#x2F;使用%f来输出一个浮点型变量的内容，函数以这样的方式取出一个浮点型    double stddbl&#x3D;114514.1919810;&#x2F;&#x2F;存储一个双精度浮点型，我们起了一个名字叫stddbl，里面放了一个114514.1919810    printf(&quot;%lf&quot;,stddbl);&#x2F;&#x2F;使用%lf来输出一个双精度浮点型变量的内容，函数以这样的方式取出一个双精度浮点型return 0;&#125;&#x2F;&#x2F;打印还有其他方式访问：%p声明打印地址，%x以十六进制的方式打印，%o以八进制的方式打印<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        问题来了，为什么整这么多花里胡哨的东西呢？一个不香吗？</p><p>​        首先我们区分他们在计算机在内存中占用的内存。使用一个运算符叫做sizeof(),我们的括号里面放的就是类型。大伙看一看，有什么区别</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    printf(&quot;%d\n&quot;,sizeof(char));&#x2F;&#x2F;char申请内存的大小    printf(&quot;%d\n&quot;,sizeof(short));&#x2F;&#x2F;short申请内存的大小    printf(&quot;%d\n&quot;,sizeof(int));&#x2F;&#x2F;int申请内存的大小    printf(&quot;%d\n&quot;,sizeof(long));&#x2F;&#x2F;long申请内存的大小    printf(&quot;%d\n&quot;,sizeof(float));&#x2F;&#x2F;float申请内存的大小    printf(&quot;%d\n&quot;,sizeof(double));&#x2F;&#x2F;double申请内存的大小&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230129173130931.png" alt="image-20230129173130931"></p><p>​        等等，我们是得到了数，单位是什么呢？字节（byte）。下面插一个小科普：计算机的单位有以下几个层级：</p><p>​        bit                    byte            kb            mb            gb            tb            pb </p><p>​        计算机力最小的单位是怎么定义的呢？</p><p>​        计算机通电工作，这些硬件下通过的电流分为正电和负电，分别代表0和1。（高低电平）这就是2进制的来源，我们用一系列的0和1来表达数据或者物体的状态。1个比特位就可以存储一个0或者是1，8个比特位构成一个字节，随后k,m,g,t,p的进位关系是1024倍数的关系。就是说：一个char的大小是8个比特位，一个int由32个比特位构成。我们的这些类型就是为了更加方便和丰富的表达生活的类型，所以才产生的。</p><h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p>​        我们针对数据变不变来区分出来数据是常量还是变量。</p><p>​        比如说：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int age&#x3D;10;&#x2F;&#x2F;向内存申请4个字节存放一个20，而这个字节表达的含义是age<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个age是可以变动的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int age&#x3D;10;printf(&quot;%d\n&quot;,age);age&#x3D;20;printf(&quot;%d\n&quot;,age);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的代码打出来了10和20 。</p><p>​        定义变量的方法是这样的：</p><pre class="line-numbers language-none"><code class="language-none">类型 变量名 &#x3D; 值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        变量自身也有分类：局部变量和全局变量，区别又是什么呢？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int num1&#x3D;20;int main()&#123;    int num2&#x3D;10;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不难猜到：num1是全局变量，num2是局部变量。全局变量指的是定义在代码块{ }之外的变量。反之，在{ }内的是全局变量。问题来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int global &#x3D;2023;int main()&#123;    int local&#x3D;2022;    &#x2F;&#x2F;?So what about the next line?int global&#x3D;2022;    printf(&quot;global here is %d\n&quot;,global);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         当你在VS2022一敲出来，高亮颜色就告诉你，答案是2022：</p><p>​        <img src="image-20230129180112913.png" alt="image-20230129180112913"></p><p>​        能同时共存，而且：<strong>局部变量优先</strong> 这里给出建议：</p><p>​        <strong>打代码的时候不要使用同名的局部变量和全局变量，如果相同了，记住一件事情：局部变量优先！</strong></p><p>​        下面我们继续玩一个新的函数：scanf函数。</p><p>​        我说停停！！！先别函数玩的欢乐，这是因为在新标准下，C标准委员会嫌这东西不安全（为什么不安全这里先不扯，简单来讲就是这个函数读到什么东西就往里塞，实在读不进去就直接扔回一个-1摆烂，导致程序安全性很差）, 所以整了一个船新函数scanf_s ,这个函数我的评价是VS用用行，但是移植到别的编译器还要切换标准，怎么办呢？在VS编译器下面使用一个宏定义#define _CRT_SECURE_NO_WARNINGS 1 让编译器赶紧闭嘴通过就完事，这个宏（可以先不追究这是什么东西）扔到程序的最前面就可以了</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Example#define _CRT_SECURE_NO_WARNINGS 1&#x2F;&#x2F;Looking here#include&lt;stdio.h&gt;int global &#x3D; 2023;int main()&#123;    int local &#x3D; 2022;    &#x2F;&#x2F;?So what about the next line?    int global &#x3D; 2022;    printf(&quot;global here is %d\n&quot;, global);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个函数读取键盘的输入，使用方法如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;A basic program that reads two numbers then returns the sum of themint num1&#x3D;0;int num2&#x3D;0;scanf(&quot;%d%d&quot;,&amp;num1,&amp;num2);&#x2F;&#x2F;字符串里面不要塞上空格！不要塞上空格int sum&#x3D;num1+num2;printf(&quot;%d&quot;,sum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对了，这个&amp;是什么捏？取地址符号，后面我们提到指针的时候我们会天天见到他。人话就是这样讲：告诉这个函数，这两个变量在计算机的哪里。</p><p>​        认真的讲，计算机有巨大的内存，那么多数据，我们的计算机怎么哪里是哪里？使用地址，就像你们家的门牌号一样。</p><p>​        变量也有作用域：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int global&#x3D;10;int main()&#123;    int numlevel1&#x3D;10;    &#123;        int numlevel2&#x3D;20;    &#125;    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel1);    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你的编译器很快（也很不幸的）告诉你，我不到numlevel2是什么啊。那就对了，因为每个变量都有它的作用域：范围就是从他定义的位置到当前它在的大括号区域}结束处：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int global&#x3D;10;int main()&#123;printf(&quot;%d&quot;,numlevel1);&#x2F;&#x2F;NOOOO,变量还没被声明，不要用:(    int numlevel1&#x3D;10;&#x2F;&#x2F;----init numlevel1    &#123;       int numlevel2&#x3D;20;&#x2F;&#x2F;----init numlevel2    &#125;&#x2F;&#x2F;----destroy numlevel2 Sadly    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel1);   &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel2);&#125;&#x2F;&#x2F;----destroy numlevel1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的图就表示了程序变量的生命周期或者说作用域：创建完之后到被回收之前，变量才是被允许使用的。所以，当你的编译器不知道你想要使用的变量的时候，他会指出错误：未声明的标识符。这个时候回去看看你的代码哪里出现了问题⑧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
